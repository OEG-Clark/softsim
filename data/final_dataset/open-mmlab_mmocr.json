{"home.repos.pwc.inspect_result.open-mmlab_mmocr.None.setup.readme": [[9, 13], ["open", "f.read"], "function", ["None"], ["def", "readme", "(", ")", ":", "\n", "    ", "with", "open", "(", "'README.md'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "return", "content", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.None.setup.add_mim_extension": [[19, 77], ["os.dirname", "os.join", "os.makedirs", "os.makedirs", "os.exists", "os.join", "os.join", "os.isfile", "os.islink", "os.remove", "os.remove", "os.isdir", "os.relpath", "os.isfile", "ValueError", "shutil.rmtree", "os.dirname", "os.symlink", "os.symlink", "shutil.copyfile", "os.isdir", "warnings.warn", "shutil.copytree", "warnings.warn"], "function", ["None"], ["def", "add_mim_extension", "(", ")", ":", "\n", "    ", "\"\"\"Add extra files that are required to support MIM into the package.\n\n    These files will be added by creating a symlink to the originals if the\n    package is installed in `editable` mode (e.g. pip install -e .), or by\n    copying from the originals otherwise.\n    \"\"\"", "\n", "\n", "# parse installment mode", "\n", "if", "'develop'", "in", "sys", ".", "argv", ":", "\n", "# installed by `pip install -e .`", "\n", "        ", "mode", "=", "'symlink'", "\n", "", "elif", "'sdist'", "in", "sys", ".", "argv", "or", "'bdist_wheel'", "in", "sys", ".", "argv", ":", "\n", "# installed by `pip install .`", "\n", "# or create source distribution by `python setup.py sdist`", "\n", "        ", "mode", "=", "'copy'", "\n", "", "else", ":", "\n", "        ", "return", "\n", "\n", "", "filenames", "=", "[", "'tools'", ",", "'configs'", ",", "'model-index.yml'", "]", "\n", "repo_path", "=", "osp", ".", "dirname", "(", "__file__", ")", "\n", "mim_path", "=", "osp", ".", "join", "(", "repo_path", ",", "'mmocr'", ",", "'.mim'", ")", "\n", "os", ".", "makedirs", "(", "mim_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "for", "filename", "in", "filenames", ":", "\n", "        ", "if", "osp", ".", "exists", "(", "filename", ")", ":", "\n", "            ", "src_path", "=", "osp", ".", "join", "(", "repo_path", ",", "filename", ")", "\n", "tar_path", "=", "osp", ".", "join", "(", "mim_path", ",", "filename", ")", "\n", "\n", "if", "osp", ".", "isfile", "(", "tar_path", ")", "or", "osp", ".", "islink", "(", "tar_path", ")", ":", "\n", "                ", "os", ".", "remove", "(", "tar_path", ")", "\n", "", "elif", "osp", ".", "isdir", "(", "tar_path", ")", ":", "\n", "                ", "shutil", ".", "rmtree", "(", "tar_path", ")", "\n", "\n", "", "if", "mode", "==", "'symlink'", ":", "\n", "                ", "src_relpath", "=", "osp", ".", "relpath", "(", "src_path", ",", "osp", ".", "dirname", "(", "tar_path", ")", ")", "\n", "try", ":", "\n", "                    ", "os", ".", "symlink", "(", "src_relpath", ",", "tar_path", ")", "\n", "", "except", "OSError", ":", "\n", "# Creating a symbolic link on windows may raise an", "\n", "# `OSError: [WinError 1314]` due to privilege. If", "\n", "# the error happens, the src file will be copied", "\n", "                    ", "mode", "=", "'copy'", "\n", "warnings", ".", "warn", "(", "\n", "f'Failed to create a symbolic link for {src_relpath}, '", "\n", "f'and it will be copied to {tar_path}'", ")", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "\n", "", "", "if", "mode", "==", "'copy'", ":", "\n", "                ", "if", "osp", ".", "isfile", "(", "src_path", ")", ":", "\n", "                    ", "shutil", ".", "copyfile", "(", "src_path", ",", "tar_path", ")", "\n", "", "elif", "osp", ".", "isdir", "(", "src_path", ")", ":", "\n", "                    ", "shutil", ".", "copytree", "(", "src_path", ",", "tar_path", ")", "\n", "", "else", ":", "\n", "                    ", "warnings", ".", "warn", "(", "f'Cannot copy file {src_path}.'", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f'Invalid mode {mode}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.None.setup.get_version": [[79, 89], ["open", "exec", "compile", "locals", "locals", "f.read"], "function", ["None"], ["", "", "", "", "def", "get_version", "(", ")", ":", "\n", "    ", "with", "open", "(", "version_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "exec", "(", "compile", "(", "f", ".", "read", "(", ")", ",", "version_file", ",", "'exec'", ")", ")", "\n", "", "import", "sys", "\n", "\n", "# return short version for sdist", "\n", "if", "'sdist'", "in", "sys", ".", "argv", "or", "'bdist_wheel'", "in", "sys", ".", "argv", ":", "\n", "        ", "return", "locals", "(", ")", "[", "'short_version'", "]", "\n", "", "else", ":", "\n", "        ", "return", "locals", "(", ")", "[", "'__version__'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.None.setup.parse_requirements": [[91, 163], ["list", "line.strip.startswith", "exists", "setup.parse_requirements.gen_packages_items"], "function", ["None"], ["", "", "def", "parse_requirements", "(", "fname", "=", "'requirements.txt'", ",", "with_version", "=", "True", ")", ":", "\n", "    ", "\"\"\"Parse the package dependencies listed in a requirements file but strip\n    specific version information.\n\n    Args:\n        fname (str): Path to requirements file.\n        with_version (bool, default=False): If True, include version specs.\n    Returns:\n        info (list[str]): List of requirements items.\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n    \"\"\"", "\n", "import", "re", "\n", "import", "sys", "\n", "from", "os", ".", "path", "import", "exists", "\n", "require_fpath", "=", "fname", "\n", "\n", "def", "parse_line", "(", "line", ")", ":", "\n", "        ", "\"\"\"Parse information from a line in a requirements text file.\"\"\"", "\n", "if", "line", ".", "startswith", "(", "'-r '", ")", ":", "\n", "# Allow specifying requirements in other files", "\n", "            ", "target", "=", "line", ".", "split", "(", "' '", ")", "[", "1", "]", "\n", "for", "info", "in", "parse_require_file", "(", "target", ")", ":", "\n", "                ", "yield", "info", "\n", "", "", "else", ":", "\n", "            ", "info", "=", "{", "'line'", ":", "line", "}", "\n", "if", "line", ".", "startswith", "(", "'-e '", ")", ":", "\n", "                ", "info", "[", "'package'", "]", "=", "line", ".", "split", "(", "'#egg='", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "# Remove versioning from the package", "\n", "                ", "pat", "=", "'('", "+", "'|'", ".", "join", "(", "[", "'>='", ",", "'=='", ",", "'>'", "]", ")", "+", "')'", "\n", "parts", "=", "re", ".", "split", "(", "pat", ",", "line", ",", "maxsplit", "=", "1", ")", "\n", "parts", "=", "[", "p", ".", "strip", "(", ")", "for", "p", "in", "parts", "]", "\n", "\n", "info", "[", "'package'", "]", "=", "parts", "[", "0", "]", "\n", "if", "len", "(", "parts", ")", ">", "1", ":", "\n", "                    ", "op", ",", "rest", "=", "parts", "[", "1", ":", "]", "\n", "if", "';'", "in", "rest", ":", "\n", "# Handle platform specific dependencies", "\n", "# http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies", "\n", "                        ", "version", ",", "platform_deps", "=", "map", "(", "str", ".", "strip", ",", "\n", "rest", ".", "split", "(", "';'", ")", ")", "\n", "info", "[", "'platform_deps'", "]", "=", "platform_deps", "\n", "", "else", ":", "\n", "                        ", "version", "=", "rest", "# NOQA", "\n", "", "info", "[", "'version'", "]", "=", "(", "op", ",", "version", ")", "\n", "", "", "yield", "info", "\n", "\n", "", "", "def", "parse_require_file", "(", "fpath", ")", ":", "\n", "        ", "with", "open", "(", "fpath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "and", "not", "line", ".", "startswith", "(", "'#'", ")", ":", "\n", "                    ", "for", "info", "in", "parse_line", "(", "line", ")", ":", "\n", "                        ", "yield", "info", "\n", "\n", "", "", "", "", "", "def", "gen_packages_items", "(", ")", ":", "\n", "        ", "if", "exists", "(", "require_fpath", ")", ":", "\n", "            ", "for", "info", "in", "parse_require_file", "(", "require_fpath", ")", ":", "\n", "                ", "parts", "=", "[", "info", "[", "'package'", "]", "]", "\n", "if", "with_version", "and", "'version'", "in", "info", ":", "\n", "                    ", "parts", ".", "extend", "(", "info", "[", "'version'", "]", ")", "\n", "", "if", "not", "sys", ".", "version", ".", "startswith", "(", "'3.4'", ")", ":", "\n", "# apparently package_deps are broken in 3.4", "\n", "                    ", "platform_deps", "=", "info", ".", "get", "(", "'platform_deps'", ")", "\n", "if", "platform_deps", "is", "not", "None", ":", "\n", "                        ", "parts", ".", "append", "(", "';'", "+", "platform_deps", ")", "\n", "", "", "item", "=", "''", ".", "join", "(", "parts", ")", "\n", "yield", "item", "\n", "\n", "", "", "", "packages", "=", "list", "(", "gen_packages_items", "(", ")", ")", "\n", "return", "packages", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version": [[11, 47], ["packaging.version.parse", "list", "tuple", "len", "list.extend", "list.extend", "list.extend", "list.extend", "warnings.warn", "len", "mmcv.__version__", "mmdet.__version__"], "function", ["None"], ["def", "digit_version", "(", "version_str", ":", "str", ",", "length", ":", "int", "=", "4", ")", ":", "\n", "    ", "\"\"\"Convert a version string into a tuple of integers.\n\n    This method is usually used for comparing two versions. For pre-release\n    versions: alpha < beta < rc.\n    Args:\n        version_str (str): The version string.\n        length (int): The maximum number of version levels. Default: 4.\n    Returns:\n        tuple[int]: The version info in digits (integers).\n    \"\"\"", "\n", "version", "=", "parse", "(", "version_str", ")", "\n", "assert", "version", ".", "release", ",", "f'failed to parse version {version_str}'", "\n", "release", "=", "list", "(", "version", ".", "release", ")", "\n", "release", "=", "release", "[", ":", "length", "]", "\n", "if", "len", "(", "release", ")", "<", "length", ":", "\n", "        ", "release", "=", "release", "+", "[", "0", "]", "*", "(", "length", "-", "len", "(", "release", ")", ")", "\n", "", "if", "version", ".", "is_prerelease", ":", "\n", "        ", "mapping", "=", "{", "'a'", ":", "-", "3", ",", "'b'", ":", "-", "2", ",", "'rc'", ":", "-", "1", "}", "\n", "val", "=", "-", "4", "\n", "# version.pre can be None", "\n", "if", "version", ".", "pre", ":", "\n", "            ", "if", "version", ".", "pre", "[", "0", "]", "not", "in", "mapping", ":", "\n", "                ", "warnings", ".", "warn", "(", "f'unknown prerelease version {version.pre[0]}, '", "\n", "'version checking may go wrong'", ")", "\n", "", "else", ":", "\n", "                ", "val", "=", "mapping", "[", "version", ".", "pre", "[", "0", "]", "]", "\n", "", "release", ".", "extend", "(", "[", "val", ",", "version", ".", "pre", "[", "-", "1", "]", "]", ")", "\n", "", "else", ":", "\n", "            ", "release", ".", "extend", "(", "[", "val", ",", "0", "]", ")", "\n", "\n", "", "", "elif", "version", ".", "is_postrelease", ":", "\n", "        ", "release", ".", "extend", "(", "[", "1", ",", "version", ".", "post", "]", ")", "\n", "", "else", ":", "\n", "        ", "release", ".", "extend", "(", "[", "0", ",", "0", "]", ")", "\n", "", "return", "tuple", "(", "release", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist": [[4, 22], ["isinstance", "len", "check_argument.is_2dlist"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["def", "is_3dlist", "(", "x", ")", ":", "\n", "    ", "\"\"\"check x is 3d-list([[[1], []]]) or 2d empty list([[], []]) or 1d empty\n    list([]).\n\n    Notice:\n        The reason that it contains 1d or 2d empty list is because\n        some arguments from gt annotation file or model prediction\n        may be empty, but usually, it should be 3d-list.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "        ", "return", "False", "\n", "", "if", "len", "(", "x", ")", "==", "0", ":", "\n", "        ", "return", "True", "\n", "", "for", "sub_x", "in", "x", ":", "\n", "        ", "if", "not", "is_2dlist", "(", "sub_x", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist": [[24, 38], ["all", "isinstance", "len", "isinstance"], "function", ["None"], ["", "def", "is_2dlist", "(", "x", ")", ":", "\n", "    ", "\"\"\"check x is 2d-list([[1], []]) or 1d empty list([]).\n\n    Notice:\n        The reason that it contains 1d empty list is because\n        some arguments from gt annotation file or model prediction\n        may be empty, but usually, it should be 2d-list.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "        ", "return", "False", "\n", "", "if", "len", "(", "x", ")", "==", "0", ":", "\n", "        ", "return", "True", "\n", "\n", "", "return", "all", "(", "isinstance", "(", "item", ",", "list", ")", "for", "item", "in", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list": [[40, 46], ["all", "isinstance", "isinstance"], "function", ["None"], ["", "def", "is_type_list", "(", "x", ",", "type", ")", ":", "\n", "\n", "    ", "if", "not", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "return", "all", "(", "isinstance", "(", "item", ",", "type", ")", "for", "item", "in", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type": [[48, 51], ["isinstance"], "function", ["None"], ["", "def", "is_none_or_type", "(", "x", ",", "type", ")", ":", "\n", "\n", "    ", "return", "isinstance", "(", "x", ",", "type", ")", "or", "x", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.equal_len": [[53, 61], ["len", "len", "len"], "function", ["None"], ["", "def", "equal_len", "(", "*", "argv", ")", ":", "\n", "    ", "assert", "len", "(", "argv", ")", ">", "0", "\n", "\n", "num_arg", "=", "len", "(", "argv", "[", "0", "]", ")", "\n", "for", "arg", "in", "argv", ":", "\n", "        ", "if", "len", "(", "arg", ")", "!=", "num_arg", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary": [[63, 73], ["len"], "function", ["None"], ["", "def", "valid_boundary", "(", "x", ",", "with_score", "=", "True", ")", ":", "\n", "    ", "num", "=", "len", "(", "x", ")", "\n", "if", "num", "<", "8", ":", "\n", "        ", "return", "False", "\n", "", "if", "num", "%", "2", "==", "0", "and", "(", "not", "with_score", ")", ":", "\n", "        ", "return", "True", "\n", "", "if", "num", "%", "2", "==", "1", "and", "with_score", ":", "\n", "        ", "return", "True", "\n", "\n", "", "return", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.string_util.StringStrip.__init__": [[17, 25], ["isinstance", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "strip", "=", "True", ",", "strip_pos", "=", "'both'", ",", "strip_str", "=", "None", ")", ":", "\n", "        ", "assert", "isinstance", "(", "strip", ",", "bool", ")", "\n", "assert", "strip_pos", "in", "(", "'both'", ",", "'left'", ",", "'right'", ")", "\n", "assert", "strip_str", "is", "None", "or", "isinstance", "(", "strip_str", ",", "str", ")", "\n", "\n", "self", ".", "strip", "=", "strip", "\n", "self", ".", "strip_pos", "=", "strip_pos", "\n", "self", ".", "strip_str", "=", "strip_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.string_util.StringStrip.__call__": [[26, 37], ["in_str.lstrip", "in_str.rstrip", "in_str.strip"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "in_str", ")", ":", "\n", "\n", "        ", "if", "not", "self", ".", "strip", ":", "\n", "            ", "return", "in_str", "\n", "\n", "", "if", "self", ".", "strip_pos", "==", "'left'", ":", "\n", "            ", "return", "in_str", ".", "lstrip", "(", "self", ".", "strip_str", ")", "\n", "", "elif", "self", ".", "strip_pos", "==", "'right'", ":", "\n", "            ", "return", "in_str", ".", "rstrip", "(", "self", ".", "strip_str", ")", "\n", "", "else", ":", "\n", "            ", "return", "in_str", ".", "strip", "(", "self", ".", "strip_str", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.logger.get_root_logger": [[7, 26], ["mmcv.utils.get_logger", "__name__.split"], "function", ["None"], ["def", "get_root_logger", "(", "log_file", "=", "None", ",", "log_level", "=", "logging", ".", "INFO", ")", ":", "\n", "    ", "\"\"\"Use `get_logger` method in mmcv to get the root logger.\n\n    The logger will be initialized if it has not been initialized. By default a\n    StreamHandler will be added. If `log_file` is specified, a FileHandler will\n    also be added. The name of the root logger is the top-level package name,\n    e.g., \"mmpose\".\n\n    Args:\n        log_file (str | None): The log filename. If specified, a FileHandler\n            will be added to the root logger.\n        log_level (int): The root logger level. Note that only the process of\n            rank 0 is affected, while other processes will set the level to\n            \"Error\" and be silent most of the time.\n\n    Returns:\n        logging.Logger: The root logger.\n    \"\"\"", "\n", "return", "get_logger", "(", "__name__", ".", "split", "(", "'.'", ")", "[", "0", "]", ",", "log_file", ",", "log_level", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes": [[10, 48], ["cfg.get", "cv2.setNumThreads", "platform.system", "cfg.get", "torch.get_start_method", "torch.set_start_method", "warnings.warn", "str", "warnings.warn", "str", "warnings.warn"], "function", ["None"], ["def", "setup_multi_processes", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"Setup multi-processing environment variables.\"\"\"", "\n", "# set multi-process start method as `fork` to speed up the training", "\n", "if", "platform", ".", "system", "(", ")", "!=", "'Windows'", ":", "\n", "        ", "mp_start_method", "=", "cfg", ".", "get", "(", "'mp_start_method'", ",", "'fork'", ")", "\n", "current_method", "=", "mp", ".", "get_start_method", "(", "allow_none", "=", "True", ")", "\n", "if", "current_method", "is", "not", "None", "and", "current_method", "!=", "mp_start_method", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "f'Multi-processing start method `{mp_start_method}` is '", "\n", "f'different from the previous setting `{current_method}`.'", "\n", "f'It will be force set to `{mp_start_method}`. You can change '", "\n", "f'this behavior by changing `mp_start_method` in your config.'", ")", "\n", "", "mp", ".", "set_start_method", "(", "mp_start_method", ",", "force", "=", "True", ")", "\n", "\n", "# disable opencv multithreading to avoid system being overloaded", "\n", "", "opencv_num_threads", "=", "cfg", ".", "get", "(", "'opencv_num_threads'", ",", "0", ")", "\n", "cv2", ".", "setNumThreads", "(", "opencv_num_threads", ")", "\n", "\n", "# setup OMP threads", "\n", "# This code is referred from https://github.com/pytorch/pytorch/blob/master/torch/distributed/run.py  # noqa", "\n", "if", "'OMP_NUM_THREADS'", "not", "in", "os", ".", "environ", "and", "cfg", ".", "data", ".", "workers_per_gpu", ">", "1", ":", "\n", "        ", "omp_num_threads", "=", "1", "\n", "warnings", ".", "warn", "(", "\n", "f'Setting OMP_NUM_THREADS environment variable for each process '", "\n", "f'to be {omp_num_threads} in default, to avoid your system being '", "\n", "f'overloaded, please further tune the variable for optimal '", "\n", "f'performance in your application as needed.'", ")", "\n", "os", ".", "environ", "[", "'OMP_NUM_THREADS'", "]", "=", "str", "(", "omp_num_threads", ")", "\n", "\n", "# setup MKL threads", "\n", "", "if", "'MKL_NUM_THREADS'", "not", "in", "os", ".", "environ", "and", "cfg", ".", "data", ".", "workers_per_gpu", ">", "1", ":", "\n", "        ", "mkl_num_threads", "=", "1", "\n", "warnings", ".", "warn", "(", "\n", "f'Setting MKL_NUM_THREADS environment variable for each process '", "\n", "f'to be {mkl_num_threads} in default, to avoid your system being '", "\n", "f'overloaded, please further tune the variable for optimal '", "\n", "f'performance in your application as needed.'", ")", "\n", "os", ".", "environ", "[", "'MKL_NUM_THREADS'", "]", "=", "str", "(", "mkl_num_threads", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.img_util.drop_orientation": [[7, 36], ["isinstance", "mmcv.imread", "mmcv.imread", "mmcv.imread", "mmcv.imwrite", "os.remove", "print", "os.path.splitext"], "function", ["None"], ["def", "drop_orientation", "(", "img_file", ")", ":", "\n", "    ", "\"\"\"Check if the image has orientation information. If yes, ignore it by\n    converting the image format to png, and return new filename, otherwise\n    return the original filename.\n\n    Args:\n        img_file(str): The image path\n\n    Returns:\n        The converted image filename with proper postfix\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_file", ",", "str", ")", "\n", "assert", "img_file", "\n", "\n", "# read imgs with ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "# read imgs with orientations as dataloader does when training and testing", "\n", "img_color", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'color'", ")", "\n", "# make sure imgs have no orientation info, or annotation gt is wrong.", "\n", "if", "img", ".", "shape", "[", ":", "2", "]", "==", "img_color", ".", "shape", "[", ":", "2", "]", ":", "\n", "        ", "return", "img_file", "\n", "\n", "", "target_file", "=", "os", ".", "path", ".", "splitext", "(", "img_file", ")", "[", "0", "]", "+", "'.png'", "\n", "# read img with ignoring orientation information", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "mmcv", ".", "imwrite", "(", "img", ",", "target_file", ")", "\n", "os", ".", "remove", "(", "img_file", ")", "\n", "print", "(", "f'{img_file} has orientation info. Ignore it by converting to png'", ")", "\n", "return", "target_file", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.img_util.is_not_png": [[38, 53], ["isinstance", "os.path.splitext"], "function", ["None"], ["", "def", "is_not_png", "(", "img_file", ")", ":", "\n", "    ", "\"\"\"Check img_file is not png image.\n\n    Args:\n        img_file(str): The input image file name\n\n    Returns:\n        The bool flag indicating whether it is not png\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_file", ",", "str", ")", "\n", "assert", "img_file", "\n", "\n", "suffix", "=", "os", ".", "path", ".", "splitext", "(", "img_file", ")", "[", "1", "]", "\n", "\n", "return", "suffix", "not", "in", "[", "'.PNG'", ",", "'.png'", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model._BatchNormXd._check_input_dim": [[16, 18], ["None"], "methods", ["None"], ["def", "_check_input_dim", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm": [[20, 52], ["isinstance", "module.named_children", "model._BatchNormXd", "hasattr", "_BatchNormXd.add_module", "model.revert_sync_batchnorm", "torch.no_grad"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm"], ["", "", "def", "revert_sync_batchnorm", "(", "module", ")", ":", "\n", "    ", "\"\"\"Helper function to convert all `SyncBatchNorm` layers in the model to\n    `BatchNormXd` layers.\n\n    Adapted from @kapily's work:\n    (https://github.com/pytorch/pytorch/issues/41081#issuecomment-783961547)\n\n    Args:\n        module (nn.Module): The module containing `SyncBatchNorm` layers.\n\n    Returns:\n        module_output: The converted module with `BatchNormXd` layers.\n    \"\"\"", "\n", "module_output", "=", "module", "\n", "if", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "modules", ".", "batchnorm", ".", "SyncBatchNorm", ")", ":", "\n", "        ", "module_output", "=", "_BatchNormXd", "(", "module", ".", "num_features", ",", "module", ".", "eps", ",", "\n", "module", ".", "momentum", ",", "module", ".", "affine", ",", "\n", "module", ".", "track_running_stats", ")", "\n", "if", "module", ".", "affine", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "module_output", ".", "weight", "=", "module", ".", "weight", "\n", "module_output", ".", "bias", "=", "module", ".", "bias", "\n", "", "", "module_output", ".", "running_mean", "=", "module", ".", "running_mean", "\n", "module_output", ".", "running_var", "=", "module", ".", "running_var", "\n", "module_output", ".", "num_batches_tracked", "=", "module", ".", "num_batches_tracked", "\n", "module_output", ".", "training", "=", "module", ".", "training", "\n", "if", "hasattr", "(", "module", ",", "'qconfig'", ")", ":", "\n", "            ", "module_output", ".", "qconfig", "=", "module", ".", "qconfig", "\n", "", "", "for", "name", ",", "child", "in", "module", ".", "named_children", "(", ")", ":", "\n", "        ", "module_output", ".", "add_module", "(", "name", ",", "revert_sync_batchnorm", "(", "child", ")", ")", "\n", "", "del", "module", "\n", "return", "module_output", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.is_on_same_line": [[9, 45], ["numpy.min", "numpy.min", "numpy.max", "numpy.max", "sorted"], "function", ["None"], ["def", "is_on_same_line", "(", "box_a", ",", "box_b", ",", "min_y_overlap_ratio", "=", "0.8", ")", ":", "\n", "    ", "\"\"\"Check if two boxes are on the same line by their y-axis coordinates.\n\n    Two boxes are on the same line if they overlap vertically, and the length\n    of the overlapping line segment is greater than min_y_overlap_ratio * the\n    height of either of the boxes.\n\n    Args:\n        box_a (list), box_b (list): Two bounding boxes to be checked\n        min_y_overlap_ratio (float): The minimum vertical overlapping ratio\n                                    allowed for boxes in the same line\n\n    Returns:\n        The bool flag indicating if they are on the same line\n    \"\"\"", "\n", "a_y_min", "=", "np", ".", "min", "(", "box_a", "[", "1", ":", ":", "2", "]", ")", "\n", "b_y_min", "=", "np", ".", "min", "(", "box_b", "[", "1", ":", ":", "2", "]", ")", "\n", "a_y_max", "=", "np", ".", "max", "(", "box_a", "[", "1", ":", ":", "2", "]", ")", "\n", "b_y_max", "=", "np", ".", "max", "(", "box_b", "[", "1", ":", ":", "2", "]", ")", "\n", "\n", "# Make sure that box a is always the box above another", "\n", "if", "a_y_min", ">", "b_y_min", ":", "\n", "        ", "a_y_min", ",", "b_y_min", "=", "b_y_min", ",", "a_y_min", "\n", "a_y_max", ",", "b_y_max", "=", "b_y_max", ",", "a_y_max", "\n", "\n", "", "if", "b_y_min", "<=", "a_y_max", ":", "\n", "        ", "if", "min_y_overlap_ratio", "is", "not", "None", ":", "\n", "            ", "sorted_y", "=", "sorted", "(", "[", "b_y_min", ",", "b_y_max", ",", "a_y_max", "]", ")", "\n", "overlap", "=", "sorted_y", "[", "1", "]", "-", "sorted_y", "[", "0", "]", "\n", "min_a_overlap", "=", "(", "a_y_max", "-", "a_y_min", ")", "*", "min_y_overlap_ratio", "\n", "min_b_overlap", "=", "(", "b_y_max", "-", "b_y_min", ")", "*", "min_y_overlap_ratio", "\n", "return", "overlap", ">=", "min_a_overlap", "or", "overlap", ">=", "min_b_overlap", "\n", "", "else", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.stitch_boxes_into_lines": [[47, 123], ["sorted", "set", "range", "len", "len", "range", "lines.append", "range", "len", "box_util.is_on_same_line", "len", "lines[].append", "merged_boxes.append", "numpy.min", "line.append", "set.add", "numpy.min", "numpy.max", "lines.append", "float", "float", "float", "float", "max", "min", "max", "min", "numpy.max", "numpy.min", "numpy.max", "numpy.min"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.is_on_same_line"], ["", "def", "stitch_boxes_into_lines", "(", "boxes", ",", "max_x_dist", "=", "10", ",", "min_y_overlap_ratio", "=", "0.8", ")", ":", "\n", "    ", "\"\"\"Stitch fragmented boxes of words into lines.\n\n    Note: part of its logic is inspired by @Johndirr\n    (https://github.com/faustomorales/keras-ocr/issues/22)\n\n    Args:\n        boxes (list): List of ocr results to be stitched\n        max_x_dist (int): The maximum horizontal distance between the closest\n                    edges of neighboring boxes in the same line\n        min_y_overlap_ratio (float): The minimum vertical overlapping ratio\n                    allowed for any pairs of neighboring boxes in the same line\n\n    Returns:\n        merged_boxes(list[dict]): List of merged boxes and texts\n    \"\"\"", "\n", "\n", "if", "len", "(", "boxes", ")", "<=", "1", ":", "\n", "        ", "return", "boxes", "\n", "\n", "", "merged_boxes", "=", "[", "]", "\n", "\n", "# sort groups based on the x_min coordinate of boxes", "\n", "x_sorted_boxes", "=", "sorted", "(", "boxes", ",", "key", "=", "lambda", "x", ":", "np", ".", "min", "(", "x", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", ")", "\n", "# store indexes of boxes which are already parts of other lines", "\n", "skip_idxs", "=", "set", "(", ")", "\n", "\n", "i", "=", "0", "\n", "# locate lines of boxes starting from the leftmost one", "\n", "for", "i", "in", "range", "(", "len", "(", "x_sorted_boxes", ")", ")", ":", "\n", "        ", "if", "i", "in", "skip_idxs", ":", "\n", "            ", "continue", "\n", "# the rightmost box in the current line", "\n", "", "rightmost_box_idx", "=", "i", "\n", "line", "=", "[", "rightmost_box_idx", "]", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "x_sorted_boxes", ")", ")", ":", "\n", "            ", "if", "j", "in", "skip_idxs", ":", "\n", "                ", "continue", "\n", "", "if", "is_on_same_line", "(", "x_sorted_boxes", "[", "rightmost_box_idx", "]", "[", "'box'", "]", ",", "\n", "x_sorted_boxes", "[", "j", "]", "[", "'box'", "]", ",", "min_y_overlap_ratio", ")", ":", "\n", "                ", "line", ".", "append", "(", "j", ")", "\n", "skip_idxs", ".", "add", "(", "j", ")", "\n", "rightmost_box_idx", "=", "j", "\n", "\n", "# split line into lines if the distance between two neighboring", "\n", "# sub-lines' is greater than max_x_dist", "\n", "", "", "lines", "=", "[", "]", "\n", "line_idx", "=", "0", "\n", "lines", ".", "append", "(", "[", "line", "[", "0", "]", "]", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "len", "(", "line", ")", ")", ":", "\n", "            ", "curr_box", "=", "x_sorted_boxes", "[", "line", "[", "k", "]", "]", "\n", "prev_box", "=", "x_sorted_boxes", "[", "line", "[", "k", "-", "1", "]", "]", "\n", "dist", "=", "np", ".", "min", "(", "curr_box", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", "-", "np", ".", "max", "(", "prev_box", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", "\n", "if", "dist", ">", "max_x_dist", ":", "\n", "                ", "line_idx", "+=", "1", "\n", "lines", ".", "append", "(", "[", "]", ")", "\n", "", "lines", "[", "line_idx", "]", ".", "append", "(", "line", "[", "k", "]", ")", "\n", "\n", "# Get merged boxes", "\n", "", "for", "box_group", "in", "lines", ":", "\n", "            ", "merged_box", "=", "{", "}", "\n", "merged_box", "[", "'text'", "]", "=", "' '", ".", "join", "(", "\n", "[", "x_sorted_boxes", "[", "idx", "]", "[", "'text'", "]", "for", "idx", "in", "box_group", "]", ")", "\n", "x_min", ",", "y_min", "=", "float", "(", "'inf'", ")", ",", "float", "(", "'inf'", ")", "\n", "x_max", ",", "y_max", "=", "float", "(", "'-inf'", ")", ",", "float", "(", "'-inf'", ")", "\n", "for", "idx", "in", "box_group", ":", "\n", "                ", "x_max", "=", "max", "(", "np", ".", "max", "(", "x_sorted_boxes", "[", "idx", "]", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", ",", "x_max", ")", "\n", "x_min", "=", "min", "(", "np", ".", "min", "(", "x_sorted_boxes", "[", "idx", "]", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", ",", "x_min", ")", "\n", "y_max", "=", "max", "(", "np", ".", "max", "(", "x_sorted_boxes", "[", "idx", "]", "[", "'box'", "]", "[", "1", ":", ":", "2", "]", ")", ",", "y_max", ")", "\n", "y_min", "=", "min", "(", "np", ".", "min", "(", "x_sorted_boxes", "[", "idx", "]", "[", "'box'", "]", "[", "1", ":", ":", "2", "]", ")", ",", "y_min", ")", "\n", "", "merged_box", "[", "'box'", "]", "=", "[", "\n", "x_min", ",", "y_min", ",", "x_max", ",", "y_min", ",", "x_max", ",", "y_max", ",", "x_min", ",", "y_max", "\n", "]", "\n", "merged_boxes", ".", "append", "(", "merged_box", ")", "\n", "\n", "", "", "return", "merged_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.bezier_to_polygon": [[125, 160], ["numpy.asarray", "np.asarray.reshape().transpose().reshape", "numpy.linspace", "numpy.concatenate", "np.concatenate.tolist", "numpy.prod", "numpy.outer", "np.asarray.reshape().transpose", "numpy.outer", "numpy.outer", "numpy.outer", "np.asarray.reshape"], "function", ["None"], ["", "def", "bezier_to_polygon", "(", "bezier_points", ",", "num_sample", "=", "20", ")", ":", "\n", "    ", "\"\"\"Sample points from the boundary of a polygon enclosed by two Bezier\n    curves, which are controlled by ``bezier_points``.\n\n    Args:\n        bezier_points (ndarray): A :math:`(2, 4, 2)` array of 8 Bezeir points\n            or its equalivance. The first 4 points control the curve at one\n            side and the last four control the other side.\n        num_sample (int): The number of sample points at each Bezeir curve.\n\n    Returns:\n        list[ndarray]: A list of 2*num_sample points representing the polygon\n        extracted from Bezier curves.\n\n    Warning:\n        The points are not guaranteed to be ordered. Please use\n        :func:`mmocr.utils.sort_points` to sort points if necessary.\n    \"\"\"", "\n", "assert", "num_sample", ">", "0", "\n", "\n", "bezier_points", "=", "np", ".", "asarray", "(", "bezier_points", ")", "\n", "assert", "np", ".", "prod", "(", "\n", "bezier_points", ".", "shape", ")", "==", "16", ",", "'Need 8 Bezier control points to continue!'", "\n", "\n", "bezier", "=", "bezier_points", ".", "reshape", "(", "2", ",", "4", ",", "2", ")", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", ".", "reshape", "(", "4", ",", "4", ")", "\n", "u", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num_sample", ")", "\n", "\n", "points", "=", "np", ".", "outer", "(", "(", "1", "-", "u", ")", "**", "3", ",", "bezier", "[", ":", ",", "0", "]", ")", "+", "np", ".", "outer", "(", "3", "*", "u", "*", "(", "(", "1", "-", "u", ")", "**", "2", ")", ",", "bezier", "[", ":", ",", "1", "]", ")", "+", "np", ".", "outer", "(", "3", "*", "(", "u", "**", "2", ")", "*", "(", "1", "-", "u", ")", ",", "bezier", "[", ":", ",", "2", "]", ")", "+", "np", ".", "outer", "(", "u", "**", "3", ",", "bezier", "[", ":", ",", "3", "]", ")", "\n", "\n", "# Convert points to polygon", "\n", "points", "=", "np", ".", "concatenate", "(", "(", "points", "[", ":", ",", ":", "2", "]", ",", "points", "[", ":", ",", "2", ":", "]", ")", ",", "axis", "=", "0", ")", "\n", "return", "points", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.sort_points": [[162, 200], ["numpy.array", "numpy.mean", "sorted", "mmocr.utils.check_argument.is_type_list", "isinstance", "mmocr.utils.check_argument.is_2dlist", "numpy.cross", "functools.cmp_to_key"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "sort_points", "(", "points", ")", ":", "\n", "    ", "\"\"\"Sort arbitory points in clockwise order. Reference:\n    https://stackoverflow.com/a/6989383.\n\n    Args:\n        points (list[ndarray] or ndarray or list[list]): A list of unsorted\n            boundary points.\n\n    Returns:\n        list[ndarray]: A list of points sorted in clockwise order.\n    \"\"\"", "\n", "\n", "assert", "is_type_list", "(", "points", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "points", ",", "np", ".", "ndarray", ")", "or", "is_2dlist", "(", "points", ")", "\n", "\n", "points", "=", "np", ".", "array", "(", "points", ")", "\n", "center", "=", "np", ".", "mean", "(", "points", ",", "axis", "=", "0", ")", "\n", "\n", "def", "cmp", "(", "a", ",", "b", ")", ":", "\n", "        ", "oa", "=", "a", "-", "center", "\n", "ob", "=", "b", "-", "center", "\n", "\n", "# Some corner cases", "\n", "if", "oa", "[", "0", "]", ">=", "0", "and", "ob", "[", "0", "]", "<", "0", ":", "\n", "            ", "return", "1", "\n", "", "if", "oa", "[", "0", "]", "<", "0", "and", "ob", "[", "0", "]", ">=", "0", ":", "\n", "            ", "return", "-", "1", "\n", "\n", "", "prod", "=", "np", ".", "cross", "(", "oa", ",", "ob", ")", "\n", "if", "prod", ">", "0", ":", "\n", "            ", "return", "1", "\n", "", "if", "prod", "<", "0", ":", "\n", "            ", "return", "-", "1", "\n", "\n", "# a, b are on the same line from the center", "\n", "", "return", "1", "if", "(", "oa", "**", "2", ")", ".", "sum", "(", ")", "<", "(", "ob", "**", "2", ")", ".", "sum", "(", ")", "else", "-", "1", "\n", "\n", "", "return", "sorted", "(", "points", ",", "key", "=", "functools", ".", "cmp_to_key", "(", "cmp", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.collect_env.collect_env": [[8, 13], ["mmcv.utils.collect_env", "mmcv.utils.get_git_hash"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.collect_env.collect_env"], ["def", "collect_env", "(", ")", ":", "\n", "    ", "\"\"\"Collect the information of the running environments.\"\"\"", "\n", "env_info", "=", "collect_base_env", "(", ")", "\n", "env_info", "[", "'MMOCR'", "]", "=", "mmocr", ".", "__version__", "+", "'+'", "+", "get_git_hash", "(", ")", "[", ":", "7", "]", "\n", "return", "env_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file": [[7, 18], ["mmcv.mkdir_or_exist", "os.path.dirname", "open", "fw.write"], "function", ["None"], ["def", "list_to_file", "(", "filename", ",", "lines", ")", ":", "\n", "    ", "\"\"\"Write a list of strings to a text file.\n\n    Args:\n        filename (str): The output filename. It will be created/overwritten.\n        lines (list(str)): Data to be written.\n    \"\"\"", "\n", "mmcv", ".", "mkdir_or_exist", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ")", "\n", "with", "open", "(", "filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "fw", ":", "\n", "        ", "for", "line", "in", "lines", ":", "\n", "            ", "fw", ".", "write", "(", "f'{line}\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file": [[20, 39], ["open", "item_list.append", "line.rstrip"], "function", ["None"], ["", "", "", "def", "list_from_file", "(", "filename", ",", "encoding", "=", "'utf-8'", ")", ":", "\n", "    ", "\"\"\"Load a text file and parse the content as a list of strings. The\n    trailing \"\\\\r\" and \"\\\\n\" of each line will be removed.\n\n    Note:\n        This will be replaced by mmcv's version after it supports encoding.\n\n    Args:\n        filename (str): Filename.\n        encoding (str): Encoding used to open the file. Default utf-8.\n\n    Returns:\n        list[str]: A list of strings.\n    \"\"\"", "\n", "item_list", "=", "[", "]", "\n", "with", "open", "(", "filename", ",", "'r'", ",", "encoding", "=", "encoding", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ":", "\n", "            ", "item_list", ".", "append", "(", "line", ".", "rstrip", "(", "'\\n\\r'", ")", ")", "\n", "", "", "return", "item_list", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.__init__": [[175, 440], ["os.path.join", "list", "str", "torch.device", "ValueError", "mmcv.utils.config.Config.fromfile", "mmocr.models.build_detector", "mmocr.utils.model.revert_sync_batchnorm", "mmcv.runner.load_checkpoint", "filter", "hasattr", "pathlib.Path.cwd", "ValueError", "ImportError", "mmocr.apis.init_detector", "mmocr.utils.model.revert_sync_batchnorm", "ImportError", "mmocr.apis.init_detector", "mmocr.utils.model.revert_sync_batchnorm", "os.path.join", "torch.cuda.is_available", "os.path.join", "os.path.join", "mmcv.utils.config.Config.fromfile.get", "ValueError", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm"], ["    ", "def", "__init__", "(", "self", ",", "\n", "det", "=", "'PANet_IC15'", ",", "\n", "det_config", "=", "''", ",", "\n", "det_ckpt", "=", "''", ",", "\n", "recog", "=", "'SEG'", ",", "\n", "recog_config", "=", "''", ",", "\n", "recog_ckpt", "=", "''", ",", "\n", "kie", "=", "''", ",", "\n", "kie_config", "=", "''", ",", "\n", "kie_ckpt", "=", "''", ",", "\n", "config_dir", "=", "os", ".", "path", ".", "join", "(", "str", "(", "Path", ".", "cwd", "(", ")", ")", ",", "'configs/'", ")", ",", "\n", "device", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "        ", "textdet_models", "=", "{", "\n", "'DB_r18'", ":", "{", "\n", "'config'", ":", "\n", "'dbnet/dbnet_r18_fpnc_1200e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'dbnet/'", "\n", "'dbnet_r18_fpnc_sbn_1200e_icdar2015_20210329-ba3ab597.pth'", "\n", "}", ",", "\n", "'DB_r50'", ":", "{", "\n", "'config'", ":", "\n", "'dbnet/dbnet_r50dcnv2_fpnc_1200e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'dbnet/'", "\n", "'dbnet_r50dcnv2_fpnc_sbn_1200e_icdar2015_20211025-9fe3b590.pth'", "\n", "}", ",", "\n", "'DBPP_r50'", ":", "{", "\n", "'config'", ":", "\n", "'dbnetpp/dbnetpp_r50dcnv2_fpnc_1200e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'dbnet/'", "\n", "'dbnetpp_r50dcnv2_fpnc_1200e_icdar2015-20220502-d7a76fff.pth'", "\n", "}", ",", "\n", "'DRRG'", ":", "{", "\n", "'config'", ":", "\n", "'drrg/drrg_r50_fpn_unet_1200e_ctw1500.py'", ",", "\n", "'ckpt'", ":", "\n", "'drrg/drrg_r50_fpn_unet_1200e_ctw1500_20211022-fb30b001.pth'", "\n", "}", ",", "\n", "'FCE_IC15'", ":", "{", "\n", "'config'", ":", "\n", "'fcenet/fcenet_r50_fpn_1500e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'fcenet/fcenet_r50_fpn_1500e_icdar2015_20211022-daefb6ed.pth'", "\n", "}", ",", "\n", "'FCE_CTW_DCNv2'", ":", "{", "\n", "'config'", ":", "\n", "'fcenet/fcenet_r50dcnv2_fpn_1500e_ctw1500.py'", ",", "\n", "'ckpt'", ":", "\n", "'fcenet/'", "+", "\n", "'fcenet_r50dcnv2_fpn_1500e_ctw1500_20211022-e326d7ec.pth'", "\n", "}", ",", "\n", "'MaskRCNN_CTW'", ":", "{", "\n", "'config'", ":", "\n", "'maskrcnn/mask_rcnn_r50_fpn_160e_ctw1500.py'", ",", "\n", "'ckpt'", ":", "\n", "'maskrcnn/'", "\n", "'mask_rcnn_r50_fpn_160e_ctw1500_20210219-96497a76.pth'", "\n", "}", ",", "\n", "'MaskRCNN_IC15'", ":", "{", "\n", "'config'", ":", "\n", "'maskrcnn/mask_rcnn_r50_fpn_160e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'maskrcnn/'", "\n", "'mask_rcnn_r50_fpn_160e_icdar2015_20210219-8eb340a3.pth'", "\n", "}", ",", "\n", "'MaskRCNN_IC17'", ":", "{", "\n", "'config'", ":", "\n", "'maskrcnn/mask_rcnn_r50_fpn_160e_icdar2017.py'", ",", "\n", "'ckpt'", ":", "\n", "'maskrcnn/'", "\n", "'mask_rcnn_r50_fpn_160e_icdar2017_20210218-c6ec3ebb.pth'", "\n", "}", ",", "\n", "'PANet_CTW'", ":", "{", "\n", "'config'", ":", "\n", "'panet/panet_r18_fpem_ffm_600e_ctw1500.py'", ",", "\n", "'ckpt'", ":", "\n", "'panet/'", "\n", "'panet_r18_fpem_ffm_sbn_600e_ctw1500_20210219-3b3a9aa3.pth'", "\n", "}", ",", "\n", "'PANet_IC15'", ":", "{", "\n", "'config'", ":", "\n", "'panet/panet_r18_fpem_ffm_600e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'panet/'", "\n", "'panet_r18_fpem_ffm_sbn_600e_icdar2015_20210219-42dbe46a.pth'", "\n", "}", ",", "\n", "'PS_CTW'", ":", "{", "\n", "'config'", ":", "'psenet/psenet_r50_fpnf_600e_ctw1500.py'", ",", "\n", "'ckpt'", ":", "\n", "'psenet/psenet_r50_fpnf_600e_ctw1500_20210401-216fed50.pth'", "\n", "}", ",", "\n", "'PS_IC15'", ":", "{", "\n", "'config'", ":", "\n", "'psenet/psenet_r50_fpnf_600e_icdar2015.py'", ",", "\n", "'ckpt'", ":", "\n", "'psenet/psenet_r50_fpnf_600e_icdar2015_pretrain-eefd8fe6.pth'", "\n", "}", ",", "\n", "'TextSnake'", ":", "{", "\n", "'config'", ":", "\n", "'textsnake/textsnake_r50_fpn_unet_1200e_ctw1500.py'", ",", "\n", "'ckpt'", ":", "\n", "'textsnake/textsnake_r50_fpn_unet_1200e_ctw1500-27f65b64.pth'", "\n", "}", ",", "\n", "'Tesseract'", ":", "{", "}", "\n", "}", "\n", "\n", "textrecog_models", "=", "{", "\n", "'CRNN'", ":", "{", "\n", "'config'", ":", "'crnn/crnn_academic_dataset.py'", ",", "\n", "'ckpt'", ":", "'crnn/crnn_academic-a723a1c5.pth'", "\n", "}", ",", "\n", "'SAR'", ":", "{", "\n", "'config'", ":", "'sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "'ckpt'", ":", "'sar/sar_r31_parallel_decoder_academic-dba3a4a3.pth'", "\n", "}", ",", "\n", "'SAR_CN'", ":", "{", "\n", "'config'", ":", "\n", "'sar/sar_r31_parallel_decoder_chinese.py'", ",", "\n", "'ckpt'", ":", "\n", "'sar/sar_r31_parallel_decoder_chineseocr_20210507-b4be8214.pth'", "\n", "}", ",", "\n", "'NRTR_1/16-1/8'", ":", "{", "\n", "'config'", ":", "'nrtr/nrtr_r31_1by16_1by8_academic.py'", ",", "\n", "'ckpt'", ":", "\n", "'nrtr/nrtr_r31_1by16_1by8_academic_20211124-f60cebf4.pth'", "\n", "}", ",", "\n", "'NRTR_1/8-1/4'", ":", "{", "\n", "'config'", ":", "'nrtr/nrtr_r31_1by8_1by4_academic.py'", ",", "\n", "'ckpt'", ":", "\n", "'nrtr/nrtr_r31_1by8_1by4_academic_20211123-e1fdb322.pth'", "\n", "}", ",", "\n", "'RobustScanner'", ":", "{", "\n", "'config'", ":", "'robust_scanner/robustscanner_r31_academic.py'", ",", "\n", "'ckpt'", ":", "'robustscanner/robustscanner_r31_academic-5f05874f.pth'", "\n", "}", ",", "\n", "'SATRN'", ":", "{", "\n", "'config'", ":", "'satrn/satrn_academic.py'", ",", "\n", "'ckpt'", ":", "'satrn/satrn_academic_20211009-cb8b1580.pth'", "\n", "}", ",", "\n", "'SATRN_sm'", ":", "{", "\n", "'config'", ":", "'satrn/satrn_small.py'", ",", "\n", "'ckpt'", ":", "'satrn/satrn_small_20211009-2cf13355.pth'", "\n", "}", ",", "\n", "'ABINet'", ":", "{", "\n", "'config'", ":", "'abinet/abinet_academic.py'", ",", "\n", "'ckpt'", ":", "'abinet/abinet_academic-f718abf6.pth'", "\n", "}", ",", "\n", "'ABINet_Vision'", ":", "{", "\n", "'config'", ":", "'abinet/abinet_vision_only_academic.py'", ",", "\n", "'ckpt'", ":", "'abinet/abinet_vision_only_academic-e6b9ea89.pth'", "\n", "}", ",", "\n", "'SEG'", ":", "{", "\n", "'config'", ":", "'seg/seg_r31_1by16_fpnocr_academic.py'", ",", "\n", "'ckpt'", ":", "'seg/seg_r31_1by16_fpnocr_academic-72235b11.pth'", "\n", "}", ",", "\n", "'CRNN_TPS'", ":", "{", "\n", "'config'", ":", "'tps/crnn_tps_academic_dataset.py'", ",", "\n", "'ckpt'", ":", "'tps/crnn_tps_academic_dataset_20210510-d221a905.pth'", "\n", "}", ",", "\n", "'Tesseract'", ":", "{", "}", ",", "\n", "'MASTER'", ":", "{", "\n", "'config'", ":", "'master/master_r31_12e_ST_MJ_SA.py'", ",", "\n", "'ckpt'", ":", "'master/master_r31_12e_ST_MJ_SA-787edd36.pth'", "\n", "}", "\n", "}", "\n", "\n", "kie_models", "=", "{", "\n", "'SDMGR'", ":", "{", "\n", "'config'", ":", "'sdmgr/sdmgr_unet16_60e_wildreceipt.py'", ",", "\n", "'ckpt'", ":", "\n", "'sdmgr/sdmgr_unet16_60e_wildreceipt_20210520-7489e6de.pth'", "\n", "}", "\n", "}", "\n", "\n", "self", ".", "td", "=", "det", "\n", "self", ".", "tr", "=", "recog", "\n", "self", ".", "kie", "=", "kie", "\n", "self", ".", "device", "=", "device", "\n", "if", "self", ".", "device", "is", "None", ":", "\n", "            ", "self", ".", "device", "=", "torch", ".", "device", "(", "\n", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "\n", "# Check if the det/recog model choice is valid", "\n", "", "if", "self", ".", "td", "and", "self", ".", "td", "not", "in", "textdet_models", ":", "\n", "            ", "raise", "ValueError", "(", "self", ".", "td", ",", "\n", "'is not a supported text detection algorthm'", ")", "\n", "", "elif", "self", ".", "tr", "and", "self", ".", "tr", "not", "in", "textrecog_models", ":", "\n", "            ", "raise", "ValueError", "(", "self", ".", "tr", ",", "\n", "'is not a supported text recognition algorithm'", ")", "\n", "", "elif", "self", ".", "kie", ":", "\n", "            ", "if", "self", ".", "kie", "not", "in", "kie_models", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "self", ".", "kie", ",", "'is not a supported key information extraction'", "\n", "' algorithm'", ")", "\n", "", "elif", "not", "(", "self", ".", "td", "and", "self", ".", "tr", ")", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "self", ".", "kie", ",", "'has to run together'", "\n", "' with text detection and recognition algorithms.'", ")", "\n", "\n", "", "", "self", ".", "detect_model", "=", "None", "\n", "if", "self", ".", "td", "and", "self", ".", "td", "==", "'Tesseract'", ":", "\n", "            ", "if", "tesserocr", "is", "None", ":", "\n", "                ", "raise", "ImportError", "(", "'Please install tesserocr first. '", "\n", "'Check out the installation guide at '", "\n", "'https://github.com/sirfz/tesserocr'", ")", "\n", "", "self", ".", "detect_model", "=", "'Tesseract_det'", "\n", "", "elif", "self", ".", "td", ":", "\n", "# Build detection model", "\n", "            ", "if", "not", "det_config", ":", "\n", "                ", "det_config", "=", "os", ".", "path", ".", "join", "(", "config_dir", ",", "'textdet/'", ",", "\n", "textdet_models", "[", "self", ".", "td", "]", "[", "'config'", "]", ")", "\n", "", "if", "not", "det_ckpt", ":", "\n", "                ", "det_ckpt", "=", "'https://download.openmmlab.com/mmocr/textdet/'", "+", "textdet_models", "[", "self", ".", "td", "]", "[", "'ckpt'", "]", "\n", "\n", "", "self", ".", "detect_model", "=", "init_detector", "(", "\n", "det_config", ",", "det_ckpt", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "detect_model", "=", "revert_sync_batchnorm", "(", "self", ".", "detect_model", ")", "\n", "\n", "", "self", ".", "recog_model", "=", "None", "\n", "if", "self", ".", "tr", "and", "self", ".", "tr", "==", "'Tesseract'", ":", "\n", "            ", "if", "tesserocr", "is", "None", ":", "\n", "                ", "raise", "ImportError", "(", "'Please install tesserocr first. '", "\n", "'Check out the installation guide at '", "\n", "'https://github.com/sirfz/tesserocr'", ")", "\n", "", "self", ".", "recog_model", "=", "'Tesseract_recog'", "\n", "", "elif", "self", ".", "tr", ":", "\n", "# Build recognition model", "\n", "            ", "if", "not", "recog_config", ":", "\n", "                ", "recog_config", "=", "os", ".", "path", ".", "join", "(", "\n", "config_dir", ",", "'textrecog/'", ",", "\n", "textrecog_models", "[", "self", ".", "tr", "]", "[", "'config'", "]", ")", "\n", "", "if", "not", "recog_ckpt", ":", "\n", "                ", "recog_ckpt", "=", "'https://download.openmmlab.com/mmocr/'", "+", "'textrecog/'", "+", "textrecog_models", "[", "self", ".", "tr", "]", "[", "'ckpt'", "]", "\n", "\n", "", "self", ".", "recog_model", "=", "init_detector", "(", "\n", "recog_config", ",", "recog_ckpt", ",", "device", "=", "self", ".", "device", ")", "\n", "self", ".", "recog_model", "=", "revert_sync_batchnorm", "(", "self", ".", "recog_model", ")", "\n", "\n", "", "self", ".", "kie_model", "=", "None", "\n", "if", "self", ".", "kie", ":", "\n", "# Build key information extraction model", "\n", "            ", "if", "not", "kie_config", ":", "\n", "                ", "kie_config", "=", "os", ".", "path", ".", "join", "(", "config_dir", ",", "'kie/'", ",", "\n", "kie_models", "[", "self", ".", "kie", "]", "[", "'config'", "]", ")", "\n", "", "if", "not", "kie_ckpt", ":", "\n", "                ", "kie_ckpt", "=", "'https://download.openmmlab.com/mmocr/'", "+", "'kie/'", "+", "kie_models", "[", "self", ".", "kie", "]", "[", "'ckpt'", "]", "\n", "\n", "", "kie_cfg", "=", "Config", ".", "fromfile", "(", "kie_config", ")", "\n", "self", ".", "kie_model", "=", "build_detector", "(", "\n", "kie_cfg", ".", "model", ",", "test_cfg", "=", "kie_cfg", ".", "get", "(", "'test_cfg'", ")", ")", "\n", "self", ".", "kie_model", "=", "revert_sync_batchnorm", "(", "self", ".", "kie_model", ")", "\n", "self", ".", "kie_model", ".", "cfg", "=", "kie_cfg", "\n", "load_checkpoint", "(", "self", ".", "kie_model", ",", "kie_ckpt", ",", "map_location", "=", "self", ".", "device", ")", "\n", "\n", "# Attribute check", "\n", "", "for", "model", "in", "list", "(", "filter", "(", "None", ",", "[", "self", ".", "recog_model", ",", "self", ".", "detect_model", "]", ")", ")", ":", "\n", "            ", "if", "hasattr", "(", "model", ",", "'module'", ")", ":", "\n", "                ", "model", "=", "model", ".", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.get_tesserocr_api": [[441, 465], ["tesserocr.PyTessBaseAPI", "subprocess.Popen", "[].decode().split", "tesserocr.PyTessBaseAPI", "RuntimeError", "[].decode", "subprocess.Popen.communicate"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode"], ["", "", "", "@", "staticmethod", "\n", "def", "get_tesserocr_api", "(", ")", ":", "\n", "        ", "\"\"\"Get tesserocr api depending on different platform.\"\"\"", "\n", "import", "subprocess", "\n", "import", "sys", "\n", "\n", "if", "sys", ".", "platform", "==", "'linux'", ":", "\n", "            ", "api", "=", "tesserocr", ".", "PyTessBaseAPI", "(", ")", "\n", "", "elif", "sys", ".", "platform", "==", "'win32'", ":", "\n", "            ", "try", ":", "\n", "                ", "p", "=", "subprocess", ".", "Popen", "(", "\n", "'where tesseract'", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "shell", "=", "True", ")", "\n", "s", "=", "p", ".", "communicate", "(", ")", "[", "0", "]", ".", "decode", "(", "'utf-8'", ")", ".", "split", "(", "'\\\\'", ")", "\n", "path", "=", "s", "[", ":", "-", "1", "]", "+", "[", "'tessdata'", "]", "\n", "tessdata_path", "=", "'/'", ".", "join", "(", "path", ")", "\n", "api", "=", "tesserocr", ".", "PyTessBaseAPI", "(", "path", "=", "tessdata_path", ")", "\n", "", "except", "RuntimeError", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "'Please install tesseract first.\\n Check out the'", "\n", "' installation guide at'", "\n", "' https://github.com/UB-Mannheim/tesseract/wiki'", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "api", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.tesseract_det_inference": [[466, 507], ["isinstance", "mmocr.utils.is_type_list", "ocr.MMOCR.get_tesserocr_api", "ocr.MMOCR.End", "PIL.Image.fromarray", "ocr.MMOCR.SetImage", "ocr.MMOCR.GetComponentImages", "results.append", "boundaries.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.get_tesserocr_api"], ["", "def", "tesseract_det_inference", "(", "self", ",", "imgs", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Inference image(s) with the tesseract detector.\n\n        Args:\n            imgs (ndarray or list[ndarray]): image(s) to inference.\n\n        Returns:\n            result (dict): Predicted results.\n        \"\"\"", "\n", "is_batch", "=", "True", "\n", "if", "isinstance", "(", "imgs", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "is_batch", "=", "False", "\n", "imgs", "=", "[", "imgs", "]", "\n", "", "assert", "is_type_list", "(", "imgs", ",", "np", ".", "ndarray", ")", "\n", "api", "=", "self", ".", "get_tesserocr_api", "(", ")", "\n", "\n", "# Get detection result using tesseract", "\n", "results", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "            ", "image", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "api", ".", "SetImage", "(", "image", ")", "\n", "boxes", "=", "api", ".", "GetComponentImages", "(", "tesserocr", ".", "RIL", ".", "TEXTLINE", ",", "True", ")", "\n", "boundaries", "=", "[", "]", "\n", "for", "_", ",", "box", ",", "_", ",", "_", "in", "boxes", ":", "\n", "                ", "min_x", "=", "box", "[", "'x'", "]", "\n", "min_y", "=", "box", "[", "'y'", "]", "\n", "max_x", "=", "box", "[", "'x'", "]", "+", "box", "[", "'w'", "]", "\n", "max_y", "=", "box", "[", "'y'", "]", "+", "box", "[", "'h'", "]", "\n", "boundary", "=", "[", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", ",", "1.0", "\n", "]", "\n", "boundaries", ".", "append", "(", "boundary", ")", "\n", "", "results", ".", "append", "(", "{", "'boundary_result'", ":", "boundaries", "}", ")", "\n", "\n", "# close tesserocr api", "\n", "", "api", ".", "End", "(", ")", "\n", "\n", "if", "not", "is_batch", ":", "\n", "            ", "return", "results", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.tesseract_recog_inference": [[508, 541], ["isinstance", "mmocr.utils.is_type_list", "ocr.MMOCR.get_tesserocr_api", "ocr.MMOCR.End", "PIL.Image.fromarray", "ocr.MMOCR.SetImage", "ocr.MMOCR.SetRectangle", "ocr.MMOCR.GetUTF8Text().strip", "results.append", "ocr.MMOCR.MeanTextConf", "ocr.MMOCR.GetUTF8Text"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.get_tesserocr_api"], ["", "", "def", "tesseract_recog_inference", "(", "self", ",", "imgs", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Inference image(s) with the tesseract recognizer.\n\n        Args:\n            imgs (ndarray or list[ndarray]): image(s) to inference.\n\n        Returns:\n            result (dict): Predicted results.\n        \"\"\"", "\n", "is_batch", "=", "True", "\n", "if", "isinstance", "(", "imgs", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "is_batch", "=", "False", "\n", "imgs", "=", "[", "imgs", "]", "\n", "", "assert", "is_type_list", "(", "imgs", ",", "np", ".", "ndarray", ")", "\n", "api", "=", "self", ".", "get_tesserocr_api", "(", ")", "\n", "\n", "results", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "            ", "image", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "api", ".", "SetImage", "(", "image", ")", "\n", "api", ".", "SetRectangle", "(", "0", ",", "0", ",", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "0", "]", ")", "\n", "# Remove beginning and trailing spaces from Tesseract", "\n", "text", "=", "api", ".", "GetUTF8Text", "(", ")", ".", "strip", "(", ")", "\n", "conf", "=", "api", ".", "MeanTextConf", "(", ")", "/", "100", "\n", "results", ".", "append", "(", "{", "'text'", ":", "text", ",", "'score'", ":", "conf", "}", ")", "\n", "\n", "# close tesserocr api", "\n", "", "api", ".", "End", "(", ")", "\n", "\n", "if", "not", "is_batch", ":", "\n", "            ", "return", "results", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.readtext": [[542, 582], ["locals().copy", "argparse.Namespace", "ocr.MMOCR._args_processing", "argparse.Namespace.pop", "ocr.MMOCR.det_recog_kie_inference", "ocr.MMOCR.det_recog_pp", "list", "locals", "filter", "ocr.MMOCR.single_inference", "ocr.MMOCR.single_pp"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR._args_processing", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.det_recog_kie_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.det_recog_pp", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_pp"], ["", "", "def", "readtext", "(", "self", ",", "\n", "img", ",", "\n", "output", "=", "None", ",", "\n", "details", "=", "False", ",", "\n", "export", "=", "None", ",", "\n", "export_format", "=", "'json'", ",", "\n", "batch_mode", "=", "False", ",", "\n", "recog_batch_size", "=", "0", ",", "\n", "det_batch_size", "=", "0", ",", "\n", "single_batch_size", "=", "0", ",", "\n", "imshow", "=", "False", ",", "\n", "print_result", "=", "False", ",", "\n", "merge", "=", "False", ",", "\n", "merge_xdist", "=", "20", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "args", "=", "locals", "(", ")", ".", "copy", "(", ")", "\n", "[", "args", ".", "pop", "(", "x", ",", "None", ")", "for", "x", "in", "[", "'kwargs'", ",", "'self'", "]", "]", "\n", "args", "=", "Namespace", "(", "**", "args", ")", "\n", "\n", "# Input and output arguments processing", "\n", "self", ".", "_args_processing", "(", "args", ")", "\n", "self", ".", "args", "=", "args", "\n", "\n", "pp_result", "=", "None", "\n", "\n", "# Send args and models to the MMOCR model inference API", "\n", "# and call post-processing functions for the output", "\n", "if", "self", ".", "detect_model", "and", "self", ".", "recog_model", ":", "\n", "            ", "det_recog_result", "=", "self", ".", "det_recog_kie_inference", "(", "\n", "self", ".", "detect_model", ",", "self", ".", "recog_model", ",", "kie_model", "=", "self", ".", "kie_model", ")", "\n", "pp_result", "=", "self", ".", "det_recog_pp", "(", "det_recog_result", ")", "\n", "", "else", ":", "\n", "            ", "for", "model", "in", "list", "(", "\n", "filter", "(", "None", ",", "[", "self", ".", "recog_model", ",", "self", ".", "detect_model", "]", ")", ")", ":", "\n", "                ", "result", "=", "self", ".", "single_inference", "(", "model", ",", "args", ".", "arrays", ",", "\n", "args", ".", "batch_mode", ",", "\n", "args", ".", "single_batch_size", ")", "\n", "pp_result", "=", "self", ".", "single_pp", "(", "result", ",", "model", ")", "\n", "\n", "", "", "return", "pp_result", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.det_recog_pp": [[584, 612], ["zip", "final_results.append", "mmcv.dump", "print", "mmocr.core.visualize.det_recog_show_result", "mmocr.core.visualize.det_recog_show_result", "mmcv.imshow"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.det_recog_show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.det_recog_show_result"], ["", "def", "det_recog_pp", "(", "self", ",", "result", ")", ":", "\n", "        ", "final_results", "=", "[", "]", "\n", "args", "=", "self", ".", "args", "\n", "for", "arr", ",", "output", ",", "export", ",", "det_recog_result", "in", "zip", "(", "\n", "args", ".", "arrays", ",", "args", ".", "output", ",", "args", ".", "export", ",", "result", ")", ":", "\n", "            ", "if", "output", "or", "args", ".", "imshow", ":", "\n", "                ", "if", "self", ".", "kie_model", ":", "\n", "                    ", "res_img", "=", "det_recog_show_result", "(", "arr", ",", "det_recog_result", ")", "\n", "", "else", ":", "\n", "                    ", "res_img", "=", "det_recog_show_result", "(", "\n", "arr", ",", "det_recog_result", ",", "out_file", "=", "output", ")", "\n", "", "if", "args", ".", "imshow", "and", "not", "self", ".", "kie_model", ":", "\n", "                    ", "mmcv", ".", "imshow", "(", "res_img", ",", "'inference results'", ")", "\n", "", "", "if", "not", "args", ".", "details", ":", "\n", "                ", "simple_res", "=", "{", "}", "\n", "simple_res", "[", "'filename'", "]", "=", "det_recog_result", "[", "'filename'", "]", "\n", "simple_res", "[", "'text'", "]", "=", "[", "\n", "x", "[", "'text'", "]", "for", "x", "in", "det_recog_result", "[", "'result'", "]", "\n", "]", "\n", "final_result", "=", "simple_res", "\n", "", "else", ":", "\n", "                ", "final_result", "=", "det_recog_result", "\n", "", "if", "export", ":", "\n", "                ", "mmcv", ".", "dump", "(", "final_result", ",", "export", ",", "indent", "=", "4", ")", "\n", "", "if", "args", ".", "print_result", ":", "\n", "                ", "print", "(", "final_result", ",", "end", "=", "'\\n\\n'", ")", "\n", "", "final_results", ".", "append", "(", "final_result", ")", "\n", "", "return", "final_results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_pp": [[614, 633], ["zip", "mmcv.dump", "print", "mmocr.models.textdet.detectors.TextDetectorMixin().show_result", "mmcv.imshow", "mmocr.models.textrecog.recognizer.BaseRecognizer.show_result", "model.show_result", "mmocr.models.textdet.detectors.TextDetectorMixin"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "single_pp", "(", "self", ",", "result", ",", "model", ")", ":", "\n", "        ", "for", "arr", ",", "output", ",", "export", ",", "res", "in", "zip", "(", "self", ".", "args", ".", "arrays", ",", "self", ".", "args", ".", "output", ",", "\n", "self", ".", "args", ".", "export", ",", "result", ")", ":", "\n", "            ", "if", "export", ":", "\n", "                ", "mmcv", ".", "dump", "(", "res", ",", "export", ",", "indent", "=", "4", ")", "\n", "", "if", "output", "or", "self", ".", "args", ".", "imshow", ":", "\n", "                ", "if", "model", "==", "'Tesseract_det'", ":", "\n", "                    ", "res_img", "=", "TextDetectorMixin", "(", "show_score", "=", "False", ")", ".", "show_result", "(", "\n", "arr", ",", "res", ",", "out_file", "=", "output", ")", "\n", "", "elif", "model", "==", "'Tesseract_recog'", ":", "\n", "                    ", "res_img", "=", "BaseRecognizer", ".", "show_result", "(", "\n", "arr", ",", "res", ",", "out_file", "=", "output", ")", "\n", "", "else", ":", "\n", "                    ", "res_img", "=", "model", ".", "show_result", "(", "arr", ",", "res", ",", "out_file", "=", "output", ")", "\n", "", "if", "self", ".", "args", ".", "imshow", ":", "\n", "                    ", "mmcv", ".", "imshow", "(", "res_img", ",", "'inference results'", ")", "\n", "", "", "if", "self", ".", "args", ".", "print_result", ":", "\n", "                ", "print", "(", "res", ",", "end", "=", "'\\n\\n'", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.generate_kie_labels": [[634, 652], ["torch.max", "max_idx.numpy().tolist", "max_value.numpy().tolist", "range", "mmocr.utils.fileio.list_from_file", "result[].detach().cpu", "len", "str", "labels.append", "line.strip().split", "max_idx.numpy", "max_value.numpy", "result[].detach", "line.strip"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["", "def", "generate_kie_labels", "(", "self", ",", "result", ",", "boxes", ",", "class_list", ")", ":", "\n", "        ", "idx_to_cls", "=", "{", "}", "\n", "if", "class_list", "is", "not", "None", ":", "\n", "            ", "for", "line", "in", "list_from_file", "(", "class_list", ")", ":", "\n", "                ", "class_idx", ",", "class_label", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "idx_to_cls", "[", "class_idx", "]", "=", "class_label", "\n", "\n", "", "", "max_value", ",", "max_idx", "=", "torch", ".", "max", "(", "result", "[", "'nodes'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "-", "1", ")", "\n", "node_pred_label", "=", "max_idx", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "node_pred_score", "=", "max_value", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "boxes", ")", ")", ":", "\n", "            ", "pred_label", "=", "str", "(", "node_pred_label", "[", "i", "]", ")", "\n", "if", "pred_label", "in", "idx_to_cls", ":", "\n", "                ", "pred_label", "=", "idx_to_cls", "[", "pred_label", "]", "\n", "", "pred_score", "=", "node_pred_score", "[", "i", "]", "\n", "labels", ".", "append", "(", "(", "pred_label", ",", "pred_score", ")", ")", "\n", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.visualize_kie_output": [[653, 674], ["data[].data.numpy().tolist", "img_meta.get", "model.show_result", "img_tensor.cpu().numpy().transpose", "data[].data.numpy", "mmcv.image.misc.tensor2imgs", "img_tensor.cpu().numpy", "img_tensor.unsqueeze", "img_meta.get", "img_tensor.cpu"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "visualize_kie_output", "(", "self", ",", "\n", "model", ",", "\n", "data", ",", "\n", "result", ",", "\n", "out_file", "=", "None", ",", "\n", "show", "=", "False", ")", ":", "\n", "        ", "\"\"\"Visualizes KIE output.\"\"\"", "\n", "img_tensor", "=", "data", "[", "'img'", "]", ".", "data", "\n", "img_meta", "=", "data", "[", "'img_metas'", "]", ".", "data", "\n", "gt_bboxes", "=", "data", "[", "'gt_bboxes'", "]", ".", "data", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "if", "img_tensor", ".", "dtype", "==", "torch", ".", "uint8", ":", "\n", "# The img tensor is the raw input not being normalized", "\n", "# (For SDMGR non-visual)", "\n", "            ", "img", "=", "img_tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "tensor2imgs", "(", "\n", "img_tensor", ".", "unsqueeze", "(", "0", ")", ",", "**", "img_meta", ".", "get", "(", "'img_norm_cfg'", ",", "{", "}", ")", ")", "[", "0", "]", "\n", "", "h", ",", "w", ",", "_", "=", "img_meta", ".", "get", "(", "'img_shape'", ",", "img", ".", "shape", ")", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "model", ".", "show_result", "(", "\n", "img_show", ",", "result", ",", "gt_bboxes", ",", "show", "=", "show", ",", "out_file", "=", "out_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.det_recog_kie_inference": [[676, 783], ["ocr.MMOCR.single_inference", "zip", "mmocr.datasets.kie_dataset.KIEDataset", "end2end_res.append", "float", "mmocr.datasets.pipelines.crop.crop_img", "img_e2e_res[].append", "ocr.MMOCR.single_inference", "enumerate", "mmocr.utils.box_util.stitch_boxes_into_lines", "copy.deepcopy", "enumerate", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info.get", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info.get", "mmocr.apis.inference.model_inference", "ocr.MMOCR.visualize_kie_output", "data[].data.numpy().tolist", "ocr.MMOCR.generate_kie_labels", "range", "round", "len", "min", "min", "max", "max", "box_imgs.append", "isinstance", "isinstance", "min", "min", "max", "max", "len", "ocr.MMOCR.single_inference", "mmocr.apis.inference.model_inference", "data[].data.numpy", "sum", "max", "sum", "max", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.stitch_boxes_into_lines", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.visualize_kie_output", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.generate_kie_labels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "def", "det_recog_kie_inference", "(", "self", ",", "det_model", ",", "recog_model", ",", "kie_model", "=", "None", ")", ":", "\n", "        ", "end2end_res", "=", "[", "]", "\n", "# Find bounding boxes in the images (text detection)", "\n", "det_result", "=", "self", ".", "single_inference", "(", "det_model", ",", "self", ".", "args", ".", "arrays", ",", "\n", "self", ".", "args", ".", "batch_mode", ",", "\n", "self", ".", "args", ".", "det_batch_size", ")", "\n", "bboxes_list", "=", "[", "res", "[", "'boundary_result'", "]", "for", "res", "in", "det_result", "]", "\n", "\n", "if", "kie_model", ":", "\n", "            ", "kie_dataset", "=", "KIEDataset", "(", "\n", "dict_file", "=", "kie_model", ".", "cfg", ".", "data", ".", "test", ".", "dict_file", ")", "\n", "\n", "# For each bounding box, the image is cropped and", "\n", "# sent to the recognition model either one by one", "\n", "# or all together depending on the batch_mode", "\n", "", "for", "filename", ",", "arr", ",", "bboxes", ",", "out_file", "in", "zip", "(", "self", ".", "args", ".", "filenames", ",", "\n", "self", ".", "args", ".", "arrays", ",", "\n", "bboxes_list", ",", "\n", "self", ".", "args", ".", "output", ")", ":", "\n", "            ", "img_e2e_res", "=", "{", "}", "\n", "img_e2e_res", "[", "'filename'", "]", "=", "filename", "\n", "img_e2e_res", "[", "'result'", "]", "=", "[", "]", "\n", "box_imgs", "=", "[", "]", "\n", "for", "bbox", "in", "bboxes", ":", "\n", "                ", "box_res", "=", "{", "}", "\n", "box_res", "[", "'box'", "]", "=", "[", "round", "(", "x", ")", "for", "x", "in", "bbox", "[", ":", "-", "1", "]", "]", "\n", "box_res", "[", "'box_score'", "]", "=", "float", "(", "bbox", "[", "-", "1", "]", ")", "\n", "box", "=", "bbox", "[", ":", "8", "]", "\n", "if", "len", "(", "bbox", ")", ">", "9", ":", "\n", "                    ", "min_x", "=", "min", "(", "bbox", "[", "0", ":", "-", "1", ":", "2", "]", ")", "\n", "min_y", "=", "min", "(", "bbox", "[", "1", ":", "-", "1", ":", "2", "]", ")", "\n", "max_x", "=", "max", "(", "bbox", "[", "0", ":", "-", "1", ":", "2", "]", ")", "\n", "max_y", "=", "max", "(", "bbox", "[", "1", ":", "-", "1", ":", "2", "]", ")", "\n", "box", "=", "[", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", "\n", "]", "\n", "", "box_img", "=", "crop_img", "(", "arr", ",", "box", ")", "\n", "if", "self", ".", "args", ".", "batch_mode", ":", "\n", "                    ", "box_imgs", ".", "append", "(", "box_img", ")", "\n", "", "else", ":", "\n", "                    ", "if", "recog_model", "==", "'Tesseract_recog'", ":", "\n", "                        ", "recog_result", "=", "self", ".", "single_inference", "(", "\n", "recog_model", ",", "box_img", ",", "batch_mode", "=", "True", ")", "\n", "", "else", ":", "\n", "                        ", "recog_result", "=", "model_inference", "(", "recog_model", ",", "box_img", ")", "\n", "", "text", "=", "recog_result", "[", "'text'", "]", "\n", "text_score", "=", "recog_result", "[", "'score'", "]", "\n", "if", "isinstance", "(", "text_score", ",", "list", ")", ":", "\n", "                        ", "text_score", "=", "sum", "(", "text_score", ")", "/", "max", "(", "1", ",", "len", "(", "text", ")", ")", "\n", "", "box_res", "[", "'text'", "]", "=", "text", "\n", "box_res", "[", "'text_score'", "]", "=", "text_score", "\n", "", "img_e2e_res", "[", "'result'", "]", ".", "append", "(", "box_res", ")", "\n", "\n", "", "if", "self", ".", "args", ".", "batch_mode", ":", "\n", "                ", "recog_results", "=", "self", ".", "single_inference", "(", "\n", "recog_model", ",", "box_imgs", ",", "True", ",", "self", ".", "args", ".", "recog_batch_size", ")", "\n", "for", "i", ",", "recog_result", "in", "enumerate", "(", "recog_results", ")", ":", "\n", "                    ", "text", "=", "recog_result", "[", "'text'", "]", "\n", "text_score", "=", "recog_result", "[", "'score'", "]", "\n", "if", "isinstance", "(", "text_score", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "                        ", "text_score", "=", "sum", "(", "text_score", ")", "/", "max", "(", "1", ",", "len", "(", "text", ")", ")", "\n", "", "img_e2e_res", "[", "'result'", "]", "[", "i", "]", "[", "'text'", "]", "=", "text", "\n", "img_e2e_res", "[", "'result'", "]", "[", "i", "]", "[", "'text_score'", "]", "=", "text_score", "\n", "\n", "", "", "if", "self", ".", "args", ".", "merge", ":", "\n", "                ", "img_e2e_res", "[", "'result'", "]", "=", "stitch_boxes_into_lines", "(", "\n", "img_e2e_res", "[", "'result'", "]", ",", "self", ".", "args", ".", "merge_xdist", ",", "0.5", ")", "\n", "\n", "", "if", "kie_model", ":", "\n", "                ", "annotations", "=", "copy", ".", "deepcopy", "(", "img_e2e_res", "[", "'result'", "]", ")", "\n", "# Customized for kie_dataset, which", "\n", "# assumes that boxes are represented by only 4 points", "\n", "for", "i", ",", "ann", "in", "enumerate", "(", "annotations", ")", ":", "\n", "                    ", "min_x", "=", "min", "(", "ann", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", "\n", "min_y", "=", "min", "(", "ann", "[", "'box'", "]", "[", "1", ":", ":", "2", "]", ")", "\n", "max_x", "=", "max", "(", "ann", "[", "'box'", "]", "[", ":", ":", "2", "]", ")", "\n", "max_y", "=", "max", "(", "ann", "[", "'box'", "]", "[", "1", ":", ":", "2", "]", ")", "\n", "annotations", "[", "i", "]", "[", "'box'", "]", "=", "[", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", "\n", "]", "\n", "", "ann_info", "=", "kie_dataset", ".", "_parse_anno_info", "(", "annotations", ")", "\n", "ann_info", "[", "'ori_bboxes'", "]", "=", "ann_info", ".", "get", "(", "'ori_bboxes'", ",", "\n", "ann_info", "[", "'bboxes'", "]", ")", "\n", "ann_info", "[", "'gt_bboxes'", "]", "=", "ann_info", ".", "get", "(", "'gt_bboxes'", ",", "\n", "ann_info", "[", "'bboxes'", "]", ")", "\n", "kie_result", ",", "data", "=", "model_inference", "(", "\n", "kie_model", ",", "\n", "arr", ",", "\n", "ann", "=", "ann_info", ",", "\n", "return_data", "=", "True", ",", "\n", "batch_mode", "=", "self", ".", "args", ".", "batch_mode", ")", "\n", "# visualize KIE results", "\n", "self", ".", "visualize_kie_output", "(", "\n", "kie_model", ",", "\n", "data", ",", "\n", "kie_result", ",", "\n", "out_file", "=", "out_file", ",", "\n", "show", "=", "self", ".", "args", ".", "imshow", ")", "\n", "gt_bboxes", "=", "data", "[", "'gt_bboxes'", "]", ".", "data", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "labels", "=", "self", ".", "generate_kie_labels", "(", "kie_result", ",", "gt_bboxes", ",", "\n", "kie_model", ".", "class_list", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "gt_bboxes", ")", ")", ":", "\n", "                    ", "img_e2e_res", "[", "'result'", "]", "[", "i", "]", "[", "'label'", "]", "=", "labels", "[", "i", "]", "[", "0", "]", "\n", "img_e2e_res", "[", "'result'", "]", "[", "i", "]", "[", "'label_score'", "]", "=", "labels", "[", "i", "]", "[", "1", "]", "\n", "\n", "", "", "end2end_res", ".", "append", "(", "img_e2e_res", ")", "\n", "", "return", "end2end_res", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference": [[785, 810], ["ocr.MMOCR.tesseract_det_inference", "ocr.MMOCR.single_inference.inference"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.tesseract_det_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr_handler.MMOCRHandler.inference"], ["", "def", "single_inference", "(", "self", ",", "model", ",", "arrays", ",", "batch_mode", ",", "batch_size", "=", "0", ")", ":", "\n", "\n", "        ", "def", "inference", "(", "m", ",", "a", ",", "**", "kwargs", ")", ":", "\n", "            ", "if", "model", "==", "'Tesseract_det'", ":", "\n", "                ", "return", "self", ".", "tesseract_det_inference", "(", "a", ")", "\n", "", "elif", "model", "==", "'Tesseract_recog'", ":", "\n", "                ", "return", "self", ".", "tesseract_recog_inference", "(", "a", ")", "\n", "", "else", ":", "\n", "                ", "return", "model_inference", "(", "m", ",", "a", ",", "**", "kwargs", ")", "\n", "\n", "", "", "result", "=", "[", "]", "\n", "if", "batch_mode", ":", "\n", "            ", "if", "batch_size", "==", "0", ":", "\n", "                ", "result", "=", "inference", "(", "model", ",", "arrays", ",", "batch_mode", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "n", "=", "batch_size", "\n", "arr_chunks", "=", "[", "\n", "arrays", "[", "i", ":", "i", "+", "n", "]", "for", "i", "in", "range", "(", "0", ",", "len", "(", "arrays", ")", ",", "n", ")", "\n", "]", "\n", "for", "chunk", "in", "arr_chunks", ":", "\n", "                    ", "result", ".", "extend", "(", "inference", "(", "model", ",", "chunk", ",", "batch_mode", "=", "True", ")", ")", "\n", "", "", "", "else", ":", "\n", "            ", "for", "arr", "in", "arrays", ":", "\n", "                ", "result", ".", "append", "(", "inference", "(", "model", ",", "arr", ",", "batch_mode", "=", "False", ")", ")", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR._args_processing": [[812, 868], ["isinstance", "isinstance", "isinstance", "len", "pathlib.Path", "pathlib.Path.is_dir", "isinstance", "mmcv.imread", "pathlib.Path", "pathlib.Path.is_dir", "pathlib.Path", "all", "AssertionError", "str", "str", "str", "str", "str", "range", "str", "str", "AssertionError", "isinstance", "pathlib.Path.glob", "pathlib.Path", "len"], "methods", ["None"], ["", "def", "_args_processing", "(", "self", ",", "args", ")", ":", "\n", "# Check if the input is a list/tuple that", "\n", "# contains only np arrays or strings", "\n", "        ", "if", "isinstance", "(", "args", ".", "img", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "img_list", "=", "args", ".", "img", "\n", "if", "not", "all", "(", "[", "isinstance", "(", "x", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", "for", "x", "in", "args", ".", "img", "]", ")", ":", "\n", "                ", "raise", "AssertionError", "(", "'Images must be strings or numpy arrays'", ")", "\n", "\n", "# Create a list of the images", "\n", "", "", "if", "isinstance", "(", "args", ".", "img", ",", "str", ")", ":", "\n", "            ", "img_path", "=", "Path", "(", "args", ".", "img", ")", "\n", "if", "img_path", ".", "is_dir", "(", ")", ":", "\n", "                ", "img_list", "=", "[", "str", "(", "x", ")", "for", "x", "in", "img_path", ".", "glob", "(", "'*'", ")", "]", "\n", "", "else", ":", "\n", "                ", "img_list", "=", "[", "str", "(", "img_path", ")", "]", "\n", "", "", "elif", "isinstance", "(", "args", ".", "img", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "img_list", "=", "[", "args", ".", "img", "]", "\n", "\n", "# Read all image(s) in advance to reduce wasted time", "\n", "# re-reading the images for visualization output", "\n", "", "args", ".", "arrays", "=", "[", "mmcv", ".", "imread", "(", "x", ")", "for", "x", "in", "img_list", "]", "\n", "\n", "# Create a list of filenames (used for output images and result files)", "\n", "if", "isinstance", "(", "img_list", "[", "0", "]", ",", "str", ")", ":", "\n", "            ", "args", ".", "filenames", "=", "[", "str", "(", "Path", "(", "x", ")", ".", "stem", ")", "for", "x", "in", "img_list", "]", "\n", "", "else", ":", "\n", "            ", "args", ".", "filenames", "=", "[", "str", "(", "x", ")", "for", "x", "in", "range", "(", "len", "(", "img_list", ")", ")", "]", "\n", "\n", "# If given an output argument, create a list of output image filenames", "\n", "", "num_res", "=", "len", "(", "img_list", ")", "\n", "if", "args", ".", "output", ":", "\n", "            ", "output_path", "=", "Path", "(", "args", ".", "output", ")", "\n", "if", "output_path", ".", "is_dir", "(", ")", ":", "\n", "                ", "args", ".", "output", "=", "[", "\n", "str", "(", "output_path", "/", "f'out_{x}.png'", ")", "for", "x", "in", "args", ".", "filenames", "\n", "]", "\n", "", "else", ":", "\n", "                ", "args", ".", "output", "=", "[", "str", "(", "args", ".", "output", ")", "]", "\n", "if", "args", ".", "batch_mode", ":", "\n", "                    ", "raise", "AssertionError", "(", "'Output of multiple images inference'", "\n", "' must be a directory'", ")", "\n", "", "", "", "else", ":", "\n", "            ", "args", ".", "output", "=", "[", "None", "]", "*", "num_res", "\n", "\n", "# If given an export argument, create a list of", "\n", "# result filenames for each image", "\n", "", "if", "args", ".", "export", ":", "\n", "            ", "export_path", "=", "Path", "(", "args", ".", "export", ")", "\n", "args", ".", "export", "=", "[", "\n", "str", "(", "export_path", "/", "f'out_{x}.{args.export_format}'", ")", "\n", "for", "x", "in", "args", ".", "filenames", "\n", "]", "\n", "", "else", ":", "\n", "            ", "args", ".", "export", "=", "[", "None", "]", "*", "num_res", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.parse_args": [[37, 171], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "warnings.warn", "warnings.warn", "os.path.join", "os.path.samefile", "str", "os.path.join", "pathlib.Path.cwd", "str", "pathlib.Path.cwd"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'img'", ",", "type", "=", "str", ",", "help", "=", "'Input image file or folder path.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Output file/folder name for visualization'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--det'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "'PANet_IC15'", ",", "\n", "help", "=", "'Pretrained text detection algorithm'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--det-config'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Path to the custom config file of the selected det model. It '", "\n", "'overrides the settings in det'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--det-ckpt'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Path to the custom checkpoint file of the selected det model. '", "\n", "'It overrides the settings in det'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--recog'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "'SEG'", ",", "\n", "help", "=", "'Pretrained text recognition algorithm'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--recog-config'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Path to the custom config file of the selected recog model. It'", "\n", "'overrides the settings in recog'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--recog-ckpt'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Path to the custom checkpoint file of the selected recog model. '", "\n", "'It overrides the settings in recog'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--kie'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Pretrained key information extraction algorithm'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--kie-config'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Path to the custom config file of the selected kie model. It'", "\n", "'overrides the settings in kie'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--kie-ckpt'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Path to the custom checkpoint file of the selected kie model. '", "\n", "'It overrides the settings in kie'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--config-dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "os", ".", "path", ".", "join", "(", "str", "(", "Path", ".", "cwd", "(", ")", ")", ",", "'configs/'", ")", ",", "\n", "help", "=", "'Path to the config directory where all the config files '", "\n", "'are located. Defaults to \"configs/\"'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--batch-mode'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether use batch mode for inference'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--recog-batch-size'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "'Batch size for text recognition'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--det-batch-size'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "'Batch size for text detection'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--single-batch-size'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "0", ",", "\n", "help", "=", "'Batch size for separate det/recog inference'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "None", ",", "help", "=", "'Device used for inference.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--export'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "''", ",", "\n", "help", "=", "'Folder where the results of each image are exported'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--export-format'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "'json'", ",", "\n", "help", "=", "'Format of the exported result file(s)'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--details'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether include the text boxes coordinates and confidence values'", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--imshow'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether show image with OpenCV.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--print-result'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Prints the recognised text'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--merge'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Merge neighboring boxes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--merge-xdist'", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "20", ",", "\n", "help", "=", "'The maximum x-axis distance to merge boxes'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "args", ".", "det", "==", "'None'", ":", "\n", "        ", "args", ".", "det", "=", "None", "\n", "", "if", "args", ".", "recog", "==", "'None'", ":", "\n", "        ", "args", ".", "recog", "=", "None", "\n", "# Warnings", "\n", "", "if", "args", ".", "merge", "and", "not", "(", "args", ".", "det", "and", "args", ".", "recog", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "'Box merging will not work if the script is not'", "\n", "' running in detection + recognition mode.'", ",", "UserWarning", ")", "\n", "", "if", "not", "os", ".", "path", ".", "samefile", "(", "args", ".", "config_dir", ",", "os", ".", "path", ".", "join", "(", "str", "(", "\n", "Path", ".", "cwd", "(", ")", ")", ")", ")", "and", "(", "args", ".", "det_config", "!=", "''", "\n", "or", "args", ".", "recog_config", "!=", "''", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "'config_dir will be overridden by det-config or recog-config.'", ",", "\n", "UserWarning", ")", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.main": [[871, 875], ["ocr.parse_args", "ocr.MMOCR", "ocr.MMOCR.readtext", "vars", "vars"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.readtext"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "ocr", "=", "MMOCR", "(", "**", "vars", "(", "args", ")", ")", "\n", "ocr", ".", "readtext", "(", "**", "vars", "(", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.check_image_is_valid": [[13, 22], ["numpy.frombuffer", "cv2.imdecode"], "function", ["None"], ["def", "check_image_is_valid", "(", "imageBin", ")", ":", "\n", "    ", "if", "imageBin", "is", "None", ":", "\n", "        ", "return", "False", "\n", "", "imageBuf", "=", "np", ".", "frombuffer", "(", "imageBin", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "img", "=", "cv2", ".", "imdecode", "(", "imageBuf", ",", "cv2", ".", "IMREAD_GRAYSCALE", ")", "\n", "imgH", ",", "imgW", "=", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", "\n", "if", "imgH", "*", "imgW", "==", "0", ":", "\n", "        ", "return", "False", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.parse_line": [[24, 32], ["json.loads.split", "json.loads"], "function", ["None"], ["", "def", "parse_line", "(", "line", ",", "format", ")", ":", "\n", "    ", "if", "format", "==", "'txt'", ":", "\n", "        ", "img_name", ",", "text", "=", "line", ".", "split", "(", "' '", ")", "\n", "", "else", ":", "\n", "        ", "line", "=", "json", ".", "loads", "(", "line", ")", "\n", "img_name", "=", "line", "[", "'filename'", "]", "\n", "text", "=", "line", "[", "'text'", "]", "\n", "", "return", "img_name", ",", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.write_cache": [[34, 38], ["env.begin", "txn.cursor", "txn.cursor.putmulti"], "function", ["None"], ["", "def", "write_cache", "(", "env", ",", "cache", ")", ":", "\n", "    ", "with", "env", ".", "begin", "(", "write", "=", "True", ")", "as", "txn", ":", "\n", "        ", "cursor", "=", "txn", ".", "cursor", "(", ")", "\n", "cursor", ".", "putmulti", "(", "cache", ",", "dupdata", "=", "False", ",", "overwrite", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.recog2lmdb": [[40, 129], ["os.makedirs", "os.makedirs", "lmdb.open", "mmocr.utils.list_from_file", "len", "cache.append", "lmdb_util.write_cache", "print", "lmdb_util.parse_line", "os.basename().split", "json.dumps", "cache.append", "os.join", "cache.append", "cache.append", "lmdb_util.write_cache", "print", "str().encode", "dict", "os.exists", "print", "open", "f.read", "os.basename", "json.dumps.encode", "text.encode", "str", "lmdb_util.check_image_is_valid", "print", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.write_cache", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.parse_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.write_cache", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.check_image_is_valid"], ["", "", "def", "recog2lmdb", "(", "img_root", ",", "\n", "label_path", ",", "\n", "output", ",", "\n", "label_format", "=", "'txt'", ",", "\n", "label_only", "=", "False", ",", "\n", "batch_size", "=", "1000", ",", "\n", "encoding", "=", "'utf-8'", ",", "\n", "lmdb_map_size", "=", "109951162776", ",", "\n", "verify", "=", "True", ")", ":", "\n", "    ", "\"\"\"Create text recognition dataset to LMDB format.\n\n    Args:\n        img_root (str): Path to images.\n        label_path (str): Path to label file.\n        output (str): LMDB output path.\n        label_format (str): Format of the label file, either txt or jsonl.\n        label_only (bool): Only convert label to lmdb format.\n        batch_size (int): Number of files written to the cache each time.\n        encoding (str): Label encoding method.\n        lmdb_map_size (int): Maximum size database may grow to.\n        verify (bool): If true, check the validity of\n            every image.Defaults to True.\n\n    E.g.\n    This function supports MMOCR's recognition data format and the label file\n    can be txt or jsonl, as follows:\n\n        \u251c\u2500\u2500img_root\n        |      |\u2014\u2014 img1.jpg\n        |      |\u2014\u2014 img2.jpg\n        |      |\u2014\u2014 ...\n        |\u2014\u2014label.txt (or label.jsonl)\n\n        label.txt: img1.jpg HELLO\n                   img2.jpg WORLD\n                   ...\n\n        label.jsonl: {'filename':'img1.jpg', 'text':'HELLO'}\n                     {'filename':'img2.jpg', 'text':'WORLD'}\n                     ...\n    \"\"\"", "\n", "# check label format", "\n", "assert", "osp", ".", "basename", "(", "label_path", ")", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "==", "label_format", "\n", "# create lmdb env", "\n", "os", ".", "makedirs", "(", "output", ",", "exist_ok", "=", "True", ")", "\n", "env", "=", "lmdb", ".", "open", "(", "output", ",", "map_size", "=", "lmdb_map_size", ")", "\n", "# load label file", "\n", "anno_list", "=", "list_from_file", "(", "label_path", ",", "encoding", "=", "encoding", ")", "\n", "cache", "=", "[", "]", "\n", "# index start from 1", "\n", "cnt", "=", "1", "\n", "n_samples", "=", "len", "(", "anno_list", ")", "\n", "for", "anno", "in", "anno_list", ":", "\n", "        ", "label_key", "=", "'label-%09d'", ".", "encode", "(", "encoding", ")", "%", "cnt", "\n", "img_name", ",", "text", "=", "parse_line", "(", "anno", ",", "label_format", ")", "\n", "if", "label_only", ":", "\n", "# convert only labels to lmdb", "\n", "            ", "line", "=", "json", ".", "dumps", "(", "\n", "dict", "(", "filename", "=", "img_name", ",", "text", "=", "text", ")", ",", "ensure_ascii", "=", "False", ")", "\n", "cache", ".", "append", "(", "(", "label_key", ",", "line", ".", "encode", "(", "encoding", ")", ")", ")", "\n", "", "else", ":", "\n", "# convert both images and labels to lmdb", "\n", "            ", "img_path", "=", "osp", ".", "join", "(", "img_root", ",", "img_name", ")", "\n", "if", "not", "osp", ".", "exists", "(", "img_path", ")", ":", "\n", "                ", "print", "(", "'%s does not exist'", "%", "img_path", ")", "\n", "continue", "\n", "", "with", "open", "(", "img_path", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "image_bin", "=", "f", ".", "read", "(", ")", "\n", "", "if", "verify", ":", "\n", "                ", "try", ":", "\n", "                    ", "if", "not", "check_image_is_valid", "(", "image_bin", ")", ":", "\n", "                        ", "print", "(", "'%s is not a valid image'", "%", "img_path", ")", "\n", "continue", "\n", "", "", "except", "Exception", ":", "\n", "                    ", "print", "(", "'error occurred at '", ",", "img_name", ")", "\n", "", "", "image_key", "=", "'image-%09d'", ".", "encode", "(", "encoding", ")", "%", "cnt", "\n", "cache", ".", "append", "(", "(", "image_key", ",", "image_bin", ")", ")", "\n", "cache", ".", "append", "(", "(", "label_key", ",", "text", ".", "encode", "(", "encoding", ")", ")", ")", "\n", "\n", "", "if", "cnt", "%", "batch_size", "==", "0", ":", "\n", "            ", "write_cache", "(", "env", ",", "cache", ")", "\n", "cache", "=", "[", "]", "\n", "print", "(", "'Written %d / %d'", "%", "(", "cnt", ",", "n_samples", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "", "n_samples", "=", "cnt", "-", "1", "\n", "cache", ".", "append", "(", "\n", "(", "'num-samples'", ".", "encode", "(", "encoding", ")", ",", "str", "(", "n_samples", ")", ".", "encode", "(", "encoding", ")", ")", ")", "\n", "write_cache", "(", "env", ",", "cache", ")", "\n", "print", "(", "'Created lmdb dataset with %d samples'", "%", "n_samples", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.data_convert_util.convert_annotations": [[5, 43], ["isinstance", "isinstance", "dict", "dict", "out_json[].append", "mmcv.dump", "image_info.pop", "out_json[].append", "len", "dict.pop", "out_json[].append"], "function", ["None"], ["def", "convert_annotations", "(", "image_infos", ",", "out_json_name", ")", ":", "\n", "    ", "\"\"\"Convert the annotation into coco style.\n\n    Args:\n        image_infos(list): The list of image information dicts\n        out_json_name(str): The output json filename\n\n    Returns:\n        out_json(dict): The coco style dict\n    \"\"\"", "\n", "assert", "isinstance", "(", "image_infos", ",", "list", ")", "\n", "assert", "isinstance", "(", "out_json_name", ",", "str", ")", "\n", "assert", "out_json_name", "\n", "\n", "out_json", "=", "dict", "(", ")", "\n", "img_id", "=", "0", "\n", "ann_id", "=", "0", "\n", "out_json", "[", "'images'", "]", "=", "[", "]", "\n", "out_json", "[", "'categories'", "]", "=", "[", "]", "\n", "out_json", "[", "'annotations'", "]", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "image_info", "[", "'id'", "]", "=", "img_id", "\n", "anno_infos", "=", "image_info", ".", "pop", "(", "'anno_info'", ")", "\n", "out_json", "[", "'images'", "]", ".", "append", "(", "image_info", ")", "\n", "for", "anno_info", "in", "anno_infos", ":", "\n", "            ", "anno_info", "[", "'image_id'", "]", "=", "img_id", "\n", "anno_info", "[", "'id'", "]", "=", "ann_id", "\n", "out_json", "[", "'annotations'", "]", ".", "append", "(", "anno_info", ")", "\n", "ann_id", "+=", "1", "\n", "", "img_id", "+=", "1", "\n", "", "cat", "=", "dict", "(", "id", "=", "1", ",", "name", "=", "'text'", ")", "\n", "out_json", "[", "'categories'", "]", ".", "append", "(", "cat", ")", "\n", "\n", "if", "len", "(", "out_json", "[", "'annotations'", "]", ")", "==", "0", ":", "\n", "        ", "out_json", ".", "pop", "(", "'annotations'", ")", "\n", "", "mmcv", ".", "dump", "(", "out_json", ",", "out_json_name", ")", "\n", "\n", "return", "out_json", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend.__init__": [[21, 58], ["backend.LmdbAnnFileBackend._get_env", "backend.LmdbAnnFileBackend.begin", "int", "txn.get", "txn.get().decode", "warnings.warn", "int", "image_key.encode", "txn.get().decode", "txn.get", "txn.get"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend._get_env", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode"], ["def", "__init__", "(", "self", ",", "lmdb_path", ",", "encoding", "=", "'utf8'", ")", ":", "\n", "        ", "\"\"\"Currently we support two lmdb formats, one is the lmdb file with\n        only labels generated by txt2lmdb (deprecated), and one is the lmdb\n        file generated by recog2lmdb.\n\n        The former stores string in 'filename text' format directly in lmdb,\n        while the latter uses a more reasonable image_key as well as label_key\n        for querying.\n        \"\"\"", "\n", "self", ".", "lmdb_path", "=", "lmdb_path", "\n", "self", ".", "encoding", "=", "encoding", "\n", "self", ".", "deprecated_format", "=", "False", "\n", "env", "=", "self", ".", "_get_env", "(", ")", "\n", "with", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "total_number", "=", "int", "(", "\n", "txn", ".", "get", "(", "'num-samples'", ".", "encode", "(", "'utf-8'", ")", ")", ".", "decode", "(", "\n", "self", ".", "encoding", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "'DeprecationWarning: The lmdb dataset generated with '", "\n", "'txt2lmdb will be deprecate, please use the latest '", "\n", "'tools/data/utils/recog2lmdb to generate lmdb dataset. '", "\n", "'See https://mmocr.readthedocs.io/en/latest/tools.html#'", "\n", "'convert-text-recognition-dataset-to-lmdb-format for '", "\n", "'details.'", ")", "\n", "self", ".", "total_number", "=", "int", "(", "\n", "txn", ".", "get", "(", "'total_number'", ".", "encode", "(", "'utf-8'", ")", ")", ".", "decode", "(", "\n", "self", ".", "encoding", ")", ")", "\n", "self", ".", "deprecated_format", "=", "True", "\n", "# The lmdb file may contain only the label, or it may contain both", "\n", "# the label and the image, so we use image_key here for probing.", "\n", "", "image_key", "=", "f'image-{1:09d}'", "\n", "if", "txn", ".", "get", "(", "image_key", ".", "encode", "(", "encoding", ")", ")", "is", "None", ":", "\n", "                ", "self", ".", "label_only", "=", "True", "\n", "", "else", ":", "\n", "                ", "self", ".", "label_only", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend.__getitem__": [[59, 89], ["hasattr", "backend.LmdbAnnFileBackend._get_env", "backend.LmdbAnnFileBackend.env.begin", "txn.get().decode", "json.dumps.strip().split", "json.dumps", "dict", "txn.get().decode", "txn.get().decode", "json.dumps", "txn.get", "json.dumps.strip", "dict", "str().encode", "txn.get", "txn.get", "label_key.encode", "label_key.encode", "str"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend._get_env", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode"], ["", "", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Retrieve one line from lmdb file by index.\n\n        In order to support space\n        reading, the returned lines are in the form of json, such as\n        '{'filename': 'image1.jpg' ,'text':'HELLO'}'\n        \"\"\"", "\n", "if", "not", "hasattr", "(", "self", ",", "'env'", ")", ":", "\n", "            ", "self", ".", "env", "=", "self", ".", "_get_env", "(", ")", "\n", "\n", "", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "if", "self", ".", "deprecated_format", ":", "\n", "                ", "line", "=", "txn", ".", "get", "(", "str", "(", "index", ")", ".", "encode", "(", "'utf-8'", ")", ")", ".", "decode", "(", "\n", "self", ".", "encoding", ")", "\n", "filename", ",", "text", "=", "line", ".", "strip", "(", "'/n'", ")", ".", "split", "(", "' '", ")", "\n", "line", "=", "json", ".", "dumps", "(", "\n", "dict", "(", "filename", "=", "filename", ",", "text", "=", "text", ")", ",", "ensure_ascii", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "index", "=", "index", "+", "1", "\n", "label_key", "=", "f'label-{index:09d}'", "\n", "if", "self", ".", "label_only", ":", "\n", "                    ", "line", "=", "txn", ".", "get", "(", "label_key", ".", "encode", "(", "'utf-8'", ")", ")", ".", "decode", "(", "\n", "self", ".", "encoding", ")", "\n", "", "else", ":", "\n", "                    ", "img_key", "=", "f'image-{index:09d}'", "\n", "text", "=", "txn", ".", "get", "(", "label_key", ".", "encode", "(", "'utf-8'", ")", ")", ".", "decode", "(", "\n", "self", ".", "encoding", ")", "\n", "line", "=", "json", ".", "dumps", "(", "\n", "dict", "(", "filename", "=", "img_key", ",", "text", "=", "text", ")", ",", "ensure_ascii", "=", "False", ")", "\n", "", "", "return", "line", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend.__len__": [[90, 92], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "total_number", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend._get_env": [[93, 106], ["lmdb.open", "ImportError"], "methods", ["None"], ["", "def", "_get_env", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "lmdb", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "\n", "'Please install lmdb to enable LmdbAnnFileBackend.'", ")", "\n", "", "return", "lmdb", ".", "open", "(", "\n", "self", ".", "lmdb_path", ",", "\n", "max_readers", "=", "1", ",", "\n", "readonly", "=", "True", ",", "\n", "lock", "=", "False", ",", "\n", "readahead", "=", "False", ",", "\n", "meminit", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.LmdbAnnFileBackend.close": [[108, 110], ["backend.LmdbAnnFileBackend.env.close"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "env", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.HardDiskAnnFileBackend.__init__": [[115, 118], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "file_format", "=", "'txt'", ")", ":", "\n", "        ", "assert", "file_format", "in", "[", "'txt'", ",", "'lmdb'", "]", "\n", "self", ".", "file_format", "=", "file_format", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.HardDiskAnnFileBackend.__call__": [[119, 124], ["mmocr.utils.list_from_file", "backend.LmdbAnnFileBackend"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["", "def", "__call__", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "if", "self", ".", "file_format", "==", "'lmdb'", ":", "\n", "            ", "return", "LmdbAnnFileBackend", "(", "ann_file", ")", "\n", "\n", "", "return", "list_from_file", "(", "ann_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.PetrelAnnFileBackend.__init__": [[129, 133], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "file_format", "=", "'txt'", ",", "save_dir", "=", "'tmp_dir'", ")", ":", "\n", "        ", "assert", "file_format", "in", "[", "'txt'", ",", "'lmdb'", "]", "\n", "self", ".", "file_format", "=", "file_format", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.PetrelAnnFileBackend.__call__": [[134, 169], ["mmcv.FileClient", "str().split", "mmocr.digit_version", "mmcv.FileClient.isdir", "mmcv.FileClient.list_dir_or_file", "os.dirname", "os.dirname", "os.basename", "os.basename", "os.join", "os.join", "os.exists", "os.exists", "backend.LmdbAnnFileBackend", "mmocr.digit_version", "Exception", "ann_file.split", "warnings.warn", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "print", "str", "mmcv.FileClient.join_path", "mmcv.FileClient.get", "x.strip", "mmcv.FileClient.get_local_path", "shutil.copy", "os.join", "os.join"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version"], ["", "def", "__call__", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "file_client", "=", "mmcv", ".", "FileClient", "(", "backend", "=", "'petrel'", ")", "\n", "\n", "if", "self", ".", "file_format", "==", "'lmdb'", ":", "\n", "            ", "mmcv_version", "=", "digit_version", "(", "mmcv", ".", "__version__", ")", "\n", "if", "mmcv_version", "<", "digit_version", "(", "'1.3.16'", ")", ":", "\n", "                ", "raise", "Exception", "(", "'Please update mmcv to 1.3.16 or higher '", "\n", "'to enable \"get_local_path\" of \"FileClient\".'", ")", "\n", "", "assert", "file_client", ".", "isdir", "(", "ann_file", ")", "\n", "files", "=", "file_client", ".", "list_dir_or_file", "(", "ann_file", ")", "\n", "\n", "ann_file_rel_path", "=", "ann_file", ".", "split", "(", "'s3://'", ")", "[", "-", "1", "]", "\n", "ann_file_dir", "=", "osp", ".", "dirname", "(", "ann_file_rel_path", ")", "\n", "ann_file_name", "=", "osp", ".", "basename", "(", "ann_file_rel_path", ")", "\n", "local_dir", "=", "osp", ".", "join", "(", "self", ".", "save_dir", ",", "ann_file_dir", ",", "ann_file_name", ")", "\n", "if", "osp", ".", "exists", "(", "local_dir", ")", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "f'local_ann_file: {local_dir} is already existed and '", "\n", "'will be used. If it is not the correct ann_file '", "\n", "'corresponding to {ann_file}, please remove it or '", "\n", "'change \"save_dir\" first then try again.'", ")", "\n", "", "else", ":", "\n", "                ", "os", ".", "makedirs", "(", "local_dir", ",", "exist_ok", "=", "True", ")", "\n", "print", "(", "f'Fetching {ann_file} to {local_dir}...'", ")", "\n", "for", "each_file", "in", "files", ":", "\n", "                    ", "tmp_file_path", "=", "file_client", ".", "join_path", "(", "ann_file", ",", "each_file", ")", "\n", "with", "file_client", ".", "get_local_path", "(", "\n", "tmp_file_path", ")", "as", "local_path", ":", "\n", "                        ", "shutil", ".", "copy", "(", "local_path", ",", "osp", ".", "join", "(", "local_dir", ",", "each_file", ")", ")", "\n", "\n", "", "", "", "return", "LmdbAnnFileBackend", "(", "local_dir", ")", "\n", "\n", "", "lines", "=", "str", "(", "file_client", ".", "get", "(", "ann_file", ")", ",", "encoding", "=", "'utf-8'", ")", ".", "split", "(", "'\\n'", ")", "\n", "\n", "return", "[", "x", "for", "x", "in", "lines", "if", "x", ".", "strip", "(", ")", "!=", "''", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.HTTPAnnFileBackend.__init__": [[174, 177], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "file_format", "=", "'txt'", ")", ":", "\n", "        ", "assert", "file_format", "in", "[", "'txt'", ",", "'lmdb'", "]", "\n", "self", ".", "file_format", "=", "file_format", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.backend.HTTPAnnFileBackend.__call__": [[178, 188], ["mmcv.FileClient", "str().split", "NotImplementedError", "str", "mmcv.FileClient.get", "x.strip"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "file_client", "=", "mmcv", ".", "FileClient", "(", "backend", "=", "'http'", ")", "\n", "\n", "if", "self", ".", "file_format", "==", "'lmdb'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "'Loading lmdb file on http is not supported yet.'", ")", "\n", "\n", "", "lines", "=", "str", "(", "file_client", ".", "get", "(", "ann_file", ")", ",", "encoding", "=", "'utf-8'", ")", ".", "split", "(", "'\\n'", ")", "\n", "\n", "return", "[", "x", "for", "x", "in", "lines", "if", "x", ".", "strip", "(", ")", "!=", "''", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineStrParser.__init__": [[20, 34], ["isinstance", "isinstance", "isinstance", "mmocr.utils.StringStrip", "len", "len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "keys", "=", "[", "'filename'", ",", "'text'", "]", ",", "\n", "keys_idx", "=", "[", "0", ",", "1", "]", ",", "\n", "separator", "=", "' '", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "keys", ",", "list", ")", "\n", "assert", "isinstance", "(", "keys_idx", ",", "list", ")", "\n", "assert", "isinstance", "(", "separator", ",", "str", ")", "\n", "assert", "len", "(", "keys", ")", ">", "0", "\n", "assert", "len", "(", "keys", ")", "==", "len", "(", "keys_idx", ")", "\n", "self", ".", "keys", "=", "keys", "\n", "self", ".", "keys_idx", "=", "keys_idx", "\n", "self", ".", "separator", "=", "separator", "\n", "self", ".", "strip_cls", "=", "StringStrip", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineStrParser.get_item": [[35, 57], ["parser.LineStrParser.strip_cls", "line_str.split.split.split", "enumerate", "len", "len", "warnings.warn", "len", "max", "Exception", "line_str.split.split.split", "max"], "methods", ["None"], ["", "def", "get_item", "(", "self", ",", "data_ret", ",", "index", ")", ":", "\n", "        ", "map_index", "=", "index", "%", "len", "(", "data_ret", ")", "\n", "line_str", "=", "data_ret", "[", "map_index", "]", "\n", "line_str", "=", "self", ".", "strip_cls", "(", "line_str", ")", "\n", "if", "len", "(", "line_str", ".", "split", "(", "' '", ")", ")", ">", "2", ":", "\n", "            ", "msg", "=", "'More than two blank spaces were detected. '", "\n", "msg", "+=", "'Please use LineJsonParser to handle '", "\n", "msg", "+=", "'annotations with blanks. '", "\n", "msg", "+=", "'Check Doc '", "\n", "msg", "+=", "'https://mmocr.readthedocs.io/en/latest/'", "\n", "msg", "+=", "'tutorials/blank_recog.html '", "\n", "msg", "+=", "'for details.'", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "", "line_str", "=", "line_str", ".", "split", "(", "self", ".", "separator", ")", "\n", "if", "len", "(", "line_str", ")", "<=", "max", "(", "self", ".", "keys_idx", ")", ":", "\n", "            ", "raise", "Exception", "(", "\n", "f'key index: {max(self.keys_idx)} out of range: {line_str}'", ")", "\n", "\n", "", "line_info", "=", "{", "}", "\n", "for", "i", ",", "key", "in", "enumerate", "(", "self", ".", "keys", ")", ":", "\n", "            ", "line_info", "[", "key", "]", "=", "line_str", "[", "self", ".", "keys_idx", "[", "i", "]", "]", "\n", "", "return", "line_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.__init__": [[67, 71], ["isinstance", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "keys", "=", "[", "]", ")", ":", "\n", "        ", "assert", "isinstance", "(", "keys", ",", "list", ")", "\n", "assert", "len", "(", "keys", ")", ">", "0", "\n", "self", ".", "keys", "=", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.get_item": [[72, 83], ["json.loads", "len", "Exception"], "methods", ["None"], ["", "def", "get_item", "(", "self", ",", "data_ret", ",", "index", ")", ":", "\n", "        ", "map_index", "=", "index", "%", "len", "(", "data_ret", ")", "\n", "json_str", "=", "data_ret", "[", "map_index", "]", "\n", "line_json_obj", "=", "json", ".", "loads", "(", "json_str", ")", "\n", "line_info", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "keys", ":", "\n", "            ", "if", "key", "not", "in", "line_json_obj", ":", "\n", "                ", "raise", "Exception", "(", "f'key {key} not in line json {line_json_obj}'", ")", "\n", "", "line_info", "[", "key", "]", "=", "line_json_obj", "[", "key", "]", "\n", "\n", "", "return", "line_info", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.__init__": [[31, 54], ["isinstance", "isinstance", "isinstance", "mmocr.datasets.builder.build_parser", "loader.AnnFileLoader._load", "ValueError"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.builder.build_parser", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader._load"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "parser", ",", "\n", "repeat", "=", "1", ",", "\n", "file_storage_backend", "=", "'disk'", ",", "\n", "file_format", "=", "'txt'", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "ann_file", ",", "str", ")", "\n", "assert", "isinstance", "(", "repeat", ",", "(", "int", ",", "float", ")", ")", "\n", "assert", "isinstance", "(", "parser", ",", "dict", ")", "\n", "assert", "repeat", ">", "0", "\n", "assert", "file_storage_backend", "in", "[", "'disk'", ",", "'http'", ",", "'petrel'", "]", "\n", "assert", "file_format", "in", "[", "'txt'", ",", "'lmdb'", "]", "\n", "\n", "if", "file_format", "==", "'lmdb'", "and", "parser", "[", "'type'", "]", "==", "'LineStrParser'", ":", "\n", "            ", "raise", "ValueError", "(", "'We only support using LineJsonParser '", "\n", "'to parse lmdb file. Please use LineJsonParser '", "\n", "'in the dataset config'", ")", "\n", "", "self", ".", "parser", "=", "build_parser", "(", "parser", ")", "\n", "self", ".", "repeat", "=", "repeat", "\n", "self", ".", "ann_file_backend", "=", "self", ".", "_backends", "[", "file_storage_backend", "]", "(", "\n", "file_format", ",", "**", "kwargs", ")", "\n", "self", ".", "ori_data_infos", "=", "self", ".", "_load", "(", "ann_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.__len__": [[55, 57], ["int", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "int", "(", "len", "(", "self", ".", "ori_data_infos", ")", "*", "self", ".", "repeat", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader._load": [[58, 62], ["loader.AnnFileLoader.ann_file_backend"], "methods", ["None"], ["", "def", "_load", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation file.\"\"\"", "\n", "\n", "return", "self", ".", "ann_file_backend", "(", "ann_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.__getitem__": [[63, 66], ["loader.AnnFileLoader.parser.get_item"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.get_item"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Retrieve anno info of one instance with dict format.\"\"\"", "\n", "return", "self", ".", "parser", ".", "get_item", "(", "self", ".", "ori_data_infos", ",", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.__iter__": [[67, 70], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_n", "=", "0", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.__next__": [[71, 77], ["len"], "methods", ["None"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_n", "<", "len", "(", "self", ")", ":", "\n", "            ", "data", "=", "self", "[", "self", ".", "_n", "]", "\n", "self", ".", "_n", "+=", "1", "\n", "return", "data", "\n", "", "raise", "StopIteration", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.close": [[78, 81], ["loader.AnnFileLoader.ori_data_infos.close"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"For ann_file with lmdb format only.\"\"\"", "\n", "self", ".", "ori_data_infos", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.HardDiskLoader.__init__": [[87, 97], ["warnings.warn", "loader.AnnFileLoader.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "ann_file", ",", "parser", ",", "repeat", "=", "1", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "'HardDiskLoader is deprecated, please use '", "\n", "'AnnFileLoader instead.'", ",", "UserWarning", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "ann_file", ",", "\n", "parser", ",", "\n", "repeat", ",", "\n", "file_storage_backend", "=", "'disk'", ",", "\n", "file_format", "=", "'txt'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.LmdbLoader.__init__": [[103, 113], ["warnings.warn", "loader.AnnFileLoader.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "ann_file", ",", "parser", ",", "repeat", "=", "1", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "'LmdbLoader is deprecated, please use '", "\n", "'AnnFileLoader instead.'", ",", "UserWarning", ")", "\n", "super", "(", ")", ".", "__init__", "(", "\n", "ann_file", ",", "\n", "parser", ",", "\n", "repeat", ",", "\n", "file_storage_backend", "=", "'disk'", ",", "\n", "file_format", "=", "'lmdb'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.__init__": [[37, 75], ["dict", "torch.Module.__init__", "bert.BertEmbeddings", "bert.BertEncoder", "bert.BertPooler", "bert.BertModel.init_weights"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights"], ["def", "__init__", "(", "self", ",", "\n", "num_hidden_layers", "=", "12", ",", "\n", "initializer_range", "=", "0.02", ",", "\n", "vocab_size", "=", "21128", ",", "\n", "hidden_size", "=", "768", ",", "\n", "max_position_embeddings", "=", "128", ",", "\n", "type_vocab_size", "=", "2", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ",", "\n", "output_attentions", "=", "False", ",", "\n", "output_hidden_states", "=", "False", ",", "\n", "num_attention_heads", "=", "12", ",", "\n", "attention_probs_dropout_prob", "=", "0.1", ",", "\n", "intermediate_size", "=", "3072", ",", "\n", "hidden_act_cfg", "=", "dict", "(", "type", "=", "'GeluNew'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embeddings", "=", "BertEmbeddings", "(", "\n", "vocab_size", "=", "vocab_size", ",", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "max_position_embeddings", "=", "max_position_embeddings", ",", "\n", "type_vocab_size", "=", "type_vocab_size", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ")", "\n", "self", ".", "encoder", "=", "BertEncoder", "(", "\n", "output_attentions", "=", "output_attentions", ",", "\n", "output_hidden_states", "=", "output_hidden_states", ",", "\n", "num_hidden_layers", "=", "num_hidden_layers", ",", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "num_attention_heads", "=", "num_attention_heads", ",", "\n", "attention_probs_dropout_prob", "=", "attention_probs_dropout_prob", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ",", "\n", "intermediate_size", "=", "intermediate_size", ",", "\n", "hidden_act_cfg", "=", "hidden_act_cfg", ")", "\n", "self", ".", "pooler", "=", "BertPooler", "(", "hidden_size", "=", "hidden_size", ")", "\n", "self", ".", "num_hidden_layers", "=", "num_hidden_layers", "\n", "self", ".", "initializer_range", "=", "initializer_range", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel._resize_token_embeddings": [[76, 82], ["bert.BertModel._get_resized_embeddings"], "methods", ["None"], ["", "def", "_resize_token_embeddings", "(", "self", ",", "new_num_tokens", ")", ":", "\n", "        ", "old_embeddings", "=", "self", ".", "embeddings", ".", "word_embeddings", "\n", "new_embeddings", "=", "self", ".", "_get_resized_embeddings", "(", "old_embeddings", ",", "\n", "new_num_tokens", ")", "\n", "self", ".", "embeddings", ".", "word_embeddings", "=", "new_embeddings", "\n", "return", "self", ".", "embeddings", ".", "word_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.forward": [[83, 122], ["torch.ones_like.to", "torch.ones_like.to", "bert.BertModel.embeddings", "bert.BertModel.encoder", "bert.BertModel.pooler", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "head_mask.to.to.to", "tuple", "head_mask.to.to.dim", "next", "head_mask.to.to.dim", "bert.BertModel.parameters", "next", "bert.BertModel.parameters"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "\n", "input_ids", ",", "\n", "attention_masks", "=", "None", ",", "\n", "token_type_ids", "=", "None", ",", "\n", "position_ids", "=", "None", ",", "\n", "head_mask", "=", "None", ")", ":", "\n", "        ", "if", "attention_masks", "is", "None", ":", "\n", "            ", "attention_masks", "=", "torch", ".", "ones_like", "(", "input_ids", ")", "\n", "", "if", "token_type_ids", "is", "None", ":", "\n", "            ", "token_type_ids", "=", "torch", ".", "zeros_like", "(", "input_ids", ")", "\n", "", "attention_masks", "=", "attention_masks", "[", ":", ",", "None", ",", "None", "]", "\n", "attention_masks", "=", "attention_masks", ".", "to", "(", "\n", "dtype", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "dtype", ")", "\n", "attention_masks", "=", "(", "1.0", "-", "attention_masks", ")", "*", "-", "10000.0", "\n", "if", "head_mask", "is", "not", "None", ":", "\n", "            ", "if", "head_mask", ".", "dim", "(", ")", "==", "1", ":", "\n", "                ", "head_mask", "=", "head_mask", "[", "None", ",", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "", "elif", "head_mask", ".", "dim", "(", ")", "==", "2", ":", "\n", "                ", "head_mask", "=", "head_mask", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "", "head_mask", "=", "head_mask", ".", "to", "(", "dtype", "=", "next", "(", "self", ".", "parameters", "(", ")", ")", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "head_mask", "=", "[", "None", "]", "*", "self", ".", "num_hidden_layers", "\n", "\n", "", "embedding_output", "=", "self", ".", "embeddings", "(", "\n", "input_ids", ",", "\n", "position_ids", "=", "position_ids", ",", "\n", "token_type_ids", "=", "token_type_ids", ")", "\n", "sequence_output", ",", "*", "encoder_outputs", "=", "self", ".", "encoder", "(", "\n", "embedding_output", ",", "attention_masks", ",", "head_mask", "=", "head_mask", ")", "\n", "# sequence_output = encoder_outputs[0]", "\n", "pooled_output", "=", "self", ".", "pooler", "(", "sequence_output", ")", "\n", "\n", "# add hidden_states and attentions if they are here", "\n", "# sequence_output, pooled_output, (hidden_states), (attentions)", "\n", "outputs", "=", "(", "\n", "sequence_output", ",", "\n", "pooled_output", ",", "\n", ")", "+", "tuple", "(", "encoder_outputs", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel._init_weights": [[123, 135], ["isinstance", "module.weight.data.normal_", "isinstance", "isinstance", "module.bias.data.zero_", "module.bias.data.zero_", "module.weight.data.fill_"], "methods", ["None"], ["", "def", "_init_weights", "(", "self", ",", "module", ")", ":", "\n", "        ", "\"\"\"Initialize the weights.\"\"\"", "\n", "if", "isinstance", "(", "module", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Embedding", ")", ")", ":", "\n", "# Slightly different from the TF version which", "\n", "# uses truncated_normal for initialization", "\n", "# cf https://github.com/pytorch/pytorch/pull/5617", "\n", "            ", "module", ".", "weight", ".", "data", ".", "normal_", "(", "mean", "=", "0.0", ",", "std", "=", "self", ".", "initializer_range", ")", "\n", "", "elif", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "LayerNorm", ")", ":", "\n", "            ", "module", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "module", ".", "weight", ".", "data", ".", "fill_", "(", "1.0", ")", "\n", "", "if", "isinstance", "(", "module", ",", "nn", ".", "Linear", ")", "and", "module", ".", "bias", "is", "not", "None", ":", "\n", "            ", "module", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights": [[136, 140], ["bert.BertModel.apply"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize and prunes weights if needed.\"\"\"", "\n", "# Initialize weights", "\n", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertEmbeddings.__init__": [[155, 175], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "vocab_size", "=", "21128", ",", "\n", "hidden_size", "=", "768", ",", "\n", "max_position_embeddings", "=", "128", ",", "\n", "type_vocab_size", "=", "2", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "word_embeddings", "=", "nn", ".", "Embedding", "(", "\n", "vocab_size", ",", "hidden_size", ",", "padding_idx", "=", "0", ")", "\n", "self", ".", "position_embeddings", "=", "nn", ".", "Embedding", "(", "max_position_embeddings", ",", "\n", "hidden_size", ")", "\n", "self", ".", "token_type_embeddings", "=", "nn", ".", "Embedding", "(", "type_vocab_size", ",", "hidden_size", ")", "\n", "\n", "# self.LayerNorm is not snake-cased to stick with", "\n", "# TensorFlow model variable name and be able to load", "\n", "# any TensorFlow checkpoint file", "\n", "self", ".", "LayerNorm", "=", "torch", ".", "nn", ".", "LayerNorm", "(", "hidden_size", ",", "eps", "=", "layer_norm_eps", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "hidden_dropout_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertEmbeddings.forward": [[176, 192], ["input_ids.size", "bert.BertEmbeddings.word_embeddings", "bert.BertEmbeddings.position_embeddings", "bert.BertEmbeddings.token_type_embeddings", "bert.BertEmbeddings.LayerNorm", "bert.BertEmbeddings.dropout", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "position_ids.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze().expand_as", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "position_ids.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_ids", ",", "token_type_ids", "=", "None", ",", "position_ids", "=", "None", ")", ":", "\n", "        ", "seq_length", "=", "input_ids", ".", "size", "(", "1", ")", "\n", "if", "position_ids", "is", "None", ":", "\n", "            ", "position_ids", "=", "torch", ".", "arange", "(", "\n", "seq_length", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "input_ids", ".", "device", ")", "\n", "position_ids", "=", "position_ids", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "input_ids", ")", "\n", "", "if", "token_type_ids", "is", "None", ":", "\n", "            ", "token_type_ids", "=", "torch", ".", "zeros_like", "(", "input_ids", ")", "\n", "\n", "", "words_emb", "=", "self", ".", "word_embeddings", "(", "input_ids", ")", "\n", "position_emb", "=", "self", ".", "position_embeddings", "(", "position_ids", ")", "\n", "token_type_emb", "=", "self", ".", "token_type_embeddings", "(", "token_type_ids", ")", "\n", "embeddings", "=", "words_emb", "+", "position_emb", "+", "token_type_emb", "\n", "embeddings", "=", "self", ".", "LayerNorm", "(", "embeddings", ")", "\n", "embeddings", "=", "self", ".", "dropout", "(", "embeddings", ")", "\n", "return", "embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertEncoder.__init__": [[198, 223], ["dict", "torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "bert.BertLayer", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "output_attentions", "=", "False", ",", "\n", "output_hidden_states", "=", "False", ",", "\n", "num_hidden_layers", "=", "12", ",", "\n", "hidden_size", "=", "768", ",", "\n", "num_attention_heads", "=", "12", ",", "\n", "attention_probs_dropout_prob", "=", "0.1", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ",", "\n", "intermediate_size", "=", "3072", ",", "\n", "hidden_act_cfg", "=", "dict", "(", "type", "=", "'GeluNew'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_attentions", "=", "output_attentions", "\n", "self", ".", "output_hidden_states", "=", "output_hidden_states", "\n", "self", ".", "layer", "=", "nn", ".", "ModuleList", "(", "[", "\n", "BertLayer", "(", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "num_attention_heads", "=", "num_attention_heads", ",", "\n", "output_attentions", "=", "output_attentions", ",", "\n", "attention_probs_dropout_prob", "=", "attention_probs_dropout_prob", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ",", "\n", "intermediate_size", "=", "intermediate_size", ",", "\n", "hidden_act_cfg", "=", "hidden_act_cfg", ")", "\n", "for", "_", "in", "range", "(", "num_hidden_layers", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertEncoder.forward": [[225, 250], ["enumerate", "layer_module"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ",", "attention_mask", "=", "None", ",", "head_mask", "=", "None", ")", ":", "\n", "        ", "all_hidden_states", "=", "(", ")", "\n", "all_attentions", "=", "(", ")", "\n", "for", "i", ",", "layer_module", "in", "enumerate", "(", "self", ".", "layer", ")", ":", "\n", "            ", "if", "self", ".", "output_hidden_states", ":", "\n", "                ", "all_hidden_states", "=", "all_hidden_states", "+", "(", "hidden_states", ",", ")", "\n", "\n", "", "layer_outputs", "=", "layer_module", "(", "hidden_states", ",", "attention_mask", ",", "\n", "head_mask", "[", "i", "]", ")", "\n", "hidden_states", "=", "layer_outputs", "[", "0", "]", "\n", "\n", "if", "self", ".", "output_attentions", ":", "\n", "                ", "all_attentions", "=", "all_attentions", "+", "(", "layer_outputs", "[", "1", "]", ",", ")", "\n", "\n", "# Add last layer", "\n", "", "", "if", "self", ".", "output_hidden_states", ":", "\n", "            ", "all_hidden_states", "=", "all_hidden_states", "+", "(", "hidden_states", ",", ")", "\n", "\n", "", "outputs", "=", "(", "hidden_states", ",", ")", "\n", "if", "self", ".", "output_hidden_states", ":", "\n", "            ", "outputs", "=", "outputs", "+", "(", "all_hidden_states", ",", ")", "\n", "", "if", "self", ".", "output_attentions", ":", "\n", "            ", "outputs", "=", "outputs", "+", "(", "all_attentions", ",", ")", "\n", "# last-layer hidden state, (all hidden states), (all attentions)", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertPooler.__init__": [[254, 258], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Tanh", "torch.Tanh"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", "=", "768", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dense", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", "\n", "self", ".", "activation", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertPooler.forward": [[259, 266], ["bert.BertPooler.dense", "bert.BertPooler.activation"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ")", ":", "\n", "# We \"pool\" the model by simply taking the hidden state corresponding", "\n", "# to the first token.", "\n", "        ", "first_token_tensor", "=", "hidden_states", "[", ":", ",", "0", "]", "\n", "pooled_output", "=", "self", ".", "dense", "(", "first_token_tensor", ")", "\n", "pooled_output", "=", "self", ".", "activation", "(", "pooled_output", ")", "\n", "return", "pooled_output", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertLayer.__init__": [[274, 300], ["dict", "torch.Module.__init__", "bert.BertAttention", "bert.BertIntermediate", "bert.BertOutput"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "hidden_size", "=", "768", ",", "\n", "num_attention_heads", "=", "12", ",", "\n", "output_attentions", "=", "False", ",", "\n", "attention_probs_dropout_prob", "=", "0.1", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ",", "\n", "intermediate_size", "=", "3072", ",", "\n", "hidden_act_cfg", "=", "dict", "(", "type", "=", "'GeluNew'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "attention", "=", "BertAttention", "(", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "num_attention_heads", "=", "num_attention_heads", ",", "\n", "output_attentions", "=", "output_attentions", ",", "\n", "attention_probs_dropout_prob", "=", "attention_probs_dropout_prob", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ")", "\n", "self", ".", "intermediate", "=", "BertIntermediate", "(", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "intermediate_size", "=", "intermediate_size", ",", "\n", "hidden_act_cfg", "=", "hidden_act_cfg", ")", "\n", "self", ".", "output", "=", "BertOutput", "(", "\n", "intermediate_size", "=", "intermediate_size", ",", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertLayer.forward": [[301, 310], ["bert.BertLayer.attention", "bert.BertLayer.intermediate", "bert.BertLayer.output"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ",", "attention_mask", "=", "None", ",", "head_mask", "=", "None", ")", ":", "\n", "        ", "attention_outputs", "=", "self", ".", "attention", "(", "hidden_states", ",", "attention_mask", ",", "\n", "head_mask", ")", "\n", "attention_output", "=", "attention_outputs", "[", "0", "]", "\n", "intermediate_output", "=", "self", ".", "intermediate", "(", "attention_output", ")", "\n", "layer_output", "=", "self", ".", "output", "(", "intermediate_output", ",", "attention_output", ")", "\n", "outputs", "=", "(", "layer_output", ",", ")", "+", "attention_outputs", "[", "\n", "1", ":", "]", "# add attentions if we output them", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfAttention.__init__": [[318, 339], ["torch.Module.__init__", "int", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "ValueError"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "hidden_size", "=", "768", ",", "\n", "num_attention_heads", "=", "12", ",", "\n", "output_attentions", "=", "False", ",", "\n", "attention_probs_dropout_prob", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "hidden_size", "%", "num_attention_heads", "!=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'The hidden size (%d) is not a multiple of'", "\n", "'the number of attention heads (%d)'", "%", "\n", "(", "hidden_size", ",", "num_attention_heads", ")", ")", "\n", "", "self", ".", "output_attentions", "=", "output_attentions", "\n", "\n", "self", ".", "num_attention_heads", "=", "num_attention_heads", "\n", "self", ".", "att_head_size", "=", "int", "(", "hidden_size", "/", "num_attention_heads", ")", "\n", "self", ".", "all_head_size", "=", "self", ".", "num_attention_heads", "*", "self", ".", "att_head_size", "\n", "\n", "self", ".", "query", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "all_head_size", ")", "\n", "self", ".", "key", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "all_head_size", ")", "\n", "self", ".", "value", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "all_head_size", ")", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "attention_probs_dropout_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfAttention.transpose_for_scores": [[340, 345], ["x.view.view.view", "x.view.view.permute", "x.view.view.size"], "methods", ["None"], ["", "def", "transpose_for_scores", "(", "self", ",", "x", ")", ":", "\n", "        ", "new_x_shape", "=", "x", ".", "size", "(", ")", "[", ":", "-", "1", "]", "+", "(", "self", ".", "num_attention_heads", ",", "\n", "self", ".", "att_head_size", ")", "\n", "x", "=", "x", ".", "view", "(", "*", "new_x_shape", ")", "\n", "return", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfAttention.forward": [[346, 387], ["bert.BertSelfAttention.query", "bert.BertSelfAttention.key", "bert.BertSelfAttention.value", "bert.BertSelfAttention.transpose_for_scores", "bert.BertSelfAttention.transpose_for_scores", "bert.BertSelfAttention.transpose_for_scores", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "bert.BertSelfAttention.dropout", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "context_layer.view.view.permute().contiguous", "context_layer.view.view.view", "bert.BertSelfAttention.transpose", "math.sqrt", "torch.Softmax", "torch.Softmax", "context_layer.view.view.permute", "context_layer.view.view.size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfAttention.transpose_for_scores", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfAttention.transpose_for_scores", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfAttention.transpose_for_scores"], ["", "def", "forward", "(", "self", ",", "hidden_states", ",", "attention_mask", "=", "None", ",", "head_mask", "=", "None", ")", ":", "\n", "        ", "mixed_query_layer", "=", "self", ".", "query", "(", "hidden_states", ")", "\n", "mixed_key_layer", "=", "self", ".", "key", "(", "hidden_states", ")", "\n", "mixed_value_layer", "=", "self", ".", "value", "(", "hidden_states", ")", "\n", "\n", "query_layer", "=", "self", ".", "transpose_for_scores", "(", "mixed_query_layer", ")", "\n", "key_layer", "=", "self", ".", "transpose_for_scores", "(", "mixed_key_layer", ")", "\n", "value_layer", "=", "self", ".", "transpose_for_scores", "(", "mixed_value_layer", ")", "\n", "\n", "# Take the dot product between \"query\" and", "\n", "# \"key\" to get the raw attention scores.", "\n", "attention_scores", "=", "torch", ".", "matmul", "(", "query_layer", ",", "\n", "key_layer", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "attention_scores", "=", "attention_scores", "/", "math", ".", "sqrt", "(", "self", ".", "att_head_size", ")", "\n", "if", "attention_mask", "is", "not", "None", ":", "\n", "# Apply the attention mask is precomputed for", "\n", "# all layers in BertModel forward() function.", "\n", "            ", "attention_scores", "=", "attention_scores", "+", "attention_mask", "\n", "\n", "# Normalize the attention scores to probabilities.", "\n", "", "attention_probs", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "(", "attention_scores", ")", "\n", "\n", "# This is actually dropping out entire tokens to attend to, which might", "\n", "# seem a bit unusual, but is taken from the original Transformer paper.", "\n", "attention_probs", "=", "self", ".", "dropout", "(", "attention_probs", ")", "\n", "\n", "# Mask heads if we want to.", "\n", "if", "head_mask", "is", "not", "None", ":", "\n", "            ", "attention_probs", "=", "attention_probs", "*", "head_mask", "\n", "\n", "", "context_layer", "=", "torch", ".", "matmul", "(", "attention_probs", ",", "value_layer", ")", "\n", "\n", "context_layer", "=", "context_layer", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "new_context_layer_shape", "=", "context_layer", ".", "size", "(", ")", "[", ":", "-", "2", "]", "+", "(", "\n", "self", ".", "all_head_size", ",", ")", "\n", "context_layer", "=", "context_layer", ".", "view", "(", "*", "new_context_layer_shape", ")", "\n", "\n", "outputs", "=", "(", "context_layer", ",", "\n", "attention_probs", ")", "if", "self", ".", "output_attentions", "else", "(", "\n", "context_layer", ",", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfOutput.__init__": [[395, 403], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "hidden_size", "=", "768", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dense", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", "\n", "self", ".", "LayerNorm", "=", "torch", ".", "nn", ".", "LayerNorm", "(", "hidden_size", ",", "eps", "=", "layer_norm_eps", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "hidden_dropout_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertSelfOutput.forward": [[404, 409], ["bert.BertSelfOutput.dense", "bert.BertSelfOutput.dropout", "bert.BertSelfOutput.LayerNorm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ",", "input_tensor", ")", ":", "\n", "        ", "hidden_states", "=", "self", ".", "dense", "(", "hidden_states", ")", "\n", "hidden_states", "=", "self", ".", "dropout", "(", "hidden_states", ")", "\n", "hidden_states", "=", "self", ".", "LayerNorm", "(", "hidden_states", "+", "input_tensor", ")", "\n", "return", "hidden_states", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertAttention.__init__": [[417, 434], ["torch.Module.__init__", "bert.BertSelfAttention", "bert.BertSelfOutput"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "hidden_size", "=", "768", ",", "\n", "num_attention_heads", "=", "12", ",", "\n", "output_attentions", "=", "False", ",", "\n", "attention_probs_dropout_prob", "=", "0.1", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "self", "=", "BertSelfAttention", "(", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "num_attention_heads", "=", "num_attention_heads", ",", "\n", "output_attentions", "=", "output_attentions", ",", "\n", "attention_probs_dropout_prob", "=", "attention_probs_dropout_prob", ")", "\n", "self", ".", "output", "=", "BertSelfOutput", "(", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertAttention.forward": [[435, 441], ["bert.BertAttention.self", "bert.BertAttention.output"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_tensor", ",", "attention_mask", "=", "None", ",", "head_mask", "=", "None", ")", ":", "\n", "        ", "self_outputs", "=", "self", ".", "self", "(", "input_tensor", ",", "attention_mask", ",", "head_mask", ")", "\n", "attention_output", "=", "self", ".", "output", "(", "self_outputs", "[", "0", "]", ",", "input_tensor", ")", "\n", "outputs", "=", "(", "attention_output", ",", "\n", ")", "+", "self_outputs", "[", "1", ":", "]", "# add attentions if we output them", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertIntermediate.__init__": [[449, 457], ["dict", "torch.Module.__init__", "torch.Linear", "torch.Linear", "mmocr.models.builder.build_activation_layer"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_activation_layer"], ["def", "__init__", "(", "self", ",", "\n", "hidden_size", "=", "768", ",", "\n", "intermediate_size", "=", "3072", ",", "\n", "hidden_act_cfg", "=", "dict", "(", "type", "=", "'GeluNew'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "dense", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "intermediate_size", ")", "\n", "self", ".", "intermediate_act_fn", "=", "build_activation_layer", "(", "hidden_act_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertIntermediate.forward": [[458, 462], ["bert.BertIntermediate.dense", "bert.BertIntermediate.intermediate_act_fn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ")", ":", "\n", "        ", "hidden_states", "=", "self", ".", "dense", "(", "hidden_states", ")", "\n", "hidden_states", "=", "self", ".", "intermediate_act_fn", "(", "hidden_states", ")", "\n", "return", "hidden_states", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertOutput.__init__": [[470, 480], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.nn.LayerNorm", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "intermediate_size", "=", "3072", ",", "\n", "hidden_size", "=", "768", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dense", "=", "nn", ".", "Linear", "(", "intermediate_size", ",", "hidden_size", ")", "\n", "self", ".", "LayerNorm", "=", "torch", ".", "nn", ".", "LayerNorm", "(", "hidden_size", ",", "eps", "=", "layer_norm_eps", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "hidden_dropout_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertOutput.forward": [[481, 486], ["bert.BertOutput.dense", "bert.BertOutput.dropout", "bert.BertOutput.LayerNorm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "hidden_states", ",", "input_tensor", ")", ":", "\n", "        ", "hidden_states", "=", "self", ".", "dense", "(", "hidden_states", ")", "\n", "hidden_states", "=", "self", ".", "dropout", "(", "hidden_states", ")", "\n", "hidden_states", "=", "self", ".", "LayerNorm", "(", "hidden_states", "+", "input_tensor", ")", "\n", "return", "hidden_states", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.activations.GeluNew.forward": [[22, 33], ["torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "math.sqrt", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: Activated tensor.\n        \"\"\"", "\n", "return", "0.5", "*", "x", "*", "(", "1", "+", "torch", ".", "tanh", "(", "\n", "math", ".", "sqrt", "(", "2", "/", "math", ".", "pi", ")", "*", "(", "x", "+", "0.044715", "*", "torch", ".", "pow", "(", "x", ",", "3", ")", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_converter.main": [[7, 47], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "mmocr.utils.recog2lmdb"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.recog2lmdb"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'label_path'", ",", "type", "=", "str", ",", "help", "=", "'Path to label file'", ")", "\n", "parser", ".", "add_argument", "(", "'output'", ",", "type", "=", "str", ",", "help", "=", "'Output lmdb path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--img-root'", ",", "'-i'", ",", "type", "=", "str", ",", "help", "=", "'Input imglist path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--label-only'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Only converter label to lmdb'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--label-format'", ",", "\n", "'-f'", ",", "\n", "default", "=", "'txt'", ",", "\n", "choices", "=", "[", "'txt'", ",", "'jsonl'", "]", ",", "\n", "help", "=", "'The format of the label file, either txt or jsonl'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--batch-size'", ",", "\n", "'-b'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "1000", ",", "\n", "help", "=", "'Processing batch size, defaults to 1000'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--encoding'", ",", "\n", "'-e'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "'utf8'", ",", "\n", "help", "=", "'Bytes coding scheme, defaults to utf8'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--lmdb-map-size'", ",", "\n", "'-m'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "109951162776", ",", "\n", "help", "=", "'Maximum size database may grow to, '", "\n", "'defaults to 109951162776 bytes'", ")", "\n", "opt", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "assert", "opt", ".", "img_root", "or", "opt", ".", "label_only", "\n", "recog2lmdb", "(", "opt", ".", "img_root", ",", "opt", ".", "label_path", ",", "opt", ".", "output", ",", "opt", ".", "label_format", ",", "\n", "opt", ".", "label_only", ",", "opt", ".", "batch_size", ",", "opt", ".", "encoding", ",", "opt", ".", "lmdb_map_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.text_det_dataset.TextDetDataset._parse_anno_info": [[12, 54], ["dict", "dict.get", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros.append", "gt_masks_ignore.append", "numpy.zeros.append", "numpy.array.append", "gt_masks.append", "dict.get", "dict.get"], "methods", ["None"], ["    ", "def", "_parse_anno_info", "(", "self", ",", "annotations", ")", ":", "\n", "        ", "\"\"\"Parse bbox and mask annotation.\n        Args:\n            annotations (dict): Annotations of one image.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\n                labels, masks, masks_ignore. \"masks\"  and\n                \"masks_ignore\" are represented by polygon boundary\n                point sequences.\n        \"\"\"", "\n", "gt_bboxes", ",", "gt_bboxes_ignore", "=", "[", "]", ",", "[", "]", "\n", "gt_masks", ",", "gt_masks_ignore", "=", "[", "]", ",", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "for", "ann", "in", "annotations", ":", "\n", "            ", "if", "ann", ".", "get", "(", "'iscrowd'", ",", "False", ")", ":", "\n", "                ", "gt_bboxes_ignore", ".", "append", "(", "ann", "[", "'bbox'", "]", ")", "\n", "gt_masks_ignore", ".", "append", "(", "ann", ".", "get", "(", "'segmentation'", ",", "None", ")", ")", "\n", "", "else", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "ann", "[", "'bbox'", "]", ")", "\n", "gt_labels", ".", "append", "(", "ann", "[", "'category_id'", "]", ")", "\n", "gt_masks", ".", "append", "(", "ann", ".", "get", "(", "'segmentation'", ",", "None", ")", ")", "\n", "", "", "if", "gt_bboxes", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "array", "(", "gt_bboxes_ignore", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "ann", "=", "dict", "(", "\n", "bboxes", "=", "gt_bboxes", ",", "\n", "labels", "=", "gt_labels", ",", "\n", "bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "masks_ignore", "=", "gt_masks_ignore", ",", "\n", "masks", "=", "gt_masks", ")", "\n", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.text_det_dataset.TextDetDataset.prepare_train_img": [[55, 79], ["text_det_dataset.TextDetDataset._parse_anno_info", "dict", "text_det_dataset.TextDetDataset.pre_pipeline", "text_det_dataset.TextDetDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline"], ["", "def", "prepare_train_img", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations from pipeline.\n\n        Args:\n            index (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys\n                introduced by pipeline.\n        \"\"\"", "\n", "img_ann_info", "=", "self", ".", "data_infos", "[", "index", "]", "\n", "img_info", "=", "{", "\n", "'filename'", ":", "img_ann_info", "[", "'file_name'", "]", ",", "\n", "'height'", ":", "img_ann_info", "[", "'height'", "]", ",", "\n", "'width'", ":", "img_ann_info", "[", "'width'", "]", "\n", "}", "\n", "ann_info", "=", "self", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ",", "ann_info", "=", "ann_info", ")", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "results", "[", "'seg_fields'", "]", "=", "[", "]", "\n", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.text_det_dataset.TextDetDataset.evaluate": [[80, 132], ["range", "mmocr.core.evaluation.hmean.eval_hmean", "isinstance", "set", "set", "len", "text_det_dataset.TextDetDataset._parse_anno_info", "img_infos.append", "ann_infos.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'hmean-iou'", ",", "\n", "score_thr", "=", "None", ",", "\n", "min_score_thr", "=", "0.3", ",", "\n", "max_score_thr", "=", "0.9", ",", "\n", "step", "=", "0.1", ",", "\n", "rank_list", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the dataset.\n\n        Args:\n            results (list): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            score_thr (float): Deprecated. Please use min_score_thr instead.\n            min_score_thr (float): Minimum score threshold of prediction map.\n            max_score_thr (float): Maximum score threshold of prediction map.\n            step (float): The spacing between score thresholds.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n            rank_list (str): json file used to save eval result\n                of each image after ranking.\n        Returns:\n            dict[str: float]\n        \"\"\"", "\n", "metrics", "=", "metric", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "allowed_metrics", "=", "[", "'hmean-iou'", ",", "'hmean-ic13'", "]", "\n", "metrics", "=", "set", "(", "metrics", ")", "&", "set", "(", "allowed_metrics", ")", "\n", "\n", "img_infos", "=", "[", "]", "\n", "ann_infos", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_ann_info", "=", "self", ".", "data_infos", "[", "i", "]", "\n", "img_info", "=", "{", "'filename'", ":", "img_ann_info", "[", "'file_name'", "]", "}", "\n", "ann_info", "=", "self", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "img_infos", ".", "append", "(", "img_info", ")", "\n", "ann_infos", ".", "append", "(", "ann_info", ")", "\n", "\n", "", "eval_results", "=", "eval_hmean", "(", "\n", "results", ",", "\n", "img_infos", ",", "\n", "ann_infos", ",", "\n", "metrics", "=", "metrics", ",", "\n", "score_thr", "=", "score_thr", ",", "\n", "min_score_thr", "=", "min_score_thr", ",", "\n", "max_score_thr", "=", "max_score_thr", ",", "\n", "step", "=", "step", ",", "\n", "logger", "=", "logger", ",", "\n", "rank_list", "=", "rank_list", ")", "\n", "\n", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.icdar_dataset.IcdarDataset.__init__": [[23, 45], ["mmdet.datasets.coco.CocoDataset.__init__", "numpy.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "pipeline", ",", "\n", "classes", "=", "None", ",", "\n", "data_root", "=", "None", ",", "\n", "img_prefix", "=", "''", ",", "\n", "seg_prefix", "=", "None", ",", "\n", "proposal_file", "=", "None", ",", "\n", "test_mode", "=", "False", ",", "\n", "filter_empty_gt", "=", "True", ",", "\n", "select_first_k", "=", "-", "1", ",", "\n", "ann_file_backend", "=", "'disk'", ")", ":", "\n", "# select first k images for fast debugging.", "\n", "        ", "self", ".", "select_first_k", "=", "select_first_k", "\n", "assert", "ann_file_backend", "in", "[", "'disk'", ",", "'petrel'", ",", "'http'", "]", "\n", "self", ".", "ann_file_backend", "=", "ann_file_backend", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "ann_file", ",", "pipeline", ",", "classes", ",", "data_root", ",", "img_prefix", ",", "\n", "seg_prefix", ",", "proposal_file", ",", "test_mode", ",", "filter_empty_gt", ")", "\n", "\n", "# Set dummy flags just to be compatible with MMDet", "\n", "self", ".", "flag", "=", "np", ".", "zeros", "(", "len", "(", "self", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.icdar_dataset.IcdarDataset.load_annotations": [[46, 79], ["icdar_dataset.IcdarDataset.coco.get_cat_ids", "icdar_dataset.IcdarDataset.coco.get_img_ids", "mmdet.datasets.api_wrappers.COCO", "mmocr.digit_version", "mmcv.FileClient", "data_infos.append", "mmocr.digit_version", "Exception", "mmcv.FileClient.get_local_path", "mmdet.datasets.api_wrappers.COCO", "enumerate", "icdar_dataset.IcdarDataset.coco.load_imgs"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version"], ["", "def", "load_annotations", "(", "self", ",", "ann_file", ")", ":", "\n", "        ", "\"\"\"Load annotation from COCO style annotation file.\n\n        Args:\n            ann_file (str): Path of annotation file.\n\n        Returns:\n            list[dict]: Annotation info from COCO api.\n        \"\"\"", "\n", "if", "self", ".", "ann_file_backend", "==", "'disk'", ":", "\n", "            ", "self", ".", "coco", "=", "COCO", "(", "ann_file", ")", "\n", "", "else", ":", "\n", "            ", "mmcv_version", "=", "digit_version", "(", "mmcv", ".", "__version__", ")", "\n", "if", "mmcv_version", "<", "digit_version", "(", "'1.3.16'", ")", ":", "\n", "                ", "raise", "Exception", "(", "'Please update mmcv to 1.3.16 or higher '", "\n", "'to enable \"get_local_path\" of \"FileClient\".'", ")", "\n", "", "file_client", "=", "mmcv", ".", "FileClient", "(", "backend", "=", "self", ".", "ann_file_backend", ")", "\n", "with", "file_client", ".", "get_local_path", "(", "ann_file", ")", "as", "local_path", ":", "\n", "                ", "self", ".", "coco", "=", "COCO", "(", "local_path", ")", "\n", "", "", "self", ".", "cat_ids", "=", "self", ".", "coco", ".", "get_cat_ids", "(", "cat_names", "=", "self", ".", "CLASSES", ")", "\n", "self", ".", "cat2label", "=", "{", "cat_id", ":", "i", "for", "i", ",", "cat_id", "in", "enumerate", "(", "self", ".", "cat_ids", ")", "}", "\n", "self", ".", "img_ids", "=", "self", ".", "coco", ".", "get_img_ids", "(", ")", "\n", "data_infos", "=", "[", "]", "\n", "\n", "count", "=", "0", "\n", "for", "i", "in", "self", ".", "img_ids", ":", "\n", "            ", "info", "=", "self", ".", "coco", ".", "load_imgs", "(", "[", "i", "]", ")", "[", "0", "]", "\n", "info", "[", "'filename'", "]", "=", "info", "[", "'file_name'", "]", "\n", "data_infos", ".", "append", "(", "info", ")", "\n", "count", "=", "count", "+", "1", "\n", "if", "count", ">", "self", ".", "select_first_k", "and", "self", ".", "select_first_k", ">", "0", ":", "\n", "                ", "break", "\n", "", "", "return", "data_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.icdar_dataset.IcdarDataset._parse_ann_info": [[80, 139], ["img_info[].replace", "dict", "dict.get", "dict.get", "numpy.array", "numpy.array", "numpy.zeros", "numpy.array", "numpy.array", "numpy.zeros", "numpy.zeros.append", "gt_masks_ignore.append", "numpy.zeros.append", "numpy.array.append", "gt_masks_ann.append", "dict.get", "dict.get"], "methods", ["None"], ["", "def", "_parse_ann_info", "(", "self", ",", "img_info", ",", "ann_info", ")", ":", "\n", "        ", "\"\"\"Parse bbox and mask annotation.\n\n        Args:\n            ann_info (list[dict]): Annotation info of an image.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\n                labels, masks, masks_ignore, seg_map. \"masks\"  and\n                \"masks_ignore\" are represented by polygon boundary\n                point sequences.\n        \"\"\"", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_bboxes_ignore", "=", "[", "]", "\n", "gt_masks_ignore", "=", "[", "]", "\n", "gt_masks_ann", "=", "[", "]", "\n", "\n", "for", "ann", "in", "ann_info", ":", "\n", "            ", "if", "ann", ".", "get", "(", "'ignore'", ",", "False", ")", ":", "\n", "                ", "continue", "\n", "", "x1", ",", "y1", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "if", "ann", "[", "'area'", "]", "<=", "0", "or", "w", "<", "1", "or", "h", "<", "1", ":", "\n", "                ", "continue", "\n", "", "if", "ann", "[", "'category_id'", "]", "not", "in", "self", ".", "cat_ids", ":", "\n", "                ", "continue", "\n", "", "bbox", "=", "[", "x1", ",", "y1", ",", "x1", "+", "w", ",", "y1", "+", "h", "]", "\n", "if", "ann", ".", "get", "(", "'iscrowd'", ",", "False", ")", ":", "\n", "                ", "gt_bboxes_ignore", ".", "append", "(", "bbox", ")", "\n", "gt_masks_ignore", ".", "append", "(", "ann", ".", "get", "(", "\n", "'segmentation'", ",", "None", ")", ")", "# to float32 for latter processing", "\n", "\n", "", "else", ":", "\n", "                ", "gt_bboxes", ".", "append", "(", "bbox", ")", "\n", "gt_labels", ".", "append", "(", "self", ".", "cat2label", "[", "ann", "[", "'category_id'", "]", "]", ")", "\n", "gt_masks_ann", ".", "append", "(", "ann", ".", "get", "(", "'segmentation'", ",", "None", ")", ")", "\n", "", "", "if", "gt_bboxes", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "array", "(", "gt_bboxes", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "gt_labels", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_labels", "=", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "", "if", "gt_bboxes_ignore", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "array", "(", "gt_bboxes_ignore", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "", "else", ":", "\n", "            ", "gt_bboxes_ignore", "=", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "", "seg_map", "=", "img_info", "[", "'filename'", "]", ".", "replace", "(", "'jpg'", ",", "'png'", ")", "\n", "\n", "ann", "=", "dict", "(", "\n", "bboxes", "=", "gt_bboxes", ",", "\n", "labels", "=", "gt_labels", ",", "\n", "bboxes_ignore", "=", "gt_bboxes_ignore", ",", "\n", "masks_ignore", "=", "gt_masks_ignore", ",", "\n", "masks", "=", "gt_masks_ann", ",", "\n", "seg_map", "=", "seg_map", ")", "\n", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.icdar_dataset.IcdarDataset.evaluate": [[140, 192], ["mmocr.is_type_list", "range", "mmocr.core.evaluation.hmean.eval_hmean", "isinstance", "set", "set", "len", "img_infos.append", "ann_infos.append", "icdar_dataset.IcdarDataset.get_ann_info"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'hmean-iou'", ",", "\n", "logger", "=", "None", ",", "\n", "score_thr", "=", "None", ",", "\n", "min_score_thr", "=", "0.3", ",", "\n", "max_score_thr", "=", "0.9", ",", "\n", "step", "=", "0.1", ",", "\n", "rank_list", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the hmean metric.\n\n        Args:\n            results (list[dict]): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n            score_thr (float): Deprecated. Please use min_score_thr instead.\n            min_score_thr (float): Minimum score threshold of prediction map.\n            max_score_thr (float): Maximum score threshold of prediction map.\n            step (float): The spacing between score thresholds.\n            rank_list (str): json file used to save eval result\n                of each image after ranking.\n        Returns:\n            dict[dict[str: float]]: The evaluation results.\n        \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "\n", "metrics", "=", "metric", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "allowed_metrics", "=", "[", "'hmean-iou'", ",", "'hmean-ic13'", "]", "\n", "metrics", "=", "set", "(", "metrics", ")", "&", "set", "(", "allowed_metrics", ")", "\n", "\n", "img_infos", "=", "[", "]", "\n", "ann_infos", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "img_info", "=", "{", "'filename'", ":", "self", ".", "data_infos", "[", "i", "]", "[", "'file_name'", "]", "}", "\n", "img_infos", ".", "append", "(", "img_info", ")", "\n", "ann_infos", ".", "append", "(", "self", ".", "get_ann_info", "(", "i", ")", ")", "\n", "\n", "", "eval_results", "=", "eval_hmean", "(", "\n", "results", ",", "\n", "img_infos", ",", "\n", "ann_infos", ",", "\n", "metrics", "=", "metrics", ",", "\n", "score_thr", "=", "score_thr", ",", "\n", "min_score_thr", "=", "min_score_thr", ",", "\n", "max_score_thr", "=", "max_score_thr", ",", "\n", "step", "=", "step", ",", "\n", "logger", "=", "logger", ",", "\n", "rank_list", "=", "rank_list", ")", "\n", "\n", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ocr_dataset.OCRDataset.pre_pipeline": [[12, 15], ["None"], "methods", ["None"], ["    ", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "[", "'img_prefix'", "]", "=", "self", ".", "img_prefix", "\n", "results", "[", "'text'", "]", "=", "results", "[", "'img_info'", "]", "[", "'text'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ocr_dataset.OCRDataset.evaluate": [[16, 40], ["range", "mmocr.core.evaluation.ocr_metric.eval_ocr_metric", "isinstance", "mmocr.utils.is_type_list", "len", "gt_texts.append", "pred_texts.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.eval_ocr_metric", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "evaluate", "(", "self", ",", "results", ",", "metric", "=", "'acc'", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the dataset.\n\n        Args:\n            results (list): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n        Returns:\n            dict[str: float]\n        \"\"\"", "\n", "assert", "isinstance", "(", "metric", ",", "str", ")", "or", "is_type_list", "(", "metric", ",", "str", ")", "\n", "\n", "gt_texts", "=", "[", "]", "\n", "pred_texts", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "item_info", "=", "self", ".", "data_infos", "[", "i", "]", "\n", "text", "=", "item_info", "[", "'text'", "]", "\n", "gt_texts", ".", "append", "(", "text", ")", "\n", "pred_texts", ".", "append", "(", "results", "[", "i", "]", "[", "'text'", "]", ")", "\n", "\n", "", "eval_results", "=", "eval_ocr_metric", "(", "pred_texts", ",", "gt_texts", ",", "metric", "=", "metric", ")", "\n", "\n", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.__init__": [[55, 74], ["torch.utils.data.Dataset.__init__", "loader.update", "mmocr.datasets.builder.build_loader", "mmdet.datasets.pipelines.Compose", "base_dataset.BaseDataset._set_group_flag"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.builder.build_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._set_group_flag"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "loader", ",", "\n", "pipeline", ",", "\n", "img_prefix", "=", "''", ",", "\n", "test_mode", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "test_mode", "=", "test_mode", "\n", "self", ".", "img_prefix", "=", "img_prefix", "\n", "self", ".", "ann_file", "=", "ann_file", "\n", "# load annotations", "\n", "loader", ".", "update", "(", "ann_file", "=", "ann_file", ")", "\n", "self", ".", "data_infos", "=", "build_loader", "(", "loader", ")", "\n", "# processing pipeline", "\n", "self", ".", "pipeline", "=", "Compose", "(", "pipeline", ")", "\n", "# set group flag and class, no meaning", "\n", "# for text detect and recognize", "\n", "self", ".", "_set_group_flag", "(", ")", "\n", "self", ".", "CLASSES", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.__len__": [[75, 77], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "data_infos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._set_group_flag": [[78, 81], ["numpy.zeros", "len"], "methods", ["None"], ["", "def", "_set_group_flag", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set flag.\"\"\"", "\n", "self", ".", "flag", "=", "np", ".", "zeros", "(", "len", "(", "self", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.pre_pipeline": [[82, 85], ["None"], "methods", ["None"], ["", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Prepare results dict for pipeline.\"\"\"", "\n", "results", "[", "'img_prefix'", "]", "=", "self", ".", "img_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.prepare_train_img": [[86, 100], ["dict", "base_dataset.BaseDataset.pre_pipeline", "base_dataset.BaseDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline"], ["", "def", "prepare_train_img", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations from pipeline.\n\n        Args:\n            index (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys\n                introduced by pipeline.\n        \"\"\"", "\n", "img_info", "=", "self", ".", "data_infos", "[", "index", "]", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ")", "\n", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.prepare_test_img": [[101, 112], ["base_dataset.BaseDataset.prepare_train_img"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img"], ["", "def", "prepare_test_img", "(", "self", ",", "img_info", ")", ":", "\n", "        ", "\"\"\"Get testing data from pipeline.\n\n        Args:\n            idx (int): Index of data.\n\n        Returns:\n            dict: Testing data after pipeline with new keys introduced by\n                pipeline.\n        \"\"\"", "\n", "return", "self", ".", "prepare_train_img", "(", "img_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._log_error_index": [[113, 122], ["mmcv.utils.print_log", "mmcv.utils.print_log"], "methods", ["None"], ["", "def", "_log_error_index", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Logging data info of bad index.\"\"\"", "\n", "try", ":", "\n", "            ", "data_info", "=", "self", ".", "data_infos", "[", "index", "]", "\n", "img_prefix", "=", "self", ".", "img_prefix", "\n", "print_log", "(", "f'Warning: skip broken file {data_info} '", "\n", "f'with img_prefix {img_prefix}'", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "print_log", "(", "f'load index {index} with error {e}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._get_next_index": [[123, 128], ["base_dataset.BaseDataset._log_error_index", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._log_error_index"], ["", "", "def", "_get_next_index", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get next index from dataset.\"\"\"", "\n", "self", ".", "_log_error_index", "(", "index", ")", "\n", "index", "=", "(", "index", "+", "1", ")", "%", "len", "(", "self", ")", "\n", "return", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.__getitem__": [[129, 151], ["base_dataset.BaseDataset.prepare_test_img", "base_dataset.BaseDataset.prepare_train_img", "Exception", "mmcv.utils.print_log", "base_dataset.BaseDataset._get_next_index"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.prepare_test_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._get_next_index"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get training/test data from pipeline.\n\n        Args:\n            index (int): Index of data.\n\n        Returns:\n            dict: Training/test data.\n        \"\"\"", "\n", "if", "self", ".", "test_mode", ":", "\n", "            ", "return", "self", ".", "prepare_test_img", "(", "index", ")", "\n", "\n", "", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "data", "=", "self", ".", "prepare_train_img", "(", "index", ")", "\n", "if", "data", "is", "None", ":", "\n", "                    ", "raise", "Exception", "(", "'prepared train data empty'", ")", "\n", "", "break", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "print_log", "(", "f'prepare index {index} with error {e}'", ")", "\n", "index", "=", "self", ".", "_get_next_index", "(", "index", ")", "\n", "", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.format_results": [[152, 155], ["None"], "methods", ["None"], ["", "def", "format_results", "(", "self", ",", "results", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Placeholder to format result to dataset-specific output.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.evaluate": [[156, 168], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "results", ",", "metric", "=", "None", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the dataset.\n\n        Args:\n            results (list): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n        Returns:\n            dict[str: float]\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.builder.build_loader": [[8, 11], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["def", "build_loader", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"Build anno file loader.\"\"\"", "\n", "return", "build_from_cfg", "(", "cfg", ",", "LOADERS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.builder.build_parser": [[13, 16], ["mmcv.utils.build_from_cfg"], "function", ["None"], ["", "def", "build_parser", "(", "cfg", ")", ":", "\n", "    ", "\"\"\"Build anno file parser.\"\"\"", "\n", "return", "build_from_cfg", "(", "cfg", ",", "PARSERS", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.__init__": [[36, 60], ["mmocr.datasets.KIEDataset.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", ",", "\n", "loader", ",", "\n", "dict_file", ",", "\n", "img_prefix", "=", "''", ",", "\n", "pipeline", "=", "None", ",", "\n", "norm", "=", "10.", ",", "\n", "link_type", "=", "'one-to-one'", ",", "\n", "edge_thr", "=", "0.5", ",", "\n", "test_mode", "=", "True", ",", "\n", "key_node_idx", "=", "1", ",", "\n", "value_node_idx", "=", "2", ",", "\n", "node_classes", "=", "4", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "ann_file", ",", "loader", ",", "dict_file", ",", "img_prefix", ",", "pipeline", ",", "\n", "norm", ",", "False", ",", "test_mode", ")", "\n", "assert", "link_type", "in", "[", "\n", "'one-to-one'", ",", "'one-to-many'", ",", "'many-to-one'", ",", "'many-to-many'", ",", "'none'", "\n", "]", "\n", "self", ".", "link_type", "=", "link_type", "\n", "self", ".", "data_dict", "=", "{", "x", "[", "'file_name'", "]", ":", "x", "for", "x", "in", "self", ".", "data_infos", "}", "\n", "self", ".", "edge_thr", "=", "edge_thr", "\n", "self", ".", "key_node_idx", "=", "key_node_idx", "\n", "self", ".", "value_node_idx", "=", "value_node_idx", "\n", "self", ".", "node_classes", "=", "node_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.pre_pipeline": [[61, 65], ["super().pre_pipeline"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline"], ["", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "super", "(", ")", ".", "pre_pipeline", "(", "results", ")", "\n", "results", "[", "'ori_texts'", "]", "=", "results", "[", "'ann_info'", "]", "[", "'ori_texts'", "]", "\n", "results", "[", "'ori_bboxes'", "]", "=", "results", "[", "'ann_info'", "]", "[", "'ori_bboxes'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.list_to_numpy": [[66, 72], ["super().list_to_numpy", "super().list_to_numpy.update", "super().list_to_numpy.update", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.list_to_numpy"], ["", "def", "list_to_numpy", "(", "self", ",", "ann_infos", ")", ":", "\n", "        ", "results", "=", "super", "(", ")", ".", "list_to_numpy", "(", "ann_infos", ")", "\n", "results", ".", "update", "(", "dict", "(", "ori_texts", "=", "ann_infos", "[", "'texts'", "]", ")", ")", "\n", "results", ".", "update", "(", "dict", "(", "ori_bboxes", "=", "ann_infos", "[", "'boxes'", "]", ")", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.evaluate": [[73, 97], ["copy.deepcopy", "openset_kie_dataset.OpensetKIEDataset.compute_openset_f1", "isinstance", "openset_kie_dataset.OpensetKIEDataset.decode_pred", "preds.append", "openset_kie_dataset.OpensetKIEDataset.decode_gt", "gts.append", "KeyError"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.compute_openset_f1", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.decode_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.decode_gt"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'openset_f1'", ",", "\n", "metric_options", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "# Protect ``metric_options`` since it uses mutable value as default", "\n", "        ", "metric_options", "=", "copy", ".", "deepcopy", "(", "metric_options", ")", "\n", "\n", "metrics", "=", "metric", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "allowed_metrics", "=", "[", "'openset_f1'", "]", "\n", "for", "m", "in", "metrics", ":", "\n", "            ", "if", "m", "not", "in", "allowed_metrics", ":", "\n", "                ", "raise", "KeyError", "(", "f'metric {m} is not supported'", ")", "\n", "\n", "", "", "preds", ",", "gts", "=", "[", "]", ",", "[", "]", "\n", "for", "result", "in", "results", ":", "\n", "# data for preds", "\n", "            ", "pred", "=", "self", ".", "decode_pred", "(", "result", ")", "\n", "preds", ".", "append", "(", "pred", ")", "\n", "# data for gts", "\n", "gt", "=", "self", ".", "decode_gt", "(", "pred", "[", "'filename'", "]", ")", "\n", "gts", ".", "append", "(", "gt", ")", "\n", "\n", "", "return", "self", ".", "compute_openset_f1", "(", "preds", ",", "gts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset._decode_pairs_gt": [[98, 112], ["enumerate", "enumerate", "gt_pairs.append"], "methods", ["None"], ["", "def", "_decode_pairs_gt", "(", "self", ",", "labels", ",", "edge_ids", ")", ":", "\n", "        ", "\"\"\"Find all pairs in gt.\n\n        The first index in the pair (n1, n2) is key.\n        \"\"\"", "\n", "gt_pairs", "=", "[", "]", "\n", "for", "i", ",", "label", "in", "enumerate", "(", "labels", ")", ":", "\n", "            ", "if", "label", "==", "self", ".", "key_node_idx", ":", "\n", "                ", "for", "j", ",", "edge_id", "in", "enumerate", "(", "edge_ids", ")", ":", "\n", "                    ", "if", "edge_id", "==", "edge_ids", "[", "i", "]", "and", "labels", "[", "\n", "j", "]", "==", "self", ".", "value_node_idx", ":", "\n", "                        ", "gt_pairs", ".", "append", "(", "(", "i", ",", "j", ")", ")", "\n", "\n", "", "", "", "", "return", "gt_pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset._decode_pairs_pred": [[113, 155], ["torch.max", "torch.max.clone", "edges[].item", "numpy.unravel_index", "pred_pairs.append", "zip", "torch.argmax", "n1.item", "n2.item", "n2.item", "n1.item", "ValueError"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_decode_pairs_pred", "(", "nodes", ",", "\n", "labels", ",", "\n", "edges", ",", "\n", "edge_thr", "=", "0.5", ",", "\n", "link_type", "=", "'one-to-one'", ")", ":", "\n", "        ", "\"\"\"Find all pairs in prediction.\n\n        The first index in the pair (n1, n2) is more likely to be a key\n        according to prediction in nodes.\n        \"\"\"", "\n", "edges", "=", "torch", ".", "max", "(", "edges", ",", "edges", ".", "T", ")", "\n", "if", "link_type", "in", "[", "'none'", ",", "'many-to-many'", "]", ":", "\n", "            ", "pair_inds", "=", "(", "edges", ">", "edge_thr", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "\n", "pred_pairs", "=", "[", "(", "n1", ".", "item", "(", ")", ",", "\n", "n2", ".", "item", "(", ")", ")", "if", "nodes", "[", "n1", ",", "1", "]", ">", "nodes", "[", "n1", ",", "2", "]", "else", "\n", "(", "n2", ".", "item", "(", ")", ",", "n1", ".", "item", "(", ")", ")", "for", "n1", ",", "n2", "in", "zip", "(", "*", "pair_inds", ")", "\n", "if", "n1", "<", "n2", "]", "\n", "pred_pairs", "=", "[", "(", "i", ",", "j", ")", "for", "i", ",", "j", "in", "pred_pairs", "\n", "if", "labels", "[", "i", "]", "==", "1", "and", "labels", "[", "j", "]", "==", "2", "]", "\n", "", "else", ":", "\n", "            ", "links", "=", "edges", ".", "clone", "(", ")", "\n", "links", "[", "links", "<=", "edge_thr", "]", "=", "-", "1", "\n", "links", "[", "labels", "!=", "1", ",", ":", "]", "=", "-", "1", "\n", "links", "[", ":", ",", "labels", "!=", "2", "]", "=", "-", "1", "\n", "\n", "pred_pairs", "=", "[", "]", "\n", "while", "(", "links", ">", "-", "1", ")", ".", "any", "(", ")", ":", "\n", "                ", "i", ",", "j", "=", "np", ".", "unravel_index", "(", "torch", ".", "argmax", "(", "links", ")", ",", "links", ".", "shape", ")", "\n", "pred_pairs", ".", "append", "(", "(", "i", ",", "j", ")", ")", "\n", "if", "link_type", "==", "'one-to-one'", ":", "\n", "                    ", "links", "[", "i", ",", ":", "]", "=", "-", "1", "\n", "links", "[", ":", ",", "j", "]", "=", "-", "1", "\n", "", "elif", "link_type", "==", "'one-to-many'", ":", "\n", "                    ", "links", "[", ":", ",", "j", "]", "=", "-", "1", "\n", "", "elif", "link_type", "==", "'many-to-one'", ":", "\n", "                    ", "links", "[", "i", ",", ":", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "f'not supported link type {link_type}'", ")", "\n", "\n", "", "", "", "pairs_conf", "=", "[", "edges", "[", "i", ",", "j", "]", ".", "item", "(", ")", "for", "i", ",", "j", "in", "pred_pairs", "]", "\n", "return", "pred_pairs", ",", "pairs_conf", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.decode_pred": [[156, 186], ["result[].cpu", "torch.max", "result[].cpu.size", "[].view().cpu", "torch.cat", "openset_kie_dataset.OpensetKIEDataset._decode_pairs_pred", "torch.Tensor", "torch.cat.tolist", "labels.tolist", "labels_conf.tolist", "[].view", "labels[].float"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset._decode_pairs_pred"], ["", "def", "decode_pred", "(", "self", ",", "result", ")", ":", "\n", "        ", "\"\"\"Decode prediction.\n\n        Assemble boxes and predicted labels into bboxes, and convert edges into\n        matrix.\n        \"\"\"", "\n", "filename", "=", "result", "[", "'img_metas'", "]", "[", "0", "]", "[", "'ori_filename'", "]", "\n", "nodes", "=", "result", "[", "'nodes'", "]", ".", "cpu", "(", ")", "\n", "labels_conf", ",", "labels", "=", "torch", ".", "max", "(", "nodes", ",", "dim", "=", "-", "1", ")", "\n", "num_nodes", "=", "nodes", ".", "size", "(", "0", ")", "\n", "edges", "=", "result", "[", "'edges'", "]", "[", ":", ",", "-", "1", "]", ".", "view", "(", "num_nodes", ",", "num_nodes", ")", ".", "cpu", "(", ")", "\n", "annos", "=", "self", ".", "data_dict", "[", "filename", "]", "[", "'annotations'", "]", "\n", "boxes", "=", "[", "x", "[", "'box'", "]", "for", "x", "in", "annos", "]", "\n", "texts", "=", "[", "x", "[", "'text'", "]", "for", "x", "in", "annos", "]", "\n", "bboxes", "=", "torch", ".", "Tensor", "(", "boxes", ")", "[", ":", ",", "[", "0", ",", "1", ",", "4", ",", "5", "]", "]", "\n", "bboxes", "=", "torch", ".", "cat", "(", "[", "bboxes", ",", "labels", "[", ":", ",", "None", "]", ".", "float", "(", ")", "]", ",", "-", "1", ")", "\n", "pairs", ",", "pairs_conf", "=", "self", ".", "_decode_pairs_pred", "(", "nodes", ",", "labels", ",", "edges", ",", "\n", "self", ".", "edge_thr", ",", "\n", "self", ".", "link_type", ")", "\n", "pred", "=", "{", "\n", "'filename'", ":", "filename", ",", "\n", "'boxes'", ":", "boxes", ",", "\n", "'bboxes'", ":", "bboxes", ".", "tolist", "(", ")", ",", "\n", "'labels'", ":", "labels", ".", "tolist", "(", ")", ",", "\n", "'labels_conf'", ":", "labels_conf", ".", "tolist", "(", ")", ",", "\n", "'texts'", ":", "texts", ",", "\n", "'pairs'", ":", "pairs", ",", "\n", "'pairs_conf'", ":", "pairs_conf", "\n", "}", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.decode_gt": [[187, 211], ["torch.Tensor", "torch.cat", "openset_kie_dataset.OpensetKIEDataset._decode_pairs_gt", "torch.Tensor", "torch.cat.tolist", "torch.Tensor.tolist", "labels[].float"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset._decode_pairs_gt"], ["", "def", "decode_gt", "(", "self", ",", "filename", ")", ":", "\n", "        ", "\"\"\"Decode ground truth.\n\n        Assemble boxes and labels into bboxes.\n        \"\"\"", "\n", "annos", "=", "self", ".", "data_dict", "[", "filename", "]", "[", "'annotations'", "]", "\n", "labels", "=", "torch", ".", "Tensor", "(", "[", "x", "[", "'label'", "]", "for", "x", "in", "annos", "]", ")", "\n", "texts", "=", "[", "x", "[", "'text'", "]", "for", "x", "in", "annos", "]", "\n", "edge_ids", "=", "[", "x", "[", "'edge'", "]", "for", "x", "in", "annos", "]", "\n", "boxes", "=", "[", "x", "[", "'box'", "]", "for", "x", "in", "annos", "]", "\n", "bboxes", "=", "torch", ".", "Tensor", "(", "boxes", ")", "[", ":", ",", "[", "0", ",", "1", ",", "4", ",", "5", "]", "]", "\n", "bboxes", "=", "torch", ".", "cat", "(", "[", "bboxes", ",", "labels", "[", ":", ",", "None", "]", ".", "float", "(", ")", "]", ",", "-", "1", ")", "\n", "pairs", "=", "self", ".", "_decode_pairs_gt", "(", "labels", ",", "edge_ids", ")", "\n", "gt", "=", "{", "\n", "'filename'", ":", "filename", ",", "\n", "'boxes'", ":", "boxes", ",", "\n", "'bboxes'", ":", "bboxes", ".", "tolist", "(", ")", ",", "\n", "'labels'", ":", "labels", ".", "tolist", "(", ")", ",", "\n", "'labels_conf'", ":", "[", "1.", "for", "_", "in", "labels", "]", ",", "\n", "'texts'", ":", "texts", ",", "\n", "'pairs'", ":", "pairs", ",", "\n", "'pairs_conf'", ":", "[", "1.", "for", "_", "in", "pairs", "]", "\n", "}", "\n", "return", "gt", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.compute_openset_f1": [[212, 310], ["list", "zip", "numpy.mean", "range", "len", "len", "enumerate", "max", "max", "max", "max", "max", "max", "max", "max", "max", "int", "max", "max", "max", "len", "len", "node_macro_metric.items"], "methods", ["None"], ["", "def", "compute_openset_f1", "(", "self", ",", "preds", ",", "gts", ")", ":", "\n", "        ", "\"\"\"Compute openset macro-f1 and micro-f1 score.\n\n        Args:\n            preds: (list[dict]): List of prediction results, including\n                keys: ``filename``, ``pairs``, etc.\n            gts: (list[dict]): List of ground-truth infos, including\n                keys: ``filename``, ``pairs``, etc.\n\n        Returns:\n            dict: Evaluation result with keys: ``node_openset_micro_f1``, \\\n                ``node_openset_macro_f1``, ``edge_openset_f1``.\n        \"\"\"", "\n", "\n", "total_edge_hit_num", ",", "total_edge_gt_num", ",", "total_edge_pred_num", "=", "0", ",", "0", ",", "0", "\n", "total_node_hit_num", ",", "total_node_gt_num", ",", "total_node_pred_num", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "node_inds", "=", "list", "(", "range", "(", "self", ".", "node_classes", ")", ")", "\n", "for", "node_idx", "in", "node_inds", ":", "\n", "            ", "total_node_hit_num", "[", "node_idx", "]", "=", "0", "\n", "total_node_gt_num", "[", "node_idx", "]", "=", "0", "\n", "total_node_pred_num", "[", "node_idx", "]", "=", "0", "\n", "\n", "", "img_level_res", "=", "{", "}", "\n", "for", "pred", ",", "gt", "in", "zip", "(", "preds", ",", "gts", ")", ":", "\n", "            ", "filename", "=", "pred", "[", "'filename'", "]", "\n", "img_res", "=", "{", "}", "\n", "# edge metric related", "\n", "pairs_pred", "=", "pred", "[", "'pairs'", "]", "\n", "pairs_gt", "=", "gt", "[", "'pairs'", "]", "\n", "img_res", "[", "'edge_hit_num'", "]", "=", "0", "\n", "for", "pair", "in", "pairs_gt", ":", "\n", "                ", "if", "pair", "in", "pairs_pred", ":", "\n", "                    ", "img_res", "[", "'edge_hit_num'", "]", "+=", "1", "\n", "", "", "img_res", "[", "'edge_recall'", "]", "=", "1.0", "*", "img_res", "[", "'edge_hit_num'", "]", "/", "max", "(", "\n", "1", ",", "len", "(", "pairs_gt", ")", ")", "\n", "img_res", "[", "'edge_precision'", "]", "=", "1.0", "*", "img_res", "[", "'edge_hit_num'", "]", "/", "max", "(", "\n", "1", ",", "len", "(", "pairs_pred", ")", ")", "\n", "img_res", "[", "'f1'", "]", "=", "2", "*", "img_res", "[", "'edge_recall'", "]", "*", "img_res", "[", "\n", "'edge_precision'", "]", "/", "max", "(", "\n", "1", ",", "img_res", "[", "'edge_recall'", "]", "+", "img_res", "[", "'edge_precision'", "]", ")", "\n", "total_edge_hit_num", "+=", "img_res", "[", "'edge_hit_num'", "]", "\n", "total_edge_gt_num", "+=", "len", "(", "pairs_gt", ")", "\n", "total_edge_pred_num", "+=", "len", "(", "pairs_pred", ")", "\n", "\n", "# node metric related", "\n", "nodes_pred", "=", "pred", "[", "'labels'", "]", "\n", "nodes_gt", "=", "gt", "[", "'labels'", "]", "\n", "for", "i", ",", "node_gt", "in", "enumerate", "(", "nodes_gt", ")", ":", "\n", "                ", "node_gt", "=", "int", "(", "node_gt", ")", "\n", "total_node_gt_num", "[", "node_gt", "]", "+=", "1", "\n", "if", "nodes_pred", "[", "i", "]", "==", "node_gt", ":", "\n", "                    ", "total_node_hit_num", "[", "node_gt", "]", "+=", "1", "\n", "", "", "for", "node_pred", "in", "nodes_pred", ":", "\n", "                ", "total_node_pred_num", "[", "node_pred", "]", "+=", "1", "\n", "\n", "", "img_level_res", "[", "filename", "]", "=", "img_res", "\n", "\n", "", "stats", "=", "{", "}", "\n", "# edge f1", "\n", "total_edge_recall", "=", "1.0", "*", "total_edge_hit_num", "/", "max", "(", "\n", "1", ",", "total_edge_gt_num", ")", "\n", "total_edge_precision", "=", "1.0", "*", "total_edge_hit_num", "/", "max", "(", "\n", "1", ",", "total_edge_pred_num", ")", "\n", "edge_f1", "=", "2", "*", "total_edge_recall", "*", "total_edge_precision", "/", "max", "(", "\n", "1", ",", "total_edge_recall", "+", "total_edge_precision", ")", "\n", "stats", "=", "{", "'edge_openset_f1'", ":", "edge_f1", "}", "\n", "\n", "# node f1", "\n", "cared_node_hit_num", ",", "cared_node_gt_num", ",", "cared_node_pred_num", "=", "0", ",", "0", ",", "0", "\n", "node_macro_metric", "=", "{", "}", "\n", "for", "node_idx", "in", "node_inds", ":", "\n", "            ", "if", "node_idx", "<", "1", "or", "node_idx", ">", "2", ":", "\n", "                ", "continue", "\n", "", "cared_node_hit_num", "+=", "total_node_hit_num", "[", "node_idx", "]", "\n", "cared_node_gt_num", "+=", "total_node_gt_num", "[", "node_idx", "]", "\n", "cared_node_pred_num", "+=", "total_node_pred_num", "[", "node_idx", "]", "\n", "node_res", "=", "{", "}", "\n", "node_res", "[", "'recall'", "]", "=", "1.0", "*", "total_node_hit_num", "[", "node_idx", "]", "/", "max", "(", "\n", "1", ",", "total_node_gt_num", "[", "node_idx", "]", ")", "\n", "node_res", "[", "'precision'", "]", "=", "1.0", "*", "total_node_hit_num", "[", "node_idx", "]", "/", "max", "(", "\n", "1", ",", "total_node_pred_num", "[", "node_idx", "]", ")", "\n", "node_res", "[", "\n", "'f1'", "]", "=", "2", "*", "node_res", "[", "'recall'", "]", "*", "node_res", "[", "'precision'", "]", "/", "max", "(", "\n", "1", ",", "node_res", "[", "'recall'", "]", "+", "node_res", "[", "'precision'", "]", ")", "\n", "node_macro_metric", "[", "node_idx", "]", "=", "node_res", "\n", "\n", "", "node_micro_recall", "=", "1.0", "*", "cared_node_hit_num", "/", "max", "(", "\n", "1", ",", "cared_node_gt_num", ")", "\n", "node_micro_precision", "=", "1.0", "*", "cared_node_hit_num", "/", "max", "(", "\n", "1", ",", "cared_node_pred_num", ")", "\n", "node_micro_f1", "=", "2", "*", "node_micro_recall", "*", "node_micro_precision", "/", "max", "(", "\n", "1", ",", "node_micro_recall", "+", "node_micro_precision", ")", "\n", "\n", "stats", "[", "'node_openset_micro_f1'", "]", "=", "node_micro_f1", "\n", "stats", "[", "'node_openset_macro_f1'", "]", "=", "np", ".", "mean", "(", "\n", "[", "v", "[", "'f1'", "]", "for", "k", ",", "v", "in", "node_macro_metric", ".", "items", "(", ")", "]", ")", "\n", "\n", "return", "stats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ocr_seg_dataset.OCRSegDataset.pre_pipeline": [[11, 13], ["None"], "methods", ["None"], ["    ", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "[", "'img_prefix'", "]", "=", "self", ".", "img_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ocr_seg_dataset.OCRSegDataset._parse_anno_info": [[14, 71], ["mmocr.is_type_list", "dict", "len", "chars.append", "len", "dict.get", "char_rects.append", "char_quads.append", "len", "range", "char_rects.append", "char_quads.append", "Exception", "char_rects.append", "char_quads.append", "ValueError", "x_list.append", "y_list.append", "max", "min", "max", "min", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "_parse_anno_info", "(", "self", ",", "annotations", ")", ":", "\n", "        ", "\"\"\"Parse char boxes annotations.\n        Args:\n            annotations (list[dict]): Annotations of one image, where\n                each dict is for one character.\n\n        Returns:\n            dict: A dict containing the following keys:\n\n                - chars (list[str]): List of character strings.\n                - char_rects (list[list[float]]): List of char box, with each\n                    in style of rectangle: [x_min, y_min, x_max, y_max].\n                - char_quads (list[list[float]]): List of char box, with each\n                    in style of quadrangle: [x1, y1, x2, y2, x3, y3, x4, y4].\n        \"\"\"", "\n", "\n", "assert", "utils", ".", "is_type_list", "(", "annotations", ",", "dict", ")", "\n", "assert", "'char_box'", "in", "annotations", "[", "0", "]", "\n", "assert", "'char_text'", "in", "annotations", "[", "0", "]", "\n", "assert", "len", "(", "annotations", "[", "0", "]", "[", "'char_box'", "]", ")", "in", "[", "4", ",", "8", "]", "\n", "\n", "chars", ",", "char_rects", ",", "char_quads", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "ann", "in", "annotations", ":", "\n", "            ", "char_box", "=", "ann", "[", "'char_box'", "]", "\n", "if", "len", "(", "char_box", ")", "==", "4", ":", "\n", "                ", "char_box_type", "=", "ann", ".", "get", "(", "'char_box_type'", ",", "'xyxy'", ")", "\n", "if", "char_box_type", "==", "'xyxy'", ":", "\n", "                    ", "char_rects", ".", "append", "(", "char_box", ")", "\n", "char_quads", ".", "append", "(", "[", "\n", "char_box", "[", "0", "]", ",", "char_box", "[", "1", "]", ",", "char_box", "[", "2", "]", ",", "char_box", "[", "1", "]", ",", "\n", "char_box", "[", "2", "]", ",", "char_box", "[", "3", "]", ",", "char_box", "[", "0", "]", ",", "char_box", "[", "3", "]", "\n", "]", ")", "\n", "", "elif", "char_box_type", "==", "'xywh'", ":", "\n", "                    ", "x1", ",", "y1", ",", "w", ",", "h", "=", "char_box", "\n", "x2", "=", "x1", "+", "w", "\n", "y2", "=", "y1", "+", "h", "\n", "char_rects", ".", "append", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ")", "\n", "char_quads", ".", "append", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y1", ",", "x2", ",", "y2", ",", "x1", ",", "y2", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "f'invalid char_box_type {char_box_type}'", ")", "\n", "", "", "elif", "len", "(", "char_box", ")", "==", "8", ":", "\n", "                ", "x_list", ",", "y_list", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "                    ", "x_list", ".", "append", "(", "char_box", "[", "2", "*", "i", "]", ")", "\n", "y_list", ".", "append", "(", "char_box", "[", "2", "*", "i", "+", "1", "]", ")", "\n", "", "x_max", ",", "x_min", "=", "max", "(", "x_list", ")", ",", "min", "(", "x_list", ")", "\n", "y_max", ",", "y_min", "=", "max", "(", "y_list", ")", ",", "min", "(", "y_list", ")", "\n", "char_rects", ".", "append", "(", "[", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", "]", ")", "\n", "char_quads", ".", "append", "(", "char_box", ")", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\n", "f'invalid num in char box: {len(char_box)} not in (4, 8)'", ")", "\n", "", "chars", ".", "append", "(", "ann", "[", "'char_text'", "]", ")", "\n", "\n", "", "ann", "=", "dict", "(", "chars", "=", "chars", ",", "char_rects", "=", "char_rects", ",", "char_quads", "=", "char_quads", ")", "\n", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ocr_seg_dataset.OCRSegDataset.prepare_train_img": [[72, 92], ["ocr_seg_dataset.OCRSegDataset._parse_anno_info", "dict", "ocr_seg_dataset.OCRSegDataset.pre_pipeline", "ocr_seg_dataset.OCRSegDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline"], ["", "def", "prepare_train_img", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations from pipeline.\n\n        Args:\n            index (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys\n                introduced by pipeline.\n        \"\"\"", "\n", "img_ann_info", "=", "self", ".", "data_infos", "[", "index", "]", "\n", "img_info", "=", "{", "\n", "'filename'", ":", "img_ann_info", "[", "'file_name'", "]", ",", "\n", "}", "\n", "ann_info", "=", "self", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ",", "ann_info", "=", "ann_info", ")", "\n", "\n", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ner_dataset.NerDataset.prepare_train_img": [[21, 34], ["ner_dataset.NerDataset.pipeline"], "methods", ["None"], ["def", "prepare_train_img", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations after pipeline.\n\n        Args:\n            index (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys \\\n                introduced by pipeline.\n        \"\"\"", "\n", "ann_info", "=", "self", ".", "data_infos", "[", "index", "]", "\n", "\n", "return", "self", ".", "pipeline", "(", "ann_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.ner_dataset.NerDataset.evaluate": [[35, 50], ["list", "mmocr.core.evaluation.ner_metric.eval_ner_f1"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric.eval_ner_f1"], ["", "def", "evaluate", "(", "self", ",", "results", ",", "metric", "=", "None", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the dataset.\n\n        Args:\n            results (list): Testing results of the dataset.\n            metric (str | list[str]): Metrics to be evaluated.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n        Returns:\n            info (dict): A dict containing the following keys:\n             'acc', 'recall', 'f1-score'.\n        \"\"\"", "\n", "gt_infos", "=", "list", "(", "self", ".", "data_infos", ")", "\n", "eval_results", "=", "eval_ner_f1", "(", "results", ",", "gt_infos", ")", "\n", "return", "eval_results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.__init__": [[32, 63], ["warnings.warn", "mmocr.datasets.base_dataset.BaseDataset.__init__", "os.path.exists", "line.rstrip", "enumerate", "mmocr.utils.list_from_file"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["def", "__init__", "(", "self", ",", "\n", "ann_file", "=", "None", ",", "\n", "loader", "=", "None", ",", "\n", "dict_file", "=", "None", ",", "\n", "img_prefix", "=", "''", ",", "\n", "pipeline", "=", "None", ",", "\n", "norm", "=", "10.", ",", "\n", "directed", "=", "False", ",", "\n", "test_mode", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "if", "ann_file", "is", "None", "and", "loader", "is", "None", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "'KIEDataset is only initialized as a downstream demo task '", "\n", "'of text detection and recognition '", "\n", "'without an annotation file.'", ",", "UserWarning", ")", "\n", "", "else", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "ann_file", ",", "\n", "loader", ",", "\n", "pipeline", ",", "\n", "img_prefix", "=", "img_prefix", ",", "\n", "test_mode", "=", "test_mode", ")", "\n", "assert", "osp", ".", "exists", "(", "dict_file", ")", "\n", "\n", "", "self", ".", "norm", "=", "norm", "\n", "self", ".", "directed", "=", "directed", "\n", "self", ".", "dict", "=", "{", "\n", "''", ":", "0", ",", "\n", "**", "{", "\n", "line", ".", "rstrip", "(", "'\\r\\n'", ")", ":", "ind", "\n", "for", "ind", ",", "line", "in", "enumerate", "(", "list_from_file", "(", "dict_file", ")", ",", "1", ")", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline": [[66, 75], ["os.path.join", "numpy.zeros"], "methods", ["None"], ["", "def", "pre_pipeline", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "[", "'img_prefix'", "]", "=", "self", ".", "img_prefix", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "]", "\n", "results", "[", "'ori_texts'", "]", "=", "results", "[", "'ann_info'", "]", "[", "'ori_texts'", "]", "\n", "results", "[", "'filename'", "]", "=", "osp", ".", "join", "(", "self", ".", "img_prefix", ",", "\n", "results", "[", "'img_info'", "]", "[", "'filename'", "]", ")", "\n", "results", "[", "'ori_filename'", "]", "=", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "# a dummy img data", "\n", "results", "[", "'img'", "]", "=", "np", ".", "zeros", "(", "(", "0", ",", "0", ",", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info": [[76, 120], ["mmocr.utils.is_type_list", "dict", "kie_dataset.KIEDataset.list_to_numpy", "len", "mmocr.datasets.pipelines.sort_vertex8", "boxes.append", "texts.append", "text_inds.append", "labels.append", "edges.append", "ann.get", "ann.get"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.list_to_numpy", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex8"], ["", "def", "_parse_anno_info", "(", "self", ",", "annotations", ")", ":", "\n", "        ", "\"\"\"Parse annotations of boxes, texts and labels for one image.\n        Args:\n            annotations (list[dict]): Annotations of one image, where\n                each dict is for one character.\n\n        Returns:\n            dict: A dict containing the following keys:\n\n                - bboxes (np.ndarray): Bbox in one image with shape:\n                    box_num * 4. They are sorted clockwise when loading.\n                - relations (np.ndarray): Relations between bbox with shape:\n                    box_num * box_num * D.\n                - texts (np.ndarray): Text index with shape:\n                    box_num * text_max_len.\n                - labels (np.ndarray): Box Labels with shape:\n                    box_num * (box_num + 1).\n        \"\"\"", "\n", "\n", "assert", "is_type_list", "(", "annotations", ",", "dict", ")", "\n", "assert", "len", "(", "annotations", ")", ">", "0", ",", "'Please remove data with empty annotation'", "\n", "assert", "'box'", "in", "annotations", "[", "0", "]", "\n", "assert", "'text'", "in", "annotations", "[", "0", "]", "\n", "\n", "boxes", ",", "texts", ",", "text_inds", ",", "labels", ",", "edges", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "ann", "in", "annotations", ":", "\n", "            ", "box", "=", "ann", "[", "'box'", "]", "\n", "sorted_box", "=", "sort_vertex8", "(", "box", "[", ":", "8", "]", ")", "\n", "boxes", ".", "append", "(", "sorted_box", ")", "\n", "text", "=", "ann", "[", "'text'", "]", "\n", "texts", ".", "append", "(", "ann", "[", "'text'", "]", ")", "\n", "text_ind", "=", "[", "self", ".", "dict", "[", "c", "]", "for", "c", "in", "text", "if", "c", "in", "self", ".", "dict", "]", "\n", "text_inds", ".", "append", "(", "text_ind", ")", "\n", "labels", ".", "append", "(", "ann", ".", "get", "(", "'label'", ",", "0", ")", ")", "\n", "edges", ".", "append", "(", "ann", ".", "get", "(", "'edge'", ",", "0", ")", ")", "\n", "\n", "", "ann_infos", "=", "dict", "(", "\n", "boxes", "=", "boxes", ",", "\n", "texts", "=", "texts", ",", "\n", "text_inds", "=", "text_inds", ",", "\n", "edges", "=", "edges", ",", "\n", "labels", "=", "labels", ")", "\n", "\n", "return", "self", ".", "list_to_numpy", "(", "ann_infos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img": [[121, 143], ["kie_dataset.KIEDataset._parse_anno_info", "dict", "kie_dataset.KIEDataset.pre_pipeline", "kie_dataset.KIEDataset.pipeline"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline"], ["", "def", "prepare_train_img", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"Get training data and annotations from pipeline.\n\n        Args:\n            index (int): Index of data.\n\n        Returns:\n            dict: Training data and annotation after pipeline with new keys\n                introduced by pipeline.\n        \"\"\"", "\n", "img_ann_info", "=", "self", ".", "data_infos", "[", "index", "]", "\n", "img_info", "=", "{", "\n", "'filename'", ":", "img_ann_info", "[", "'file_name'", "]", ",", "\n", "'height'", ":", "img_ann_info", "[", "'height'", "]", ",", "\n", "'width'", ":", "img_ann_info", "[", "'width'", "]", "\n", "}", "\n", "ann_info", "=", "self", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ",", "ann_info", "=", "ann_info", ")", "\n", "\n", "self", ".", "pre_pipeline", "(", "results", ")", "\n", "\n", "return", "self", ".", "pipeline", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.evaluate": [[144, 162], ["dict", "set().issubset", "copy.deepcopy", "kie_dataset.KIEDataset.compute_macro_f1", "isinstance", "dict", "set", "KeyError"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.compute_macro_f1"], ["", "def", "evaluate", "(", "self", ",", "\n", "results", ",", "\n", "metric", "=", "'macro_f1'", ",", "\n", "metric_options", "=", "dict", "(", "macro_f1", "=", "dict", "(", "ignores", "=", "[", "]", ")", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "# allow some kwargs to pass through", "\n", "        ", "assert", "set", "(", "kwargs", ")", ".", "issubset", "(", "[", "'logger'", "]", ")", "\n", "\n", "# Protect ``metric_options`` since it uses mutable value as default", "\n", "metric_options", "=", "copy", ".", "deepcopy", "(", "metric_options", ")", "\n", "\n", "metrics", "=", "metric", "if", "isinstance", "(", "metric", ",", "list", ")", "else", "[", "metric", "]", "\n", "allowed_metrics", "=", "[", "'macro_f1'", "]", "\n", "for", "m", "in", "metrics", ":", "\n", "            ", "if", "m", "not", "in", "allowed_metrics", ":", "\n", "                ", "raise", "KeyError", "(", "f'metric {m} is not supported'", ")", "\n", "\n", "", "", "return", "self", ".", "compute_macro_f1", "(", "results", ",", "**", "metric_options", "[", "'macro_f1'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.compute_macro_f1": [[163, 179], ["enumerate", "torch.cat", "torch.cat().int", "mmocr.core.compute_f1_score", "torch.cat.append", "torch.cat().int.append", "mmocr.core.compute_f1_score.mean", "result[].cpu", "torch.Tensor", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.kie_metric.compute_f1_score"], ["", "def", "compute_macro_f1", "(", "self", ",", "results", ",", "ignores", "=", "[", "]", ")", ":", "\n", "        ", "node_preds", "=", "[", "]", "\n", "node_gts", "=", "[", "]", "\n", "for", "idx", ",", "result", "in", "enumerate", "(", "results", ")", ":", "\n", "            ", "node_preds", ".", "append", "(", "result", "[", "'nodes'", "]", ".", "cpu", "(", ")", ")", "\n", "box_ann_infos", "=", "self", ".", "data_infos", "[", "idx", "]", "[", "'annotations'", "]", "\n", "node_gt", "=", "[", "box_ann_info", "[", "'label'", "]", "for", "box_ann_info", "in", "box_ann_infos", "]", "\n", "node_gts", ".", "append", "(", "torch", ".", "Tensor", "(", "node_gt", ")", ")", "\n", "\n", "", "node_preds", "=", "torch", ".", "cat", "(", "node_preds", ")", "\n", "node_gts", "=", "torch", ".", "cat", "(", "node_gts", ")", ".", "int", "(", ")", "\n", "\n", "node_f1s", "=", "compute_f1_score", "(", "node_preds", ",", "node_gts", ",", "ignores", ")", "\n", "\n", "return", "{", "\n", "'macro_f1'", ":", "node_f1s", ".", "mean", "(", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.list_to_numpy": [[181, 208], ["numpy.array", "kie_dataset.KIEDataset.compute_relation", "ann_infos.get", "kie_dataset.KIEDataset.pad_text_indices", "dict", "numpy.array", "ann_infos.get", "numpy.array", "numpy.fill_diagonal", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.compute_relation", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pad_text_indices"], ["", "def", "list_to_numpy", "(", "self", ",", "ann_infos", ")", ":", "\n", "        ", "\"\"\"Convert bboxes, relations, texts and labels to ndarray.\"\"\"", "\n", "boxes", ",", "text_inds", "=", "ann_infos", "[", "'boxes'", "]", ",", "ann_infos", "[", "'text_inds'", "]", "\n", "texts", "=", "ann_infos", "[", "'texts'", "]", "\n", "boxes", "=", "np", ".", "array", "(", "boxes", ",", "np", ".", "int32", ")", "\n", "relations", ",", "bboxes", "=", "self", ".", "compute_relation", "(", "boxes", ")", "\n", "\n", "labels", "=", "ann_infos", ".", "get", "(", "'labels'", ",", "None", ")", "\n", "if", "labels", "is", "not", "None", ":", "\n", "            ", "labels", "=", "np", ".", "array", "(", "labels", ",", "np", ".", "int32", ")", "\n", "edges", "=", "ann_infos", ".", "get", "(", "'edges'", ",", "None", ")", "\n", "if", "edges", "is", "not", "None", ":", "\n", "                ", "labels", "=", "labels", "[", ":", ",", "None", "]", "\n", "edges", "=", "np", ".", "array", "(", "edges", ")", "\n", "edges", "=", "(", "edges", "[", ":", ",", "None", "]", "==", "edges", "[", "None", ",", ":", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "if", "self", ".", "directed", ":", "\n", "                    ", "edges", "=", "(", "edges", "&", "labels", "==", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "np", ".", "fill_diagonal", "(", "edges", ",", "-", "1", ")", "\n", "labels", "=", "np", ".", "concatenate", "(", "[", "labels", ",", "edges", "]", ",", "-", "1", ")", "\n", "", "", "padded_text_inds", "=", "self", ".", "pad_text_indices", "(", "text_inds", ")", "\n", "\n", "return", "dict", "(", "\n", "bboxes", "=", "bboxes", ",", "\n", "relations", "=", "relations", ",", "\n", "texts", "=", "padded_text_inds", ",", "\n", "ori_texts", "=", "texts", ",", "\n", "labels", "=", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pad_text_indices": [[209, 216], ["max", "enumerate", "numpy.ones", "numpy.array", "len", "len", "len"], "methods", ["None"], ["", "def", "pad_text_indices", "(", "self", ",", "text_inds", ")", ":", "\n", "        ", "\"\"\"Pad text index to same length.\"\"\"", "\n", "max_len", "=", "max", "(", "[", "len", "(", "text_ind", ")", "for", "text_ind", "in", "text_inds", "]", ")", "\n", "padded_text_inds", "=", "-", "np", ".", "ones", "(", "(", "len", "(", "text_inds", ")", ",", "max_len", ")", ",", "np", ".", "int32", ")", "\n", "for", "idx", ",", "text_ind", "in", "enumerate", "(", "text_inds", ")", ":", "\n", "            ", "padded_text_inds", "[", "idx", ",", ":", "len", "(", "text_ind", ")", "]", "=", "np", ".", "array", "(", "text_ind", ")", "\n", "", "return", "padded_text_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.compute_relation": [[217, 237], ["numpy.concatenate().astype", "numpy.stack().astype", "numpy.maximum", "numpy.maximum", "numpy.zeros_like", "numpy.concatenate", "numpy.stack", "boxes[].min", "boxes[].min", "boxes[].max", "boxes[].max"], "methods", ["None"], ["", "def", "compute_relation", "(", "self", ",", "boxes", ")", ":", "\n", "        ", "\"\"\"Compute relation between every two boxes.\"\"\"", "\n", "# Get minimal axis-aligned bounding boxes for each of the boxes", "\n", "# yapf: disable", "\n", "bboxes", "=", "np", ".", "concatenate", "(", "\n", "[", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", ".", "min", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", ",", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", ".", "min", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", ",", "\n", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", ".", "max", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", ",", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", ".", "max", "(", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "]", ",", "\n", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "# yapf: enable", "\n", "x1", ",", "y1", "=", "bboxes", "[", ":", ",", "0", ":", "1", "]", ",", "bboxes", "[", ":", ",", "1", ":", "2", "]", "\n", "x2", ",", "y2", "=", "bboxes", "[", ":", ",", "2", ":", "3", "]", ",", "bboxes", "[", ":", ",", "3", ":", "4", "]", "\n", "w", ",", "h", "=", "np", ".", "maximum", "(", "x2", "-", "x1", "+", "1", ",", "1", ")", ",", "np", ".", "maximum", "(", "y2", "-", "y1", "+", "1", ",", "1", ")", "\n", "dx", "=", "(", "x1", ".", "T", "-", "x1", ")", "/", "self", ".", "norm", "\n", "dy", "=", "(", "y1", ".", "T", "-", "y1", ")", "/", "self", ".", "norm", "\n", "xhh", ",", "xwh", "=", "h", ".", "T", "/", "h", ",", "w", ".", "T", "/", "h", "\n", "whs", "=", "w", "/", "h", "+", "np", ".", "zeros_like", "(", "xhh", ")", "\n", "relation", "=", "np", ".", "stack", "(", "[", "dx", ",", "dy", ",", "whs", ",", "xhh", ",", "xwh", "]", ",", "-", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "return", "relation", ",", "bboxes", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.__init__": [[39, 84], ["mmdet.datasets.ConcatDataset.__init__", "isinstance", "mmocr.utils.is_type_list", "mmocr.utils.is_2dlist", "mmdet.datasets.build_dataset", "NotImplementedError", "isinstance", "uniform_concat_dataset.UniformConcatDataset._apply_pipeline", "mmocr.utils.is_2dlist", "len", "len", "NotImplementedError", "mmocr.utils.is_2dlist", "zip", "new_datasets.extend", "len", "set", "len", "len", "uniform_concat_dataset.UniformConcatDataset._apply_pipeline", "new_datasets.extend", "type"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset._apply_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset._apply_pipeline"], ["def", "__init__", "(", "self", ",", "\n", "datasets", ",", "\n", "separate_eval", "=", "True", ",", "\n", "show_mean_scores", "=", "'auto'", ",", "\n", "pipeline", "=", "None", ",", "\n", "force_apply", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "new_datasets", "=", "[", "]", "\n", "if", "pipeline", "is", "not", "None", ":", "\n", "            ", "assert", "isinstance", "(", "\n", "pipeline", ",", "\n", "list", ")", ",", "'pipeline must be list[dict] or list[list[dict]].'", "\n", "if", "is_type_list", "(", "pipeline", ",", "dict", ")", ":", "\n", "                ", "self", ".", "_apply_pipeline", "(", "datasets", ",", "pipeline", ",", "force_apply", ")", "\n", "new_datasets", "=", "datasets", "\n", "", "elif", "is_2dlist", "(", "pipeline", ")", ":", "\n", "                ", "assert", "is_2dlist", "(", "datasets", ")", "\n", "assert", "len", "(", "datasets", ")", "==", "len", "(", "pipeline", ")", "\n", "for", "sub_datasets", ",", "tmp_pipeline", "in", "zip", "(", "datasets", ",", "pipeline", ")", ":", "\n", "                    ", "self", ".", "_apply_pipeline", "(", "sub_datasets", ",", "tmp_pipeline", ",", "\n", "force_apply", ")", "\n", "new_datasets", ".", "extend", "(", "sub_datasets", ")", "\n", "", "", "", "else", ":", "\n", "            ", "if", "is_2dlist", "(", "datasets", ")", ":", "\n", "                ", "for", "sub_datasets", "in", "datasets", ":", "\n", "                    ", "new_datasets", ".", "extend", "(", "sub_datasets", ")", "\n", "", "", "else", ":", "\n", "                ", "new_datasets", "=", "datasets", "\n", "", "", "datasets", "=", "[", "build_dataset", "(", "c", ",", "kwargs", ")", "for", "c", "in", "new_datasets", "]", "\n", "super", "(", ")", ".", "__init__", "(", "datasets", ",", "separate_eval", ")", "\n", "\n", "if", "not", "separate_eval", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "'Evaluating datasets as a whole is not'", "\n", "' supported yet. Please use \"separate_eval=True\"'", ")", "\n", "\n", "", "assert", "isinstance", "(", "show_mean_scores", ",", "bool", ")", "or", "show_mean_scores", "==", "'auto'", "\n", "if", "show_mean_scores", "==", "'auto'", ":", "\n", "            ", "show_mean_scores", "=", "len", "(", "self", ".", "datasets", ")", ">", "1", "\n", "", "self", ".", "show_mean_scores", "=", "show_mean_scores", "\n", "if", "show_mean_scores", "is", "True", "or", "show_mean_scores", "==", "'auto'", "and", "len", "(", "\n", "self", ".", "datasets", ")", ">", "1", ":", "\n", "            ", "if", "len", "(", "set", "(", "[", "type", "(", "ds", ")", "for", "ds", "in", "self", ".", "datasets", "]", ")", ")", "!=", "1", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "'To compute mean evaluation scores, all datasets'", "\n", "'must have the same type'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset._apply_pipeline": [[86, 94], ["all", "all", "isinstance", "isinstance", "copy.deepcopy"], "methods", ["None"], ["", "", "", "@", "staticmethod", "\n", "def", "_apply_pipeline", "(", "datasets", ",", "pipeline", ",", "force_apply", "=", "False", ")", ":", "\n", "        ", "from_cfg", "=", "all", "(", "isinstance", "(", "x", ",", "dict", ")", "for", "x", "in", "datasets", ")", "\n", "assert", "from_cfg", ",", "'datasets should be config dicts'", "\n", "assert", "all", "(", "isinstance", "(", "x", ",", "dict", ")", "for", "x", "in", "pipeline", ")", "\n", "for", "dataset", "in", "datasets", ":", "\n", "            ", "if", "dataset", "[", "'pipeline'", "]", "is", "None", "or", "force_apply", ":", "\n", "                ", "dataset", "[", "'pipeline'", "]", "=", "copy", ".", "deepcopy", "(", "pipeline", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate": [[95, 151], ["len", "hasattr", "dict", "NotImplementedError", "len", "collections.defaultdict", "mmcv.utils.print_log", "dataset.evaluate", "dataset.evaluate.items", "collections.defaultdict.items", "type", "dict.update", "numpy.mean", "mean_eval_results[].append", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "", "", "def", "evaluate", "(", "self", ",", "results", ",", "logger", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Evaluate the results.\n\n        Args:\n            results (list[list | tuple]): Testing results of the dataset.\n            logger (logging.Logger | str | None): Logger used for printing\n                related information during evaluation. Default: None.\n\n        Returns:\n            dict[str: float]: Results of each separate\n            dataset if `self.separate_eval=True`.\n        \"\"\"", "\n", "assert", "len", "(", "results", ")", "==", "self", ".", "cumulative_sizes", "[", "-", "1", "]", ",", "(", "'Dataset and results have different sizes: '", "\n", "f'{self.cumulative_sizes[-1]} v.s. {len(results)}'", ")", "\n", "\n", "# Check whether all the datasets support evaluation", "\n", "for", "dataset", "in", "self", ".", "datasets", ":", "\n", "            ", "assert", "hasattr", "(", "dataset", ",", "'evaluate'", ")", ",", "f'{type(dataset)} does not implement evaluate function'", "\n", "\n", "", "if", "self", ".", "separate_eval", ":", "\n", "            ", "dataset_idx", "=", "-", "1", "\n", "\n", "total_eval_results", "=", "dict", "(", ")", "\n", "\n", "if", "self", ".", "show_mean_scores", ":", "\n", "                ", "mean_eval_results", "=", "defaultdict", "(", "list", ")", "\n", "\n", "", "for", "dataset", "in", "self", ".", "datasets", ":", "\n", "                ", "start_idx", "=", "0", "if", "dataset_idx", "==", "-", "1", "else", "self", ".", "cumulative_sizes", "[", "dataset_idx", "]", "\n", "end_idx", "=", "self", ".", "cumulative_sizes", "[", "dataset_idx", "+", "1", "]", "\n", "\n", "results_per_dataset", "=", "results", "[", "start_idx", ":", "end_idx", "]", "\n", "print_log", "(", "\n", "f'\\nEvaluating {dataset.ann_file} with '", "\n", "f'{len(results_per_dataset)} images now'", ",", "\n", "logger", "=", "logger", ")", "\n", "\n", "eval_results_per_dataset", "=", "dataset", ".", "evaluate", "(", "\n", "results_per_dataset", ",", "logger", "=", "logger", ",", "**", "kwargs", ")", "\n", "dataset_idx", "+=", "1", "\n", "for", "k", ",", "v", "in", "eval_results_per_dataset", ".", "items", "(", ")", ":", "\n", "                    ", "total_eval_results", ".", "update", "(", "{", "f'{dataset_idx}_{k}'", ":", "v", "}", ")", "\n", "if", "self", ".", "show_mean_scores", ":", "\n", "                        ", "mean_eval_results", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "\n", "", "", "", "if", "self", ".", "show_mean_scores", ":", "\n", "                ", "for", "k", ",", "v", "in", "mean_eval_results", ".", "items", "(", ")", ":", "\n", "                    ", "total_eval_results", "[", "f'mean_{k}'", "]", "=", "np", ".", "mean", "(", "v", ")", "\n", "\n", "", "", "return", "total_eval_results", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "'Evaluating datasets as a whole is not'", "\n", "' supported yet. Please use \"separate_eval=True\"'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.__init__": [[28, 42], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "target_size", ",", "\n", "instance_key", ",", "\n", "mask_type", "=", "'inx0'", ",", "# 'inx0' or 'union_all'", "\n", "positive_sample_ratio", "=", "5.0", "/", "8.0", ")", ":", "\n", "\n", "        ", "assert", "mask_type", "in", "[", "'inx0'", ",", "'union_all'", "]", "\n", "\n", "self", ".", "mask_type", "=", "mask_type", "\n", "self", ".", "instance_key", "=", "instance_key", "\n", "self", ".", "positive_sample_ratio", "=", "positive_sample_ratio", "\n", "self", ".", "target_size", "=", "target_size", "if", "(", "target_size", "is", "None", "or", "isinstance", "(", "\n", "target_size", ",", "tuple", ")", ")", "else", "(", "target_size", ",", "target_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.sample_offset": [[43, 75], ["min", "min", "numpy.random.random_sample", "numpy.max", "numpy.min", "numpy.max", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "sample_offset", "(", "self", ",", "img_gt", ",", "img_size", ")", ":", "\n", "        ", "h", ",", "w", "=", "img_size", "\n", "t_h", ",", "t_w", "=", "self", ".", "target_size", "\n", "\n", "# target size is bigger than origin size", "\n", "t_h", "=", "t_h", "if", "t_h", "<", "h", "else", "h", "\n", "t_w", "=", "t_w", "if", "t_w", "<", "w", "else", "w", "\n", "if", "(", "img_gt", "is", "not", "None", "\n", "and", "np", ".", "random", ".", "random_sample", "(", ")", "<", "self", ".", "positive_sample_ratio", "\n", "and", "np", ".", "max", "(", "img_gt", ")", ">", "0", ")", ":", "\n", "\n", "# make sure to crop the positive region", "\n", "\n", "# the minimum top left to crop positive region (h,w)", "\n", "            ", "tl", "=", "np", ".", "min", "(", "np", ".", "where", "(", "img_gt", ">", "0", ")", ",", "axis", "=", "1", ")", "-", "(", "t_h", ",", "t_w", ")", "\n", "tl", "[", "tl", "<", "0", "]", "=", "0", "\n", "# the maximum top left to crop positive region", "\n", "br", "=", "np", ".", "max", "(", "np", ".", "where", "(", "img_gt", ">", "0", ")", ",", "axis", "=", "1", ")", "-", "(", "t_h", ",", "t_w", ")", "\n", "br", "[", "br", "<", "0", "]", "=", "0", "\n", "# if br is too big so that crop the outside region of img", "\n", "br", "[", "0", "]", "=", "min", "(", "br", "[", "0", "]", ",", "h", "-", "t_h", ")", "\n", "br", "[", "1", "]", "=", "min", "(", "br", "[", "1", "]", ",", "w", "-", "t_w", ")", "\n", "#", "\n", "h", "=", "np", ".", "random", ".", "randint", "(", "tl", "[", "0", "]", ",", "br", "[", "0", "]", ")", "if", "tl", "[", "0", "]", "<", "br", "[", "0", "]", "else", "0", "\n", "w", "=", "np", ".", "random", ".", "randint", "(", "tl", "[", "1", "]", ",", "br", "[", "1", "]", ")", "if", "tl", "[", "1", "]", "<", "br", "[", "1", "]", "else", "0", "\n", "", "else", ":", "\n", "# make sure not to crop outside of img", "\n", "\n", "            ", "h", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "h", "-", "t_h", ")", "if", "h", "-", "t_h", ">", "0", "else", "0", "\n", "w", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "w", "-", "t_w", ")", "if", "w", "-", "t_w", ">", "0", "else", "0", "\n", "\n", "", "return", "(", "h", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.crop_img": [[76, 85], ["numpy.min", "numpy.stack", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "crop_img", "(", "img", ",", "offset", ",", "target_size", ")", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "br", "=", "np", ".", "min", "(", "\n", "np", ".", "stack", "(", "(", "np", ".", "array", "(", "offset", ")", "+", "np", ".", "array", "(", "target_size", ")", ",", "np", ".", "array", "(", "\n", "(", "h", ",", "w", ")", ")", ")", ")", ",", "\n", "axis", "=", "0", ")", "\n", "return", "img", "[", "offset", "[", "0", "]", ":", "br", "[", "0", "]", ",", "offset", "[", "1", "]", ":", "br", "[", "1", "]", "]", ",", "np", ".", "array", "(", "\n", "[", "offset", "[", "1", "]", ",", "offset", "[", "0", "]", ",", "br", "[", "1", "]", ",", "br", "[", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.crop_bboxes": [[86, 110], ["mmocr.box2polygon", "enumerate", "mmocr.box2polygon", "mmocr.poly_intersection", "len", "numpy.stack", "numpy.array", "numpy.array().astype().reshape", "numpy.array().astype", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection"], ["", "def", "crop_bboxes", "(", "self", ",", "bboxes", ",", "canvas_bbox", ")", ":", "\n", "        ", "kept_bboxes", "=", "[", "]", "\n", "kept_inx", "=", "[", "]", "\n", "canvas_poly", "=", "eval_utils", ".", "box2polygon", "(", "canvas_bbox", ")", "\n", "tl", "=", "canvas_bbox", "[", "0", ":", "2", "]", "\n", "\n", "for", "idx", ",", "bbox", "in", "enumerate", "(", "bboxes", ")", ":", "\n", "            ", "poly", "=", "eval_utils", ".", "box2polygon", "(", "bbox", ")", "\n", "area", ",", "inters", "=", "eval_utils", ".", "poly_intersection", "(", "\n", "poly", ",", "canvas_poly", ",", "return_poly", "=", "True", ")", "\n", "if", "area", "==", "0", ":", "\n", "                ", "continue", "\n", "", "xmin", ",", "ymin", ",", "xmax", ",", "ymax", "=", "inters", ".", "bounds", "\n", "kept_bboxes", "+=", "[", "\n", "np", ".", "array", "(", "\n", "[", "xmin", "-", "tl", "[", "0", "]", ",", "ymin", "-", "tl", "[", "1", "]", ",", "xmax", "-", "tl", "[", "0", "]", ",", "ymax", "-", "tl", "[", "1", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "]", "\n", "kept_inx", "+=", "[", "idx", "]", "\n", "\n", "", "if", "len", "(", "kept_inx", ")", "==", "0", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "reshape", "(", "0", ",", "4", ")", ",", "kept_inx", "\n", "\n", "", "return", "np", ".", "stack", "(", "kept_bboxes", ")", ",", "kept_inx", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.generate_mask": [[111, 123], ["gt_mask.masks[].copy", "range", "len", "numpy.logical_or"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "generate_mask", "(", "gt_mask", ",", "type", ")", ":", "\n", "\n", "        ", "if", "type", "==", "'inx0'", ":", "\n", "            ", "return", "gt_mask", ".", "masks", "[", "0", "]", "\n", "", "if", "type", "==", "'union_all'", ":", "\n", "            ", "mask", "=", "gt_mask", ".", "masks", "[", "0", "]", ".", "copy", "(", ")", "\n", "for", "idx", "in", "range", "(", "1", ",", "len", "(", "gt_mask", ".", "masks", ")", ")", ":", "\n", "                ", "mask", "=", "np", ".", "logical_or", "(", "mask", ",", "gt_mask", ".", "masks", "[", "idx", "]", ")", "\n", "", "return", "mask", "\n", "\n", "", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.__call__": [[124, 173], ["torchvision.RandomCropInstances.sample_offset", "torchvision.RandomCropInstances.crop_img", "results.get", "results.get", "len", "torchvision.RandomCropInstances.generate_mask", "results[].crop", "torchvision.RandomCropInstances.crop_bboxes", "len", "mmdet.core.BitmapMasks", "len", "numpy.stack", "numpy.empty", "range", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.sample_offset", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.generate_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.crop_bboxes"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "gt_mask", "=", "results", "[", "self", ".", "instance_key", "]", "\n", "mask", "=", "None", "\n", "if", "len", "(", "gt_mask", ".", "masks", ")", ">", "0", ":", "\n", "            ", "mask", "=", "self", ".", "generate_mask", "(", "gt_mask", ",", "self", ".", "mask_type", ")", "\n", "", "results", "[", "'crop_offset'", "]", "=", "self", ".", "sample_offset", "(", "mask", ",", "\n", "results", "[", "'img'", "]", ".", "shape", "[", ":", "2", "]", ")", "\n", "\n", "# crop img. bbox = [x1,y1,x2,y2]", "\n", "img", ",", "bbox", "=", "self", ".", "crop_img", "(", "results", "[", "'img'", "]", ",", "results", "[", "'crop_offset'", "]", ",", "\n", "self", ".", "target_size", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "img_shape", "=", "img", ".", "shape", "\n", "results", "[", "'img_shape'", "]", "=", "img_shape", "\n", "\n", "# crop masks", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "crop", "(", "bbox", ")", "\n", "\n", "# for mask rcnn", "\n", "", "for", "key", "in", "results", ".", "get", "(", "'bbox_fields'", ",", "[", "]", ")", ":", "\n", "            ", "results", "[", "key", "]", ",", "kept_inx", "=", "self", ".", "crop_bboxes", "(", "results", "[", "key", "]", ",", "bbox", ")", "\n", "if", "key", "==", "'gt_bboxes'", ":", "\n", "# ignore gt_labels accordingly", "\n", "                ", "if", "'gt_labels'", "in", "results", ":", "\n", "                    ", "ori_labels", "=", "results", "[", "'gt_labels'", "]", "\n", "ori_inst_num", "=", "len", "(", "ori_labels", ")", "\n", "results", "[", "'gt_labels'", "]", "=", "[", "\n", "ori_labels", "[", "idx", "]", "for", "idx", "in", "range", "(", "ori_inst_num", ")", "\n", "if", "idx", "in", "kept_inx", "\n", "]", "\n", "# ignore g_masks accordingly", "\n", "", "if", "'gt_masks'", "in", "results", ":", "\n", "                    ", "ori_mask", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "kept_mask", "=", "[", "\n", "ori_mask", "[", "idx", "]", "for", "idx", "in", "range", "(", "ori_inst_num", ")", "\n", "if", "idx", "in", "kept_inx", "\n", "]", "\n", "target_h", ",", "target_w", "=", "bbox", "[", "3", "]", "-", "bbox", "[", "1", "]", ",", "bbox", "[", "2", "]", "-", "bbox", "[", "0", "]", "\n", "if", "len", "(", "kept_inx", ")", ">", "0", ":", "\n", "                        ", "kept_mask", "=", "np", ".", "stack", "(", "kept_mask", ")", "\n", "", "else", ":", "\n", "                        ", "kept_mask", "=", "np", ".", "empty", "(", "(", "0", ",", "target_h", ",", "target_w", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "", "results", "[", "'gt_masks'", "]", "=", "BitmapMasks", "(", "kept_mask", ",", "target_h", ",", "\n", "target_w", ")", "\n", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.__repr__": [[174, 177], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotateTextDet.__init__": [[183, 186], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "rotate_ratio", "=", "1.0", ",", "max_angle", "=", "10", ")", ":", "\n", "        ", "self", ".", "rotate_ratio", "=", "rotate_ratio", "\n", "self", ".", "max_angle", "=", "max_angle", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotateTextDet.sample_angle": [[187, 191], ["numpy.random.random_sample"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "sample_angle", "(", "max_angle", ")", ":", "\n", "        ", "angle", "=", "np", ".", "random", ".", "random_sample", "(", ")", "*", "2", "*", "max_angle", "-", "max_angle", "\n", "return", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotateTextDet.rotate_img": [[192, 200], ["cv2.getRotationMatrix2D", "cv2.warpAffine"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "rotate_img", "(", "img", ",", "angle", ")", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "rotation_matrix", "=", "cv2", ".", "getRotationMatrix2D", "(", "(", "w", "/", "2", ",", "h", "/", "2", ")", ",", "angle", ",", "1", ")", "\n", "img_target", "=", "cv2", ".", "warpAffine", "(", "\n", "img", ",", "rotation_matrix", ",", "(", "w", ",", "h", ")", ",", "flags", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "assert", "img_target", ".", "shape", "==", "img", ".", "shape", "\n", "return", "img_target", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotateTextDet.__call__": [[201, 220], ["numpy.random.random_sample", "torchvision.RandomRotateTextDet.sample_angle", "torchvision.RandomRotateTextDet.rotate_img", "results.get", "mmdet.core.BitmapMasks", "torchvision.RandomRotateTextDet.rotate_img", "mask_list.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.sample_angle", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate_img"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "if", "np", ".", "random", ".", "random_sample", "(", ")", "<", "self", ".", "rotate_ratio", ":", "\n", "# rotate imgs", "\n", "            ", "results", "[", "'rotated_angle'", "]", "=", "self", ".", "sample_angle", "(", "self", ".", "max_angle", ")", "\n", "img", "=", "self", ".", "rotate_img", "(", "results", "[", "'img'", "]", ",", "results", "[", "'rotated_angle'", "]", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "img_shape", "=", "img", ".", "shape", "\n", "results", "[", "'img_shape'", "]", "=", "img_shape", "\n", "\n", "# rotate masks", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "                ", "masks", "=", "results", "[", "key", "]", ".", "masks", "\n", "mask_list", "=", "[", "]", "\n", "for", "m", "in", "masks", ":", "\n", "                    ", "rotated_m", "=", "self", ".", "rotate_img", "(", "m", ",", "results", "[", "'rotated_angle'", "]", ")", "\n", "mask_list", ".", "append", "(", "rotated_m", ")", "\n", "", "results", "[", "key", "]", "=", "BitmapMasks", "(", "mask_list", ",", "*", "(", "img_shape", "[", ":", "2", "]", ")", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotateTextDet.__repr__": [[221, 224], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ColorJitter.__init__": [[231, 233], ["torchvision.ColorJitter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transforms", ".", "ColorJitter", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ColorJitter.__call__": [[234, 243], ["PIL.Image.fromarray", "torchvision.ColorJitter.transform", "numpy.asarray"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "# img is bgr", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "img", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "img", "=", "self", ".", "transform", "(", "img", ")", "\n", "img", "=", "np", ".", "asarray", "(", "img", ")", "\n", "img", "=", "img", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ColorJitter.__repr__": [[244, 247], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.__init__": [[257, 298], ["mmdet.datasets.pipelines.transforms.Resize.__init__", "isinstance", "isinstance", "mmocr.utils.check_argument.equal_len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.equal_len"], ["def", "__init__", "(", "self", ",", "\n", "img_scale", "=", "None", ",", "\n", "multiscale_mode", "=", "'range'", ",", "\n", "ratio_range", "=", "None", ",", "\n", "keep_ratio", "=", "False", ",", "\n", "resize_type", "=", "'around_min_img_scale'", ",", "\n", "aspect_ratio_range", "=", "None", ",", "\n", "long_size_bound", "=", "None", ",", "\n", "short_size_bound", "=", "None", ",", "\n", "scale_range", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "img_scale", "=", "img_scale", ",", "\n", "multiscale_mode", "=", "multiscale_mode", ",", "\n", "ratio_range", "=", "ratio_range", ",", "\n", "keep_ratio", "=", "keep_ratio", ")", "\n", "assert", "not", "keep_ratio", "\n", "assert", "resize_type", "in", "[", "\n", "'around_min_img_scale'", ",", "'long_short_bound'", ",", "'indep_sample_in_range'", "\n", "]", "\n", "self", ".", "resize_type", "=", "resize_type", "\n", "\n", "if", "resize_type", "==", "'indep_sample_in_range'", ":", "\n", "            ", "assert", "ratio_range", "is", "None", "\n", "assert", "aspect_ratio_range", "is", "None", "\n", "assert", "short_size_bound", "is", "None", "\n", "assert", "long_size_bound", "is", "None", "\n", "assert", "scale_range", "is", "not", "None", "\n", "", "else", ":", "\n", "            ", "assert", "scale_range", "is", "None", "\n", "assert", "isinstance", "(", "ratio_range", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "aspect_ratio_range", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "equal_len", "(", "ratio_range", ",", "aspect_ratio_range", ")", "\n", "\n", "if", "resize_type", "in", "[", "'long_short_bound'", "]", ":", "\n", "                ", "assert", "short_size_bound", "is", "not", "None", "\n", "assert", "long_size_bound", "is", "not", "None", "\n", "\n", "", "", "self", ".", "aspect_ratio_range", "=", "aspect_ratio_range", "\n", "self", ".", "long_size_bound", "=", "long_size_bound", "\n", "self", ".", "short_size_bound", "=", "short_size_bound", "\n", "self", ".", "scale_range", "=", "scale_range", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range": [[299, 306], ["len", "min", "max", "numpy.random.random_sample"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "sample_from_range", "(", "range", ")", ":", "\n", "        ", "assert", "len", "(", "range", ")", "==", "2", "\n", "min_value", ",", "max_value", "=", "min", "(", "range", ")", ",", "max", "(", "range", ")", "\n", "value", "=", "np", ".", "random", ".", "random_sample", "(", ")", "*", "(", "max_value", "-", "min_value", ")", "+", "min_value", "\n", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter._random_scale": [[307, 336], ["torchvision.ScaleAspectJitter.sample_from_range", "torchvision.ScaleAspectJitter.sample_from_range", "torchvision.ScaleAspectJitter.sample_from_range", "torchvision.ScaleAspectJitter.sample_from_range", "math.sqrt", "math.sqrt", "int", "int", "int", "int", "max", "min", "torchvision.ScaleAspectJitter.sample_from_range", "max", "min", "min", "min"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range"], ["", "def", "_random_scale", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "if", "self", ".", "resize_type", "==", "'indep_sample_in_range'", ":", "\n", "            ", "w", "=", "self", ".", "sample_from_range", "(", "self", ".", "scale_range", ")", "\n", "h", "=", "self", ".", "sample_from_range", "(", "self", ".", "scale_range", ")", "\n", "results", "[", "'scale'", "]", "=", "(", "int", "(", "w", ")", ",", "int", "(", "h", ")", ")", "# (w,h)", "\n", "results", "[", "'scale_idx'", "]", "=", "None", "\n", "return", "\n", "", "h", ",", "w", "=", "results", "[", "'img'", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "if", "self", ".", "resize_type", "==", "'long_short_bound'", ":", "\n", "            ", "scale1", "=", "1", "\n", "if", "max", "(", "h", ",", "w", ")", ">", "self", ".", "long_size_bound", ":", "\n", "                ", "scale1", "=", "self", ".", "long_size_bound", "/", "max", "(", "h", ",", "w", ")", "\n", "", "scale2", "=", "self", ".", "sample_from_range", "(", "self", ".", "ratio_range", ")", "\n", "scale", "=", "scale1", "*", "scale2", "\n", "if", "min", "(", "h", ",", "w", ")", "*", "scale", "<=", "self", ".", "short_size_bound", ":", "\n", "                ", "scale", "=", "(", "self", ".", "short_size_bound", "+", "10", ")", "*", "1.0", "/", "min", "(", "h", ",", "w", ")", "\n", "", "", "elif", "self", ".", "resize_type", "==", "'around_min_img_scale'", ":", "\n", "            ", "short_size", "=", "min", "(", "self", ".", "img_scale", "[", "0", "]", ")", "\n", "ratio", "=", "self", ".", "sample_from_range", "(", "self", ".", "ratio_range", ")", "\n", "scale", "=", "(", "ratio", "*", "short_size", ")", "/", "min", "(", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "aspect", "=", "self", ".", "sample_from_range", "(", "self", ".", "aspect_ratio_range", ")", "\n", "h_scale", "=", "scale", "*", "math", ".", "sqrt", "(", "aspect", ")", "\n", "w_scale", "=", "scale", "/", "math", ".", "sqrt", "(", "aspect", ")", "\n", "results", "[", "'scale'", "]", "=", "(", "int", "(", "w", "*", "w_scale", ")", ",", "int", "(", "h", "*", "h_scale", ")", ")", "# (w,h)", "\n", "results", "[", "'scale_idx'", "]", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.AffineJitter.__init__": [[343, 357], ["torchvision.RandomAffine"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "degrees", "=", "4", ",", "\n", "translate", "=", "(", "0.02", ",", "0.04", ")", ",", "\n", "scale", "=", "(", "0.9", ",", "1.1", ")", ",", "\n", "shear", "=", "None", ",", "\n", "resample", "=", "False", ",", "\n", "fillcolor", "=", "0", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transforms", ".", "RandomAffine", "(", "\n", "degrees", "=", "degrees", ",", "\n", "translate", "=", "translate", ",", "\n", "scale", "=", "scale", ",", "\n", "shear", "=", "shear", ",", "\n", "resample", "=", "resample", ",", "\n", "fillcolor", "=", "fillcolor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.AffineJitter.__call__": [[358, 367], ["PIL.Image.fromarray", "torchvision.AffineJitter.transform", "numpy.asarray"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "# img is bgr", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "img", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "img", "=", "self", ".", "transform", "(", "img", ")", "\n", "img", "=", "np", ".", "asarray", "(", "img", ")", "\n", "img", "=", "img", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.AffineJitter.__repr__": [[368, 371], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.__init__": [[378, 386], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "instance_key", "=", "'gt_masks'", ",", "\n", "crop_ratio", "=", "5.0", "/", "8.0", ",", "\n", "min_side_ratio", "=", "0.4", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "instance_key", "=", "instance_key", "\n", "self", ".", "crop_ratio", "=", "crop_ratio", "\n", "self", ".", "min_side_ratio", "=", "min_side_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.sample_valid_start_end": [[387, 414], ["isinstance", "valid_array.copy", "min", "numpy.random.randint", "numpy.random.randint", "valid_array.copy", "max", "numpy.random.randint", "numpy.random.randint", "len", "numpy.hstack", "numpy.hstack", "numpy.where", "numpy.where", "len", "numpy.hstack", "numpy.hstack", "numpy.where", "numpy.where", "len", "len"], "methods", ["None"], ["", "def", "sample_valid_start_end", "(", "self", ",", "valid_array", ",", "min_len", ",", "max_start", ",", "min_end", ")", ":", "\n", "\n", "        ", "assert", "isinstance", "(", "min_len", ",", "int", ")", "\n", "assert", "len", "(", "valid_array", ")", ">", "min_len", "\n", "\n", "start_array", "=", "valid_array", ".", "copy", "(", ")", "\n", "max_start", "=", "min", "(", "len", "(", "start_array", ")", "-", "min_len", ",", "max_start", ")", "\n", "start_array", "[", "max_start", ":", "]", "=", "0", "\n", "start_array", "[", "0", "]", "=", "1", "\n", "diff_array", "=", "np", ".", "hstack", "(", "[", "0", ",", "start_array", "]", ")", "-", "np", ".", "hstack", "(", "[", "start_array", ",", "0", "]", ")", "\n", "region_starts", "=", "np", ".", "where", "(", "diff_array", "<", "0", ")", "[", "0", "]", "\n", "region_ends", "=", "np", ".", "where", "(", "diff_array", ">", "0", ")", "[", "0", "]", "\n", "region_ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "region_starts", ")", ")", "\n", "start", "=", "np", ".", "random", ".", "randint", "(", "region_starts", "[", "region_ind", "]", ",", "\n", "region_ends", "[", "region_ind", "]", ")", "\n", "\n", "end_array", "=", "valid_array", ".", "copy", "(", ")", "\n", "min_end", "=", "max", "(", "start", "+", "min_len", ",", "min_end", ")", "\n", "end_array", "[", ":", "min_end", "]", "=", "0", "\n", "end_array", "[", "-", "1", "]", "=", "1", "\n", "diff_array", "=", "np", ".", "hstack", "(", "[", "0", ",", "end_array", "]", ")", "-", "np", ".", "hstack", "(", "[", "end_array", ",", "0", "]", ")", "\n", "region_starts", "=", "np", ".", "where", "(", "diff_array", "<", "0", ")", "[", "0", "]", "\n", "region_ends", "=", "np", ".", "where", "(", "diff_array", ">", "0", ")", "[", "0", "]", "\n", "region_ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "region_starts", ")", ")", "\n", "end", "=", "np", ".", "random", ".", "randint", "(", "region_starts", "[", "region_ind", "]", ",", "\n", "region_ends", "[", "region_ind", "]", ")", "\n", "return", "start", ",", "end", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.sample_crop_box": [[415, 461], ["isinstance", "numpy.ones", "numpy.ones", "selected_mask[].reshape().astype", "max", "min", "max", "min", "results.get", "int", "int", "torchvision.RandomCropPolyInstances.sample_valid_start_end", "torchvision.RandomCropPolyInstances.sample_valid_start_end", "numpy.array", "numpy.random.randint", "selected_mask[].reshape", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "len", "mask[].reshape().astype", "numpy.clip", "numpy.clip", "len", "len", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "mask[].reshape"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.sample_valid_start_end", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.sample_valid_start_end"], ["", "def", "sample_crop_box", "(", "self", ",", "img_size", ",", "results", ")", ":", "\n", "        ", "\"\"\"Generate crop box and make sure not to crop the polygon instances.\n\n        Args:\n            img_size (tuple(int)): The image size (h, w).\n            results (dict): The results dict.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "h", ",", "w", "=", "img_size", "[", ":", "2", "]", "\n", "\n", "key_masks", "=", "results", "[", "self", ".", "instance_key", "]", ".", "masks", "\n", "x_valid_array", "=", "np", ".", "ones", "(", "w", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "y_valid_array", "=", "np", ".", "ones", "(", "h", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "selected_mask", "=", "key_masks", "[", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "key_masks", ")", ")", "]", "\n", "selected_mask", "=", "selected_mask", "[", "0", "]", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "max_x_start", "=", "max", "(", "np", ".", "min", "(", "selected_mask", "[", ":", ",", "0", "]", ")", "-", "2", ",", "0", ")", "\n", "min_x_end", "=", "min", "(", "np", ".", "max", "(", "selected_mask", "[", ":", ",", "0", "]", ")", "+", "3", ",", "w", "-", "1", ")", "\n", "max_y_start", "=", "max", "(", "np", ".", "min", "(", "selected_mask", "[", ":", ",", "1", "]", ")", "-", "2", ",", "0", ")", "\n", "min_y_end", "=", "min", "(", "np", ".", "max", "(", "selected_mask", "[", ":", ",", "1", "]", ")", "+", "3", ",", "h", "-", "1", ")", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "if", "len", "(", "results", "[", "key", "]", ".", "masks", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "masks", "=", "results", "[", "key", "]", ".", "masks", "\n", "for", "mask", "in", "masks", ":", "\n", "                ", "assert", "len", "(", "mask", ")", "==", "1", "\n", "mask", "=", "mask", "[", "0", "]", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "clip_x", "=", "np", ".", "clip", "(", "mask", "[", ":", ",", "0", "]", ",", "0", ",", "w", "-", "1", ")", "\n", "clip_y", "=", "np", ".", "clip", "(", "mask", "[", ":", ",", "1", "]", ",", "0", ",", "h", "-", "1", ")", "\n", "min_x", ",", "max_x", "=", "np", ".", "min", "(", "clip_x", ")", ",", "np", ".", "max", "(", "clip_x", ")", "\n", "min_y", ",", "max_y", "=", "np", ".", "min", "(", "clip_y", ")", ",", "np", ".", "max", "(", "clip_y", ")", "\n", "\n", "x_valid_array", "[", "min_x", "-", "2", ":", "max_x", "+", "3", "]", "=", "0", "\n", "y_valid_array", "[", "min_y", "-", "2", ":", "max_y", "+", "3", "]", "=", "0", "\n", "\n", "", "", "min_w", "=", "int", "(", "w", "*", "self", ".", "min_side_ratio", ")", "\n", "min_h", "=", "int", "(", "h", "*", "self", ".", "min_side_ratio", ")", "\n", "\n", "x1", ",", "x2", "=", "self", ".", "sample_valid_start_end", "(", "x_valid_array", ",", "min_w", ",", "max_x_start", ",", "\n", "min_x_end", ")", "\n", "y1", ",", "y2", "=", "self", ".", "sample_valid_start_end", "(", "y_valid_array", ",", "min_h", ",", "max_y_start", ",", "\n", "min_y_end", ")", "\n", "\n", "return", "np", ".", "array", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.crop_img": [[462, 468], ["None"], "methods", ["None"], ["", "def", "crop_img", "(", "self", ",", "img", ",", "bbox", ")", ":", "\n", "        ", "assert", "img", ".", "ndim", "==", "3", "\n", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "assert", "0", "<=", "bbox", "[", "1", "]", "<", "bbox", "[", "3", "]", "<=", "h", "\n", "assert", "0", "<=", "bbox", "[", "0", "]", "<", "bbox", "[", "2", "]", "<=", "w", "\n", "return", "img", "[", "bbox", "[", "1", "]", ":", "bbox", "[", "3", "]", ",", "bbox", "[", "0", "]", ":", "bbox", "[", "2", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.__call__": [[469, 510], ["len", "numpy.random.random_sample", "torchvision.RandomCropPolyInstances.sample_crop_box", "torchvision.RandomCropPolyInstances.crop_img", "max", "max", "results.get", "numpy.array", "results[].crop", "enumerate", "mmdet.core.PolygonMasks", "len", "mask[].reshape", "len", "numpy.clip", "numpy.clip", "valid_masks_list.append", "valid_labels.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.sample_crop_box", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "if", "len", "(", "results", "[", "self", ".", "instance_key", "]", ".", "masks", ")", "<", "1", ":", "\n", "            ", "return", "results", "\n", "", "if", "np", ".", "random", ".", "random_sample", "(", ")", "<", "self", ".", "crop_ratio", ":", "\n", "            ", "crop_box", "=", "self", ".", "sample_crop_box", "(", "results", "[", "'img'", "]", ".", "shape", ",", "results", ")", "\n", "results", "[", "'crop_region'", "]", "=", "crop_box", "\n", "img", "=", "self", ".", "crop_img", "(", "results", "[", "'img'", "]", ",", "crop_box", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "\n", "# crop and filter masks", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "crop_box", "\n", "w", "=", "max", "(", "x2", "-", "x1", ",", "1", ")", "\n", "h", "=", "max", "(", "y2", "-", "y1", ",", "1", ")", "\n", "labels", "=", "results", "[", "'gt_labels'", "]", "\n", "valid_labels", "=", "[", "]", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "                ", "if", "len", "(", "results", "[", "key", "]", ".", "masks", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "crop", "(", "crop_box", ")", "\n", "# filter out polygons beyond crop box.", "\n", "masks", "=", "results", "[", "key", "]", ".", "masks", "\n", "valid_masks_list", "=", "[", "]", "\n", "\n", "for", "ind", ",", "mask", "in", "enumerate", "(", "masks", ")", ":", "\n", "                    ", "assert", "len", "(", "mask", ")", "==", "1", "\n", "polygon", "=", "mask", "[", "0", "]", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", "\n", "if", "(", "polygon", "[", ":", ",", "0", "]", ">", "\n", "-", "4", ")", ".", "all", "(", ")", "and", "(", "polygon", "[", ":", ",", "0", "]", "<", "w", "+", "4", ")", ".", "all", "(", ")", "and", "(", "\n", "polygon", "[", ":", ",", "1", "]", ">", "-", "4", ")", ".", "all", "(", ")", "and", "(", "polygon", "[", ":", ",", "1", "]", "<", "\n", "h", "+", "4", ")", ".", "all", "(", ")", ":", "\n", "                        ", "mask", "[", "0", "]", "[", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "mask", "[", "0", "]", "[", ":", ":", "2", "]", ",", "0", ",", "w", ")", "\n", "mask", "[", "0", "]", "[", "1", ":", ":", "2", "]", "=", "np", ".", "clip", "(", "mask", "[", "0", "]", "[", "1", ":", ":", "2", "]", ",", "0", ",", "h", ")", "\n", "if", "key", "==", "self", ".", "instance_key", ":", "\n", "                            ", "valid_labels", ".", "append", "(", "labels", "[", "ind", "]", ")", "\n", "", "valid_masks_list", ".", "append", "(", "mask", ")", "\n", "\n", "", "", "results", "[", "key", "]", "=", "PolygonMasks", "(", "valid_masks_list", ",", "h", ",", "w", ")", "\n", "", "results", "[", "'gt_labels'", "]", "=", "np", ".", "array", "(", "valid_labels", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.__repr__": [[511, 514], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.__init__": [[519, 538], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "rotate_ratio", "=", "0.5", ",", "\n", "max_angle", "=", "10", ",", "\n", "pad_with_fixed_color", "=", "False", ",", "\n", "pad_value", "=", "(", "0", ",", "0", ",", "0", ")", ")", ":", "\n", "        ", "\"\"\"Randomly rotate images and polygon masks.\n\n        Args:\n            rotate_ratio (float): The ratio of samples to operate rotation.\n            max_angle (int): The maximum rotation angle.\n            pad_with_fixed_color (bool): The flag for whether to pad rotated\n               image with fixed value. If set to False, the rotated image will\n               be padded onto cropped image.\n            pad_value (tuple(int)): The color value for padding rotated image.\n        \"\"\"", "\n", "self", ".", "rotate_ratio", "=", "rotate_ratio", "\n", "self", ".", "max_angle", "=", "max_angle", "\n", "self", ".", "pad_with_fixed_color", "=", "pad_with_fixed_color", "\n", "self", ".", "pad_value", "=", "pad_value", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate": [[539, 558], ["math.cos", "math.sin"], "methods", ["None"], ["", "def", "rotate", "(", "self", ",", "center", ",", "points", ",", "theta", ",", "center_shift", "=", "(", "0", ",", "0", ")", ")", ":", "\n", "# rotate points.", "\n", "        ", "(", "center_x", ",", "center_y", ")", "=", "center", "\n", "center_y", "=", "-", "center_y", "\n", "x", ",", "y", "=", "points", "[", ":", ":", "2", "]", ",", "points", "[", "1", ":", ":", "2", "]", "\n", "y", "=", "-", "y", "\n", "\n", "theta", "=", "theta", "/", "180", "*", "math", ".", "pi", "\n", "cos", "=", "math", ".", "cos", "(", "theta", ")", "\n", "sin", "=", "math", ".", "sin", "(", "theta", ")", "\n", "\n", "x", "=", "(", "x", "-", "center_x", ")", "\n", "y", "=", "(", "y", "-", "center_y", ")", "\n", "\n", "_x", "=", "center_x", "+", "x", "*", "cos", "-", "y", "*", "sin", "+", "center_shift", "[", "0", "]", "\n", "_y", "=", "-", "(", "center_y", "+", "x", "*", "sin", "+", "y", "*", "cos", ")", "+", "center_shift", "[", "1", "]", "\n", "\n", "points", "[", ":", ":", "2", "]", ",", "points", "[", "1", ":", ":", "2", "]", "=", "_x", ",", "_y", "\n", "return", "points", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.cal_canvas_size": [[559, 571], ["isinstance", "math.cos", "math.sin", "int", "int", "math.fabs", "math.fabs", "math.fabs", "math.fabs"], "methods", ["None"], ["", "def", "cal_canvas_size", "(", "self", ",", "ori_size", ",", "degree", ")", ":", "\n", "        ", "assert", "isinstance", "(", "ori_size", ",", "tuple", ")", "\n", "angle", "=", "degree", "*", "math", ".", "pi", "/", "180.0", "\n", "h", ",", "w", "=", "ori_size", "[", ":", "2", "]", "\n", "\n", "cos", "=", "math", ".", "cos", "(", "angle", ")", "\n", "sin", "=", "math", ".", "sin", "(", "angle", ")", "\n", "canvas_h", "=", "int", "(", "w", "*", "math", ".", "fabs", "(", "sin", ")", "+", "h", "*", "math", ".", "fabs", "(", "cos", ")", ")", "\n", "canvas_w", "=", "int", "(", "w", "*", "math", ".", "fabs", "(", "cos", ")", "+", "h", "*", "math", ".", "fabs", "(", "sin", ")", ")", "\n", "\n", "canvas_size", "=", "(", "canvas_h", ",", "canvas_w", ")", "\n", "return", "canvas_size", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.sample_angle": [[572, 575], ["numpy.random.random_sample"], "methods", ["None"], ["", "def", "sample_angle", "(", "self", ",", "max_angle", ")", ":", "\n", "        ", "angle", "=", "np", ".", "random", ".", "random_sample", "(", ")", "*", "2", "*", "max_angle", "-", "max_angle", "\n", "return", "angle", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate_img": [[576, 605], ["cv2.getRotationMatrix2D", "int", "int", "cv2.warpAffine", "numpy.zeros_like", "mmcv.imresize", "cv2.warpAffine", "cv2.warpAffine", "numpy.random.randint", "numpy.random.randint"], "methods", ["None"], ["", "def", "rotate_img", "(", "self", ",", "img", ",", "angle", ",", "canvas_size", ")", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "rotation_matrix", "=", "cv2", ".", "getRotationMatrix2D", "(", "(", "w", "/", "2", ",", "h", "/", "2", ")", ",", "angle", ",", "1", ")", "\n", "rotation_matrix", "[", "0", ",", "2", "]", "+=", "int", "(", "(", "canvas_size", "[", "1", "]", "-", "w", ")", "/", "2", ")", "\n", "rotation_matrix", "[", "1", ",", "2", "]", "+=", "int", "(", "(", "canvas_size", "[", "0", "]", "-", "h", ")", "/", "2", ")", "\n", "\n", "if", "self", ".", "pad_with_fixed_color", ":", "\n", "            ", "target_img", "=", "cv2", ".", "warpAffine", "(", "\n", "img", ",", "\n", "rotation_matrix", ",", "(", "canvas_size", "[", "1", "]", ",", "canvas_size", "[", "0", "]", ")", ",", "\n", "flags", "=", "cv2", ".", "INTER_NEAREST", ",", "\n", "borderValue", "=", "self", ".", "pad_value", ")", "\n", "", "else", ":", "\n", "            ", "mask", "=", "np", ".", "zeros_like", "(", "img", ")", "\n", "(", "h_ind", ",", "w_ind", ")", "=", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "h", "*", "7", "//", "8", ")", ",", "\n", "np", ".", "random", ".", "randint", "(", "0", ",", "w", "*", "7", "//", "8", ")", ")", "\n", "img_cut", "=", "img", "[", "h_ind", ":", "(", "h_ind", "+", "h", "//", "9", ")", ",", "w_ind", ":", "(", "w_ind", "+", "w", "//", "9", ")", "]", "\n", "img_cut", "=", "mmcv", ".", "imresize", "(", "img_cut", ",", "(", "canvas_size", "[", "1", "]", ",", "canvas_size", "[", "0", "]", ")", ")", "\n", "mask", "=", "cv2", ".", "warpAffine", "(", "\n", "mask", ",", "\n", "rotation_matrix", ",", "(", "canvas_size", "[", "1", "]", ",", "canvas_size", "[", "0", "]", ")", ",", "\n", "borderValue", "=", "[", "1", ",", "1", ",", "1", "]", ")", "\n", "target_img", "=", "cv2", ".", "warpAffine", "(", "\n", "img", ",", "\n", "rotation_matrix", ",", "(", "canvas_size", "[", "1", "]", ",", "canvas_size", "[", "0", "]", ")", ",", "\n", "borderValue", "=", "[", "0", ",", "0", ",", "0", "]", ")", "\n", "target_img", "=", "target_img", "+", "img_cut", "*", "mask", "\n", "\n", "", "return", "target_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.__call__": [[606, 636], ["numpy.random.random_sample", "torchvision.RandomRotatePolyInstances.sample_angle", "torchvision.RandomRotatePolyInstances.cal_canvas_size", "torchvision.RandomRotatePolyInstances.rotate_img", "results.get", "int", "int", "mmdet.core.PolygonMasks", "len", "torchvision.RandomRotatePolyInstances.rotate", "rotated_masks.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.sample_angle", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.cal_canvas_size", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "if", "np", ".", "random", ".", "random_sample", "(", ")", "<", "self", ".", "rotate_ratio", ":", "\n", "            ", "img", "=", "results", "[", "'img'", "]", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "angle", "=", "self", ".", "sample_angle", "(", "self", ".", "max_angle", ")", "\n", "canvas_size", "=", "self", ".", "cal_canvas_size", "(", "(", "h", ",", "w", ")", ",", "angle", ")", "\n", "center_shift", "=", "(", "int", "(", "\n", "(", "canvas_size", "[", "1", "]", "-", "w", ")", "/", "2", ")", ",", "int", "(", "(", "canvas_size", "[", "0", "]", "-", "h", ")", "/", "2", ")", ")", "\n", "\n", "# rotate image", "\n", "results", "[", "'rotated_poly_angle'", "]", "=", "angle", "\n", "img", "=", "self", ".", "rotate_img", "(", "img", ",", "angle", ",", "canvas_size", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "img_shape", "=", "img", ".", "shape", "\n", "results", "[", "'img_shape'", "]", "=", "img_shape", "\n", "\n", "# rotate polygons", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "                ", "if", "len", "(", "results", "[", "key", "]", ".", "masks", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "masks", "=", "results", "[", "key", "]", ".", "masks", "\n", "rotated_masks", "=", "[", "]", "\n", "for", "mask", "in", "masks", ":", "\n", "                    ", "rotated_mask", "=", "self", ".", "rotate", "(", "(", "w", "/", "2", ",", "h", "/", "2", ")", ",", "mask", "[", "0", "]", ",", "angle", ",", "\n", "center_shift", ")", "\n", "rotated_masks", ".", "append", "(", "[", "rotated_mask", "]", ")", "\n", "\n", "", "results", "[", "key", "]", "=", "PolygonMasks", "(", "rotated_masks", ",", "*", "(", "img_shape", "[", ":", "2", "]", ")", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.__repr__": [[637, 640], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.__init__": [[645, 668], ["isinstance", "isinstance", "isinstance", "isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "target_size", ",", "\n", "pad_ratio", "=", "0.6", ",", "\n", "pad_with_fixed_color", "=", "False", ",", "\n", "pad_value", "=", "(", "0", ",", "0", ",", "0", ")", ")", ":", "\n", "        ", "\"\"\"Resize or pad images to be square shape.\n\n        Args:\n            target_size (int): The target size of square shaped image.\n            pad_with_fixed_color (bool): The flag for whether to pad rotated\n               image with fixed value. If set to False, the rescales image will\n               be padded onto cropped image.\n            pad_value (tuple(int)): The color value for padding rotated image.\n        \"\"\"", "\n", "assert", "isinstance", "(", "target_size", ",", "int", ")", "\n", "assert", "isinstance", "(", "pad_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "pad_with_fixed_color", ",", "bool", ")", "\n", "assert", "isinstance", "(", "pad_value", ",", "tuple", ")", "\n", "\n", "self", ".", "target_size", "=", "target_size", "\n", "self", ".", "pad_ratio", "=", "pad_ratio", "\n", "self", ".", "pad_with_fixed_color", "=", "pad_with_fixed_color", "\n", "self", ".", "pad_value", "=", "pad_value", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.resize_img": [[669, 678], ["mmcv.imresize", "int", "int"], "methods", ["None"], ["", "def", "resize_img", "(", "self", ",", "img", ",", "keep_ratio", "=", "True", ")", ":", "\n", "        ", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "if", "keep_ratio", ":", "\n", "            ", "t_h", "=", "self", ".", "target_size", "if", "h", ">=", "w", "else", "int", "(", "h", "*", "self", ".", "target_size", "/", "w", ")", "\n", "t_w", "=", "self", ".", "target_size", "if", "h", "<=", "w", "else", "int", "(", "w", "*", "self", ".", "target_size", "/", "h", ")", "\n", "", "else", ":", "\n", "            ", "t_h", "=", "t_w", "=", "self", ".", "target_size", "\n", "", "img", "=", "mmcv", ".", "imresize", "(", "img", ",", "(", "t_w", ",", "t_h", ")", ")", "\n", "return", "img", ",", "(", "t_h", ",", "t_w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.square_pad": [[679, 700], ["max", "numpy.ones", "mmcv.imresize", "numpy.random.randint", "numpy.random.randint"], "methods", ["None"], ["", "def", "square_pad", "(", "self", ",", "img", ")", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "if", "h", "==", "w", ":", "\n", "            ", "return", "img", ",", "(", "0", ",", "0", ")", "\n", "", "pad_size", "=", "max", "(", "h", ",", "w", ")", "\n", "if", "self", ".", "pad_with_fixed_color", ":", "\n", "            ", "expand_img", "=", "np", ".", "ones", "(", "(", "pad_size", ",", "pad_size", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "expand_img", "[", ":", "]", "=", "self", ".", "pad_value", "\n", "", "else", ":", "\n", "            ", "(", "h_ind", ",", "w_ind", ")", "=", "(", "np", ".", "random", ".", "randint", "(", "0", ",", "h", "*", "7", "//", "8", ")", ",", "\n", "np", ".", "random", ".", "randint", "(", "0", ",", "w", "*", "7", "//", "8", ")", ")", "\n", "img_cut", "=", "img", "[", "h_ind", ":", "(", "h_ind", "+", "h", "//", "9", ")", ",", "w_ind", ":", "(", "w_ind", "+", "w", "//", "9", ")", "]", "\n", "expand_img", "=", "mmcv", ".", "imresize", "(", "img_cut", ",", "(", "pad_size", ",", "pad_size", ")", ")", "\n", "", "if", "h", ">", "w", ":", "\n", "            ", "y0", ",", "x0", "=", "0", ",", "(", "h", "-", "w", ")", "//", "2", "\n", "", "else", ":", "\n", "            ", "y0", ",", "x0", "=", "(", "w", "-", "h", ")", "//", "2", ",", "0", "\n", "", "expand_img", "[", "y0", ":", "y0", "+", "h", ",", "x0", ":", "x0", "+", "w", "]", "=", "img", "\n", "offset", "=", "(", "x0", ",", "y0", ")", "\n", "\n", "return", "expand_img", ",", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.square_pad_mask": [[701, 707], ["points.copy"], "methods", ["None"], ["", "def", "square_pad_mask", "(", "self", ",", "points", ",", "offset", ")", ":", "\n", "        ", "x0", ",", "y0", "=", "offset", "\n", "pad_points", "=", "points", ".", "copy", "(", ")", "\n", "pad_points", "[", ":", ":", "2", "]", "=", "pad_points", "[", ":", ":", "2", "]", "+", "x0", "\n", "pad_points", "[", "1", ":", ":", "2", "]", "=", "pad_points", "[", "1", ":", ":", "2", "]", "+", "y0", "\n", "return", "pad_points", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.__call__": [[708, 734], ["results.get", "numpy.random.random_sample", "torchvision.SquareResizePad.resize_img", "torchvision.SquareResizePad.square_pad", "torchvision.SquareResizePad.resize_img", "results[].resize", "mmdet.core.PolygonMasks", "len", "torchvision.SquareResizePad.square_pad_mask", "processed_masks.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.resize_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.square_pad", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.resize_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.square_pad_mask"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "\n", "\n", "if", "np", ".", "random", ".", "random_sample", "(", ")", "<", "self", ".", "pad_ratio", ":", "\n", "            ", "img", ",", "out_size", "=", "self", ".", "resize_img", "(", "img", ",", "keep_ratio", "=", "True", ")", "\n", "img", ",", "offset", "=", "self", ".", "square_pad", "(", "img", ")", "\n", "", "else", ":", "\n", "            ", "img", ",", "out_size", "=", "self", ".", "resize_img", "(", "img", ",", "keep_ratio", "=", "False", ")", "\n", "offset", "=", "(", "0", ",", "0", ")", "\n", "\n", "", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "if", "len", "(", "results", "[", "key", "]", ".", "masks", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "resize", "(", "out_size", ")", "\n", "masks", "=", "results", "[", "key", "]", ".", "masks", "\n", "processed_masks", "=", "[", "]", "\n", "for", "mask", "in", "masks", ":", "\n", "                ", "square_pad_mask", "=", "self", ".", "square_pad_mask", "(", "mask", "[", "0", "]", ",", "offset", ")", "\n", "processed_masks", ".", "append", "(", "[", "square_pad_mask", "]", ")", "\n", "\n", "", "results", "[", "key", "]", "=", "PolygonMasks", "(", "processed_masks", ",", "*", "(", "img", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.SquareResizePad.__repr__": [[735, 738], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomScaling.__init__": [[743, 755], ["isinstance", "isinstance", "isinstance", "isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "size", "=", "800", ",", "scale", "=", "(", "3.", "/", "4", ",", "5.", "/", "2", ")", ")", ":", "\n", "        ", "\"\"\"Random scale the image while keeping aspect.\n\n        Args:\n            size (int) : Base size before scaling.\n            scale (tuple(float)) : The range of scaling.\n        \"\"\"", "\n", "assert", "isinstance", "(", "size", ",", "int", ")", "\n", "assert", "isinstance", "(", "scale", ",", "float", ")", "or", "isinstance", "(", "scale", ",", "tuple", ")", "\n", "self", ".", "size", "=", "size", "\n", "self", ".", "scale", "=", "scale", "if", "isinstance", "(", "scale", ",", "tuple", ")", "else", "(", "1", "-", "scale", ",", "1", "+", "scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomScaling.__call__": [[756, 775], ["numpy.random.uniform", "numpy.array", "mmcv.imresize", "results.get", "min", "max", "int", "int", "results[].resize", "max", "len"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "image", "=", "results", "[", "'img'", "]", "\n", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "\n", "aspect_ratio", "=", "np", ".", "random", ".", "uniform", "(", "min", "(", "self", ".", "scale", ")", ",", "max", "(", "self", ".", "scale", ")", ")", "\n", "scales", "=", "self", ".", "size", "*", "1.0", "/", "max", "(", "h", ",", "w", ")", "*", "aspect_ratio", "\n", "scales", "=", "np", ".", "array", "(", "[", "scales", ",", "scales", "]", ")", "\n", "out_size", "=", "(", "int", "(", "h", "*", "scales", "[", "1", "]", ")", ",", "int", "(", "w", "*", "scales", "[", "0", "]", ")", ")", "\n", "image", "=", "mmcv", ".", "imresize", "(", "image", ",", "out_size", "[", ":", ":", "-", "1", "]", ")", "\n", "\n", "results", "[", "'img'", "]", "=", "image", "\n", "results", "[", "'img_shape'", "]", "=", "image", ".", "shape", "\n", "\n", "for", "key", "in", "results", ".", "get", "(", "'mask_fields'", ",", "[", "]", ")", ":", "\n", "            ", "if", "len", "(", "results", "[", "key", "]", ".", "masks", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "results", "[", "key", "]", "=", "results", "[", "key", "]", ".", "resize", "(", "out_size", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.__init__": [[780, 802], ["isinstance", "isinstance", "isinstance"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "pad_ratio", "=", "0.1", ",", "\n", "crop_ratio", "=", "0.5", ",", "\n", "iter_num", "=", "1", ",", "\n", "min_area_ratio", "=", "0.2", ")", ":", "\n", "        ", "\"\"\"Random crop and flip a patch of the image.\n\n        Args:\n            crop_ratio (float): The ratio of cropping.\n            iter_num (int): Number of operations.\n            min_area_ratio (float): Minimal area ratio between cropped patch\n                and original image.\n        \"\"\"", "\n", "assert", "isinstance", "(", "crop_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "iter_num", ",", "int", ")", "\n", "assert", "isinstance", "(", "min_area_ratio", ",", "float", ")", "\n", "\n", "self", ".", "pad_ratio", "=", "pad_ratio", "\n", "self", ".", "epsilon", "=", "1e-2", "\n", "self", ".", "crop_ratio", "=", "crop_ratio", "\n", "self", ".", "iter_num", "=", "iter_num", "\n", "self", ".", "min_area_ratio", "=", "min_area_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.__call__": [[803, 807], ["range", "torchvision.RandomCropFlip.random_crop_flip"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.random_crop_flip"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "iter_num", ")", ":", "\n", "            ", "results", "=", "self", ".", "random_crop_flip", "(", "results", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.random_crop_flip": [[808, 931], ["int", "int", "torchvision.RandomCropFlip.generate_crop_target", "numpy.random.randint", "len", "numpy.random.random", "numpy.random.choice", "numpy.clip", "numpy.clip", "numpy.random.choice", "numpy.clip", "numpy.clip", "numpy.stack().T.astype", "shapely.geometry.Polygon", "numpy.ascontiguousarray", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "len", "len", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "shapely.geometry.Polygon", "mmocr.poly_intersection", "shapely.geometry.Polygon", "mmocr.poly_intersection", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "len", "len", "enumerate", "enumerate", "polygon[].reshape", "polygon[].reshape", "polygon[].reshape", "polygon[].reshape", "enumerate", "enumerate", "enumerate", "enumerate", "numpy.stack", "numpy.abs", "numpy.abs", "numpy.abs", "polys_new.append", "polys_keep.append", "numpy.abs", "numpy.abs", "numpy.abs", "ign_polys_new.append", "ign_polys_keep.append", "polygon[].reshape.reshape", "polygon[].reshape.reshape", "polygon[].reshape", "polygon[].reshape", "polygon[].reshape", "polygon[].reshape", "polygon[].reshape.reshape", "polygon[].reshape.reshape", "polygon[].reshape.reshape", "polygon[].reshape.reshape", "float", "float", "float", "float"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.generate_crop_target", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection"], ["", "def", "random_crop_flip", "(", "self", ",", "results", ")", ":", "\n", "        ", "image", "=", "results", "[", "'img'", "]", "\n", "polygons", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "ignore_polygons", "=", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "\n", "all_polygons", "=", "polygons", "+", "ignore_polygons", "\n", "if", "len", "(", "polygons", ")", "==", "0", ":", "\n", "            ", "return", "results", "\n", "\n", "", "if", "np", ".", "random", ".", "random", "(", ")", ">=", "self", ".", "crop_ratio", ":", "\n", "            ", "return", "results", "\n", "\n", "", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "area", "=", "h", "*", "w", "\n", "pad_h", "=", "int", "(", "h", "*", "self", ".", "pad_ratio", ")", "\n", "pad_w", "=", "int", "(", "w", "*", "self", ".", "pad_ratio", ")", "\n", "h_axis", ",", "w_axis", "=", "self", ".", "generate_crop_target", "(", "image", ",", "all_polygons", ",", "pad_h", ",", "\n", "pad_w", ")", "\n", "if", "len", "(", "h_axis", ")", "==", "0", "or", "len", "(", "w_axis", ")", "==", "0", ":", "\n", "            ", "return", "results", "\n", "\n", "", "attempt", "=", "0", "\n", "while", "attempt", "<", "10", ":", "\n", "            ", "attempt", "+=", "1", "\n", "polys_keep", "=", "[", "]", "\n", "polys_new", "=", "[", "]", "\n", "ign_polys_keep", "=", "[", "]", "\n", "ign_polys_new", "=", "[", "]", "\n", "xx", "=", "np", ".", "random", ".", "choice", "(", "w_axis", ",", "size", "=", "2", ")", "\n", "xmin", "=", "np", ".", "min", "(", "xx", ")", "-", "pad_w", "\n", "xmax", "=", "np", ".", "max", "(", "xx", ")", "-", "pad_w", "\n", "xmin", "=", "np", ".", "clip", "(", "xmin", ",", "0", ",", "w", "-", "1", ")", "\n", "xmax", "=", "np", ".", "clip", "(", "xmax", ",", "0", ",", "w", "-", "1", ")", "\n", "yy", "=", "np", ".", "random", ".", "choice", "(", "h_axis", ",", "size", "=", "2", ")", "\n", "ymin", "=", "np", ".", "min", "(", "yy", ")", "-", "pad_h", "\n", "ymax", "=", "np", ".", "max", "(", "yy", ")", "-", "pad_h", "\n", "ymin", "=", "np", ".", "clip", "(", "ymin", ",", "0", ",", "h", "-", "1", ")", "\n", "ymax", "=", "np", ".", "clip", "(", "ymax", ",", "0", ",", "h", "-", "1", ")", "\n", "if", "(", "xmax", "-", "xmin", ")", "*", "(", "ymax", "-", "ymin", ")", "<", "area", "*", "self", ".", "min_area_ratio", ":", "\n", "# area too small", "\n", "                ", "continue", "\n", "\n", "", "pts", "=", "np", ".", "stack", "(", "[", "[", "xmin", ",", "xmax", ",", "xmax", ",", "xmin", "]", ",", "\n", "[", "ymin", ",", "ymin", ",", "ymax", ",", "ymax", "]", "]", ")", ".", "T", ".", "astype", "(", "np", ".", "int32", ")", "\n", "pp", "=", "plg", "(", "pts", ")", "\n", "fail_flag", "=", "False", "\n", "for", "polygon", "in", "polygons", ":", "\n", "                ", "ppi", "=", "plg", "(", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "ppiou", "=", "eval_utils", ".", "poly_intersection", "(", "ppi", ",", "pp", ")", "\n", "if", "np", ".", "abs", "(", "ppiou", "-", "float", "(", "ppi", ".", "area", ")", ")", ">", "self", ".", "epsilon", "and", "np", ".", "abs", "(", "ppiou", ")", ">", "self", ".", "epsilon", ":", "\n", "                    ", "fail_flag", "=", "True", "\n", "break", "\n", "", "elif", "np", ".", "abs", "(", "ppiou", "-", "float", "(", "ppi", ".", "area", ")", ")", "<", "self", ".", "epsilon", ":", "\n", "                    ", "polys_new", ".", "append", "(", "polygon", ")", "\n", "", "else", ":", "\n", "                    ", "polys_keep", ".", "append", "(", "polygon", ")", "\n", "\n", "", "", "for", "polygon", "in", "ignore_polygons", ":", "\n", "                ", "ppi", "=", "plg", "(", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "ppiou", "=", "eval_utils", ".", "poly_intersection", "(", "ppi", ",", "pp", ")", "\n", "if", "np", ".", "abs", "(", "ppiou", "-", "float", "(", "ppi", ".", "area", ")", ")", ">", "self", ".", "epsilon", "and", "np", ".", "abs", "(", "ppiou", ")", ">", "self", ".", "epsilon", ":", "\n", "                    ", "fail_flag", "=", "True", "\n", "break", "\n", "", "elif", "np", ".", "abs", "(", "ppiou", "-", "float", "(", "ppi", ".", "area", ")", ")", "<", "self", ".", "epsilon", ":", "\n", "                    ", "ign_polys_new", ".", "append", "(", "polygon", ")", "\n", "", "else", ":", "\n", "                    ", "ign_polys_keep", ".", "append", "(", "polygon", ")", "\n", "\n", "", "", "if", "fail_flag", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n", "", "", "cropped", "=", "image", "[", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", ",", ":", "]", "\n", "select_type", "=", "np", ".", "random", ".", "randint", "(", "3", ")", "\n", "if", "select_type", "==", "0", ":", "\n", "            ", "img", "=", "np", ".", "ascontiguousarray", "(", "cropped", "[", ":", ",", ":", ":", "-", "1", "]", ")", "\n", "", "elif", "select_type", "==", "1", ":", "\n", "            ", "img", "=", "np", ".", "ascontiguousarray", "(", "cropped", "[", ":", ":", "-", "1", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "np", ".", "ascontiguousarray", "(", "cropped", "[", ":", ":", "-", "1", ",", ":", ":", "-", "1", "]", ")", "\n", "", "image", "[", "ymin", ":", "ymax", ",", "xmin", ":", "xmax", ",", ":", "]", "=", "img", "\n", "results", "[", "'img'", "]", "=", "image", "\n", "\n", "if", "len", "(", "polys_new", ")", "+", "len", "(", "ign_polys_new", ")", "!=", "0", ":", "\n", "            ", "height", ",", "width", ",", "_", "=", "cropped", ".", "shape", "\n", "if", "select_type", "==", "0", ":", "\n", "                ", "for", "idx", ",", "polygon", "in", "enumerate", "(", "polys_new", ")", ":", "\n", "                    ", "poly", "=", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "[", ":", ",", "0", "]", "=", "width", "-", "poly", "[", ":", ",", "0", "]", "+", "2", "*", "xmin", "\n", "polys_new", "[", "idx", "]", "=", "[", "poly", ".", "reshape", "(", "-", "1", ",", ")", "]", "\n", "", "for", "idx", ",", "polygon", "in", "enumerate", "(", "ign_polys_new", ")", ":", "\n", "                    ", "poly", "=", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "[", ":", ",", "0", "]", "=", "width", "-", "poly", "[", ":", ",", "0", "]", "+", "2", "*", "xmin", "\n", "ign_polys_new", "[", "idx", "]", "=", "[", "poly", ".", "reshape", "(", "-", "1", ",", ")", "]", "\n", "", "", "elif", "select_type", "==", "1", ":", "\n", "                ", "for", "idx", ",", "polygon", "in", "enumerate", "(", "polys_new", ")", ":", "\n", "                    ", "poly", "=", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "[", ":", ",", "1", "]", "=", "height", "-", "poly", "[", ":", ",", "1", "]", "+", "2", "*", "ymin", "\n", "polys_new", "[", "idx", "]", "=", "[", "poly", ".", "reshape", "(", "-", "1", ",", ")", "]", "\n", "", "for", "idx", ",", "polygon", "in", "enumerate", "(", "ign_polys_new", ")", ":", "\n", "                    ", "poly", "=", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "[", ":", ",", "1", "]", "=", "height", "-", "poly", "[", ":", ",", "1", "]", "+", "2", "*", "ymin", "\n", "ign_polys_new", "[", "idx", "]", "=", "[", "poly", ".", "reshape", "(", "-", "1", ",", ")", "]", "\n", "", "", "else", ":", "\n", "                ", "for", "idx", ",", "polygon", "in", "enumerate", "(", "polys_new", ")", ":", "\n", "                    ", "poly", "=", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "[", ":", ",", "0", "]", "=", "width", "-", "poly", "[", ":", ",", "0", "]", "+", "2", "*", "xmin", "\n", "poly", "[", ":", ",", "1", "]", "=", "height", "-", "poly", "[", ":", ",", "1", "]", "+", "2", "*", "ymin", "\n", "polys_new", "[", "idx", "]", "=", "[", "poly", ".", "reshape", "(", "-", "1", ",", ")", "]", "\n", "", "for", "idx", ",", "polygon", "in", "enumerate", "(", "ign_polys_new", ")", ":", "\n", "                    ", "poly", "=", "polygon", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "[", ":", ",", "0", "]", "=", "width", "-", "poly", "[", ":", ",", "0", "]", "+", "2", "*", "xmin", "\n", "poly", "[", ":", ",", "1", "]", "=", "height", "-", "poly", "[", ":", ",", "1", "]", "+", "2", "*", "ymin", "\n", "ign_polys_new", "[", "idx", "]", "=", "[", "poly", ".", "reshape", "(", "-", "1", ",", ")", "]", "\n", "", "", "polygons", "=", "polys_keep", "+", "polys_new", "\n", "ignore_polygons", "=", "ign_polys_keep", "+", "ign_polys_new", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "polygons", ",", "*", "(", "image", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "ignore_polygons", ",", "\n", "*", "(", "image", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.generate_crop_target": [[932, 970], ["numpy.zeros", "numpy.zeros", "numpy.array", "cv2.minAreaRect", "cv2.boxPoints", "numpy.int0", "text_polys.append", "numpy.round().astype", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "numpy.where", "numpy.where", "polygon[].astype().reshape", "numpy.round", "polygon[].astype"], "methods", ["None"], ["", "def", "generate_crop_target", "(", "self", ",", "image", ",", "all_polys", ",", "pad_h", ",", "pad_w", ")", ":", "\n", "        ", "\"\"\"Generate crop target and make sure not to crop the polygon\n        instances.\n\n        Args:\n            image (ndarray): The image waited to be crop.\n            all_polys (list[list[ndarray]]): All polygons including ground\n                truth polygons and ground truth ignored polygons.\n            pad_h (int): Padding length of height.\n            pad_w (int): Padding length of width.\n        Returns:\n            h_axis (ndarray): Vertical cropping range.\n            w_axis (ndarray): Horizontal cropping range.\n        \"\"\"", "\n", "h", ",", "w", ",", "_", "=", "image", ".", "shape", "\n", "h_array", "=", "np", ".", "zeros", "(", "(", "h", "+", "pad_h", "*", "2", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "w_array", "=", "np", ".", "zeros", "(", "(", "w", "+", "pad_w", "*", "2", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "text_polys", "=", "[", "]", "\n", "for", "polygon", "in", "all_polys", ":", "\n", "            ", "rect", "=", "cv2", ".", "minAreaRect", "(", "polygon", "[", "0", "]", ".", "astype", "(", "np", ".", "int32", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "box", "=", "cv2", ".", "boxPoints", "(", "rect", ")", "\n", "box", "=", "np", ".", "int0", "(", "box", ")", "\n", "text_polys", ".", "append", "(", "[", "box", "[", "0", "]", ",", "box", "[", "1", "]", ",", "box", "[", "2", "]", ",", "box", "[", "3", "]", "]", ")", "\n", "\n", "", "polys", "=", "np", ".", "array", "(", "text_polys", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "poly", "in", "polys", ":", "\n", "            ", "poly", "=", "np", ".", "round", "(", "poly", ",", "decimals", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "minx", "=", "np", ".", "min", "(", "poly", "[", ":", ",", "0", "]", ")", "\n", "maxx", "=", "np", ".", "max", "(", "poly", "[", ":", ",", "0", "]", ")", "\n", "w_array", "[", "minx", "+", "pad_w", ":", "maxx", "+", "pad_w", "]", "=", "1", "\n", "miny", "=", "np", ".", "min", "(", "poly", "[", ":", ",", "1", "]", ")", "\n", "maxy", "=", "np", ".", "max", "(", "poly", "[", ":", ",", "1", "]", ")", "\n", "h_array", "[", "miny", "+", "pad_h", ":", "maxy", "+", "pad_h", "]", "=", "1", "\n", "\n", "", "h_axis", "=", "np", ".", "where", "(", "h_array", "==", "0", ")", "[", "0", "]", "\n", "w_axis", "=", "np", ".", "where", "(", "w_array", "==", "0", ")", "[", "0", "]", "\n", "return", "h_axis", ",", "w_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.PyramidRescale.__init__": [[994, 1002], ["isinstance", "isinstance", "isinstance", "isinstance", "len", "numpy.random.randint"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "factor", "=", "4", ",", "base_shape", "=", "(", "128", ",", "512", ")", ",", "randomize_factor", "=", "True", ")", ":", "\n", "        ", "assert", "isinstance", "(", "factor", ",", "int", ")", "\n", "assert", "isinstance", "(", "base_shape", ",", "list", ")", "or", "isinstance", "(", "base_shape", ",", "tuple", ")", "\n", "assert", "len", "(", "base_shape", ")", "==", "2", "\n", "assert", "isinstance", "(", "randomize_factor", ",", "bool", ")", "\n", "self", ".", "factor", "=", "factor", "if", "not", "randomize_factor", "else", "np", ".", "random", ".", "randint", "(", "\n", "0", ",", "factor", "+", "1", ")", "\n", "self", ".", "base_w", ",", "self", ".", "base_h", "=", "base_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.PyramidRescale.__call__": [[1003, 1015], ["mmcv.imresize", "range", "mmcv.imresize", "cv2.pyrDown"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "assert", "'img'", "in", "results", "\n", "if", "self", ".", "factor", "==", "0", ":", "\n", "            ", "return", "results", "\n", "", "img", "=", "results", "[", "'img'", "]", "\n", "src_h", ",", "src_w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "scale_img", "=", "mmcv", ".", "imresize", "(", "img", ",", "(", "self", ".", "base_w", ",", "self", ".", "base_h", ")", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "factor", ")", ":", "\n", "            ", "scale_img", "=", "cv2", ".", "pyrDown", "(", "scale_img", ")", "\n", "", "scale_img", "=", "mmcv", ".", "imresize", "(", "scale_img", ",", "(", "src_w", ",", "src_h", ")", ")", "\n", "results", "[", "'img'", "]", "=", "scale_img", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.PyramidRescale.__repr__": [[1016, 1021], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(factor={self.factor}, '", "\n", "repr_str", "+=", "f'basew={self.basew}, baseh={self.baseh})'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter": [[10, 39], ["isinstance", "isinstance", "max", "range", "len", "len", "shapely.geometry.Point", "shapely.geometry.LineString", "range", "range", "numpy.random.rand", "numpy.random.rand"], "function", ["None"], ["def", "box_jitter", "(", "points_x", ",", "points_y", ",", "jitter_ratio_x", "=", "0.5", ",", "jitter_ratio_y", "=", "0.1", ")", ":", "\n", "    ", "\"\"\"Jitter on the coordinates of bounding box.\n\n    Args:\n        points_x (list[float | int]): List of y for four vertices.\n        points_y (list[float | int]): List of x for four vertices.\n        jitter_ratio_x (float): Horizontal jitter ratio relative to the height.\n        jitter_ratio_y (float): Vertical jitter ratio relative to the height.\n    \"\"\"", "\n", "assert", "len", "(", "points_x", ")", "==", "4", "\n", "assert", "len", "(", "points_y", ")", "==", "4", "\n", "assert", "isinstance", "(", "jitter_ratio_x", ",", "float", ")", "\n", "assert", "isinstance", "(", "jitter_ratio_y", ",", "float", ")", "\n", "assert", "0", "<=", "jitter_ratio_x", "<", "1", "\n", "assert", "0", "<=", "jitter_ratio_y", "<", "1", "\n", "\n", "points", "=", "[", "Point", "(", "points_x", "[", "i", "]", ",", "points_y", "[", "i", "]", ")", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "line_list", "=", "[", "\n", "LineString", "(", "[", "points", "[", "i", "]", ",", "points", "[", "i", "+", "1", "if", "i", "<", "3", "else", "0", "]", "]", ")", "\n", "for", "i", "in", "range", "(", "4", ")", "\n", "]", "\n", "\n", "tmp_h", "=", "max", "(", "line_list", "[", "1", "]", ".", "length", ",", "line_list", "[", "3", "]", ".", "length", ")", "\n", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "jitter_pixel_x", "=", "(", "np", ".", "random", ".", "rand", "(", ")", "-", "0.5", ")", "*", "2", "*", "jitter_ratio_x", "*", "tmp_h", "\n", "jitter_pixel_y", "=", "(", "np", ".", "random", ".", "rand", "(", ")", "-", "0.5", ")", "*", "2", "*", "jitter_ratio_y", "*", "tmp_h", "\n", "points_x", "[", "i", "]", "+=", "jitter_pixel_x", "\n", "points_y", "[", "i", "]", "+=", "jitter_pixel_y", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.warp_img": [[41, 85], ["mmocr.is_type_list", "box_utils.sort_vertex", "numpy.float32", "max", "max", "numpy.float32", "cv2.getPerspectiveTransform", "cv2.warpPerspective", "len", "min", "min", "crop.box_jitter", "shapely.geometry.Point", "shapely.geometry.LineString", "max", "max", "range", "range", "int", "int", "range"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter"], ["", "", "def", "warp_img", "(", "src_img", ",", "\n", "box", ",", "\n", "jitter_flag", "=", "False", ",", "\n", "jitter_ratio_x", "=", "0.5", ",", "\n", "jitter_ratio_y", "=", "0.1", ")", ":", "\n", "    ", "\"\"\"Crop box area from image using opencv warpPerspective w/o box jitter.\n\n    Args:\n        src_img (np.array): Image before cropping.\n        box (list[float | int]): Coordinates of quadrangle.\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "box", ",", "(", "float", ",", "int", ")", ")", "\n", "assert", "len", "(", "box", ")", "==", "8", "\n", "\n", "h", ",", "w", "=", "src_img", ".", "shape", "[", ":", "2", "]", "\n", "points_x", "=", "[", "min", "(", "max", "(", "x", ",", "0", ")", ",", "w", ")", "for", "x", "in", "box", "[", "0", ":", "8", ":", "2", "]", "]", "\n", "points_y", "=", "[", "min", "(", "max", "(", "y", ",", "0", ")", ",", "h", ")", "for", "y", "in", "box", "[", "1", ":", "9", ":", "2", "]", "]", "\n", "\n", "points_x", ",", "points_y", "=", "sort_vertex", "(", "points_x", ",", "points_y", ")", "\n", "\n", "if", "jitter_flag", ":", "\n", "        ", "box_jitter", "(", "\n", "points_x", ",", "\n", "points_y", ",", "\n", "jitter_ratio_x", "=", "jitter_ratio_x", ",", "\n", "jitter_ratio_y", "=", "jitter_ratio_y", ")", "\n", "\n", "", "points", "=", "[", "Point", "(", "points_x", "[", "i", "]", ",", "points_y", "[", "i", "]", ")", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "edges", "=", "[", "\n", "LineString", "(", "[", "points", "[", "i", "]", ",", "points", "[", "i", "+", "1", "if", "i", "<", "3", "else", "0", "]", "]", ")", "\n", "for", "i", "in", "range", "(", "4", ")", "\n", "]", "\n", "\n", "pts1", "=", "np", ".", "float32", "(", "[", "[", "points", "[", "i", "]", ".", "x", ",", "points", "[", "i", "]", ".", "y", "]", "for", "i", "in", "range", "(", "4", ")", "]", ")", "\n", "box_width", "=", "max", "(", "edges", "[", "0", "]", ".", "length", ",", "edges", "[", "2", "]", ".", "length", ")", "\n", "box_height", "=", "max", "(", "edges", "[", "1", "]", ".", "length", ",", "edges", "[", "3", "]", ".", "length", ")", "\n", "\n", "pts2", "=", "np", ".", "float32", "(", "[", "[", "0", ",", "0", "]", ",", "[", "box_width", ",", "0", "]", ",", "[", "box_width", ",", "box_height", "]", ",", "\n", "[", "0", ",", "box_height", "]", "]", ")", "\n", "M", "=", "cv2", ".", "getPerspectiveTransform", "(", "pts1", ",", "pts2", ")", "\n", "dst_img", "=", "cv2", ".", "warpPerspective", "(", "src_img", ",", "M", ",", "\n", "(", "int", "(", "box_width", ")", ",", "int", "(", "box_height", ")", ")", ")", "\n", "\n", "return", "dst_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img": [[87, 126], ["mmocr.is_type_list", "numpy.clip", "numpy.clip", "min", "numpy.clip", "numpy.clip", "numpy.clip", "numpy.clip", "len", "numpy.array", "numpy.array", "numpy.max", "numpy.min", "numpy.max", "numpy.min", "int", "int", "int", "int", "numpy.min", "numpy.min", "numpy.max", "numpy.max"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "crop_img", "(", "src_img", ",", "box", ",", "long_edge_pad_ratio", "=", "0.4", ",", "short_edge_pad_ratio", "=", "0.2", ")", ":", "\n", "    ", "\"\"\"Crop text region with their bounding box.\n\n    Args:\n        src_img (np.array): The original image.\n        box (list[float | int]): Points of quadrangle.\n        long_edge_pad_ratio (float): Box pad ratio for long edge\n            corresponding to font size.\n        short_edge_pad_ratio (float): Box pad ratio for short edge\n            corresponding to font size.\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "box", ",", "(", "float", ",", "int", ")", ")", "\n", "assert", "len", "(", "box", ")", "==", "8", "\n", "assert", "0.", "<=", "long_edge_pad_ratio", "<", "1.0", "\n", "assert", "0.", "<=", "short_edge_pad_ratio", "<", "1.0", "\n", "\n", "h", ",", "w", "=", "src_img", ".", "shape", "[", ":", "2", "]", "\n", "points_x", "=", "np", ".", "clip", "(", "np", ".", "array", "(", "box", "[", "0", ":", ":", "2", "]", ")", ",", "0", ",", "w", ")", "\n", "points_y", "=", "np", ".", "clip", "(", "np", ".", "array", "(", "box", "[", "1", ":", ":", "2", "]", ")", ",", "0", ",", "h", ")", "\n", "\n", "box_width", "=", "np", ".", "max", "(", "points_x", ")", "-", "np", ".", "min", "(", "points_x", ")", "\n", "box_height", "=", "np", ".", "max", "(", "points_y", ")", "-", "np", ".", "min", "(", "points_y", ")", "\n", "font_size", "=", "min", "(", "box_height", ",", "box_width", ")", "\n", "\n", "if", "box_height", "<", "box_width", ":", "\n", "        ", "horizontal_pad", "=", "long_edge_pad_ratio", "*", "font_size", "\n", "vertical_pad", "=", "short_edge_pad_ratio", "*", "font_size", "\n", "", "else", ":", "\n", "        ", "horizontal_pad", "=", "short_edge_pad_ratio", "*", "font_size", "\n", "vertical_pad", "=", "long_edge_pad_ratio", "*", "font_size", "\n", "\n", "", "left", "=", "np", ".", "clip", "(", "int", "(", "np", ".", "min", "(", "points_x", ")", "-", "horizontal_pad", ")", ",", "0", ",", "w", ")", "\n", "top", "=", "np", ".", "clip", "(", "int", "(", "np", ".", "min", "(", "points_y", ")", "-", "vertical_pad", ")", ",", "0", ",", "h", ")", "\n", "right", "=", "np", ".", "clip", "(", "int", "(", "np", ".", "max", "(", "points_x", ")", "+", "horizontal_pad", ")", ",", "0", ",", "w", ")", "\n", "bottom", "=", "np", ".", "clip", "(", "int", "(", "np", ".", "max", "(", "points_y", ")", "+", "vertical_pad", ")", ",", "0", ",", "h", ")", "\n", "\n", "dst_img", "=", "src_img", "[", "top", ":", "bottom", ",", "left", ":", "right", "]", "\n", "\n", "return", "dst_img", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ner_transforms.NerTransform.__init__": [[20, 23], ["mmocr.models.builder.build_convertor"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor"], ["def", "__init__", "(", "self", ",", "label_convertor", ",", "max_len", ")", ":", "\n", "        ", "self", ".", "label_convertor", "=", "build_convertor", "(", "label_convertor", ")", "\n", "self", ".", "max_len", "=", "max_len", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ner_transforms.NerTransform.__call__": [[24, 43], ["ner_transforms.NerTransform.label_convertor.convert_text2id", "ner_transforms.NerTransform.label_convertor.convert_entity2label", "range", "dict", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_text2id", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_entity2label"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "texts", "=", "results", "[", "'text'", "]", "\n", "input_ids", "=", "self", ".", "label_convertor", ".", "convert_text2id", "(", "texts", ")", "\n", "labels", "=", "self", ".", "label_convertor", ".", "convert_entity2label", "(", "\n", "results", "[", "'label'", "]", ",", "len", "(", "texts", ")", ")", "\n", "\n", "attention_mask", "=", "[", "0", "]", "*", "self", ".", "max_len", "\n", "token_type_ids", "=", "[", "0", "]", "*", "self", ".", "max_len", "\n", "# The beginning and end IDs are added to the ID,", "\n", "# so the mask length is increased by 2", "\n", "for", "i", "in", "range", "(", "len", "(", "texts", ")", "+", "2", ")", ":", "\n", "            ", "attention_mask", "[", "i", "]", "=", "1", "\n", "", "results", "=", "dict", "(", "\n", "labels", "=", "labels", ",", "\n", "texts", "=", "texts", ",", "\n", "input_ids", "=", "input_ids", ",", "\n", "attention_mask", "=", "attention_mask", ",", "\n", "token_type_ids", "=", "token_type_ids", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ner_transforms.ToTensorNER.__call__": [[49, 64], ["torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "dict", "dict"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "input_ids", "=", "torch", ".", "tensor", "(", "results", "[", "'input_ids'", "]", ")", "\n", "labels", "=", "torch", ".", "tensor", "(", "results", "[", "'labels'", "]", ")", "\n", "attention_masks", "=", "torch", ".", "tensor", "(", "results", "[", "'attention_mask'", "]", ")", "\n", "token_type_ids", "=", "torch", ".", "tensor", "(", "results", "[", "'token_type_ids'", "]", ")", "\n", "\n", "results", "=", "dict", "(", "\n", "img", "=", "[", "]", ",", "\n", "img_metas", "=", "dict", "(", "\n", "input_ids", "=", "input_ids", ",", "\n", "attention_masks", "=", "attention_masks", ",", "\n", "labels", "=", "labels", ",", "\n", "token_type_ids", "=", "token_type_ids", ")", ")", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.custom_format_bundle.CustomFormatBundle.__init__": [[28, 37], ["dict", "mmdet.datasets.pipelines.formatting.DefaultFormatBundle.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "keys", "=", "[", "]", ",", "\n", "call_super", "=", "True", ",", "\n", "visualize", "=", "dict", "(", "flag", "=", "False", ",", "boundary_key", "=", "None", ")", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "visualize", "=", "visualize", "\n", "self", ".", "keys", "=", "keys", "\n", "self", ".", "call_super", "=", "call_super", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.custom_format_bundle.CustomFormatBundle.__call__": [[38, 64], ["results[].astype", "mmocr.core.visualize.show_feature", "super().__call__", "mmcv.parallel.DataContainer", "mmocr.core.visualize.overlay_mask_img", "range", "len", "features.append", "names.append", "to_uint8.append", "str"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.textsnake_postprocessor.TextSnakePostprocessor.__call__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.overlay_mask_img"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "if", "self", ".", "visualize", "[", "'flag'", "]", ":", "\n", "            ", "img", "=", "results", "[", "'img'", "]", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "boundary_key", "=", "self", ".", "visualize", "[", "'boundary_key'", "]", "\n", "if", "boundary_key", "is", "not", "None", ":", "\n", "                ", "img", "=", "overlay_mask_img", "(", "img", ",", "results", "[", "boundary_key", "]", ".", "masks", "[", "0", "]", ")", "\n", "\n", "", "features", "=", "[", "img", "]", "\n", "names", "=", "[", "'img'", "]", "\n", "to_uint8", "=", "[", "1", "]", "\n", "\n", "for", "k", "in", "results", "[", "'mask_fields'", "]", ":", "\n", "                ", "for", "iter", "in", "range", "(", "len", "(", "results", "[", "k", "]", ".", "masks", ")", ")", ":", "\n", "                    ", "features", ".", "append", "(", "results", "[", "k", "]", ".", "masks", "[", "iter", "]", ")", "\n", "names", ".", "append", "(", "k", "+", "str", "(", "iter", ")", ")", "\n", "to_uint8", ".", "append", "(", "0", ")", "\n", "", "", "show_feature", "(", "features", ",", "names", ",", "to_uint8", ")", "\n", "\n", "", "if", "self", ".", "call_super", ":", "\n", "            ", "results", "=", "super", "(", ")", ".", "__call__", "(", "results", ")", "\n", "\n", "", "for", "k", "in", "self", ".", "keys", ":", "\n", "            ", "results", "[", "k", "]", "=", "DC", "(", "results", "[", "k", "]", ",", "cpu_only", "=", "True", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.custom_format_bundle.CustomFormatBundle.__repr__": [[65, 67], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex": [[7, 26], ["mmocr.is_type_list", "mmocr.is_type_list", "numpy.stack().astype", "box_utils._sort_vertex", "list", "list", "len", "len", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils._sort_vertex"], ["def", "sort_vertex", "(", "points_x", ",", "points_y", ")", ":", "\n", "    ", "\"\"\"Sort box vertices in clockwise order from left-top first.\n\n    Args:\n        points_x (list[float]): x of four vertices.\n        points_y (list[float]): y of four vertices.\n    Returns:\n        sorted_points_x (list[float]): x of sorted four vertices.\n        sorted_points_y (list[float]): y of sorted four vertices.\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "points_x", ",", "(", "float", ",", "int", ")", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "points_y", ",", "(", "float", ",", "int", ")", ")", "\n", "assert", "len", "(", "points_x", ")", "==", "4", "\n", "assert", "len", "(", "points_y", ")", "==", "4", "\n", "vertices", "=", "np", ".", "stack", "(", "(", "points_x", ",", "points_y", ")", ",", "axis", "=", "-", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "vertices", "=", "_sort_vertex", "(", "vertices", ")", "\n", "sorted_points_x", "=", "list", "(", "vertices", "[", ":", ",", "0", "]", ")", "\n", "sorted_points_y", "=", "list", "(", "vertices", "[", ":", ",", "1", "]", ")", "\n", "return", "sorted_points_x", ",", "sorted_points_y", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils._sort_vertex": [[28, 46], ["numpy.mean", "numpy.arctan2", "numpy.argsort", "numpy.min", "numpy.linalg.norm", "numpy.argmin", "numpy.arange"], "function", ["None"], ["", "def", "_sort_vertex", "(", "vertices", ")", ":", "\n", "    ", "assert", "vertices", ".", "ndim", "==", "2", "\n", "assert", "vertices", ".", "shape", "[", "-", "1", "]", "==", "2", "\n", "N", "=", "vertices", ".", "shape", "[", "0", "]", "\n", "if", "N", "==", "0", ":", "\n", "        ", "return", "vertices", "\n", "\n", "", "center", "=", "np", ".", "mean", "(", "vertices", ",", "axis", "=", "0", ")", "\n", "directions", "=", "vertices", "-", "center", "\n", "angles", "=", "np", ".", "arctan2", "(", "directions", "[", ":", ",", "1", "]", ",", "directions", "[", ":", ",", "0", "]", ")", "\n", "sort_idx", "=", "np", ".", "argsort", "(", "angles", ")", "\n", "vertices", "=", "vertices", "[", "sort_idx", "]", "\n", "\n", "left_top", "=", "np", ".", "min", "(", "vertices", ",", "axis", "=", "0", ")", "\n", "dists", "=", "np", ".", "linalg", ".", "norm", "(", "left_top", "-", "vertices", ",", "axis", "=", "-", "1", ",", "ord", "=", "2", ")", "\n", "lefttop_idx", "=", "np", ".", "argmin", "(", "dists", ")", "\n", "indexes", "=", "(", "np", ".", "arange", "(", "N", ",", "dtype", "=", "np", ".", "int", ")", "+", "lefttop_idx", ")", "%", "N", "\n", "return", "vertices", "[", "indexes", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex8": [[48, 54], ["box_utils._sort_vertex", "list", "len", "numpy.array().reshape", "_sort_vertex.flatten", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils._sort_vertex"], ["", "def", "sort_vertex8", "(", "points", ")", ":", "\n", "    ", "\"\"\"Sort vertex with 8 points [x1 y1 x2 y2 x3 y3 x4 y4]\"\"\"", "\n", "assert", "len", "(", "points", ")", "==", "8", "\n", "vertices", "=", "_sort_vertex", "(", "np", ".", "array", "(", "points", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "sorted_box", "=", "list", "(", "vertices", ".", "flatten", "(", ")", ")", "\n", "return", "sorted_box", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.test_time_aug.MultiRotateAugOCR.__init__": [[53, 67], ["mmdet.datasets.pipelines.compose.Compose", "mmcv.is_list_of", "isinstance", "test_time_aug.MultiRotateAugOCR.rotate_degrees.append"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ",", "rotate_degrees", "=", "None", ",", "force_rotate", "=", "False", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "Compose", "(", "transforms", ")", "\n", "self", ".", "force_rotate", "=", "force_rotate", "\n", "if", "rotate_degrees", "is", "not", "None", ":", "\n", "            ", "self", ".", "rotate_degrees", "=", "rotate_degrees", "if", "isinstance", "(", "\n", "rotate_degrees", ",", "list", ")", "else", "[", "rotate_degrees", "]", "\n", "assert", "mmcv", ".", "is_list_of", "(", "self", ".", "rotate_degrees", ",", "int", ")", "\n", "for", "degree", "in", "self", ".", "rotate_degrees", ":", "\n", "                ", "assert", "0", "<=", "degree", "<", "360", "\n", "assert", "degree", "%", "90", "==", "0", "\n", "", "if", "0", "not", "in", "self", ".", "rotate_degrees", ":", "\n", "                ", "self", ".", "rotate_degrees", ".", "append", "(", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "rotate_degrees", "=", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.test_time_aug.MultiRotateAugOCR.__call__": [[68, 103], ["set", "results.copy", "test_time_aug.MultiRotateAugOCR.transforms", "aug_data.append", "test_time_aug.MultiRotateAugOCR.items", "aug_data_dict[].append", "numpy.rot90", "numpy.rot90", "numpy.rot90"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to apply test time augment transformation to results.\n\n        Args:\n            results (dict): Result dict contains the data to be transformed.\n\n        Returns:\n           dict[str: list]: The augmented data, where each value is wrapped\n               into a list.\n        \"\"\"", "\n", "img_shape", "=", "results", "[", "'img_shape'", "]", "\n", "ori_height", ",", "ori_width", "=", "img_shape", "[", ":", "2", "]", "\n", "if", "not", "self", ".", "force_rotate", "and", "ori_height", "<=", "ori_width", ":", "\n", "            ", "rotate_degrees", "=", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "rotate_degrees", "=", "self", ".", "rotate_degrees", "\n", "", "aug_data", "=", "[", "]", "\n", "for", "degree", "in", "set", "(", "rotate_degrees", ")", ":", "\n", "            ", "_results", "=", "results", ".", "copy", "(", ")", "\n", "if", "degree", "==", "0", ":", "\n", "                ", "pass", "\n", "", "elif", "degree", "==", "90", ":", "\n", "                ", "_results", "[", "'img'", "]", "=", "np", ".", "rot90", "(", "_results", "[", "'img'", "]", ",", "1", ")", "\n", "", "elif", "degree", "==", "180", ":", "\n", "                ", "_results", "[", "'img'", "]", "=", "np", ".", "rot90", "(", "_results", "[", "'img'", "]", ",", "2", ")", "\n", "", "elif", "degree", "==", "270", ":", "\n", "                ", "_results", "[", "'img'", "]", "=", "np", ".", "rot90", "(", "_results", "[", "'img'", "]", ",", "3", ")", "\n", "", "data", "=", "self", ".", "transforms", "(", "_results", ")", "\n", "aug_data", ".", "append", "(", "data", ")", "\n", "# list of dict to dict of list", "\n", "", "aug_data_dict", "=", "{", "key", ":", "[", "]", "for", "key", "in", "aug_data", "[", "0", "]", "}", "\n", "for", "data", "in", "aug_data", ":", "\n", "            ", "for", "key", ",", "val", "in", "data", ".", "items", "(", ")", ":", "\n", "                ", "aug_data_dict", "[", "key", "]", ".", "append", "(", "val", ")", "\n", "", "", "return", "aug_data_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.test_time_aug.MultiRotateAugOCR.__repr__": [[104, 109], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(transforms={self.transforms}, '", "\n", "repr_str", "+=", "f'rotate_degrees={self.rotate_degrees})'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.ResizeOCR.__init__": [[39, 66], ["isinstance", "mmocr.is_none_or_type", "mmocr.is_none_or_type", "isinstance", "isinstance", "isinstance", "isinstance", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type"], ["def", "__init__", "(", "self", ",", "\n", "height", ",", "\n", "min_width", "=", "None", ",", "\n", "max_width", "=", "None", ",", "\n", "keep_aspect_ratio", "=", "True", ",", "\n", "img_pad_value", "=", "0", ",", "\n", "width_downsample_ratio", "=", "1.0", "/", "16", ",", "\n", "backend", "=", "None", ")", ":", "\n", "        ", "assert", "isinstance", "(", "height", ",", "(", "int", ",", "tuple", ")", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "min_width", ",", "(", "int", ",", "tuple", ")", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "max_width", ",", "(", "int", ",", "tuple", ")", ")", "\n", "if", "not", "keep_aspect_ratio", ":", "\n", "            ", "assert", "max_width", "is", "not", "None", ",", "(", "'\"max_width\" must assigned '", "\n", "'if \"keep_aspect_ratio\" is False'", ")", "\n", "", "assert", "isinstance", "(", "img_pad_value", ",", "int", ")", "\n", "if", "isinstance", "(", "height", ",", "tuple", ")", ":", "\n", "            ", "assert", "isinstance", "(", "min_width", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "max_width", ",", "tuple", ")", "\n", "assert", "len", "(", "height", ")", "==", "len", "(", "min_width", ")", "==", "len", "(", "max_width", ")", "\n", "\n", "", "self", ".", "height", "=", "height", "\n", "self", ".", "min_width", "=", "min_width", "\n", "self", ".", "max_width", "=", "max_width", "\n", "self", ".", "keep_aspect_ratio", "=", "keep_aspect_ratio", "\n", "self", ".", "img_pad_value", "=", "img_pad_value", "\n", "self", ".", "width_downsample_ratio", "=", "width_downsample_ratio", "\n", "self", ".", "backend", "=", "backend", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.ResizeOCR.__call__": [[67, 130], ["mmcv.runner.dist_utils.get_dist_info", "isinstance", "list", "list", "math.ceil", "int", "mmcv.imresize", "len", "max", "min", "min", "mmcv.imresize", "mmcv.imresize", "round", "mmcv.impad", "float"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "isinstance", "(", "self", ".", "height", ",", "int", ")", ":", "\n", "            ", "dst_height", "=", "self", ".", "height", "\n", "dst_min_width", "=", "self", ".", "min_width", "\n", "dst_max_width", "=", "self", ".", "max_width", "\n", "", "else", ":", "\n", "# Multi-scale resize used in distributed training.", "\n", "# Choose one (height, width) pair for one rank id.", "\n", "\n", "            ", "idx", "=", "rank", "%", "len", "(", "self", ".", "height", ")", "\n", "dst_height", "=", "self", ".", "height", "[", "idx", "]", "\n", "dst_min_width", "=", "self", ".", "min_width", "[", "idx", "]", "\n", "dst_max_width", "=", "self", ".", "max_width", "[", "idx", "]", "\n", "\n", "", "img_shape", "=", "results", "[", "'img_shape'", "]", "\n", "ori_height", ",", "ori_width", "=", "img_shape", "[", ":", "2", "]", "\n", "valid_ratio", "=", "1.0", "\n", "resize_shape", "=", "list", "(", "img_shape", ")", "\n", "pad_shape", "=", "list", "(", "img_shape", ")", "\n", "\n", "if", "self", ".", "keep_aspect_ratio", ":", "\n", "            ", "new_width", "=", "math", ".", "ceil", "(", "float", "(", "dst_height", ")", "/", "ori_height", "*", "ori_width", ")", "\n", "width_divisor", "=", "int", "(", "1", "/", "self", ".", "width_downsample_ratio", ")", "\n", "# make sure new_width is an integral multiple of width_divisor.", "\n", "if", "new_width", "%", "width_divisor", "!=", "0", ":", "\n", "                ", "new_width", "=", "round", "(", "new_width", "/", "width_divisor", ")", "*", "width_divisor", "\n", "", "if", "dst_min_width", "is", "not", "None", ":", "\n", "                ", "new_width", "=", "max", "(", "dst_min_width", ",", "new_width", ")", "\n", "", "if", "dst_max_width", "is", "not", "None", ":", "\n", "                ", "valid_ratio", "=", "min", "(", "1.0", ",", "1.0", "*", "new_width", "/", "dst_max_width", ")", "\n", "resize_width", "=", "min", "(", "dst_max_width", ",", "new_width", ")", "\n", "img_resize", "=", "mmcv", ".", "imresize", "(", "\n", "results", "[", "'img'", "]", ",", "(", "resize_width", ",", "dst_height", ")", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "resize_shape", "=", "img_resize", ".", "shape", "\n", "pad_shape", "=", "img_resize", ".", "shape", "\n", "if", "new_width", "<", "dst_max_width", ":", "\n", "                    ", "img_resize", "=", "mmcv", ".", "impad", "(", "\n", "img_resize", ",", "\n", "shape", "=", "(", "dst_height", ",", "dst_max_width", ")", ",", "\n", "pad_val", "=", "self", ".", "img_pad_value", ")", "\n", "pad_shape", "=", "img_resize", ".", "shape", "\n", "", "", "else", ":", "\n", "                ", "img_resize", "=", "mmcv", ".", "imresize", "(", "\n", "results", "[", "'img'", "]", ",", "(", "new_width", ",", "dst_height", ")", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "resize_shape", "=", "img_resize", ".", "shape", "\n", "pad_shape", "=", "img_resize", ".", "shape", "\n", "", "", "else", ":", "\n", "            ", "img_resize", "=", "mmcv", ".", "imresize", "(", "\n", "results", "[", "'img'", "]", ",", "(", "dst_max_width", ",", "dst_height", ")", ",", "\n", "backend", "=", "self", ".", "backend", ")", "\n", "resize_shape", "=", "img_resize", ".", "shape", "\n", "pad_shape", "=", "img_resize", ".", "shape", "\n", "\n", "", "results", "[", "'img'", "]", "=", "img_resize", "\n", "results", "[", "'img_shape'", "]", "=", "resize_shape", "\n", "results", "[", "'resize_shape'", "]", "=", "resize_shape", "\n", "results", "[", "'pad_shape'", "]", "=", "pad_shape", "\n", "results", "[", "'valid_ratio'", "]", "=", "valid_ratio", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.ToTensorOCR.__init__": [[136, 138], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.ToTensorOCR.__call__": [[139, 143], ["torchvision.to_tensor", "results[].copy"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "[", "'img'", "]", "=", "TF", ".", "to_tensor", "(", "results", "[", "'img'", "]", ".", "copy", "(", ")", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.NormalizeOCR.__init__": [[149, 152], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.NormalizeOCR.__call__": [[153, 157], ["torchvision.normalize", "dict"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "[", "'img'", "]", "=", "TF", ".", "normalize", "(", "results", "[", "'img'", "]", ",", "self", ".", "mean", ",", "self", ".", "std", ")", "\n", "results", "[", "'img_norm_cfg'", "]", "=", "dict", "(", "mean", "=", "self", ".", "mean", ",", "std", "=", "self", ".", "std", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.OnlineCropOCR.__init__": [[173, 187], ["mmocr.is_type_list"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["def", "__init__", "(", "self", ",", "\n", "box_keys", "=", "[", "'x1'", ",", "'y1'", ",", "'x2'", ",", "'y2'", ",", "'x3'", ",", "'y3'", ",", "'x4'", ",", "'y4'", "]", ",", "\n", "jitter_prob", "=", "0.5", ",", "\n", "max_jitter_ratio_x", "=", "0.05", ",", "\n", "max_jitter_ratio_y", "=", "0.02", ")", ":", "\n", "        ", "assert", "utils", ".", "is_type_list", "(", "box_keys", ",", "str", ")", "\n", "assert", "0", "<=", "jitter_prob", "<=", "1", "\n", "assert", "0", "<=", "max_jitter_ratio_x", "<=", "1", "\n", "assert", "0", "<=", "max_jitter_ratio_y", "<=", "1", "\n", "\n", "self", ".", "box_keys", "=", "box_keys", "\n", "self", ".", "jitter_prob", "=", "jitter_prob", "\n", "self", ".", "max_jitter_ratio_x", "=", "max_jitter_ratio_x", "\n", "self", ".", "max_jitter_ratio_y", "=", "max_jitter_ratio_y", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.OnlineCropOCR.__call__": [[188, 217], ["dict", "mmocr.datasets.pipelines.crop.warp_img", "shapely.geometry.box.append", "numpy.random.random", "float"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.warp_img"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "if", "'img_info'", "not", "in", "results", ":", "\n", "            ", "return", "results", "\n", "\n", "", "crop_flag", "=", "True", "\n", "box", "=", "[", "]", "\n", "for", "key", "in", "self", ".", "box_keys", ":", "\n", "            ", "if", "key", "not", "in", "results", "[", "'img_info'", "]", ":", "\n", "                ", "crop_flag", "=", "False", "\n", "break", "\n", "\n", "", "box", ".", "append", "(", "float", "(", "results", "[", "'img_info'", "]", "[", "key", "]", ")", ")", "\n", "\n", "", "if", "not", "crop_flag", ":", "\n", "            ", "return", "results", "\n", "\n", "", "jitter_flag", "=", "np", ".", "random", ".", "random", "(", ")", ">", "self", ".", "jitter_prob", "\n", "\n", "kwargs", "=", "dict", "(", "\n", "jitter_flag", "=", "jitter_flag", ",", "\n", "jitter_ratio_x", "=", "self", ".", "max_jitter_ratio_x", ",", "\n", "jitter_ratio_y", "=", "self", ".", "max_jitter_ratio_y", ")", "\n", "crop_img", "=", "warp_img", "(", "results", "[", "'img'", "]", ",", "box", ",", "**", "kwargs", ")", "\n", "\n", "results", "[", "'img'", "]", "=", "crop_img", "\n", "results", "[", "'img_shape'", "]", "=", "crop_img", ".", "shape", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.FancyPCA.__init__": [[228, 239], ["torch.Tensor().t", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "eig_vec", "=", "None", ",", "eig_val", "=", "None", ")", ":", "\n", "        ", "if", "eig_vec", "is", "None", ":", "\n", "            ", "eig_vec", "=", "torch", ".", "Tensor", "(", "[", "\n", "[", "-", "0.5675", ",", "+", "0.7192", ",", "+", "0.4009", "]", ",", "\n", "[", "-", "0.5808", ",", "-", "0.0045", ",", "-", "0.8140", "]", ",", "\n", "[", "-", "0.5836", ",", "-", "0.6948", ",", "+", "0.4203", "]", ",", "\n", "]", ")", ".", "t", "(", ")", "\n", "", "if", "eig_val", "is", "None", ":", "\n", "            ", "eig_val", "=", "torch", ".", "Tensor", "(", "[", "[", "0.2175", ",", "0.0188", ",", "0.0045", "]", "]", ")", "\n", "", "self", ".", "eig_val", "=", "eig_val", "# 1*3", "\n", "self", ".", "eig_vec", "=", "eig_vec", "# 3*3", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.FancyPCA.pca": [[240, 247], ["torch.mm", "tensor.size", "torch.normal", "torch.mm.view", "torch.zeros_like"], "methods", ["None"], ["", "def", "pca", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "assert", "tensor", ".", "size", "(", "0", ")", "==", "3", "\n", "alpha", "=", "torch", ".", "normal", "(", "mean", "=", "torch", ".", "zeros_like", "(", "self", ".", "eig_val", ")", ")", "*", "0.1", "\n", "reconst", "=", "torch", ".", "mm", "(", "self", ".", "eig_val", "*", "alpha", ",", "self", ".", "eig_vec", ")", "\n", "tensor", "=", "tensor", "+", "reconst", ".", "view", "(", "3", ",", "1", ",", "1", ")", "\n", "\n", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.FancyPCA.__call__": [[248, 254], ["ocr_transforms.FancyPCA.pca"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.FancyPCA.pca"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "\n", "tensor", "=", "self", ".", "pca", "(", "img", ")", "\n", "results", "[", "'img'", "]", "=", "tensor", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.FancyPCA.__repr__": [[255, 258], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomPaddingOCR.__init__": [[273, 283], ["mmocr.is_type_list", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["def", "__init__", "(", "self", ",", "max_ratio", "=", "None", ",", "box_type", "=", "None", ")", ":", "\n", "        ", "if", "max_ratio", "is", "None", ":", "\n", "            ", "max_ratio", "=", "[", "0.1", ",", "0.2", ",", "0.1", ",", "0.2", "]", "\n", "", "else", ":", "\n", "            ", "assert", "utils", ".", "is_type_list", "(", "max_ratio", ",", "float", ")", "\n", "assert", "len", "(", "max_ratio", ")", "==", "4", "\n", "", "assert", "box_type", "is", "None", "or", "box_type", "in", "(", "'char_rects'", ",", "'char_quads'", ")", "\n", "\n", "self", ".", "max_ratio", "=", "max_ratio", "\n", "self", ".", "box_type", "=", "box_type", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomPaddingOCR.__call__": [[284, 316], ["round", "round", "round", "round", "mmcv.impad", "len", "range", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "range"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "img_shape", "=", "results", "[", "'img_shape'", "]", "\n", "ori_height", ",", "ori_width", "=", "img_shape", "[", ":", "2", "]", "\n", "\n", "random_padding_left", "=", "round", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0", ",", "self", ".", "max_ratio", "[", "0", "]", ")", "*", "ori_width", ")", "\n", "random_padding_top", "=", "round", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0", ",", "self", ".", "max_ratio", "[", "1", "]", ")", "*", "ori_height", ")", "\n", "random_padding_right", "=", "round", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0", ",", "self", ".", "max_ratio", "[", "2", "]", ")", "*", "ori_width", ")", "\n", "random_padding_bottom", "=", "round", "(", "\n", "np", ".", "random", ".", "uniform", "(", "0", ",", "self", ".", "max_ratio", "[", "3", "]", ")", "*", "ori_height", ")", "\n", "\n", "padding", "=", "(", "random_padding_left", ",", "random_padding_top", ",", "\n", "random_padding_right", ",", "random_padding_bottom", ")", "\n", "img", "=", "mmcv", ".", "impad", "(", "results", "[", "'img'", "]", ",", "padding", "=", "padding", ",", "padding_mode", "=", "'edge'", ")", "\n", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "\n", "if", "self", ".", "box_type", "is", "not", "None", ":", "\n", "            ", "num_points", "=", "2", "if", "self", ".", "box_type", "==", "'char_rects'", "else", "4", "\n", "char_num", "=", "len", "(", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", ")", "\n", "for", "i", "in", "range", "(", "char_num", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "num_points", ")", ":", "\n", "                    ", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", "[", "i", "]", "[", "\n", "j", "*", "2", "]", "+=", "random_padding_left", "\n", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", "[", "i", "]", "[", "\n", "j", "*", "2", "+", "1", "]", "+=", "random_padding_top", "\n", "\n", "", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomPaddingOCR.__repr__": [[317, 320], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomRotateImageBox.__init__": [[335, 341], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_angle", "=", "-", "10", ",", "max_angle", "=", "10", ",", "box_type", "=", "'char_quads'", ")", ":", "\n", "        ", "assert", "box_type", "in", "(", "'char_rects'", ",", "'char_quads'", ")", "\n", "\n", "self", ".", "min_angle", "=", "min_angle", "\n", "self", ".", "max_angle", "=", "max_angle", "\n", "self", ".", "box_type", "=", "box_type", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomRotateImageBox.__call__": [[342, 376], ["numpy.random.uniform", "shapely.geometry.box", "torchvision.rotate", "ocr_transforms.RandomRotateImageBox.rotate_bbox", "max", "min", "numpy.arctan"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomRotatePolyInstances.rotate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomRotateImageBox.rotate_bbox"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "in_img", "=", "results", "[", "'img'", "]", "\n", "in_chars", "=", "results", "[", "'ann_info'", "]", "[", "'chars'", "]", "\n", "in_boxes", "=", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", "\n", "\n", "img_width", ",", "img_height", "=", "in_img", ".", "size", "\n", "rotate_center", "=", "[", "img_width", "/", "2.", ",", "img_height", "/", "2.", "]", "\n", "\n", "tan_temp_max_angle", "=", "rotate_center", "[", "1", "]", "/", "rotate_center", "[", "0", "]", "\n", "temp_max_angle", "=", "np", ".", "arctan", "(", "tan_temp_max_angle", ")", "*", "180.", "/", "np", ".", "pi", "\n", "\n", "random_angle", "=", "np", ".", "random", ".", "uniform", "(", "\n", "max", "(", "self", ".", "min_angle", ",", "-", "temp_max_angle", ")", ",", "\n", "min", "(", "self", ".", "max_angle", ",", "temp_max_angle", ")", ")", "\n", "random_angle_radian", "=", "random_angle", "*", "np", ".", "pi", "/", "180.", "\n", "\n", "img_box", "=", "shapely_box", "(", "0", ",", "0", ",", "img_width", ",", "img_height", ")", "\n", "\n", "out_img", "=", "TF", ".", "rotate", "(", "\n", "in_img", ",", "\n", "random_angle", ",", "\n", "resample", "=", "False", ",", "\n", "expand", "=", "False", ",", "\n", "center", "=", "rotate_center", ")", "\n", "\n", "out_boxes", ",", "out_chars", "=", "self", ".", "rotate_bbox", "(", "in_boxes", ",", "in_chars", ",", "\n", "random_angle_radian", ",", "\n", "rotate_center", ",", "img_box", ")", "\n", "\n", "results", "[", "'img'", "]", "=", "out_img", "\n", "results", "[", "'ann_info'", "]", "[", "'chars'", "]", "=", "out_chars", "\n", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", "=", "out_boxes", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomRotateImageBox.rotate_bbox": [[377, 404], ["enumerate", "range", "shapely.geometry.Polygon().buffer", "temp_bbox.append", "len", "ocr_transforms.RandomRotateImageBox.rotate_point", "shapely.geometry.Polygon", "img_box.intersects", "img_box.touches", "img_box.intersection", "out_boxes.append", "out_chars.append", "out_box.extend"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomRotateImageBox.rotate_point"], ["", "@", "staticmethod", "\n", "def", "rotate_bbox", "(", "boxes", ",", "chars", ",", "angle", ",", "center", ",", "img_box", ")", ":", "\n", "        ", "out_boxes", "=", "[", "]", "\n", "out_chars", "=", "[", "]", "\n", "for", "idx", ",", "bbox", "in", "enumerate", "(", "boxes", ")", ":", "\n", "            ", "temp_bbox", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "bbox", ")", "//", "2", ")", ":", "\n", "                ", "point", "=", "[", "bbox", "[", "2", "*", "i", "]", ",", "bbox", "[", "2", "*", "i", "+", "1", "]", "]", "\n", "temp_bbox", ".", "append", "(", "\n", "RandomRotateImageBox", ".", "rotate_point", "(", "point", ",", "angle", ",", "center", ")", ")", "\n", "", "poly_temp_bbox", "=", "Polygon", "(", "temp_bbox", ")", ".", "buffer", "(", "0", ")", "\n", "if", "poly_temp_bbox", ".", "is_valid", ":", "\n", "                ", "if", "img_box", ".", "intersects", "(", "poly_temp_bbox", ")", "and", "(", "\n", "not", "img_box", ".", "touches", "(", "poly_temp_bbox", ")", ")", ":", "\n", "                    ", "temp_bbox_area", "=", "poly_temp_bbox", ".", "area", "\n", "\n", "intersect_area", "=", "img_box", ".", "intersection", "(", "poly_temp_bbox", ")", ".", "area", "\n", "intersect_ratio", "=", "intersect_area", "/", "temp_bbox_area", "\n", "\n", "if", "intersect_ratio", ">=", "0.7", ":", "\n", "                        ", "out_box", "=", "[", "]", "\n", "for", "p", "in", "temp_bbox", ":", "\n", "                            ", "out_box", ".", "extend", "(", "p", ")", "\n", "", "out_boxes", ".", "append", "(", "out_box", ")", "\n", "out_chars", ".", "append", "(", "chars", "[", "idx", "]", ")", "\n", "\n", "", "", "", "", "return", "out_boxes", ",", "out_chars", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.RandomRotateImageBox.rotate_point": [[405, 417], ["math.cos", "math.sin"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "rotate_point", "(", "point", ",", "angle", ",", "center", ")", ":", "\n", "        ", "cos_theta", "=", "math", ".", "cos", "(", "-", "angle", ")", "\n", "sin_theta", "=", "math", ".", "sin", "(", "-", "angle", ")", "\n", "c_x", "=", "center", "[", "0", "]", "\n", "c_y", "=", "center", "[", "1", "]", "\n", "new_x", "=", "(", "point", "[", "0", "]", "-", "c_x", ")", "*", "cos_theta", "-", "(", "point", "[", "1", "]", "-", "\n", "c_y", ")", "*", "sin_theta", "+", "c_x", "\n", "new_y", "=", "(", "point", "[", "0", "]", "-", "c_x", ")", "*", "sin_theta", "+", "(", "point", "[", "1", "]", "-", "\n", "c_y", ")", "*", "cos_theta", "+", "c_y", "\n", "\n", "return", "[", "new_x", ",", "new_y", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.OpencvToPil.__init__": [[423, 425], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.OpencvToPil.__call__": [[426, 432], ["PIL.Image.fromarray"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "img", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.OpencvToPil.__repr__": [[433, 436], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.PilToOpencv.__init__": [[442, 444], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.PilToOpencv.__call__": [[445, 451], ["numpy.asarray"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img", "=", "np", ".", "asarray", "(", "results", "[", "'img'", "]", ")", "\n", "img", "=", "img", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_transforms.PilToOpencv.__repr__": [[452, 455], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations.__init__": [[31, 46], ["mmdet.datasets.pipelines.loading.LoadAnnotations.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "with_bbox", "=", "True", ",", "\n", "with_label", "=", "True", ",", "\n", "with_mask", "=", "False", ",", "\n", "with_seg", "=", "False", ",", "\n", "poly2mask", "=", "True", ",", "\n", "use_img_shape", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "with_bbox", "=", "with_bbox", ",", "\n", "with_label", "=", "with_label", ",", "\n", "with_mask", "=", "with_mask", ",", "\n", "with_seg", "=", "with_seg", ",", "\n", "poly2mask", "=", "poly2mask", ")", "\n", "\n", "self", ".", "use_img_shape", "=", "use_img_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations.process_polygons": [[47, 63], ["numpy.array().astype", "valid_polygons.append", "numpy.array", "len", "len"], "methods", ["None"], ["", "def", "process_polygons", "(", "self", ",", "polygons", ")", ":", "\n", "        ", "\"\"\"Convert polygons to list of ndarray and filter invalid polygons.\n\n        Args:\n            polygons (list[list]): Polygons of one instance.\n\n        Returns:\n            list[numpy.ndarray]: Processed polygons.\n        \"\"\"", "\n", "\n", "polygons", "=", "[", "np", ".", "array", "(", "p", ")", ".", "astype", "(", "np", ".", "float32", ")", "for", "p", "in", "polygons", "]", "\n", "valid_polygons", "=", "[", "]", "\n", "for", "polygon", "in", "polygons", ":", "\n", "            ", "if", "len", "(", "polygon", ")", "%", "2", "==", "0", "and", "len", "(", "polygon", ")", ">=", "6", ":", "\n", "                ", "valid_polygons", ".", "append", "(", "polygon", ")", "\n", "", "", "return", "valid_polygons", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations._load_masks": [[64, 100], ["ann_info.get", "results[].append", "results.get", "mmdet.core.BitmapMasks", "mmdet.core.PolygonMasks", "results[].append", "warnings.warn", "mmdet.core.BitmapMasks", "mmdet.core.PolygonMasks", "loading.LoadTextAnnotations._poly2mask", "loading.LoadTextAnnotations.process_polygons", "loading.LoadTextAnnotations._poly2mask", "loading.LoadTextAnnotations.process_polygons"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations.process_polygons", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations.process_polygons"], ["", "def", "_load_masks", "(", "self", ",", "results", ")", ":", "\n", "        ", "ann_info", "=", "results", "[", "'ann_info'", "]", "\n", "h", ",", "w", "=", "results", "[", "'img_info'", "]", "[", "'height'", "]", ",", "results", "[", "'img_info'", "]", "[", "'width'", "]", "\n", "if", "self", ".", "use_img_shape", ":", "\n", "            ", "if", "results", ".", "get", "(", "'ori_shape'", ",", "None", ")", ":", "\n", "                ", "h", ",", "w", "=", "results", "[", "'ori_shape'", "]", "[", ":", "2", "]", "\n", "results", "[", "'img_info'", "]", "[", "'height'", "]", "=", "h", "\n", "results", "[", "'img_info'", "]", "[", "'width'", "]", "=", "w", "\n", "", "else", ":", "\n", "                ", "warnings", ".", "warn", "(", "'\"ori_shape\" not in results, use the shape '", "\n", "'in \"img_info\" instead.'", ")", "\n", "", "", "gt_masks", "=", "ann_info", "[", "'masks'", "]", "\n", "if", "self", ".", "poly2mask", ":", "\n", "            ", "gt_masks", "=", "BitmapMasks", "(", "\n", "[", "self", ".", "_poly2mask", "(", "mask", ",", "h", ",", "w", ")", "for", "mask", "in", "gt_masks", "]", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "gt_masks", "=", "PolygonMasks", "(", "\n", "[", "self", ".", "process_polygons", "(", "polygons", ")", "for", "polygons", "in", "gt_masks", "]", ",", "h", ",", "\n", "w", ")", "\n", "", "gt_masks_ignore", "=", "ann_info", ".", "get", "(", "'masks_ignore'", ",", "None", ")", "\n", "if", "gt_masks_ignore", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "poly2mask", ":", "\n", "                ", "gt_masks_ignore", "=", "BitmapMasks", "(", "\n", "[", "self", ".", "_poly2mask", "(", "mask", ",", "h", ",", "w", ")", "for", "mask", "in", "gt_masks_ignore", "]", ",", "\n", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "                ", "gt_masks_ignore", "=", "PolygonMasks", "(", "[", "\n", "self", ".", "process_polygons", "(", "polygons", ")", "\n", "for", "polygons", "in", "gt_masks_ignore", "\n", "]", ",", "h", ",", "w", ")", "\n", "", "results", "[", "'gt_masks_ignore'", "]", "=", "gt_masks_ignore", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "'gt_masks_ignore'", ")", "\n", "\n", "", "results", "[", "'gt_masks'", "]", "=", "gt_masks", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "'gt_masks'", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadImageFromNdarray.__call__": [[110, 137], ["mmcv.bgr2gray", "mmcv.gray2bgr", "img.astype.astype.astype"], "methods", ["None"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call functions to add image meta information.\n\n        Args:\n            results (dict): Result dict with Webcam read image in\n                ``results['img']``.\n\n        Returns:\n            dict: The dict contains loaded image and meta information.\n        \"\"\"", "\n", "assert", "results", "[", "'img'", "]", ".", "dtype", "==", "'uint8'", "\n", "\n", "img", "=", "results", "[", "'img'", "]", "\n", "if", "self", ".", "color_type", "==", "'grayscale'", "and", "img", ".", "shape", "[", "2", "]", "==", "3", ":", "\n", "            ", "img", "=", "mmcv", ".", "bgr2gray", "(", "img", ",", "keepdim", "=", "True", ")", "\n", "", "if", "self", ".", "color_type", "==", "'color'", "and", "img", ".", "shape", "[", "2", "]", "==", "1", ":", "\n", "            ", "img", "=", "mmcv", ".", "gray2bgr", "(", "img", ")", "\n", "", "if", "self", ".", "to_float32", ":", "\n", "            ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "results", "[", "'filename'", "]", "=", "None", "\n", "results", "[", "'ori_filename'", "]", "=", "None", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadImageFromLMDB.__init__": [[147, 151], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "color_type", "=", "'color'", ")", ":", "\n", "        ", "self", ".", "color_type", "=", "color_type", "\n", "self", ".", "env", "=", "None", "\n", "self", ".", "txn", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadImageFromLMDB.__call__": [[152, 182], ["lmdb.open", "loading.LoadImageFromLMDB.env.begin", "txn.get", "img_key.encode", "mmcv.imfrombytes", "print"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img_key", "=", "results", "[", "'img_info'", "]", "[", "'filename'", "]", "\n", "lmdb_path", "=", "results", "[", "'img_prefix'", "]", "\n", "\n", "# lmdb env", "\n", "if", "self", ".", "env", "is", "None", ":", "\n", "            ", "self", ".", "env", "=", "lmdb", ".", "open", "(", "\n", "lmdb_path", ",", "\n", "max_readers", "=", "1", ",", "\n", "readonly", "=", "True", ",", "\n", "lock", "=", "False", ",", "\n", "readahead", "=", "False", ",", "\n", "meminit", "=", "False", ",", "\n", ")", "\n", "# read image", "\n", "", "with", "self", ".", "env", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "imgbuf", "=", "txn", ".", "get", "(", "img_key", ".", "encode", "(", "'utf-8'", ")", ")", "\n", "try", ":", "\n", "                ", "img", "=", "mmcv", ".", "imfrombytes", "(", "imgbuf", ",", "flag", "=", "self", ".", "color_type", ")", "\n", "", "except", "IOError", ":", "\n", "                ", "print", "(", "'Corrupted image for {}'", ".", "format", "(", "img_key", ")", ")", "\n", "return", "None", "\n", "\n", "", "results", "[", "'filename'", "]", "=", "img_key", "\n", "results", "[", "'ori_filename'", "]", "=", "img_key", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'ori_shape'", "]", "=", "img", ".", "shape", "\n", "results", "[", "'img_fields'", "]", "=", "[", "'img'", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadImageFromLMDB.__repr__": [[183, 186], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'{} (color_type={})'", ".", "format", "(", "self", ".", "__class__", ".", "__name__", ",", "\n", "self", ".", "color_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadImageFromLMDB.__del__": [[187, 190], ["loading.LoadImageFromLMDB.env.close"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.close"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "env", "is", "not", "None", ":", "\n", "            ", "self", ".", "env", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.__init__": [[28, 47], ["isinstance", "isinstance", "mmocr.models.builder.build_convertor"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor"], ["def", "__init__", "(", "self", ",", "\n", "label_convertor", "=", "None", ",", "\n", "attn_shrink_ratio", "=", "0.5", ",", "\n", "seg_shrink_ratio", "=", "0.25", ",", "\n", "box_type", "=", "'char_rects'", ",", "\n", "pad_val", "=", "255", ")", ":", "\n", "\n", "        ", "assert", "isinstance", "(", "attn_shrink_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "seg_shrink_ratio", ",", "float", ")", "\n", "assert", "0.", "<", "attn_shrink_ratio", "<", "1.0", "\n", "assert", "0.", "<", "seg_shrink_ratio", "<", "1.0", "\n", "assert", "label_convertor", "is", "not", "None", "\n", "assert", "box_type", "in", "(", "'char_rects'", ",", "'char_quads'", ")", "\n", "\n", "self", ".", "attn_shrink_ratio", "=", "attn_shrink_ratio", "\n", "self", ".", "seg_shrink_ratio", "=", "seg_shrink_ratio", "\n", "self", ".", "label_convertor", "=", "build_convertor", "(", "label_convertor", ")", "\n", "self", ".", "box_type", "=", "box_type", "\n", "self", ".", "pad_val", "=", "pad_val", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.shrink_char_quad": [[48, 88], ["enumerate", "numpy.array", "ocr_seg_targets.OCRSegTargets.l2_dist_two_points", "ocr_seg_targets.OCRSegTargets.l2_dist_two_points", "min", "shrink_points.append", "round", "round"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.l2_dist_two_points", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.l2_dist_two_points"], ["", "def", "shrink_char_quad", "(", "self", ",", "char_quad", ",", "shrink_ratio", ")", ":", "\n", "        ", "\"\"\"Shrink char box in style of quadrangle.\n\n        Args:\n            char_quad (list[float]): Char box with format\n                [x1, y1, x2, y2, x3, y3, x4, y4].\n            shrink_ratio (float): The area shrunk ratio\n                between gt kernels and gt text masks.\n        \"\"\"", "\n", "points", "=", "[", "[", "char_quad", "[", "0", "]", ",", "char_quad", "[", "1", "]", "]", ",", "[", "char_quad", "[", "2", "]", ",", "char_quad", "[", "3", "]", "]", ",", "\n", "[", "char_quad", "[", "4", "]", ",", "char_quad", "[", "5", "]", "]", ",", "[", "char_quad", "[", "6", "]", ",", "char_quad", "[", "7", "]", "]", "]", "\n", "shrink_points", "=", "[", "]", "\n", "for", "p_idx", ",", "point", "in", "enumerate", "(", "points", ")", ":", "\n", "            ", "p1", "=", "points", "[", "(", "p_idx", "+", "3", ")", "%", "4", "]", "\n", "p2", "=", "points", "[", "(", "p_idx", "+", "1", ")", "%", "4", "]", "\n", "\n", "dist1", "=", "self", ".", "l2_dist_two_points", "(", "p1", ",", "point", ")", "\n", "dist2", "=", "self", ".", "l2_dist_two_points", "(", "p2", ",", "point", ")", "\n", "min_dist", "=", "min", "(", "dist1", ",", "dist2", ")", "\n", "\n", "v1", "=", "[", "p1", "[", "0", "]", "-", "point", "[", "0", "]", ",", "p1", "[", "1", "]", "-", "point", "[", "1", "]", "]", "\n", "v2", "=", "[", "p2", "[", "0", "]", "-", "point", "[", "0", "]", ",", "p2", "[", "1", "]", "-", "point", "[", "1", "]", "]", "\n", "\n", "temp_dist1", "=", "(", "shrink_ratio", "*", "min_dist", "/", "\n", "dist1", ")", "if", "min_dist", "!=", "0", "else", "0.", "\n", "temp_dist2", "=", "(", "shrink_ratio", "*", "min_dist", "/", "\n", "dist2", ")", "if", "min_dist", "!=", "0", "else", "0.", "\n", "\n", "v1", "=", "[", "temp", "*", "temp_dist1", "for", "temp", "in", "v1", "]", "\n", "v2", "=", "[", "temp", "*", "temp_dist2", "for", "temp", "in", "v2", "]", "\n", "\n", "shrink_point", "=", "[", "\n", "round", "(", "point", "[", "0", "]", "+", "v1", "[", "0", "]", "+", "v2", "[", "0", "]", ")", ",", "\n", "round", "(", "point", "[", "1", "]", "+", "v1", "[", "1", "]", "+", "v2", "[", "1", "]", ")", "\n", "]", "\n", "shrink_points", ".", "append", "(", "shrink_point", ")", "\n", "\n", "", "poly", "=", "np", ".", "array", "(", "shrink_points", ")", "\n", "\n", "return", "poly", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.shrink_char_rect": [[89, 109], ["round", "round", "round", "round", "numpy.array"], "methods", ["None"], ["", "def", "shrink_char_rect", "(", "self", ",", "char_rect", ",", "shrink_ratio", ")", ":", "\n", "        ", "\"\"\"Shrink char box in style of rectangle.\n\n        Args:\n            char_rect (list[float]): Char box with format\n                [x_min, y_min, x_max, y_max].\n            shrink_ratio (float): The area shrunk ratio\n                between gt kernels and gt text masks.\n        \"\"\"", "\n", "x_min", ",", "y_min", ",", "x_max", ",", "y_max", "=", "char_rect", "\n", "w", "=", "x_max", "-", "x_min", "\n", "h", "=", "y_max", "-", "y_min", "\n", "x_min_s", "=", "round", "(", "(", "x_min", "+", "x_max", "-", "w", "*", "shrink_ratio", ")", "/", "2", ")", "\n", "y_min_s", "=", "round", "(", "(", "y_min", "+", "y_max", "-", "h", "*", "shrink_ratio", ")", "/", "2", ")", "\n", "x_max_s", "=", "round", "(", "(", "x_min", "+", "x_max", "+", "w", "*", "shrink_ratio", ")", "/", "2", ")", "\n", "y_max_s", "=", "round", "(", "(", "y_min", "+", "y_max", "+", "h", "*", "shrink_ratio", ")", "/", "2", ")", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "x_min_s", ",", "y_min_s", "]", ",", "[", "x_max_s", ",", "y_min_s", "]", ",", "\n", "[", "x_max_s", ",", "y_max_s", "]", ",", "[", "x_min_s", ",", "y_max_s", "]", "]", ")", "\n", "\n", "return", "poly", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.generate_kernels": [[110, 153], ["isinstance", "isinstance", "mmocr.is_2dlist", "mmocr.is_type_list", "isinstance", "isinstance", "numpy.zeros", "enumerate", "cv2.fillConvexPoly", "ocr_seg_targets.OCRSegTargets.shrink_char_rect", "ocr_seg_targets.OCRSegTargets.astype", "ocr_seg_targets.OCRSegTargets.shrink_char_quad"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.shrink_char_rect", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.shrink_char_quad"], ["", "def", "generate_kernels", "(", "self", ",", "\n", "resize_shape", ",", "\n", "pad_shape", ",", "\n", "char_boxes", ",", "\n", "char_inds", ",", "\n", "shrink_ratio", "=", "0.5", ",", "\n", "binary", "=", "True", ")", ":", "\n", "        ", "\"\"\"Generate char instance kernels for one shrink ratio.\n\n        Args:\n            resize_shape (tuple(int, int)): Image size (height, width)\n                after resizing.\n            pad_shape (tuple(int, int)):  Image size (height, width)\n                after padding.\n            char_boxes (list[list[float]]): The list of char polygons.\n            char_inds (list[int]): List of char indexes.\n            shrink_ratio (float): The shrink ratio of kernel.\n            binary (bool): If True, return binary ndarray\n                containing 0 & 1 only.\n        Returns:\n            char_kernel (ndarray): The text kernel mask of (height, width).\n        \"\"\"", "\n", "assert", "isinstance", "(", "resize_shape", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "pad_shape", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "char_boxes", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "char_inds", ",", "int", ")", "\n", "assert", "isinstance", "(", "shrink_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "binary", ",", "bool", ")", "\n", "\n", "char_kernel", "=", "np", ".", "zeros", "(", "pad_shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "char_kernel", "[", ":", "resize_shape", "[", "0", "]", ",", "resize_shape", "[", "1", "]", ":", "]", "=", "self", ".", "pad_val", "\n", "\n", "for", "i", ",", "char_box", "in", "enumerate", "(", "char_boxes", ")", ":", "\n", "            ", "if", "self", ".", "box_type", "==", "'char_rects'", ":", "\n", "                ", "poly", "=", "self", ".", "shrink_char_rect", "(", "char_box", ",", "shrink_ratio", ")", "\n", "", "elif", "self", ".", "box_type", "==", "'char_quads'", ":", "\n", "                ", "poly", "=", "self", ".", "shrink_char_quad", "(", "char_box", ",", "shrink_ratio", ")", "\n", "\n", "", "fill_value", "=", "1", "if", "binary", "else", "char_inds", "[", "i", "]", "\n", "cv2", ".", "fillConvexPoly", "(", "char_kernel", ",", "poly", ".", "astype", "(", "np", ".", "int32", ")", ",", "\n", "(", "fill_value", ")", ")", "\n", "\n", "", "return", "char_kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.l2_dist_two_points": [[154, 156], ["None"], "methods", ["None"], ["", "def", "l2_dist_two_points", "(", "self", ",", "p1", ",", "p2", ")", ":", "\n", "        ", "return", "(", "(", "p1", "[", "0", "]", "-", "p2", "[", "0", "]", ")", "**", "2", "+", "(", "p1", "[", "1", "]", "-", "p2", "[", "1", "]", ")", "**", "2", ")", "**", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.ocr_seg_targets.OCRSegTargets.__call__": [[157, 203], ["len", "range", "tuple", "tuple", "ocr_seg_targets.OCRSegTargets.generate_kernels", "ocr_seg_targets.OCRSegTargets.generate_kernels", "numpy.ones", "mmdet.core.BitmapMasks", "range", "char_boxes.append", "char_inds.append", "round", "round", "ocr_seg_targets.OCRSegTargets.label_convertor.str2idx"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "img_shape", "=", "results", "[", "'img_shape'", "]", "\n", "resize_shape", "=", "results", "[", "'resize_shape'", "]", "\n", "\n", "h_scale", "=", "1.0", "*", "resize_shape", "[", "0", "]", "/", "img_shape", "[", "0", "]", "\n", "w_scale", "=", "1.0", "*", "resize_shape", "[", "1", "]", "/", "img_shape", "[", "1", "]", "\n", "\n", "char_boxes", ",", "char_inds", "=", "[", "]", ",", "[", "]", "\n", "char_num", "=", "len", "(", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", ")", "\n", "for", "i", "in", "range", "(", "char_num", ")", ":", "\n", "            ", "char_box", "=", "results", "[", "'ann_info'", "]", "[", "self", ".", "box_type", "]", "[", "i", "]", "\n", "num_points", "=", "2", "if", "self", ".", "box_type", "==", "'char_rects'", "else", "4", "\n", "for", "j", "in", "range", "(", "num_points", ")", ":", "\n", "                ", "char_box", "[", "j", "*", "2", "]", "=", "round", "(", "char_box", "[", "j", "*", "2", "]", "*", "w_scale", ")", "\n", "char_box", "[", "j", "*", "2", "+", "1", "]", "=", "round", "(", "char_box", "[", "j", "*", "2", "+", "1", "]", "*", "h_scale", ")", "\n", "", "char_boxes", ".", "append", "(", "char_box", ")", "\n", "char", "=", "results", "[", "'ann_info'", "]", "[", "'chars'", "]", "[", "i", "]", "\n", "char_ind", "=", "self", ".", "label_convertor", ".", "str2idx", "(", "[", "char", "]", ")", "[", "0", "]", "[", "0", "]", "\n", "char_inds", ".", "append", "(", "char_ind", ")", "\n", "\n", "", "resize_shape", "=", "tuple", "(", "results", "[", "'resize_shape'", "]", "[", ":", "2", "]", ")", "\n", "pad_shape", "=", "tuple", "(", "results", "[", "'pad_shape'", "]", "[", ":", "2", "]", ")", "\n", "binary_target", "=", "self", ".", "generate_kernels", "(", "\n", "resize_shape", ",", "\n", "pad_shape", ",", "\n", "char_boxes", ",", "\n", "char_inds", ",", "\n", "shrink_ratio", "=", "self", ".", "attn_shrink_ratio", ",", "\n", "binary", "=", "True", ")", "\n", "\n", "seg_target", "=", "self", ".", "generate_kernels", "(", "\n", "resize_shape", ",", "\n", "pad_shape", ",", "\n", "char_boxes", ",", "\n", "char_inds", ",", "\n", "shrink_ratio", "=", "self", ".", "seg_shrink_ratio", ",", "\n", "binary", "=", "False", ")", "\n", "\n", "mask", "=", "np", ".", "ones", "(", "pad_shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "mask", "[", ":", "resize_shape", "[", "0", "]", ",", "resize_shape", "[", "1", "]", ":", "]", "=", "0", "\n", "\n", "results", "[", "'gt_kernels'", "]", "=", "BitmapMasks", "(", "[", "binary_target", ",", "seg_target", ",", "mask", "]", ",", "\n", "pad_shape", "[", "0", "]", ",", "pad_shape", "[", "1", "]", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_kernels'", "]", "\n", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.kie_transforms.ResizeNoImg.__init__": [[16, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "img_scale", ",", "keep_ratio", "=", "True", ")", ":", "\n", "        ", "self", ".", "img_scale", "=", "img_scale", "\n", "self", ".", "keep_ratio", "=", "keep_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.kie_transforms.ResizeNoImg.__call__": [[20, 40], ["numpy.array", "mmcv.rescale_size"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "w", ",", "h", "=", "results", "[", "'img_info'", "]", "[", "'width'", "]", ",", "results", "[", "'img_info'", "]", "[", "'height'", "]", "\n", "if", "self", ".", "keep_ratio", ":", "\n", "            ", "(", "new_w", ",", "new_h", ")", "=", "rescale_size", "(", "(", "w", ",", "h", ")", ",", "\n", "self", ".", "img_scale", ",", "\n", "return_scale", "=", "False", ")", "\n", "w_scale", "=", "new_w", "/", "w", "\n", "h_scale", "=", "new_h", "/", "h", "\n", "", "else", ":", "\n", "            ", "(", "new_w", ",", "new_h", ")", "=", "self", ".", "img_scale", "\n", "\n", "", "w_scale", "=", "new_w", "/", "w", "\n", "h_scale", "=", "new_h", "/", "h", "\n", "scale_factor", "=", "np", ".", "array", "(", "[", "w_scale", ",", "h_scale", ",", "w_scale", ",", "h_scale", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "results", "[", "'img_shape'", "]", "=", "(", "new_h", ",", "new_w", ",", "1", ")", "\n", "results", "[", "'scale_factor'", "]", "=", "scale_factor", "\n", "results", "[", "'keep_ratio'", "]", "=", "True", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.kie_transforms.KIEFormatBundle.__call__": [[63, 88], ["super().__call__", "mmcv.parallel.DataContainer", "isinstance", "numpy.array().astype", "mmdet.datasets.pipelines.formatting.to_tensor", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.textsnake_postprocessor.TextSnakePostprocessor.__call__"], ["def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Call function to transform and format common fields in results.\n\n        Args:\n            results (dict): Result dict contains the data to convert.\n\n        Returns:\n            dict: The result dict contains the data that is formatted with\n                default bundle.\n        \"\"\"", "\n", "super", "(", ")", ".", "__call__", "(", "results", ")", "\n", "if", "'ann_info'", "in", "results", ":", "\n", "            ", "for", "key", "in", "[", "'relations'", ",", "'texts'", "]", ":", "\n", "                ", "value", "=", "results", "[", "'ann_info'", "]", "[", "key", "]", "\n", "if", "key", "==", "'relations'", "and", "'scale_factor'", "in", "results", ":", "\n", "                    ", "scale_factor", "=", "results", "[", "'scale_factor'", "]", "\n", "if", "isinstance", "(", "scale_factor", ",", "float", ")", ":", "\n", "                        ", "sx", "=", "sy", "=", "scale_factor", "\n", "", "else", ":", "\n", "                        ", "sx", ",", "sy", "=", "results", "[", "'scale_factor'", "]", "[", ":", "2", "]", "\n", "", "r", "=", "sx", "/", "sy", "\n", "factor", "=", "np", ".", "array", "(", "[", "sx", ",", "sy", ",", "r", ",", "1", ",", "r", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "value", "=", "value", "*", "factor", "[", "None", ",", "None", "]", "\n", "", "results", "[", "key", "]", "=", "DC", "(", "to_tensor", "(", "value", ")", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.kie_transforms.KIEFormatBundle.__repr__": [[89, 91], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.OneOfWrapper.__init__": [[28, 39], ["isinstance", "isinstance", "len", "isinstance", "transform_wrappers.OneOfWrapper.transforms.append", "callable", "mmcv.utils.build_from_cfg", "transform_wrappers.OneOfWrapper.transforms.append", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "assert", "isinstance", "(", "transforms", ",", "list", ")", "or", "isinstance", "(", "transforms", ",", "tuple", ")", "\n", "assert", "len", "(", "transforms", ")", ">", "0", ",", "'Need at least one transform.'", "\n", "self", ".", "transforms", "=", "[", "]", "\n", "for", "t", "in", "transforms", ":", "\n", "            ", "if", "isinstance", "(", "t", ",", "dict", ")", ":", "\n", "                ", "self", ".", "transforms", ".", "append", "(", "build_from_cfg", "(", "t", ",", "PIPELINES", ")", ")", "\n", "", "elif", "callable", "(", "t", ")", ":", "\n", "                ", "self", ".", "transforms", ".", "append", "(", "t", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "'transform must be callable or a dict'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.OneOfWrapper.__call__": [[40, 42], ["random.choice"], "methods", ["None"], ["", "", "", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "return", "random", ".", "choice", "(", "self", ".", "transforms", ")", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.OneOfWrapper.__repr__": [[43, 47], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(transforms={self.transforms})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.RandomWrapper.__init__": [[58, 62], ["mmdet.datasets.pipelines.Compose"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ",", "p", ")", ":", "\n", "        ", "assert", "0", "<=", "p", "<=", "1", "\n", "self", ".", "transforms", "=", "Compose", "(", "transforms", ")", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.RandomWrapper.__call__": [[63, 66], ["transform_wrappers.RandomWrapper.transforms", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "return", "results", "if", "np", ".", "random", ".", "uniform", "(", ")", ">", "self", ".", "p", "else", "self", ".", "transforms", "(", "\n", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.RandomWrapper.__repr__": [[67, 72], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(transforms={self.transforms}, '", "\n", "repr_str", "+=", "f'p={self.p})'", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.TorchVisionWrapper.__init__": [[100, 112], ["mmcv.is_str", "getattr.", "type", "getattr", "inspect.isclass", "TypeError", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "op", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "type", "(", "op", ")", "is", "str", "\n", "\n", "if", "mmcv", ".", "is_str", "(", "op", ")", ":", "\n", "            ", "obj_cls", "=", "getattr", "(", "torchvision_transforms", ",", "op", ")", "\n", "", "elif", "inspect", ".", "isclass", "(", "op", ")", ":", "\n", "            ", "obj_cls", "=", "op", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f'type must be a str or valid type, but got {type(type)}'", ")", "\n", "", "self", ".", "transform", "=", "obj_cls", "(", "**", "kwargs", ")", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.TorchVisionWrapper.__call__": [[113, 124], ["PIL.Image.fromarray", "transform_wrappers.TorchVisionWrapper.transform", "numpy.asarray"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "assert", "'img'", "in", "results", "\n", "# BGR -> RGB", "\n", "img", "=", "results", "[", "'img'", "]", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "img", "=", "Image", ".", "fromarray", "(", "img", ")", "\n", "img", "=", "self", ".", "transform", "(", "img", ")", "\n", "img", "=", "np", ".", "asarray", "(", "img", ")", "\n", "img", "=", "img", "[", "...", ",", ":", ":", "-", "1", "]", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'img_shape'", "]", "=", "img", ".", "shape", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transform_wrappers.TorchVisionWrapper.__repr__": [[125, 129], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "repr_str", "+=", "f'(transform={self.transform})'", "\n", "return", "repr_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.__init__": [[13, 15], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build": [[16, 41], ["isinstance", "isinstance", "isinstance", "RuntimeError", "imgaug.Sequential", "imgaug.Sequential", "dbnet_transforms.AugmenterBuilder.to_tuple_if_list", "getattr", "getattr", "getattr.", "str", "dbnet_transforms.AugmenterBuilder.build", "dbnet_transforms.AugmenterBuilder.build", "args.items", "dbnet_transforms.AugmenterBuilder.to_tuple_if_list", "args.items"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.to_tuple_if_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.to_tuple_if_list"], ["", "def", "build", "(", "self", ",", "args", ",", "root", "=", "True", ")", ":", "\n", "        ", "if", "args", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "if", "isinstance", "(", "args", ",", "(", "int", ",", "float", ",", "str", ")", ")", ":", "\n", "            ", "return", "args", "\n", "", "if", "isinstance", "(", "args", ",", "list", ")", ":", "\n", "            ", "if", "root", ":", "\n", "                ", "sequence", "=", "[", "self", ".", "build", "(", "value", ",", "root", "=", "False", ")", "for", "value", "in", "args", "]", "\n", "return", "iaa", ".", "Sequential", "(", "sequence", ")", "\n", "", "arg_list", "=", "[", "self", ".", "to_tuple_if_list", "(", "a", ")", "for", "a", "in", "args", "[", "1", ":", "]", "]", "\n", "return", "getattr", "(", "iaa", ",", "args", "[", "0", "]", ")", "(", "*", "arg_list", ")", "\n", "", "if", "isinstance", "(", "args", ",", "dict", ")", ":", "\n", "            ", "if", "'cls'", "in", "args", ":", "\n", "                ", "cls", "=", "getattr", "(", "iaa", ",", "args", "[", "'cls'", "]", ")", "\n", "return", "cls", "(", "\n", "**", "{", "\n", "k", ":", "self", ".", "to_tuple_if_list", "(", "v", ")", "\n", "for", "k", ",", "v", "in", "args", ".", "items", "(", ")", "if", "not", "k", "==", "'cls'", "\n", "}", ")", "\n", "", "else", ":", "\n", "                ", "return", "{", "\n", "key", ":", "self", ".", "build", "(", "value", ",", "root", "=", "False", ")", "\n", "for", "key", ",", "value", "in", "args", ".", "items", "(", ")", "\n", "}", "\n", "", "", "raise", "RuntimeError", "(", "'unknown augmenter arg: '", "+", "str", "(", "args", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.to_tuple_if_list": [[42, 46], ["isinstance", "tuple"], "methods", ["None"], ["", "def", "to_tuple_if_list", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "list", ")", ":", "\n", "            ", "return", "tuple", "(", "obj", ")", "\n", "", "return", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.__init__": [[64, 68], ["dbnet_transforms.AugmenterBuilder.build", "dbnet_transforms.AugmenterBuilder"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], ["def", "__init__", "(", "self", ",", "args", "=", "None", ",", "clip_invalid_ploys", "=", "True", ")", ":", "\n", "        ", "self", ".", "augmenter_args", "=", "args", "\n", "self", ".", "augmenter", "=", "AugmenterBuilder", "(", ")", ".", "build", "(", "self", ".", "augmenter_args", ")", "\n", "self", ".", "clip_invalid_polys", "=", "clip_invalid_ploys", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.__call__": [[69, 86], ["dbnet_transforms.ImgAug.augmenter.to_deterministic", "dbnet_transforms.ImgAug.augment_image", "dbnet_transforms.ImgAug.may_augment_annotation"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_annotation"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "# img is bgr", "\n", "        ", "image", "=", "results", "[", "'img'", "]", "\n", "aug", "=", "None", "\n", "shape", "=", "image", ".", "shape", "\n", "\n", "if", "self", ".", "augmenter", ":", "\n", "            ", "aug", "=", "self", ".", "augmenter", ".", "to_deterministic", "(", ")", "\n", "results", "[", "'img'", "]", "=", "aug", ".", "augment_image", "(", "image", ")", "\n", "results", "[", "'img_shape'", "]", "=", "results", "[", "'img'", "]", ".", "shape", "\n", "results", "[", "'flip'", "]", "=", "'unknown'", "# it's unknown", "\n", "results", "[", "'flip_direction'", "]", "=", "'unknown'", "# it's unknown", "\n", "target_shape", "=", "results", "[", "'img_shape'", "]", "\n", "\n", "self", ".", "may_augment_annotation", "(", "aug", ",", "shape", ",", "target_shape", ",", "results", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_annotation": [[87, 109], ["dbnet_transforms.ImgAug.may_augment_bbox", "numpy.zeros", "dbnet_transforms.ImgAug.may_augment_poly", "mmdet.core.mask.PolygonMasks", "dbnet_transforms.ImgAug.may_augment_poly_legacy", "len", "numpy.stack", "len", "mmdet.core.mask.PolygonMasks"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_bbox", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_poly", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_poly_legacy"], ["", "def", "may_augment_annotation", "(", "self", ",", "aug", ",", "shape", ",", "target_shape", ",", "results", ")", ":", "\n", "        ", "if", "aug", "is", "None", ":", "\n", "            ", "return", "results", "\n", "\n", "# augment polygon mask", "\n", "", "for", "key", "in", "results", "[", "'mask_fields'", "]", ":", "\n", "            ", "if", "self", ".", "clip_invalid_polys", ":", "\n", "                ", "masks", "=", "self", ".", "may_augment_poly", "(", "aug", ",", "shape", ",", "results", "[", "key", "]", ")", "\n", "results", "[", "key", "]", "=", "PolygonMasks", "(", "masks", ",", "*", "target_shape", "[", ":", "2", "]", ")", "\n", "", "else", ":", "\n", "                ", "masks", "=", "self", ".", "may_augment_poly_legacy", "(", "aug", ",", "shape", ",", "results", "[", "key", "]", ")", "\n", "if", "len", "(", "masks", ")", ">", "0", ":", "\n", "                    ", "results", "[", "key", "]", "=", "PolygonMasks", "(", "masks", ",", "*", "target_shape", "[", ":", "2", "]", ")", "\n", "\n", "# augment bbox", "\n", "", "", "", "for", "key", "in", "results", "[", "'bbox_fields'", "]", ":", "\n", "            ", "bboxes", "=", "self", ".", "may_augment_bbox", "(", "aug", ",", "shape", ",", "results", "[", "key", "]", ")", "\n", "results", "[", "key", "]", "=", "np", ".", "zeros", "(", "0", ")", "\n", "if", "len", "(", "bboxes", ")", ">", "0", ":", "\n", "                ", "results", "[", "key", "]", "=", "np", ".", "stack", "(", "bboxes", ")", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_bbox": [[110, 126], ["[].clip_out_of_image", "[].clip_out_of_image.append", "new_bboxes.append", "imgaug.BoundingBox", "imgaug.BoundingBox", "imgaug.BoundingBox", "imgaug.BoundingBox", "numpy.array", "aug.augment_bounding_boxes", "imgaug.BoundingBoxesOnImage", "imgaug.BoundingBoxesOnImage", "imgaug.BoundingBoxesOnImage", "imgaug.BoundingBoxesOnImage"], "methods", ["None"], ["", "def", "may_augment_bbox", "(", "self", ",", "aug", ",", "ori_shape", ",", "bboxes", ")", ":", "\n", "        ", "imgaug_bboxes", "=", "[", "]", "\n", "for", "bbox", "in", "bboxes", ":", "\n", "            ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "bbox", "\n", "imgaug_bboxes", ".", "append", "(", "\n", "imgaug", ".", "BoundingBox", "(", "x1", "=", "x1", ",", "y1", "=", "y1", ",", "x2", "=", "x2", ",", "y2", "=", "y2", ")", ")", "\n", "", "imgaug_bboxes", "=", "aug", ".", "augment_bounding_boxes", "(", "[", "\n", "imgaug", ".", "BoundingBoxesOnImage", "(", "imgaug_bboxes", ",", "shape", "=", "ori_shape", ")", "\n", "]", ")", "[", "0", "]", ".", "clip_out_of_image", "(", ")", "\n", "\n", "new_bboxes", "=", "[", "]", "\n", "for", "box", "in", "imgaug_bboxes", ".", "bounding_boxes", ":", "\n", "            ", "new_bboxes", ".", "append", "(", "\n", "np", ".", "array", "(", "[", "box", ".", "x1", ",", "box", ".", "y1", ",", "box", ".", "x2", ",", "box", ".", "y2", "]", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "\n", "", "return", "new_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_poly": [[127, 146], ["[].clip_out_of_image", "poly.reshape.reshape.reshape", "[].clip_out_of_image.append", "numpy.array().flatten", "new_polys.append", "imgaug.Polygon", "imgaug.Polygon", "imgaug.Polygon", "imgaug.Polygon", "numpy.array().flatten.append", "aug.augment_polygons", "numpy.array", "numpy.array", "imgaug.PolygonsOnImage", "imgaug.PolygonsOnImage", "imgaug.PolygonsOnImage", "imgaug.PolygonsOnImage"], "methods", ["None"], ["", "def", "may_augment_poly", "(", "self", ",", "aug", ",", "img_shape", ",", "polys", ")", ":", "\n", "        ", "imgaug_polys", "=", "[", "]", "\n", "for", "poly", "in", "polys", ":", "\n", "            ", "poly", "=", "poly", "[", "0", "]", "\n", "poly", "=", "poly", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "imgaug_polys", ".", "append", "(", "imgaug", ".", "Polygon", "(", "poly", ")", ")", "\n", "", "imgaug_polys", "=", "aug", ".", "augment_polygons", "(", "\n", "[", "imgaug", ".", "PolygonsOnImage", "(", "imgaug_polys", ",", "\n", "shape", "=", "img_shape", ")", "]", ")", "[", "0", "]", ".", "clip_out_of_image", "(", ")", "\n", "\n", "new_polys", "=", "[", "]", "\n", "for", "poly", "in", "imgaug_polys", ".", "polygons", ":", "\n", "            ", "new_poly", "=", "[", "]", "\n", "for", "point", "in", "poly", ":", "\n", "                ", "new_poly", ".", "append", "(", "np", ".", "array", "(", "point", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "", "new_poly", "=", "np", ".", "array", "(", "new_poly", ",", "dtype", "=", "np", ".", "float32", ")", ".", "flatten", "(", ")", "\n", "new_polys", ".", "append", "(", "[", "new_poly", "]", ")", "\n", "\n", "", "return", "new_polys", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.may_augment_poly_legacy": [[147, 171], ["poly.reshape.reshape.reshape", "key_points.extend", "poly_point_nums.append", "numpy.array().flatten", "new_polys.append", "aug.augment_keypoints", "numpy.array().flatten.append", "imgaug.Keypoint", "imgaug.Keypoint", "imgaug.Keypoint", "imgaug.Keypoint", "numpy.array", "imgaug.KeypointsOnImage", "imgaug.KeypointsOnImage", "imgaug.KeypointsOnImage", "imgaug.KeypointsOnImage"], "methods", ["None"], ["", "def", "may_augment_poly_legacy", "(", "self", ",", "aug", ",", "img_shape", ",", "polys", ")", ":", "\n", "        ", "key_points", ",", "poly_point_nums", "=", "[", "]", ",", "[", "]", "\n", "for", "poly", "in", "polys", ":", "\n", "            ", "poly", "=", "poly", "[", "0", "]", "\n", "poly", "=", "poly", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "key_points", ".", "extend", "(", "[", "imgaug", ".", "Keypoint", "(", "p", "[", "0", "]", ",", "p", "[", "1", "]", ")", "for", "p", "in", "poly", "]", ")", "\n", "poly_point_nums", ".", "append", "(", "poly", ".", "shape", "[", "0", "]", ")", "\n", "# Warning: we do not clip the out-of-boudnary polygons", "\n", "", "key_points", "=", "aug", ".", "augment_keypoints", "(", "\n", "[", "imgaug", ".", "KeypointsOnImage", "(", "keypoints", "=", "key_points", ",", "\n", "shape", "=", "img_shape", ")", "]", ")", "[", "0", "]", ".", "keypoints", "\n", "\n", "new_polys", "=", "[", "]", "\n", "start_idx", "=", "0", "\n", "for", "poly_point_num", "in", "poly_point_nums", ":", "\n", "            ", "new_poly", "=", "[", "]", "\n", "for", "key_point", "in", "key_points", "[", "start_idx", ":", "(", "start_idx", "+", "\n", "poly_point_num", ")", "]", ":", "\n", "                ", "new_poly", ".", "append", "(", "[", "key_point", ".", "x", ",", "key_point", ".", "y", "]", ")", "\n", "", "start_idx", "+=", "poly_point_num", "\n", "new_poly", "=", "np", ".", "array", "(", "new_poly", ")", ".", "flatten", "(", ")", "\n", "new_polys", ".", "append", "(", "[", "new_poly", "]", ")", "\n", "\n", "", "return", "new_polys", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.ImgAug.__repr__": [[172, 175], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "repr_str", "=", "self", ".", "__class__", ".", "__name__", "\n", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.__init__": [[180, 187], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "target_size", "=", "(", "640", ",", "640", ")", ",", "\n", "max_tries", "=", "10", ",", "\n", "min_crop_side_ratio", "=", "0.1", ")", ":", "\n", "        ", "self", ".", "target_size", "=", "target_size", "\n", "self", ".", "max_tries", "=", "max_tries", "\n", "self", ".", "min_crop_side_ratio", "=", "min_crop_side_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.__call__": [[188, 232], ["dbnet_transforms.EastRandomCrop.crop_area", "min", "int", "int", "numpy.zeros", "mmcv.imresize", "numpy.array", "mmdet.core.mask.PolygonMasks", "box.reshape.reshape.reshape", "numpy.array().reshape", "dbnet_transforms.EastRandomCrop.is_poly_outside_rect", "lines.append", "dbnet_transforms.EastRandomCrop.is_poly_outside_rect", "polys.append", "polys_label.append", "numpy.array().reshape.flatten", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.crop_area", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.is_poly_outside_rect", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.is_poly_outside_rect"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "# sampling crop", "\n", "# crop image, boxes, masks", "\n", "        ", "img", "=", "results", "[", "'img'", "]", "\n", "crop_x", ",", "crop_y", ",", "crop_w", ",", "crop_h", "=", "self", ".", "crop_area", "(", "\n", "img", ",", "results", "[", "'gt_masks'", "]", ")", "\n", "scale_w", "=", "self", ".", "target_size", "[", "0", "]", "/", "crop_w", "\n", "scale_h", "=", "self", ".", "target_size", "[", "1", "]", "/", "crop_h", "\n", "scale", "=", "min", "(", "scale_w", ",", "scale_h", ")", "\n", "h", "=", "int", "(", "crop_h", "*", "scale", ")", "\n", "w", "=", "int", "(", "crop_w", "*", "scale", ")", "\n", "padded_img", "=", "np", ".", "zeros", "(", "\n", "(", "self", ".", "target_size", "[", "1", "]", ",", "self", ".", "target_size", "[", "0", "]", ",", "img", ".", "shape", "[", "2", "]", ")", ",", "\n", "img", ".", "dtype", ")", "\n", "padded_img", "[", ":", "h", ",", ":", "w", "]", "=", "mmcv", ".", "imresize", "(", "\n", "img", "[", "crop_y", ":", "crop_y", "+", "crop_h", ",", "crop_x", ":", "crop_x", "+", "crop_w", "]", ",", "(", "w", ",", "h", ")", ")", "\n", "\n", "# for bboxes", "\n", "for", "key", "in", "results", "[", "'bbox_fields'", "]", ":", "\n", "            ", "lines", "=", "[", "]", "\n", "for", "box", "in", "results", "[", "key", "]", ":", "\n", "                ", "box", "=", "box", ".", "reshape", "(", "2", ",", "2", ")", "\n", "poly", "=", "(", "(", "box", "-", "(", "crop_x", ",", "crop_y", ")", ")", "*", "scale", ")", "\n", "if", "not", "self", ".", "is_poly_outside_rect", "(", "poly", ",", "0", ",", "0", ",", "w", ",", "h", ")", ":", "\n", "                    ", "lines", ".", "append", "(", "poly", ".", "flatten", "(", ")", ")", "\n", "", "", "results", "[", "key", "]", "=", "np", ".", "array", "(", "lines", ")", "\n", "# for masks", "\n", "", "for", "key", "in", "results", "[", "'mask_fields'", "]", ":", "\n", "            ", "polys", "=", "[", "]", "\n", "polys_label", "=", "[", "]", "\n", "for", "poly", "in", "results", "[", "key", "]", ":", "\n", "                ", "poly", "=", "np", ".", "array", "(", "poly", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "poly", "=", "(", "(", "poly", "-", "(", "crop_x", ",", "crop_y", ")", ")", "*", "scale", ")", "\n", "if", "not", "self", ".", "is_poly_outside_rect", "(", "poly", ",", "0", ",", "0", ",", "w", ",", "h", ")", ":", "\n", "                    ", "polys", ".", "append", "(", "[", "poly", "]", ")", "\n", "polys_label", ".", "append", "(", "0", ")", "\n", "", "", "results", "[", "key", "]", "=", "PolygonMasks", "(", "polys", ",", "*", "self", ".", "target_size", ")", "\n", "if", "key", "==", "'gt_masks'", ":", "\n", "                ", "results", "[", "'gt_labels'", "]", "=", "polys_label", "\n", "\n", "", "", "results", "[", "'img'", "]", "=", "padded_img", "\n", "results", "[", "'img_shape'", "]", "=", "padded_img", ".", "shape", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.is_poly_in_rect": [[233, 240], ["numpy.array", "poly[].min", "poly[].max", "poly[].min", "poly[].max"], "methods", ["None"], ["", "def", "is_poly_in_rect", "(", "self", ",", "poly", ",", "x", ",", "y", ",", "w", ",", "h", ")", ":", "\n", "        ", "poly", "=", "np", ".", "array", "(", "poly", ")", "\n", "if", "poly", "[", ":", ",", "0", "]", ".", "min", "(", ")", "<", "x", "or", "poly", "[", ":", ",", "0", "]", ".", "max", "(", ")", ">", "x", "+", "w", ":", "\n", "            ", "return", "False", "\n", "", "if", "poly", "[", ":", ",", "1", "]", ".", "min", "(", ")", "<", "y", "or", "poly", "[", ":", ",", "1", "]", ".", "max", "(", ")", ">", "y", "+", "h", ":", "\n", "            ", "return", "False", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.is_poly_outside_rect": [[241, 248], ["numpy.array().reshape", "numpy.array", "poly[].max", "poly[].min", "poly[].max", "poly[].min"], "methods", ["None"], ["", "def", "is_poly_outside_rect", "(", "self", ",", "poly", ",", "x", ",", "y", ",", "w", ",", "h", ")", ":", "\n", "        ", "poly", "=", "np", ".", "array", "(", "poly", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "if", "poly", "[", ":", ",", "0", "]", ".", "max", "(", ")", "<", "x", "or", "poly", "[", ":", ",", "0", "]", ".", "min", "(", ")", ">", "x", "+", "w", ":", "\n", "            ", "return", "True", "\n", "", "if", "poly", "[", ":", ",", "1", "]", ".", "max", "(", ")", "<", "y", "or", "poly", "[", ":", ",", "1", "]", ".", "min", "(", ")", ">", "y", "+", "h", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.split_regions": [[249, 258], ["range", "regions.append"], "methods", ["None"], ["", "def", "split_regions", "(", "self", ",", "axis", ")", ":", "\n", "        ", "regions", "=", "[", "]", "\n", "min_axis", "=", "0", "\n", "for", "i", "in", "range", "(", "1", ",", "axis", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "axis", "[", "i", "]", "!=", "axis", "[", "i", "-", "1", "]", "+", "1", ":", "\n", "                ", "region", "=", "axis", "[", "min_axis", ":", "i", "]", "\n", "min_axis", "=", "i", "\n", "regions", ".", "append", "(", "region", ")", "\n", "", "", "return", "regions", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.random_select": [[259, 266], ["numpy.random.choice", "numpy.min", "numpy.max", "numpy.clip", "numpy.clip"], "methods", ["None"], ["", "def", "random_select", "(", "self", ",", "axis", ",", "max_size", ")", ":", "\n", "        ", "xx", "=", "np", ".", "random", ".", "choice", "(", "axis", ",", "size", "=", "2", ")", "\n", "xmin", "=", "np", ".", "min", "(", "xx", ")", "\n", "xmax", "=", "np", ".", "max", "(", "xx", ")", "\n", "xmin", "=", "np", ".", "clip", "(", "xmin", ",", "0", ",", "max_size", "-", "1", ")", "\n", "xmax", "=", "np", ".", "clip", "(", "xmax", ",", "0", ",", "max_size", "-", "1", ")", "\n", "return", "xmin", ",", "xmax", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.region_wise_random_select": [[267, 277], ["list", "min", "max", "numpy.random.choice", "int", "selected_values.append", "len", "numpy.random.choice"], "methods", ["None"], ["", "def", "region_wise_random_select", "(", "self", ",", "regions", ")", ":", "\n", "        ", "selected_index", "=", "list", "(", "np", ".", "random", ".", "choice", "(", "len", "(", "regions", ")", ",", "2", ")", ")", "\n", "selected_values", "=", "[", "]", "\n", "for", "index", "in", "selected_index", ":", "\n", "            ", "axis", "=", "regions", "[", "index", "]", "\n", "xx", "=", "int", "(", "np", ".", "random", ".", "choice", "(", "axis", ",", "size", "=", "1", ")", ")", "\n", "selected_values", ".", "append", "(", "xx", ")", "\n", "", "xmin", "=", "min", "(", "selected_values", ")", "\n", "xmax", "=", "max", "(", "selected_values", ")", "\n", "return", "xmin", ",", "xmax", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.crop_area": [[278, 326], ["numpy.zeros", "numpy.zeros", "dbnet_transforms.EastRandomCrop.split_regions", "dbnet_transforms.EastRandomCrop.split_regions", "range", "numpy.round().astype().reshape", "numpy.min", "numpy.max", "numpy.min", "numpy.max", "numpy.where", "numpy.where", "len", "len", "len", "dbnet_transforms.EastRandomCrop.region_wise_random_select", "dbnet_transforms.EastRandomCrop.random_select", "len", "dbnet_transforms.EastRandomCrop.region_wise_random_select", "dbnet_transforms.EastRandomCrop.random_select", "numpy.round().astype", "dbnet_transforms.EastRandomCrop.is_poly_outside_rect", "numpy.round"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.split_regions", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.split_regions", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.region_wise_random_select", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.random_select", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.region_wise_random_select", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.random_select", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.EastRandomCrop.is_poly_outside_rect"], ["", "def", "crop_area", "(", "self", ",", "img", ",", "polys", ")", ":", "\n", "        ", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "h_array", "=", "np", ".", "zeros", "(", "h", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "w_array", "=", "np", ".", "zeros", "(", "w", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "points", "in", "polys", ":", "\n", "            ", "points", "=", "np", ".", "round", "(", "\n", "points", ",", "decimals", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "min_x", "=", "np", ".", "min", "(", "points", "[", ":", ",", "0", "]", ")", "\n", "max_x", "=", "np", ".", "max", "(", "points", "[", ":", ",", "0", "]", ")", "\n", "w_array", "[", "min_x", ":", "max_x", "]", "=", "1", "\n", "min_y", "=", "np", ".", "min", "(", "points", "[", ":", ",", "1", "]", ")", "\n", "max_y", "=", "np", ".", "max", "(", "points", "[", ":", ",", "1", "]", ")", "\n", "h_array", "[", "min_y", ":", "max_y", "]", "=", "1", "\n", "# ensure the cropped area not across a text", "\n", "", "h_axis", "=", "np", ".", "where", "(", "h_array", "==", "0", ")", "[", "0", "]", "\n", "w_axis", "=", "np", ".", "where", "(", "w_array", "==", "0", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "h_axis", ")", "==", "0", "or", "len", "(", "w_axis", ")", "==", "0", ":", "\n", "            ", "return", "0", ",", "0", ",", "w", ",", "h", "\n", "\n", "", "h_regions", "=", "self", ".", "split_regions", "(", "h_axis", ")", "\n", "w_regions", "=", "self", ".", "split_regions", "(", "w_axis", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "max_tries", ")", ":", "\n", "            ", "if", "len", "(", "w_regions", ")", ">", "1", ":", "\n", "                ", "xmin", ",", "xmax", "=", "self", ".", "region_wise_random_select", "(", "w_regions", ")", "\n", "", "else", ":", "\n", "                ", "xmin", ",", "xmax", "=", "self", ".", "random_select", "(", "w_axis", ",", "w", ")", "\n", "", "if", "len", "(", "h_regions", ")", ">", "1", ":", "\n", "                ", "ymin", ",", "ymax", "=", "self", ".", "region_wise_random_select", "(", "h_regions", ")", "\n", "", "else", ":", "\n", "                ", "ymin", ",", "ymax", "=", "self", ".", "random_select", "(", "h_axis", ",", "h", ")", "\n", "\n", "", "if", "(", "xmax", "-", "xmin", "<", "self", ".", "min_crop_side_ratio", "*", "w", "\n", "or", "ymax", "-", "ymin", "<", "self", ".", "min_crop_side_ratio", "*", "h", ")", ":", "\n", "# area too small", "\n", "                ", "continue", "\n", "", "num_poly_in_rect", "=", "0", "\n", "for", "poly", "in", "polys", ":", "\n", "                ", "if", "not", "self", ".", "is_poly_outside_rect", "(", "poly", ",", "xmin", ",", "ymin", ",", "xmax", "-", "xmin", ",", "\n", "ymax", "-", "ymin", ")", ":", "\n", "                    ", "num_poly_in_rect", "+=", "1", "\n", "break", "\n", "\n", "", "", "if", "num_poly_in_rect", ">", "0", ":", "\n", "                ", "return", "xmin", ",", "ymin", ",", "xmax", "-", "xmin", ",", "ymax", "-", "ymin", "\n", "\n", "", "", "return", "0", ",", "0", ",", "w", ",", "h", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.__init__": [[16, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.point2line": [[19, 54], ["numpy.nan_to_num", "numpy.sqrt", "numpy.square", "numpy.square", "numpy.square", "numpy.square", "numpy.square", "numpy.square", "numpy.square", "numpy.sqrt", "numpy.fmin", "numpy.finfo", "numpy.sqrt", "numpy.finfo"], "methods", ["None"], ["", "def", "point2line", "(", "self", ",", "xs", ",", "ys", ",", "point_1", ",", "point_2", ")", ":", "\n", "        ", "\"\"\"Compute the distance from point to a line. This is adapted from\n        https://github.com/MhLiao/DB.\n\n        Args:\n            xs (ndarray): The x coordinates of size hxw.\n            ys (ndarray): The y coordinates of size hxw.\n            point_1 (ndarray): The first point with shape 1x2.\n            point_2 (ndarray): The second point with shape 1x2.\n\n        Returns:\n            result (ndarray): The distance matrix of size hxw.\n        \"\"\"", "\n", "# suppose a triangle with three edge abc with c=point_1 point_2", "\n", "# a^2", "\n", "a_square", "=", "np", ".", "square", "(", "xs", "-", "point_1", "[", "0", "]", ")", "+", "np", ".", "square", "(", "ys", "-", "point_1", "[", "1", "]", ")", "\n", "# b^2", "\n", "b_square", "=", "np", ".", "square", "(", "xs", "-", "point_2", "[", "0", "]", ")", "+", "np", ".", "square", "(", "ys", "-", "point_2", "[", "1", "]", ")", "\n", "# c^2", "\n", "c_square", "=", "np", ".", "square", "(", "point_1", "[", "0", "]", "-", "point_2", "[", "0", "]", ")", "+", "np", ".", "square", "(", "point_1", "[", "1", "]", "-", "\n", "point_2", "[", "1", "]", ")", "\n", "# -cosC=(c^2-a^2-b^2)/2(ab)", "\n", "neg_cos_c", "=", "(", "\n", "(", "c_square", "-", "a_square", "-", "b_square", ")", "/", "\n", "(", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", "+", "2", "*", "np", ".", "sqrt", "(", "a_square", "*", "b_square", ")", ")", ")", "\n", "# sinC^2=1-cosC^2", "\n", "square_sin", "=", "1", "-", "np", ".", "square", "(", "neg_cos_c", ")", "\n", "square_sin", "=", "np", ".", "nan_to_num", "(", "square_sin", ")", "\n", "# distance=a*b*sinC/c=a*h/c=2*area/c", "\n", "result", "=", "np", ".", "sqrt", "(", "a_square", "*", "b_square", "*", "square_sin", "/", "\n", "(", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", "+", "c_square", ")", ")", "\n", "# set result to minimum edge if C<pi/2", "\n", "result", "[", "neg_cos_c", "<", "0", "]", "=", "np", ".", "sqrt", "(", "np", ".", "fmin", "(", "a_square", ",", "\n", "b_square", ")", ")", "[", "neg_cos_c", "<", "0", "]", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.polygon_area": [[55, 72], ["polygon.reshape.reshape.reshape", "range"], "methods", ["None"], ["", "def", "polygon_area", "(", "self", ",", "polygon", ")", ":", "\n", "        ", "\"\"\"Compute the polygon area. Please refer to Green's theorem.\n        https://en.wikipedia.org/wiki/Green%27s_theorem. This is adapted from\n        https://github.com/MhLiao/DB.\n\n        Args:\n            polygon (ndarray): The polygon boundary points.\n        \"\"\"", "\n", "\n", "polygon", "=", "polygon", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "edge", "=", "0", "\n", "for", "i", "in", "range", "(", "polygon", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "next_index", "=", "(", "i", "+", "1", ")", "%", "polygon", ".", "shape", "[", "0", "]", "\n", "edge", "+=", "(", "polygon", "[", "next_index", ",", "0", "]", "-", "polygon", "[", "i", ",", "0", "]", ")", "*", "(", "\n", "polygon", "[", "next_index", ",", "1", "]", "+", "polygon", "[", "i", ",", "1", "]", ")", "\n", "\n", "", "return", "edge", "/", "2.", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.polygon_size": [[73, 87], ["polygon.reshape", "cv2.minAreaRect", "polygon.reshape.astype"], "methods", ["None"], ["", "def", "polygon_size", "(", "self", ",", "polygon", ")", ":", "\n", "        ", "\"\"\"Estimate the height and width of the minimum bounding box of the\n        polygon.\n\n        Args:\n            polygon (ndarray): The polygon point sequence.\n\n        Returns:\n            size (tuple): The height and width of the minimum bounding box.\n        \"\"\"", "\n", "poly", "=", "polygon", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "rect", "=", "cv2", ".", "minAreaRect", "(", "poly", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "size", "=", "rect", "[", "1", "]", "\n", "return", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels": [[88, 138], ["isinstance", "mmocr.is_2dlist", "isinstance", "numpy.zeros", "enumerate", "poly[].reshape().astype", "cv2.arcLength", "min", "pyclipper.PyclipperOffset", "pyclipper.PyclipperOffset.AddPath", "numpy.array", "cv2.fillPoly", "shapely.geometry.Polygon", "int", "pyclipper.PyclipperOffset.Execute", "numpy.array().reshape", "poly[].reshape", "len", "mmcv.utils.print_log", "numpy.array().reshape.astype", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "generate_kernels", "(", "self", ",", "\n", "img_size", ",", "\n", "text_polys", ",", "\n", "shrink_ratio", ",", "\n", "max_shrink", "=", "sys", ".", "maxsize", ",", "\n", "ignore_tags", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate text instance kernels for one shrink ratio.\n\n        Args:\n            img_size (tuple(int, int)): The image size of (height, width).\n            text_polys (list[list[ndarray]]: The list of text polygons.\n            shrink_ratio (float): The shrink ratio of kernel.\n\n        Returns:\n            text_kernel (ndarray): The text kernel mask of (height, width).\n        \"\"\"", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "text_polys", ")", "\n", "assert", "isinstance", "(", "shrink_ratio", ",", "float", ")", "\n", "\n", "h", ",", "w", "=", "img_size", "\n", "text_kernel", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "text_ind", ",", "poly", "in", "enumerate", "(", "text_polys", ")", ":", "\n", "            ", "instance", "=", "poly", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "area", "=", "plg", "(", "instance", ")", ".", "area", "\n", "peri", "=", "cv2", ".", "arcLength", "(", "instance", ",", "True", ")", "\n", "distance", "=", "min", "(", "\n", "int", "(", "area", "*", "(", "1", "-", "shrink_ratio", "*", "shrink_ratio", ")", "/", "(", "peri", "+", "0.001", ")", "+", "\n", "0.5", ")", ",", "max_shrink", ")", "\n", "pco", "=", "pyclipper", ".", "PyclipperOffset", "(", ")", "\n", "pco", ".", "AddPath", "(", "instance", ",", "pyclipper", ".", "JT_ROUND", ",", "\n", "pyclipper", ".", "ET_CLOSEDPOLYGON", ")", "\n", "shrunk", "=", "np", ".", "array", "(", "pco", ".", "Execute", "(", "-", "distance", ")", ")", "\n", "\n", "# check shrunk == [] or empty ndarray", "\n", "if", "len", "(", "shrunk", ")", "==", "0", "or", "shrunk", ".", "size", "==", "0", ":", "\n", "                ", "if", "ignore_tags", "is", "not", "None", ":", "\n", "                    ", "ignore_tags", "[", "text_ind", "]", "=", "True", "\n", "", "continue", "\n", "", "try", ":", "\n", "                ", "shrunk", "=", "np", ".", "array", "(", "shrunk", "[", "0", "]", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "print_log", "(", "f'{shrunk} with error {e}'", ")", "\n", "if", "ignore_tags", "is", "not", "None", ":", "\n", "                    ", "ignore_tags", "[", "text_ind", "]", "=", "True", "\n", "", "continue", "\n", "", "cv2", ".", "fillPoly", "(", "text_kernel", ",", "[", "shrunk", ".", "astype", "(", "np", ".", "int32", ")", "]", ",", "text_ind", "+", "1", ")", "\n", "", "return", "text_kernel", ",", "ignore_tags", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask": [[139, 162], ["mmocr.is_2dlist", "numpy.ones", "poly[].reshape().astype().reshape", "cv2.fillPoly", "poly[].reshape().astype", "poly[].reshape"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "generate_effective_mask", "(", "self", ",", "mask_size", ":", "tuple", ",", "polygons_ignore", ")", ":", "\n", "        ", "\"\"\"Generate effective mask by setting the ineffective regions to 0 and\n        effective regions to 1.\n\n        Args:\n            mask_size (tuple): The mask size.\n            polygons_ignore (list[[ndarray]]: The list of ignored text\n                polygons.\n\n        Returns:\n            mask (ndarray): The effective mask of (height, width).\n        \"\"\"", "\n", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "polygons_ignore", ")", "\n", "\n", "mask", "=", "np", ".", "ones", "(", "mask_size", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "for", "poly", "in", "polygons_ignore", ":", "\n", "            ", "instance", "=", "poly", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "\n", "2", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "reshape", "(", "1", ",", "-", "1", ",", "2", ")", "\n", "cv2", ".", "fillPoly", "(", "mask", ",", "instance", ",", "0", ")", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_targets": [[163, 165], ["None"], "methods", ["None"], ["", "def", "generate_targets", "(", "self", ",", "results", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.__call__": [[166, 169], ["base_textdet_targets.BaseTextDetTargets.generate_targets"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_targets"], ["", "def", "__call__", "(", "self", ",", "results", ")", ":", "\n", "        ", "results", "=", "self", ".", "generate_targets", "(", "results", ")", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.__init__": [[28, 38], ["BaseTextDetTargets.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "shrink_ratio", "=", "0.4", ",", "\n", "thr_min", "=", "0.3", ",", "\n", "thr_max", "=", "0.7", ",", "\n", "min_short_size", "=", "8", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shrink_ratio", "=", "shrink_ratio", "\n", "self", ".", "thr_min", "=", "thr_min", "\n", "self", ".", "thr_max", "=", "thr_max", "\n", "self", ".", "min_short_size", "=", "min_short_size", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.find_invalid": [[39, 55], ["enumerate", "len", "dbnet_targets.DBNetTargets.invalid_polygon"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon"], ["", "def", "find_invalid", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Find invalid polygons.\n\n        Args:\n            results (dict): The dict containing gt_mask.\n\n        Returns:\n            ignore_tags (list[bool]): The indicators for ignoring polygons.\n        \"\"\"", "\n", "texts", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "ignore_tags", "=", "[", "False", "]", "*", "len", "(", "texts", ")", "\n", "\n", "for", "idx", ",", "text", "in", "enumerate", "(", "texts", ")", ":", "\n", "            ", "if", "self", ".", "invalid_polygon", "(", "text", "[", "0", "]", ")", ":", "\n", "                ", "ignore_tags", "[", "idx", "]", "=", "True", "\n", "", "", "return", "ignore_tags", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon": [[56, 75], ["dbnet_targets.DBNetTargets.polygon_area", "min", "abs", "dbnet_targets.DBNetTargets.polygon_size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.polygon_area", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.polygon_size"], ["", "def", "invalid_polygon", "(", "self", ",", "poly", ")", ":", "\n", "        ", "\"\"\"Judge the input polygon is invalid or not. It is invalid if its area\n        smaller than 1 or the shorter side of its minimum bounding box smaller\n        than min_short_size.\n\n        Args:\n            poly (ndarray): The polygon boundary point sequence.\n\n        Returns:\n            True/False (bool): Whether the polygon is invalid.\n        \"\"\"", "\n", "area", "=", "self", ".", "polygon_area", "(", "poly", ")", "\n", "if", "abs", "(", "area", ")", "<", "1", ":", "\n", "            ", "return", "True", "\n", "", "short_size", "=", "min", "(", "self", ".", "polygon_size", "(", "poly", ")", ")", "\n", "if", "short_size", "<", "self", ".", "min_short_size", ":", "\n", "            ", "return", "True", "\n", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.ignore_texts": [[76, 107], ["len", "numpy.array", "len", "len", "enumerate", "enumerate", "enumerate"], "methods", ["None"], ["", "def", "ignore_texts", "(", "self", ",", "results", ",", "ignore_tags", ")", ":", "\n", "        ", "\"\"\"Ignore gt masks and gt_labels while padding gt_masks_ignore in\n        results given ignore_tags.\n\n        Args:\n            results (dict): Result for one image.\n            ignore_tags (list[int]): Indicate whether to ignore its\n                corresponding ground truth text.\n\n        Returns:\n            results (dict): Results after filtering.\n        \"\"\"", "\n", "flag_len", "=", "len", "(", "ignore_tags", ")", "\n", "assert", "flag_len", "==", "len", "(", "results", "[", "'gt_masks'", "]", ".", "masks", ")", "\n", "assert", "flag_len", "==", "len", "(", "results", "[", "'gt_labels'", "]", ")", "\n", "\n", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "+=", "[", "\n", "mask", "for", "i", ",", "mask", "in", "enumerate", "(", "results", "[", "'gt_masks'", "]", ".", "masks", ")", "\n", "if", "ignore_tags", "[", "i", "]", "\n", "]", "\n", "results", "[", "'gt_masks'", "]", ".", "masks", "=", "[", "\n", "mask", "for", "i", ",", "mask", "in", "enumerate", "(", "results", "[", "'gt_masks'", "]", ".", "masks", ")", "\n", "if", "not", "ignore_tags", "[", "i", "]", "\n", "]", "\n", "results", "[", "'gt_labels'", "]", "=", "np", ".", "array", "(", "[", "\n", "mask", "for", "i", ",", "mask", "in", "enumerate", "(", "results", "[", "'gt_labels'", "]", ")", "\n", "if", "not", "ignore_tags", "[", "i", "]", "\n", "]", ")", "\n", "new_ignore_tags", "=", "[", "ignore", "for", "ignore", "in", "ignore_tags", "if", "not", "ignore", "]", "\n", "\n", "return", "results", ",", "new_ignore_tags", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.generate_thr_map": [[108, 127], ["numpy.zeros", "numpy.zeros", "dbnet_targets.DBNetTargets.draw_border_map"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.draw_border_map"], ["", "def", "generate_thr_map", "(", "self", ",", "img_size", ",", "polygons", ")", ":", "\n", "        ", "\"\"\"Generate threshold map.\n\n        Args:\n            img_size (tuple(int)): The image size (h,w)\n            polygons (list(ndarray)): The polygon list.\n\n        Returns:\n            thr_map (ndarray): The generated threshold map.\n            thr_mask (ndarray): The effective mask of threshold map.\n        \"\"\"", "\n", "thr_map", "=", "np", ".", "zeros", "(", "img_size", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "thr_mask", "=", "np", ".", "zeros", "(", "img_size", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "for", "polygon", "in", "polygons", ":", "\n", "            ", "self", ".", "draw_border_map", "(", "polygon", "[", "0", "]", ",", "thr_map", ",", "mask", "=", "thr_mask", ")", "\n", "", "thr_map", "=", "thr_map", "*", "(", "self", ".", "thr_max", "-", "self", ".", "thr_min", ")", "+", "self", ".", "thr_min", "\n", "\n", "return", "thr_map", ",", "thr_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.draw_border_map": [[128, 197], ["polygon.reshape.reshape.reshape", "shapely.geometry.Polygon", "pyclipper.PyclipperOffset", "pyclipper.PyclipperOffset.AddPath", "pyclipper.PyclipperOffset.Execute", "padded_polygon[].min", "padded_polygon[].max", "padded_polygon[].min", "padded_polygon[].max", "numpy.broadcast_to", "numpy.broadcast_to", "numpy.zeros", "range", "distance_map.min.min.min", "min", "min", "min", "min", "cv2.fillPoly", "numpy.fmax", "tuple", "len", "numpy.array", "print", "polygon.reshape.reshape.copy().astype", "numpy.linspace().reshape", "numpy.linspace().reshape", "dbnet_targets.DBNetTargets.point2line", "numpy.clip", "max", "max", "max", "max", "polygon.reshape.copy().astype.astype", "numpy.power", "polygon.reshape.reshape.copy", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.point2line"], ["", "def", "draw_border_map", "(", "self", ",", "polygon", ",", "canvas", ",", "mask", ")", ":", "\n", "        ", "\"\"\"Generate threshold map for one polygon.\n\n        Args:\n            polygon(ndarray): The polygon boundary ndarray.\n            canvas(ndarray): The generated threshold map.\n            mask(ndarray): The generated threshold mask.\n        \"\"\"", "\n", "polygon", "=", "polygon", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "assert", "polygon", ".", "ndim", "==", "2", "\n", "assert", "polygon", ".", "shape", "[", "1", "]", "==", "2", "\n", "\n", "polygon_shape", "=", "Polygon", "(", "polygon", ")", "\n", "distance", "=", "(", "\n", "polygon_shape", ".", "area", "*", "(", "1", "-", "np", ".", "power", "(", "self", ".", "shrink_ratio", ",", "2", ")", ")", "/", "\n", "polygon_shape", ".", "length", ")", "\n", "subject", "=", "[", "tuple", "(", "p", ")", "for", "p", "in", "polygon", "]", "\n", "padding", "=", "pyclipper", ".", "PyclipperOffset", "(", ")", "\n", "padding", ".", "AddPath", "(", "subject", ",", "pyclipper", ".", "JT_ROUND", ",", "\n", "pyclipper", ".", "ET_CLOSEDPOLYGON", ")", "\n", "padded_polygon", "=", "padding", ".", "Execute", "(", "distance", ")", "\n", "if", "len", "(", "padded_polygon", ")", ">", "0", ":", "\n", "            ", "padded_polygon", "=", "np", ".", "array", "(", "padded_polygon", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "f'padding {polygon} with {distance} gets {padded_polygon}'", ")", "\n", "padded_polygon", "=", "polygon", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "", "x_min", "=", "padded_polygon", "[", ":", ",", "0", "]", ".", "min", "(", ")", "\n", "x_max", "=", "padded_polygon", "[", ":", ",", "0", "]", ".", "max", "(", ")", "\n", "y_min", "=", "padded_polygon", "[", ":", ",", "1", "]", ".", "min", "(", ")", "\n", "y_max", "=", "padded_polygon", "[", ":", ",", "1", "]", ".", "max", "(", ")", "\n", "\n", "width", "=", "x_max", "-", "x_min", "+", "1", "\n", "height", "=", "y_max", "-", "y_min", "+", "1", "\n", "\n", "polygon", "[", ":", ",", "0", "]", "=", "polygon", "[", ":", ",", "0", "]", "-", "x_min", "\n", "polygon", "[", ":", ",", "1", "]", "=", "polygon", "[", ":", ",", "1", "]", "-", "y_min", "\n", "\n", "xs", "=", "np", ".", "broadcast_to", "(", "\n", "np", ".", "linspace", "(", "0", ",", "width", "-", "1", ",", "num", "=", "width", ")", ".", "reshape", "(", "1", ",", "width", ")", ",", "\n", "(", "height", ",", "width", ")", ")", "\n", "ys", "=", "np", ".", "broadcast_to", "(", "\n", "np", ".", "linspace", "(", "0", ",", "height", "-", "1", ",", "num", "=", "height", ")", ".", "reshape", "(", "height", ",", "1", ")", ",", "\n", "(", "height", ",", "width", ")", ")", "\n", "\n", "distance_map", "=", "np", ".", "zeros", "(", "(", "polygon", ".", "shape", "[", "0", "]", ",", "height", ",", "width", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "polygon", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "j", "=", "(", "i", "+", "1", ")", "%", "polygon", ".", "shape", "[", "0", "]", "\n", "absolute_distance", "=", "self", ".", "point2line", "(", "xs", ",", "ys", ",", "polygon", "[", "i", "]", ",", "polygon", "[", "j", "]", ")", "\n", "distance_map", "[", "i", "]", "=", "np", ".", "clip", "(", "absolute_distance", "/", "distance", ",", "0", ",", "1", ")", "\n", "", "distance_map", "=", "distance_map", ".", "min", "(", "axis", "=", "0", ")", "\n", "\n", "x_min_valid", "=", "min", "(", "max", "(", "0", ",", "x_min", ")", ",", "canvas", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "x_max_valid", "=", "min", "(", "max", "(", "0", ",", "x_max", ")", ",", "canvas", ".", "shape", "[", "1", "]", "-", "1", ")", "\n", "y_min_valid", "=", "min", "(", "max", "(", "0", ",", "y_min", ")", ",", "canvas", ".", "shape", "[", "0", "]", "-", "1", ")", "\n", "y_max_valid", "=", "min", "(", "max", "(", "0", ",", "y_max", ")", ",", "canvas", ".", "shape", "[", "0", "]", "-", "1", ")", "\n", "\n", "if", "x_min_valid", "-", "x_min", ">=", "width", "or", "y_min_valid", "-", "y_min", ">=", "height", ":", "\n", "            ", "return", "\n", "\n", "", "cv2", ".", "fillPoly", "(", "mask", ",", "[", "padded_polygon", ".", "astype", "(", "np", ".", "int32", ")", "]", ",", "1.0", ")", "\n", "canvas", "[", "y_min_valid", ":", "y_max_valid", "+", "1", ",", "\n", "x_min_valid", ":", "x_max_valid", "+", "1", "]", "=", "np", ".", "fmax", "(", "\n", "1", "-", "distance_map", "[", "y_min_valid", "-", "y_min", ":", "y_max_valid", "-", "y_max", "+", "\n", "height", ",", "x_min_valid", "-", "x_min", ":", "x_max_valid", "-", "\n", "x_max", "+", "width", "]", ",", "\n", "canvas", "[", "y_min_valid", ":", "y_max_valid", "+", "1", ",", "\n", "x_min_valid", ":", "x_max_valid", "+", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.generate_targets": [[198, 251], ["isinstance", "dbnet_targets.DBNetTargets.find_invalid", "dbnet_targets.DBNetTargets.ignore_texts", "dbnet_targets.DBNetTargets.generate_kernels", "dbnet_targets.DBNetTargets.ignore_texts", "dbnet_targets.DBNetTargets.generate_effective_mask", "dbnet_targets.DBNetTargets.generate_thr_map", "results[].clear", "results.pop", "results.pop", "results.pop", "results.pop", "mapping.items", "results[].clear", "mmdet.core.BitmapMasks", "results[].append", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.find_invalid", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.ignore_texts", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.ignore_texts", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.generate_thr_map"], ["", "def", "generate_targets", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Generate the gt targets for DBNet.\n\n        Args:\n            results (dict): The input result dictionary.\n\n        Returns:\n            results (dict): The output result dictionary.\n        \"\"\"", "\n", "assert", "isinstance", "(", "results", ",", "dict", ")", "\n", "\n", "if", "'bbox_fields'", "in", "results", ":", "\n", "            ", "results", "[", "'bbox_fields'", "]", ".", "clear", "(", ")", "\n", "\n", "", "ignore_tags", "=", "self", ".", "find_invalid", "(", "results", ")", "\n", "results", ",", "ignore_tags", "=", "self", ".", "ignore_texts", "(", "results", ",", "ignore_tags", ")", "\n", "\n", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "polygons", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "\n", "# generate gt_shrink_kernel", "\n", "gt_shrink", ",", "ignore_tags", "=", "self", ".", "generate_kernels", "(", "(", "h", ",", "w", ")", ",", "\n", "polygons", ",", "\n", "self", ".", "shrink_ratio", ",", "\n", "ignore_tags", "=", "ignore_tags", ")", "\n", "\n", "results", ",", "ignore_tags", "=", "self", ".", "ignore_texts", "(", "results", ",", "ignore_tags", ")", "\n", "# genenrate gt_shrink_mask", "\n", "polygons_ignore", "=", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "\n", "gt_shrink_mask", "=", "self", ".", "generate_effective_mask", "(", "(", "h", ",", "w", ")", ",", "polygons_ignore", ")", "\n", "\n", "# generate gt_threshold and gt_threshold_mask", "\n", "polygons", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "gt_thr", ",", "gt_thr_mask", "=", "self", ".", "generate_thr_map", "(", "(", "h", ",", "w", ")", ",", "polygons", ")", "\n", "\n", "results", "[", "'mask_fields'", "]", ".", "clear", "(", ")", "# rm gt_masks encoded by polygons", "\n", "results", ".", "pop", "(", "'gt_labels'", ",", "None", ")", "\n", "results", ".", "pop", "(", "'gt_masks'", ",", "None", ")", "\n", "results", ".", "pop", "(", "'gt_bboxes'", ",", "None", ")", "\n", "results", ".", "pop", "(", "'gt_bboxes_ignore'", ",", "None", ")", "\n", "\n", "mapping", "=", "{", "\n", "'gt_shrink'", ":", "gt_shrink", ",", "\n", "'gt_shrink_mask'", ":", "gt_shrink_mask", ",", "\n", "'gt_thr'", ":", "gt_thr", ",", "\n", "'gt_thr_mask'", ":", "gt_thr_mask", "\n", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "value", "=", "value", "if", "isinstance", "(", "value", ",", "list", ")", "else", "[", "value", "]", "\n", "results", "[", "key", "]", "=", "BitmapMasks", "(", "value", ",", "h", ",", "w", ")", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "key", ")", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.psenet_targets.PSENetTargets.__init__": [[20, 24], ["PANetTargets.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "shrink_ratio", "=", "(", "1.0", ",", "0.9", ",", "0.8", ",", "0.7", ",", "0.6", ",", "0.5", ",", "0.4", ")", ",", "\n", "max_shrink", "=", "20", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "shrink_ratio", "=", "shrink_ratio", ",", "max_shrink", "=", "max_shrink", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.__init__": [[26, 36], ["BaseTextDetTargets.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "orientation_thr", "=", "2.0", ",", "\n", "resample_step", "=", "4.0", ",", "\n", "center_region_shrink_ratio", "=", "0.3", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "orientation_thr", "=", "orientation_thr", "\n", "self", ".", "resample_step", "=", "resample_step", "\n", "self", ".", "center_region_shrink_ratio", "=", "center_region_shrink_ratio", "\n", "self", ".", "eps", "=", "1e-8", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_angle": [[37, 50], ["numpy.arccos", "numpy.clip", "numpy.sum", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "vector_angle", "(", "self", ",", "vec1", ",", "vec2", ")", ":", "\n", "        ", "if", "vec1", ".", "ndim", ">", "1", ":", "\n", "            ", "unit_vec1", "=", "vec1", "/", "(", "norm", "(", "vec1", ",", "axis", "=", "-", "1", ")", "+", "self", ".", "eps", ")", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "unit_vec1", "=", "vec1", "/", "(", "norm", "(", "vec1", ",", "axis", "=", "-", "1", ")", "+", "self", ".", "eps", ")", "\n", "", "if", "vec2", ".", "ndim", ">", "1", ":", "\n", "            ", "unit_vec2", "=", "vec2", "/", "(", "norm", "(", "vec2", ",", "axis", "=", "-", "1", ")", "+", "self", ".", "eps", ")", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "unit_vec2", "=", "vec2", "/", "(", "norm", "(", "vec2", ",", "axis", "=", "-", "1", ")", "+", "self", ".", "eps", ")", "\n", "", "return", "np", ".", "arccos", "(", "\n", "np", ".", "clip", "(", "np", ".", "sum", "(", "unit_vec1", "*", "unit_vec2", ",", "axis", "=", "-", "1", ")", ",", "-", "1.0", ",", "1.0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope": [[51, 54], ["abs", "len"], "methods", ["None"], ["", "def", "vector_slope", "(", "self", ",", "vec", ")", ":", "\n", "        ", "assert", "len", "(", "vec", ")", "==", "2", "\n", "return", "abs", "(", "vec", "[", "1", "]", "/", "(", "vec", "[", "0", "]", "+", "self", ".", "eps", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_sin": [[55, 58], ["len", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "vector_sin", "(", "self", ",", "vec", ")", ":", "\n", "        ", "assert", "len", "(", "vec", ")", "==", "2", "\n", "return", "vec", "[", "1", "]", "/", "(", "norm", "(", "vec", ")", "+", "self", ".", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_cos": [[59, 62], ["len", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "vector_cos", "(", "self", ",", "vec", ")", ":", "\n", "        ", "assert", "len", "(", "vec", ")", "==", "2", "\n", "return", "vec", "[", "0", "]", "/", "(", "norm", "(", "vec", ")", "+", "self", ".", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.find_head_tail": [[63, 161], ["isinstance", "len", "numpy.vstack", "enumerate", "numpy.mean", "numpy.maximum", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "range", "numpy.unravel_index", "numpy.sum", "textsnake_targets.TextSnakeTargets.vector_angle", "theta_sum.append", "adjacent_vec_theta.append", "numpy.array", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "len", "numpy.arange", "float", "numpy.exp", "numpy.max", "len", "numpy.zeros.argmax", "len", "len", "len", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.linalg.norm", "textsnake_targets.TextSnakeTargets.vector_angle", "numpy.max", "len", "len", "textsnake_targets.TextSnakeTargets.vector_slope", "textsnake_targets.TextSnakeTargets.vector_slope", "textsnake_targets.TextSnakeTargets.vector_slope", "textsnake_targets.TextSnakeTargets.vector_slope", "len", "len", "len", "len", "numpy.sqrt", "numpy.power", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_angle", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_angle", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope"], ["", "def", "find_head_tail", "(", "self", ",", "points", ",", "orientation_thr", ")", ":", "\n", "        ", "\"\"\"Find the head edge and tail edge of a text polygon.\n\n        Args:\n            points (ndarray): The points composing a text polygon.\n            orientation_thr (float): The threshold for distinguishing between\n                head edge and tail edge among the horizontal and vertical edges\n                of a quadrangle.\n\n        Returns:\n            head_inds (list): The indexes of two points composing head edge.\n            tail_inds (list): The indexes of two points composing tail edge.\n        \"\"\"", "\n", "\n", "assert", "points", ".", "ndim", "==", "2", "\n", "assert", "points", ".", "shape", "[", "0", "]", ">=", "4", "\n", "assert", "points", ".", "shape", "[", "1", "]", "==", "2", "\n", "assert", "isinstance", "(", "orientation_thr", ",", "float", ")", "\n", "\n", "if", "len", "(", "points", ")", ">", "4", ":", "\n", "            ", "pad_points", "=", "np", ".", "vstack", "(", "[", "points", ",", "points", "[", "0", "]", "]", ")", "\n", "edge_vec", "=", "pad_points", "[", "1", ":", "]", "-", "pad_points", "[", ":", "-", "1", "]", "\n", "\n", "theta_sum", "=", "[", "]", "\n", "adjacent_vec_theta", "=", "[", "]", "\n", "for", "i", ",", "edge_vec1", "in", "enumerate", "(", "edge_vec", ")", ":", "\n", "                ", "adjacent_ind", "=", "[", "x", "%", "len", "(", "edge_vec", ")", "for", "x", "in", "[", "i", "-", "1", ",", "i", "+", "1", "]", "]", "\n", "adjacent_edge_vec", "=", "edge_vec", "[", "adjacent_ind", "]", "\n", "temp_theta_sum", "=", "np", ".", "sum", "(", "\n", "self", ".", "vector_angle", "(", "edge_vec1", ",", "adjacent_edge_vec", ")", ")", "\n", "temp_adjacent_theta", "=", "self", ".", "vector_angle", "(", "\n", "adjacent_edge_vec", "[", "0", "]", ",", "adjacent_edge_vec", "[", "1", "]", ")", "\n", "theta_sum", ".", "append", "(", "temp_theta_sum", ")", "\n", "adjacent_vec_theta", ".", "append", "(", "temp_adjacent_theta", ")", "\n", "", "theta_sum_score", "=", "np", ".", "array", "(", "theta_sum", ")", "/", "np", ".", "pi", "\n", "adjacent_theta_score", "=", "np", ".", "array", "(", "adjacent_vec_theta", ")", "/", "np", ".", "pi", "\n", "poly_center", "=", "np", ".", "mean", "(", "points", ",", "axis", "=", "0", ")", "\n", "edge_dist", "=", "np", ".", "maximum", "(", "\n", "norm", "(", "pad_points", "[", "1", ":", "]", "-", "poly_center", ",", "axis", "=", "-", "1", ")", ",", "\n", "norm", "(", "pad_points", "[", ":", "-", "1", "]", "-", "poly_center", ",", "axis", "=", "-", "1", ")", ")", "\n", "dist_score", "=", "edge_dist", "/", "(", "np", ".", "max", "(", "edge_dist", ")", "+", "self", ".", "eps", ")", "\n", "position_score", "=", "np", ".", "zeros", "(", "len", "(", "edge_vec", ")", ")", "\n", "score", "=", "0.5", "*", "theta_sum_score", "+", "0.15", "*", "adjacent_theta_score", "\n", "score", "+=", "0.35", "*", "dist_score", "\n", "if", "len", "(", "points", ")", "%", "2", "==", "0", ":", "\n", "                ", "position_score", "[", "(", "len", "(", "score", ")", "//", "2", "-", "1", ")", "]", "+=", "1", "\n", "position_score", "[", "-", "1", "]", "+=", "1", "\n", "", "score", "+=", "0.1", "*", "position_score", "\n", "pad_score", "=", "np", ".", "concatenate", "(", "[", "score", ",", "score", "]", ")", "\n", "score_matrix", "=", "np", ".", "zeros", "(", "(", "len", "(", "score", ")", ",", "len", "(", "score", ")", "-", "3", ")", ")", "\n", "x", "=", "np", ".", "arange", "(", "len", "(", "score", ")", "-", "3", ")", "/", "float", "(", "len", "(", "score", ")", "-", "4", ")", "\n", "gaussian", "=", "1.", "/", "(", "np", ".", "sqrt", "(", "2.", "*", "np", ".", "pi", ")", "*", "0.5", ")", "*", "np", ".", "exp", "(", "-", "np", ".", "power", "(", "\n", "(", "x", "-", "0.5", ")", "/", "0.5", ",", "2.", ")", "/", "2", ")", "\n", "gaussian", "=", "gaussian", "/", "np", ".", "max", "(", "gaussian", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "score", ")", ")", ":", "\n", "                ", "score_matrix", "[", "i", ",", ":", "]", "=", "score", "[", "i", "]", "+", "pad_score", "[", "\n", "(", "i", "+", "2", ")", ":", "(", "i", "+", "len", "(", "score", ")", "-", "1", ")", "]", "*", "gaussian", "*", "0.3", "\n", "\n", "", "head_start", ",", "tail_increment", "=", "np", ".", "unravel_index", "(", "\n", "score_matrix", ".", "argmax", "(", ")", ",", "score_matrix", ".", "shape", ")", "\n", "tail_start", "=", "(", "head_start", "+", "tail_increment", "+", "2", ")", "%", "len", "(", "points", ")", "\n", "head_end", "=", "(", "head_start", "+", "1", ")", "%", "len", "(", "points", ")", "\n", "tail_end", "=", "(", "tail_start", "+", "1", ")", "%", "len", "(", "points", ")", "\n", "\n", "if", "head_end", ">", "tail_end", ":", "\n", "                ", "head_start", ",", "tail_start", "=", "tail_start", ",", "head_start", "\n", "head_end", ",", "tail_end", "=", "tail_end", ",", "head_end", "\n", "", "head_inds", "=", "[", "head_start", ",", "head_end", "]", "\n", "tail_inds", "=", "[", "tail_start", ",", "tail_end", "]", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "vector_slope", "(", "points", "[", "1", "]", "-", "points", "[", "0", "]", ")", "+", "self", ".", "vector_slope", "(", "\n", "points", "[", "3", "]", "-", "points", "[", "2", "]", ")", "<", "self", ".", "vector_slope", "(", "\n", "points", "[", "2", "]", "-", "points", "[", "1", "]", ")", "+", "self", ".", "vector_slope", "(", "points", "[", "0", "]", "-", "\n", "points", "[", "3", "]", ")", ":", "\n", "                ", "horizontal_edge_inds", "=", "[", "[", "0", ",", "1", "]", ",", "[", "2", ",", "3", "]", "]", "\n", "vertical_edge_inds", "=", "[", "[", "3", ",", "0", "]", ",", "[", "1", ",", "2", "]", "]", "\n", "", "else", ":", "\n", "                ", "horizontal_edge_inds", "=", "[", "[", "3", ",", "0", "]", ",", "[", "1", ",", "2", "]", "]", "\n", "vertical_edge_inds", "=", "[", "[", "0", ",", "1", "]", ",", "[", "2", ",", "3", "]", "]", "\n", "\n", "", "vertical_len_sum", "=", "norm", "(", "points", "[", "vertical_edge_inds", "[", "0", "]", "[", "0", "]", "]", "-", "\n", "points", "[", "vertical_edge_inds", "[", "0", "]", "[", "1", "]", "]", ")", "+", "norm", "(", "\n", "points", "[", "vertical_edge_inds", "[", "1", "]", "[", "0", "]", "]", "-", "\n", "points", "[", "vertical_edge_inds", "[", "1", "]", "[", "1", "]", "]", ")", "\n", "horizontal_len_sum", "=", "norm", "(", "\n", "points", "[", "horizontal_edge_inds", "[", "0", "]", "[", "0", "]", "]", "-", "\n", "points", "[", "horizontal_edge_inds", "[", "0", "]", "[", "1", "]", "]", ")", "+", "norm", "(", "\n", "points", "[", "horizontal_edge_inds", "[", "1", "]", "[", "0", "]", "]", "-", "\n", "points", "[", "horizontal_edge_inds", "[", "1", "]", "[", "1", "]", "]", ")", "\n", "\n", "if", "vertical_len_sum", ">", "horizontal_len_sum", "*", "orientation_thr", ":", "\n", "                ", "head_inds", "=", "horizontal_edge_inds", "[", "0", "]", "\n", "tail_inds", "=", "horizontal_edge_inds", "[", "1", "]", "\n", "", "else", ":", "\n", "                ", "head_inds", "=", "vertical_edge_inds", "[", "0", "]", "\n", "tail_inds", "=", "vertical_edge_inds", "[", "1", "]", "\n", "\n", "", "", "return", "head_inds", ",", "tail_inds", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.reorder_poly_edge": [[162, 203], ["textsnake_targets.TextSnakeTargets.find_head_tail", "numpy.vstack", "len", "numpy.mean", "numpy.mean", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.find_head_tail"], ["", "def", "reorder_poly_edge", "(", "self", ",", "points", ")", ":", "\n", "        ", "\"\"\"Get the respective points composing head edge, tail edge, top\n        sideline and bottom sideline.\n\n        Args:\n            points (ndarray): The points composing a text polygon.\n\n        Returns:\n            head_edge (ndarray): The two points composing the head edge of text\n                polygon.\n            tail_edge (ndarray): The two points composing the tail edge of text\n                polygon.\n            top_sideline (ndarray): The points composing top curved sideline of\n                text polygon.\n            bot_sideline (ndarray): The points composing bottom curved sideline\n                of text polygon.\n        \"\"\"", "\n", "\n", "assert", "points", ".", "ndim", "==", "2", "\n", "assert", "points", ".", "shape", "[", "0", "]", ">=", "4", "\n", "assert", "points", ".", "shape", "[", "1", "]", "==", "2", "\n", "\n", "head_inds", ",", "tail_inds", "=", "self", ".", "find_head_tail", "(", "points", ",", "\n", "self", ".", "orientation_thr", ")", "\n", "head_edge", ",", "tail_edge", "=", "points", "[", "head_inds", "]", ",", "points", "[", "tail_inds", "]", "\n", "\n", "pad_points", "=", "np", ".", "vstack", "(", "[", "points", ",", "points", "]", ")", "\n", "if", "tail_inds", "[", "1", "]", "<", "1", ":", "\n", "            ", "tail_inds", "[", "1", "]", "=", "len", "(", "points", ")", "\n", "", "sideline1", "=", "pad_points", "[", "head_inds", "[", "1", "]", ":", "tail_inds", "[", "1", "]", "]", "\n", "sideline2", "=", "pad_points", "[", "tail_inds", "[", "1", "]", ":", "(", "head_inds", "[", "1", "]", "+", "len", "(", "points", ")", ")", "]", "\n", "sideline_mean_shift", "=", "np", ".", "mean", "(", "\n", "sideline1", ",", "axis", "=", "0", ")", "-", "np", ".", "mean", "(", "\n", "sideline2", ",", "axis", "=", "0", ")", "\n", "\n", "if", "sideline_mean_shift", "[", "1", "]", ">", "0", ":", "\n", "            ", "top_sideline", ",", "bot_sideline", "=", "sideline2", ",", "sideline1", "\n", "", "else", ":", "\n", "            ", "top_sideline", ",", "bot_sideline", "=", "sideline1", ",", "sideline2", "\n", "\n", "", "return", "head_edge", ",", "tail_edge", ",", "top_sideline", ",", "bot_sideline", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.cal_curve_length": [[204, 226], ["numpy.sqrt", "numpy.sum", "len"], "methods", ["None"], ["", "def", "cal_curve_length", "(", "self", ",", "line", ")", ":", "\n", "        ", "\"\"\"Calculate the length of each edge on the discrete curve and the sum.\n\n        Args:\n            line (ndarray): The points composing a discrete curve.\n\n        Returns:\n            tuple: Returns (edges_length, total_length).\n\n                - | edge_length (ndarray): The length of each edge on the\n                    discrete curve.\n                - | total_length (float): The total length of the discrete\n                    curve.\n        \"\"\"", "\n", "\n", "assert", "line", ".", "ndim", "==", "2", "\n", "assert", "len", "(", "line", ")", ">=", "2", "\n", "\n", "edges_length", "=", "np", ".", "sqrt", "(", "(", "line", "[", "1", ":", ",", "0", "]", "-", "line", "[", ":", "-", "1", ",", "0", "]", ")", "**", "2", "+", "\n", "(", "line", "[", "1", ":", ",", "1", "]", "-", "line", "[", ":", "-", "1", ",", "1", "]", ")", "**", "2", ")", "\n", "total_length", "=", "np", ".", "sum", "(", "edges_length", ")", "\n", "return", "edges_length", ",", "total_length", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_line": [[227, 262], ["isinstance", "textsnake_targets.TextSnakeTargets.cal_curve_length", "numpy.insert", "points.append", "numpy.vstack", "numpy.cumsum", "numpy.arange", "numpy.dot", "points.append", "numpy.array", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.cal_curve_length"], ["", "def", "resample_line", "(", "self", ",", "line", ",", "n", ")", ":", "\n", "        ", "\"\"\"Resample n points on a line.\n\n        Args:\n            line (ndarray): The points composing a line.\n            n (int): The resampled points number.\n\n        Returns:\n            resampled_line (ndarray): The points composing the resampled line.\n        \"\"\"", "\n", "\n", "assert", "line", ".", "ndim", "==", "2", "\n", "assert", "line", ".", "shape", "[", "0", "]", ">=", "2", "\n", "assert", "line", ".", "shape", "[", "1", "]", "==", "2", "\n", "assert", "isinstance", "(", "n", ",", "int", ")", "\n", "assert", "n", ">", "2", "\n", "\n", "edges_length", ",", "total_length", "=", "self", ".", "cal_curve_length", "(", "line", ")", "\n", "t_org", "=", "np", ".", "insert", "(", "np", ".", "cumsum", "(", "edges_length", ")", ",", "0", ",", "0", ")", "\n", "unit_t", "=", "total_length", "/", "(", "n", "-", "1", ")", "\n", "t_equidistant", "=", "np", ".", "arange", "(", "1", ",", "n", "-", "1", ",", "dtype", "=", "np", ".", "float32", ")", "*", "unit_t", "\n", "edge_ind", "=", "0", "\n", "points", "=", "[", "line", "[", "0", "]", "]", "\n", "for", "t", "in", "t_equidistant", ":", "\n", "            ", "while", "edge_ind", "<", "len", "(", "edges_length", ")", "-", "1", "and", "t", ">", "t_org", "[", "edge_ind", "+", "1", "]", ":", "\n", "                ", "edge_ind", "+=", "1", "\n", "", "t_l", ",", "t_r", "=", "t_org", "[", "edge_ind", "]", ",", "t_org", "[", "edge_ind", "+", "1", "]", "\n", "weight", "=", "np", ".", "array", "(", "[", "t_r", "-", "t", ",", "t", "-", "t_l", "]", ",", "dtype", "=", "np", ".", "float32", ")", "/", "(", "\n", "t_r", "-", "t_l", "+", "self", ".", "eps", ")", "\n", "p_coords", "=", "np", ".", "dot", "(", "weight", ",", "line", "[", "[", "edge_ind", ",", "edge_ind", "+", "1", "]", "]", ")", "\n", "points", ".", "append", "(", "p_coords", ")", "\n", "", "points", ".", "append", "(", "line", "[", "-", "1", "]", ")", "\n", "resampled_line", "=", "np", ".", "vstack", "(", "points", ")", "\n", "\n", "return", "resampled_line", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_sidelines": [[263, 295], ["isinstance", "textsnake_targets.TextSnakeTargets.cal_curve_length", "textsnake_targets.TextSnakeTargets.cal_curve_length", "max", "textsnake_targets.TextSnakeTargets.resample_line", "textsnake_targets.TextSnakeTargets.resample_line", "int", "float"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.cal_curve_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.cal_curve_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_line"], ["", "def", "resample_sidelines", "(", "self", ",", "sideline1", ",", "sideline2", ",", "resample_step", ")", ":", "\n", "        ", "\"\"\"Resample two sidelines to be of the same points number according to\n        step size.\n\n        Args:\n            sideline1 (ndarray): The points composing a sideline of a text\n                polygon.\n            sideline2 (ndarray): The points composing another sideline of a\n                text polygon.\n            resample_step (float): The resampled step size.\n\n        Returns:\n            resampled_line1 (ndarray): The resampled line 1.\n            resampled_line2 (ndarray): The resampled line 2.\n        \"\"\"", "\n", "\n", "assert", "sideline1", ".", "ndim", "==", "sideline2", ".", "ndim", "==", "2", "\n", "assert", "sideline1", ".", "shape", "[", "1", "]", "==", "sideline2", ".", "shape", "[", "1", "]", "==", "2", "\n", "assert", "sideline1", ".", "shape", "[", "0", "]", ">=", "2", "\n", "assert", "sideline2", ".", "shape", "[", "0", "]", ">=", "2", "\n", "assert", "isinstance", "(", "resample_step", ",", "float", ")", "\n", "\n", "_", ",", "length1", "=", "self", ".", "cal_curve_length", "(", "sideline1", ")", "\n", "_", ",", "length2", "=", "self", ".", "cal_curve_length", "(", "sideline2", ")", "\n", "\n", "avg_length", "=", "(", "length1", "+", "length2", ")", "/", "2", "\n", "resample_point_num", "=", "max", "(", "int", "(", "float", "(", "avg_length", ")", "/", "resample_step", ")", "+", "1", ",", "3", ")", "\n", "\n", "resampled_line1", "=", "self", ".", "resample_line", "(", "sideline1", ",", "resample_point_num", ")", "\n", "resampled_line2", "=", "self", ".", "resample_line", "(", "sideline2", ",", "resample_point_num", ")", "\n", "\n", "return", "resampled_line1", ",", "resampled_line2", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.draw_center_region_maps": [[296, 349], ["isinstance", "range", "textsnake_targets.TextSnakeTargets.vector_sin", "textsnake_targets.TextSnakeTargets.vector_cos", "numpy.vstack().astype", "cv2.fillPoly", "cv2.fillPoly", "cv2.fillPoly", "cv2.fillPoly", "len", "numpy.linalg.norm", "numpy.vstack"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_sin", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_cos"], ["", "def", "draw_center_region_maps", "(", "self", ",", "top_line", ",", "bot_line", ",", "center_line", ",", "\n", "center_region_mask", ",", "radius_map", ",", "sin_map", ",", "\n", "cos_map", ",", "region_shrink_ratio", ")", ":", "\n", "        ", "\"\"\"Draw attributes on text center region.\n\n        Args:\n            top_line (ndarray): The points composing top curved sideline of\n                text polygon.\n            bot_line (ndarray): The points composing bottom curved sideline\n                of text polygon.\n            center_line (ndarray): The points composing the center line of text\n                instance.\n            center_region_mask (ndarray): The text center region mask.\n            radius_map (ndarray): The map where the distance from point to\n                sidelines will be drawn on for each pixel in text center\n                region.\n            sin_map (ndarray): The map where vector_sin(theta) will be drawn\n                on text center regions. Theta is the angle between tangent\n                line and vector (1, 0).\n            cos_map (ndarray): The map where vector_cos(theta) will be drawn on\n                text center regions. Theta is the angle between tangent line\n                and vector (1, 0).\n            region_shrink_ratio (float): The shrink ratio of text center.\n        \"\"\"", "\n", "\n", "assert", "top_line", ".", "shape", "==", "bot_line", ".", "shape", "==", "center_line", ".", "shape", "\n", "assert", "(", "center_region_mask", ".", "shape", "==", "radius_map", ".", "shape", "==", "sin_map", ".", "shape", "\n", "==", "cos_map", ".", "shape", ")", "\n", "assert", "isinstance", "(", "region_shrink_ratio", ",", "float", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "center_line", ")", "-", "1", ")", ":", "\n", "\n", "            ", "top_mid_point", "=", "(", "top_line", "[", "i", "]", "+", "top_line", "[", "i", "+", "1", "]", ")", "/", "2", "\n", "bot_mid_point", "=", "(", "bot_line", "[", "i", "]", "+", "bot_line", "[", "i", "+", "1", "]", ")", "/", "2", "\n", "radius", "=", "norm", "(", "top_mid_point", "-", "bot_mid_point", ")", "/", "2", "\n", "\n", "text_direction", "=", "center_line", "[", "i", "+", "1", "]", "-", "center_line", "[", "i", "]", "\n", "sin_theta", "=", "self", ".", "vector_sin", "(", "text_direction", ")", "\n", "cos_theta", "=", "self", ".", "vector_cos", "(", "text_direction", ")", "\n", "\n", "tl", "=", "center_line", "[", "i", "]", "+", "(", "top_line", "[", "i", "]", "-", "\n", "center_line", "[", "i", "]", ")", "*", "region_shrink_ratio", "\n", "tr", "=", "center_line", "[", "i", "+", "1", "]", "+", "(", "\n", "top_line", "[", "i", "+", "1", "]", "-", "center_line", "[", "i", "+", "1", "]", ")", "*", "region_shrink_ratio", "\n", "br", "=", "center_line", "[", "i", "+", "1", "]", "+", "(", "\n", "bot_line", "[", "i", "+", "1", "]", "-", "center_line", "[", "i", "+", "1", "]", ")", "*", "region_shrink_ratio", "\n", "bl", "=", "center_line", "[", "i", "]", "+", "(", "bot_line", "[", "i", "]", "-", "\n", "center_line", "[", "i", "]", ")", "*", "region_shrink_ratio", "\n", "current_center_box", "=", "np", ".", "vstack", "(", "[", "tl", ",", "tr", ",", "br", ",", "bl", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "cv2", ".", "fillPoly", "(", "center_region_mask", ",", "[", "current_center_box", "]", ",", "color", "=", "1", ")", "\n", "cv2", ".", "fillPoly", "(", "sin_map", ",", "[", "current_center_box", "]", ",", "color", "=", "sin_theta", ")", "\n", "cv2", ".", "fillPoly", "(", "cos_map", ",", "[", "current_center_box", "]", ",", "color", "=", "cos_theta", ")", "\n", "cv2", ".", "fillPoly", "(", "radius_map", ",", "[", "current_center_box", "]", ",", "color", "=", "radius", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_center_mask_attrib_maps": [[350, 430], ["isinstance", "mmocr.is_2dlist", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.array().reshape", "len", "range", "textsnake_targets.TextSnakeTargets.reorder_poly_edge", "textsnake_targets.TextSnakeTargets.resample_sidelines", "int", "int", "textsnake_targets.TextSnakeTargets.draw_center_region_maps", "len", "textsnake_targets.TextSnakeTargets.vector_slope", "numpy.linalg.norm", "numpy.linalg.norm", "len", "range", "numpy.array", "numpy.linalg.norm", "keep_inds.append", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.reorder_poly_edge", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_sidelines", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.draw_center_region_maps", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope"], ["", "", "def", "generate_center_mask_attrib_maps", "(", "self", ",", "img_size", ",", "text_polys", ")", ":", "\n", "        ", "\"\"\"Generate text center region mask and geometric attribute maps.\n\n        Args:\n            img_size (tuple): The image size of (height, width).\n            text_polys (list[list[ndarray]]): The list of text polygons.\n\n        Returns:\n            center_region_mask (ndarray): The text center region mask.\n            radius_map (ndarray): The distance map from each pixel in text\n                center region to top sideline.\n            sin_map (ndarray): The sin(theta) map where theta is the angle\n                between vector (top point - bottom point) and vector (1, 0).\n            cos_map (ndarray): The cos(theta) map where theta is the angle\n                between vector (top point - bottom point) and vector (1, 0).\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "text_polys", ")", "\n", "\n", "h", ",", "w", "=", "img_size", "\n", "\n", "center_region_mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "np", ".", "uint8", ")", "\n", "radius_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "sin_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "cos_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "poly", "in", "text_polys", ":", "\n", "            ", "assert", "len", "(", "poly", ")", "==", "1", "\n", "text_instance", "=", "[", "[", "poly", "[", "0", "]", "[", "i", "]", ",", "poly", "[", "0", "]", "[", "i", "+", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "poly", "[", "0", "]", ")", ",", "2", ")", "]", "\n", "polygon_points", "=", "np", ".", "array", "(", "text_instance", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "\n", "n", "=", "len", "(", "polygon_points", ")", "\n", "keep_inds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                ", "if", "norm", "(", "polygon_points", "[", "i", "]", "-", "\n", "polygon_points", "[", "(", "i", "+", "1", ")", "%", "n", "]", ")", ">", "1e-5", ":", "\n", "                    ", "keep_inds", ".", "append", "(", "i", ")", "\n", "", "", "polygon_points", "=", "polygon_points", "[", "keep_inds", "]", "\n", "\n", "_", ",", "_", ",", "top_line", ",", "bot_line", "=", "self", ".", "reorder_poly_edge", "(", "polygon_points", ")", "\n", "resampled_top_line", ",", "resampled_bot_line", "=", "self", ".", "resample_sidelines", "(", "\n", "top_line", ",", "bot_line", ",", "self", ".", "resample_step", ")", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "center_line", "=", "(", "resampled_top_line", "+", "resampled_bot_line", ")", "/", "2", "\n", "\n", "if", "self", ".", "vector_slope", "(", "center_line", "[", "-", "1", "]", "-", "center_line", "[", "0", "]", ")", ">", "0.9", ":", "\n", "                ", "if", "(", "center_line", "[", "-", "1", "]", "-", "center_line", "[", "0", "]", ")", "[", "1", "]", "<", "0", ":", "\n", "                    ", "center_line", "=", "center_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "if", "(", "center_line", "[", "-", "1", "]", "-", "center_line", "[", "0", "]", ")", "[", "0", "]", "<", "0", ":", "\n", "                    ", "center_line", "=", "center_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "\n", "", "", "line_head_shrink_len", "=", "norm", "(", "resampled_top_line", "[", "0", "]", "-", "\n", "resampled_bot_line", "[", "0", "]", ")", "/", "4.0", "\n", "line_tail_shrink_len", "=", "norm", "(", "resampled_top_line", "[", "-", "1", "]", "-", "\n", "resampled_bot_line", "[", "-", "1", "]", ")", "/", "4.0", "\n", "head_shrink_num", "=", "int", "(", "line_head_shrink_len", "//", "self", ".", "resample_step", ")", "\n", "tail_shrink_num", "=", "int", "(", "line_tail_shrink_len", "//", "self", ".", "resample_step", ")", "\n", "\n", "if", "len", "(", "center_line", ")", ">", "head_shrink_num", "+", "tail_shrink_num", "+", "2", ":", "\n", "                ", "center_line", "=", "center_line", "[", "head_shrink_num", ":", "len", "(", "center_line", ")", "-", "\n", "tail_shrink_num", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", "\n", "head_shrink_num", ":", "len", "(", "resampled_top_line", ")", "-", "tail_shrink_num", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", "\n", "head_shrink_num", ":", "len", "(", "resampled_bot_line", ")", "-", "tail_shrink_num", "]", "\n", "\n", "", "self", ".", "draw_center_region_maps", "(", "resampled_top_line", ",", "\n", "resampled_bot_line", ",", "center_line", ",", "\n", "center_region_mask", ",", "radius_map", ",", "\n", "sin_map", ",", "cos_map", ",", "\n", "self", ".", "center_region_shrink_ratio", ")", "\n", "\n", "", "return", "center_region_mask", ",", "radius_map", ",", "sin_map", ",", "cos_map", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_text_region_mask": [[431, 457], ["isinstance", "mmocr.is_2dlist", "numpy.zeros", "numpy.array().reshape", "cv2.fillPoly", "len", "range", "numpy.array", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "generate_text_region_mask", "(", "self", ",", "img_size", ",", "text_polys", ")", ":", "\n", "        ", "\"\"\"Generate text center region mask and geometry attribute maps.\n\n        Args:\n            img_size (tuple): The image size (height, width).\n            text_polys (list[list[ndarray]]): The list of text polygons.\n\n        Returns:\n            text_region_mask (ndarray): The text region mask.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "text_polys", ")", "\n", "\n", "h", ",", "w", "=", "img_size", "\n", "text_region_mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "for", "poly", "in", "text_polys", ":", "\n", "            ", "assert", "len", "(", "poly", ")", "==", "1", "\n", "text_instance", "=", "[", "[", "poly", "[", "0", "]", "[", "i", "]", ",", "poly", "[", "0", "]", "[", "i", "+", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "poly", "[", "0", "]", ")", ",", "2", ")", "]", "\n", "polygon", "=", "np", ".", "array", "(", "\n", "text_instance", ",", "dtype", "=", "np", ".", "int32", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ",", "2", ")", ")", "\n", "cv2", ".", "fillPoly", "(", "text_region_mask", ",", "polygon", ",", "1", ")", "\n", "\n", "", "return", "text_region_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_targets": [[458, 497], ["isinstance", "textsnake_targets.TextSnakeTargets.generate_text_region_mask", "textsnake_targets.TextSnakeTargets.generate_effective_mask", "textsnake_targets.TextSnakeTargets.generate_center_mask_attrib_maps", "results[].clear", "mapping.items", "mmdet.core.BitmapMasks", "results[].append", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_text_region_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_center_mask_attrib_maps"], ["", "def", "generate_targets", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Generate the gt targets for TextSnake.\n\n        Args:\n            results (dict): The input result dictionary.\n\n        Returns:\n            results (dict): The output result dictionary.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "results", ",", "dict", ")", "\n", "\n", "polygon_masks", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "polygon_masks_ignore", "=", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "\n", "\n", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "\n", "gt_text_mask", "=", "self", ".", "generate_text_region_mask", "(", "(", "h", ",", "w", ")", ",", "polygon_masks", ")", "\n", "gt_mask", "=", "self", ".", "generate_effective_mask", "(", "(", "h", ",", "w", ")", ",", "polygon_masks_ignore", ")", "\n", "\n", "(", "gt_center_region_mask", ",", "gt_radius_map", ",", "gt_sin_map", ",", "\n", "gt_cos_map", ")", "=", "self", ".", "generate_center_mask_attrib_maps", "(", "(", "h", ",", "w", ")", ",", "\n", "polygon_masks", ")", "\n", "\n", "results", "[", "'mask_fields'", "]", ".", "clear", "(", ")", "# rm gt_masks encoded by polygons", "\n", "mapping", "=", "{", "\n", "'gt_text_mask'", ":", "gt_text_mask", ",", "\n", "'gt_center_region_mask'", ":", "gt_center_region_mask", ",", "\n", "'gt_mask'", ":", "gt_mask", ",", "\n", "'gt_radius_map'", ":", "gt_radius_map", ",", "\n", "'gt_sin_map'", ":", "gt_sin_map", ",", "\n", "'gt_cos_map'", ":", "gt_cos_map", "\n", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "value", "=", "value", "if", "isinstance", "(", "value", ",", "list", ")", "else", "[", "value", "]", "\n", "results", "[", "key", "]", "=", "BitmapMasks", "(", "value", ",", "h", ",", "w", ")", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "key", ")", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.panet_targets.PANetTargets.__init__": [[21, 24], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "shrink_ratio", "=", "(", "1.0", ",", "0.5", ")", ",", "max_shrink", "=", "20", ")", ":", "\n", "        ", "self", ".", "shrink_ratio", "=", "shrink_ratio", "\n", "self", ".", "max_shrink", "=", "max_shrink", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.panet_targets.PANetTargets.generate_targets": [[25, 66], ["isinstance", "panet_targets.PANetTargets.generate_effective_mask", "results[].clear", "results.pop", "results.pop", "results.pop", "results.pop", "mapping.items", "panet_targets.PANetTargets.generate_kernels", "gt_kernels.append", "results[].clear", "mmdet.core.BitmapMasks", "results[].append", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels"], ["", "def", "generate_targets", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Generate the gt targets for PANet.\n\n        Args:\n            results (dict): The input result dictionary.\n\n        Returns:\n            results (dict): The output result dictionary.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "results", ",", "dict", ")", "\n", "\n", "polygon_masks", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "polygon_masks_ignore", "=", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "\n", "\n", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "gt_kernels", "=", "[", "]", "\n", "for", "ratio", "in", "self", ".", "shrink_ratio", ":", "\n", "            ", "mask", ",", "_", "=", "self", ".", "generate_kernels", "(", "(", "h", ",", "w", ")", ",", "\n", "polygon_masks", ",", "\n", "ratio", ",", "\n", "max_shrink", "=", "self", ".", "max_shrink", ",", "\n", "ignore_tags", "=", "None", ")", "\n", "gt_kernels", ".", "append", "(", "mask", ")", "\n", "", "gt_mask", "=", "self", ".", "generate_effective_mask", "(", "(", "h", ",", "w", ")", ",", "polygon_masks_ignore", ")", "\n", "\n", "results", "[", "'mask_fields'", "]", ".", "clear", "(", ")", "# rm gt_masks encoded by polygons", "\n", "if", "'bbox_fields'", "in", "results", ":", "\n", "            ", "results", "[", "'bbox_fields'", "]", ".", "clear", "(", ")", "\n", "", "results", ".", "pop", "(", "'gt_labels'", ",", "None", ")", "\n", "results", ".", "pop", "(", "'gt_masks'", ",", "None", ")", "\n", "results", ".", "pop", "(", "'gt_bboxes'", ",", "None", ")", "\n", "results", ".", "pop", "(", "'gt_bboxes_ignore'", ",", "None", ")", "\n", "\n", "mapping", "=", "{", "'gt_kernels'", ":", "gt_kernels", ",", "'gt_mask'", ":", "gt_mask", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "value", "=", "value", "if", "isinstance", "(", "value", ",", "list", ")", "else", "[", "value", "]", "\n", "results", "[", "key", "]", "=", "BitmapMasks", "(", "value", ",", "h", ",", "w", ")", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "key", ")", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.__init__": [[44, 73], ["textsnake_targets.TextSnakeTargets.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "orientation_thr", "=", "2.0", ",", "\n", "resample_step", "=", "8.0", ",", "\n", "num_min_comps", "=", "9", ",", "\n", "num_max_comps", "=", "600", ",", "\n", "min_width", "=", "8.0", ",", "\n", "max_width", "=", "24.0", ",", "\n", "center_region_shrink_ratio", "=", "0.3", ",", "\n", "comp_shrink_ratio", "=", "1.0", ",", "\n", "comp_w_h_ratio", "=", "0.3", ",", "\n", "text_comp_nms_thr", "=", "0.25", ",", "\n", "min_rand_half_height", "=", "8.0", ",", "\n", "max_rand_half_height", "=", "24.0", ",", "\n", "jitter_level", "=", "0.2", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "orientation_thr", "=", "orientation_thr", "\n", "self", ".", "resample_step", "=", "resample_step", "\n", "self", ".", "num_max_comps", "=", "num_max_comps", "\n", "self", ".", "num_min_comps", "=", "num_min_comps", "\n", "self", ".", "min_width", "=", "min_width", "\n", "self", ".", "max_width", "=", "max_width", "\n", "self", ".", "center_region_shrink_ratio", "=", "center_region_shrink_ratio", "\n", "self", ".", "comp_shrink_ratio", "=", "comp_shrink_ratio", "\n", "self", ".", "comp_w_h_ratio", "=", "comp_w_h_ratio", "\n", "self", ".", "text_comp_nms_thr", "=", "text_comp_nms_thr", "\n", "self", ".", "min_rand_half_height", "=", "min_rand_half_height", "\n", "self", ".", "max_rand_half_height", "=", "max_rand_half_height", "\n", "self", ".", "jitter_level", "=", "jitter_level", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.dist_point2line": [[74, 81], ["isinstance", "abs", "numpy.cross", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "dist_point2line", "(", "self", ",", "point", ",", "line", ")", ":", "\n", "\n", "        ", "assert", "isinstance", "(", "line", ",", "tuple", ")", "\n", "point1", ",", "point2", "=", "line", "\n", "d", "=", "abs", "(", "np", ".", "cross", "(", "point2", "-", "point1", ",", "point", "-", "point1", ")", ")", "/", "(", "\n", "norm", "(", "point2", "-", "point1", ")", "+", "1e-8", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.draw_center_region_maps": [[82, 157], ["isinstance", "range", "drrg_targets.DRRGTargets.vector_sin", "drrg_targets.DRRGTargets.vector_cos", "numpy.vstack().astype", "cv2.fillPoly", "cv2.fillPoly", "cv2.fillPoly", "numpy.clip", "numpy.clip", "numpy.min().astype", "numpy.max().astype", "numpy.zeros", "cv2.fillPoly", "numpy.argwhere", "numpy.fliplr", "drrg_targets.DRRGTargets.dist_point2line", "drrg_targets.DRRGTargets.dist_point2line", "len", "numpy.vstack", "numpy.min", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_sin", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_cos", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.dist_point2line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.dist_point2line"], ["", "def", "draw_center_region_maps", "(", "self", ",", "top_line", ",", "bot_line", ",", "center_line", ",", "\n", "center_region_mask", ",", "top_height_map", ",", "\n", "bot_height_map", ",", "sin_map", ",", "cos_map", ",", "\n", "region_shrink_ratio", ")", ":", "\n", "        ", "\"\"\"Draw attributes of text components on text center regions.\n\n        Args:\n            top_line (ndarray): The points composing the top side lines of text\n                polygons.\n            bot_line (ndarray): The points composing bottom side lines of text\n                polygons.\n            center_line (ndarray): The points composing the center lines of\n                text instances.\n            center_region_mask (ndarray): The text center region mask.\n            top_height_map (ndarray): The map on which the distance from points\n                to top side lines will be drawn for each pixel in text center\n                regions.\n            bot_height_map (ndarray): The map on which the distance from points\n                to bottom side lines will be drawn for each pixel in text\n                center regions.\n            sin_map (ndarray): The map of vector_sin(top_point - bot_point)\n                that will be drawn on text center regions.\n            cos_map (ndarray): The map of vector_cos(top_point - bot_point)\n                will be drawn on text center regions.\n            region_shrink_ratio (float): The shrink ratio of text center\n                regions.\n        \"\"\"", "\n", "\n", "assert", "top_line", ".", "shape", "==", "bot_line", ".", "shape", "==", "center_line", ".", "shape", "\n", "assert", "(", "center_region_mask", ".", "shape", "==", "top_height_map", ".", "shape", "==", "\n", "bot_height_map", ".", "shape", "==", "sin_map", ".", "shape", "==", "cos_map", ".", "shape", ")", "\n", "assert", "isinstance", "(", "region_shrink_ratio", ",", "float", ")", "\n", "\n", "h", ",", "w", "=", "center_region_mask", ".", "shape", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "center_line", ")", "-", "1", ")", ":", "\n", "\n", "            ", "top_mid_point", "=", "(", "top_line", "[", "i", "]", "+", "top_line", "[", "i", "+", "1", "]", ")", "/", "2", "\n", "bot_mid_point", "=", "(", "bot_line", "[", "i", "]", "+", "bot_line", "[", "i", "+", "1", "]", ")", "/", "2", "\n", "\n", "sin_theta", "=", "self", ".", "vector_sin", "(", "top_mid_point", "-", "bot_mid_point", ")", "\n", "cos_theta", "=", "self", ".", "vector_cos", "(", "top_mid_point", "-", "bot_mid_point", ")", "\n", "\n", "tl", "=", "center_line", "[", "i", "]", "+", "(", "top_line", "[", "i", "]", "-", "\n", "center_line", "[", "i", "]", ")", "*", "region_shrink_ratio", "\n", "tr", "=", "center_line", "[", "i", "+", "1", "]", "+", "(", "\n", "top_line", "[", "i", "+", "1", "]", "-", "center_line", "[", "i", "+", "1", "]", ")", "*", "region_shrink_ratio", "\n", "br", "=", "center_line", "[", "i", "+", "1", "]", "+", "(", "\n", "bot_line", "[", "i", "+", "1", "]", "-", "center_line", "[", "i", "+", "1", "]", ")", "*", "region_shrink_ratio", "\n", "bl", "=", "center_line", "[", "i", "]", "+", "(", "bot_line", "[", "i", "]", "-", "\n", "center_line", "[", "i", "]", ")", "*", "region_shrink_ratio", "\n", "current_center_box", "=", "np", ".", "vstack", "(", "[", "tl", ",", "tr", ",", "br", ",", "bl", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "cv2", ".", "fillPoly", "(", "center_region_mask", ",", "[", "current_center_box", "]", ",", "color", "=", "1", ")", "\n", "cv2", ".", "fillPoly", "(", "sin_map", ",", "[", "current_center_box", "]", ",", "color", "=", "sin_theta", ")", "\n", "cv2", ".", "fillPoly", "(", "cos_map", ",", "[", "current_center_box", "]", ",", "color", "=", "cos_theta", ")", "\n", "\n", "current_center_box", "[", ":", ",", "0", "]", "=", "np", ".", "clip", "(", "current_center_box", "[", ":", ",", "0", "]", ",", "0", ",", "\n", "w", "-", "1", ")", "\n", "current_center_box", "[", ":", ",", "1", "]", "=", "np", ".", "clip", "(", "current_center_box", "[", ":", ",", "1", "]", ",", "0", ",", "\n", "h", "-", "1", ")", "\n", "min_coord", "=", "np", ".", "min", "(", "current_center_box", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "max_coord", "=", "np", ".", "max", "(", "current_center_box", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "current_center_box", "=", "current_center_box", "-", "min_coord", "\n", "box_sz", "=", "(", "max_coord", "-", "min_coord", "+", "1", ")", "\n", "\n", "center_box_mask", "=", "np", ".", "zeros", "(", "(", "box_sz", "[", "1", "]", ",", "box_sz", "[", "0", "]", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "cv2", ".", "fillPoly", "(", "center_box_mask", ",", "[", "current_center_box", "]", ",", "color", "=", "1", ")", "\n", "\n", "inds", "=", "np", ".", "argwhere", "(", "center_box_mask", ">", "0", ")", "\n", "inds", "=", "inds", "+", "(", "min_coord", "[", "1", "]", ",", "min_coord", "[", "0", "]", ")", "\n", "inds_xy", "=", "np", ".", "fliplr", "(", "inds", ")", "\n", "top_height_map", "[", "(", "inds", "[", ":", ",", "0", "]", ",", "inds", "[", ":", ",", "1", "]", ")", "]", "=", "self", ".", "dist_point2line", "(", "\n", "inds_xy", ",", "(", "top_line", "[", "i", "]", ",", "top_line", "[", "i", "+", "1", "]", ")", ")", "\n", "bot_height_map", "[", "(", "inds", "[", ":", ",", "0", "]", ",", "inds", "[", ":", ",", "1", "]", ")", "]", "=", "self", ".", "dist_point2line", "(", "\n", "inds_xy", ",", "(", "bot_line", "[", "i", "]", ",", "bot_line", "[", "i", "+", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_center_mask_attrib_maps": [[158, 237], ["isinstance", "mmocr.is_2dlist", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "poly[].reshape", "drrg_targets.DRRGTargets.reorder_poly_edge", "drrg_targets.DRRGTargets.resample_sidelines", "int", "int", "center_lines.append", "drrg_targets.DRRGTargets.draw_center_region_maps", "len", "drrg_targets.DRRGTargets.vector_slope", "numpy.clip", "numpy.clip", "len", "center_line.astype", "numpy.linalg.norm", "numpy.linalg.norm", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.reorder_poly_edge", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_sidelines", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.draw_center_region_maps", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_slope"], ["", "", "def", "generate_center_mask_attrib_maps", "(", "self", ",", "img_size", ",", "text_polys", ")", ":", "\n", "        ", "\"\"\"Generate text center region masks and geometric attribute maps.\n\n        Args:\n            img_size (tuple): The image size (height, width).\n            text_polys (list[list[ndarray]]): The list of text polygons.\n\n        Returns:\n            center_lines (list): The list of text center lines.\n            center_region_mask (ndarray): The text center region mask.\n            top_height_map (ndarray): The map on which the distance from points\n                to top side lines will be drawn for each pixel in text center\n                regions.\n            bot_height_map (ndarray): The map on which the distance from points\n                to bottom side lines will be drawn for each pixel in text\n                center regions.\n            sin_map (ndarray): The sin(theta) map where theta is the angle\n                between vector (top point - bottom point) and vector (1, 0).\n            cos_map (ndarray): The cos(theta) map where theta is the angle\n                between vector (top point - bottom point) and vector (1, 0).\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "text_polys", ")", "\n", "\n", "h", ",", "w", "=", "img_size", "\n", "\n", "center_lines", "=", "[", "]", "\n", "center_region_mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "np", ".", "uint8", ")", "\n", "top_height_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "bot_height_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "sin_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "cos_map", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "poly", "in", "text_polys", ":", "\n", "            ", "assert", "len", "(", "poly", ")", "==", "1", "\n", "polygon_points", "=", "poly", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "_", ",", "_", ",", "top_line", ",", "bot_line", "=", "self", ".", "reorder_poly_edge", "(", "polygon_points", ")", "\n", "resampled_top_line", ",", "resampled_bot_line", "=", "self", ".", "resample_sidelines", "(", "\n", "top_line", ",", "bot_line", ",", "self", ".", "resample_step", ")", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "center_line", "=", "(", "resampled_top_line", "+", "resampled_bot_line", ")", "/", "2", "\n", "\n", "if", "self", ".", "vector_slope", "(", "center_line", "[", "-", "1", "]", "-", "center_line", "[", "0", "]", ")", ">", "2", ":", "\n", "                ", "if", "(", "center_line", "[", "-", "1", "]", "-", "center_line", "[", "0", "]", ")", "[", "1", "]", "<", "0", ":", "\n", "                    ", "center_line", "=", "center_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "if", "(", "center_line", "[", "-", "1", "]", "-", "center_line", "[", "0", "]", ")", "[", "0", "]", "<", "0", ":", "\n", "                    ", "center_line", "=", "center_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", ":", ":", "-", "1", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "\n", "", "", "line_head_shrink_len", "=", "np", ".", "clip", "(", "\n", "(", "norm", "(", "top_line", "[", "0", "]", "-", "bot_line", "[", "0", "]", ")", "*", "self", ".", "comp_w_h_ratio", ")", ",", "\n", "self", ".", "min_width", ",", "self", ".", "max_width", ")", "/", "2", "\n", "line_tail_shrink_len", "=", "np", ".", "clip", "(", "\n", "(", "norm", "(", "top_line", "[", "-", "1", "]", "-", "bot_line", "[", "-", "1", "]", ")", "*", "self", ".", "comp_w_h_ratio", ")", ",", "\n", "self", ".", "min_width", ",", "self", ".", "max_width", ")", "/", "2", "\n", "num_head_shrink", "=", "int", "(", "line_head_shrink_len", "//", "self", ".", "resample_step", ")", "\n", "num_tail_shrink", "=", "int", "(", "line_tail_shrink_len", "//", "self", ".", "resample_step", ")", "\n", "if", "len", "(", "center_line", ")", ">", "num_head_shrink", "+", "num_tail_shrink", "+", "2", ":", "\n", "                ", "center_line", "=", "center_line", "[", "num_head_shrink", ":", "len", "(", "center_line", ")", "-", "\n", "num_tail_shrink", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", "\n", "num_head_shrink", ":", "len", "(", "resampled_top_line", ")", "-", "num_tail_shrink", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", "\n", "num_head_shrink", ":", "len", "(", "resampled_bot_line", ")", "-", "num_tail_shrink", "]", "\n", "", "center_lines", ".", "append", "(", "center_line", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "\n", "self", ".", "draw_center_region_maps", "(", "resampled_top_line", ",", "\n", "resampled_bot_line", ",", "center_line", ",", "\n", "center_region_mask", ",", "top_height_map", ",", "\n", "bot_height_map", ",", "sin_map", ",", "cos_map", ",", "\n", "self", ".", "center_region_shrink_ratio", ")", "\n", "\n", "", "return", "(", "center_lines", ",", "center_region_mask", ",", "top_height_map", ",", "\n", "bot_height_map", ",", "sin_map", ",", "cos_map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_rand_comp_attribs": [[238, 319], ["isinstance", "numpy.clip", "numpy.zeros_like", "int", "cv2.erode", "numpy.argwhere", "len", "numpy.random.choice", "numpy.random.randint", "numpy.random.randint", "numpy.sqrt", "numpy.clip", "numpy.hstack().astype", "int", "min", "max", "max", "numpy.clip", "numpy.clip", "numpy.ones", "numpy.sqrt", "min", "int", "numpy.random.random", "numpy.random.random", "numpy.hstack", "numpy.sqrt", "min", "numpy.sqrt", "len", "len", "numpy.zeros_like", "len", "len"], "methods", ["None"], ["", "def", "generate_rand_comp_attribs", "(", "self", ",", "num_rand_comps", ",", "center_sample_mask", ")", ":", "\n", "        ", "\"\"\"Generate random text components and their attributes to ensure the\n        the number of text components in an image is larger than k_hop1, which\n        is the number of one hop neighbors in KNN graph.\n\n        Args:\n            num_rand_comps (int): The number of random text components.\n            center_sample_mask (ndarray): The region mask for sampling text\n                component centers .\n\n        Returns:\n            rand_comp_attribs (ndarray): The random text component attributes\n                (x, y, h, w, cos, sin, comp_label=0).\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "num_rand_comps", ",", "int", ")", "\n", "assert", "num_rand_comps", ">", "0", "\n", "assert", "center_sample_mask", ".", "ndim", "==", "2", "\n", "\n", "h", ",", "w", "=", "center_sample_mask", ".", "shape", "\n", "\n", "max_rand_half_height", "=", "self", ".", "max_rand_half_height", "\n", "min_rand_half_height", "=", "self", ".", "min_rand_half_height", "\n", "max_rand_height", "=", "max_rand_half_height", "*", "2", "\n", "max_rand_width", "=", "np", ".", "clip", "(", "max_rand_height", "*", "self", ".", "comp_w_h_ratio", ",", "\n", "self", ".", "min_width", ",", "self", ".", "max_width", ")", "\n", "margin", "=", "int", "(", "\n", "np", ".", "sqrt", "(", "(", "max_rand_height", "/", "2", ")", "**", "2", "+", "(", "max_rand_width", "/", "2", ")", "**", "2", ")", ")", "+", "1", "\n", "\n", "if", "2", "*", "margin", "+", "1", ">", "min", "(", "h", ",", "w", ")", ":", "\n", "\n", "            ", "assert", "min", "(", "h", ",", "w", ")", ">", "(", "np", ".", "sqrt", "(", "2", ")", "*", "(", "self", ".", "min_width", "+", "1", ")", ")", "\n", "max_rand_half_height", "=", "max", "(", "min", "(", "h", ",", "w", ")", "/", "4", ",", "self", ".", "min_width", "/", "2", "+", "1", ")", "\n", "min_rand_half_height", "=", "max", "(", "max_rand_half_height", "/", "4", ",", "\n", "self", ".", "min_width", "/", "2", ")", "\n", "\n", "max_rand_height", "=", "max_rand_half_height", "*", "2", "\n", "max_rand_width", "=", "np", ".", "clip", "(", "max_rand_height", "*", "self", ".", "comp_w_h_ratio", ",", "\n", "self", ".", "min_width", ",", "self", ".", "max_width", ")", "\n", "margin", "=", "int", "(", "\n", "np", ".", "sqrt", "(", "(", "max_rand_height", "/", "2", ")", "**", "2", "+", "\n", "(", "max_rand_width", "/", "2", ")", "**", "2", ")", ")", "+", "1", "\n", "\n", "", "inner_center_sample_mask", "=", "np", ".", "zeros_like", "(", "center_sample_mask", ")", "\n", "inner_center_sample_mask", "[", "margin", ":", "h", "-", "margin", ",", "margin", ":", "w", "-", "margin", "]", "=", "center_sample_mask", "[", "margin", ":", "h", "-", "margin", ",", "margin", ":", "w", "-", "margin", "]", "\n", "kernel_size", "=", "int", "(", "np", ".", "clip", "(", "max_rand_half_height", ",", "7", ",", "21", ")", ")", "\n", "inner_center_sample_mask", "=", "cv2", ".", "erode", "(", "\n", "inner_center_sample_mask", ",", "\n", "np", ".", "ones", "(", "(", "kernel_size", ",", "kernel_size", ")", ",", "np", ".", "uint8", ")", ")", "\n", "\n", "center_candidates", "=", "np", ".", "argwhere", "(", "inner_center_sample_mask", ">", "0", ")", "\n", "num_center_candidates", "=", "len", "(", "center_candidates", ")", "\n", "sample_inds", "=", "np", ".", "random", ".", "choice", "(", "num_center_candidates", ",", "num_rand_comps", ")", "\n", "rand_centers", "=", "center_candidates", "[", "sample_inds", "]", "\n", "\n", "rand_top_height", "=", "np", ".", "random", ".", "randint", "(", "\n", "min_rand_half_height", ",", "\n", "max_rand_half_height", ",", "\n", "size", "=", "(", "len", "(", "rand_centers", ")", ",", "1", ")", ")", "\n", "rand_bot_height", "=", "np", ".", "random", ".", "randint", "(", "\n", "min_rand_half_height", ",", "\n", "max_rand_half_height", ",", "\n", "size", "=", "(", "len", "(", "rand_centers", ")", ",", "1", ")", ")", "\n", "\n", "rand_cos", "=", "2", "*", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "rand_centers", ")", ",", "1", ")", ")", "-", "1", "\n", "rand_sin", "=", "2", "*", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "rand_centers", ")", ",", "1", ")", ")", "-", "1", "\n", "scale", "=", "np", ".", "sqrt", "(", "1.0", "/", "(", "rand_cos", "**", "2", "+", "rand_sin", "**", "2", "+", "1e-8", ")", ")", "\n", "rand_cos", "=", "rand_cos", "*", "scale", "\n", "rand_sin", "=", "rand_sin", "*", "scale", "\n", "\n", "height", "=", "(", "rand_top_height", "+", "rand_bot_height", ")", "\n", "width", "=", "np", ".", "clip", "(", "height", "*", "self", ".", "comp_w_h_ratio", ",", "self", ".", "min_width", ",", "\n", "self", ".", "max_width", ")", "\n", "\n", "rand_comp_attribs", "=", "np", ".", "hstack", "(", "[", "\n", "rand_centers", "[", ":", ",", ":", ":", "-", "1", "]", ",", "height", ",", "width", ",", "rand_cos", ",", "rand_sin", ",", "\n", "np", ".", "zeros_like", "(", "rand_sin", ")", "\n", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "return", "rand_comp_attribs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.jitter_comp_attribs": [[320, 367], ["isinstance", "comp_attribs[].reshape", "comp_attribs[].reshape", "comp_attribs[].reshape", "comp_attribs[].reshape", "comp_attribs[].reshape", "comp_attribs[].reshape", "comp_attribs[].reshape", "numpy.sqrt", "numpy.hstack", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "len", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "jitter_comp_attribs", "(", "self", ",", "comp_attribs", ",", "jitter_level", ")", ":", "\n", "        ", "\"\"\"Jitter text components attributes.\n\n        Args:\n            comp_attribs (ndarray): The text component attributes.\n            jitter_level (float): The jitter level of text components\n                attributes.\n\n        Returns:\n            jittered_comp_attribs (ndarray): The jittered text component\n                attributes (x, y, h, w, cos, sin, comp_label).\n        \"\"\"", "\n", "\n", "assert", "comp_attribs", ".", "shape", "[", "1", "]", "==", "7", "\n", "assert", "comp_attribs", ".", "shape", "[", "0", "]", ">", "0", "\n", "assert", "isinstance", "(", "jitter_level", ",", "float", ")", "\n", "\n", "x", "=", "comp_attribs", "[", ":", ",", "0", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "y", "=", "comp_attribs", "[", ":", ",", "1", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "h", "=", "comp_attribs", "[", ":", ",", "2", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "w", "=", "comp_attribs", "[", ":", ",", "3", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "cos", "=", "comp_attribs", "[", ":", ",", "4", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "sin", "=", "comp_attribs", "[", ":", ",", "5", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "comp_labels", "=", "comp_attribs", "[", ":", ",", "6", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "x", "+=", "(", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "comp_attribs", ")", ",", "1", ")", ")", "-", "\n", "0.5", ")", "*", "(", "h", "*", "np", ".", "abs", "(", "cos", ")", "+", "w", "*", "np", ".", "abs", "(", "sin", ")", ")", "*", "jitter_level", "\n", "y", "+=", "(", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "comp_attribs", ")", ",", "1", ")", ")", "-", "\n", "0.5", ")", "*", "(", "h", "*", "np", ".", "abs", "(", "sin", ")", "+", "w", "*", "np", ".", "abs", "(", "cos", ")", ")", "*", "jitter_level", "\n", "\n", "h", "+=", "(", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "comp_attribs", ")", ",", "1", ")", ")", "-", "\n", "0.5", ")", "*", "h", "*", "jitter_level", "\n", "w", "+=", "(", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "comp_attribs", ")", ",", "1", ")", ")", "-", "\n", "0.5", ")", "*", "w", "*", "jitter_level", "\n", "\n", "cos", "+=", "(", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "comp_attribs", ")", ",", "1", ")", ")", "-", "\n", "0.5", ")", "*", "2", "*", "jitter_level", "\n", "sin", "+=", "(", "np", ".", "random", ".", "random", "(", "size", "=", "(", "len", "(", "comp_attribs", ")", ",", "1", ")", ")", "-", "\n", "0.5", ")", "*", "2", "*", "jitter_level", "\n", "\n", "scale", "=", "np", ".", "sqrt", "(", "1.0", "/", "(", "cos", "**", "2", "+", "sin", "**", "2", "+", "1e-8", ")", ")", "\n", "cos", "=", "cos", "*", "scale", "\n", "sin", "=", "sin", "*", "scale", "\n", "\n", "jittered_comp_attribs", "=", "np", ".", "hstack", "(", "[", "x", ",", "y", ",", "h", ",", "w", ",", "cos", ",", "sin", ",", "comp_labels", "]", ")", "\n", "\n", "return", "jittered_comp_attribs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_comp_attribs": [[368, 486], ["isinstance", "numpy.zeros_like", "cv2.polylines", "numpy.argwhere", "sin_map[].reshape", "cos_map[].reshape", "numpy.clip", "numpy.hstack().astype", "numpy.ones", "numpy.hstack", "lanms.merge_quadrangle_n9", "numpy.hstack", "numpy.zeros", "top_height_map[].reshape", "bot_height_map[].reshape", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.clip", "numpy.clip", "numpy.mean().astype", "numpy.clip", "cos_map[].reshape", "sin_map[].reshape", "cv2.connectedComponents", "comp_label_mask[].reshape().astype", "x.reshape().astype.reshape().astype.reshape().astype", "y.reshape().astype.reshape().astype.reshape().astype", "numpy.hstack", "drrg_targets.DRRGTargets.jitter_comp_attribs", "drrg_targets.DRRGTargets.generate_rand_comp_attribs", "numpy.ones", "numpy.hstack", "drrg_targets.DRRGTargets.generate_rand_comp_attribs", "numpy.vstack", "numpy.mean", "comp_label_mask[].reshape", "x.reshape().astype.reshape().astype.reshape", "y.reshape().astype.reshape().astype.reshape", "text_comps[].reshape"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.jitter_comp_attribs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_rand_comp_attribs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_rand_comp_attribs"], ["", "def", "generate_comp_attribs", "(", "self", ",", "center_lines", ",", "text_mask", ",", "\n", "center_region_mask", ",", "top_height_map", ",", "\n", "bot_height_map", ",", "sin_map", ",", "cos_map", ")", ":", "\n", "        ", "\"\"\"Generate text component attributes.\n\n        Args:\n            center_lines (list[ndarray]): The list of text center lines .\n            text_mask (ndarray): The text region mask.\n            center_region_mask (ndarray): The text center region mask.\n            top_height_map (ndarray): The map on which the distance from points\n                to top side lines will be drawn for each pixel in text center\n                regions.\n            bot_height_map (ndarray): The map on which the distance from points\n                to bottom side lines will be drawn for each pixel in text\n                center regions.\n            sin_map (ndarray): The sin(theta) map where theta is the angle\n                between vector (top point - bottom point) and vector (1, 0).\n            cos_map (ndarray): The cos(theta) map where theta is the angle\n                between vector (top point - bottom point) and vector (1, 0).\n\n        Returns:\n            pad_comp_attribs (ndarray): The padded text component attributes\n                of a fixed size.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "center_lines", ",", "list", ")", "\n", "assert", "(", "text_mask", ".", "shape", "==", "center_region_mask", ".", "shape", "==", "\n", "top_height_map", ".", "shape", "==", "bot_height_map", ".", "shape", "==", "sin_map", ".", "shape", "\n", "==", "cos_map", ".", "shape", ")", "\n", "\n", "center_lines_mask", "=", "np", ".", "zeros_like", "(", "center_region_mask", ")", "\n", "cv2", ".", "polylines", "(", "center_lines_mask", ",", "center_lines", ",", "0", ",", "1", ",", "1", ")", "\n", "center_lines_mask", "=", "center_lines_mask", "*", "center_region_mask", "\n", "comp_centers", "=", "np", ".", "argwhere", "(", "center_lines_mask", ">", "0", ")", "\n", "\n", "y", "=", "comp_centers", "[", ":", ",", "0", "]", "\n", "x", "=", "comp_centers", "[", ":", ",", "1", "]", "\n", "\n", "top_height", "=", "top_height_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "*", "self", ".", "comp_shrink_ratio", "\n", "bot_height", "=", "bot_height_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "*", "self", ".", "comp_shrink_ratio", "\n", "sin", "=", "sin_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "cos", "=", "cos_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "top_mid_points", "=", "comp_centers", "+", "np", ".", "hstack", "(", "\n", "[", "top_height", "*", "sin", ",", "top_height", "*", "cos", "]", ")", "\n", "bot_mid_points", "=", "comp_centers", "-", "np", ".", "hstack", "(", "\n", "[", "bot_height", "*", "sin", ",", "bot_height", "*", "cos", "]", ")", "\n", "\n", "width", "=", "(", "top_height", "+", "bot_height", ")", "*", "self", ".", "comp_w_h_ratio", "\n", "width", "=", "np", ".", "clip", "(", "width", ",", "self", ".", "min_width", ",", "self", ".", "max_width", ")", "\n", "r", "=", "width", "/", "2", "\n", "\n", "tl", "=", "top_mid_points", "[", ":", ",", ":", ":", "-", "1", "]", "-", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "tr", "=", "top_mid_points", "[", ":", ",", ":", ":", "-", "1", "]", "+", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "br", "=", "bot_mid_points", "[", ":", ",", ":", ":", "-", "1", "]", "+", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "bl", "=", "bot_mid_points", "[", ":", ",", ":", ":", "-", "1", "]", "-", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "text_comps", "=", "np", ".", "hstack", "(", "[", "tl", ",", "tr", ",", "br", ",", "bl", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "score", "=", "np", ".", "ones", "(", "(", "text_comps", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "text_comps", "=", "np", ".", "hstack", "(", "[", "text_comps", ",", "score", "]", ")", "\n", "text_comps", "=", "la_nms", "(", "text_comps", ",", "self", ".", "text_comp_nms_thr", ")", "\n", "\n", "if", "text_comps", ".", "shape", "[", "0", "]", ">=", "1", ":", "\n", "            ", "img_h", ",", "img_w", "=", "center_region_mask", ".", "shape", "\n", "text_comps", "[", ":", ",", "0", ":", "8", ":", "2", "]", "=", "np", ".", "clip", "(", "text_comps", "[", ":", ",", "0", ":", "8", ":", "2", "]", ",", "0", ",", "img_w", "-", "1", ")", "\n", "text_comps", "[", ":", ",", "1", ":", "8", ":", "2", "]", "=", "np", ".", "clip", "(", "text_comps", "[", ":", ",", "1", ":", "8", ":", "2", "]", ",", "0", ",", "img_h", "-", "1", ")", "\n", "\n", "comp_centers", "=", "np", ".", "mean", "(", "\n", "text_comps", "[", ":", ",", "0", ":", "8", "]", ".", "reshape", "(", "(", "-", "1", ",", "4", ",", "2", ")", ")", ",", "\n", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "x", "=", "comp_centers", "[", ":", ",", "0", "]", "\n", "y", "=", "comp_centers", "[", ":", ",", "1", "]", "\n", "\n", "height", "=", "(", "top_height_map", "[", "y", ",", "x", "]", "+", "bot_height_map", "[", "y", ",", "x", "]", ")", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "\n", "width", "=", "np", ".", "clip", "(", "height", "*", "self", ".", "comp_w_h_ratio", ",", "self", ".", "min_width", ",", "\n", "self", ".", "max_width", ")", "\n", "\n", "cos", "=", "cos_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "sin", "=", "sin_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "_", ",", "comp_label_mask", "=", "cv2", ".", "connectedComponents", "(", "\n", "center_region_mask", ",", "connectivity", "=", "8", ")", "\n", "comp_labels", "=", "comp_label_mask", "[", "y", ",", "x", "]", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "y", "=", "y", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "comp_attribs", "=", "np", ".", "hstack", "(", "\n", "[", "x", ",", "y", ",", "height", ",", "width", ",", "cos", ",", "sin", ",", "comp_labels", "]", ")", "\n", "comp_attribs", "=", "self", ".", "jitter_comp_attribs", "(", "comp_attribs", ",", "\n", "self", ".", "jitter_level", ")", "\n", "\n", "if", "comp_attribs", ".", "shape", "[", "0", "]", "<", "self", ".", "num_min_comps", ":", "\n", "                ", "num_rand_comps", "=", "self", ".", "num_min_comps", "-", "comp_attribs", ".", "shape", "[", "0", "]", "\n", "rand_comp_attribs", "=", "self", ".", "generate_rand_comp_attribs", "(", "\n", "num_rand_comps", ",", "1", "-", "text_mask", ")", "\n", "comp_attribs", "=", "np", ".", "vstack", "(", "[", "comp_attribs", ",", "rand_comp_attribs", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "comp_attribs", "=", "self", ".", "generate_rand_comp_attribs", "(", "\n", "self", ".", "num_min_comps", ",", "1", "-", "text_mask", ")", "\n", "\n", "", "num_comps", "=", "(", "\n", "np", ".", "ones", "(", "(", "comp_attribs", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "*", "\n", "comp_attribs", ".", "shape", "[", "0", "]", ")", "\n", "comp_attribs", "=", "np", ".", "hstack", "(", "[", "num_comps", ",", "comp_attribs", "]", ")", "\n", "\n", "if", "comp_attribs", ".", "shape", "[", "0", "]", ">", "self", ".", "num_max_comps", ":", "\n", "            ", "comp_attribs", "=", "comp_attribs", "[", ":", "self", ".", "num_max_comps", ",", ":", "]", "\n", "comp_attribs", "[", ":", ",", "0", "]", "=", "self", ".", "num_max_comps", "\n", "\n", "", "pad_comp_attribs", "=", "np", ".", "zeros", "(", "\n", "(", "self", ".", "num_max_comps", ",", "comp_attribs", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "pad_comp_attribs", "[", ":", "comp_attribs", ".", "shape", "[", "0", "]", ",", ":", "]", "=", "comp_attribs", "\n", "\n", "return", "pad_comp_attribs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_targets": [[487, 535], ["isinstance", "drrg_targets.DRRGTargets.generate_text_region_mask", "drrg_targets.DRRGTargets.generate_effective_mask", "drrg_targets.DRRGTargets.generate_center_mask_attrib_maps", "drrg_targets.DRRGTargets.generate_comp_attribs", "results[].clear", "mapping.items", "mmdet.core.BitmapMasks", "results[].append", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_text_region_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_center_mask_attrib_maps", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_comp_attribs"], ["", "def", "generate_targets", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Generate the gt targets for DRRG.\n\n        Args:\n            results (dict): The input result dictionary.\n\n        Returns:\n            results (dict): The output result dictionary.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "results", ",", "dict", ")", "\n", "\n", "polygon_masks", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "polygon_masks_ignore", "=", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "\n", "\n", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "\n", "gt_text_mask", "=", "self", ".", "generate_text_region_mask", "(", "(", "h", ",", "w", ")", ",", "polygon_masks", ")", "\n", "gt_mask", "=", "self", ".", "generate_effective_mask", "(", "(", "h", ",", "w", ")", ",", "polygon_masks_ignore", ")", "\n", "(", "center_lines", ",", "gt_center_region_mask", ",", "gt_top_height_map", ",", "\n", "gt_bot_height_map", ",", "gt_sin_map", ",", "\n", "gt_cos_map", ")", "=", "self", ".", "generate_center_mask_attrib_maps", "(", "(", "h", ",", "w", ")", ",", "\n", "polygon_masks", ")", "\n", "\n", "gt_comp_attribs", "=", "self", ".", "generate_comp_attribs", "(", "center_lines", ",", "\n", "gt_text_mask", ",", "\n", "gt_center_region_mask", ",", "\n", "gt_top_height_map", ",", "\n", "gt_bot_height_map", ",", "\n", "gt_sin_map", ",", "gt_cos_map", ")", "\n", "\n", "results", "[", "'mask_fields'", "]", ".", "clear", "(", ")", "# rm gt_masks encoded by polygons", "\n", "mapping", "=", "{", "\n", "'gt_text_mask'", ":", "gt_text_mask", ",", "\n", "'gt_center_region_mask'", ":", "gt_center_region_mask", ",", "\n", "'gt_mask'", ":", "gt_mask", ",", "\n", "'gt_top_height_map'", ":", "gt_top_height_map", ",", "\n", "'gt_bot_height_map'", ":", "gt_bot_height_map", ",", "\n", "'gt_sin_map'", ":", "gt_sin_map", ",", "\n", "'gt_cos_map'", ":", "gt_cos_map", "\n", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "value", "=", "value", "if", "isinstance", "(", "value", ",", "list", ")", "else", "[", "value", "]", "\n", "results", "[", "key", "]", "=", "BitmapMasks", "(", "value", ",", "h", ",", "w", ")", "\n", "results", "[", "'mask_fields'", "]", ".", "append", "(", "key", ")", "\n", "\n", "", "results", "[", "'gt_comp_attribs'", "]", "=", "gt_comp_attribs", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.__init__": [[30, 46], ["textsnake_targets.TextSnakeTargets.__init__", "isinstance", "isinstance", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "fourier_degree", "=", "5", ",", "\n", "resample_step", "=", "4.0", ",", "\n", "center_region_shrink_ratio", "=", "0.3", ",", "\n", "level_size_divisors", "=", "(", "8", ",", "16", ",", "32", ")", ",", "\n", "level_proportion_range", "=", "(", "(", "0", ",", "0.4", ")", ",", "(", "0.3", ",", "0.7", ")", ",", "(", "0.6", ",", "1.0", ")", ")", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "level_size_divisors", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "level_proportion_range", ",", "tuple", ")", "\n", "assert", "len", "(", "level_size_divisors", ")", "==", "len", "(", "level_proportion_range", ")", "\n", "self", ".", "fourier_degree", "=", "fourier_degree", "\n", "self", ".", "resample_step", "=", "resample_step", "\n", "self", ".", "center_region_shrink_ratio", "=", "center_region_shrink_ratio", "\n", "self", ".", "level_size_divisors", "=", "level_size_divisors", "\n", "self", ".", "level_proportion_range", "=", "level_proportion_range", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_center_region_mask": [[47, 106], ["isinstance", "mmocr.is_2dlist", "numpy.zeros", "cv2.fillPoly", "poly[].reshape", "fcenet_targets.FCENetTargets.reorder_poly_edge", "fcenet_targets.FCENetTargets.resample_sidelines", "int", "int", "range", "len", "numpy.linalg.norm", "numpy.linalg.norm", "len", "numpy.vstack().astype", "center_region_boxes.append", "len", "numpy.vstack", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.reorder_poly_edge", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_sidelines"], ["", "def", "generate_center_region_mask", "(", "self", ",", "img_size", ",", "text_polys", ")", ":", "\n", "        ", "\"\"\"Generate text center region mask.\n\n        Args:\n            img_size (tuple): The image size of (height, width).\n            text_polys (list[list[ndarray]]): The list of text polygons.\n\n        Returns:\n            center_region_mask (ndarray): The text center region mask.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "text_polys", ")", "\n", "\n", "h", ",", "w", "=", "img_size", "\n", "\n", "center_region_mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "np", ".", "uint8", ")", "\n", "\n", "center_region_boxes", "=", "[", "]", "\n", "for", "poly", "in", "text_polys", ":", "\n", "            ", "assert", "len", "(", "poly", ")", "==", "1", "\n", "polygon_points", "=", "poly", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "_", ",", "_", ",", "top_line", ",", "bot_line", "=", "self", ".", "reorder_poly_edge", "(", "polygon_points", ")", "\n", "resampled_top_line", ",", "resampled_bot_line", "=", "self", ".", "resample_sidelines", "(", "\n", "top_line", ",", "bot_line", ",", "self", ".", "resample_step", ")", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", ":", ":", "-", "1", "]", "\n", "center_line", "=", "(", "resampled_top_line", "+", "resampled_bot_line", ")", "/", "2", "\n", "\n", "line_head_shrink_len", "=", "norm", "(", "resampled_top_line", "[", "0", "]", "-", "\n", "resampled_bot_line", "[", "0", "]", ")", "/", "4.0", "\n", "line_tail_shrink_len", "=", "norm", "(", "resampled_top_line", "[", "-", "1", "]", "-", "\n", "resampled_bot_line", "[", "-", "1", "]", ")", "/", "4.0", "\n", "head_shrink_num", "=", "int", "(", "line_head_shrink_len", "//", "self", ".", "resample_step", ")", "\n", "tail_shrink_num", "=", "int", "(", "line_tail_shrink_len", "//", "self", ".", "resample_step", ")", "\n", "if", "len", "(", "center_line", ")", ">", "head_shrink_num", "+", "tail_shrink_num", "+", "2", ":", "\n", "                ", "center_line", "=", "center_line", "[", "head_shrink_num", ":", "len", "(", "center_line", ")", "-", "\n", "tail_shrink_num", "]", "\n", "resampled_top_line", "=", "resampled_top_line", "[", "\n", "head_shrink_num", ":", "len", "(", "resampled_top_line", ")", "-", "tail_shrink_num", "]", "\n", "resampled_bot_line", "=", "resampled_bot_line", "[", "\n", "head_shrink_num", ":", "len", "(", "resampled_bot_line", ")", "-", "tail_shrink_num", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "len", "(", "center_line", ")", "-", "1", ")", ":", "\n", "                ", "tl", "=", "center_line", "[", "i", "]", "+", "(", "resampled_top_line", "[", "i", "]", "-", "center_line", "[", "i", "]", "\n", ")", "*", "self", ".", "center_region_shrink_ratio", "\n", "tr", "=", "center_line", "[", "i", "+", "1", "]", "+", "(", "\n", "resampled_top_line", "[", "i", "+", "1", "]", "-", "\n", "center_line", "[", "i", "+", "1", "]", ")", "*", "self", ".", "center_region_shrink_ratio", "\n", "br", "=", "center_line", "[", "i", "+", "1", "]", "+", "(", "\n", "resampled_bot_line", "[", "i", "+", "1", "]", "-", "\n", "center_line", "[", "i", "+", "1", "]", ")", "*", "self", ".", "center_region_shrink_ratio", "\n", "bl", "=", "center_line", "[", "i", "]", "+", "(", "resampled_bot_line", "[", "i", "]", "-", "center_line", "[", "i", "]", "\n", ")", "*", "self", ".", "center_region_shrink_ratio", "\n", "current_center_box", "=", "np", ".", "vstack", "(", "[", "tl", ",", "tr", ",", "br", ",", "\n", "bl", "]", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "center_region_boxes", ".", "append", "(", "current_center_box", ")", "\n", "\n", "", "", "cv2", ".", "fillPoly", "(", "center_region_mask", ",", "center_region_boxes", ",", "1", ")", "\n", "return", "center_region_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.resample_polygon": [[107, 148], ["range", "sum", "n_on_each_line.astype.astype.astype", "range", "numpy.array", "len", "length.append", "len", "range", "numpy.array", "new_polygon.append", "len", "len"], "methods", ["None"], ["", "def", "resample_polygon", "(", "self", ",", "polygon", ",", "n", "=", "400", ")", ":", "\n", "        ", "\"\"\"Resample one polygon with n points on its boundary.\n\n        Args:\n            polygon (list[float]): The input polygon.\n            n (int): The number of resampled points.\n        Returns:\n            resampled_polygon (list[float]): The resampled polygon.\n        \"\"\"", "\n", "length", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "polygon", ")", ")", ":", "\n", "            ", "p1", "=", "polygon", "[", "i", "]", "\n", "if", "i", "==", "len", "(", "polygon", ")", "-", "1", ":", "\n", "                ", "p2", "=", "polygon", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "p2", "=", "polygon", "[", "i", "+", "1", "]", "\n", "", "length", ".", "append", "(", "(", "(", "p1", "[", "0", "]", "-", "p2", "[", "0", "]", ")", "**", "2", "+", "(", "p1", "[", "1", "]", "-", "p2", "[", "1", "]", ")", "**", "2", ")", "**", "0.5", ")", "\n", "\n", "", "total_length", "=", "sum", "(", "length", ")", "\n", "n_on_each_line", "=", "(", "np", ".", "array", "(", "length", ")", "/", "(", "total_length", "+", "1e-8", ")", ")", "*", "n", "\n", "n_on_each_line", "=", "n_on_each_line", ".", "astype", "(", "np", ".", "int32", ")", "\n", "new_polygon", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "polygon", ")", ")", ":", "\n", "            ", "num", "=", "n_on_each_line", "[", "i", "]", "\n", "p1", "=", "polygon", "[", "i", "]", "\n", "if", "i", "==", "len", "(", "polygon", ")", "-", "1", ":", "\n", "                ", "p2", "=", "polygon", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "p2", "=", "polygon", "[", "i", "+", "1", "]", "\n", "\n", "", "if", "num", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "dxdy", "=", "(", "p2", "-", "p1", ")", "/", "num", "\n", "for", "j", "in", "range", "(", "num", ")", ":", "\n", "                ", "point", "=", "p1", "+", "dxdy", "*", "j", "\n", "new_polygon", ".", "append", "(", "point", ")", "\n", "\n", "", "", "return", "np", ".", "array", "(", "new_polygon", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.normalize_polygon": [[149, 165], ["numpy.abs", "numpy.argsort", "numpy.argmin", "numpy.concatenate", "polygon.mean"], "methods", ["None"], ["", "def", "normalize_polygon", "(", "self", ",", "polygon", ")", ":", "\n", "        ", "\"\"\"Normalize one polygon so that its start point is at right most.\n\n        Args:\n            polygon (list[float]): The origin polygon.\n        Returns:\n            new_polygon (lost[float]): The polygon with start point at right.\n        \"\"\"", "\n", "temp_polygon", "=", "polygon", "-", "polygon", ".", "mean", "(", "axis", "=", "0", ")", "\n", "x", "=", "np", ".", "abs", "(", "temp_polygon", "[", ":", ",", "0", "]", ")", "\n", "y", "=", "temp_polygon", "[", ":", ",", "1", "]", "\n", "index_x", "=", "np", ".", "argsort", "(", "x", ")", "\n", "index_y", "=", "np", ".", "argmin", "(", "y", "[", "index_x", "[", ":", "8", "]", "]", ")", "\n", "index", "=", "index_x", "[", "index_y", "]", "\n", "new_polygon", "=", "np", ".", "concatenate", "(", "[", "polygon", "[", "index", ":", "]", ",", "polygon", "[", ":", "index", "]", "]", ")", "\n", "return", "new_polygon", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.poly2fourier": [[166, 180], ["numpy.hstack", "numpy.fft.fft", "len"], "methods", ["None"], ["", "def", "poly2fourier", "(", "self", ",", "polygon", ",", "fourier_degree", ")", ":", "\n", "        ", "\"\"\"Perform Fourier transformation to generate Fourier coefficients ck\n        from polygon.\n\n        Args:\n            polygon (ndarray): An input polygon.\n            fourier_degree (int): The maximum Fourier degree K.\n        Returns:\n            c (ndarray(complex)): Fourier coefficients.\n        \"\"\"", "\n", "points", "=", "polygon", "[", ":", ",", "0", "]", "+", "polygon", "[", ":", ",", "1", "]", "*", "1j", "\n", "c_fft", "=", "fft", "(", "points", ")", "/", "len", "(", "points", ")", "\n", "c", "=", "np", ".", "hstack", "(", "(", "c_fft", "[", "-", "fourier_degree", ":", "]", ",", "c_fft", "[", ":", "fourier_degree", "+", "1", "]", ")", ")", "\n", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.clockwise": [[181, 199], ["numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs"], "methods", ["None"], ["", "def", "clockwise", "(", "self", ",", "c", ",", "fourier_degree", ")", ":", "\n", "        ", "\"\"\"Make sure the polygon reconstructed from Fourier coefficients c in\n        the clockwise direction.\n\n        Args:\n            polygon (list[float]): The origin polygon.\n        Returns:\n            new_polygon (lost[float]): The polygon in clockwise point order.\n        \"\"\"", "\n", "if", "np", ".", "abs", "(", "c", "[", "fourier_degree", "+", "1", "]", ")", ">", "np", ".", "abs", "(", "c", "[", "fourier_degree", "-", "1", "]", ")", ":", "\n", "            ", "return", "c", "\n", "", "elif", "np", ".", "abs", "(", "c", "[", "fourier_degree", "+", "1", "]", ")", "<", "np", ".", "abs", "(", "c", "[", "fourier_degree", "-", "1", "]", ")", ":", "\n", "            ", "return", "c", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "if", "np", ".", "abs", "(", "c", "[", "fourier_degree", "+", "2", "]", ")", ">", "np", ".", "abs", "(", "c", "[", "fourier_degree", "-", "2", "]", ")", ":", "\n", "                ", "return", "c", "\n", "", "else", ":", "\n", "                ", "return", "c", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.cal_fourier_signature": [[200, 221], ["fcenet_targets.FCENetTargets.resample_polygon", "fcenet_targets.FCENetTargets.normalize_polygon", "fcenet_targets.FCENetTargets.poly2fourier", "fcenet_targets.FCENetTargets.clockwise", "numpy.real().reshape", "numpy.imag().reshape", "numpy.hstack", "numpy.real", "numpy.imag"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.resample_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.normalize_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.poly2fourier", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.clockwise"], ["", "", "", "def", "cal_fourier_signature", "(", "self", ",", "polygon", ",", "fourier_degree", ")", ":", "\n", "        ", "\"\"\"Calculate Fourier signature from input polygon.\n\n        Args:\n              polygon (ndarray): The input polygon.\n              fourier_degree (int): The maximum Fourier degree K.\n        Returns:\n              fourier_signature (ndarray): An array shaped (2k+1, 2) containing\n                  real part and image part of 2k+1 Fourier coefficients.\n        \"\"\"", "\n", "resampled_polygon", "=", "self", ".", "resample_polygon", "(", "polygon", ")", "\n", "resampled_polygon", "=", "self", ".", "normalize_polygon", "(", "resampled_polygon", ")", "\n", "\n", "fourier_coeff", "=", "self", ".", "poly2fourier", "(", "resampled_polygon", ",", "fourier_degree", ")", "\n", "fourier_coeff", "=", "self", ".", "clockwise", "(", "fourier_coeff", ",", "fourier_degree", ")", "\n", "\n", "real_part", "=", "np", ".", "real", "(", "fourier_coeff", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "image_part", "=", "np", ".", "imag", "(", "fourier_coeff", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "fourier_signature", "=", "np", ".", "hstack", "(", "[", "real_part", ",", "image_part", "]", ")", "\n", "\n", "return", "fourier_signature", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_fourier_maps": [[222, 265], ["isinstance", "mmocr.is_2dlist", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.array().reshape", "cv2.fillPoly", "fcenet_targets.FCENetTargets.cal_fourier_signature", "range", "len", "numpy.array().reshape.astype", "range", "numpy.array", "numpy.argwhere", "len", "numpy.ones", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.cal_fourier_signature"], ["", "def", "generate_fourier_maps", "(", "self", ",", "img_size", ",", "text_polys", ")", ":", "\n", "        ", "\"\"\"Generate Fourier coefficient maps.\n\n        Args:\n            img_size (tuple): The image size of (height, width).\n            text_polys (list[list[ndarray]]): The list of text polygons.\n\n        Returns:\n            fourier_real_map (ndarray): The Fourier coefficient real part maps.\n            fourier_image_map (ndarray): The Fourier coefficient image part\n                maps.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "text_polys", ")", "\n", "\n", "h", ",", "w", "=", "img_size", "\n", "k", "=", "self", ".", "fourier_degree", "\n", "real_map", "=", "np", ".", "zeros", "(", "(", "k", "*", "2", "+", "1", ",", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "imag_map", "=", "np", ".", "zeros", "(", "(", "k", "*", "2", "+", "1", ",", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "for", "poly", "in", "text_polys", ":", "\n", "            ", "assert", "len", "(", "poly", ")", "==", "1", "\n", "text_instance", "=", "[", "[", "poly", "[", "0", "]", "[", "i", "]", ",", "poly", "[", "0", "]", "[", "i", "+", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "poly", "[", "0", "]", ")", ",", "2", ")", "]", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "polygon", "=", "np", ".", "array", "(", "text_instance", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ",", "2", ")", ")", "\n", "cv2", ".", "fillPoly", "(", "mask", ",", "polygon", ".", "astype", "(", "np", ".", "int32", ")", ",", "1", ")", "\n", "fourier_coeff", "=", "self", ".", "cal_fourier_signature", "(", "polygon", "[", "0", "]", ",", "k", ")", "\n", "for", "i", "in", "range", "(", "-", "k", ",", "k", "+", "1", ")", ":", "\n", "                ", "if", "i", "!=", "0", ":", "\n", "                    ", "real_map", "[", "i", "+", "k", ",", ":", ",", ":", "]", "=", "mask", "*", "fourier_coeff", "[", "i", "+", "k", ",", "0", "]", "+", "(", "\n", "1", "-", "mask", ")", "*", "real_map", "[", "i", "+", "k", ",", ":", ",", ":", "]", "\n", "imag_map", "[", "i", "+", "k", ",", ":", ",", ":", "]", "=", "mask", "*", "fourier_coeff", "[", "i", "+", "k", ",", "1", "]", "+", "(", "\n", "1", "-", "mask", ")", "*", "imag_map", "[", "i", "+", "k", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "                    ", "yx", "=", "np", ".", "argwhere", "(", "mask", ">", "0.5", ")", "\n", "k_ind", "=", "np", ".", "ones", "(", "(", "len", "(", "yx", ")", ")", ",", "dtype", "=", "np", ".", "int64", ")", "*", "k", "\n", "y", ",", "x", "=", "yx", "[", ":", ",", "0", "]", ",", "yx", "[", ":", ",", "1", "]", "\n", "real_map", "[", "k_ind", ",", "y", ",", "x", "]", "=", "fourier_coeff", "[", "k", ",", "0", "]", "-", "x", "\n", "imag_map", "[", "k_ind", ",", "y", ",", "x", "]", "=", "fourier_coeff", "[", "k", ",", "1", "]", "-", "y", "\n", "\n", "", "", "", "return", "real_map", ",", "imag_map", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_level_targets": [[266, 331], ["enumerate", "numpy.array().reshape", "cv2.boundingRect", "enumerate", "numpy.array().reshape", "cv2.boundingRect", "enumerate", "current_level_maps.append", "current_level_maps.append", "current_level_maps.append", "fcenet_targets.FCENetTargets.generate_fourier_maps", "current_level_maps.append", "current_level_maps.append", "level_maps.append", "range", "range", "len", "max", "len", "max", "fcenet_targets.FCENetTargets.generate_text_region_mask", "fcenet_targets.FCENetTargets.generate_center_region_mask", "fcenet_targets.FCENetTargets.generate_effective_mask", "numpy.concatenate", "len", "len", "range", "numpy.array", "lv_text_polys[].append", "range", "numpy.array", "lv_ignore_polys[].append", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_fourier_maps", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_text_region_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_center_region_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask"], ["", "def", "generate_level_targets", "(", "self", ",", "img_size", ",", "text_polys", ",", "ignore_polys", ")", ":", "\n", "        ", "\"\"\"Generate ground truth target on each level.\n\n        Args:\n            img_size (list[int]): Shape of input image.\n            text_polys (list[list[ndarray]]): A list of ground truth polygons.\n            ignore_polys (list[list[ndarray]]): A list of ignored polygons.\n        Returns:\n            level_maps (list(ndarray)): A list of ground target on each level.\n        \"\"\"", "\n", "h", ",", "w", "=", "img_size", "\n", "lv_size_divs", "=", "self", ".", "level_size_divisors", "\n", "lv_proportion_range", "=", "self", ".", "level_proportion_range", "\n", "lv_text_polys", "=", "[", "[", "]", "for", "i", "in", "range", "(", "len", "(", "lv_size_divs", ")", ")", "]", "\n", "lv_ignore_polys", "=", "[", "[", "]", "for", "i", "in", "range", "(", "len", "(", "lv_size_divs", ")", ")", "]", "\n", "level_maps", "=", "[", "]", "\n", "for", "poly", "in", "text_polys", ":", "\n", "            ", "assert", "len", "(", "poly", ")", "==", "1", "\n", "text_instance", "=", "[", "[", "poly", "[", "0", "]", "[", "i", "]", ",", "poly", "[", "0", "]", "[", "i", "+", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "poly", "[", "0", "]", ")", ",", "2", ")", "]", "\n", "polygon", "=", "np", ".", "array", "(", "text_instance", ",", "dtype", "=", "np", ".", "int", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ",", "2", ")", ")", "\n", "_", ",", "_", ",", "box_w", ",", "box_h", "=", "cv2", ".", "boundingRect", "(", "polygon", ")", "\n", "proportion", "=", "max", "(", "box_h", ",", "box_w", ")", "/", "(", "h", "+", "1e-8", ")", "\n", "\n", "for", "ind", ",", "proportion_range", "in", "enumerate", "(", "lv_proportion_range", ")", ":", "\n", "                ", "if", "proportion_range", "[", "0", "]", "<", "proportion", "<", "proportion_range", "[", "1", "]", ":", "\n", "                    ", "lv_text_polys", "[", "ind", "]", ".", "append", "(", "[", "poly", "[", "0", "]", "/", "lv_size_divs", "[", "ind", "]", "]", ")", "\n", "\n", "", "", "", "for", "ignore_poly", "in", "ignore_polys", ":", "\n", "            ", "assert", "len", "(", "ignore_poly", ")", "==", "1", "\n", "text_instance", "=", "[", "[", "ignore_poly", "[", "0", "]", "[", "i", "]", ",", "ignore_poly", "[", "0", "]", "[", "i", "+", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "ignore_poly", "[", "0", "]", ")", ",", "2", ")", "]", "\n", "polygon", "=", "np", ".", "array", "(", "text_instance", ",", "dtype", "=", "np", ".", "int", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ",", "2", ")", ")", "\n", "_", ",", "_", ",", "box_w", ",", "box_h", "=", "cv2", ".", "boundingRect", "(", "polygon", ")", "\n", "proportion", "=", "max", "(", "box_h", ",", "box_w", ")", "/", "(", "h", "+", "1e-8", ")", "\n", "\n", "for", "ind", ",", "proportion_range", "in", "enumerate", "(", "lv_proportion_range", ")", ":", "\n", "                ", "if", "proportion_range", "[", "0", "]", "<", "proportion", "<", "proportion_range", "[", "1", "]", ":", "\n", "                    ", "lv_ignore_polys", "[", "ind", "]", ".", "append", "(", "\n", "[", "ignore_poly", "[", "0", "]", "/", "lv_size_divs", "[", "ind", "]", "]", ")", "\n", "\n", "", "", "", "for", "ind", ",", "size_divisor", "in", "enumerate", "(", "lv_size_divs", ")", ":", "\n", "            ", "current_level_maps", "=", "[", "]", "\n", "level_img_size", "=", "(", "h", "//", "size_divisor", ",", "w", "//", "size_divisor", ")", "\n", "\n", "text_region", "=", "self", ".", "generate_text_region_mask", "(", "\n", "level_img_size", ",", "lv_text_polys", "[", "ind", "]", ")", "[", "None", "]", "\n", "current_level_maps", ".", "append", "(", "text_region", ")", "\n", "\n", "center_region", "=", "self", ".", "generate_center_region_mask", "(", "\n", "level_img_size", ",", "lv_text_polys", "[", "ind", "]", ")", "[", "None", "]", "\n", "current_level_maps", ".", "append", "(", "center_region", ")", "\n", "\n", "effective_mask", "=", "self", ".", "generate_effective_mask", "(", "\n", "level_img_size", ",", "lv_ignore_polys", "[", "ind", "]", ")", "[", "None", "]", "\n", "current_level_maps", ".", "append", "(", "effective_mask", ")", "\n", "\n", "fourier_real_map", ",", "fourier_image_maps", "=", "self", ".", "generate_fourier_maps", "(", "\n", "level_img_size", ",", "lv_text_polys", "[", "ind", "]", ")", "\n", "current_level_maps", ".", "append", "(", "fourier_real_map", ")", "\n", "current_level_maps", ".", "append", "(", "fourier_image_maps", ")", "\n", "\n", "level_maps", ".", "append", "(", "np", ".", "concatenate", "(", "current_level_maps", ")", ")", "\n", "\n", "", "return", "level_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_targets": [[332, 362], ["isinstance", "fcenet_targets.FCENetTargets.generate_level_targets", "results[].clear", "mapping.items"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_level_targets"], ["", "def", "generate_targets", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Generate the ground truth targets for FCENet.\n\n        Args:\n            results (dict): The input result dictionary.\n\n        Returns:\n            results (dict): The output result dictionary.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "results", ",", "dict", ")", "\n", "\n", "polygon_masks", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "polygon_masks_ignore", "=", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "\n", "\n", "h", ",", "w", ",", "_", "=", "results", "[", "'img_shape'", "]", "\n", "\n", "level_maps", "=", "self", ".", "generate_level_targets", "(", "(", "h", ",", "w", ")", ",", "polygon_masks", ",", "\n", "polygon_masks_ignore", ")", "\n", "\n", "results", "[", "'mask_fields'", "]", ".", "clear", "(", ")", "# rm gt_masks encoded by polygons", "\n", "mapping", "=", "{", "\n", "'p3_maps'", ":", "level_maps", "[", "0", "]", ",", "\n", "'p4_maps'", ":", "level_maps", "[", "1", "]", ",", "\n", "'p5_maps'", ":", "level_maps", "[", "2", "]", "\n", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "results", "[", "key", "]", "=", "value", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector": [[19, 57], ["isinstance", "mmcv.Config.fromfile.model.get", "mmocr.models.build_detector", "mmocr.models.build_detector.to", "mmocr.models.build_detector.eval", "mmcv.Config.fromfile", "mmcv.Config.fromfile.merge_from_dict", "mmcv.runner.load_checkpoint", "isinstance", "TypeError", "mmcv.Config.fromfile.get", "mmcv.runner.load_checkpoint.get", "warnings.simplefilter", "warnings.warn", "mmdet.core.get_classes", "type"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["def", "init_detector", "(", "config", ",", "checkpoint", "=", "None", ",", "device", "=", "'cuda:0'", ",", "cfg_options", "=", "None", ")", ":", "\n", "    ", "\"\"\"Initialize a detector from config file.\n\n    Args:\n        config (str or :obj:`mmcv.Config`): Config file path or the config\n            object.\n        checkpoint (str, optional): Checkpoint path. If left as None, the model\n            will not load any weights.\n        cfg_options (dict): Options to override some settings in the used\n            config.\n\n    Returns:\n        nn.Module: The constructed detector.\n    \"\"\"", "\n", "if", "isinstance", "(", "config", ",", "str", ")", ":", "\n", "        ", "config", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "config", ")", "\n", "", "elif", "not", "isinstance", "(", "config", ",", "mmcv", ".", "Config", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'config must be a filename or Config object, '", "\n", "f'but got {type(config)}'", ")", "\n", "", "if", "cfg_options", "is", "not", "None", ":", "\n", "        ", "config", ".", "merge_from_dict", "(", "cfg_options", ")", "\n", "", "if", "config", ".", "model", ".", "get", "(", "'pretrained'", ")", ":", "\n", "        ", "config", ".", "model", ".", "pretrained", "=", "None", "\n", "", "config", ".", "model", ".", "train_cfg", "=", "None", "\n", "model", "=", "build_detector", "(", "config", ".", "model", ",", "test_cfg", "=", "config", ".", "get", "(", "'test_cfg'", ")", ")", "\n", "if", "checkpoint", "is", "not", "None", ":", "\n", "        ", "checkpoint", "=", "load_checkpoint", "(", "model", ",", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "if", "'CLASSES'", "in", "checkpoint", ".", "get", "(", "'meta'", ",", "{", "}", ")", ":", "\n", "            ", "model", ".", "CLASSES", "=", "checkpoint", "[", "'meta'", "]", "[", "'CLASSES'", "]", "\n", "", "else", ":", "\n", "            ", "warnings", ".", "simplefilter", "(", "'once'", ")", "\n", "warnings", ".", "warn", "(", "'Class names are not saved in the checkpoint\\'s '", "\n", "'meta data, use COCO classes by default.'", ")", "\n", "model", ".", "CLASSES", "=", "get_classes", "(", "'coco'", ")", "\n", "", "", "model", ".", "cfg", "=", "config", "# save the config in the model for convenience", "\n", "model", ".", "to", "(", "device", ")", "\n", "model", ".", "eval", "(", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference": [[59, 195], ["isinstance", "isinstance", "mmocr.utils.is_2dlist", "mmdet.datasets.replace_ImageToTensor", "mmdet.datasets.pipelines.Compose", "mmcv.parallel.collate", "isinstance", "isinstance", "isinstance", "utils.disable_text_recog_aug_test", "next", "cfg.copy.data.test.get", "mmocr.utils.is_2dlist", "cfg.copy.copy", "mmdet.datasets.pipelines.Compose.", "datas.append", "isinstance", "Exception", "isinstance", "next", "model.modules", "torch.no_grad", "model", "len", "Exception", "isinstance", "AssertionError", "AssertionError", "model.parameters", "dict", "dict", "dict.update", "len", "len", "model.parameters", "mmcv.parallel.scatter", "dict", "dict.items", "isinstance", "dict", "dict", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "model_inference", "(", "model", ",", "\n", "imgs", ",", "\n", "ann", "=", "None", ",", "\n", "batch_mode", "=", "False", ",", "\n", "return_data", "=", "False", ")", ":", "\n", "    ", "\"\"\"Inference image(s) with the detector.\n\n    Args:\n        model (nn.Module): The loaded detector.\n        imgs (str/ndarray or list[str/ndarray] or tuple[str/ndarray]):\n            Either image files or loaded images.\n        batch_mode (bool): If True, use batch mode for inference.\n        ann (dict): Annotation info for key information extraction.\n        return_data: Return postprocessed data.\n    Returns:\n        result (dict): Predicted results.\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "imgs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "is_batch", "=", "True", "\n", "if", "len", "(", "imgs", ")", "==", "0", ":", "\n", "            ", "raise", "Exception", "(", "'empty imgs provided, please check and try again'", ")", "\n", "", "if", "not", "isinstance", "(", "imgs", "[", "0", "]", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "'imgs must be strings or numpy arrays'", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "imgs", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", ":", "\n", "        ", "imgs", "=", "[", "imgs", "]", "\n", "is_batch", "=", "False", "\n", "", "else", ":", "\n", "        ", "raise", "AssertionError", "(", "'imgs must be strings or numpy arrays'", ")", "\n", "\n", "", "is_ndarray", "=", "isinstance", "(", "imgs", "[", "0", "]", ",", "np", ".", "ndarray", ")", "\n", "\n", "cfg", "=", "model", ".", "cfg", "\n", "\n", "if", "batch_mode", ":", "\n", "        ", "cfg", "=", "disable_text_recog_aug_test", "(", "cfg", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "\n", "", "device", "=", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "device", "# model device", "\n", "\n", "if", "cfg", ".", "data", ".", "test", ".", "get", "(", "'pipeline'", ",", "None", ")", "is", "None", ":", "\n", "        ", "if", "is_2dlist", "(", "cfg", ".", "data", ".", "test", ".", "datasets", ")", ":", "\n", "            ", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "[", "0", "]", ".", "pipeline", "\n", "", "else", ":", "\n", "            ", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ".", "pipeline", "\n", "", "", "if", "is_2dlist", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", ":", "\n", "        ", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "0", "]", "\n", "\n", "", "if", "is_ndarray", ":", "\n", "        ", "cfg", "=", "cfg", ".", "copy", "(", ")", "\n", "# set loading pipeline type", "\n", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "0", "]", ".", "type", "=", "'LoadImageFromNdarray'", "\n", "\n", "", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "replace_ImageToTensor", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "test_pipeline", "=", "Compose", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "\n", "datas", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "# prepare data", "\n", "        ", "if", "is_ndarray", ":", "\n", "# directly add img", "\n", "            ", "data", "=", "dict", "(", "\n", "img", "=", "img", ",", "\n", "ann_info", "=", "ann", ",", "\n", "img_info", "=", "dict", "(", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "height", "=", "img", ".", "shape", "[", "0", "]", ")", ",", "\n", "bbox_fields", "=", "[", "]", ")", "\n", "", "else", ":", "\n", "# add information into dict", "\n", "            ", "data", "=", "dict", "(", "\n", "img_info", "=", "dict", "(", "filename", "=", "img", ")", ",", "\n", "img_prefix", "=", "None", ",", "\n", "ann_info", "=", "ann", ",", "\n", "bbox_fields", "=", "[", "]", ")", "\n", "", "if", "ann", "is", "not", "None", ":", "\n", "            ", "data", ".", "update", "(", "dict", "(", "**", "ann", ")", ")", "\n", "\n", "# build the data pipeline", "\n", "", "data", "=", "test_pipeline", "(", "data", ")", "\n", "# get tensor from list to stack for batch mode (text detection)", "\n", "if", "batch_mode", ":", "\n", "            ", "if", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "1", "]", ".", "type", "==", "'MultiScaleFlipAug'", ":", "\n", "                ", "for", "key", ",", "value", "in", "data", ".", "items", "(", ")", ":", "\n", "                    ", "data", "[", "key", "]", "=", "value", "[", "0", "]", "\n", "", "", "", "datas", ".", "append", "(", "data", ")", "\n", "\n", "", "if", "isinstance", "(", "datas", "[", "0", "]", "[", "'img'", "]", ",", "list", ")", "and", "len", "(", "datas", ")", ">", "1", ":", "\n", "        ", "raise", "Exception", "(", "'aug test does not support '", "\n", "f'inference with batch size '", "\n", "f'{len(datas)}'", ")", "\n", "\n", "", "data", "=", "collate", "(", "datas", ",", "samples_per_gpu", "=", "len", "(", "imgs", ")", ")", "\n", "\n", "# process img_metas", "\n", "if", "isinstance", "(", "data", "[", "'img_metas'", "]", ",", "list", ")", ":", "\n", "        ", "data", "[", "'img_metas'", "]", "=", "[", "\n", "img_metas", ".", "data", "[", "0", "]", "for", "img_metas", "in", "data", "[", "'img_metas'", "]", "\n", "]", "\n", "", "else", ":", "\n", "        ", "data", "[", "'img_metas'", "]", "=", "data", "[", "'img_metas'", "]", ".", "data", "\n", "\n", "", "if", "isinstance", "(", "data", "[", "'img'", "]", ",", "list", ")", ":", "\n", "        ", "data", "[", "'img'", "]", "=", "[", "img", ".", "data", "for", "img", "in", "data", "[", "'img'", "]", "]", "\n", "if", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "list", ")", ":", "\n", "            ", "data", "[", "'img'", "]", "=", "[", "img", "[", "0", "]", "for", "img", "in", "data", "[", "'img'", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "data", "[", "'img'", "]", "=", "data", "[", "'img'", "]", ".", "data", "\n", "\n", "# for KIE models", "\n", "", "if", "ann", "is", "not", "None", ":", "\n", "        ", "data", "[", "'relations'", "]", "=", "data", "[", "'relations'", "]", ".", "data", "[", "0", "]", "\n", "data", "[", "'gt_bboxes'", "]", "=", "data", "[", "'gt_bboxes'", "]", ".", "data", "[", "0", "]", "\n", "data", "[", "'texts'", "]", "=", "data", "[", "'texts'", "]", ".", "data", "[", "0", "]", "\n", "data", "[", "'img'", "]", "=", "data", "[", "'img'", "]", "[", "0", "]", "\n", "data", "[", "'img_metas'", "]", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", "\n", "\n", "", "if", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "is_cuda", ":", "\n", "# scatter to specified GPU", "\n", "        ", "data", "=", "scatter", "(", "data", ",", "[", "device", "]", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "            ", "assert", "not", "isinstance", "(", "\n", "m", ",", "RoIPool", "\n", ")", ",", "'CPU inference with RoIPool is not supported currently.'", "\n", "\n", "# forward the model", "\n", "", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "results", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "if", "not", "is_batch", ":", "\n", "        ", "if", "not", "return_data", ":", "\n", "            ", "return", "results", "[", "0", "]", "\n", "", "return", "results", "[", "0", "]", ",", "datas", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "if", "not", "return_data", ":", "\n", "            ", "return", "results", "\n", "", "return", "results", ",", "datas", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.text_model_inference": [[197, 239], ["isinstance", "mmocr.utils.is_2dlist", "mmdet.datasets.pipelines.Compose", "mmdet.datasets.pipelines.Compose.", "isinstance", "isinstance", "cfg.data.test.get", "mmocr.utils.is_2dlist", "img_metas[].unsqueeze", "img_metas[].unsqueeze", "img_metas[].unsqueeze", "img_metas[].unsqueeze", "torch.no_grad", "model"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "", "def", "text_model_inference", "(", "model", ",", "input_sentence", ")", ":", "\n", "    ", "\"\"\"Inference text(s) with the entity recognizer.\n\n    Args:\n        model (nn.Module): The loaded recognizer.\n        input_sentence (str): A text entered by the user.\n\n    Returns:\n        result (dict): Predicted results.\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "input_sentence", ",", "str", ")", "\n", "\n", "cfg", "=", "model", ".", "cfg", "\n", "if", "cfg", ".", "data", ".", "test", ".", "get", "(", "'pipeline'", ",", "None", ")", "is", "None", ":", "\n", "        ", "if", "is_2dlist", "(", "cfg", ".", "data", ".", "test", ".", "datasets", ")", ":", "\n", "            ", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "[", "0", "]", ".", "pipeline", "\n", "", "else", ":", "\n", "            ", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ".", "pipeline", "\n", "", "", "if", "is_2dlist", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", ":", "\n", "        ", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "0", "]", "\n", "", "test_pipeline", "=", "Compose", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "data", "=", "{", "'text'", ":", "input_sentence", ",", "'label'", ":", "{", "}", "}", "\n", "\n", "# build the data pipeline", "\n", "data", "=", "test_pipeline", "(", "data", ")", "\n", "if", "isinstance", "(", "data", "[", "'img_metas'", "]", ",", "dict", ")", ":", "\n", "        ", "img_metas", "=", "data", "[", "'img_metas'", "]", "\n", "", "else", ":", "\n", "        ", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "\n", "\n", "", "assert", "isinstance", "(", "img_metas", ",", "dict", ")", "\n", "img_metas", "=", "{", "\n", "'input_ids'", ":", "img_metas", "[", "'input_ids'", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'attention_masks'", ":", "img_metas", "[", "'attention_masks'", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'token_type_ids'", ":", "img_metas", "[", "'token_type_ids'", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'labels'", ":", "img_metas", "[", "'labels'", "]", ".", "unsqueeze", "(", "0", ")", "\n", "}", "\n", "# forward the model", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "result", "=", "model", "(", "None", ",", "img_metas", ",", "return_loss", "=", "False", ")", "\n", "", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.train.train_detector": [[21, 156], ["mmocr.utils.get_root_logger", "default_loader_cfg.update", "dict", "mmcv.runner.build_optimizer", "mmcv.runner.build_runner", "mmocr.apis.utils.replace_image_to_tensor.get", "mmcv.runner.build_runner.register_training_hooks", "mmcv.runner.build_runner.run", "isinstance", "dict", "mmdet.datasets.build_dataloader", "mmocr.apis.utils.replace_image_to_tensor.get", "mmcv.parallel.MMDistributedDataParallel", "mmcv.parallel.MMDataParallel", "warnings.warn", "mmcv.runner.Fp16OptimizerHook", "mmocr.apis.utils.replace_image_to_tensor.get", "isinstance", "mmocr.apis.utils.replace_image_to_tensor.data.get().get", "mmdet.datasets.build_dataset", "mmdet.datasets.build_dataloader", "mmocr.apis.utils.replace_image_to_tensor.get", "mmcv.runner.build_runner.register_hook", "mmcv.runner.build_runner.resume", "dict", "mmocr.apis.utils.replace_image_to_tensor.data.get", "mmcv.parallel.MMDataParallel.cuda", "torch.cuda.is_available", "torch.cuda.is_available", "dict", "mmcv.runner.OptimizerHook", "mmocr.apis.utils.replace_image_to_tensor.get", "mmcv.runner.build_runner.register_hook", "mmocr.apis.utils.replace_image_to_tensor.data.get", "mmocr.apis.utils.disable_text_recog_aug_test", "mmocr.apis.utils.replace_image_to_tensor", "dict", "dict", "mmocr.apis.utils.replace_image_to_tensor.data.get", "dict", "eval_hook", "mmcv.runner.build_runner.load_checkpoint", "len", "mmocr.apis.utils.replace_image_to_tensor.get", "mmocr.apis.utils.replace_image_to_tensor.data.items", "mmocr.digit_version", "mmocr.digit_version", "mmcv.runner.DistSamplerSeedHook", "mmocr.apis.utils.replace_image_to_tensor.data.get", "torch.cuda.current_device", "torch.cuda.current_device"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.replace_image_to_tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version"], ["def", "train_detector", "(", "model", ",", "\n", "dataset", ",", "\n", "cfg", ",", "\n", "distributed", "=", "False", ",", "\n", "validate", "=", "False", ",", "\n", "timestamp", "=", "None", ",", "\n", "meta", "=", "None", ")", ":", "\n", "    ", "logger", "=", "get_root_logger", "(", "cfg", ".", "log_level", ")", "\n", "\n", "# prepare data loaders", "\n", "dataset", "=", "dataset", "if", "isinstance", "(", "dataset", ",", "(", "list", ",", "tuple", ")", ")", "else", "[", "dataset", "]", "\n", "# step 1: give default values and override (if exist) from cfg.data", "\n", "default_loader_cfg", "=", "{", "\n", "**", "dict", "(", "\n", "num_gpus", "=", "len", "(", "cfg", ".", "gpu_ids", ")", ",", "\n", "dist", "=", "distributed", ",", "\n", "seed", "=", "cfg", ".", "get", "(", "'seed'", ")", ",", "\n", "drop_last", "=", "False", ",", "\n", "persistent_workers", "=", "False", ")", ",", "\n", "**", "(", "{", "}", "if", "torch", ".", "__version__", "!=", "'parrots'", "else", "dict", "(", "\n", "prefetch_num", "=", "2", ",", "\n", "pin_memory", "=", "False", ",", "\n", ")", ")", ",", "\n", "}", "\n", "# update overall dataloader(for train, val and test) setting", "\n", "default_loader_cfg", ".", "update", "(", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "cfg", ".", "data", ".", "items", "(", ")", "if", "k", "not", "in", "[", "\n", "'train'", ",", "'val'", ",", "'test'", ",", "'train_dataloader'", ",", "'val_dataloader'", ",", "\n", "'test_dataloader'", "\n", "]", "\n", "}", ")", "\n", "\n", "# step 2: cfg.data.train_dataloader has highest priority", "\n", "train_loader_cfg", "=", "dict", "(", "default_loader_cfg", ",", "\n", "**", "cfg", ".", "data", ".", "get", "(", "'train_dataloader'", ",", "{", "}", ")", ")", "\n", "\n", "data_loaders", "=", "[", "build_dataloader", "(", "ds", ",", "**", "train_loader_cfg", ")", "for", "ds", "in", "dataset", "]", "\n", "\n", "# put model on gpus", "\n", "if", "distributed", ":", "\n", "        ", "find_unused_parameters", "=", "cfg", ".", "get", "(", "'find_unused_parameters'", ",", "False", ")", "\n", "# Sets the `find_unused_parameters` parameter in", "\n", "# torch.nn.parallel.DistributedDataParallel", "\n", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ",", "\n", "find_unused_parameters", "=", "find_unused_parameters", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "assert", "digit_version", "(", "mmcv", ".", "__version__", ")", ">=", "digit_version", "(", "'1.4.4'", ")", ",", "'Please use MMCV >= 1.4.4 for CPU training!'", "\n", "", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "cfg", ".", "gpu_ids", ")", "\n", "\n", "# build runner", "\n", "", "optimizer", "=", "build_optimizer", "(", "model", ",", "cfg", ".", "optimizer", ")", "\n", "\n", "if", "'runner'", "not", "in", "cfg", ":", "\n", "        ", "cfg", ".", "runner", "=", "{", "\n", "'type'", ":", "'EpochBasedRunner'", ",", "\n", "'max_epochs'", ":", "cfg", ".", "total_epochs", "\n", "}", "\n", "warnings", ".", "warn", "(", "\n", "'config is now expected to have a `runner` section, '", "\n", "'please set `runner` in your config.'", ",", "UserWarning", ")", "\n", "", "else", ":", "\n", "        ", "if", "'total_epochs'", "in", "cfg", ":", "\n", "            ", "assert", "cfg", ".", "total_epochs", "==", "cfg", ".", "runner", ".", "max_epochs", "\n", "\n", "", "", "runner", "=", "build_runner", "(", "\n", "cfg", ".", "runner", ",", "\n", "default_args", "=", "dict", "(", "\n", "model", "=", "model", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "work_dir", "=", "cfg", ".", "work_dir", ",", "\n", "logger", "=", "logger", ",", "\n", "meta", "=", "meta", ")", ")", "\n", "\n", "# an ugly workaround to make .log and .log.json filenames the same", "\n", "runner", ".", "timestamp", "=", "timestamp", "\n", "\n", "# fp16 setting", "\n", "fp16_cfg", "=", "cfg", ".", "get", "(", "'fp16'", ",", "None", ")", "\n", "if", "fp16_cfg", "is", "not", "None", ":", "\n", "        ", "optimizer_config", "=", "Fp16OptimizerHook", "(", "\n", "**", "cfg", ".", "optimizer_config", ",", "**", "fp16_cfg", ",", "distributed", "=", "distributed", ")", "\n", "", "elif", "distributed", "and", "'type'", "not", "in", "cfg", ".", "optimizer_config", ":", "\n", "        ", "optimizer_config", "=", "OptimizerHook", "(", "**", "cfg", ".", "optimizer_config", ")", "\n", "", "else", ":", "\n", "        ", "optimizer_config", "=", "cfg", ".", "optimizer_config", "\n", "\n", "# register hooks", "\n", "", "runner", ".", "register_training_hooks", "(", "\n", "cfg", ".", "lr_config", ",", "\n", "optimizer_config", ",", "\n", "cfg", ".", "checkpoint_config", ",", "\n", "cfg", ".", "log_config", ",", "\n", "cfg", ".", "get", "(", "'momentum_config'", ",", "None", ")", ",", "\n", "custom_hooks_config", "=", "cfg", ".", "get", "(", "'custom_hooks'", ",", "None", ")", ")", "\n", "if", "distributed", ":", "\n", "        ", "if", "isinstance", "(", "runner", ",", "EpochBasedRunner", ")", ":", "\n", "            ", "runner", ".", "register_hook", "(", "DistSamplerSeedHook", "(", ")", ")", "\n", "\n", "# register eval hooks", "\n", "", "", "if", "validate", ":", "\n", "        ", "val_samples_per_gpu", "=", "(", "cfg", ".", "data", ".", "get", "(", "'val_dataloader'", ",", "{", "}", ")", ")", ".", "get", "(", "\n", "'samples_per_gpu'", ",", "cfg", ".", "data", ".", "get", "(", "'samples_per_gpu'", ",", "1", ")", ")", "\n", "if", "val_samples_per_gpu", ">", "1", ":", "\n", "# Support batch_size > 1 in test for text recognition", "\n", "# by disable MultiRotateAugOCR since it is useless for most case", "\n", "            ", "cfg", "=", "disable_text_recog_aug_test", "(", "cfg", ")", "\n", "cfg", "=", "replace_image_to_tensor", "(", "cfg", ")", "\n", "\n", "", "val_dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ",", "dict", "(", "test_mode", "=", "True", ")", ")", "\n", "\n", "val_loader_cfg", "=", "{", "\n", "**", "default_loader_cfg", ",", "\n", "**", "dict", "(", "shuffle", "=", "False", ",", "drop_last", "=", "False", ")", ",", "\n", "**", "cfg", ".", "data", ".", "get", "(", "'val_dataloader'", ",", "{", "}", ")", ",", "\n", "**", "dict", "(", "samples_per_gpu", "=", "val_samples_per_gpu", ")", "\n", "}", "\n", "\n", "val_dataloader", "=", "build_dataloader", "(", "val_dataset", ",", "**", "val_loader_cfg", ")", "\n", "\n", "eval_cfg", "=", "cfg", ".", "get", "(", "'evaluation'", ",", "{", "}", ")", "\n", "eval_cfg", "[", "'by_epoch'", "]", "=", "cfg", ".", "runner", "[", "'type'", "]", "!=", "'IterBasedRunner'", "\n", "eval_hook", "=", "DistEvalHook", "if", "distributed", "else", "EvalHook", "\n", "runner", ".", "register_hook", "(", "eval_hook", "(", "val_dataloader", ",", "**", "eval_cfg", ")", ")", "\n", "\n", "", "if", "cfg", ".", "resume_from", ":", "\n", "        ", "runner", ".", "resume", "(", "cfg", ".", "resume_from", ")", "\n", "", "elif", "cfg", ".", "load_from", ":", "\n", "        ", "runner", ".", "load_checkpoint", "(", "cfg", ".", "load_from", ")", "\n", "", "runner", ".", "run", "(", "data_loaders", ",", "cfg", ".", "workflow", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.train.init_random_seed": [[158, 186], ["mmcv.runner.get_dist_info", "numpy.random.randint", "torch.broadcast", "torch.tensor.item", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "init_random_seed", "(", "seed", "=", "None", ",", "device", "=", "'cuda'", ")", ":", "\n", "    ", "\"\"\"Initialize random seed. If the seed is None, it will be replaced by a\n    random number, and then broadcasted to all processes.\n\n    Args:\n        seed (int, Optional): The seed.\n        device (str): The device where the seed will be put on.\n\n    Returns:\n        int: Seed to be used.\n    \"\"\"", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "return", "seed", "\n", "\n", "# Make sure all ranks share the same random seed to prevent", "\n", "# some potential bugs. Please refer to", "\n", "# https://github.com/open-mmlab/mmdetection/issues/6339", "\n", "", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "seed", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "seed", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "random_num", "=", "torch", ".", "tensor", "(", "seed", ",", "dtype", "=", "torch", ".", "int32", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "random_num", "=", "torch", ".", "tensor", "(", "0", ",", "dtype", "=", "torch", ".", "int32", ",", "device", "=", "device", ")", "\n", "", "dist", ".", "broadcast", "(", "random_num", ",", "src", "=", "0", ")", "\n", "return", "random_num", ".", "item", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.retrieve_img_tensor_and_meta": [[14, 60], ["isinstance", "isinstance", "max", "isinstance", "isinstance", "KeyError", "isinstance"], "function", ["None"], ["def", "retrieve_img_tensor_and_meta", "(", "data", ")", ":", "\n", "    ", "\"\"\"Retrieval img_tensor, img_metas and img_norm_cfg.\n\n    Args:\n        data (dict): One batch data from data_loader.\n\n    Returns:\n        tuple: Returns (img_tensor, img_metas, img_norm_cfg).\n\n            - | img_tensor (Tensor): Input image tensor with shape\n                :math:`(N, C, H, W)`.\n            - | img_metas (list[dict]): The metadata of images.\n            - | img_norm_cfg (dict): Config for image normalization.\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "data", "[", "'img'", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "# for textrecog with batch_size > 1", "\n", "# and not use 'DefaultFormatBundle' in pipeline", "\n", "        ", "img_tensor", "=", "data", "[", "'img'", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "data", "[", "'img'", "]", ",", "list", ")", ":", "\n", "        ", "if", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "# for textrecog with aug_test and batch_size = 1", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "DataContainer", ")", ":", "\n", "# for textdet with 'MultiScaleFlipAug'", "\n", "# and 'DefaultFormatBundle' in pipeline", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "", "img_metas", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "data", "[", "'img'", "]", ",", "DataContainer", ")", ":", "\n", "# for textrecog with 'DefaultFormatBundle' in pipeline", "\n", "        ", "img_tensor", "=", "data", "[", "'img'", "]", ".", "data", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "\n", "", "must_keys", "=", "[", "'img_norm_cfg'", ",", "'ori_filename'", ",", "'img_shape'", ",", "'ori_shape'", "]", "\n", "for", "key", "in", "must_keys", ":", "\n", "        ", "if", "key", "not", "in", "img_metas", "[", "0", "]", ":", "\n", "            ", "raise", "KeyError", "(", "\n", "f'Please add {key} to the \"meta_keys\" in the pipeline'", ")", "\n", "\n", "", "", "img_norm_cfg", "=", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", "\n", "if", "max", "(", "img_norm_cfg", "[", "'mean'", "]", ")", "<=", "1", ":", "\n", "        ", "img_norm_cfg", "[", "'mean'", "]", "=", "[", "255", "*", "x", "for", "x", "in", "img_norm_cfg", "[", "'mean'", "]", "]", "\n", "img_norm_cfg", "[", "'std'", "]", "=", "[", "255", "*", "x", "for", "x", "in", "img_norm_cfg", "[", "'std'", "]", "]", "\n", "\n", "", "return", "img_tensor", ",", "img_metas", ",", "img_norm_cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test": [[62, 158], ["model.eval", "mmcv.ProgressBar", "len", "len", "isinstance", "results.extend", "range", "torch.no_grad", "model", "mmcv.ProgressBar.update", "enumerate", "test.retrieve_img_tensor_and_meta", "enumerate", "KeyError", "numpy.prod", "mmcv.image.tensor2imgs", "model.module.show_result", "img_tensor.size", "utils.tensor2grayimgs", "mmcv.image.tensor2imgs", "len", "len", "zip", "mmcv.imresize", "model.module.show_result", "mmdet.core.encode_mask_results", "KeyError", "mmcv.image.tensor2imgs.append", "os.join", "os.join", "mmcv.imread", "print", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.retrieve_img_tensor_and_meta", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "single_gpu_test", "(", "model", ",", "\n", "data_loader", ",", "\n", "show", "=", "False", ",", "\n", "out_dir", "=", "None", ",", "\n", "is_kie", "=", "False", ",", "\n", "show_score_thr", "=", "0.3", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "data", "in", "data_loader", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "batch_size", "=", "len", "(", "result", ")", "\n", "if", "show", "or", "out_dir", ":", "\n", "            ", "if", "is_kie", ":", "\n", "                ", "img_tensor", "=", "data", "[", "'img'", "]", ".", "data", "[", "0", "]", "\n", "if", "img_tensor", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "                    ", "raise", "KeyError", "(", "'Visualizing KIE outputs in batches is'", "\n", "'currently not supported.'", ")", "\n", "", "gt_bboxes", "=", "data", "[", "'gt_bboxes'", "]", ".", "data", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "must_keys", "=", "[", "'img_norm_cfg'", ",", "'ori_filename'", ",", "'img_shape'", "]", "\n", "for", "key", "in", "must_keys", ":", "\n", "                    ", "if", "key", "not", "in", "img_metas", "[", "0", "]", ":", "\n", "                        ", "raise", "KeyError", "(", "\n", "f'Please add {key} to the \"meta_keys\" in config.'", ")", "\n", "# for no visual model", "\n", "", "", "if", "np", ".", "prod", "(", "img_tensor", ".", "shape", ")", "==", "0", ":", "\n", "                    ", "imgs", "=", "[", "]", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "                        ", "try", ":", "\n", "                            ", "img", "=", "mmcv", ".", "imread", "(", "img_meta", "[", "'filename'", "]", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                            ", "print", "(", "f'Load image with error: {e}, '", "\n", "'use empty image instead.'", ")", "\n", "img", "=", "np", ".", "ones", "(", "\n", "img_meta", "[", "'img_shape'", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "imgs", ".", "append", "(", "img", ")", "\n", "", "", "else", ":", "\n", "                    ", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "\n", "**", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", ")", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "                    ", "h", ",", "w", ",", "_", "=", "img_metas", "[", "i", "]", "[", "'img_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "if", "out_dir", ":", "\n", "                        ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "\n", "img_metas", "[", "i", "]", "[", "'ori_filename'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "out_file", "=", "None", "\n", "\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ")", "\n", "", "", "else", ":", "\n", "                ", "img_tensor", ",", "img_metas", ",", "img_norm_cfg", "=", "retrieve_img_tensor_and_meta", "(", "data", ")", "\n", "\n", "if", "img_tensor", ".", "size", "(", "1", ")", "==", "1", ":", "\n", "                    ", "imgs", "=", "tensor2grayimgs", "(", "img_tensor", ",", "**", "img_norm_cfg", ")", "\n", "", "else", ":", "\n", "                    ", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "**", "img_norm_cfg", ")", "\n", "", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "\n", "for", "j", ",", "(", "img", ",", "img_meta", ")", "in", "enumerate", "(", "zip", "(", "imgs", ",", "img_metas", ")", ")", ":", "\n", "                    ", "img_shape", ",", "ori_shape", "=", "img_meta", "[", "'img_shape'", "]", ",", "img_meta", "[", "\n", "'ori_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "img_shape", "[", "0", "]", ",", ":", "img_shape", "[", "1", "]", "]", "\n", "img_show", "=", "mmcv", ".", "imresize", "(", "img_show", ",", "\n", "(", "ori_shape", "[", "1", "]", ",", "ori_shape", "[", "0", "]", ")", ")", "\n", "\n", "if", "out_dir", ":", "\n", "                        ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "img_meta", "[", "'ori_filename'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "out_file", "=", "None", "\n", "\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", "[", "j", "]", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ",", "\n", "score_thr", "=", "show_score_thr", ")", "\n", "\n", "# encode mask results", "\n", "", "", "", "if", "isinstance", "(", "result", "[", "0", "]", ",", "tuple", ")", ":", "\n", "            ", "result", "=", "[", "(", "bbox_results", ",", "encode_mask_results", "(", "mask_results", ")", ")", "\n", "for", "bbox_results", ",", "mask_results", "in", "result", "]", "\n", "", "results", ".", "extend", "(", "result", ")", "\n", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline": [[13, 19], ["mmdet.datasets.replace_ImageToTensor", "mmdet.datasets.replace_ImageToTensor"], "function", ["None"], ["def", "update_pipeline", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "pipeline", "is", "not", "None", ":", "\n", "            ", "cfg", ".", "pipeline", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", ")", "\n", "", "", "else", ":", "\n", "        ", "cfg", ".", "pipeline", "[", "idx", "]", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", "[", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.replace_image_to_tensor": [[21, 45], ["copy.deepcopy", "isinstance", "copy.deepcopy.data[].get", "mmocr.utils.is_type_list", "copy.deepcopy.data[].get", "utils.update_pipeline", "mmocr.utils.is_2dlist", "isinstance", "enumerate", "utils.update_pipeline", "utils.update_pipeline", "utils.update_pipeline"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline"], ["", "", "def", "replace_image_to_tensor", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Replace 'ImageToTensor' to 'DefaultFormatBundle'.\"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n", "                ", "update_pipeline", "(", "dataset", ")", "\n", "\n", "", "", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline_recog": [[47, 59], ["cfg.get", "warnings.warn", "warnings.warn"], "function", ["None"], ["", "def", "update_pipeline_recog", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "warning_msg", "=", "'Remove \"MultiRotateAugOCR\" to support batch '", "+", "'inference since samples_per_gpu > 1.'", "\n", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "get", "(", "'pipeline'", ",", "\n", "None", ")", "and", "cfg", ".", "pipeline", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", ".", "pipeline", "=", "[", "cfg", ".", "pipeline", "[", "0", "]", ",", "*", "cfg", ".", "pipeline", "[", "1", "]", ".", "transforms", "]", "\n", "", "", "else", ":", "\n", "        ", "if", "cfg", "[", "idx", "]", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", "[", "idx", "]", "=", "[", "cfg", "[", "idx", "]", "[", "0", "]", ",", "*", "cfg", "[", "idx", "]", "[", "1", "]", ".", "transforms", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test": [[61, 99], ["copy.deepcopy", "warnings.simplefilter", "isinstance", "copy.deepcopy.data[].get", "mmocr.utils.is_type_list", "copy.deepcopy.data[].get", "utils.update_pipeline_recog", "mmocr.utils.is_2dlist", "isinstance", "enumerate", "utils.update_pipeline_recog", "utils.update_pipeline_recog", "utils.update_pipeline_recog"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline_recog", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline_recog", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline_recog", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.update_pipeline_recog"], ["", "", "", "def", "disable_text_recog_aug_test", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Remove aug_test from test pipeline for text recognition.\n\n    Args:\n        cfg (mmcv.Config): Input config.\n        set_types (list[str]): Type of dataset source. Should be\n            None or sublist of ['test', 'val'].\n    \"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "warnings", ".", "simplefilter", "(", "'once'", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "dataset_type", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "type", "\n", "if", "dataset_type", "not", "in", "[", "\n", "'ConcatDataset'", ",", "'UniformConcatDataset'", ",", "'OCRDataset'", ",", "\n", "'OCRSegDataset'", "\n", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ".", "pipeline", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline_recog", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n", "                ", "update_pipeline_recog", "(", "dataset", ")", "\n", "\n", "", "", "", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs": [[101, 127], ["tensor.size", "numpy.array", "numpy.array", "range", "torch.is_tensor", "tensor.size", "len", "len", "tensor[].cpu().numpy().transpose", "mmcv.imdenormalize().astype", "imgs.append", "numpy.ascontiguousarray", "tensor[].cpu().numpy", "mmcv.imdenormalize", "tensor[].cpu"], "function", ["None"], ["", "def", "tensor2grayimgs", "(", "tensor", ",", "mean", "=", "(", "127", ",", ")", ",", "std", "=", "(", "127", ",", ")", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Convert tensor to 1-channel gray images.\n\n    Args:\n        tensor (torch.Tensor): Tensor that contains multiple images, shape (\n            N, C, H, W).\n        mean (tuple[float], optional): Mean of images. Defaults to (127).\n        std (tuple[float], optional): Standard deviation of images.\n            Defaults to (127).\n\n    Returns:\n        list[np.ndarray]: A list that contains multiple images.\n    \"\"\"", "\n", "\n", "assert", "torch", ".", "is_tensor", "(", "tensor", ")", "and", "tensor", ".", "ndim", "==", "4", "\n", "assert", "tensor", ".", "size", "(", "1", ")", "==", "len", "(", "mean", ")", "==", "len", "(", "std", ")", "==", "1", "\n", "\n", "num_imgs", "=", "tensor", ".", "size", "(", "0", ")", "\n", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "imgs", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "num_imgs", ")", ":", "\n", "        ", "img", "=", "tensor", "[", "img_id", ",", "...", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "img", "=", "mmcv", ".", "imdenormalize", "(", "img", ",", "mean", ",", "std", ",", "to_bgr", "=", "False", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "imgs", ".", "append", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", "\n", "", "return", "imgs", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_recognizer": [[29, 33], ["mmcv.utils.build_from_cfg", "dict"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor": [[35, 38], ["mmcv.utils.build_from_cfg"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_encoder": [[40, 43], ["mmcv.utils.build_from_cfg"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder": [[45, 48], ["mmcv.utils.build_from_cfg"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_preprocessor": [[50, 53], ["mmcv.utils.build_from_cfg"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_postprocessor": [[55, 58], ["mmcv.utils.build_from_cfg"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_roi_extractor": [[60, 63], ["ROI_EXTRACTORS.build"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss": [[65, 68], ["LOSSES.build"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_backbone": [[70, 73], ["mmdet.models.builder.BACKBONES.build"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_head": [[75, 78], ["HEADS.build"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_neck": [[80, 83], ["NECKS.build"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_fuser": [[85, 88], ["FUSERS.build"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_upsample_layer": [[90, 125], ["cfg.copy", "cfg.copy.pop", "UPSAMPLE_LAYERS.get.", "isinstance", "TypeError", "KeyError", "KeyError", "mmcv.cnn.UPSAMPLE_LAYERS.get", "type"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_activation_layer": [[127, 139], ["mmcv.utils.build_from_cfg"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector": [[141, 153], ["DETECTORS.build", "warnings.warn", "cfg.get", "cfg.get", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.dbnet_transforms.AugmenterBuilder.build"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.kie.closeset_to_openset.convert": [[11, 85], ["list", "list", "json.loads", "json.dumps", "range", "range", "label_to_edge.get", "label_to_edge.get", "list.index", "list.index"], "function", ["None"], ["def", "convert", "(", "closeset_line", ",", "merge_bg_others", "=", "False", ",", "ignore_idx", "=", "0", ",", "others_idx", "=", "25", ")", ":", "\n", "    ", "\"\"\"Convert line-json str of closeset to line-json str of openset. Note that\n    this function is designed for closeset-wildreceipt to openset-wildreceipt.\n    It may not be suitable to your own dataset.\n\n    Args:\n        closeset_line (str): The string to be deserialized to\n            the closeset dictionary object.\n        merge_bg_others (bool): If True, give the same label to \"background\"\n            class and \"others\" class.\n        ignore_idx (int): Index for ``ignore`` class.\n        others_idx (int): Index for ``others`` class.\n    \"\"\"", "\n", "# Two labels at the same index of the following two lists", "\n", "# make up a key-value pair. For example, in wildreceipt,", "\n", "# closeset_key_inds[0] maps to \"Store_name_key\"", "\n", "# and closeset_value_inds[0] maps to \"Store_addr_value\".", "\n", "closeset_key_inds", "=", "list", "(", "range", "(", "2", ",", "others_idx", ",", "2", ")", ")", "\n", "closeset_value_inds", "=", "list", "(", "range", "(", "1", ",", "others_idx", ",", "2", ")", ")", "\n", "\n", "openset_node_label_mapping", "=", "{", "'bg'", ":", "0", ",", "'key'", ":", "1", ",", "'value'", ":", "2", ",", "'others'", ":", "3", "}", "\n", "if", "merge_bg_others", ":", "\n", "        ", "openset_node_label_mapping", "[", "'others'", "]", "=", "openset_node_label_mapping", "[", "'bg'", "]", "\n", "\n", "", "closeset_obj", "=", "json", ".", "loads", "(", "closeset_line", ")", "\n", "openset_obj", "=", "{", "\n", "'file_name'", ":", "closeset_obj", "[", "'file_name'", "]", ",", "\n", "'height'", ":", "closeset_obj", "[", "'height'", "]", ",", "\n", "'width'", ":", "closeset_obj", "[", "'width'", "]", ",", "\n", "'annotations'", ":", "[", "]", "\n", "}", "\n", "\n", "edge_idx", "=", "1", "\n", "label_to_edge", "=", "{", "}", "\n", "for", "anno", "in", "closeset_obj", "[", "'annotations'", "]", ":", "\n", "        ", "label", "=", "anno", "[", "'label'", "]", "\n", "if", "label", "==", "ignore_idx", ":", "\n", "            ", "anno", "[", "'label'", "]", "=", "openset_node_label_mapping", "[", "'bg'", "]", "\n", "anno", "[", "'edge'", "]", "=", "edge_idx", "\n", "edge_idx", "+=", "1", "\n", "", "elif", "label", "==", "others_idx", ":", "\n", "            ", "anno", "[", "'label'", "]", "=", "openset_node_label_mapping", "[", "'others'", "]", "\n", "anno", "[", "'edge'", "]", "=", "edge_idx", "\n", "edge_idx", "+=", "1", "\n", "", "else", ":", "\n", "            ", "edge", "=", "label_to_edge", ".", "get", "(", "label", ",", "None", ")", "\n", "if", "edge", "is", "not", "None", ":", "\n", "                ", "anno", "[", "'edge'", "]", "=", "edge", "\n", "if", "label", "in", "closeset_key_inds", ":", "\n", "                    ", "anno", "[", "'label'", "]", "=", "openset_node_label_mapping", "[", "'key'", "]", "\n", "", "elif", "label", "in", "closeset_value_inds", ":", "\n", "                    ", "anno", "[", "'label'", "]", "=", "openset_node_label_mapping", "[", "'value'", "]", "\n", "", "", "else", ":", "\n", "                ", "tmp_key", "=", "'key'", "\n", "if", "label", "in", "closeset_key_inds", ":", "\n", "                    ", "label_with_same_edge", "=", "closeset_value_inds", "[", "\n", "closeset_key_inds", ".", "index", "(", "label", ")", "]", "\n", "", "elif", "label", "in", "closeset_value_inds", ":", "\n", "                    ", "label_with_same_edge", "=", "closeset_key_inds", "[", "\n", "closeset_value_inds", ".", "index", "(", "label", ")", "]", "\n", "tmp_key", "=", "'value'", "\n", "", "edge_counterpart", "=", "label_to_edge", ".", "get", "(", "label_with_same_edge", ",", "\n", "None", ")", "\n", "if", "edge_counterpart", "is", "not", "None", ":", "\n", "                    ", "anno", "[", "'edge'", "]", "=", "edge_counterpart", "\n", "", "else", ":", "\n", "                    ", "anno", "[", "'edge'", "]", "=", "edge_idx", "\n", "edge_idx", "+=", "1", "\n", "", "anno", "[", "'label'", "]", "=", "openset_node_label_mapping", "[", "tmp_key", "]", "\n", "label_to_edge", "[", "label", "]", "=", "anno", "[", "'edge'", "]", "\n", "\n", "", "", "", "openset_obj", "[", "'annotations'", "]", "=", "closeset_obj", "[", "'annotations'", "]", "\n", "\n", "return", "json", ".", "dumps", "(", "openset_obj", ",", "ensure_ascii", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.kie.closeset_to_openset.process": [[87, 96], ["mmocr.utils.list_from_file", "functools.partial", "mmcv.track_parallel_progress", "mmocr.utils.list_to_file"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "process", "(", "closeset_file", ",", "openset_file", ",", "merge_bg_others", "=", "False", ",", "n_proc", "=", "10", ")", ":", "\n", "    ", "closeset_lines", "=", "list_from_file", "(", "closeset_file", ")", "\n", "\n", "convert_func", "=", "partial", "(", "convert", ",", "merge_bg_others", "=", "merge_bg_others", ")", "\n", "\n", "openset_lines", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "convert_func", ",", "closeset_lines", ",", "nproc", "=", "n_proc", ")", "\n", "\n", "list_to_file", "(", "openset_file", ",", "openset_lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.kie.closeset_to_openset.parse_args": [[98, 111], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'in_file'", ",", "help", "=", "'Annotation file for closeset.'", ")", "\n", "parser", ".", "add_argument", "(", "'out_file'", ",", "help", "=", "'Annotation file for openset.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--merge'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Merge two classes: \"background\" and \"others\" in closeset '", "\n", "'to one class in openset.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--n_proc'", ",", "type", "=", "int", ",", "default", "=", "10", ",", "help", "=", "'Number of process.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.kie.closeset_to_openset.main": [[113, 119], ["closeset_to_openset.parse_args", "closeset_to_openset.process", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.labelme_converter.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "process", "(", "args", ".", "in_file", ",", "args", ".", "out_file", ",", "args", ".", "merge", ",", "args", ".", "n_proc", ")", "\n", "\n", "print", "(", "'finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.SDMGRHead.__init__": [[13, 49], ["dict", "dict", "mmcv.runner.BaseModule.__init__", "sdmgr_head.Block", "torch.nn.Embedding", "torch.nn.LSTM", "torch.nn.Linear", "torch.nn.ModuleList", "torch.nn.Linear", "torch.nn.Linear", "mmocr.models.builder.build_loss", "dict", "sdmgr_head.GNNLayer", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss"], ["    ", "def", "__init__", "(", "self", ",", "\n", "num_chars", "=", "92", ",", "\n", "visual_dim", "=", "64", ",", "\n", "fusion_dim", "=", "1024", ",", "\n", "node_input", "=", "32", ",", "\n", "node_embed", "=", "256", ",", "\n", "edge_input", "=", "5", ",", "\n", "edge_embed", "=", "256", ",", "\n", "num_gnn", "=", "2", ",", "\n", "num_classes", "=", "26", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'SDMGRLoss'", ")", ",", "\n", "bidirectional", "=", "False", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Normal'", ",", "\n", "override", "=", "dict", "(", "name", "=", "'edge_embed'", ")", ",", "\n", "mean", "=", "0", ",", "\n", "std", "=", "0.01", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "fusion", "=", "Block", "(", "[", "visual_dim", ",", "node_embed", "]", ",", "node_embed", ",", "fusion_dim", ")", "\n", "self", ".", "node_embed", "=", "nn", ".", "Embedding", "(", "num_chars", ",", "node_input", ",", "0", ")", "\n", "hidden", "=", "node_embed", "//", "2", "if", "bidirectional", "else", "node_embed", "\n", "self", ".", "rnn", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "node_input", ",", "\n", "hidden_size", "=", "hidden", ",", "\n", "num_layers", "=", "1", ",", "\n", "batch_first", "=", "True", ",", "\n", "bidirectional", "=", "bidirectional", ")", "\n", "self", ".", "edge_embed", "=", "nn", ".", "Linear", "(", "edge_input", ",", "edge_embed", ")", "\n", "self", ".", "gnn_layers", "=", "nn", ".", "ModuleList", "(", "\n", "[", "GNNLayer", "(", "node_embed", ",", "edge_embed", ")", "for", "_", "in", "range", "(", "num_gnn", ")", "]", ")", "\n", "self", ".", "node_cls", "=", "nn", ".", "Linear", "(", "node_embed", ",", "num_classes", ")", "\n", "self", ".", "edge_cls", "=", "nn", ".", "Linear", "(", "edge_embed", ",", "2", ")", "\n", "self", ".", "loss", "=", "build_loss", "(", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.SDMGRHead.forward": [[50, 86], ["max", "torch.cat", "sdmgr_head.SDMGRHead.node_embed", "sdmgr_head.SDMGRHead.rnn", "rnn_nodes.new_zeros", "torch.cat", "rnn_nodes[].gather().squeeze", "torch.cat", "sdmgr_head.SDMGRHead.edge_embed", "torch.nn.functional.normalize", "node_nums.append", "char_nums.append", "torch.cat.clamp().long", "sdmgr_head.SDMGRHead.fusion", "torch.cat.float", "gnn_layer", "sdmgr_head.SDMGRHead.node_cls", "sdmgr_head.SDMGRHead.edge_cls", "text.size", "char_num.max", "torch.cat", "rnn_nodes[].gather", "rel.view", "torch.cat.clamp", "rel.size", "text.new_zeros", "rnn_nodes.size", "text.size", "text.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "relations", ",", "texts", ",", "x", "=", "None", ")", ":", "\n", "        ", "node_nums", ",", "char_nums", "=", "[", "]", ",", "[", "]", "\n", "for", "text", "in", "texts", ":", "\n", "            ", "node_nums", ".", "append", "(", "text", ".", "size", "(", "0", ")", ")", "\n", "char_nums", ".", "append", "(", "(", "text", ">", "0", ")", ".", "sum", "(", "-", "1", ")", ")", "\n", "\n", "", "max_num", "=", "max", "(", "[", "char_num", ".", "max", "(", ")", "for", "char_num", "in", "char_nums", "]", ")", "\n", "all_nodes", "=", "torch", ".", "cat", "(", "[", "\n", "torch", ".", "cat", "(", "\n", "[", "text", ",", "\n", "text", ".", "new_zeros", "(", "text", ".", "size", "(", "0", ")", ",", "max_num", "-", "text", ".", "size", "(", "1", ")", ")", "]", ",", "-", "1", ")", "\n", "for", "text", "in", "texts", "\n", "]", ")", "\n", "embed_nodes", "=", "self", ".", "node_embed", "(", "all_nodes", ".", "clamp", "(", "min", "=", "0", ")", ".", "long", "(", ")", ")", "\n", "rnn_nodes", ",", "_", "=", "self", ".", "rnn", "(", "embed_nodes", ")", "\n", "\n", "nodes", "=", "rnn_nodes", ".", "new_zeros", "(", "*", "rnn_nodes", ".", "shape", "[", ":", ":", "2", "]", ")", "\n", "all_nums", "=", "torch", ".", "cat", "(", "char_nums", ")", "\n", "valid", "=", "all_nums", ">", "0", "\n", "nodes", "[", "valid", "]", "=", "rnn_nodes", "[", "valid", "]", ".", "gather", "(", "\n", "1", ",", "(", "all_nums", "[", "valid", "]", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "expand", "(", "\n", "-", "1", ",", "-", "1", ",", "rnn_nodes", ".", "size", "(", "-", "1", ")", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "if", "x", "is", "not", "None", ":", "\n", "            ", "nodes", "=", "self", ".", "fusion", "(", "[", "x", ",", "nodes", "]", ")", "\n", "\n", "", "all_edges", "=", "torch", ".", "cat", "(", "\n", "[", "rel", ".", "view", "(", "-", "1", ",", "rel", ".", "size", "(", "-", "1", ")", ")", "for", "rel", "in", "relations", "]", ")", "\n", "embed_edges", "=", "self", ".", "edge_embed", "(", "all_edges", ".", "float", "(", ")", ")", "\n", "embed_edges", "=", "F", ".", "normalize", "(", "embed_edges", ")", "\n", "\n", "for", "gnn_layer", "in", "self", ".", "gnn_layers", ":", "\n", "            ", "nodes", ",", "cat_nodes", "=", "gnn_layer", "(", "nodes", ",", "embed_edges", ",", "node_nums", ")", "\n", "\n", "", "node_cls", ",", "edge_cls", "=", "self", ".", "node_cls", "(", "nodes", ")", ",", "self", ".", "edge_cls", "(", "cat_nodes", ")", "\n", "return", "node_cls", ",", "edge_cls", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.GNNLayer.__init__": [[90, 96], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "node_dim", "=", "256", ",", "edge_dim", "=", "256", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_fc", "=", "nn", ".", "Linear", "(", "node_dim", "*", "2", "+", "edge_dim", ",", "node_dim", ")", "\n", "self", ".", "coef_fc", "=", "nn", ".", "Linear", "(", "node_dim", ",", "1", ")", "\n", "self", ".", "out_fc", "=", "nn", ".", "Linear", "(", "node_dim", ",", "node_dim", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.GNNLayer.forward": [[97, 123], ["torch.cat", "sdmgr_head.GNNLayer.relu", "sdmgr_head.GNNLayer.coef_fc", "sdmgr_head.GNNLayer.relu", "sdmgr_head.GNNLayer.append", "sdmgr_head.GNNLayer.in_fc", "torch.nn.functional.softmax", "residuals.append", "sdmgr_head.GNNLayer.out_fc", "torch.cat().view", "torch.cat", "torch.cat", "coefs[].view", "torch.cat", "torch.eye().to().unsqueeze", "cat_nodes[].view", "sample_nodes.unsqueeze().expand", "sample_nodes.unsqueeze().expand", "torch.eye().to", "sample_nodes.unsqueeze", "sample_nodes.unsqueeze", "torch.eye"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "nodes", ",", "edges", ",", "nums", ")", ":", "\n", "        ", "start", ",", "cat_nodes", "=", "0", ",", "[", "]", "\n", "for", "num", "in", "nums", ":", "\n", "            ", "sample_nodes", "=", "nodes", "[", "start", ":", "start", "+", "num", "]", "\n", "cat_nodes", ".", "append", "(", "\n", "torch", ".", "cat", "(", "[", "\n", "sample_nodes", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "num", ",", "-", "1", ")", ",", "\n", "sample_nodes", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "num", ",", "-", "1", ",", "-", "1", ")", "\n", "]", ",", "-", "1", ")", ".", "view", "(", "num", "**", "2", ",", "-", "1", ")", ")", "\n", "start", "+=", "num", "\n", "", "cat_nodes", "=", "torch", ".", "cat", "(", "[", "torch", ".", "cat", "(", "cat_nodes", ")", ",", "edges", "]", ",", "-", "1", ")", "\n", "cat_nodes", "=", "self", ".", "relu", "(", "self", ".", "in_fc", "(", "cat_nodes", ")", ")", "\n", "coefs", "=", "self", ".", "coef_fc", "(", "cat_nodes", ")", "\n", "\n", "start", ",", "residuals", "=", "0", ",", "[", "]", "\n", "for", "num", "in", "nums", ":", "\n", "            ", "residual", "=", "F", ".", "softmax", "(", "\n", "-", "torch", ".", "eye", "(", "num", ")", ".", "to", "(", "coefs", ".", "device", ")", ".", "unsqueeze", "(", "-", "1", ")", "*", "1e9", "+", "\n", "coefs", "[", "start", ":", "start", "+", "num", "**", "2", "]", ".", "view", "(", "num", ",", "num", ",", "-", "1", ")", ",", "1", ")", "\n", "residuals", ".", "append", "(", "\n", "(", "residual", "*", "\n", "cat_nodes", "[", "start", ":", "start", "+", "num", "**", "2", "]", ".", "view", "(", "num", ",", "num", ",", "-", "1", ")", ")", ".", "sum", "(", "1", ")", ")", "\n", "start", "+=", "num", "**", "2", "\n", "\n", "", "nodes", "+=", "self", ".", "relu", "(", "self", ".", "out_fc", "(", "torch", ".", "cat", "(", "residuals", ")", ")", ")", "\n", "return", "nodes", ",", "cat_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.Block.__init__": [[127, 158], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.ModuleList", "torch.nn.ModuleList", "sdmgr_head.Block.chunk_sizes", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "sdmgr_head.Block.merge_linears0.append", "sdmgr_head.Block.merge_linears1.append", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.Block.chunk_sizes"], ["    ", "def", "__init__", "(", "self", ",", "\n", "input_dims", ",", "\n", "output_dim", ",", "\n", "mm_dim", "=", "1600", ",", "\n", "chunks", "=", "20", ",", "\n", "rank", "=", "15", ",", "\n", "shared", "=", "False", ",", "\n", "dropout_input", "=", "0.", ",", "\n", "dropout_pre_lin", "=", "0.", ",", "\n", "dropout_output", "=", "0.", ",", "\n", "pos_norm", "=", "'before_cat'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "dropout_input", "=", "dropout_input", "\n", "self", ".", "dropout_pre_lin", "=", "dropout_pre_lin", "\n", "self", ".", "dropout_output", "=", "dropout_output", "\n", "assert", "(", "pos_norm", "in", "[", "'before_cat'", ",", "'after_cat'", "]", ")", "\n", "self", ".", "pos_norm", "=", "pos_norm", "\n", "# Modules", "\n", "self", ".", "linear0", "=", "nn", ".", "Linear", "(", "input_dims", "[", "0", "]", ",", "mm_dim", ")", "\n", "self", ".", "linear1", "=", "(", "\n", "self", ".", "linear0", "if", "shared", "else", "nn", ".", "Linear", "(", "input_dims", "[", "1", "]", ",", "mm_dim", ")", ")", "\n", "self", ".", "merge_linears0", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "merge_linears1", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "chunks", "=", "self", ".", "chunk_sizes", "(", "mm_dim", ",", "chunks", ")", "\n", "for", "size", "in", "self", ".", "chunks", ":", "\n", "            ", "ml0", "=", "nn", ".", "Linear", "(", "size", ",", "size", "*", "rank", ")", "\n", "self", ".", "merge_linears0", ".", "append", "(", "ml0", ")", "\n", "ml1", "=", "ml0", "if", "shared", "else", "nn", ".", "Linear", "(", "size", ",", "size", "*", "rank", ")", "\n", "self", ".", "merge_linears1", ".", "append", "(", "ml1", ")", "\n", "", "self", ".", "linear_out", "=", "nn", ".", "Linear", "(", "mm_dim", ",", "output_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.Block.forward": [[159, 190], ["sdmgr_head.Block.linear0", "sdmgr_head.Block.linear1", "torch.nn.functional.dropout.size", "torch.split", "torch.split", "zip", "torch.cat", "sdmgr_head.Block.linear_out", "torch.nn.functional.dropout", "torch.nn.functional.dropout", "m.view.view.view", "torch.sum", "zs.append", "torch.nn.functional.normalize", "torch.nn.functional.dropout", "torch.nn.functional.dropout", "m0", "m1", "torch.nn.functional.normalize", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x0", "=", "self", ".", "linear0", "(", "x", "[", "0", "]", ")", "\n", "x1", "=", "self", ".", "linear1", "(", "x", "[", "1", "]", ")", "\n", "bs", "=", "x1", ".", "size", "(", "0", ")", "\n", "if", "self", ".", "dropout_input", ">", "0", ":", "\n", "            ", "x0", "=", "F", ".", "dropout", "(", "x0", ",", "p", "=", "self", ".", "dropout_input", ",", "training", "=", "self", ".", "training", ")", "\n", "x1", "=", "F", ".", "dropout", "(", "x1", ",", "p", "=", "self", ".", "dropout_input", ",", "training", "=", "self", ".", "training", ")", "\n", "", "x0_chunks", "=", "torch", ".", "split", "(", "x0", ",", "self", ".", "chunks", ",", "-", "1", ")", "\n", "x1_chunks", "=", "torch", ".", "split", "(", "x1", ",", "self", ".", "chunks", ",", "-", "1", ")", "\n", "zs", "=", "[", "]", "\n", "for", "x0_c", ",", "x1_c", ",", "m0", ",", "m1", "in", "zip", "(", "x0_chunks", ",", "x1_chunks", ",", "\n", "self", ".", "merge_linears0", ",", "\n", "self", ".", "merge_linears1", ")", ":", "\n", "            ", "m", "=", "m0", "(", "x0_c", ")", "*", "m1", "(", "x1_c", ")", "# bs x split_size*rank", "\n", "m", "=", "m", ".", "view", "(", "bs", ",", "self", ".", "rank", ",", "-", "1", ")", "\n", "z", "=", "torch", ".", "sum", "(", "m", ",", "1", ")", "\n", "if", "self", ".", "pos_norm", "==", "'before_cat'", ":", "\n", "                ", "z", "=", "torch", ".", "sqrt", "(", "F", ".", "relu", "(", "z", ")", ")", "-", "torch", ".", "sqrt", "(", "F", ".", "relu", "(", "-", "z", ")", ")", "\n", "z", "=", "F", ".", "normalize", "(", "z", ")", "\n", "", "zs", ".", "append", "(", "z", ")", "\n", "", "z", "=", "torch", ".", "cat", "(", "zs", ",", "1", ")", "\n", "if", "self", ".", "pos_norm", "==", "'after_cat'", ":", "\n", "            ", "z", "=", "torch", ".", "sqrt", "(", "F", ".", "relu", "(", "z", ")", ")", "-", "torch", ".", "sqrt", "(", "F", ".", "relu", "(", "-", "z", ")", ")", "\n", "z", "=", "F", ".", "normalize", "(", "z", ")", "\n", "\n", "", "if", "self", ".", "dropout_pre_lin", ">", "0", ":", "\n", "            ", "z", "=", "F", ".", "dropout", "(", "z", ",", "p", "=", "self", ".", "dropout_pre_lin", ",", "training", "=", "self", ".", "training", ")", "\n", "", "z", "=", "self", ".", "linear_out", "(", "z", ")", "\n", "if", "self", ".", "dropout_output", ">", "0", ":", "\n", "            ", "z", "=", "F", ".", "dropout", "(", "z", ",", "p", "=", "self", ".", "dropout_output", ",", "training", "=", "self", ".", "training", ")", "\n", "", "return", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.sdmgr_head.Block.chunk_sizes": [[191, 197], ["sum"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "chunk_sizes", "(", "dim", ",", "chunks", ")", ":", "\n", "        ", "split_size", "=", "(", "dim", "+", "chunks", "-", "1", ")", "//", "chunks", "\n", "sizes_list", "=", "[", "split_size", "]", "*", "chunks", "\n", "sizes_list", "[", "-", "1", "]", "=", "sizes_list", "[", "-", "1", "]", "-", "(", "sum", "(", "sizes_list", ")", "-", "dim", ")", "\n", "return", "sizes_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.seg_head.SegHead.__init__": [[22, 45], ["mmcv.runner.BaseModule.__init__", "isinstance", "mmcv.cnn.ConvModule", "torch.nn.Conv2d", "isinstance", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "128", ",", "\n", "num_classes", "=", "37", ",", "\n", "upsample_param", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "num_classes", ",", "int", ")", "\n", "assert", "num_classes", ">", "0", "\n", "assert", "upsample_param", "is", "None", "or", "isinstance", "(", "upsample_param", ",", "dict", ")", "\n", "\n", "self", ".", "upsample_param", "=", "upsample_param", "\n", "\n", "self", ".", "seg_conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "in_channels", ",", "\n", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ")", "\n", "\n", "# prediction", "\n", "self", ".", "pred_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.heads.seg_head.SegHead.forward": [[46, 65], ["seg_head.SegHead.seg_conv", "seg_head.SegHead.pred_conv", "torch.interpolate"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "out_neck", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            out_neck (list[Tensor]): A list of tensor of shape\n                :math:`(N, C_i, H_i, W_i)`. The network only uses the last one\n                (``out_neck[-1]``).\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, C_{out}, kH, kW)` where\n            :math:`k` is determined by ``upsample_param``.\n        \"\"\"", "\n", "\n", "seg_map", "=", "self", ".", "seg_conv", "(", "out_neck", "[", "-", "1", "]", ")", "\n", "seg_map", "=", "self", ".", "pred_conv", "(", "seg_map", ")", "\n", "\n", "if", "self", ".", "upsample_param", "is", "not", "None", ":", "\n", "            ", "seg_map", "=", "F", ".", "interpolate", "(", "seg_map", ",", "**", "self", ".", "upsample_param", ")", "\n", "\n", "", "return", "seg_map", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.extractors.sdmgr.SDMGR.__init__": [[27, 54], ["dict", "mmocr.models.common.detectors.SingleStageDetector.__init__", "mmocr.models.builder.build_roi_extractor", "torch.nn.MaxPool2d", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_roi_extractor"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "bbox_head", "=", "None", ",", "\n", "extractor", "=", "dict", "(", "\n", "type", "=", "'mmdet.SingleRoIExtractor'", ",", "\n", "roi_layer", "=", "dict", "(", "type", "=", "'RoIAlign'", ",", "output_size", "=", "7", ")", ",", "\n", "featmap_strides", "=", "[", "1", "]", ")", ",", "\n", "visual_modality", "=", "False", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "class_list", "=", "None", ",", "\n", "init_cfg", "=", "None", ",", "\n", "openset", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "backbone", ",", "neck", ",", "bbox_head", ",", "train_cfg", ",", "test_cfg", ",", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "visual_modality", "=", "visual_modality", "\n", "if", "visual_modality", ":", "\n", "            ", "self", ".", "extractor", "=", "build_roi_extractor", "(", "{", "\n", "**", "extractor", ",", "'out_channels'", ":", "\n", "self", ".", "backbone", ".", "base_channels", "\n", "}", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "extractor", "[", "'roi_layer'", "]", "[", "'output_size'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "extractor", "=", "None", "\n", "", "self", ".", "class_list", "=", "class_list", "\n", "self", ".", "openset", "=", "openset", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.extractors.sdmgr.SDMGR.forward_train": [[55, 78], ["sdmgr.SDMGR.extract_feat", "sdmgr.SDMGR.bbox_head.forward", "sdmgr.SDMGR.bbox_head.loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "relations", ",", "texts", ",", "gt_bboxes", ",", "\n", "gt_labels", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A list of image info dict where each dict\n                contains: 'img_shape', 'scale_factor', 'flip', and may also\n                contain 'filename', 'ori_shape', 'pad_shape', and\n                'img_norm_cfg'. For details of the values of these keys,\n                please see :class:`mmdet.datasets.pipelines.Collect`.\n            relations (list[tensor]): Relations between bboxes.\n            texts (list[tensor]): Texts in bboxes.\n            gt_bboxes (list[tensor]): Each item is the truth boxes for each\n                image in [tl_x, tl_y, br_x, br_y] format.\n            gt_labels (list[tensor]): Class indices corresponding to each box.\n\n        Returns:\n            dict[str, tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ",", "gt_bboxes", ")", "\n", "node_preds", ",", "edge_preds", "=", "self", ".", "bbox_head", ".", "forward", "(", "relations", ",", "texts", ",", "x", ")", "\n", "return", "self", ".", "bbox_head", ".", "loss", "(", "node_preds", ",", "edge_preds", ",", "gt_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.extractors.sdmgr.SDMGR.forward_test": [[79, 93], ["sdmgr.SDMGR.extract_feat", "sdmgr.SDMGR.bbox_head.forward", "dict", "torch.nn.functional.softmax", "torch.nn.functional.softmax"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "def", "forward_test", "(", "self", ",", "\n", "img", ",", "\n", "img_metas", ",", "\n", "relations", ",", "\n", "texts", ",", "\n", "gt_bboxes", ",", "\n", "rescale", "=", "False", ")", ":", "\n", "        ", "x", "=", "self", ".", "extract_feat", "(", "img", ",", "gt_bboxes", ")", "\n", "node_preds", ",", "edge_preds", "=", "self", ".", "bbox_head", ".", "forward", "(", "relations", ",", "texts", ",", "x", ")", "\n", "return", "[", "\n", "dict", "(", "\n", "img_metas", "=", "img_metas", ",", "\n", "nodes", "=", "F", ".", "softmax", "(", "node_preds", ",", "-", "1", ")", ",", "\n", "edges", "=", "F", ".", "softmax", "(", "edge_preds", ",", "-", "1", ")", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.extractors.sdmgr.SDMGR.extract_feat": [[95, 101], ["sdmgr.SDMGR.maxpool", "sdmgr.SDMGR.view", "super().extract_feat", "sdmgr.SDMGR.extractor", "sdmgr.SDMGR.size", "mmdet.core.bbox2roi"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat"], ["", "def", "extract_feat", "(", "self", ",", "img", ",", "gt_bboxes", ")", ":", "\n", "        ", "if", "self", ".", "visual_modality", ":", "\n", "            ", "x", "=", "super", "(", ")", ".", "extract_feat", "(", "img", ")", "[", "-", "1", "]", "\n", "feats", "=", "self", ".", "maxpool", "(", "self", ".", "extractor", "(", "[", "x", "]", ",", "bbox2roi", "(", "gt_bboxes", ")", ")", ")", "\n", "return", "feats", ".", "view", "(", "feats", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.extractors.sdmgr.SDMGR.show_result": [[102, 167], ["mmcv.imread", "mmocr.core.imshow_node.copy", "mmocr.utils.list_from_file", "mmocr.core.imshow_edge", "mmocr.core.imshow_node", "warnings.warn", "line.strip().split", "line.strip"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_edge", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_node"], ["", "def", "show_result", "(", "self", ",", "\n", "img", ",", "\n", "result", ",", "\n", "boxes", ",", "\n", "win_name", "=", "''", ",", "\n", "show", "=", "False", ",", "\n", "wait_time", "=", "0", ",", "\n", "out_file", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Draw `result` on `img`.\n\n        Args:\n            img (str or tensor): The image to be displayed.\n            result (dict): The results to draw on `img`.\n            boxes (list): Bbox of img.\n            win_name (str): The window name.\n            wait_time (int): Value of waitKey param.\n                Default: 0.\n            show (bool): Whether to show the image.\n                Default: False.\n            out_file (str or None): The output filename.\n                Default: None.\n\n        Returns:\n            img (tensor): Only if not `show` or `out_file`.\n        \"\"\"", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "img", "=", "img", ".", "copy", "(", ")", "\n", "\n", "idx_to_cls", "=", "{", "}", "\n", "if", "self", ".", "class_list", "is", "not", "None", ":", "\n", "            ", "for", "line", "in", "list_from_file", "(", "self", ".", "class_list", ")", ":", "\n", "                ", "class_idx", ",", "class_label", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "idx_to_cls", "[", "class_idx", "]", "=", "class_label", "\n", "\n", "# if out_file specified, do not show image in window", "\n", "", "", "if", "out_file", "is", "not", "None", ":", "\n", "            ", "show", "=", "False", "\n", "\n", "", "if", "self", ".", "openset", ":", "\n", "            ", "img", "=", "imshow_edge", "(", "\n", "img", ",", "\n", "result", ",", "\n", "boxes", ",", "\n", "show", "=", "show", ",", "\n", "win_name", "=", "win_name", ",", "\n", "wait_time", "=", "wait_time", ",", "\n", "out_file", "=", "out_file", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "imshow_node", "(", "\n", "img", ",", "\n", "result", ",", "\n", "boxes", ",", "\n", "idx_to_cls", "=", "idx_to_cls", ",", "\n", "show", "=", "show", ",", "\n", "win_name", "=", "win_name", ",", "\n", "wait_time", "=", "wait_time", ",", "\n", "out_file", "=", "out_file", ")", "\n", "\n", "", "if", "not", "(", "show", "or", "out_file", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'show==False and out_file is not specified, only '", "\n", "'result image will be returned'", ")", "\n", "return", "img", "\n", "\n", "", "return", "img", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.sdmgr_loss.SDMGRLoss.__init__": [[18, 25], ["torch.nn.Module.__init__", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "node_weight", "=", "1.0", ",", "edge_weight", "=", "1.0", ",", "ignore", "=", "-", "100", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "loss_node", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "ignore", ")", "\n", "self", ".", "loss_edge", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "-", "1", ")", "\n", "self", ".", "node_weight", "=", "node_weight", "\n", "self", ".", "edge_weight", "=", "edge_weight", "\n", "self", ".", "ignore", "=", "ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.sdmgr_loss.SDMGRLoss.forward": [[26, 42], ["torch.cat().long", "torch.cat().long", "torch.nonzero().view", "torch.nonzero().view", "dict", "torch.cat().long.append", "torch.cat().long.append", "gt[].contiguous().view", "torch.cat", "torch.cat", "torch.nonzero", "torch.nonzero", "mmdet.models.losses.accuracy", "mmdet.models.losses.accuracy", "sdmgr_loss.SDMGRLoss.loss_node", "sdmgr_loss.SDMGRLoss.loss_edge", "gt[].contiguous"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "node_preds", ",", "edge_preds", ",", "gts", ")", ":", "\n", "        ", "node_gts", ",", "edge_gts", "=", "[", "]", ",", "[", "]", "\n", "for", "gt", "in", "gts", ":", "\n", "            ", "node_gts", ".", "append", "(", "gt", "[", ":", ",", "0", "]", ")", "\n", "edge_gts", ".", "append", "(", "gt", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ")", "\n", "", "node_gts", "=", "torch", ".", "cat", "(", "node_gts", ")", ".", "long", "(", ")", "\n", "edge_gts", "=", "torch", ".", "cat", "(", "edge_gts", ")", ".", "long", "(", ")", "\n", "\n", "node_valids", "=", "torch", ".", "nonzero", "(", "\n", "node_gts", "!=", "self", ".", "ignore", ",", "as_tuple", "=", "False", ")", ".", "view", "(", "-", "1", ")", "\n", "edge_valids", "=", "torch", ".", "nonzero", "(", "edge_gts", "!=", "-", "1", ",", "as_tuple", "=", "False", ")", ".", "view", "(", "-", "1", ")", "\n", "return", "dict", "(", "\n", "loss_node", "=", "self", ".", "node_weight", "*", "self", ".", "loss_node", "(", "node_preds", ",", "node_gts", ")", ",", "\n", "loss_edge", "=", "self", ".", "edge_weight", "*", "self", ".", "loss_edge", "(", "edge_preds", ",", "edge_gts", ")", ",", "\n", "acc_node", "=", "accuracy", "(", "node_preds", "[", "node_valids", "]", ",", "node_gts", "[", "node_valids", "]", ")", ",", "\n", "acc_edge", "=", "accuracy", "(", "edge_preds", "[", "edge_valids", "]", ",", "edge_gts", "[", "edge_valids", "]", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ctc_loss.CTCLoss.__init__": [[25, 41], ["torch.Module.__init__", "isinstance", "isinstance", "isinstance", "isinstance", "torch.CTCLoss", "torch.CTCLoss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "flatten", "=", "True", ",", "\n", "blank", "=", "0", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "zero_infinity", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "flatten", ",", "bool", ")", "\n", "assert", "isinstance", "(", "blank", ",", "int", ")", "\n", "assert", "isinstance", "(", "reduction", ",", "str", ")", "\n", "assert", "isinstance", "(", "zero_infinity", ",", "bool", ")", "\n", "\n", "self", ".", "flatten", "=", "flatten", "\n", "self", ".", "blank", "=", "blank", "\n", "self", ".", "ctc_loss", "=", "nn", ".", "CTCLoss", "(", "\n", "blank", "=", "blank", ",", "reduction", "=", "reduction", ",", "zero_infinity", "=", "zero_infinity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ctc_loss.CTCLoss.forward": [[42, 104], ["torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax.permute().contiguous", "torch.log_softmax.permute().contiguous", "torch.clamp().long", "torch.clamp().long", "torch.clamp().long", "torch.clamp().long", "torch.full", "torch.full", "torch.full", "torch.full", "ctc_loss.CTCLoss.ctc_loss", "dict", "torch.log_softmax.size", "torch.log_softmax.size", "torch.log_softmax.size", "torch.log_softmax.size", "torch.full", "torch.full", "torch.full", "torch.full", "enumerate", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "img_meta.get", "torch.log_softmax.permute", "torch.log_softmax.permute", "min", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "math.ceil", "tensor.size", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "outputs", ",", "targets_dict", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            outputs (Tensor): A raw logit tensor of shape :math:`(N, T, C)`.\n            targets_dict (dict): A dict with 3 keys ``target_lengths``,\n                ``flatten_targets`` and ``targets``.\n\n                - | ``target_lengths`` (Tensor): A tensor of shape :math:`(N)`.\n                    Each item is the length of a word.\n\n                - | ``flatten_targets`` (Tensor): Used if ``self.flatten=True``\n                    (default). A tensor of shape\n                    (sum(targets_dict['target_lengths'])). Each item is the\n                    index of a character.\n\n                - | ``targets`` (Tensor): Used if ``self.flatten=False``. A\n                    tensor of :math:`(N, T)`. Empty slots are padded with\n                    ``self.blank``.\n\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            dict: The loss dict with key ``loss_ctc``.\n        \"\"\"", "\n", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "\n", "\n", "", "outputs", "=", "torch", ".", "log_softmax", "(", "outputs", ",", "dim", "=", "2", ")", "\n", "bsz", ",", "seq_len", "=", "outputs", ".", "size", "(", "0", ")", ",", "outputs", ".", "size", "(", "1", ")", "\n", "outputs_for_loss", "=", "outputs", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ".", "contiguous", "(", ")", "# T * N * C", "\n", "\n", "if", "self", ".", "flatten", ":", "\n", "            ", "targets", "=", "targets_dict", "[", "'flatten_targets'", "]", "\n", "", "else", ":", "\n", "            ", "targets", "=", "torch", ".", "full", "(", "\n", "size", "=", "(", "bsz", ",", "seq_len", ")", ",", "fill_value", "=", "self", ".", "blank", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "for", "idx", ",", "tensor", "in", "enumerate", "(", "targets_dict", "[", "'targets'", "]", ")", ":", "\n", "                ", "valid_len", "=", "min", "(", "tensor", ".", "size", "(", "0", ")", ",", "seq_len", ")", "\n", "targets", "[", "idx", ",", ":", "valid_len", "]", "=", "tensor", "[", ":", "valid_len", "]", "\n", "\n", "", "", "target_lengths", "=", "targets_dict", "[", "'target_lengths'", "]", "\n", "target_lengths", "=", "torch", ".", "clamp", "(", "target_lengths", ",", "min", "=", "1", ",", "max", "=", "seq_len", ")", ".", "long", "(", ")", "\n", "\n", "input_lengths", "=", "torch", ".", "full", "(", "\n", "size", "=", "(", "bsz", ",", ")", ",", "fill_value", "=", "seq_len", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "if", "not", "self", ".", "flatten", "and", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "input_lengths", "=", "[", "\n", "math", ".", "ceil", "(", "valid_ratio", "*", "seq_len", ")", "\n", "for", "valid_ratio", "in", "valid_ratios", "\n", "]", "\n", "input_lengths", "=", "torch", ".", "Tensor", "(", "input_lengths", ")", ".", "long", "(", ")", "\n", "\n", "", "loss_ctc", "=", "self", ".", "ctc_loss", "(", "outputs_for_loss", ",", "targets", ",", "input_lengths", ",", "\n", "target_lengths", ")", "\n", "\n", "losses", "=", "dict", "(", "loss_ctc", "=", "loss_ctc", ")", "\n", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss.__init__": [[25, 40], ["torch.Module.__init__", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "enc_weight", "=", "1.0", ",", "\n", "dec_weight", "=", "1.0", ",", "\n", "fusion_weight", "=", "1.0", ",", "\n", "num_classes", "=", "37", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "enc_weight", ",", "float", ")", "or", "isinstance", "(", "enc_weight", ",", "int", ")", "\n", "assert", "isinstance", "(", "dec_weight", ",", "float", ")", "or", "isinstance", "(", "dec_weight", ",", "int", ")", "\n", "assert", "isinstance", "(", "fusion_weight", ",", "float", ")", "or", "isinstance", "(", "fusion_weight", ",", "int", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "enc_weight", "=", "enc_weight", "\n", "self", ".", "dec_weight", "=", "dec_weight", "\n", "self", ".", "fusion_weight", "=", "fusion_weight", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._flatten": [[41, 45], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "enumerate"], "methods", ["None"], ["", "def", "_flatten", "(", "self", ",", "logits", ",", "target_lens", ")", ":", "\n", "        ", "flatten_logits", "=", "torch", ".", "cat", "(", "\n", "[", "s", "[", ":", "target_lens", "[", "i", "]", "]", "for", "i", ",", "s", "in", "enumerate", "(", "(", "logits", ")", ")", "]", ")", "\n", "return", "flatten_logits", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._ce_loss": [[46, 51], ["torch.one_hot", "torch.one_hot", "torch.one_hot", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "loss.mean", "torch.one_hot.to"], "methods", ["None"], ["", "def", "_ce_loss", "(", "self", ",", "logits", ",", "targets", ")", ":", "\n", "        ", "targets_one_hot", "=", "F", ".", "one_hot", "(", "targets", ",", "self", ".", "num_classes", ")", "\n", "log_prob", "=", "F", ".", "log_softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "loss", "=", "-", "(", "targets_one_hot", ".", "to", "(", "log_prob", ".", "device", ")", "*", "log_prob", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "return", "loss", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._loss_over_iters": [[52, 65], ["len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "targets.repeat", "mix_loss.ABILoss._ce_loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._ce_loss"], ["", "def", "_loss_over_iters", "(", "self", ",", "outputs", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            outputs (list[Tensor]): Each tensor has shape (N, T, C) where N is\n                the batch size, T is the sequence length and C is the number of\n                classes.\n            targets_dicts (dict): The dictionary with at least `padded_targets`\n                defined.\n        \"\"\"", "\n", "iter_num", "=", "len", "(", "outputs", ")", "\n", "dec_outputs", "=", "torch", ".", "cat", "(", "outputs", ",", "dim", "=", "0", ")", "\n", "flatten_targets_iternum", "=", "targets", ".", "repeat", "(", "iter_num", ")", "\n", "return", "self", ".", "_ce_loss", "(", "dec_outputs", ",", "flatten_targets_iternum", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss.forward": [[66, 110], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "outputs.get", "outputs.get", "outputs.get", "len", "mix_loss.ABILoss._flatten", "mix_loss.ABILoss._ce_loss", "mix_loss.ABILoss._flatten", "mix_loss.ABILoss._loss_over_iters", "mix_loss.ABILoss._flatten", "mix_loss.ABILoss._loss_over_iters"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._flatten", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._ce_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._flatten", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._loss_over_iters", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._flatten", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.mix_loss.ABILoss._loss_over_iters"], ["", "def", "forward", "(", "self", ",", "outputs", ",", "targets_dict", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            outputs (dict): The output dictionary with at least one of\n                ``out_enc``, ``out_dec`` and ``out_fusers`` specified.\n            targets_dict (dict): The target dictionary containing the key\n                ``padded_targets``, which represents target sequences in\n                shape (batch_size, sequence_length).\n\n        Returns:\n            A loss dictionary with ``loss_visual``, ``loss_lang`` and\n            ``loss_fusion``. Each should either be the loss tensor or ``0`` if\n            the output of its corresponding module is not given.\n        \"\"\"", "\n", "assert", "'out_enc'", "in", "outputs", "or", "'out_dec'", "in", "outputs", "or", "'out_fusers'", "in", "outputs", "\n", "losses", "=", "{", "}", "\n", "\n", "target_lens", "=", "[", "len", "(", "t", ")", "for", "t", "in", "targets_dict", "[", "'targets'", "]", "]", "\n", "flatten_targets", "=", "torch", ".", "cat", "(", "[", "t", "for", "t", "in", "targets_dict", "[", "'targets'", "]", "]", ")", "\n", "\n", "if", "outputs", ".", "get", "(", "'out_enc'", ",", "None", ")", ":", "\n", "            ", "enc_input", "=", "self", ".", "_flatten", "(", "outputs", "[", "'out_enc'", "]", "[", "'logits'", "]", ",", "\n", "target_lens", ")", "\n", "enc_loss", "=", "self", ".", "_ce_loss", "(", "enc_input", ",", "\n", "flatten_targets", ")", "*", "self", ".", "enc_weight", "\n", "losses", "[", "'loss_visual'", "]", "=", "enc_loss", "\n", "", "if", "outputs", ".", "get", "(", "'out_decs'", ",", "None", ")", ":", "\n", "            ", "dec_logits", "=", "[", "\n", "self", ".", "_flatten", "(", "o", "[", "'logits'", "]", ",", "target_lens", ")", "\n", "for", "o", "in", "outputs", "[", "'out_decs'", "]", "\n", "]", "\n", "dec_loss", "=", "self", ".", "_loss_over_iters", "(", "dec_logits", ",", "\n", "flatten_targets", ")", "*", "self", ".", "dec_weight", "\n", "losses", "[", "'loss_lang'", "]", "=", "dec_loss", "\n", "", "if", "outputs", ".", "get", "(", "'out_fusers'", ",", "None", ")", ":", "\n", "            ", "fusion_logits", "=", "[", "\n", "self", ".", "_flatten", "(", "o", "[", "'logits'", "]", ",", "target_lens", ")", "\n", "for", "o", "in", "outputs", "[", "'out_fusers'", "]", "\n", "]", "\n", "fusion_loss", "=", "self", ".", "_loss_over_iters", "(", "\n", "fusion_logits", ",", "flatten_targets", ")", "*", "self", ".", "fusion_weight", "\n", "losses", "[", "'loss_fusion'", "]", "=", "fusion_loss", "\n", "", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.CELoss.__init__": [[22, 35], ["torch.Module.__init__", "isinstance", "isinstance", "isinstance", "torch.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "ignore_index", "=", "-", "1", ",", "\n", "reduction", "=", "'none'", ",", "\n", "ignore_first_char", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "ignore_index", ",", "int", ")", "\n", "assert", "isinstance", "(", "reduction", ",", "str", ")", "\n", "assert", "reduction", "in", "[", "'none'", ",", "'mean'", ",", "'sum'", "]", "\n", "assert", "isinstance", "(", "ignore_first_char", ",", "bool", ")", "\n", "\n", "self", ".", "loss_ce", "=", "nn", ".", "CrossEntropyLoss", "(", "\n", "ignore_index", "=", "ignore_index", ",", "reduction", "=", "reduction", ")", "\n", "self", ".", "ignore_first_char", "=", "ignore_first_char", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.CELoss.format": [[36, 45], ["outputs.permute().contiguous.permute().contiguous.permute().contiguous", "targets[].contiguous", "outputs.permute().contiguous.permute().contiguous.permute"], "methods", ["None"], ["", "def", "format", "(", "self", ",", "outputs", ",", "targets_dict", ")", ":", "\n", "        ", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", "\n", "if", "self", ".", "ignore_first_char", ":", "\n", "            ", "targets", "=", "targets", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", "\n", "outputs", "=", "outputs", "[", ":", ",", ":", "-", "1", ",", ":", "]", "\n", "\n", "", "outputs", "=", "outputs", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "return", "outputs", ",", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.CELoss.forward": [[46, 64], ["ce_loss.CELoss.format", "ce_loss.CELoss.loss_ce", "dict", "targets.to"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.TFLoss.format"], ["", "def", "forward", "(", "self", ",", "outputs", ",", "targets_dict", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            outputs (Tensor): A raw logit tensor of shape :math:`(N, T, C)`.\n            targets_dict (dict): A dict with a key ``padded_targets``, which is\n                a tensor of shape :math:`(N, T)`. Each element is the index of\n                a character.\n            img_metas (None): Unused.\n\n        Returns:\n            dict: A loss dict with the key ``loss_ce``.\n        \"\"\"", "\n", "outputs", ",", "targets", "=", "self", ".", "format", "(", "outputs", ",", "targets_dict", ")", "\n", "\n", "loss_ce", "=", "self", ".", "loss_ce", "(", "outputs", ",", "targets", ".", "to", "(", "outputs", ".", "device", ")", ")", "\n", "losses", "=", "dict", "(", "loss_ce", "=", "loss_ce", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.SARLoss.__init__": [[82, 84], ["ce_loss.CELoss.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "ignore_index", "=", "-", "1", ",", "reduction", "=", "'mean'", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "ignore_index", ",", "reduction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.SARLoss.format": [[85, 96], ["targets[].contiguous", "outputs[].permute().contiguous", "outputs[].permute"], "methods", ["None"], ["", "def", "format", "(", "self", ",", "outputs", ",", "targets_dict", ")", ":", "\n", "        ", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", "\n", "# targets[0, :], [start_idx, idx1, idx2, ..., end_idx, pad_idx...]", "\n", "# outputs[0, :, 0], [idx1, idx2, ..., end_idx, ...]", "\n", "\n", "# ignore first index of target in loss calculation", "\n", "targets", "=", "targets", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", "\n", "# ignore last index of outputs to be in same seq_len with targets", "\n", "outputs", "=", "outputs", "[", ":", ",", ":", "-", "1", ",", ":", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "return", "outputs", ",", "targets", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.TFLoss.__init__": [[113, 122], ["ce_loss.CELoss.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "ignore_index", "=", "-", "1", ",", "\n", "reduction", "=", "'none'", ",", "\n", "flatten", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "ignore_index", ",", "reduction", ")", "\n", "assert", "isinstance", "(", "flatten", ",", "bool", ")", "\n", "\n", "self", ".", "flatten", "=", "flatten", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.TFLoss.format": [[123, 134], ["outputs[].contiguous", "targets[].contiguous", "outputs.permute().contiguous.permute().contiguous.view", "targets.view.view.view", "outputs.permute().contiguous.permute().contiguous.permute().contiguous", "outputs.permute().contiguous.permute().contiguous.size", "outputs.permute().contiguous.permute().contiguous.permute"], "methods", ["None"], ["", "def", "format", "(", "self", ",", "outputs", ",", "targets_dict", ")", ":", "\n", "        ", "outputs", "=", "outputs", "[", ":", ",", ":", "-", "1", ",", ":", "]", ".", "contiguous", "(", ")", "\n", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", "\n", "targets", "=", "targets", "[", ":", ",", "1", ":", "]", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "flatten", ":", "\n", "            ", "outputs", "=", "outputs", ".", "view", "(", "-", "1", ",", "outputs", ".", "size", "(", "-", "1", ")", ")", "\n", "targets", "=", "targets", ".", "view", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "outputs", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "", "return", "outputs", ",", "targets", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.seg_loss.SegLoss.__init__": [[23, 37], ["torch.Module.__init__", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "seg_downsample_ratio", "=", "0.5", ",", "\n", "seg_with_loss_weight", "=", "True", ",", "\n", "ignore_index", "=", "255", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "isinstance", "(", "seg_downsample_ratio", ",", "(", "int", ",", "float", ")", ")", "\n", "assert", "0", "<", "seg_downsample_ratio", "<=", "1", "\n", "assert", "isinstance", "(", "ignore_index", ",", "int", ")", "\n", "\n", "self", ".", "seg_downsample_ratio", "=", "seg_downsample_ratio", "\n", "self", ".", "seg_with_loss_weight", "=", "seg_with_loss_weight", "\n", "self", ".", "ignore_index", "=", "ignore_index", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.seg_loss.SegLoss.seg_loss": [[38, 61], ["torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.stack().squeeze", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "item[].rescale().to_tensor", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "seg_map.size", "item[].rescale"], "methods", ["None"], ["", "def", "seg_loss", "(", "self", ",", "out_head", ",", "gt_kernels", ")", ":", "\n", "        ", "seg_map", "=", "out_head", "# bsz * num_classes * H/2 * W/2", "\n", "seg_target", "=", "[", "\n", "item", "[", "1", "]", ".", "rescale", "(", "self", ".", "seg_downsample_ratio", ")", ".", "to_tensor", "(", "\n", "torch", ".", "long", ",", "seg_map", ".", "device", ")", "for", "item", "in", "gt_kernels", "\n", "]", "\n", "seg_target", "=", "torch", ".", "stack", "(", "seg_target", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "loss_weight", "=", "None", "\n", "if", "self", ".", "seg_with_loss_weight", ":", "\n", "            ", "N", "=", "torch", ".", "sum", "(", "seg_target", "!=", "self", ".", "ignore_index", ")", "\n", "N_neg", "=", "torch", ".", "sum", "(", "seg_target", "==", "0", ")", "\n", "weight_val", "=", "1.0", "*", "N_neg", "/", "(", "N", "-", "N_neg", ")", "\n", "loss_weight", "=", "torch", ".", "ones", "(", "seg_map", ".", "size", "(", "1", ")", ",", "device", "=", "seg_map", ".", "device", ")", "\n", "loss_weight", "[", "1", ":", "]", "=", "weight_val", "\n", "\n", "", "loss_seg", "=", "F", ".", "cross_entropy", "(", "\n", "seg_map", ",", "\n", "seg_target", ",", "\n", "weight", "=", "loss_weight", ",", "\n", "ignore_index", "=", "self", ".", "ignore_index", ")", "\n", "\n", "return", "loss_seg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.seg_loss.SegLoss.forward": [[62, 81], ["seg_loss.SegLoss.seg_loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.seg_loss.SegLoss.seg_loss"], ["", "def", "forward", "(", "self", ",", "out_neck", ",", "out_head", ",", "gt_kernels", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            out_neck (None): Unused.\n            out_head (Tensor): The output from head whose shape\n                is :math:`(N, C, H, W)`.\n            gt_kernels (BitmapMasks): The ground truth masks.\n\n        Returns:\n            dict: A loss dictionary with the key ``loss_seg``.\n        \"\"\"", "\n", "\n", "losses", "=", "{", "}", "\n", "\n", "loss_seg", "=", "self", ".", "seg_loss", "(", "out_head", ",", "gt_kernels", ")", "\n", "\n", "losses", "[", "'loss_seg'", "]", "=", "loss_seg", "\n", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.db_loss.DBLoss.__init__": [[26, 43], ["torch.nn.Module.__init__", "mmocr.models.common.losses.dice_loss.DiceLoss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "alpha", "=", "1", ",", "\n", "beta", "=", "1", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "negative_ratio", "=", "3.0", ",", "\n", "eps", "=", "1e-6", ",", "\n", "bbce_loss", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "reduction", "in", "[", "'mean'", ",", "\n", "'sum'", "]", ",", "\" reduction must in ['mean','sum']\"", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "negative_ratio", "=", "negative_ratio", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "bbce_loss", "=", "bbce_loss", "\n", "self", ".", "dice_loss", "=", "DiceLoss", "(", "eps", "=", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.db_loss.DBLoss.bitmasks2tensor": [[44, 79], ["isinstance", "isinstance", "len", "len", "range", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "result_tensors.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.pad", "torch.pad", "torch.stack.append", "torch.stack.append"], "methods", ["None"], ["", "def", "bitmasks2tensor", "(", "self", ",", "bitmasks", ",", "target_sz", ")", ":", "\n", "        ", "\"\"\"Convert Bitmasks to tensor.\n\n        Args:\n            bitmasks (list[BitmapMasks]): The BitmapMasks list. Each item is\n                for one img.\n            target_sz (tuple(int, int)): The target tensor of size\n                :math:`(H, W)`.\n\n        Returns:\n            list[Tensor]: The list of kernel tensors. Each element stands for\n            one kernel level.\n        \"\"\"", "\n", "assert", "isinstance", "(", "bitmasks", ",", "list", ")", "\n", "assert", "isinstance", "(", "target_sz", ",", "tuple", ")", "\n", "\n", "batch_size", "=", "len", "(", "bitmasks", ")", "\n", "num_levels", "=", "len", "(", "bitmasks", "[", "0", "]", ")", "\n", "\n", "result_tensors", "=", "[", "]", "\n", "\n", "for", "level_inx", "in", "range", "(", "num_levels", ")", ":", "\n", "            ", "kernel", "=", "[", "]", "\n", "for", "batch_inx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "mask", "=", "torch", ".", "from_numpy", "(", "bitmasks", "[", "batch_inx", "]", ".", "masks", "[", "level_inx", "]", ")", "\n", "mask_sz", "=", "mask", ".", "shape", "\n", "pad", "=", "[", "\n", "0", ",", "target_sz", "[", "1", "]", "-", "mask_sz", "[", "1", "]", ",", "0", ",", "target_sz", "[", "0", "]", "-", "mask_sz", "[", "0", "]", "\n", "]", "\n", "mask", "=", "F", ".", "pad", "(", "mask", ",", "pad", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "kernel", ".", "append", "(", "mask", ")", "\n", "", "kernel", "=", "torch", ".", "stack", "(", "kernel", ")", "\n", "result_tensors", ".", "append", "(", "kernel", ")", "\n", "\n", "", "return", "result_tensors", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.db_loss.DBLoss.balance_bce_loss": [[80, 101], ["int", "min", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "positive.float().sum", "int", "int", "positive.float", "negative.float", "negative_loss.view", "negative.float().sum", "gt.max", "gt.min", "pred.max", "pred.min", "positive_loss.sum", "negative_loss.sum", "positive.float", "negative.float"], "methods", ["None"], ["", "def", "balance_bce_loss", "(", "self", ",", "pred", ",", "gt", ",", "mask", ")", ":", "\n", "\n", "        ", "positive", "=", "(", "gt", "*", "mask", ")", "\n", "negative", "=", "(", "(", "1", "-", "gt", ")", "*", "mask", ")", "\n", "positive_count", "=", "int", "(", "positive", ".", "float", "(", ")", ".", "sum", "(", ")", ")", "\n", "negative_count", "=", "min", "(", "\n", "int", "(", "negative", ".", "float", "(", ")", ".", "sum", "(", ")", ")", ",", "\n", "int", "(", "positive_count", "*", "self", ".", "negative_ratio", ")", ")", "\n", "\n", "assert", "gt", ".", "max", "(", ")", "<=", "1", "and", "gt", ".", "min", "(", ")", ">=", "0", "\n", "assert", "pred", ".", "max", "(", ")", "<=", "1", "and", "pred", ".", "min", "(", ")", ">=", "0", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "pred", ",", "gt", ",", "reduction", "=", "'none'", ")", "\n", "positive_loss", "=", "loss", "*", "positive", ".", "float", "(", ")", "\n", "negative_loss", "=", "loss", "*", "negative", ".", "float", "(", ")", "\n", "\n", "negative_loss", ",", "_", "=", "torch", ".", "topk", "(", "negative_loss", ".", "view", "(", "-", "1", ")", ",", "negative_count", ")", "\n", "\n", "balance_loss", "=", "(", "positive_loss", ".", "sum", "(", ")", "+", "negative_loss", ".", "sum", "(", ")", ")", "/", "(", "\n", "positive_count", "+", "negative_count", "+", "self", ".", "eps", ")", "\n", "\n", "return", "balance_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.db_loss.DBLoss.l1_thr_loss": [[102, 106], ["torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "mask.sum", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "l1_thr_loss", "(", "self", ",", "pred", ",", "gt", ",", "mask", ")", ":", "\n", "        ", "thr_loss", "=", "torch", ".", "abs", "(", "(", "pred", "-", "gt", ")", "*", "mask", ")", ".", "sum", "(", ")", "/", "(", "\n", "mask", ".", "sum", "(", ")", "+", "self", ".", "eps", ")", "\n", "return", "thr_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.db_loss.DBLoss.forward": [[107, 166], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "preds.size", "db_loss.DBLoss.dice_loss", "db_loss.DBLoss.l1_thr_loss", "dict", "eval", "db_loss.DBLoss.bitmasks2tensor", "db_loss.DBLoss.balance_bce_loss", "db_loss.DBLoss.dice_loss", "item.rescale", "item.to"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.db_loss.DBLoss.l1_thr_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.balance_bce_loss"], ["", "def", "forward", "(", "self", ",", "preds", ",", "downsample_ratio", ",", "gt_shrink", ",", "gt_shrink_mask", ",", "\n", "gt_thr", ",", "gt_thr_mask", ")", ":", "\n", "        ", "\"\"\"Compute DBNet loss.\n\n        Args:\n            preds (Tensor): The output tensor with size :math:`(N, 3, H, W)`.\n            downsample_ratio (float): The downsample ratio for the\n                ground truths.\n            gt_shrink (list[BitmapMasks]): The mask list with each element\n                being the shrunk text mask for one img.\n            gt_shrink_mask (list[BitmapMasks]): The effective mask list with\n                each element being the shrunk effective mask for one img.\n            gt_thr (list[BitmapMasks]): The mask list with each element\n                being the threshold text mask for one img.\n            gt_thr_mask (list[BitmapMasks]): The effective mask list with\n                each element being the threshold effective mask for one img.\n\n        Returns:\n            dict: The dict for dbnet losses with \"loss_prob\", \"loss_db\" and\n            \"loss_thresh\".\n        \"\"\"", "\n", "assert", "isinstance", "(", "downsample_ratio", ",", "float", ")", "\n", "\n", "assert", "isinstance", "(", "gt_shrink", ",", "list", ")", "\n", "assert", "isinstance", "(", "gt_shrink_mask", ",", "list", ")", "\n", "assert", "isinstance", "(", "gt_thr", ",", "list", ")", "\n", "assert", "isinstance", "(", "gt_thr_mask", ",", "list", ")", "\n", "\n", "pred_prob", "=", "preds", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "pred_thr", "=", "preds", "[", ":", ",", "1", ",", ":", ",", ":", "]", "\n", "pred_db", "=", "preds", "[", ":", ",", "2", ",", ":", ",", ":", "]", "\n", "feature_sz", "=", "preds", ".", "size", "(", ")", "\n", "\n", "keys", "=", "[", "'gt_shrink'", ",", "'gt_shrink_mask'", ",", "'gt_thr'", ",", "'gt_thr_mask'", "]", "\n", "gt", "=", "{", "}", "\n", "for", "k", "in", "keys", ":", "\n", "            ", "gt", "[", "k", "]", "=", "eval", "(", "k", ")", "\n", "gt", "[", "k", "]", "=", "[", "item", ".", "rescale", "(", "downsample_ratio", ")", "for", "item", "in", "gt", "[", "k", "]", "]", "\n", "gt", "[", "k", "]", "=", "self", ".", "bitmasks2tensor", "(", "gt", "[", "k", "]", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "gt", "[", "k", "]", "=", "[", "item", ".", "to", "(", "preds", ".", "device", ")", "for", "item", "in", "gt", "[", "k", "]", "]", "\n", "", "gt", "[", "'gt_shrink'", "]", "[", "0", "]", "=", "(", "gt", "[", "'gt_shrink'", "]", "[", "0", "]", ">", "0", ")", ".", "float", "(", ")", "\n", "if", "self", ".", "bbce_loss", ":", "\n", "            ", "loss_prob", "=", "self", ".", "balance_bce_loss", "(", "pred_prob", ",", "gt", "[", "'gt_shrink'", "]", "[", "0", "]", ",", "\n", "gt", "[", "'gt_shrink_mask'", "]", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "loss_prob", "=", "self", ".", "dice_loss", "(", "pred_prob", ",", "gt", "[", "'gt_shrink'", "]", "[", "0", "]", ",", "\n", "gt", "[", "'gt_shrink_mask'", "]", "[", "0", "]", ")", "\n", "\n", "", "loss_db", "=", "self", ".", "dice_loss", "(", "pred_db", ",", "gt", "[", "'gt_shrink'", "]", "[", "0", "]", ",", "\n", "gt", "[", "'gt_shrink_mask'", "]", "[", "0", "]", ")", "\n", "loss_thr", "=", "self", ".", "l1_thr_loss", "(", "pred_thr", ",", "gt", "[", "'gt_thr'", "]", "[", "0", "]", ",", "\n", "gt", "[", "'gt_thr_mask'", "]", "[", "0", "]", ")", "\n", "\n", "results", "=", "dict", "(", "\n", "loss_prob", "=", "self", ".", "alpha", "*", "loss_prob", ",", "\n", "loss_db", "=", "loss_db", ",", "\n", "loss_thr", "=", "self", ".", "beta", "*", "loss_thr", ")", "\n", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.__init__": [[35, 52], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "alpha", "=", "0.5", ",", "\n", "beta", "=", "0.25", ",", "\n", "delta_aggregation", "=", "0.5", ",", "\n", "delta_discrimination", "=", "3", ",", "\n", "ohem_ratio", "=", "3", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "speedup_bbox_thr", "=", "-", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "reduction", "in", "[", "'mean'", ",", "'sum'", "]", ",", "\"reduction must in ['mean','sum']\"", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "delta_aggregation", "=", "delta_aggregation", "\n", "self", ".", "delta_discrimination", "=", "delta_discrimination", "\n", "self", ".", "ohem_ratio", "=", "ohem_ratio", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "speedup_bbox_thr", "=", "speedup_bbox_thr", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.bitmasks2tensor": [[53, 90], ["mmocr.utils.check_argument.is_type_list", "isinstance", "len", "len", "range", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "results.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.pad", "torch.pad", "torch.stack.append", "torch.stack.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "bitmasks2tensor", "(", "self", ",", "bitmasks", ",", "target_sz", ")", ":", "\n", "        ", "\"\"\"Convert Bitmasks to tensor.\n\n        Args:\n            bitmasks (list[BitmapMasks]): The BitmapMasks list. Each item is\n                for one img.\n            target_sz (tuple(int, int)): The target tensor of size\n                :math:`(H, W)`.\n\n        Returns:\n            list[Tensor]: The list of kernel tensors. Each element stands for\n            one kernel level.\n        \"\"\"", "\n", "assert", "check_argument", ".", "is_type_list", "(", "bitmasks", ",", "BitmapMasks", ")", "\n", "assert", "isinstance", "(", "target_sz", ",", "tuple", ")", "\n", "\n", "batch_size", "=", "len", "(", "bitmasks", ")", "\n", "num_masks", "=", "len", "(", "bitmasks", "[", "0", "]", ")", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "for", "level_inx", "in", "range", "(", "num_masks", ")", ":", "\n", "            ", "kernel", "=", "[", "]", "\n", "for", "batch_inx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "mask", "=", "torch", ".", "from_numpy", "(", "bitmasks", "[", "batch_inx", "]", ".", "masks", "[", "level_inx", "]", ")", "\n", "# hxw", "\n", "mask_sz", "=", "mask", ".", "shape", "\n", "# left, right, top, bottom", "\n", "pad", "=", "[", "\n", "0", ",", "target_sz", "[", "1", "]", "-", "mask_sz", "[", "1", "]", ",", "0", ",", "target_sz", "[", "0", "]", "-", "mask_sz", "[", "0", "]", "\n", "]", "\n", "mask", "=", "F", ".", "pad", "(", "mask", ",", "pad", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "kernel", ".", "append", "(", "mask", ")", "\n", "", "kernel", "=", "torch", ".", "stack", "(", "kernel", ")", "\n", "results", ".", "append", "(", "kernel", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.forward": [[91, 158], ["mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "isinstance", "preds.size", "mapping.items", "pan_loss.PANLoss.aggregation_discrimination_loss", "pan_loss.PANLoss.ohem_batch", "pan_loss.PANLoss.dice_loss_with_logits", "pan_loss.PANLoss.dice_loss_with_logits", "dict", "dict.update", "pan_loss.PANLoss.bitmasks2tensor", "pred_texts.detach", "[].float", "item.rescale", "item.to", "item.mean", "zip", "item.sum"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.aggregation_discrimination_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.ohem_batch", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.dice_loss_with_logits", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.dice_loss_with_logits", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor"], ["", "def", "forward", "(", "self", ",", "preds", ",", "downsample_ratio", ",", "gt_kernels", ",", "gt_mask", ")", ":", "\n", "        ", "\"\"\"Compute PANet loss.\n\n        Args:\n            preds (Tensor): The output tensor of size :math:`(N, 6, H, W)`.\n            downsample_ratio (float): The downsample ratio between preds\n                and the input img.\n            gt_kernels (list[BitmapMasks]): The kernel list with each element\n                being the text kernel mask for one img.\n            gt_mask (list[BitmapMasks]): The effective mask list\n                with each element being the effective mask for one img.\n\n        Returns:\n            dict:  A loss dict with ``loss_text``, ``loss_kernel``,\n            ``loss_aggregation`` and ``loss_discrimination``.\n        \"\"\"", "\n", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_kernels", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_mask", ",", "BitmapMasks", ")", "\n", "assert", "isinstance", "(", "downsample_ratio", ",", "float", ")", "\n", "\n", "pred_texts", "=", "preds", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "pred_kernels", "=", "preds", "[", ":", ",", "1", ",", ":", ",", ":", "]", "\n", "inst_embed", "=", "preds", "[", ":", ",", "2", ":", ",", ":", ",", ":", "]", "\n", "feature_sz", "=", "preds", ".", "size", "(", ")", "\n", "\n", "mapping", "=", "{", "'gt_kernels'", ":", "gt_kernels", ",", "'gt_mask'", ":", "gt_mask", "}", "\n", "gt", "=", "{", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "gt", "[", "key", "]", "=", "value", "\n", "gt", "[", "key", "]", "=", "[", "item", ".", "rescale", "(", "downsample_ratio", ")", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "gt", "[", "key", "]", "=", "self", ".", "bitmasks2tensor", "(", "gt", "[", "key", "]", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "gt", "[", "key", "]", "=", "[", "item", ".", "to", "(", "preds", ".", "device", ")", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "", "loss_aggrs", ",", "loss_discrs", "=", "self", ".", "aggregation_discrimination_loss", "(", "\n", "gt", "[", "'gt_kernels'", "]", "[", "0", "]", ",", "gt", "[", "'gt_kernels'", "]", "[", "1", "]", ",", "inst_embed", ")", "\n", "# compute text loss", "\n", "sampled_mask", "=", "self", ".", "ohem_batch", "(", "pred_texts", ".", "detach", "(", ")", ",", "\n", "gt", "[", "'gt_kernels'", "]", "[", "0", "]", ",", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", "\n", "loss_texts", "=", "self", ".", "dice_loss_with_logits", "(", "pred_texts", ",", "\n", "gt", "[", "'gt_kernels'", "]", "[", "0", "]", ",", "\n", "sampled_mask", ")", "\n", "\n", "# compute kernel loss", "\n", "\n", "sampled_masks_kernel", "=", "(", "gt", "[", "'gt_kernels'", "]", "[", "0", "]", ">", "0.5", ")", ".", "float", "(", ")", "*", "(", "\n", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ".", "float", "(", ")", ")", "\n", "loss_kernels", "=", "self", ".", "dice_loss_with_logits", "(", "pred_kernels", ",", "\n", "gt", "[", "'gt_kernels'", "]", "[", "1", "]", ",", "\n", "sampled_masks_kernel", ")", "\n", "losses", "=", "[", "loss_texts", ",", "loss_kernels", ",", "loss_aggrs", ",", "loss_discrs", "]", "\n", "if", "self", ".", "reduction", "==", "'mean'", ":", "\n", "            ", "losses", "=", "[", "item", ".", "mean", "(", ")", "for", "item", "in", "losses", "]", "\n", "", "elif", "self", ".", "reduction", "==", "'sum'", ":", "\n", "            ", "losses", "=", "[", "item", ".", "sum", "(", ")", "for", "item", "in", "losses", "]", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "coefs", "=", "[", "1", ",", "self", ".", "alpha", ",", "self", ".", "beta", ",", "self", ".", "beta", "]", "\n", "losses", "=", "[", "item", "*", "scale", "for", "item", ",", "scale", "in", "zip", "(", "losses", ",", "coefs", ")", "]", "\n", "\n", "results", "=", "dict", "(", ")", "\n", "results", ".", "update", "(", "\n", "loss_text", "=", "losses", "[", "0", "]", ",", "\n", "loss_kernel", "=", "losses", "[", "1", "]", ",", "\n", "loss_aggregation", "=", "losses", "[", "2", "]", ",", "\n", "loss_discrimination", "=", "losses", "[", "3", "]", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.aggregation_discrimination_loss": [[159, 252], ["gt_texts.contiguous().reshape.contiguous().reshape.contiguous().reshape", "gt_kernels.contiguous().reshape.contiguous().reshape.contiguous().reshape", "inst_embeds.contiguous().reshape.contiguous().reshape.contiguous().reshape", "zip", "gt_texts.contiguous().reshape.contiguous().reshape.size", "int", "len", "loss_aggrs.append", "itertools.combinations", "loss_discrs.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "gt_texts.contiguous().reshape.contiguous().reshape.contiguous", "gt_kernels.contiguous().reshape.contiguous().reshape.contiguous", "inst_embeds.contiguous().reshape.contiguous().reshape.contiguous", "text.max().item", "range", "embed[].mean", "kernel_avgs.append", "torch.max().pow", "torch.max().pow", "torch.max().pow", "torch.max().pow", "torch.log().mean", "torch.log().mean", "torch.log().mean", "torch.log().mean", "torch.tensor.append", "torch.tensor.append", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.max().pow", "torch.max().pow", "torch.max().pow", "torch.max().pow", "torch.log", "torch.log", "torch.log", "torch.log", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "warnings.warn", "numpy.random.choice", "text.max", "kernel_i.sum", "torch.max", "torch.max", "torch.max", "torch.max", "torch.log", "torch.log", "torch.log", "torch.log", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.max", "torch.max", "torch.max", "torch.max", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "embed[].mean.reshape"], "methods", ["None"], ["", "def", "aggregation_discrimination_loss", "(", "self", ",", "gt_texts", ",", "gt_kernels", ",", "\n", "inst_embeds", ")", ":", "\n", "        ", "\"\"\"Compute the aggregation and discrimnative losses.\n\n        Args:\n            gt_texts (Tensor): The ground truth text mask of size\n                :math:`(N, 1, H, W)`.\n            gt_kernels (Tensor): The ground truth text kernel mask of\n                size :math:`(N, 1, H, W)`.\n            inst_embeds(Tensor): The text instance embedding tensor\n                of size :math:`(N, 1, H, W)`.\n\n        Returns:\n            (Tensor, Tensor): A tuple of aggregation loss and discriminative\n            loss before reduction.\n        \"\"\"", "\n", "\n", "batch_size", "=", "gt_texts", ".", "size", "(", ")", "[", "0", "]", "\n", "gt_texts", "=", "gt_texts", ".", "contiguous", "(", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ")", "\n", "gt_kernels", "=", "gt_kernels", ".", "contiguous", "(", ")", ".", "reshape", "(", "batch_size", ",", "-", "1", ")", "\n", "\n", "assert", "inst_embeds", ".", "shape", "[", "1", "]", "==", "4", "\n", "inst_embeds", "=", "inst_embeds", ".", "contiguous", "(", ")", ".", "reshape", "(", "batch_size", ",", "4", ",", "-", "1", ")", "\n", "\n", "loss_aggrs", "=", "[", "]", "\n", "loss_discrs", "=", "[", "]", "\n", "\n", "for", "text", ",", "kernel", ",", "embed", "in", "zip", "(", "gt_texts", ",", "gt_kernels", ",", "inst_embeds", ")", ":", "\n", "\n", "# for each image", "\n", "            ", "text_num", "=", "int", "(", "text", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "loss_aggr_img", "=", "[", "]", "\n", "kernel_avgs", "=", "[", "]", "\n", "select_num", "=", "self", ".", "speedup_bbox_thr", "\n", "if", "0", "<", "select_num", "<", "text_num", ":", "\n", "                ", "inds", "=", "np", ".", "random", ".", "choice", "(", "\n", "text_num", ",", "select_num", ",", "replace", "=", "False", ")", "+", "1", "\n", "", "else", ":", "\n", "                ", "inds", "=", "range", "(", "1", ",", "text_num", "+", "1", ")", "\n", "\n", "", "for", "i", "in", "inds", ":", "\n", "# for each text instance", "\n", "                ", "kernel_i", "=", "(", "kernel", "==", "i", ")", "# 0.2ms", "\n", "if", "kernel_i", ".", "sum", "(", ")", "==", "0", "or", "(", "text", "==", "i", ")", ".", "sum", "(", ")", "==", "0", ":", "# 0.2ms", "\n", "                    ", "continue", "\n", "\n", "# compute G_Ki in Eq (2)", "\n", "", "avg", "=", "embed", "[", ":", ",", "kernel_i", "]", ".", "mean", "(", "1", ")", "# 0.5ms", "\n", "kernel_avgs", ".", "append", "(", "avg", ")", "\n", "\n", "embed_i", "=", "embed", "[", ":", ",", "text", "==", "i", "]", "# 0.6ms", "\n", "# ||F(p) - G(K_i)|| - delta_aggregation, shape: nums", "\n", "distance", "=", "(", "embed_i", "-", "avg", ".", "reshape", "(", "4", ",", "1", ")", ")", ".", "norm", "(", "# 0.5ms", "\n", "2", ",", "dim", "=", "0", ")", "-", "self", ".", "delta_aggregation", "\n", "# compute D(p,K_i) in Eq (2)", "\n", "hinge", "=", "torch", ".", "max", "(", "\n", "distance", ",", "\n", "torch", ".", "tensor", "(", "0", ",", "device", "=", "distance", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "float", ")", ")", ".", "pow", "(", "2", ")", "\n", "\n", "aggr", "=", "torch", ".", "log", "(", "hinge", "+", "1", ")", ".", "mean", "(", ")", "\n", "loss_aggr_img", ".", "append", "(", "aggr", ")", "\n", "\n", "", "num_inst", "=", "len", "(", "loss_aggr_img", ")", "\n", "if", "num_inst", ">", "0", ":", "\n", "                ", "loss_aggr_img", "=", "torch", ".", "stack", "(", "loss_aggr_img", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "loss_aggr_img", "=", "torch", ".", "tensor", "(", "\n", "0", ",", "device", "=", "gt_texts", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "", "loss_aggrs", ".", "append", "(", "loss_aggr_img", ")", "\n", "\n", "loss_discr_img", "=", "0", "\n", "for", "avg_i", ",", "avg_j", "in", "itertools", ".", "combinations", "(", "kernel_avgs", ",", "2", ")", ":", "\n", "# delta_discrimination - ||G(K_i) - G(K_j)||", "\n", "                ", "distance_ij", "=", "self", ".", "delta_discrimination", "-", "(", "avg_i", "-", "\n", "avg_j", ")", ".", "norm", "(", "2", ")", "\n", "# D(K_i,K_j)", "\n", "D_ij", "=", "torch", ".", "max", "(", "\n", "distance_ij", ",", "\n", "torch", ".", "tensor", "(", "\n", "0", ",", "device", "=", "distance_ij", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "float", ")", ")", ".", "pow", "(", "2", ")", "\n", "loss_discr_img", "+=", "torch", ".", "log", "(", "D_ij", "+", "1", ")", "\n", "\n", "", "if", "num_inst", ">", "1", ":", "\n", "                ", "loss_discr_img", "/=", "(", "num_inst", "*", "(", "num_inst", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "loss_discr_img", "=", "torch", ".", "tensor", "(", "\n", "0", ",", "device", "=", "gt_texts", ".", "device", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "", "if", "num_inst", "==", "0", ":", "\n", "                ", "warnings", ".", "warn", "(", "'num of instance is 0'", ")", "\n", "", "loss_discrs", ".", "append", "(", "loss_discr_img", ")", "\n", "", "return", "torch", ".", "stack", "(", "loss_aggrs", ")", ",", "torch", ".", "stack", "(", "loss_discrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.dice_loss_with_logits": [[253, 272], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "pred.contiguous().view.contiguous().view.contiguous().view", "target.contiguous().view.contiguous().view.contiguous().view", "mask.contiguous().view.contiguous().view.contiguous().view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "pred.contiguous().view.contiguous().view.contiguous", "pred.contiguous().view.contiguous().view.size", "target.contiguous().view.contiguous().view.contiguous", "target.contiguous().view.contiguous().view.size", "mask.contiguous().view.contiguous().view.contiguous", "mask.contiguous().view.contiguous().view.size"], "methods", ["None"], ["", "def", "dice_loss_with_logits", "(", "self", ",", "pred", ",", "target", ",", "mask", ")", ":", "\n", "\n", "        ", "smooth", "=", "0.001", "\n", "\n", "pred", "=", "torch", ".", "sigmoid", "(", "pred", ")", "\n", "target", "[", "target", "<=", "0.5", "]", "=", "0", "\n", "target", "[", "target", ">", "0.5", "]", "=", "1", "\n", "pred", "=", "pred", ".", "contiguous", "(", ")", ".", "view", "(", "pred", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "target", "=", "target", ".", "contiguous", "(", ")", ".", "view", "(", "target", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "mask", "=", "mask", ".", "contiguous", "(", ")", ".", "view", "(", "mask", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "pred", "=", "pred", "*", "mask", "\n", "target", "=", "target", "*", "mask", "\n", "\n", "a", "=", "torch", ".", "sum", "(", "pred", "*", "target", ",", "1", ")", "+", "smooth", "\n", "b", "=", "torch", ".", "sum", "(", "pred", "*", "pred", ",", "1", ")", "+", "smooth", "\n", "c", "=", "torch", ".", "sum", "(", "target", "*", "target", ",", "1", ")", "+", "smooth", "\n", "d", "=", "(", "2", "*", "a", ")", "/", "(", "b", "+", "c", ")", "\n", "return", "1", "-", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.ohem_img": [[273, 307], ["isinstance", "isinstance", "isinstance", "int", "int", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "len", "int", "int", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "min", "warnings.warn", "gt_mask.bool", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum().item", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "ohem_img", "(", "self", ",", "text_score", ",", "gt_text", ",", "gt_mask", ")", ":", "\n", "        ", "\"\"\"Sample the top-k maximal negative samples and all positive samples.\n\n        Args:\n            text_score (Tensor): The text score of size :math:`(H, W)`.\n            gt_text (Tensor): The ground truth text mask of size\n                :math:`(H, W)`.\n            gt_mask (Tensor): The effective region mask of size :math:`(H, W)`.\n\n        Returns:\n            Tensor: The sampled pixel mask of size :math:`(H, W)`.\n        \"\"\"", "\n", "assert", "isinstance", "(", "text_score", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "gt_text", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "gt_mask", ",", "torch", ".", "Tensor", ")", "\n", "assert", "len", "(", "text_score", ".", "shape", ")", "==", "2", "\n", "assert", "text_score", ".", "shape", "==", "gt_text", ".", "shape", "\n", "assert", "gt_text", ".", "shape", "==", "gt_mask", ".", "shape", "\n", "\n", "pos_num", "=", "(", "int", ")", "(", "torch", ".", "sum", "(", "gt_text", ">", "0.5", ")", ".", "item", "(", ")", ")", "-", "(", "int", ")", "(", "\n", "torch", ".", "sum", "(", "(", "gt_text", ">", "0.5", ")", "*", "(", "gt_mask", "<=", "0.5", ")", ")", ".", "item", "(", ")", ")", "\n", "neg_num", "=", "(", "int", ")", "(", "torch", ".", "sum", "(", "gt_text", "<=", "0.5", ")", ".", "item", "(", ")", ")", "\n", "neg_num", "=", "(", "int", ")", "(", "min", "(", "pos_num", "*", "self", ".", "ohem_ratio", ",", "neg_num", ")", ")", "\n", "\n", "if", "pos_num", "==", "0", "or", "neg_num", "==", "0", ":", "\n", "            ", "warnings", ".", "warn", "(", "'pos_num = 0 or neg_num = 0'", ")", "\n", "return", "gt_mask", ".", "bool", "(", ")", "\n", "\n", "", "neg_score", "=", "text_score", "[", "gt_text", "<=", "0.5", "]", "\n", "neg_score_sorted", ",", "_", "=", "torch", ".", "sort", "(", "neg_score", ",", "descending", "=", "True", ")", "\n", "threshold", "=", "neg_score_sorted", "[", "neg_num", "-", "1", "]", "\n", "sampled_mask", "=", "(", "(", "(", "text_score", ">=", "threshold", ")", "+", "(", "gt_text", ">", "0.5", ")", ")", ">", "0", ")", "*", "(", "\n", "gt_mask", ">", "0.5", ")", "\n", "return", "sampled_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.ohem_batch": [[308, 334], ["isinstance", "isinstance", "isinstance", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "len", "torch.stack.append", "torch.stack.append", "pan_loss.PANLoss.ohem_img"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.ohem_img"], ["", "def", "ohem_batch", "(", "self", ",", "text_scores", ",", "gt_texts", ",", "gt_mask", ")", ":", "\n", "        ", "\"\"\"OHEM sampling for a batch of imgs.\n\n        Args:\n            text_scores (Tensor): The text scores of size :math:`(H, W)`.\n            gt_texts (Tensor): The gt text masks of size :math:`(H, W)`.\n            gt_mask (Tensor): The gt effective mask of size :math:`(H, W)`.\n\n        Returns:\n            Tensor: The sampled mask of size :math:`(H, W)`.\n        \"\"\"", "\n", "assert", "isinstance", "(", "text_scores", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "gt_texts", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "gt_mask", ",", "torch", ".", "Tensor", ")", "\n", "assert", "len", "(", "text_scores", ".", "shape", ")", "==", "3", "\n", "assert", "text_scores", ".", "shape", "==", "gt_texts", ".", "shape", "\n", "assert", "gt_texts", ".", "shape", "==", "gt_mask", ".", "shape", "\n", "\n", "sampled_masks", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "text_scores", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "sampled_masks", ".", "append", "(", "\n", "self", ".", "ohem_img", "(", "text_scores", "[", "i", "]", ",", "gt_texts", "[", "i", "]", ",", "gt_mask", "[", "i", "]", ")", ")", "\n", "\n", "", "sampled_masks", "=", "torch", ".", "stack", "(", "sampled_masks", ")", "\n", "\n", "return", "sampled_masks", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pse_loss.PSELoss.__init__": [[25, 37], ["PANLoss.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "alpha", "=", "0.7", ",", "\n", "ohem_ratio", "=", "3", ",", "\n", "reduction", "=", "'mean'", ",", "\n", "kernel_sample_type", "=", "'adaptive'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "reduction", "in", "[", "'mean'", ",", "'sum'", "\n", "]", ",", "\"reduction must be either of ['mean','sum']\"", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "ohem_ratio", "=", "ohem_ratio", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "kernel_sample_type", "=", "kernel_sample_type", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pse_loss.PSELoss.forward": [[38, 107], ["mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "isinstance", "score_maps.size", "pse_loss.PSELoss.bitmasks2tensor", "pse_loss.PSELoss.bitmasks2tensor", "pse_loss.PSELoss.ohem_batch", "pse_loss.PSELoss.dice_loss_with_logits", "losses.append", "range", "losses.append", "dict", "item.rescale", "item.to", "item.rescale", "item.to", "pred_texts.detach", "pse_loss.PSELoss.dice_loss_with_logits", "loss_list.append", "gt_mask[].float", "len", "len", "item.mean", "gt_mask[].float", "sum", "item.sum"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.ohem_batch", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.dice_loss_with_logits", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.dice_loss_with_logits"], ["", "def", "forward", "(", "self", ",", "score_maps", ",", "downsample_ratio", ",", "gt_kernels", ",", "gt_mask", ")", ":", "\n", "        ", "\"\"\"Compute PSENet loss.\n\n        Args:\n            score_maps (tensor): The output tensor with size of Nx6xHxW.\n            downsample_ratio (float): The downsample ratio between score_maps\n                and the input img.\n            gt_kernels (list[BitmapMasks]): The kernel list with each element\n                being the text kernel mask for one img.\n            gt_mask (list[BitmapMasks]): The effective mask list\n                with each element being the effective mask for one img.\n\n        Returns:\n            dict:  A loss dict with ``loss_text`` and ``loss_kernel``.\n        \"\"\"", "\n", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_kernels", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_mask", ",", "BitmapMasks", ")", "\n", "assert", "isinstance", "(", "downsample_ratio", ",", "float", ")", "\n", "losses", "=", "[", "]", "\n", "\n", "pred_texts", "=", "score_maps", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "pred_kernels", "=", "score_maps", "[", ":", ",", "1", ":", ",", ":", ",", ":", "]", "\n", "feature_sz", "=", "score_maps", ".", "size", "(", ")", "\n", "\n", "gt_kernels", "=", "[", "item", ".", "rescale", "(", "downsample_ratio", ")", "for", "item", "in", "gt_kernels", "]", "\n", "gt_kernels", "=", "self", ".", "bitmasks2tensor", "(", "gt_kernels", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "gt_kernels", "=", "[", "item", ".", "to", "(", "score_maps", ".", "device", ")", "for", "item", "in", "gt_kernels", "]", "\n", "\n", "gt_mask", "=", "[", "item", ".", "rescale", "(", "downsample_ratio", ")", "for", "item", "in", "gt_mask", "]", "\n", "gt_mask", "=", "self", ".", "bitmasks2tensor", "(", "gt_mask", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "gt_mask", "=", "[", "item", ".", "to", "(", "score_maps", ".", "device", ")", "for", "item", "in", "gt_mask", "]", "\n", "\n", "# compute text loss", "\n", "sampled_masks_text", "=", "self", ".", "ohem_batch", "(", "pred_texts", ".", "detach", "(", ")", ",", "\n", "gt_kernels", "[", "0", "]", ",", "gt_mask", "[", "0", "]", ")", "\n", "loss_texts", "=", "self", ".", "dice_loss_with_logits", "(", "pred_texts", ",", "gt_kernels", "[", "0", "]", ",", "\n", "sampled_masks_text", ")", "\n", "losses", ".", "append", "(", "self", ".", "alpha", "*", "loss_texts", ")", "\n", "\n", "# compute kernel loss", "\n", "if", "self", ".", "kernel_sample_type", "==", "'hard'", ":", "\n", "            ", "sampled_masks_kernel", "=", "(", "gt_kernels", "[", "0", "]", ">", "0.5", ")", ".", "float", "(", ")", "*", "(", "\n", "gt_mask", "[", "0", "]", ".", "float", "(", ")", ")", "\n", "", "elif", "self", ".", "kernel_sample_type", "==", "'adaptive'", ":", "\n", "            ", "sampled_masks_kernel", "=", "(", "pred_texts", ">", "0", ")", ".", "float", "(", ")", "*", "(", "\n", "gt_mask", "[", "0", "]", ".", "float", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "num_kernel", "=", "pred_kernels", ".", "shape", "[", "1", "]", "\n", "assert", "num_kernel", "==", "len", "(", "gt_kernels", ")", "-", "1", "\n", "loss_list", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "num_kernel", ")", ":", "\n", "            ", "loss_kernels", "=", "self", ".", "dice_loss_with_logits", "(", "\n", "pred_kernels", "[", ":", ",", "idx", ",", ":", ",", ":", "]", ",", "gt_kernels", "[", "1", "+", "idx", "]", ",", "\n", "sampled_masks_kernel", ")", "\n", "loss_list", ".", "append", "(", "loss_kernels", ")", "\n", "\n", "", "losses", ".", "append", "(", "(", "1", "-", "self", ".", "alpha", ")", "*", "sum", "(", "loss_list", ")", "/", "len", "(", "loss_list", ")", ")", "\n", "\n", "if", "self", ".", "reduction", "==", "'mean'", ":", "\n", "            ", "losses", "=", "[", "item", ".", "mean", "(", ")", "for", "item", "in", "losses", "]", "\n", "", "elif", "self", ".", "reduction", "==", "'sum'", ":", "\n", "            ", "losses", "=", "[", "item", ".", "sum", "(", ")", "for", "item", "in", "losses", "]", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "results", "=", "dict", "(", "loss_text", "=", "losses", "[", "0", "]", ",", "loss_kernel", "=", "losses", "[", "1", "]", ")", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.textsnake_loss.TextSnakeLoss.__init__": [[23, 26], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "ohem_ratio", "=", "3.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "ohem_ratio", "=", "ohem_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.textsnake_loss.TextSnakeLoss.balanced_bce_loss": [[27, 52], ["int", "gt.float.float.float", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "positive.float().sum", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "min", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "negative_loss.view", "negative.float", "int", "int", "negative.float", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "float", "positive.float", "positive.float", "negative.float().sum", "negative.float"], "methods", ["None"], ["", "def", "balanced_bce_loss", "(", "self", ",", "pred", ",", "gt", ",", "mask", ")", ":", "\n", "\n", "        ", "assert", "pred", ".", "shape", "==", "gt", ".", "shape", "==", "mask", ".", "shape", "\n", "positive", "=", "gt", "*", "mask", "\n", "negative", "=", "(", "1", "-", "gt", ")", "*", "mask", "\n", "positive_count", "=", "int", "(", "positive", ".", "float", "(", ")", ".", "sum", "(", ")", ")", "\n", "gt", "=", "gt", ".", "float", "(", ")", "\n", "if", "positive_count", ">", "0", ":", "\n", "            ", "loss", "=", "F", ".", "binary_cross_entropy", "(", "pred", ",", "gt", ",", "reduction", "=", "'none'", ")", "\n", "positive_loss", "=", "torch", ".", "sum", "(", "loss", "*", "positive", ".", "float", "(", ")", ")", "\n", "negative_loss", "=", "loss", "*", "negative", ".", "float", "(", ")", "\n", "negative_count", "=", "min", "(", "\n", "int", "(", "negative", ".", "float", "(", ")", ".", "sum", "(", ")", ")", ",", "\n", "int", "(", "positive_count", "*", "self", ".", "ohem_ratio", ")", ")", "\n", "", "else", ":", "\n", "            ", "positive_loss", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "pred", ".", "device", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "pred", ",", "gt", ",", "reduction", "=", "'none'", ")", "\n", "negative_loss", "=", "loss", "*", "negative", ".", "float", "(", ")", "\n", "negative_count", "=", "100", "\n", "", "negative_loss", ",", "_", "=", "torch", ".", "topk", "(", "negative_loss", ".", "view", "(", "-", "1", ")", ",", "negative_count", ")", "\n", "\n", "balance_loss", "=", "(", "positive_loss", "+", "torch", ".", "sum", "(", "negative_loss", ")", ")", "/", "(", "\n", "float", "(", "positive_count", "+", "negative_count", ")", "+", "1e-5", ")", "\n", "\n", "return", "balance_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.textsnake_loss.TextSnakeLoss.bitmasks2tensor": [[53, 90], ["mmocr.utils.check_argument.is_type_list", "isinstance", "len", "len", "range", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "results.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.pad", "torch.pad", "torch.stack.append", "torch.stack.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "bitmasks2tensor", "(", "self", ",", "bitmasks", ",", "target_sz", ")", ":", "\n", "        ", "\"\"\"Convert Bitmasks to tensor.\n\n        Args:\n            bitmasks (list[BitmapMasks]): The BitmapMasks list. Each item is\n                for one img.\n            target_sz (tuple(int, int)): The target tensor of size\n                :math:`(H, W)`.\n\n        Returns:\n            list[Tensor]: The list of kernel tensors. Each element stands for\n            one kernel level.\n        \"\"\"", "\n", "assert", "check_argument", ".", "is_type_list", "(", "bitmasks", ",", "BitmapMasks", ")", "\n", "assert", "isinstance", "(", "target_sz", ",", "tuple", ")", "\n", "\n", "batch_size", "=", "len", "(", "bitmasks", ")", "\n", "num_masks", "=", "len", "(", "bitmasks", "[", "0", "]", ")", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "for", "level_inx", "in", "range", "(", "num_masks", ")", ":", "\n", "            ", "kernel", "=", "[", "]", "\n", "for", "batch_inx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "mask", "=", "torch", ".", "from_numpy", "(", "bitmasks", "[", "batch_inx", "]", ".", "masks", "[", "level_inx", "]", ")", "\n", "# hxw", "\n", "mask_sz", "=", "mask", ".", "shape", "\n", "# left, right, top, bottom", "\n", "pad", "=", "[", "\n", "0", ",", "target_sz", "[", "1", "]", "-", "mask_sz", "[", "1", "]", ",", "0", ",", "target_sz", "[", "0", "]", "-", "mask_sz", "[", "0", "]", "\n", "]", "\n", "mask", "=", "F", ".", "pad", "(", "mask", ",", "pad", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "kernel", ".", "append", "(", "mask", ")", "\n", "", "kernel", "=", "torch", ".", "stack", "(", "kernel", ")", "\n", "results", ".", "append", "(", "kernel", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.textsnake_loss.TextSnakeLoss.forward": [[91, 201], ["isinstance", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "pred_maps.size", "mapping.items", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "textsnake_loss.TextSnakeLoss.balanced_bce_loss", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "dict", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "[].float", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "int", "pred_radius_map.size", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "abs", "textsnake_loss.TextSnakeLoss.bitmasks2tensor", "textsnake_loss.TextSnakeLoss.bitmasks2tensor", "item.to", "text_mask.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "center_mask.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "item.rescale", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.textsnake_loss.TextSnakeLoss.balanced_bce_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor"], ["", "def", "forward", "(", "self", ",", "pred_maps", ",", "downsample_ratio", ",", "gt_text_mask", ",", "\n", "gt_center_region_mask", ",", "gt_mask", ",", "gt_radius_map", ",", "gt_sin_map", ",", "\n", "gt_cos_map", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            pred_maps (Tensor): The prediction map of shape\n                :math:`(N, 5, H, W)`, where each dimension is the map of\n                \"text_region\", \"center_region\", \"sin_map\", \"cos_map\", and\n                \"radius_map\" respectively.\n            downsample_ratio (float): Downsample ratio.\n            gt_text_mask (list[BitmapMasks]): Gold text masks.\n            gt_center_region_mask (list[BitmapMasks]): Gold center region\n                masks.\n            gt_mask (list[BitmapMasks]): Gold general masks.\n            gt_radius_map (list[BitmapMasks]): Gold radius maps.\n            gt_sin_map (list[BitmapMasks]): Gold sin maps.\n            gt_cos_map (list[BitmapMasks]): Gold cos maps.\n\n        Returns:\n            dict:  A loss dict with ``loss_text``, ``loss_center``,\n            ``loss_radius``, ``loss_sin`` and ``loss_cos``.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "downsample_ratio", ",", "float", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_text_mask", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_center_region_mask", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_mask", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_radius_map", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_sin_map", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_cos_map", ",", "BitmapMasks", ")", "\n", "\n", "pred_text_region", "=", "pred_maps", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "pred_center_region", "=", "pred_maps", "[", ":", ",", "1", ",", ":", ",", ":", "]", "\n", "pred_sin_map", "=", "pred_maps", "[", ":", ",", "2", ",", ":", ",", ":", "]", "\n", "pred_cos_map", "=", "pred_maps", "[", ":", ",", "3", ",", ":", ",", ":", "]", "\n", "pred_radius_map", "=", "pred_maps", "[", ":", ",", "4", ",", ":", ",", ":", "]", "\n", "feature_sz", "=", "pred_maps", ".", "size", "(", ")", "\n", "device", "=", "pred_maps", ".", "device", "\n", "\n", "# bitmask 2 tensor", "\n", "mapping", "=", "{", "\n", "'gt_text_mask'", ":", "gt_text_mask", ",", "\n", "'gt_center_region_mask'", ":", "gt_center_region_mask", ",", "\n", "'gt_mask'", ":", "gt_mask", ",", "\n", "'gt_radius_map'", ":", "gt_radius_map", ",", "\n", "'gt_sin_map'", ":", "gt_sin_map", ",", "\n", "'gt_cos_map'", ":", "gt_cos_map", "\n", "}", "\n", "gt", "=", "{", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "gt", "[", "key", "]", "=", "value", "\n", "if", "abs", "(", "downsample_ratio", "-", "1.0", ")", "<", "1e-2", ":", "\n", "                ", "gt", "[", "key", "]", "=", "self", ".", "bitmasks2tensor", "(", "gt", "[", "key", "]", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "", "else", ":", "\n", "                ", "gt", "[", "key", "]", "=", "[", "item", ".", "rescale", "(", "downsample_ratio", ")", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "gt", "[", "key", "]", "=", "self", ".", "bitmasks2tensor", "(", "gt", "[", "key", "]", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "if", "key", "==", "'gt_radius_map'", ":", "\n", "                    ", "gt", "[", "key", "]", "=", "[", "item", "*", "downsample_ratio", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "", "", "gt", "[", "key", "]", "=", "[", "item", ".", "to", "(", "device", ")", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "\n", "", "scale", "=", "torch", ".", "sqrt", "(", "1.0", "/", "(", "pred_sin_map", "**", "2", "+", "pred_cos_map", "**", "2", "+", "1e-8", ")", ")", "\n", "pred_sin_map", "=", "pred_sin_map", "*", "scale", "\n", "pred_cos_map", "=", "pred_cos_map", "*", "scale", "\n", "\n", "loss_text", "=", "self", ".", "balanced_bce_loss", "(", "\n", "torch", ".", "sigmoid", "(", "pred_text_region", ")", ",", "gt", "[", "'gt_text_mask'", "]", "[", "0", "]", ",", "\n", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", "\n", "\n", "text_mask", "=", "(", "gt", "[", "'gt_text_mask'", "]", "[", "0", "]", "*", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "loss_center_map", "=", "F", ".", "binary_cross_entropy", "(", "\n", "torch", ".", "sigmoid", "(", "pred_center_region", ")", ",", "\n", "gt", "[", "'gt_center_region_mask'", "]", "[", "0", "]", ".", "float", "(", ")", ",", "\n", "reduction", "=", "'none'", ")", "\n", "if", "int", "(", "text_mask", ".", "sum", "(", ")", ")", ">", "0", ":", "\n", "            ", "loss_center", "=", "torch", ".", "sum", "(", "\n", "loss_center_map", "*", "text_mask", ")", "/", "torch", ".", "sum", "(", "text_mask", ")", "\n", "", "else", ":", "\n", "            ", "loss_center", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "\n", "", "center_mask", "=", "(", "gt", "[", "'gt_center_region_mask'", "]", "[", "0", "]", "*", "\n", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "if", "int", "(", "center_mask", ".", "sum", "(", ")", ")", ">", "0", ":", "\n", "            ", "map_sz", "=", "pred_radius_map", ".", "size", "(", ")", "\n", "ones", "=", "torch", ".", "ones", "(", "map_sz", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "loss_radius", "=", "torch", ".", "sum", "(", "\n", "F", ".", "smooth_l1_loss", "(", "\n", "pred_radius_map", "/", "(", "gt", "[", "'gt_radius_map'", "]", "[", "0", "]", "+", "1e-2", ")", ",", "\n", "ones", ",", "\n", "reduction", "=", "'none'", ")", "*", "center_mask", ")", "/", "torch", ".", "sum", "(", "center_mask", ")", "\n", "loss_sin", "=", "torch", ".", "sum", "(", "\n", "F", ".", "smooth_l1_loss", "(", "\n", "pred_sin_map", ",", "gt", "[", "'gt_sin_map'", "]", "[", "0", "]", ",", "reduction", "=", "'none'", ")", "*", "\n", "center_mask", ")", "/", "torch", ".", "sum", "(", "center_mask", ")", "\n", "loss_cos", "=", "torch", ".", "sum", "(", "\n", "F", ".", "smooth_l1_loss", "(", "\n", "pred_cos_map", ",", "gt", "[", "'gt_cos_map'", "]", "[", "0", "]", ",", "reduction", "=", "'none'", ")", "*", "\n", "center_mask", ")", "/", "torch", ".", "sum", "(", "center_mask", ")", "\n", "", "else", ":", "\n", "            ", "loss_radius", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "loss_sin", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "loss_cos", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "\n", "", "results", "=", "dict", "(", "\n", "loss_text", "=", "loss_text", ",", "\n", "loss_center", "=", "loss_center", ",", "\n", "loss_radius", "=", "loss_radius", ",", "\n", "loss_sin", "=", "loss_sin", ",", "\n", "loss_cos", "=", "loss_cos", ")", "\n", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.__init__": [[23, 26], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "ohem_ratio", "=", "3.0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "ohem_ratio", "=", "ohem_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.balance_bce_loss": [[27, 63], ["int", "gt.float.float.float", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "torch.all", "positive.float().sum", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "min", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "negative_loss.view", "negative.float", "int", "int", "negative.float", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "float", "positive.float", "positive.float", "negative.float().sum", "negative.float"], "methods", ["None"], ["", "def", "balance_bce_loss", "(", "self", ",", "pred", ",", "gt", ",", "mask", ")", ":", "\n", "        ", "\"\"\"Balanced Binary-CrossEntropy Loss.\n\n        Args:\n            pred (Tensor): Shape of :math:`(1, H, W)`.\n            gt (Tensor): Shape of :math:`(1, H, W)`.\n            mask (Tensor): Shape of :math:`(1, H, W)`.\n\n        Returns:\n            Tensor: Balanced bce loss.\n        \"\"\"", "\n", "assert", "pred", ".", "shape", "==", "gt", ".", "shape", "==", "mask", ".", "shape", "\n", "assert", "torch", ".", "all", "(", "pred", ">=", "0", ")", "and", "torch", ".", "all", "(", "pred", "<=", "1", ")", "\n", "assert", "torch", ".", "all", "(", "gt", ">=", "0", ")", "and", "torch", ".", "all", "(", "gt", "<=", "1", ")", "\n", "positive", "=", "gt", "*", "mask", "\n", "negative", "=", "(", "1", "-", "gt", ")", "*", "mask", "\n", "positive_count", "=", "int", "(", "positive", ".", "float", "(", ")", ".", "sum", "(", ")", ")", "\n", "gt", "=", "gt", ".", "float", "(", ")", "\n", "if", "positive_count", ">", "0", ":", "\n", "            ", "loss", "=", "F", ".", "binary_cross_entropy", "(", "pred", ",", "gt", ",", "reduction", "=", "'none'", ")", "\n", "positive_loss", "=", "torch", ".", "sum", "(", "loss", "*", "positive", ".", "float", "(", ")", ")", "\n", "negative_loss", "=", "loss", "*", "negative", ".", "float", "(", ")", "\n", "negative_count", "=", "min", "(", "\n", "int", "(", "negative", ".", "float", "(", ")", ".", "sum", "(", ")", ")", ",", "\n", "int", "(", "positive_count", "*", "self", ".", "ohem_ratio", ")", ")", "\n", "", "else", ":", "\n", "            ", "positive_loss", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "pred", ".", "device", ")", "\n", "loss", "=", "F", ".", "binary_cross_entropy", "(", "pred", ",", "gt", ",", "reduction", "=", "'none'", ")", "\n", "negative_loss", "=", "loss", "*", "negative", ".", "float", "(", ")", "\n", "negative_count", "=", "100", "\n", "", "negative_loss", ",", "_", "=", "torch", ".", "topk", "(", "negative_loss", ".", "view", "(", "-", "1", ")", ",", "negative_count", ")", "\n", "\n", "balance_loss", "=", "(", "positive_loss", "+", "torch", ".", "sum", "(", "negative_loss", ")", ")", "/", "(", "\n", "float", "(", "positive_count", "+", "negative_count", ")", "+", "1e-5", ")", "\n", "\n", "return", "balance_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.gcn_loss": [[64, 81], ["gt_labels.view().to.view().to.view().to", "torch.cross_entropy", "torch.cross_entropy", "gt_labels.view().to.view().to.view"], "methods", ["None"], ["", "def", "gcn_loss", "(", "self", ",", "gcn_data", ")", ":", "\n", "        ", "\"\"\"CrossEntropy Loss from gcn module.\n\n        Args:\n            gcn_data (tuple(Tensor, Tensor)): The first is the\n                prediction with shape :math:`(N, 2)` and the\n                second is the gt label with shape :math:`(m, n)`\n                where :math:`m * n = N`.\n\n        Returns:\n            Tensor: CrossEntropy loss.\n        \"\"\"", "\n", "gcn_pred", ",", "gt_labels", "=", "gcn_data", "\n", "gt_labels", "=", "gt_labels", ".", "view", "(", "-", "1", ")", ".", "to", "(", "gcn_pred", ".", "device", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "gcn_pred", ",", "gt_labels", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor": [[82, 119], ["mmocr.utils.check_argument.is_type_list", "isinstance", "len", "len", "range", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "results.append", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.pad", "torch.pad", "torch.stack.append", "torch.stack.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "bitmasks2tensor", "(", "self", ",", "bitmasks", ",", "target_sz", ")", ":", "\n", "        ", "\"\"\"Convert Bitmasks to tensor.\n\n        Args:\n            bitmasks (list[BitmapMasks]): The BitmapMasks list. Each item is\n                for one img.\n            target_sz (tuple(int, int)): The target tensor of size\n                :math:`(H, W)`.\n\n        Returns:\n            list[Tensor]: The list of kernel tensors. Each element stands for\n            one kernel level.\n        \"\"\"", "\n", "assert", "check_argument", ".", "is_type_list", "(", "bitmasks", ",", "BitmapMasks", ")", "\n", "assert", "isinstance", "(", "target_sz", ",", "tuple", ")", "\n", "\n", "batch_size", "=", "len", "(", "bitmasks", ")", "\n", "num_masks", "=", "len", "(", "bitmasks", "[", "0", "]", ")", "\n", "\n", "results", "=", "[", "]", "\n", "\n", "for", "level_inx", "in", "range", "(", "num_masks", ")", ":", "\n", "            ", "kernel", "=", "[", "]", "\n", "for", "batch_inx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "mask", "=", "torch", ".", "from_numpy", "(", "bitmasks", "[", "batch_inx", "]", ".", "masks", "[", "level_inx", "]", ")", "\n", "# hxw", "\n", "mask_sz", "=", "mask", ".", "shape", "\n", "# left, right, top, bottom", "\n", "pad", "=", "[", "\n", "0", ",", "target_sz", "[", "1", "]", "-", "mask_sz", "[", "1", "]", ",", "0", ",", "target_sz", "[", "0", "]", "-", "mask_sz", "[", "0", "]", "\n", "]", "\n", "mask", "=", "F", ".", "pad", "(", "mask", ",", "pad", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "kernel", ".", "append", "(", "mask", ")", "\n", "", "kernel", "=", "torch", ".", "stack", "(", "kernel", ")", "\n", "results", ".", "append", "(", "kernel", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.forward": [[120, 254], ["isinstance", "isinstance", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "mmocr.utils.check_argument.is_type_list", "pred_maps.size", "mapping.items", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "drrg_loss.DRRGLoss.balance_bce_loss", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "drrg_loss.DRRGLoss.gcn_loss", "dict", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "[].float", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "int", "pred_top_height_map.size", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "abs", "drrg_loss.DRRGLoss.bitmasks2tensor", "drrg_loss.DRRGLoss.bitmasks2tensor", "item.to", "text_mask.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "center_mask.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "item.rescale", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.log", "torch.log", "torch.log", "torch.log"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.balance_bce_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.gcn_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor"], ["", "def", "forward", "(", "self", ",", "preds", ",", "downsample_ratio", ",", "gt_text_mask", ",", "\n", "gt_center_region_mask", ",", "gt_mask", ",", "gt_top_height_map", ",", "\n", "gt_bot_height_map", ",", "gt_sin_map", ",", "gt_cos_map", ")", ":", "\n", "        ", "\"\"\"Compute Drrg loss.\n\n        Args:\n            preds (tuple(Tensor)): The first is the prediction map\n                with shape :math:`(N, C_{out}, H, W)`.\n                The second is prediction from GCN module, with\n                shape :math:`(N, 2)`.\n                The third is ground-truth label with shape :math:`(N, 8)`.\n            downsample_ratio (float): The downsample ratio.\n            gt_text_mask (list[BitmapMasks]): Text mask.\n            gt_center_region_mask (list[BitmapMasks]): Center region mask.\n            gt_mask (list[BitmapMasks]): Effective mask.\n            gt_top_height_map (list[BitmapMasks]): Top height map.\n            gt_bot_height_map (list[BitmapMasks]): Bottom height map.\n            gt_sin_map (list[BitmapMasks]): Sinusoid map.\n            gt_cos_map (list[BitmapMasks]): Cosine map.\n\n        Returns:\n            dict:  A loss dict with ``loss_text``, ``loss_center``,\n            ``loss_height``, ``loss_sin``, ``loss_cos``, and ``loss_gcn``.\n        \"\"\"", "\n", "assert", "isinstance", "(", "preds", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "downsample_ratio", ",", "float", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_text_mask", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_center_region_mask", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_mask", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_top_height_map", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_bot_height_map", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_sin_map", ",", "BitmapMasks", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "gt_cos_map", ",", "BitmapMasks", ")", "\n", "\n", "pred_maps", ",", "gcn_data", "=", "preds", "\n", "pred_text_region", "=", "pred_maps", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "pred_center_region", "=", "pred_maps", "[", ":", ",", "1", ",", ":", ",", ":", "]", "\n", "pred_sin_map", "=", "pred_maps", "[", ":", ",", "2", ",", ":", ",", ":", "]", "\n", "pred_cos_map", "=", "pred_maps", "[", ":", ",", "3", ",", ":", ",", ":", "]", "\n", "pred_top_height_map", "=", "pred_maps", "[", ":", ",", "4", ",", ":", ",", ":", "]", "\n", "pred_bot_height_map", "=", "pred_maps", "[", ":", ",", "5", ",", ":", ",", ":", "]", "\n", "feature_sz", "=", "pred_maps", ".", "size", "(", ")", "\n", "device", "=", "pred_maps", ".", "device", "\n", "\n", "# bitmask 2 tensor", "\n", "mapping", "=", "{", "\n", "'gt_text_mask'", ":", "gt_text_mask", ",", "\n", "'gt_center_region_mask'", ":", "gt_center_region_mask", ",", "\n", "'gt_mask'", ":", "gt_mask", ",", "\n", "'gt_top_height_map'", ":", "gt_top_height_map", ",", "\n", "'gt_bot_height_map'", ":", "gt_bot_height_map", ",", "\n", "'gt_sin_map'", ":", "gt_sin_map", ",", "\n", "'gt_cos_map'", ":", "gt_cos_map", "\n", "}", "\n", "gt", "=", "{", "}", "\n", "for", "key", ",", "value", "in", "mapping", ".", "items", "(", ")", ":", "\n", "            ", "gt", "[", "key", "]", "=", "value", "\n", "if", "abs", "(", "downsample_ratio", "-", "1.0", ")", "<", "1e-2", ":", "\n", "                ", "gt", "[", "key", "]", "=", "self", ".", "bitmasks2tensor", "(", "gt", "[", "key", "]", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "", "else", ":", "\n", "                ", "gt", "[", "key", "]", "=", "[", "item", ".", "rescale", "(", "downsample_ratio", ")", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "gt", "[", "key", "]", "=", "self", ".", "bitmasks2tensor", "(", "gt", "[", "key", "]", ",", "feature_sz", "[", "2", ":", "]", ")", "\n", "if", "key", "in", "[", "'gt_top_height_map'", ",", "'gt_bot_height_map'", "]", ":", "\n", "                    ", "gt", "[", "key", "]", "=", "[", "item", "*", "downsample_ratio", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "", "", "gt", "[", "key", "]", "=", "[", "item", ".", "to", "(", "device", ")", "for", "item", "in", "gt", "[", "key", "]", "]", "\n", "\n", "", "scale", "=", "torch", ".", "sqrt", "(", "1.0", "/", "(", "pred_sin_map", "**", "2", "+", "pred_cos_map", "**", "2", "+", "1e-8", ")", ")", "\n", "pred_sin_map", "=", "pred_sin_map", "*", "scale", "\n", "pred_cos_map", "=", "pred_cos_map", "*", "scale", "\n", "\n", "loss_text", "=", "self", ".", "balance_bce_loss", "(", "\n", "torch", ".", "sigmoid", "(", "pred_text_region", ")", ",", "gt", "[", "'gt_text_mask'", "]", "[", "0", "]", ",", "\n", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", "\n", "\n", "text_mask", "=", "(", "gt", "[", "'gt_text_mask'", "]", "[", "0", "]", "*", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "negative_text_mask", "=", "(", "(", "1", "-", "gt", "[", "'gt_text_mask'", "]", "[", "0", "]", ")", "*", "\n", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "loss_center_map", "=", "F", ".", "binary_cross_entropy", "(", "\n", "torch", ".", "sigmoid", "(", "pred_center_region", ")", ",", "\n", "gt", "[", "'gt_center_region_mask'", "]", "[", "0", "]", ".", "float", "(", ")", ",", "\n", "reduction", "=", "'none'", ")", "\n", "if", "int", "(", "text_mask", ".", "sum", "(", ")", ")", ">", "0", ":", "\n", "            ", "loss_center_positive", "=", "torch", ".", "sum", "(", "\n", "loss_center_map", "*", "text_mask", ")", "/", "torch", ".", "sum", "(", "text_mask", ")", "\n", "", "else", ":", "\n", "            ", "loss_center_positive", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "", "loss_center_negative", "=", "torch", ".", "sum", "(", "\n", "loss_center_map", "*", "\n", "negative_text_mask", ")", "/", "torch", ".", "sum", "(", "negative_text_mask", ")", "\n", "loss_center", "=", "loss_center_positive", "+", "0.5", "*", "loss_center_negative", "\n", "\n", "center_mask", "=", "(", "gt", "[", "'gt_center_region_mask'", "]", "[", "0", "]", "*", "\n", "gt", "[", "'gt_mask'", "]", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "if", "int", "(", "center_mask", ".", "sum", "(", ")", ")", ">", "0", ":", "\n", "            ", "map_sz", "=", "pred_top_height_map", ".", "size", "(", ")", "\n", "ones", "=", "torch", ".", "ones", "(", "map_sz", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "loss_top", "=", "F", ".", "smooth_l1_loss", "(", "\n", "pred_top_height_map", "/", "(", "gt", "[", "'gt_top_height_map'", "]", "[", "0", "]", "+", "1e-2", ")", ",", "\n", "ones", ",", "\n", "reduction", "=", "'none'", ")", "\n", "loss_bot", "=", "F", ".", "smooth_l1_loss", "(", "\n", "pred_bot_height_map", "/", "(", "gt", "[", "'gt_bot_height_map'", "]", "[", "0", "]", "+", "1e-2", ")", ",", "\n", "ones", ",", "\n", "reduction", "=", "'none'", ")", "\n", "gt_height", "=", "(", "\n", "gt", "[", "'gt_top_height_map'", "]", "[", "0", "]", "+", "gt", "[", "'gt_bot_height_map'", "]", "[", "0", "]", ")", "\n", "loss_height", "=", "torch", ".", "sum", "(", "\n", "(", "torch", ".", "log", "(", "gt_height", "+", "1", ")", "*", "\n", "(", "loss_top", "+", "loss_bot", ")", ")", "*", "center_mask", ")", "/", "torch", ".", "sum", "(", "center_mask", ")", "\n", "\n", "loss_sin", "=", "torch", ".", "sum", "(", "\n", "F", ".", "smooth_l1_loss", "(", "\n", "pred_sin_map", ",", "gt", "[", "'gt_sin_map'", "]", "[", "0", "]", ",", "reduction", "=", "'none'", ")", "*", "\n", "center_mask", ")", "/", "torch", ".", "sum", "(", "center_mask", ")", "\n", "loss_cos", "=", "torch", ".", "sum", "(", "\n", "F", ".", "smooth_l1_loss", "(", "\n", "pred_cos_map", ",", "gt", "[", "'gt_cos_map'", "]", "[", "0", "]", ",", "reduction", "=", "'none'", ")", "*", "\n", "center_mask", ")", "/", "torch", ".", "sum", "(", "center_mask", ")", "\n", "", "else", ":", "\n", "            ", "loss_height", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "loss_sin", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "loss_cos", "=", "torch", ".", "tensor", "(", "0.0", ",", "device", "=", "device", ")", "\n", "\n", "", "loss_gcn", "=", "self", ".", "gcn_loss", "(", "gcn_data", ")", "\n", "\n", "results", "=", "dict", "(", "\n", "loss_text", "=", "loss_text", ",", "\n", "loss_center", "=", "loss_center", ",", "\n", "loss_height", "=", "loss_height", ",", "\n", "loss_sin", "=", "loss_sin", ",", "\n", "loss_cos", "=", "loss_cos", ",", "\n", "loss_gcn", "=", "loss_gcn", ")", "\n", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.__init__": [[25, 30], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "fourier_degree", ",", "num_sample", ",", "ohem_ratio", "=", "3.", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fourier_degree", "=", "fourier_degree", "\n", "self", ".", "num_sample", "=", "num_sample", "\n", "self", ".", "ohem_ratio", "=", "ohem_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.forward": [[31, 85], ["isinstance", "enumerate", "mmdet.core.multi_apply", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "enumerate", "dict", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "sum", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "sum", "sum", "sum", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.stack"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "preds", ",", "_", ",", "p3_maps", ",", "p4_maps", ",", "p5_maps", ")", ":", "\n", "        ", "\"\"\"Compute FCENet loss.\n\n        Args:\n            preds (list[list[Tensor]]): The outer list indicates images\n                in a batch, and the inner list indicates the classification\n                prediction map (with shape :math:`(N, C, H, W)`) and\n                regression map (with shape :math:`(N, C, H, W)`).\n            p3_maps (list[ndarray]): List of leval 3 ground truth target map\n                with shape :math:`(C, H, W)`.\n            p4_maps (list[ndarray]): List of leval 4 ground truth target map\n                with shape :math:`(C, H, W)`.\n            p5_maps (list[ndarray]): List of leval 5 ground truth target map\n                with shape :math:`(C, H, W)`.\n\n        Returns:\n            dict:  A loss dict with ``loss_text``, ``loss_center``,\n            ``loss_reg_x`` and ``loss_reg_y``.\n        \"\"\"", "\n", "assert", "isinstance", "(", "preds", ",", "list", ")", "\n", "assert", "p3_maps", "[", "0", "]", ".", "shape", "[", "0", "]", "==", "4", "*", "self", ".", "fourier_degree", "+", "5", ",", "'fourier degree not equal in FCEhead and FCEtarget'", "\n", "\n", "device", "=", "preds", "[", "0", "]", "[", "0", "]", ".", "device", "\n", "# to tensor", "\n", "gts", "=", "[", "p3_maps", ",", "p4_maps", ",", "p5_maps", "]", "\n", "for", "idx", ",", "maps", "in", "enumerate", "(", "gts", ")", ":", "\n", "            ", "gts", "[", "idx", "]", "=", "torch", ".", "from_numpy", "(", "np", ".", "stack", "(", "maps", ")", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "losses", "=", "multi_apply", "(", "self", ".", "forward_single", ",", "preds", ",", "gts", ")", "\n", "\n", "loss_tr", "=", "torch", ".", "tensor", "(", "0.", ",", "device", "=", "device", ")", ".", "float", "(", ")", "\n", "loss_tcl", "=", "torch", ".", "tensor", "(", "0.", ",", "device", "=", "device", ")", ".", "float", "(", ")", "\n", "loss_reg_x", "=", "torch", ".", "tensor", "(", "0.", ",", "device", "=", "device", ")", ".", "float", "(", ")", "\n", "loss_reg_y", "=", "torch", ".", "tensor", "(", "0.", ",", "device", "=", "device", ")", ".", "float", "(", ")", "\n", "\n", "for", "idx", ",", "loss", "in", "enumerate", "(", "losses", ")", ":", "\n", "            ", "if", "idx", "==", "0", ":", "\n", "                ", "loss_tr", "+=", "sum", "(", "loss", ")", "\n", "", "elif", "idx", "==", "1", ":", "\n", "                ", "loss_tcl", "+=", "sum", "(", "loss", ")", "\n", "", "elif", "idx", "==", "2", ":", "\n", "                ", "loss_reg_x", "+=", "sum", "(", "loss", ")", "\n", "", "else", ":", "\n", "                ", "loss_reg_y", "+=", "sum", "(", "loss", ")", "\n", "\n", "", "", "results", "=", "dict", "(", "\n", "loss_text", "=", "loss_tr", ",", "\n", "loss_center", "=", "loss_tcl", ",", "\n", "loss_reg_x", "=", "loss_reg_x", ",", "\n", "loss_reg_y", "=", "loss_reg_y", ",", "\n", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.forward_single": [[86, 140], ["pred[].permute().contiguous", "pred[].permute().contiguous", "gt.permute().contiguous.permute().contiguous.permute().contiguous", "cls_pred[].view", "cls_pred[].view", "reg_pred[].view", "reg_pred[].view", "gt[].view", "gt[].view", "gt[].view", "gt[].view", "gt[].view", "fce_loss.FCELoss.ohem", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "gt[].view.long", "gt[].view.long", "tr_train_mask.sum().item", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "tr_train_mask.sum().item", "weight.contiguous().view.contiguous().view.contiguous().view", "fce_loss.FCELoss.fourier2poly", "fce_loss.FCELoss.fourier2poly", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "pred[].permute", "pred[].permute", "gt.permute().contiguous.permute().contiguous.permute", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "tcl_mask[].long", "tcl_mask[].long", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "tr_train_mask.sum", "tr_train_mask.sum", "tr_mask[].float", "tcl_mask[].float", "weight.contiguous().view.contiguous().view.contiguous", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tr_train_mask.bool", "tr_neg_mask.bool", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tr_train_mask.bool", "tr_neg_mask.bool", "tr_train_mask.bool", "tr_train_mask.bool", "tr_train_mask.bool", "tr_train_mask.bool", "tr_train_mask.bool", "tr_train_mask.bool"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.ohem", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fourier2poly", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fourier2poly"], ["", "def", "forward_single", "(", "self", ",", "pred", ",", "gt", ")", ":", "\n", "        ", "cls_pred", "=", "pred", "[", "0", "]", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "reg_pred", "=", "pred", "[", "1", "]", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "gt", "=", "gt", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "k", "=", "2", "*", "self", ".", "fourier_degree", "+", "1", "\n", "tr_pred", "=", "cls_pred", "[", ":", ",", ":", ",", ":", ",", ":", "2", "]", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "tcl_pred", "=", "cls_pred", "[", ":", ",", ":", ",", ":", ",", "2", ":", "]", ".", "view", "(", "-", "1", ",", "2", ")", "\n", "x_pred", "=", "reg_pred", "[", ":", ",", ":", ",", ":", ",", "0", ":", "k", "]", ".", "view", "(", "-", "1", ",", "k", ")", "\n", "y_pred", "=", "reg_pred", "[", ":", ",", ":", ",", ":", ",", "k", ":", "2", "*", "k", "]", ".", "view", "(", "-", "1", ",", "k", ")", "\n", "\n", "tr_mask", "=", "gt", "[", ":", ",", ":", ",", ":", ",", ":", "1", "]", ".", "view", "(", "-", "1", ")", "\n", "tcl_mask", "=", "gt", "[", ":", ",", ":", ",", ":", ",", "1", ":", "2", "]", ".", "view", "(", "-", "1", ")", "\n", "train_mask", "=", "gt", "[", ":", ",", ":", ",", ":", ",", "2", ":", "3", "]", ".", "view", "(", "-", "1", ")", "\n", "x_map", "=", "gt", "[", ":", ",", ":", ",", ":", ",", "3", ":", "3", "+", "k", "]", ".", "view", "(", "-", "1", ",", "k", ")", "\n", "y_map", "=", "gt", "[", ":", ",", ":", ",", ":", ",", "3", "+", "k", ":", "]", ".", "view", "(", "-", "1", ",", "k", ")", "\n", "\n", "tr_train_mask", "=", "train_mask", "*", "tr_mask", "\n", "device", "=", "x_map", ".", "device", "\n", "# tr loss", "\n", "loss_tr", "=", "self", ".", "ohem", "(", "tr_pred", ",", "tr_mask", ".", "long", "(", ")", ",", "train_mask", ".", "long", "(", ")", ")", "\n", "\n", "# tcl loss", "\n", "loss_tcl", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "tr_neg_mask", "=", "1", "-", "tr_train_mask", "\n", "if", "tr_train_mask", ".", "sum", "(", ")", ".", "item", "(", ")", ">", "0", ":", "\n", "            ", "loss_tcl_pos", "=", "F", ".", "cross_entropy", "(", "\n", "tcl_pred", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ",", "\n", "tcl_mask", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ".", "long", "(", ")", ")", "\n", "loss_tcl_neg", "=", "F", ".", "cross_entropy", "(", "tcl_pred", "[", "tr_neg_mask", ".", "bool", "(", ")", "]", ",", "\n", "tcl_mask", "[", "tr_neg_mask", ".", "bool", "(", ")", "]", ".", "long", "(", ")", ")", "\n", "loss_tcl", "=", "loss_tcl_pos", "+", "0.5", "*", "loss_tcl_neg", "\n", "\n", "# regression loss", "\n", "", "loss_reg_x", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "loss_reg_y", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "if", "tr_train_mask", ".", "sum", "(", ")", ".", "item", "(", ")", ">", "0", ":", "\n", "            ", "weight", "=", "(", "tr_mask", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ".", "float", "(", ")", "+", "\n", "tcl_mask", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ".", "float", "(", ")", ")", "/", "2", "\n", "weight", "=", "weight", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "ft_x", ",", "ft_y", "=", "self", ".", "fourier2poly", "(", "x_map", ",", "y_map", ")", "\n", "ft_x_pre", ",", "ft_y_pre", "=", "self", ".", "fourier2poly", "(", "x_pred", ",", "y_pred", ")", "\n", "\n", "loss_reg_x", "=", "torch", ".", "mean", "(", "weight", "*", "F", ".", "smooth_l1_loss", "(", "\n", "ft_x_pre", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ",", "\n", "ft_x", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ",", "\n", "reduction", "=", "'none'", ")", ")", "\n", "loss_reg_y", "=", "torch", ".", "mean", "(", "weight", "*", "F", ".", "smooth_l1_loss", "(", "\n", "ft_y_pre", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ",", "\n", "ft_y", "[", "tr_train_mask", ".", "bool", "(", ")", "]", ",", "\n", "reduction", "=", "'none'", ")", ")", "\n", "\n", "", "return", "loss_tr", ",", "loss_tcl", ",", "loss_reg_x", ",", "loss_reg_y", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.ohem": [[141, 165], ["pos.float().sum", "pos.float().sum.item", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "min", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.cross_entropy", "torch.cross_entropy", "len", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "pos.float", "int", "int", "torch.cross_entropy.sum", "neg.float().sum().item", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "pos.float().sum.float", "neg.float().sum", "neg.float"], "methods", ["None"], ["", "def", "ohem", "(", "self", ",", "predict", ",", "target", ",", "train_mask", ")", ":", "\n", "        ", "device", "=", "train_mask", ".", "device", "\n", "pos", "=", "(", "target", "*", "train_mask", ")", ".", "bool", "(", ")", "\n", "neg", "=", "(", "(", "1", "-", "target", ")", "*", "train_mask", ")", ".", "bool", "(", ")", "\n", "\n", "n_pos", "=", "pos", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "\n", "if", "n_pos", ".", "item", "(", ")", ">", "0", ":", "\n", "            ", "loss_pos", "=", "F", ".", "cross_entropy", "(", "\n", "predict", "[", "pos", "]", ",", "target", "[", "pos", "]", ",", "reduction", "=", "'sum'", ")", "\n", "loss_neg", "=", "F", ".", "cross_entropy", "(", "\n", "predict", "[", "neg", "]", ",", "target", "[", "neg", "]", ",", "reduction", "=", "'none'", ")", "\n", "n_neg", "=", "min", "(", "\n", "int", "(", "neg", ".", "float", "(", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", ",", "\n", "int", "(", "self", ".", "ohem_ratio", "*", "n_pos", ".", "float", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "loss_pos", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "to", "(", "device", ")", "\n", "loss_neg", "=", "F", ".", "cross_entropy", "(", "\n", "predict", "[", "neg", "]", ",", "target", "[", "neg", "]", ",", "reduction", "=", "'none'", ")", "\n", "n_neg", "=", "100", "\n", "", "if", "len", "(", "loss_neg", ")", ">", "n_neg", ":", "\n", "            ", "loss_neg", ",", "_", "=", "torch", ".", "topk", "(", "loss_neg", ",", "n_neg", ")", "\n", "\n", "", "return", "(", "loss_pos", "+", "loss_neg", ".", "sum", "(", ")", ")", "/", "(", "n_pos", "+", "n_neg", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.fourier2poly": [[166, 208], ["torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.arange().view", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "fourier2poly", "(", "self", ",", "real_maps", ",", "imag_maps", ")", ":", "\n", "        ", "\"\"\"Transform Fourier coefficient maps to polygon maps.\n\n        Args:\n            real_maps (tensor): A map composed of the real parts of the\n                Fourier coefficients, whose shape is (-1, 2k+1)\n            imag_maps (tensor):A map composed of the imag parts of the\n                Fourier coefficients, whose shape is (-1, 2k+1)\n\n        Returns\n            x_maps (tensor): A map composed of the x value of the polygon\n                represented by n sample points (xn, yn), whose shape is (-1, n)\n            y_maps (tensor): A map composed of the y value of the polygon\n                represented by n sample points (xn, yn), whose shape is (-1, n)\n        \"\"\"", "\n", "\n", "device", "=", "real_maps", ".", "device", "\n", "\n", "k_vect", "=", "torch", ".", "arange", "(", "\n", "-", "self", ".", "fourier_degree", ",", "\n", "self", ".", "fourier_degree", "+", "1", ",", "\n", "dtype", "=", "torch", ".", "float", ",", "\n", "device", "=", "device", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "i_vect", "=", "torch", ".", "arange", "(", "\n", "0", ",", "self", ".", "num_sample", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "transform_matrix", "=", "2", "*", "np", ".", "pi", "/", "self", ".", "num_sample", "*", "torch", ".", "mm", "(", "\n", "k_vect", ",", "i_vect", ")", "\n", "\n", "x1", "=", "torch", ".", "einsum", "(", "'ak, kn-> an'", ",", "real_maps", ",", "\n", "torch", ".", "cos", "(", "transform_matrix", ")", ")", "\n", "x2", "=", "torch", ".", "einsum", "(", "'ak, kn-> an'", ",", "imag_maps", ",", "\n", "torch", ".", "sin", "(", "transform_matrix", ")", ")", "\n", "y1", "=", "torch", ".", "einsum", "(", "'ak, kn-> an'", ",", "real_maps", ",", "\n", "torch", ".", "sin", "(", "transform_matrix", ")", ")", "\n", "y2", "=", "torch", ".", "einsum", "(", "'ak, kn-> an'", ",", "imag_maps", ",", "\n", "torch", ".", "cos", "(", "transform_matrix", ")", ")", "\n", "\n", "x_maps", "=", "x1", "-", "x2", "\n", "y_maps", "=", "y1", "+", "y2", "\n", "\n", "return", "x_maps", ",", "y_maps", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.masked_cross_entropy_loss.MaskedCrossEntropyLoss.__init__": [[20, 24], ["torch.nn.Module.__init__", "torch.nn.CrossEntropyLoss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "num_labels", "=", "None", ",", "ignore_index", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_labels", "=", "num_labels", "\n", "self", ".", "criterion", "=", "CrossEntropyLoss", "(", "ignore_index", "=", "ignore_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.masked_cross_entropy_loss.MaskedCrossEntropyLoss.forward": [[25, 57], ["masked_cross_entropy_loss.MaskedCrossEntropyLoss.criterion", "masked_cross_entropy_loss.MaskedCrossEntropyLoss.criterion", "attention_masks.view", "logits.view", "labels.view", "logits.view", "labels.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "logits", ",", "img_metas", ")", ":", "\n", "        ", "'''Loss forword.\n        Args:\n            logits: Model output with shape [N, C].\n            img_metas (dict): A dict containing the following keys:\n                    - img (list]): This parameter is reserved.\n                    - labels (list[int]): The labels for each word\n                        of the sequence.\n                    - texts (list): The words of the sequence.\n                    - input_ids (list): The ids for each word of\n                        the sequence.\n                    - attention_mask (list): The mask for each word\n                        of the sequence. The mask has 1 for real tokens\n                        and 0 for padding tokens. Only real tokens are\n                        attended to.\n                    - token_type_ids (list): The tokens for each word\n                        of the sequence.\n        '''", "\n", "\n", "labels", "=", "img_metas", "[", "'labels'", "]", "\n", "attention_masks", "=", "img_metas", "[", "'attention_masks'", "]", "\n", "\n", "# Only keep active parts of the loss", "\n", "if", "attention_masks", "is", "not", "None", ":", "\n", "            ", "active_loss", "=", "attention_masks", ".", "view", "(", "-", "1", ")", "==", "1", "\n", "active_logits", "=", "logits", ".", "view", "(", "-", "1", ",", "self", ".", "num_labels", ")", "[", "active_loss", "]", "\n", "active_labels", "=", "labels", ".", "view", "(", "-", "1", ")", "[", "active_loss", "]", "\n", "loss", "=", "self", ".", "criterion", "(", "active_logits", ",", "active_labels", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "self", ".", "criterion", "(", "\n", "logits", ".", "view", "(", "-", "1", ",", "self", ".", "num_labels", ")", ",", "labels", ".", "view", "(", "-", "1", ")", ")", "\n", "", "return", "{", "'loss_cls'", ":", "loss", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.masked_focal_loss.MaskedFocalLoss.__init__": [[20, 24], ["torch.nn.Module.__init__", "mmocr.models.common.losses.focal_loss.FocalLoss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "num_labels", "=", "None", ",", "ignore_index", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_labels", "=", "num_labels", "\n", "self", ".", "criterion", "=", "FocalLoss", "(", "ignore_index", "=", "ignore_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.masked_focal_loss.MaskedFocalLoss.forward": [[25, 57], ["masked_focal_loss.MaskedFocalLoss.criterion", "masked_focal_loss.MaskedFocalLoss.criterion", "attention_masks.view", "logits.view", "labels.view", "logits.view", "labels.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "logits", ",", "img_metas", ")", ":", "\n", "        ", "'''Loss forword.\n        Args:\n            logits: Model output with shape [N, C].\n            img_metas (dict): A dict containing the following keys:\n                    - img (list]): This parameter is reserved.\n                    - labels (list[int]): The labels for each word\n                        of the sequence.\n                    - texts (list): The words of the sequence.\n                    - input_ids (list): The ids for each word of\n                        the sequence.\n                    - attention_mask (list): The mask for each word\n                        of the sequence. The mask has 1 for real tokens\n                        and 0 for padding tokens. Only real tokens are\n                        attended to.\n                    - token_type_ids (list): The tokens for each word\n                        of the sequence.\n        '''", "\n", "\n", "labels", "=", "img_metas", "[", "'labels'", "]", "\n", "attention_masks", "=", "img_metas", "[", "'attention_masks'", "]", "\n", "\n", "# Only keep active parts of the loss", "\n", "if", "attention_masks", "is", "not", "None", ":", "\n", "            ", "active_loss", "=", "attention_masks", ".", "view", "(", "-", "1", ")", "==", "1", "\n", "active_logits", "=", "logits", ".", "view", "(", "-", "1", ",", "self", ".", "num_labels", ")", "[", "active_loss", "]", "\n", "active_labels", "=", "labels", ".", "view", "(", "-", "1", ")", "[", "active_loss", "]", "\n", "loss", "=", "self", ".", "criterion", "(", "active_logits", ",", "active_labels", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "self", ".", "criterion", "(", "\n", "logits", ".", "view", "(", "-", "1", ",", "self", ".", "num_labels", ")", ",", "labels", ".", "view", "(", "-", "1", ")", ")", "\n", "", "return", "{", "'loss_cls'", ":", "loss", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.focal_loss.FocalLoss.__init__": [[19, 24], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "gamma", "=", "2", ",", "weight", "=", "None", ",", "ignore_index", "=", "-", "100", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "weight", "=", "weight", "\n", "self", ".", "ignore_index", "=", "ignore_index", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.focal_loss.FocalLoss.forward": [[25, 32], ["torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.nll_loss", "torch.nll_loss", "torch.nll_loss"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "logit", "=", "F", ".", "log_softmax", "(", "input", ",", "dim", "=", "1", ")", "\n", "pt", "=", "torch", ".", "exp", "(", "logit", ")", "\n", "logit", "=", "(", "1", "-", "pt", ")", "**", "self", ".", "gamma", "*", "logit", "\n", "loss", "=", "F", ".", "nll_loss", "(", "\n", "logit", ",", "target", ",", "self", ".", "weight", ",", "ignore_index", "=", "self", ".", "ignore_index", ")", "\n", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.dice_loss.DiceLoss.__init__": [[11, 15], ["torch.Module.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "isinstance", "(", "eps", ",", "float", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.dice_loss.DiceLoss.forward": [[16, 32], ["pred.contiguous().view.contiguous().view.contiguous().view", "target.contiguous().view.contiguous().view.contiguous().view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "mask.contiguous().view.contiguous().view.contiguous().view", "pred.contiguous().view.contiguous().view.contiguous", "pred.contiguous().view.contiguous().view.size", "target.contiguous().view.contiguous().view.contiguous", "target.contiguous().view.contiguous().view.size", "mask.contiguous().view.contiguous().view.contiguous", "mask.contiguous().view.contiguous().view.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "pred", "=", "pred", ".", "contiguous", "(", ")", ".", "view", "(", "pred", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "target", "=", "target", ".", "contiguous", "(", ")", ".", "view", "(", "target", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "contiguous", "(", ")", ".", "view", "(", "mask", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "pred", "=", "pred", "*", "mask", "\n", "target", "=", "target", "*", "mask", "\n", "\n", "", "a", "=", "torch", ".", "sum", "(", "pred", "*", "target", ")", "\n", "b", "=", "torch", ".", "sum", "(", "pred", ")", "\n", "c", "=", "torch", ".", "sum", "(", "target", ")", "\n", "d", "=", "(", "2", "*", "a", ")", "/", "(", "b", "+", "c", "+", "self", ".", "eps", ")", "\n", "\n", "return", "1", "-", "d", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lv_converter.convert_annotations": [[9, 56], ["isinstance", "isinstance", "mmocr.utils.fileio.list_to_file", "os.join", "open", "f.readlines", "os.join", "anno.split", "word.strip.strip", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "convert_annotations", "(", "root_path", ",", "split", ",", "format", ")", ":", "\n", "    ", "\"\"\"Convert original annotations to mmocr format.\n\n    The annotation format is as the following:\n        Crops/val/11/1/1.png weighted\n        Crops/val/11/1/2.png 26\n        Crops/val/11/1/3.png casting\n        Crops/val/11/1/4.png 28\n    After this module, the annotation has been changed to the format below:\n        jsonl:\n        {'filename': 'Crops/val/11/1/1.png', 'text': 'weighted'}\n        {'filename': 'Crops/val/11/1/1.png', 'text': '26'}\n        {'filename': 'Crops/val/11/1/1.png', 'text': 'casting'}\n        {'filename': 'Crops/val/11/1/1.png', 'text': '28'}\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "assert", "isinstance", "(", "root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "# LV has already provided txt format annos", "\n", "        ", "return", "\n", "\n", "", "if", "format", "==", "'jsonl'", ":", "\n", "        ", "lines", "=", "[", "]", "\n", "with", "open", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.txt'", ")", ",", "\n", "'r'", ",", "\n", "encoding", "=", "'\"utf-8-sig'", ")", "as", "f", ":", "\n", "            ", "annos", "=", "f", ".", "readlines", "(", ")", "\n", "", "for", "anno", "in", "annos", ":", "\n", "            ", "if", "anno", ":", "\n", "# Text may contain spaces", "\n", "                ", "dst_img_name", ",", "word", "=", "anno", ".", "split", "(", "'png '", ")", "\n", "word", "=", "word", ".", "strip", "(", "'\\n'", ")", "\n", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "dst_img_name", "+", "'png'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "list_to_file", "(", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lv_converter.parse_args": [[58, 69], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of Lecture Video DB'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of Lecture Video DB'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lv_converter.main": [[71, 78], ["lv_converter.parse_args", "lv_converter.convert_annotations", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "convert_annotations", "(", "root_path", ",", "split", ",", "args", ".", "format", ")", "\n", "print", "(", "f'{split} split converted.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.collect_files": [[14, 53], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "ann_list.append", "imgs_list.append", "zip", "enumerate", "os.join", "os.join", "ann_file.replace", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "ann_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "ann_file", ".", "replace", "(", "'json'", ",", "'jpg'", ")", ")", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "return", "trn_files", ",", "val_files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.collect_annotations": [[55, 74], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.load_img_info": [[76, 104], ["isinstance", "mmcv.imread", "dict", "rects_converter.load_json_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.json'", ":", "\n", "        ", "img_info", "=", "load_json_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.load_json_info": [[106, 160], ["mmcv.load", "img_info.update", "dict", "anno_info.append"], "function", ["None"], ["", "def", "load_json_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n\n    {\n        \"chars\": [\n            {\n                \"ignore\": 0,\n                \"transcription\": \"H\",\n                \"points\": [25, 175, 112, 175, 112, 286, 25, 286]\n            },\n            {\n                \"ignore\": 0,\n                \"transcription\": \"O\",\n                \"points\": [102, 182, 210, 182, 210, 273, 102, 273]\n            }, ...\n        ]\n        \"lines\": [\n            {\n                \"ignore\": 0,\n                \"transcription\": \"HOKI\",\n                \"points\": [23, 173, 327, 180, 327, 290, 23, 283]\n            },\n            {\n                \"ignore\": 0,\n                \"transcription\": \"TEA\",\n                \"points\": [368, 180, 621, 180, 621, 294, 368, 294]\n            }, ...\n        ]\n    }\n\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "annotation", "[", "'lines'", "]", ":", "\n", "        ", "if", "line", "[", "'ignore'", "]", "==", "1", ":", "\n", "            ", "continue", "\n", "", "segmentation", "=", "line", "[", "'points'", "]", "\n", "word", "=", "line", "[", "'transcription'", "]", "\n", "anno", "=", "dict", "(", "bbox", "=", "segmentation", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.generate_ann": [[162, 223], ["print", "os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "min", "os.join", "os.join", "lines.append", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, whether be txt or jsonl\n    \"\"\"", "\n", "print", "(", "'Cropping images...'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.parse_args": [[225, 244], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of ReCTS.'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of ReCTS'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rects_converter.main": [[246, 268], ["rects_converter.parse_args", "rects_converter.collect_files", "rects_converter.collect_annotations", "os.join", "os.join", "mmcv.Timer", "rects_converter.generate_ann", "len", "rects_converter.collect_annotations", "mmcv.Timer", "rects_converter.generate_ann"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "ratio", "=", "args", ".", "val_ratio", "\n", "\n", "trn_files", ",", "val_files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ",", "ratio", ")", "\n", "\n", "# Train set", "\n", "trn_infos", "=", "collect_annotations", "(", "trn_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert ReCTS Training annotation'", ")", ":", "\n", "        ", "generate_ann", "(", "root_path", ",", "'training'", ",", "trn_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n", "# Val set", "\n", "", "if", "len", "(", "val_files", ")", ">", "0", ":", "\n", "        ", "val_infos", "=", "collect_annotations", "(", "val_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert ReCTS Val annotation'", ")", ":", "\n", "            ", "generate_ann", "(", "root_path", ",", "'val'", ",", "val_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.collect_files": [[14, 44], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "sorted", "sorted", "gt_file.replace", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "gt_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "# Filtering repeated and missing images", "\n", "        ", "if", "'('", "in", "gt_file", "or", "gt_file", "==", "'X51006619570.txt'", ":", "\n", "            ", "continue", "\n", "", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "gt_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "gt_file", ".", "replace", "(", "'.txt'", ",", "'.jpg'", ")", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "sorted", "(", "imgs_list", ")", ",", "sorted", "(", "ann_list", ")", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.collect_annotations": [[46, 67], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.load_img_info": [[69, 99], ["isinstance", "mmcv.imread", "dict", "sroie_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.load_txt_info": [[101, 132], ["img_info.update", "open", "f.readlines", "[].replace().strip", "dict", "anno_info.append", "numpy.array().astype().tolist", "[].replace", "numpy.array().astype", "numpy.array", "ann.split", "ann.split"], "function", ["None"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Annotation Format\n    x1, y1, x2, y2, x3, y3, x4, y4, transcript\n\n    Args:\n        gt_file (list): The list of tuples (image_file, groundtruth_file)\n        img_info (int): The dict of the img and annotation information\n\n    Returns:\n        img_info (list): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'unicode_escape'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "for", "ann", "in", "f", ".", "readlines", "(", ")", ":", "\n", "# skip invalid annotation line", "\n", "            ", "try", ":", "\n", "                ", "bbox", "=", "np", ".", "array", "(", "ann", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", ")", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "", "except", "ValueError", ":", "\n", "\n", "                ", "continue", "\n", "", "word", "=", "ann", ".", "split", "(", "','", ")", "[", "-", "1", "]", ".", "replace", "(", "'\\n'", ",", "''", ")", ".", "strip", "(", ")", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.generate_ann": [[134, 187], ["os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "os.join", "mmcv.imwrite", "lines.append", "min", "len", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        format (str): Annotation format, should be either 'jsonl' or 'txt'\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ",", "\n", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", "or", "len", "(", "word", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.parse_args": [[189, 202], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of SROIE'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of SROIE'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.sroie_converter.main": [[204, 216], ["sroie_converter.parse_args", "print", "mmcv.Timer", "sroie_converter.collect_files", "sroie_converter.collect_annotations", "sroie_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'training'", ",", "'test'", "]", ":", "\n", "        ", "print", "(", "f'Processing {split} set...'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert SROIE annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ")", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "split", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.cocotext_converter.parse_args": [[13, 30], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of COCO Text v2 '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of COCO Text v2'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.cocotext_converter.process_img": [[32, 73], ["mmcv.imread", "enumerate", "os.join", "mmcv.imwrite", "max", "max", "math.ceil", "math.ceil", "os.join", "os.join", "labels.append", "math.floor", "math.floor", "labels.append", "json.dumps", "os.basename", "os.basename"], "function", ["None"], ["", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ",", "ignore_image_root", ",", "\n", "preserve_vertical", ",", "split", ",", "format", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "src_image_root", ",", "img_info", "[", "'file_name'", "]", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "text_label", "=", "ann", "[", "'utf8_string'", "]", "\n", "\n", "# Ignore illegible or non-English words", "\n", "if", "ann", "[", "'language'", "]", "==", "'not english'", ":", "\n", "            ", "continue", "\n", "", "if", "ann", "[", "'legibility'", "]", "==", "'illegible'", ":", "\n", "            ", "continue", "\n", "\n", "", "x", ",", "y", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "\n", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'train'", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "labels", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.cocotext_converter.convert_cocotext": [[75, 164], ["os.join", "mmcv.load", "os.join", "os.join", "os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "functools.partial", "enumerate", "mmcv.track_parallel_progress", "mmocr.utils.fileio.list_to_file", "len", "os.exists", "Exception", "annotation[].values", "tasks.append", "str", "str"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "convert_cocotext", "(", "root_path", ",", "\n", "split", ",", "\n", "preserve_vertical", ",", "\n", "format", ",", "\n", "nproc", ",", "\n", "img_start_idx", "=", "0", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information and crop the images.\n\n    The annotation format is as the following:\n    {\n        'anns':{\n            '45346':{\n                'mask': [468.9,286.7,468.9,295.2,493.0,295.8,493.0,287.2],\n                'class': 'machine printed',\n                'bbox': [468.9, 286.7, 24.1, 9.1], # x, y, w, h\n                'image_id': 217925,\n                'id': 45346,\n                'language': 'english', # 'english' or 'not english'\n                'area': 206.06,\n                'utf8_string': 'New',\n                'legibility': 'legible', # 'legible' or 'illegible'\n            },\n            ...\n        }\n        'imgs':{\n            '540965':{\n                'id': 540965,\n                'set': 'train', # 'train' or 'val'\n                'width': 640,\n                'height': 360,\n                'file_name': 'COCO_train2014_000000540965.jpg'\n            },\n            ...\n        }\n        'imgToAnns':{\n            '540965': [],\n            '260932': [63993, 63994, 63995, 63996, 63997, 63998, 63999],\n            ...\n        }\n    }\n\n    Args:\n        root_path (str): Root path to the dataset\n        split (str): Dataset split, which should be 'train' or 'val'\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'jsonl' or 'txt'\n        nproc (int): Number of processes\n        img_start_idx (int): Index of start image\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations/cocotext.v2.json'", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "src_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n", "src_image_root", "=", "src_image_root", ",", "\n", "dst_image_root", "=", "dst_image_root", ",", "\n", "ignore_image_root", "=", "ignore_image_root", ",", "\n", "preserve_vertical", "=", "preserve_vertical", ",", "\n", "split", "=", "split", ",", "\n", "format", "=", "format", ")", "\n", "tasks", "=", "[", "]", "\n", "for", "img_idx", ",", "img_info", "in", "enumerate", "(", "annotation", "[", "'imgs'", "]", ".", "values", "(", ")", ")", ":", "\n", "        ", "if", "img_info", "[", "'set'", "]", "==", "split", ":", "\n", "            ", "ann_ids", "=", "annotation", "[", "'imgToAnns'", "]", "[", "str", "(", "img_info", "[", "'id'", "]", ")", "]", "\n", "anns", "=", "[", "annotation", "[", "'anns'", "]", "[", "str", "(", "ann_id", ")", "]", "for", "ann_id", "in", "ann_ids", "]", "\n", "tasks", ".", "append", "(", "(", "img_idx", "+", "img_start_idx", ",", "img_info", ",", "anns", ")", ")", "\n", "", "", "labels_list", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "process_img_with_path", ",", "tasks", ",", "keep_order", "=", "True", ",", "nproc", "=", "nproc", ")", "\n", "final_labels", "=", "[", "]", "\n", "for", "label_list", "in", "labels_list", ":", "\n", "        ", "final_labels", "+=", "label_list", "\n", "", "list_to_file", "(", "dst_label_file", ",", "final_labels", ")", "\n", "\n", "return", "len", "(", "annotation", "[", "'imgs'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.cocotext_converter.main": [[166, 185], ["cocotext_converter.parse_args", "print", "cocotext_converter.convert_cocotext", "print", "cocotext_converter.convert_cocotext", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.cocotext_converter.convert_cocotext", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.cocotext_converter.convert_cocotext"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "num_train_imgs", "=", "convert_cocotext", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'train'", ",", "\n", "preserve_vertical", "=", "args", ".", "preserve_vertical", ",", "\n", "format", "=", "args", ".", "format", ",", "\n", "nproc", "=", "args", ".", "nproc", ")", "\n", "print", "(", "'Processing validation set...'", ")", "\n", "convert_cocotext", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'val'", ",", "\n", "preserve_vertical", "=", "args", ".", "preserve_vertical", ",", "\n", "format", "=", "args", ".", "format", ",", "\n", "nproc", "=", "args", ".", "nproc", ",", "\n", "img_start_idx", "=", "num_train_imgs", ")", "\n", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.parse_args": [[15, 27], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training, validation and test set of IMGUR '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of IMGUR'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.collect_imgur_info": [[29, 76], ["os.join", "mmcv.load", "annotation[].keys", "enumerate", "os.exists", "Exception", "os.join", "mmcv.imread", "dict", "dict.update", "img_infos.append", "print", "os.exists", "numpy.fromstring", "imgur_converter.convert_oriented_box", "dict", "anno_info.append", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.convert_oriented_box"], ["", "def", "collect_imgur_info", "(", "root_path", ",", "annotation_filename", ",", "print_every", "=", "1000", ")", ":", "\n", "\n", "    ", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "annotation_filename", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "images", "=", "annotation", "[", "'index_to_ann_map'", "]", ".", "keys", "(", ")", "\n", "img_infos", "=", "[", "]", "\n", "for", "i", ",", "img_name", "in", "enumerate", "(", "images", ")", ":", "\n", "        ", "if", "i", ">=", "0", "and", "i", "%", "print_every", "==", "0", ":", "\n", "            ", "print", "(", "f'{i}/{len(images)}'", ")", "\n", "\n", "", "img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "img_name", "+", "'.jpg'", ")", "\n", "\n", "# Skip not exist images", "\n", "if", "not", "osp", ".", "exists", "(", "img_path", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "img", "=", "mmcv", ".", "imread", "(", "img_path", ",", "'unchanged'", ")", "\n", "\n", "# Skip broken images", "\n", "if", "img", "is", "None", ":", "\n", "            ", "continue", "\n", "\n", "", "img_info", "=", "dict", "(", "\n", "file_name", "=", "img_name", "+", "'.jpg'", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ")", "\n", "\n", "anno_info", "=", "[", "]", "\n", "for", "ann_id", "in", "annotation", "[", "'index_to_ann_map'", "]", "[", "img_name", "]", ":", "\n", "            ", "ann", "=", "annotation", "[", "'ann_id'", "]", "[", "ann_id", "]", "\n", "\n", "# The original annotation is oriented rects [x, y, w, h, a]", "\n", "box", "=", "np", ".", "fromstring", "(", "\n", "ann", "[", "'bounding_box'", "]", "[", "1", ":", "-", "2", "]", ",", "sep", "=", "','", ",", "dtype", "=", "float", ")", "\n", "bbox", "=", "convert_oriented_box", "(", "box", ")", "\n", "word", "=", "ann", "[", "'word'", "]", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "img_infos", ".", "append", "(", "img_info", ")", "\n", "\n", "", "return", "img_infos", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.convert_oriented_box": [[78, 94], ["numpy.array", "numpy.array", "np.array.dot", "numpy.array", "imgur_converter.get_best_begin_point_single", "get_best_begin_point_single.tolist", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.get_best_begin_point_single"], ["", "def", "convert_oriented_box", "(", "box", ")", ":", "\n", "\n", "    ", "x_ctr", ",", "y_ctr", ",", "width", ",", "height", ",", "angle", "=", "box", "[", ":", "5", "]", "\n", "angle", "=", "-", "angle", "*", "math", ".", "pi", "/", "180", "\n", "\n", "tl_x", ",", "tl_y", ",", "br_x", ",", "br_y", "=", "-", "width", "/", "2", ",", "-", "height", "/", "2", ",", "width", "/", "2", ",", "height", "/", "2", "\n", "rect", "=", "np", ".", "array", "(", "[", "[", "tl_x", ",", "br_x", ",", "br_x", ",", "tl_x", "]", ",", "[", "tl_y", ",", "tl_y", ",", "br_y", ",", "br_y", "]", "]", ")", "\n", "R", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "angle", ")", ",", "-", "np", ".", "sin", "(", "angle", ")", "]", ",", "\n", "[", "np", ".", "sin", "(", "angle", ")", ",", "np", ".", "cos", "(", "angle", ")", "]", "]", ")", "\n", "poly", "=", "R", ".", "dot", "(", "rect", ")", "\n", "x0", ",", "x1", ",", "x2", ",", "x3", "=", "poly", "[", "0", ",", ":", "4", "]", "+", "x_ctr", "\n", "y0", ",", "y1", ",", "y2", ",", "y3", "=", "poly", "[", "1", ",", ":", "4", "]", "+", "y_ctr", "\n", "poly", "=", "np", ".", "array", "(", "[", "x0", ",", "y0", ",", "x1", ",", "y1", ",", "x2", ",", "y2", ",", "x3", ",", "y3", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "poly", "=", "get_best_begin_point_single", "(", "poly", ")", "\n", "\n", "return", "poly", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.get_best_begin_point_single": [[96, 122], ["min", "min", "max", "max", "range", "numpy.array().reshape", "imgur_converter.cal_line_length", "numpy.array", "imgur_converter.cal_line_length", "imgur_converter.cal_line_length", "imgur_converter.cal_line_length"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length"], ["", "def", "get_best_begin_point_single", "(", "coordinate", ")", ":", "\n", "\n", "    ", "x1", ",", "y1", ",", "x2", ",", "y2", ",", "x3", ",", "y3", ",", "x4", ",", "y4", "=", "coordinate", "\n", "xmin", "=", "min", "(", "x1", ",", "x2", ",", "x3", ",", "x4", ")", "\n", "ymin", "=", "min", "(", "y1", ",", "y2", ",", "y3", ",", "y4", ")", "\n", "xmax", "=", "max", "(", "x1", ",", "x2", ",", "x3", ",", "x4", ")", "\n", "ymax", "=", "max", "(", "y1", ",", "y2", ",", "y3", ",", "y4", ")", "\n", "combine", "=", "[", "[", "[", "x1", ",", "y1", "]", ",", "[", "x2", ",", "y2", "]", ",", "[", "x3", ",", "y3", "]", ",", "[", "x4", ",", "y4", "]", "]", ",", "\n", "[", "[", "x2", ",", "y2", "]", ",", "[", "x3", ",", "y3", "]", ",", "[", "x4", ",", "y4", "]", ",", "[", "x1", ",", "y1", "]", "]", ",", "\n", "[", "[", "x3", ",", "y3", "]", ",", "[", "x4", ",", "y4", "]", ",", "[", "x1", ",", "y1", "]", ",", "[", "x2", ",", "y2", "]", "]", ",", "\n", "[", "[", "x4", ",", "y4", "]", ",", "[", "x1", ",", "y1", "]", ",", "[", "x2", ",", "y2", "]", ",", "[", "x3", ",", "y3", "]", "]", "]", "\n", "dst_coordinate", "=", "[", "[", "xmin", ",", "ymin", "]", ",", "[", "xmax", ",", "ymin", "]", ",", "[", "xmax", ",", "ymax", "]", ",", "[", "xmin", ",", "ymax", "]", "]", "\n", "force", "=", "100000000.0", "\n", "force_flag", "=", "0", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "temp_force", "=", "cal_line_length", "(", "combine", "[", "i", "]", "[", "0", "]", ",", "dst_coordinate", "[", "0", "]", ")", "+", "cal_line_length", "(", "combine", "[", "i", "]", "[", "1", "]", ",", "dst_coordinate", "[", "1", "]", ")", "+", "cal_line_length", "(", "combine", "[", "i", "]", "[", "2", "]", ",", "dst_coordinate", "[", "2", "]", ")", "+", "cal_line_length", "(", "combine", "[", "i", "]", "[", "3", "]", ",", "dst_coordinate", "[", "3", "]", ")", "\n", "if", "temp_force", "<", "force", ":", "\n", "            ", "force", "=", "temp_force", "\n", "force_flag", "=", "i", "\n", "", "", "if", "force_flag", "!=", "0", ":", "\n", "        ", "pass", "\n", "\n", "", "return", "np", ".", "array", "(", "combine", "[", "force_flag", "]", ")", ".", "reshape", "(", "8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.cal_line_length": [[124, 129], ["math.sqrt", "math.pow", "math.pow"], "function", ["None"], ["", "def", "cal_line_length", "(", "point1", ",", "point2", ")", ":", "\n", "\n", "    ", "return", "math", ".", "sqrt", "(", "\n", "math", ".", "pow", "(", "point1", "[", "0", "]", "-", "point2", "[", "0", "]", ",", "2", ")", "+", "\n", "math", ".", "pow", "(", "point1", "[", "1", "]", "-", "point2", "[", "1", "]", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.generate_ann": [[131, 171], ["os.join", "os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "mmcv.imread", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "os.join", "mmcv.imwrite", "min", "lines.append", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "format", ")", ":", "\n", "\n", "    ", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.imgur_converter.main": [[173, 183], ["imgur_converter.parse_args", "print", "mmcv.Timer", "imgur_converter.collect_imgur_info", "imgur_converter.generate_ann"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.collect_imgur_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "print", "(", "f'Processing {split} set...'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert IMGUR annotation'", ")", ":", "\n", "            ", "anno_infos", "=", "collect_imgur_info", "(", "\n", "root_path", ",", "f'imgur5k_annotations_{split}.json'", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "anno_infos", ",", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.collect_files": [[16, 69], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "os.join", "ann_list.append", "imgs_list.append", "zip", "enumerate", "ann_file.replace", "os.join", "mmcv.imread", "print", "PIL.Image.open", "img.convert.convert", "img.convert.save", "print", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.kie.closeset_to_openset.convert"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "ann_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "img_file", "=", "osp", ".", "join", "(", "img_dir", ",", "ann_file", ".", "replace", "(", "'txt'", ",", "'jpg'", ")", ")", "\n", "# This dataset contains some images obtained from .gif,", "\n", "# which cannot be loaded by mmcv.imread(), convert them", "\n", "# to RGB mode.", "\n", "try", ":", "\n", "            ", "if", "mmcv", ".", "imread", "(", "img_file", ")", "is", "None", ":", "\n", "                ", "print", "(", "f'Convert {img_file} to RGB mode.'", ")", "\n", "img", "=", "Image", ".", "open", "(", "img_file", ")", "\n", "img", "=", "img", ".", "convert", "(", "'RGB'", ")", "\n", "img", ".", "save", "(", "img_file", ")", "\n", "", "", "except", "cv2", ".", "error", ":", "\n", "            ", "print", "(", "f'Skip broken img {img_file}'", ")", "\n", "continue", "\n", "\n", "", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "img_file", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "return", "trn_files", ",", "val_files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.collect_annotations": [[71, 90], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.load_img_info": [[92, 120], ["isinstance", "mmcv.imread", "dict", "mtwi_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.load_txt_info": [[122, 155], ["img_info.update", "open", "f.readlines", "[].rstrip", "dict", "anno_info.append", "line.split", "math.floor", "float", "line.split"], "function", ["None"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x1,y1,x2,y2,x3,y3,x4,y4,text\n\n    45.45,226.83,11.87,181.79,183.84,13.1,233.79,49.95,\u65f6\u5c1a\u888b\u888b\n    345.98,311.18,345.98,347.21,462.26,347.21,462.26,311.18,73774\n    462.26,292.34,461.44,299.71,502.39,299.71,502.39,292.34,73/74/737\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "anno_info", "=", "[", "]", "\n", "with", "open", "(", "gt_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "for", "line", "in", "lines", ":", "\n", "        ", "points", "=", "line", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", "\n", "word", "=", "line", ".", "split", "(", "','", ")", "[", "8", "]", ".", "rstrip", "(", "'\\n'", ")", "\n", "if", "word", "==", "'###'", ":", "\n", "            ", "continue", "\n", "", "bbox", "=", "[", "math", ".", "floor", "(", "float", "(", "pt", ")", ")", "for", "pt", "in", "points", "]", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.generate_ann": [[157, 218], ["print", "os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "min", "os.join", "os.join", "lines.append", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, whether be txt or jsonl\n    \"\"\"", "\n", "print", "(", "'Cropping images...'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.parse_args": [[220, 239], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of MTWI.'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of MTWI'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.mtwi_converter.main": [[241, 263], ["mtwi_converter.parse_args", "mtwi_converter.collect_files", "mtwi_converter.collect_annotations", "os.join", "os.join", "mmcv.Timer", "mtwi_converter.generate_ann", "len", "mtwi_converter.collect_annotations", "mmcv.Timer", "mtwi_converter.generate_ann"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "ratio", "=", "args", ".", "val_ratio", "\n", "\n", "trn_files", ",", "val_files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ",", "ratio", ")", "\n", "\n", "# Train set", "\n", "trn_infos", "=", "collect_annotations", "(", "trn_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert MTWI Training annotation'", ")", ":", "\n", "        ", "generate_ann", "(", "root_path", ",", "'training'", ",", "trn_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n", "# Val set", "\n", "", "if", "len", "(", "val_files", ")", ">", "0", ":", "\n", "        ", "val_infos", "=", "collect_annotations", "(", "val_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert MTWI Val annotation'", ")", ":", "\n", "            ", "generate_ann", "(", "root_path", ",", "'val'", ",", "val_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.collect_files": [[13, 39], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "img_file.split", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_file", "=", "img_file", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'_gt_ocr.txt'", "\n", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.collect_annotations": [[41, 61], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.load_img_info": [[63, 92], ["isinstance", "mmcv.imread", "dict", "bid_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.basename", "os.basename", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'_'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "\n", "'_'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "basename", "(", "img_file", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "basename", "(", "gt_file", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.load_txt_info": [[94, 134], ["img_info.update", "open", "line.strip.strip", "line.strip.split", "word.strip.strip", "dict", "anno_info.append", "int", "len"], "function", ["None"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x, y, w, h, text\n    977, 152, 16, 49, NOME\n    962, 143, 12, 323, APPINHANESI BLAZEK PASSOTTO\n    906, 446, 12, 94, 206940361\n    905, 641, 12, 44, SPTC\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'latin1'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", "'\\n'", ")", "\n", "# Ignore hard samples", "\n", "if", "line", "[", "0", "]", "==", "'['", "or", "line", "[", "0", "]", "==", "'x'", ":", "\n", "                ", "continue", "\n", "", "ann", "=", "line", ".", "split", "(", "','", ")", "\n", "bbox", "=", "ann", "[", "0", ":", "4", "]", "\n", "bbox", "=", "[", "int", "(", "coord", ")", "for", "coord", "in", "bbox", "]", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "bbox", "\n", "# in case ',' exists in label", "\n", "word", "=", "','", ".", "join", "(", "ann", "[", "4", ":", "]", ")", "if", "len", "(", "ann", "[", "4", ":", "]", ")", ">", "1", "else", "ann", "[", "4", "]", "\n", "# remove the initial space", "\n", "word", "=", "word", ".", "strip", "(", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.split_train_val_list": [[136, 153], ["len", "int"], "function", ["None"], ["", "def", "split_train_val_list", "(", "full_list", ",", "val_ratio", ")", ":", "\n", "    ", "\"\"\"Split list by val_ratio.\n\n    Args:\n        full_list (list): List to be splited\n        val_ratio (float): Split ratio for val set\n\n    return:\n        list(list, list): Train_list and val_list\n    \"\"\"", "\n", "n_total", "=", "len", "(", "full_list", ")", "\n", "offset", "=", "int", "(", "n_total", "*", "val_ratio", ")", "\n", "if", "n_total", "==", "0", "or", "offset", "<", "1", ":", "\n", "        ", "return", "[", "]", ",", "full_list", "\n", "", "val_list", "=", "full_list", "[", ":", "offset", "]", "\n", "train_list", "=", "full_list", "[", "offset", ":", "]", "\n", "return", "[", "train_list", ",", "val_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.generate_ann": [[155, 219], ["enumerate", "bid_converter.split_train_val_list", "os.join", "os.join", "os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "mmcv.imread", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "min", "os.join", "os.join", "lines.append", "os.basename", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.split_train_val_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "image_infos", ",", "preserve_vertical", ",", "val_ratio", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        val_ratio (float): Split ratio for val set\n        format (str): Using jsonl(dict) or str to format annotations\n    \"\"\"", "\n", "\n", "assert", "val_ratio", "<=", "1.", "\n", "\n", "if", "val_ratio", ":", "\n", "        ", "image_infos", "=", "split_train_val_list", "(", "image_infos", ",", "val_ratio", ")", "\n", "splits", "=", "[", "'training'", ",", "'val'", "]", "\n", "\n", "", "else", ":", "\n", "        ", "image_infos", "=", "[", "image_infos", "]", "\n", "splits", "=", "[", "'training'", "]", "\n", "\n", "", "for", "i", ",", "split", "in", "enumerate", "(", "splits", ")", ":", "\n", "        ", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", "[", "i", "]", ":", "\n", "            ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "                ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                    ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                    ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "filename", "=", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "if", "format", "==", "'txt'", ":", "\n", "                    ", "lines", ".", "append", "(", "f'{filename} '", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                    ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "filename", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.parse_args": [[221, 240], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of BID '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of BID'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.bid_converter.main": [[242, 251], ["bid_converter.parse_args", "mmcv.Timer", "bid_converter.collect_files", "bid_converter.collect_annotations", "bid_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert BID annotation'", ")", ":", "\n", "        ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "image_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "val_ratio", ",", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ic11_converter.convert_annotations": [[9, 62], ["isinstance", "isinstance", "os.join", "mmocr.utils.fileio.list_to_file", "open", "f.readlines", "split.lower", "anno.split", "word.replace.replace", "os.join", "os.join", "lines.append", "lines.append", "json.dumps", "split.lower", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "convert_annotations", "(", "root_path", ",", "split", ",", "format", ")", ":", "\n", "    ", "\"\"\"Convert original annotations to mmocr format.\n\n    The annotation format is as the following:\n        word_1.png, \"flying\"\n        word_2.png, \"today\"\n        word_3.png, \"means\"\n    After this module, the annotation has been changed to the format below:\n        txt:\n        word_1.png flying\n        word_2.png today\n        word_3.png means\n\n        jsonl:\n        {'filename': 'word_1.png', 'text': 'flying'}\n        {'filename': 'word_2.png', 'text': 'today'}\n        {'filename': 'word_3.png', 'text': 'means'}\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: Train or Test\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "assert", "isinstance", "(", "root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "with", "open", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "\n", "f'Challenge1_{split}_Task3_GT.txt'", ")", ",", "\n", "'r'", ",", "\n", "encoding", "=", "'\"utf-8-sig'", ")", "as", "f", ":", "\n", "        ", "annos", "=", "f", ".", "readlines", "(", ")", "\n", "", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "split", ".", "lower", "(", ")", ")", "\n", "for", "anno", "in", "annos", ":", "\n", "# text may contain comma ','", "\n", "        ", "dst_img_name", ",", "word", "=", "anno", ".", "split", "(", "', \"'", ")", "\n", "word", "=", "word", ".", "replace", "(", "'\"\\n'", ",", "''", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "list_to_file", "(", "osp", ".", "join", "(", "root_path", ",", "f'{split.lower()}_label.{format}'", ")", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ic11_converter.parse_args": [[64, 75], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of IC11'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of IC11'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ic11_converter.main": [[77, 84], ["ic11_converter.parse_args", "ic11_converter.convert_annotations", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'Train'", ",", "'Test'", "]", ":", "\n", "        ", "convert_annotations", "(", "root_path", ",", "split", ",", "args", ".", "format", ")", "\n", "print", "(", "f'{split} split converted.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lsvt_converter.parse_args": [[13, 32], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of LSVT '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of LSVT'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lsvt_converter.process_img": [[34, 73], ["mmcv.imread", "enumerate", "mmcv.imwrite", "segmentation.append", "segmentation.append", "min", "min", "os.join", "os.join", "labels.append", "max", "max", "max", "max", "labels.append", "json.dumps", "os.basename", "os.basename"], "function", ["None"], ["", "def", "process_img", "(", "args", ",", "dst_image_root", ",", "ignore_image_root", ",", "preserve_vertical", ",", "\n", "split", ",", "format", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "img_info", "[", "'file_name'", "]", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "segmentation", "=", "[", "]", "\n", "for", "x", ",", "y", "in", "ann", "[", "'points'", "]", ":", "\n", "            ", "segmentation", ".", "append", "(", "max", "(", "0", ",", "x", ")", ")", "\n", "segmentation", ".", "append", "(", "max", "(", "0", ",", "y", ")", ")", "\n", "", "xs", ",", "ys", "=", "segmentation", "[", ":", ":", "2", "]", ",", "segmentation", "[", "1", ":", ":", "2", "]", "\n", "x", ",", "y", "=", "min", "(", "xs", ")", ",", "min", "(", "ys", ")", "\n", "w", ",", "h", "=", "max", "(", "xs", ")", "-", "x", ",", "max", "(", "ys", ")", "-", "y", "\n", "text_label", "=", "ann", "[", "'transcription'", "]", "\n", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "\n", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'train'", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "labels", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lsvt_converter.convert_lsvt": [[75, 172], ["os.join", "mmcv.load", "os.join", "os.join", "os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "functools.partial", "mmcv.load.keys", "print", "enumerate", "mmcv.track_parallel_progress", "mmocr.utils.fileio.list_to_file", "os.exists", "Exception", "enumerate", "os.join", "tasks.append", "os.exists", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "convert_lsvt", "(", "root_path", ",", "\n", "split", ",", "\n", "ratio", ",", "\n", "preserve_vertical", ",", "\n", "format", ",", "\n", "nproc", ",", "\n", "img_start_idx", "=", "0", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information and crop the images.\n\n    The annotation format is as the following:\n    [\n        {'gt_1234': # 'gt_1234' is file name\n            [\n                {\n                    'transcription': '\u4e00\u7ad9\u5f0f\u8d2d\u7269\u4e2d\u5fc3',\n                    'points': [[45, 272], [215, 273], [212, 296], [45, 290]]\n                    'illegibility': False\n                }, ...\n            ]\n        }\n    ]\n\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or val\n        ratio (float): Split ratio for val set\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, whether be txt or jsonl\n        nproc (int): The number of process to collect annotations\n        img_start_idx (int): Index of start image\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations/train_full_labels.json'", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "src_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n", "dst_image_root", "=", "dst_image_root", ",", "\n", "ignore_image_root", "=", "ignore_image_root", ",", "\n", "preserve_vertical", "=", "preserve_vertical", ",", "\n", "split", "=", "split", ",", "\n", "format", "=", "format", ")", "\n", "\n", "img_prefixes", "=", "annotation", ".", "keys", "(", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "img_prefixes", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "img_prefixes", ",", "[", "]", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "if", "split", "==", "'train'", ":", "\n", "        ", "img_prefixes", "=", "trn_files", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "img_prefixes", "=", "val_files", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "tasks", "=", "[", "]", "\n", "idx", "=", "0", "\n", "for", "img_idx", ",", "prefix", "in", "enumerate", "(", "img_prefixes", ")", ":", "\n", "        ", "img_file", "=", "osp", ".", "join", "(", "src_image_root", ",", "prefix", "+", "'.jpg'", ")", "\n", "img_info", "=", "{", "'file_name'", ":", "img_file", "}", "\n", "# Skip not exist images", "\n", "if", "not", "osp", ".", "exists", "(", "img_file", ")", ":", "\n", "            ", "continue", "\n", "", "tasks", ".", "append", "(", "(", "img_idx", "+", "img_start_idx", ",", "img_info", ",", "annotation", "[", "prefix", "]", ")", ")", "\n", "idx", "=", "idx", "+", "1", "\n", "\n", "", "labels_list", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "process_img_with_path", ",", "tasks", ",", "keep_order", "=", "True", ",", "nproc", "=", "nproc", ")", "\n", "final_labels", "=", "[", "]", "\n", "for", "label_list", "in", "labels_list", ":", "\n", "        ", "final_labels", "+=", "label_list", "\n", "", "list_to_file", "(", "dst_label_file", ",", "final_labels", ")", "\n", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lsvt_converter.main": [[174, 196], ["lsvt_converter.parse_args", "print", "lsvt_converter.convert_lsvt", "print", "print", "lsvt_converter.convert_lsvt"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lsvt_converter.convert_lsvt", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.lsvt_converter.convert_lsvt"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "num_train_imgs", "=", "convert_lsvt", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'train'", ",", "\n", "ratio", "=", "args", ".", "val_ratio", ",", "\n", "preserve_vertical", "=", "args", ".", "preserve_vertical", ",", "\n", "format", "=", "args", ".", "format", ",", "\n", "nproc", "=", "args", ".", "nproc", ")", "\n", "if", "args", ".", "val_ratio", ">", "0", ":", "\n", "        ", "print", "(", "'Processing validation set...'", ")", "\n", "convert_lsvt", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'val'", ",", "\n", "ratio", "=", "args", ".", "val_ratio", ",", "\n", "preserve_vertical", "=", "args", ".", "preserve_vertical", ",", "\n", "format", "=", "args", ".", "format", ",", "\n", "nproc", "=", "args", ".", "nproc", ",", "\n", "img_start_idx", "=", "num_train_imgs", ")", "\n", "", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ic13_converter.convert_annotations": [[9, 62], ["isinstance", "isinstance", "os.join", "mmocr.utils.fileio.list_to_file", "open", "f.readlines", "split.lower", "anno.split", "word.replace.replace", "os.join", "os.join", "lines.append", "lines.append", "json.dumps", "split.lower", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "convert_annotations", "(", "root_path", ",", "split", ",", "format", ")", ":", "\n", "    ", "\"\"\"Convert original annotations to mmocr format\n    The annotation format is as the following:\n        word_1.png, \"flying\"\n        word_2.png, \"today\"\n        word_3.png, \"means\"\n    After this module, the annotation has been changed to the format below:\n        txt:\n        word_1.png flying\n        word_2.png today\n        word_3.png means\n\n        jsonl:\n        {'filename': 'word_1.png', 'text': 'flying'}\n        {'filename': 'word_2.png', 'text': 'today'}\n        {'filename': 'word_3.png', 'text': 'means'}\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n\n    \"\"\"", "\n", "assert", "isinstance", "(", "root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "with", "open", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "\n", "f'Challenge2_{split}_Task3_GT.txt'", ")", ",", "\n", "'r'", ",", "\n", "encoding", "=", "'\"utf-8-sig'", ")", "as", "f", ":", "\n", "        ", "annos", "=", "f", ".", "readlines", "(", ")", "\n", "", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "split", ".", "lower", "(", ")", ")", "\n", "for", "anno", "in", "annos", ":", "\n", "# text may contain comma ','", "\n", "        ", "dst_img_name", ",", "word", "=", "anno", ".", "split", "(", "', \"'", ")", "\n", "word", "=", "word", ".", "replace", "(", "'\"\\n'", ",", "''", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "list_to_file", "(", "osp", ".", "join", "(", "root_path", ",", "f'{split.lower()}_label.{format}'", ")", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ic13_converter.parse_args": [[64, 75], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of IC13'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of IC13'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ic13_converter.main": [[77, 84], ["ic13_converter.parse_args", "ic13_converter.convert_annotations", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'Train'", ",", "'Test'", "]", ":", "\n", "        ", "convert_annotations", "(", "root_path", ",", "split", ",", "args", ".", "format", ")", "\n", "print", "(", "f'{split} split converted.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.collect_files": [[14, 41], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "os.join", "os.path.exists", "os.path.exists", "zip", "ann_list.append", "imgs_list.append", "os.join", "len", "img_file.split"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_path", "=", "osp", ".", "join", "(", "gt_dir", ",", "img_file", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'.xml'", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "ann_path", ")", ":", "\n", "            ", "ann_list", ".", "append", "(", "ann_path", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.collect_annotations": [[43, 63], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.load_img_info": [[65, 98], ["isinstance", "mmcv.imread", "dict", "ilst_converter.load_xml_info", "os.basename().split", "os.basename().split", "print", "os.splitext", "os.join", "os.join", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "try", ":", "\n", "        ", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "        ", "print", "(", "f'Skip broken img {img_file}'", ")", "\n", "return", "None", "\n", "\n", "", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.xml'", ":", "\n", "        ", "img_info", "=", "load_xml_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.load_xml_info": [[100, 146], ["xml.parse", "ET.parse.getroot", "obj.getroot.iter", "img_info.update", "int", "int", "int", "int", "max", "max", "dict", "anno_info.append", "object.find", "min", "min", "abs", "abs", "object.find().find", "object.find().find", "object.find().find", "object.find().find", "object.find", "object.find", "object.find", "object.find"], "function", ["None"], ["", "def", "load_xml_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    <annotations>\n    ...\n        <object>\n            <name>SMT</name>\n            <pose>Unspecified</pose>\n            <truncated>0</truncated>\n            <difficult>0</difficult>\n            <bndbox>\n                <xmin>157</xmin>\n                <ymin>294</ymin>\n                <xmax>237</xmax>\n                <ymax>357</ymax>\n            </bndbox>\n        <object>\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "obj", "=", "ET", ".", "parse", "(", "gt_file", ")", "\n", "root", "=", "obj", ".", "getroot", "(", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "object", "in", "root", ".", "iter", "(", "'object'", ")", ":", "\n", "        ", "word", "=", "object", ".", "find", "(", "'name'", ")", ".", "text", "\n", "x1", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'xmin'", ")", ".", "text", ")", "\n", "y1", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'ymin'", ")", ".", "text", ")", "\n", "x2", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'xmax'", ")", ".", "text", ")", "\n", "y2", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'ymax'", ")", ".", "text", ")", "\n", "\n", "x", "=", "max", "(", "0", ",", "min", "(", "x1", ",", "x2", ")", ")", "\n", "y", "=", "max", "(", "0", ",", "min", "(", "y1", ",", "y2", ")", ")", "\n", "w", ",", "h", "=", "abs", "(", "x2", "-", "x1", ")", ",", "abs", "(", "y2", "-", "y1", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.split_train_val_list": [[148, 165], ["len", "int"], "function", ["None"], ["", "def", "split_train_val_list", "(", "full_list", ",", "val_ratio", ")", ":", "\n", "    ", "\"\"\"Split list by val_ratio.\n\n    Args:\n        full_list (list): List to be splited\n        val_ratio (float): Split ratio for val set\n\n    return:\n        list(list, list): Train_list and val_list\n    \"\"\"", "\n", "n_total", "=", "len", "(", "full_list", ")", "\n", "offset", "=", "int", "(", "n_total", "*", "val_ratio", ")", "\n", "if", "n_total", "==", "0", "or", "offset", "<", "1", ":", "\n", "        ", "return", "[", "]", ",", "full_list", "\n", "", "val_list", "=", "full_list", "[", ":", "offset", "]", "\n", "train_list", "=", "full_list", "[", "offset", ":", "]", "\n", "return", "[", "train_list", ",", "val_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.generate_ann": [[167, 233], ["enumerate", "ilst_converter.split_train_val_list", "os.join", "os.join", "os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "mmcv.imread", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "min", "os.join", "os.join", "lines.append", "os.basename", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.split_train_val_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "image_infos", ",", "preserve_vertical", ",", "val_ratio", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        val_ratio (float): Split ratio for val set\n        format (str): Using jsonl(dict) or str to format annotations\n    \"\"\"", "\n", "\n", "assert", "val_ratio", "<=", "1.", "\n", "\n", "if", "val_ratio", ":", "\n", "        ", "image_infos", "=", "split_train_val_list", "(", "image_infos", ",", "val_ratio", ")", "\n", "splits", "=", "[", "'training'", ",", "'val'", "]", "\n", "\n", "", "else", ":", "\n", "        ", "image_infos", "=", "[", "image_infos", "]", "\n", "splits", "=", "[", "'training'", "]", "\n", "\n", "", "for", "i", ",", "split", "in", "enumerate", "(", "splits", ")", ":", "\n", "        ", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", "[", "i", "]", ":", "\n", "            ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "                ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                    ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                    ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "filename", "=", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "if", "format", "==", "'txt'", ":", "\n", "                    ", "lines", ".", "append", "(", "f'{filename} '", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "\n", "                    ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "filename", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.parse_args": [[235, 254], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of ILST '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of ILST'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.ilst_converter.main": [[256, 267], ["ilst_converter.parse_args", "mmcv.Timer", "ilst_converter.collect_files", "ilst_converter.collect_annotations", "list", "ilst_converter.generate_ann", "os.join", "os.join", "filter"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert ILST annotation'", ")", ":", "\n", "        ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "# filter broken images", "\n", "image_infos", "=", "list", "(", "filter", "(", "None", ",", "image_infos", ")", ")", "\n", "generate_ann", "(", "root_path", ",", "image_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "val_ratio", ",", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.textocr_converter.parse_args": [[13, 22], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of TextOCR '", "\n", "'by cropping box image.'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of TextOCR'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'n_proc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes to run'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.textocr_converter.process_img": [[24, 46], ["mmcv.imread", "enumerate", "os.join", "os.join", "mmcv.imwrite", "labels.append", "max", "max", "math.ceil", "math.ceil", "math.floor", "math.floor", "os.basename"], "function", ["None"], ["", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "src_image_root", ",", "img_info", "[", "'file_name'", "]", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "text_label", "=", "ann", "[", "'utf8_string'", "]", "\n", "\n", "# Ignore illegible or non-English words", "\n", "if", "text_label", "==", "'.'", ":", "\n", "            ", "continue", "\n", "\n", "", "x", ",", "y", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.textocr_converter.convert_textocr": [[48, 84], ["os.join", "os.join", "os.join", "os.makedirs", "os.makedirs", "mmcv.load", "functools.partial", "enumerate", "mmcv.track_parallel_progress", "mmocr.utils.fileio.list_to_file", "len", "os.exists", "Exception", "annotation[].values", "tasks.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "convert_textocr", "(", "root_path", ",", "\n", "dst_image_path", ",", "\n", "dst_label_filename", ",", "\n", "annotation_filename", ",", "\n", "img_start_idx", "=", "0", ",", "\n", "nproc", "=", "1", ")", ":", "\n", "\n", "    ", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "annotation_filename", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "", "src_image_root", "=", "root_path", "\n", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "dst_label_filename", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "dst_image_path", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n", "src_image_root", "=", "src_image_root", ",", "\n", "dst_image_root", "=", "dst_image_root", ")", "\n", "tasks", "=", "[", "]", "\n", "for", "img_idx", ",", "img_info", "in", "enumerate", "(", "annotation", "[", "'imgs'", "]", ".", "values", "(", ")", ")", ":", "\n", "        ", "ann_ids", "=", "annotation", "[", "'imgToAnns'", "]", "[", "img_info", "[", "'id'", "]", "]", "\n", "anns", "=", "[", "annotation", "[", "'anns'", "]", "[", "ann_id", "]", "for", "ann_id", "in", "ann_ids", "]", "\n", "tasks", ".", "append", "(", "(", "img_idx", "+", "img_start_idx", ",", "img_info", ",", "anns", ")", ")", "\n", "", "labels_list", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "process_img_with_path", ",", "tasks", ",", "keep_order", "=", "True", ",", "nproc", "=", "nproc", ")", "\n", "final_labels", "=", "[", "]", "\n", "for", "label_list", "in", "labels_list", ":", "\n", "        ", "final_labels", "+=", "label_list", "\n", "", "list_to_file", "(", "dst_label_file", ",", "final_labels", ")", "\n", "return", "len", "(", "annotation", "[", "'imgs'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.textocr_converter.main": [[86, 105], ["textocr_converter.parse_args", "print", "textocr_converter.convert_textocr", "print", "textocr_converter.convert_textocr", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.textocr_converter.convert_textocr", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.textocr_converter.convert_textocr"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "num_train_imgs", "=", "convert_textocr", "(", "\n", "root_path", "=", "root_path", ",", "\n", "dst_image_path", "=", "'image'", ",", "\n", "dst_label_filename", "=", "'train_label.txt'", ",", "\n", "annotation_filename", "=", "'TextOCR_0.1_train.json'", ",", "\n", "nproc", "=", "args", ".", "n_proc", ")", "\n", "print", "(", "'Processing validation set...'", ")", "\n", "convert_textocr", "(", "\n", "root_path", "=", "root_path", ",", "\n", "dst_image_path", "=", "'image'", ",", "\n", "dst_label_filename", "=", "'val_label.txt'", ",", "\n", "annotation_filename", "=", "'TextOCR_0.1_val.json'", ",", "\n", "img_start_idx", "=", "num_train_imgs", ",", "\n", "nproc", "=", "args", ".", "n_proc", ")", "\n", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.seg2bbox": [[15, 32], ["len", "min", "max", "min", "max", "numpy.array().reshape", "shapely.geometry.Polygon", "numpy.array"], "function", ["None"], ["def", "seg2bbox", "(", "seg", ")", ":", "\n", "    ", "\"\"\"Convert segmentation to bbox.\n\n    Args:\n        seg (list(int | float)): A set of coordinates\n    \"\"\"", "\n", "if", "len", "(", "seg", ")", "==", "4", ":", "\n", "        ", "min_x", "=", "min", "(", "seg", "[", "0", "]", ",", "seg", "[", "2", "]", ",", "seg", "[", "4", "]", ",", "seg", "[", "6", "]", ")", "\n", "max_x", "=", "max", "(", "seg", "[", "0", "]", ",", "seg", "[", "2", "]", ",", "seg", "[", "4", "]", ",", "seg", "[", "6", "]", ")", "\n", "min_y", "=", "min", "(", "seg", "[", "1", "]", ",", "seg", "[", "3", "]", ",", "seg", "[", "5", "]", ",", "seg", "[", "7", "]", ")", "\n", "max_y", "=", "max", "(", "seg", "[", "1", "]", ",", "seg", "[", "3", "]", ",", "seg", "[", "5", "]", ",", "seg", "[", "7", "]", ")", "\n", "", "else", ":", "\n", "        ", "seg", "=", "np", ".", "array", "(", "seg", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "seg", ")", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", "-", "min_x", ",", "max_y", "-", "min_y", "]", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.process_level": [[34, 75], ["hiertext_converter.seg2bbox", "mmcv.imwrite", "max", "max", "math.ceil", "math.ceil", "os.join", "os.join", "math.floor", "math.floor", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.seg2bbox"], ["", "def", "process_level", "(", "\n", "src_img", ",", "\n", "annotation", ",", "\n", "dst_image_root", ",", "\n", "ignore_image_root", ",", "\n", "preserve_vertical", ",", "\n", "split", ",", "\n", "format", ",", "\n", "para_idx", ",", "\n", "img_idx", ",", "\n", "line_idx", ",", "\n", "word_idx", "=", "None", ",", "\n", ")", ":", "\n", "    ", "vertices", "=", "annotation", "[", "'vertices'", "]", "\n", "text_label", "=", "annotation", "[", "'text'", "]", "\n", "segmentation", "=", "[", "i", "for", "j", "in", "vertices", "for", "i", "in", "j", "]", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "seg2bbox", "(", "segmentation", ")", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "if", "word_idx", ":", "\n", "        ", "dst_img_name", "=", "f'img_{img_idx}_{para_idx}_{line_idx}_{word_idx}.jpg'", "\n", "", "else", ":", "\n", "        ", "dst_img_name", "=", "f'img_{img_idx}_{para_idx}_{line_idx}.jpg'", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'train'", ":", "\n", "        ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "        ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "        ", "label", "=", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "        ", "label", "=", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.process_img": [[77, 105], ["mmcv.imread", "enumerate", "os.join", "enumerate", "hiertext_converter.process_level", "labels.append", "enumerate", "hiertext_converter.process_level", "labels.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.process_level", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.process_level"], ["", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ",", "ignore_image_root", ",", "level", ",", "\n", "preserve_vertical", ",", "split", ",", "format", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_annos", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "src_image_root", ",", "img_annos", "[", "'image_id'", "]", "+", "'.jpg'", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "para_idx", ",", "paragraph", "in", "enumerate", "(", "img_annos", "[", "'paragraphs'", "]", ")", ":", "\n", "        ", "for", "line_idx", ",", "line", "in", "enumerate", "(", "paragraph", "[", "'lines'", "]", ")", ":", "\n", "            ", "if", "level", "==", "'line'", ":", "\n", "# Ignore illegible words", "\n", "                ", "if", "line", "[", "'legible'", "]", ":", "\n", "\n", "                    ", "label", "=", "process_level", "(", "src_img", ",", "line", ",", "dst_image_root", ",", "\n", "ignore_image_root", ",", "preserve_vertical", ",", "\n", "split", ",", "format", ",", "para_idx", ",", "img_idx", ",", "\n", "line_idx", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "", "elif", "level", "==", "'word'", ":", "\n", "                ", "for", "word_idx", ",", "word", "in", "enumerate", "(", "line", "[", "'words'", "]", ")", ":", "\n", "                    ", "if", "not", "word", "[", "'legible'", "]", ":", "\n", "                        ", "continue", "\n", "", "label", "=", "process_level", "(", "src_img", ",", "word", ",", "dst_image_root", ",", "\n", "ignore_image_root", ",", "preserve_vertical", ",", "\n", "split", ",", "format", ",", "para_idx", ",", "img_idx", ",", "\n", "line_idx", ",", "word_idx", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.convert_hiertext": [[107, 201], ["os.join", "os.join", "os.join", "os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "functools.partial", "enumerate", "mmcv.track_parallel_progress", "mmocr.utils.fileio.list_to_file", "os.exists", "Exception", "json.load", "tasks.append", "open"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "convert_hiertext", "(", "\n", "root_path", ",", "\n", "split", ",", "\n", "level", ",", "\n", "preserve_vertical", ",", "\n", "format", ",", "\n", "nproc", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information and crop the images.\n\n    The annotation format is as the following:\n    {\n        \"info\": {\n            \"date\": \"release date\",\n            \"version\": \"current version\"\n        },\n        \"annotations\": [  // List of dictionaries, one for each image.\n            {\n            \"image_id\": \"the filename of corresponding image.\",\n            \"image_width\": image_width,  // (int) The image width.\n            \"image_height\": image_height, // (int) The image height.\n            \"paragraphs\": [  // List of paragraphs.\n                {\n                \"vertices\": [[x1, y1], [x2, y2],...,[xn, yn]]\n                \"legible\": true\n                \"lines\": [\n                    {\n                    \"vertices\": [[x1, y1], [x2, y2],...,[x4, y4]]\n                    \"text\": L\n                    \"legible\": true,\n                    \"handwritten\": false\n                    \"vertical\": false,\n                    \"words\": [\n                        {\n                        \"vertices\": [[x1, y1], [x2, y2],...,[xm, ym]]\n                        \"text\": \"the text content of this word\",\n                        \"legible\": true\n                        \"handwritten\": false,\n                        \"vertical\": false,\n                        }, ...\n                    ]\n                    }, ...\n                ]\n                }, ...\n            ]\n            }, ...\n        ]\n        }\n\n    Args:\n        root_path (str): Root path to the dataset\n        split (str): Dataset split, which should be 'train' or 'val'\n        level (str): Crop word or line level instances\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'jsonl' or 'txt'\n        nproc (int): Number of processes\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations/'", "+", "split", "+", "'.jsonl'", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "json", ".", "load", "(", "open", "(", "annotation_path", ",", "'r'", ")", ")", "[", "'annotations'", "]", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "src_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n", "src_image_root", "=", "src_image_root", ",", "\n", "dst_image_root", "=", "dst_image_root", ",", "\n", "ignore_image_root", "=", "ignore_image_root", ",", "\n", "level", "=", "level", ",", "\n", "preserve_vertical", "=", "preserve_vertical", ",", "\n", "split", "=", "split", ",", "\n", "format", "=", "format", ")", "\n", "tasks", "=", "[", "]", "\n", "for", "img_idx", ",", "img_info", "in", "enumerate", "(", "annotation", ")", ":", "\n", "        ", "tasks", ".", "append", "(", "(", "img_idx", ",", "img_info", ")", ")", "\n", "", "labels_list", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "process_img_with_path", ",", "tasks", ",", "keep_order", "=", "True", ",", "nproc", "=", "nproc", ")", "\n", "\n", "final_labels", "=", "[", "]", "\n", "for", "label_list", "in", "labels_list", ":", "\n", "        ", "final_labels", "+=", "label_list", "\n", "", "list_to_file", "(", "dst_label_file", ",", "final_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.parse_args": [[203, 225], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of HierText'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of HierText'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--level'", ",", "\n", "default", "=", "'word'", ",", "\n", "help", "=", "'Crop word or line level instance'", ",", "\n", "choices", "=", "[", "'word'", ",", "'line'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.main": [[227, 247], ["hiertext_converter.parse_args", "print", "hiertext_converter.convert_hiertext", "print", "hiertext_converter.convert_hiertext", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.convert_hiertext", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.hiertext_converter.convert_hiertext"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "convert_hiertext", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'train'", ",", "\n", "level", "=", "args", ".", "level", ",", "\n", "preserve_vertical", "=", "args", ".", "preserve_vertical", ",", "\n", "format", "=", "args", ".", "format", ",", "\n", "nproc", "=", "args", ".", "nproc", ")", "\n", "print", "(", "'Processing validation set...'", ")", "\n", "convert_hiertext", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'val'", ",", "\n", "level", "=", "args", ".", "level", ",", "\n", "preserve_vertical", "=", "args", ".", "preserve_vertical", ",", "\n", "format", "=", "args", ".", "format", ",", "\n", "nproc", "=", "args", ".", "nproc", ")", "\n", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.collect_files": [[15, 55], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "ann_list.append", "imgs_list.append", "zip", "enumerate", "os.join", "os.join", "sorted", "sorted", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len", "img_file.split"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "img_file", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'.xml'", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "sorted", "(", "imgs_list", ")", ",", "sorted", "(", "ann_list", ")", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "return", "trn_files", ",", "val_files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.collect_annotations": [[57, 77], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.load_img_info": [[79, 108], ["isinstance", "mmcv.imread", "dict", "kaist_converter.load_xml_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.xml'", ":", "\n", "        ", "img_info", "=", "load_xml_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.load_xml_info": [[110, 161], ["xml.parse", "ET.parse.getroot", "obj.getroot.iter", "img_info.update", "word.iter", "dict", "anno_info.append", "max", "max", "int", "int", "chars.append", "len", "int", "int"], "function", ["None"], ["", "def", "load_xml_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Annotation Format\n    <image>\n        <imageName>DSC02306.JPG</imageName>\n        <resolution x=\"640\" y=\"480\" />\n        <words>\n            <word x=\"61\" y=\"140\" width=\"566\" height=\"107\">\n                <character x=\"61\" y=\"147\" width=\"75\" height=\"94\" char=\"C\" />\n                <character x=\"173\" y=\"147\" width=\"77\" height=\"93\" char=\"L\" />\n                <character x=\"251\" y=\"146\" width=\"83\" height=\"96\" char=\"A\" />\n                <character x=\"335\" y=\"146\" width=\"75\" height=\"97\" char=\"V\" />\n                <character x=\"409\" y=\"140\" width=\"52\" height=\"105\" char=\"I\" />\n                <character x=\"464\" y=\"147\" width=\"76\" height=\"96\" char=\"T\" />\n                <character x=\"538\" y=\"154\" width=\"89\" height=\"93\" char=\"A\" />\n            </word>\n        </words>\n        <illumination>no</illumination>\n        <difficulty>2</difficulty>\n        <tag>\n        </tag>\n    </image>\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "obj", "=", "ET", ".", "parse", "(", "gt_file", ")", "\n", "root", "=", "obj", ".", "getroot", "(", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "word", "in", "root", ".", "iter", "(", "'word'", ")", ":", "\n", "        ", "x", ",", "y", "=", "max", "(", "0", ",", "int", "(", "word", ".", "attrib", "[", "'x'", "]", ")", ")", ",", "max", "(", "0", ",", "int", "(", "word", ".", "attrib", "[", "'y'", "]", ")", ")", "\n", "w", ",", "h", "=", "int", "(", "word", ".", "attrib", "[", "'width'", "]", ")", ",", "int", "(", "word", ".", "attrib", "[", "'height'", "]", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "chars", "=", "[", "]", "\n", "for", "character", "in", "word", ".", "iter", "(", "'character'", ")", ":", "\n", "            ", "chars", ".", "append", "(", "character", ".", "attrib", "[", "'char'", "]", ")", "\n", "", "word", "=", "''", ".", "join", "(", "chars", ")", "\n", "if", "len", "(", "word", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.generate_ann": [[163, 224], ["os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "min", "os.join", "os.join", "lines.append", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Filter out vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.parse_args": [[226, 245], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of KAIST '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of KAIST'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.kaist_converter.main": [[247, 269], ["kaist_converter.parse_args", "kaist_converter.collect_files", "kaist_converter.collect_annotations", "os.join", "os.join", "mmcv.Timer", "kaist_converter.generate_ann", "len", "kaist_converter.collect_annotations", "mmcv.Timer", "kaist_converter.generate_ann"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "ratio", "=", "args", ".", "val_ratio", "\n", "\n", "trn_files", ",", "val_files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ",", "ratio", ")", "\n", "\n", "# Train set", "\n", "trn_infos", "=", "collect_annotations", "(", "trn_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert KAIST Training annotation'", ")", ":", "\n", "        ", "generate_ann", "(", "root_path", ",", "'training'", ",", "trn_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n", "# Val set", "\n", "", "if", "len", "(", "val_files", ")", ">", "0", ":", "\n", "        ", "val_infos", "=", "collect_annotations", "(", "val_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert KAIST Val annotation'", ")", ":", "\n", "            ", "generate_ann", "(", "root_path", ",", "'val'", ",", "val_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.svt_converter.parse_args": [[12, 27], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate testset of svt by cropping box image.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'root_path'", ",", "\n", "help", "=", "'Root dir path of svt, where test.xml in,'", "\n", "'for example, \"data/mixture/svt/svt1/\"'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--resize'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether resize cropped image to certain size.'", ")", "\n", "parser", ".", "add_argument", "(", "'--height'", ",", "default", "=", "32", ",", "help", "=", "'Resize height.'", ")", "\n", "parser", ".", "add_argument", "(", "'--width'", ",", "default", "=", "100", ",", "help", "=", "'Resize width.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.svt_converter.main": [[29, 79], ["svt_converter.parse_args", "os.join", "os.join", "os.join", "os.makedirs", "os.makedirs", "xml.parse", "ET.parse.getroot", "len", "tree.getroot.findall", "mmocr.utils.fileio.list_to_file", "print", "os.exists", "Exception", "print", "image_node.find().text.lower", "image_node.find().text.lower.split", "len", "cv2.imread", "image_node.find", "image_node.find", "os.join", "int", "int", "int", "int", "rectangle.find().text.lower", "os.join", "cv2.imwrite", "lines.append", "rectangle.get", "rectangle.get", "rectangle.get", "rectangle.get", "max", "max", "max", "max", "cv2.resize", "image_node.find", "rectangle.find", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "# inputs", "\n", "src_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "'test.xml'", ")", "\n", "if", "not", "osp", ".", "exists", "(", "src_label_file", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{src_label_file} not exists, please check and try again.'", ")", "\n", "", "src_image_root", "=", "root_path", "\n", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "'test_label.txt'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'image'", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "tree", "=", "ET", ".", "parse", "(", "src_label_file", ")", "\n", "root", "=", "tree", ".", "getroot", "(", ")", "\n", "\n", "index", "=", "1", "\n", "lines", "=", "[", "]", "\n", "total_img_num", "=", "len", "(", "root", ")", "\n", "i", "=", "1", "\n", "for", "image_node", "in", "root", ".", "findall", "(", "'image'", ")", ":", "\n", "        ", "image_name", "=", "image_node", ".", "find", "(", "'imageName'", ")", ".", "text", "\n", "print", "(", "f'[{i}/{total_img_num}] Process image: {image_name}'", ")", "\n", "i", "+=", "1", "\n", "lexicon", "=", "image_node", ".", "find", "(", "'lex'", ")", ".", "text", ".", "lower", "(", ")", "\n", "lexicon_list", "=", "lexicon", ".", "split", "(", "','", ")", "\n", "lex_size", "=", "len", "(", "lexicon_list", ")", "\n", "src_img", "=", "cv2", ".", "imread", "(", "osp", ".", "join", "(", "src_image_root", ",", "image_name", ")", ")", "\n", "for", "rectangle", "in", "image_node", ".", "find", "(", "'taggedRectangles'", ")", ":", "\n", "            ", "x", "=", "int", "(", "rectangle", ".", "get", "(", "'x'", ")", ")", "\n", "y", "=", "int", "(", "rectangle", ".", "get", "(", "'y'", ")", ")", "\n", "w", "=", "int", "(", "rectangle", ".", "get", "(", "'width'", ")", ")", "\n", "h", "=", "int", "(", "rectangle", ".", "get", "(", "'height'", ")", ")", "\n", "rb", ",", "re", "=", "max", "(", "0", ",", "y", ")", ",", "max", "(", "0", ",", "y", "+", "h", ")", "\n", "cb", ",", "ce", "=", "max", "(", "0", ",", "x", ")", ",", "max", "(", "0", ",", "x", "+", "w", ")", "\n", "dst_img", "=", "src_img", "[", "rb", ":", "re", ",", "cb", ":", "ce", "]", "\n", "text_label", "=", "rectangle", ".", "find", "(", "'tag'", ")", ".", "text", ".", "lower", "(", ")", "\n", "if", "args", ".", "resize", ":", "\n", "                ", "dst_img", "=", "cv2", ".", "resize", "(", "dst_img", ",", "(", "args", ".", "width", ",", "args", ".", "height", ")", ")", "\n", "", "dst_img_name", "=", "f'img_{index:04}'", "+", "'.jpg'", "\n", "index", "+=", "1", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "cv2", ".", "imwrite", "(", "dst_img_path", ",", "dst_img", ")", "\n", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{text_label} {lex_size} {lexicon}'", ")", "\n", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "print", "(", "f'Finish to generate svt testset, '", "\n", "f'with label file {dst_label_file}'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.openvino_converter.parse_args": [[14, 24], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", "description", "=", "'Generate training and validation set '", "\n", "'of OpenVINO annotations for Open '", "\n", "'Images by cropping box image.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'root_path'", ",", "help", "=", "'Root dir containing images and annotations'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'n_proc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes to run'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.openvino_converter.process_img": [[26, 51], ["PIL.Image.open", "enumerate", "Image.open.close", "os.join", "Image.open.crop", "os.join", "src_img.crop.save", "labels.append", "max", "max", "math.ceil", "math.ceil", "math.floor", "math.floor", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.close"], ["", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "Image", ".", "open", "(", "osp", ".", "join", "(", "src_image_root", ",", "img_info", "[", "'file_name'", "]", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "attrs", "=", "ann", "[", "'attributes'", "]", "\n", "text_label", "=", "attrs", "[", "'transcription'", "]", "\n", "\n", "# Ignore illegible or non-English words", "\n", "if", "not", "attrs", "[", "'legible'", "]", "or", "attrs", "[", "'language'", "]", "!=", "'english'", ":", "\n", "            ", "continue", "\n", "\n", "", "x", ",", "y", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", ".", "crop", "(", "(", "x", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ")", ")", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "# Preserve JPEG quality", "\n", "dst_img", ".", "save", "(", "dst_img_path", ",", "qtables", "=", "src_img", ".", "quantization", ")", "\n", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "src_img", ".", "close", "(", ")", "\n", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.openvino_converter.convert_openimages": [[53, 89], ["os.join", "os.join", "os.join", "os.makedirs", "os.makedirs", "mmcv.load", "functools.partial", "enumerate", "mmcv.track_parallel_progress", "mmocr.utils.fileio.list_to_file", "len", "os.exists", "Exception", "anns.setdefault().append", "tasks.append", "anns.setdefault"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "convert_openimages", "(", "root_path", ",", "\n", "dst_image_path", ",", "\n", "dst_label_filename", ",", "\n", "annotation_filename", ",", "\n", "img_start_idx", "=", "0", ",", "\n", "nproc", "=", "1", ")", ":", "\n", "    ", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "annotation_filename", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "", "src_image_root", "=", "root_path", "\n", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "dst_label_filename", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "dst_image_path", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n", "src_image_root", "=", "src_image_root", ",", "\n", "dst_image_root", "=", "dst_image_root", ")", "\n", "tasks", "=", "[", "]", "\n", "anns", "=", "{", "}", "\n", "for", "ann", "in", "annotation", "[", "'annotations'", "]", ":", "\n", "        ", "anns", ".", "setdefault", "(", "ann", "[", "'image_id'", "]", ",", "[", "]", ")", ".", "append", "(", "ann", ")", "\n", "", "for", "img_idx", ",", "img_info", "in", "enumerate", "(", "annotation", "[", "'images'", "]", ")", ":", "\n", "        ", "tasks", ".", "append", "(", "(", "img_idx", "+", "img_start_idx", ",", "img_info", ",", "anns", "[", "img_info", "[", "'id'", "]", "]", ")", ")", "\n", "", "labels_list", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "process_img_with_path", ",", "tasks", ",", "keep_order", "=", "True", ",", "nproc", "=", "nproc", ")", "\n", "final_labels", "=", "[", "]", "\n", "for", "label_list", "in", "labels_list", ":", "\n", "        ", "final_labels", "+=", "label_list", "\n", "", "list_to_file", "(", "dst_label_file", ",", "final_labels", ")", "\n", "return", "len", "(", "annotation", "[", "'images'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.openvino_converter.main": [[91, 113], ["openvino_converter.parse_args", "print", "print", "openvino_converter.convert_openimages", "print", "openvino_converter.convert_openimages"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.openvino_converter.convert_openimages", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.openvino_converter.convert_openimages"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "num_train_imgs", "=", "0", "\n", "for", "s", "in", "'125f'", ":", "\n", "        ", "num_train_imgs", "=", "convert_openimages", "(", "\n", "root_path", "=", "root_path", ",", "\n", "dst_image_path", "=", "f'image_{s}'", ",", "\n", "dst_label_filename", "=", "f'train_{s}_label.txt'", ",", "\n", "annotation_filename", "=", "f'text_spotting_openimages_v5_train_{s}.json'", ",", "\n", "img_start_idx", "=", "num_train_imgs", ",", "\n", "nproc", "=", "args", ".", "n_proc", ")", "\n", "", "print", "(", "'Processing validation set...'", ")", "\n", "convert_openimages", "(", "\n", "root_path", "=", "root_path", ",", "\n", "dst_image_path", "=", "'image_val'", ",", "\n", "dst_label_filename", "=", "'val_label.txt'", ",", "\n", "annotation_filename", "=", "'text_spotting_openimages_v5_validation.json'", ",", "\n", "img_start_idx", "=", "num_train_imgs", ",", "\n", "nproc", "=", "args", ".", "n_proc", ")", "\n", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.collect_files": [[13, 50], ["isinstance", "isinstance", "isinstance", "list", "len", "print", "zip", "os.join", "os.join", "imgs_list.append", "ann_list.append", "img.replace", "len", "os.exists", "os.exists"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "split_info", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        split_info (dict): The split information for train/val/test\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "split_info", ",", "dict", ")", "\n", "assert", "split_info", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "group", "in", "split_info", ":", "\n", "        ", "for", "img", "in", "split_info", "[", "group", "]", ":", "\n", "            ", "image_path", "=", "osp", ".", "join", "(", "img_dir", ",", "img", ")", "\n", "anno_path", "=", "osp", ".", "join", "(", "gt_dir", ",", "'groups'", ",", "group", ",", "\n", "img", ".", "replace", "(", "'jpg'", ",", "'json'", ")", ")", "\n", "\n", "# Filtering out the missing images", "\n", "if", "not", "osp", ".", "exists", "(", "image_path", ")", "or", "not", "osp", ".", "exists", "(", "anno_path", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "imgs_list", ".", "append", "(", "image_path", ")", "\n", "ann_list", ".", "append", "(", "anno_path", ")", "\n", "\n", "", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.collect_annotations": [[52, 72], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.load_img_info": [[74, 103], ["isinstance", "mmcv.imread", "dict", "naf_converter.load_json_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# Read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.json'", ":", "\n", "        ", "img_info", "=", "load_json_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.load_json_info": [[105, 172], ["isinstance", "isinstance", "mmcv.load", "img_info.update", "[].tolist", "dict", "anno_info.append", "mmcv.load.keys", "annotation[].keys", "len", "numpy.array().reshape", "numpy.array"], "function", ["None"], ["", "def", "load_json_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Annotation Format\n    {\n        'filedBBs': [{\n            'poly_points': [[435,1406], [466,1406], [466,1439], [435,1439]],\n            \"type\": \"fieldCheckBox\",\n            \"id\": \"f0\",\n            \"isBlank\": 1, # 0:text,1:handwriting,2:print,3:blank,4:signature,\n        }], ...\n        \"transcriptions\":{\n            \"f38\": \"CASE NUMBER\",\n            \"f29\": \"July 1, 1949\",\n            \"t20\": \"RANK\",\n            \"t19\": \"COMPANY\",\n            ...\n        }\n    }\n\n    Some special characters are used in the transcription:\n    \"\u00abtext\u00bb\" indicates that \"text\" had a strikethrough\n    \"\u00bf\" indicates the transcriber could not read a character\n    \"\u00a7\" indicates the whole line or word was illegible\n    \"\" (empty string) is if the field was blank\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "gt_file", ",", "str", ")", "\n", "assert", "isinstance", "(", "img_info", ",", "dict", ")", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "\n", "# 'textBBs' contains the printed texts of the table while 'fieldBBs'", "\n", "#  contains the text filled by human.", "\n", "for", "box_type", "in", "[", "'textBBs'", ",", "'fieldBBs'", "]", ":", "\n", "# NAF dataset only provides transcription GT for 'filedBBs', the", "\n", "# 'textBBs' is only used for detection task.", "\n", "        ", "if", "box_type", "==", "'textBBs'", ":", "\n", "            ", "continue", "\n", "", "for", "anno", "in", "annotation", "[", "box_type", "]", ":", "\n", "# Skip images containing detection annotations only", "\n", "            ", "if", "'transcriptions'", "not", "in", "annotation", ".", "keys", "(", ")", ":", "\n", "                ", "continue", "\n", "# Skip boxes without recognition GT", "\n", "", "if", "anno", "[", "'id'", "]", "not", "in", "annotation", "[", "'transcriptions'", "]", ".", "keys", "(", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "word", "=", "annotation", "[", "'transcriptions'", "]", "[", "anno", "[", "'id'", "]", "]", "\n", "# Skip blank boxes", "\n", "if", "len", "(", "word", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "bbox", "=", "np", ".", "array", "(", "anno", "[", "'poly_points'", "]", ")", ".", "reshape", "(", "1", ",", "8", ")", "[", "0", "]", ".", "tolist", "(", ")", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.generate_ann": [[174, 245], ["os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "word.replace().replace.strip", "word.replace().replace.replace().replace", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "os.join", "os.join", "os.join", "lines.append", "word.replace().replace.replace", "min", "len", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "word", "=", "word", ".", "strip", "(", "'\\u202a'", ")", "# Remove unicode control character", "\n", "word", "=", "word", ".", "replace", "(", "'\u00bb'", ",", "\n", "''", ")", ".", "replace", "(", "'\u00ab'", ",", "\n", "''", ")", "# Remove strikethrough flag", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid and illegible annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", "or", "'\u00a7'", "in", "word", "or", "'\u00bf'", "in", "word", "or", "len", "(", "\n", "word", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "# (Do Not Filter For Val and Test Split)", "\n", "", "if", "(", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", ")", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.parse_args": [[247, 264], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training, val, and test set of NAF '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of NAF'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.naf_converter.main": [[266, 282], ["naf_converter.parse_args", "mmcv.load", "mmcv.load.pop", "mmcv.load.pop", "os.join", "print", "mmcv.Timer", "naf_converter.collect_files", "naf_converter.collect_annotations", "naf_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "split_info", "=", "mmcv", ".", "load", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "'train_valid_test_split.json'", ")", ")", "\n", "split_info", "[", "'training'", "]", "=", "split_info", ".", "pop", "(", "'train'", ")", "\n", "split_info", "[", "'val'", "]", "=", "split_info", ".", "pop", "(", "'valid'", ")", "\n", "for", "split", "in", "[", "'training'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "print", "(", "f'Processing {split} set...'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert NAF annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ",", "split_info", "[", "split", "]", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.collect_files": [[14, 53], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "ann_list.append", "imgs_list.append", "zip", "enumerate", "os.join", "os.join", "ann_file.replace", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "ann_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "ann_file", ".", "replace", "(", "'txt'", ",", "'jpg'", ")", ")", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "return", "trn_files", ",", "val_files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.collect_annotations": [[55, 74], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.load_img_info": [[76, 104], ["isinstance", "mmcv.imread", "dict", "rctw_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.load_txt_info": [[106, 142], ["img_info.update", "open", "f.readlines", "[].rstrip().strip", "dict", "anno_info.append", "line.split", "int", "[].rstrip", "line.split", "line.split"], "function", ["None"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x1, y1, x2, y2, x3, y3, x4, y4, difficult, text\n\n    390,902,1856,902,1856,1225,390,1225,0,\"\u91d1\u6c0f\u773c\u955c\"\n    1875,1170,2149,1170,2149,1245,1875,1245,0,\"\u521b\u4e8e1989\"\n    2054,1277,2190,1277,2190,1323,2054,1323,0,\"\u57ce\u5efa\u5e97\"\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "anno_info", "=", "[", "]", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'utf-8-sig'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "for", "line", "in", "lines", ":", "\n", "        ", "points", "=", "line", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", "\n", "word", "=", "line", ".", "split", "(", "','", ")", "[", "9", "]", ".", "rstrip", "(", "'\\n'", ")", ".", "strip", "(", "'\"'", ")", "\n", "difficult", "=", "1", "if", "line", ".", "split", "(", "','", ")", "[", "8", "]", "!=", "'0'", "else", "0", "\n", "bbox", "=", "[", "int", "(", "pt", ")", "for", "pt", "in", "points", "]", "\n", "\n", "if", "word", "==", "'###'", "or", "difficult", "==", "1", ":", "\n", "            ", "continue", "\n", "\n", "", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.generate_ann": [[144, 203], ["os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "min", "os.join", "os.join", "lines.append", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or val\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Filter out vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'crops/{dst_img_name} '", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "f'crops/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.parse_args": [[205, 224], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of RCTW.'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of RCTW'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.rctw_converter.main": [[226, 248], ["rctw_converter.parse_args", "rctw_converter.collect_files", "os.join", "os.join", "mmcv.Timer", "rctw_converter.collect_annotations", "rctw_converter.generate_ann", "len", "mmcv.Timer", "rctw_converter.collect_annotations", "rctw_converter.generate_ann"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "ratio", "=", "args", ".", "val_ratio", "\n", "\n", "trn_files", ",", "val_files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ",", "ratio", ")", "\n", "\n", "# Train set", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert RCTW Training annotation'", ")", ":", "\n", "        ", "trn_infos", "=", "collect_annotations", "(", "trn_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "'training'", ",", "trn_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n", "# Val set", "\n", "", "if", "len", "(", "val_files", ")", ">", "0", ":", "\n", "        ", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert RCTW Val annotation'", ")", ":", "\n", "            ", "val_infos", "=", "collect_annotations", "(", "val_files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "'val'", ",", "val_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.collect_files": [[18, 52], ["isinstance", "isinstance", "sorted", "sorted", "len", "print", "sorted.extend", "glob.glob", "os.join", "zip", "os.join", "os.listdir", "os.listdir", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files(list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "# note that we handle png and jpg only. Pls convert others such as gif to", "\n", "# jpg or png offline", "\n", "suffixes", "=", "[", "'.png'", ",", "'.PNG'", ",", "'.jpg'", ",", "'.JPG'", ",", "'.jpeg'", ",", "'.JPEG'", "]", "\n", "# suffixes = ['.png']", "\n", "\n", "imgs_list", "=", "[", "]", "\n", "for", "suffix", "in", "suffixes", ":", "\n", "        ", "imgs_list", ".", "extend", "(", "glob", ".", "glob", "(", "osp", ".", "join", "(", "img_dir", ",", "'*'", "+", "suffix", ")", ")", ")", "\n", "\n", "", "imgs_list", "=", "sorted", "(", "imgs_list", ")", "\n", "ann_list", "=", "sorted", "(", "\n", "[", "osp", ".", "join", "(", "gt_dir", ",", "gt_file", ")", "for", "gt_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", "]", ")", "\n", "\n", "files", "=", "[", "(", "img_file", ",", "gt_file", ")", "\n", "for", "(", "img_file", ",", "gt_file", ")", "in", "zip", "(", "imgs_list", ",", "ann_list", ")", "]", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.collect_annotations": [[54, 74], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.get_contours_mat": [[76, 121], ["isinstance", "scipy.loadmat", "scio.loadmat.keys", "enumerate", "scio.loadmat.get", "numpy.array", "numpy.array", "len", "words.append", "range", "contours.append", "scio.loadmat.get", "numpy.concatenate", "contour.append", "contour.append", "numpy.asarray", "len"], "function", ["None"], ["", "def", "get_contours_mat", "(", "gt_path", ")", ":", "\n", "    ", "\"\"\"Get the contours and words for each ground_truth mat file.\n\n    Args:\n        gt_path (str): The relative path of the ground_truth mat file\n\n    Returns:\n        contours (list[lists]): A list of lists of contours\n            for the text instances\n        words (list[list]): A list of lists of words (string)\n            for the text instances\n    \"\"\"", "\n", "assert", "isinstance", "(", "gt_path", ",", "str", ")", "\n", "\n", "contours", "=", "[", "]", "\n", "words", "=", "[", "]", "\n", "data", "=", "scio", ".", "loadmat", "(", "gt_path", ")", "\n", "# 'gt' for the latest version; 'polygt' for the legacy version", "\n", "keys", "=", "data", ".", "keys", "(", ")", "\n", "if", "'gt'", "in", "keys", ":", "\n", "        ", "data_polygt", "=", "data", ".", "get", "(", "'gt'", ")", "\n", "", "elif", "'polygt'", "in", "keys", ":", "\n", "        ", "data_polygt", "=", "data", ".", "get", "(", "'polygt'", ")", "\n", "\n", "", "for", "i", ",", "lines", "in", "enumerate", "(", "data_polygt", ")", ":", "\n", "        ", "X", "=", "np", ".", "array", "(", "lines", "[", "1", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "lines", "[", "3", "]", ")", "\n", "\n", "point_num", "=", "len", "(", "X", "[", "0", "]", ")", "\n", "word", "=", "lines", "[", "4", "]", "\n", "if", "len", "(", "word", ")", "==", "0", "or", "word", "==", "'#'", ":", "\n", "            ", "word", "=", "'###'", "\n", "", "else", ":", "\n", "            ", "word", "=", "word", "[", "0", "]", "\n", "\n", "", "words", ".", "append", "(", "word", ")", "\n", "\n", "arr", "=", "np", ".", "concatenate", "(", "[", "X", ",", "Y", "]", ")", ".", "T", "\n", "contour", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "point_num", ")", ":", "\n", "            ", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "0", "]", ")", "\n", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "1", "]", ")", "\n", "", "contours", ".", "append", "(", "np", ".", "asarray", "(", "contour", ")", ")", "\n", "\n", "", "return", "contours", ",", "words", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.load_mat_info": [[123, 153], ["isinstance", "isinstance", "totaltext_converter.get_contours_mat", "zip", "img_info.update", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.get_contours_mat"], ["", "def", "load_mat_info", "(", "img_info", ",", "gt_file", ")", ":", "\n", "    ", "\"\"\"Load the information of one ground truth in .mat format.\n\n    Args:\n        img_info (dict): The dict of only the image information\n        gt_file (str): The relative path of the ground_truth mat\n            file for one image\n\n    Returns:\n        img_info(dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_info", ",", "dict", ")", "\n", "assert", "isinstance", "(", "gt_file", ",", "str", ")", "\n", "\n", "contours", ",", "words", "=", "get_contours_mat", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "contour", ",", "word", "in", "zip", "(", "contours", ",", "words", ")", ":", "\n", "        ", "if", "contour", ".", "shape", "[", "0", "]", "==", "2", "or", "word", "==", "'###'", ":", "\n", "            ", "continue", "\n", "", "coordinates", "=", "np", ".", "array", "(", "contour", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "\n", "# convert to COCO style XYWH format", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", "]", "\n", "anno", "=", "dict", "(", "word", "=", "word", ",", "bbox", "=", "bbox", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.process_line": [[155, 202], ["re.sub", "re.sub", "re.sub", "yaml.safe_load.replace", "yaml.safe_load", "numpy.array", "numpy.array", "words.append", "len", "range", "contours.append", "len", "str", "numpy.concatenate", "contour.append", "contour.append", "numpy.asarray", "line.replace().replace", "len", "eval", "line.replace"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["", "def", "process_line", "(", "line", ",", "contours", ",", "words", ")", ":", "\n", "    ", "\"\"\"Get the contours and words by processing each line in the gt file.\n\n    Args:\n        line (str): The line in gt file containing annotation info\n        contours (list[lists]): A list of lists of contours\n            for the text instances\n        words (list[list]): A list of lists of words (string)\n            for the text instances\n\n    Returns:\n        contours (list[lists]): A list of lists of contours\n            for the text instances\n        words (list[list]): A list of lists of words (string)\n            for the text instances\n    \"\"\"", "\n", "\n", "line", "=", "'{'", "+", "line", ".", "replace", "(", "'[['", ",", "'['", ")", ".", "replace", "(", "']]'", ",", "']'", ")", "+", "'}'", "\n", "ann_dict", "=", "re", ".", "sub", "(", "'([0-9]) +([0-9])'", ",", "r'\\1,\\2'", ",", "line", ")", "\n", "ann_dict", "=", "re", ".", "sub", "(", "'([0-9]) +([ 0-9])'", ",", "r'\\1,\\2'", ",", "ann_dict", ")", "\n", "ann_dict", "=", "re", ".", "sub", "(", "'([0-9]) -([0-9])'", ",", "r'\\1,-\\2'", ",", "ann_dict", ")", "\n", "ann_dict", "=", "ann_dict", ".", "replace", "(", "\"[u',']\"", ",", "\"[u'#']\"", ")", "\n", "ann_dict", "=", "yaml", ".", "safe_load", "(", "ann_dict", ")", "\n", "\n", "X", "=", "np", ".", "array", "(", "[", "ann_dict", "[", "'x'", "]", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "[", "ann_dict", "[", "'y'", "]", "]", ")", "\n", "\n", "if", "len", "(", "ann_dict", "[", "'transcriptions'", "]", ")", "==", "0", ":", "\n", "        ", "word", "=", "'###'", "\n", "", "else", ":", "\n", "        ", "word", "=", "ann_dict", "[", "'transcriptions'", "]", "[", "0", "]", "\n", "if", "len", "(", "ann_dict", "[", "'transcriptions'", "]", ")", ">", "1", ":", "\n", "            ", "for", "ann_word", "in", "ann_dict", "[", "'transcriptions'", "]", "[", "1", ":", "]", ":", "\n", "                ", "word", "+=", "','", "+", "ann_word", "\n", "", "", "word", "=", "str", "(", "eval", "(", "word", ")", ")", "\n", "", "words", ".", "append", "(", "word", ")", "\n", "\n", "point_num", "=", "len", "(", "X", "[", "0", "]", ")", "\n", "\n", "arr", "=", "np", ".", "concatenate", "(", "[", "X", ",", "Y", "]", ")", ".", "T", "\n", "contour", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "point_num", ")", ":", "\n", "        ", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "0", "]", ")", "\n", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "1", "]", ")", "\n", "", "contours", ".", "append", "(", "np", ".", "asarray", "(", "contour", ")", ")", "\n", "\n", "return", "contours", ",", "words", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.get_contours_txt": [[204, 244], ["isinstance", "open", "enumerate", "line.strip.strip", "totaltext_converter.process_line", "totaltext_converter.process_line", "line.strip.startswith"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.process_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.process_line"], ["", "def", "get_contours_txt", "(", "gt_path", ")", ":", "\n", "    ", "\"\"\"Get the contours and words for each ground_truth txt file.\n\n    Args:\n        gt_path (str): The relative path of the ground_truth mat file\n\n    Returns:\n        contours (list[lists]): A list of lists of contours\n            for the text instances\n        words (list[list]): A list of lists of words (string)\n            for the text instances\n    \"\"\"", "\n", "assert", "isinstance", "(", "gt_path", ",", "str", ")", "\n", "\n", "contours", "=", "[", "]", "\n", "words", "=", "[", "]", "\n", "\n", "with", "open", "(", "gt_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "tmp_line", "=", "''", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "idx", "==", "0", ":", "\n", "                ", "tmp_line", "=", "line", "\n", "continue", "\n", "", "if", "not", "line", ".", "startswith", "(", "'x:'", ")", ":", "\n", "                ", "tmp_line", "+=", "' '", "+", "line", "\n", "continue", "\n", "", "else", ":", "\n", "                ", "complete_line", "=", "tmp_line", "\n", "tmp_line", "=", "line", "\n", "", "contours", ",", "words", "=", "process_line", "(", "complete_line", ",", "contours", ",", "words", ")", "\n", "\n", "", "if", "tmp_line", "!=", "''", ":", "\n", "            ", "contours", ",", "words", "=", "process_line", "(", "tmp_line", ",", "contours", ",", "words", ")", "\n", "\n", "", "for", "word", "in", "words", ":", "\n", "            ", "if", "word", "==", "'#'", ":", "\n", "                ", "word", "=", "'###'", "\n", "\n", "", "", "", "return", "contours", ",", "words", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.load_txt_info": [[246, 274], ["totaltext_converter.get_contours_txt", "zip", "img_info.update", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.get_contours_txt"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Load the information of one ground truth in .txt format.\n\n    Args:\n        img_info (dict): The dict of only the image information\n        gt_file (str): The relative path of the ground_truth mat\n            file for one image\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "contours", ",", "words", "=", "get_contours_txt", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "contour", ",", "word", "in", "zip", "(", "contours", ",", "words", ")", ":", "\n", "        ", "if", "contour", ".", "shape", "[", "0", "]", "==", "2", "or", "word", "==", "'###'", ":", "\n", "            ", "continue", "\n", "", "coordinates", "=", "np", ".", "array", "(", "contour", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "\n", "# convert to COCO style XYWH format", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", "]", "\n", "anno", "=", "dict", "(", "word", "=", "word", ",", "bbox", "=", "bbox", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.generate_ann": [[276, 315], ["os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "[].split", "mmocr.datasets.pipelines.crop.crop_img", "os.join", "mmcv.imwrite", "lines.append", "min", "os.splitext", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The relative path of the totaltext file\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'dst_imgs'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "'train_label.txt'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "'test_label.txt'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "osp", ".", "splitext", "(", "image_info", "[", "'file_name'", "]", ")", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "1", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ")", "\n", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", "or", "word", "==", "'###'", ":", "\n", "                ", "continue", "\n", "\n", "", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.load_img_info": [[317, 349], ["isinstance", "mmcv.imread", "os.basename", "dict", "os.dirname", "totaltext_converter.load_mat_info", "os.join", "os.join", "os.splitext", "totaltext_converter.load_txt_info", "os.basename", "os.basename", "os.splitext"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.load_mat_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "# read imgs with ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "split_name", "=", "osp", ".", "basename", "(", "osp", ".", "dirname", "(", "img_file", ")", ")", "\n", "img_info", "=", "dict", "(", "\n", "# remove img_prefix for filename", "\n", "file_name", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "# anno_info=anno_info,", "\n", "segm_file", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.mat'", ":", "\n", "        ", "img_info", "=", "load_mat_info", "(", "img_info", ",", "gt_file", ")", "\n", "", "elif", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.parse_args": [[351, 359], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert totaltext annotations to COCO format'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Totaltext root path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.totaltext_converter.main": [[361, 380], ["totaltext_converter.parse_args", "os.join", "os.join", "set_name.items", "set_name.update", "os.exists", "print", "os.join", "mmcv.Timer", "totaltext_converter.collect_files", "totaltext_converter.collect_annotations", "totaltext_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "img_dir", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", "\n", "gt_dir", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", "\n", "\n", "set_name", "=", "{", "}", "\n", "for", "split", "in", "[", "'training'", ",", "'test'", "]", ":", "\n", "        ", "set_name", ".", "update", "(", "{", "split", ":", "split", "+", "'_label'", "+", "'.txt'", "}", ")", "\n", "assert", "osp", ".", "exists", "(", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ")", "\n", "\n", "", "for", "split", ",", "ann_name", "in", "set_name", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "f'Converting {split} into {ann_name}'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert totaltext annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ",", "osp", ".", "join", "(", "gt_dir", ",", "split", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.collect_files": [[14, 39], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "sorted", "sorted", "gt_file.replace", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "gt_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "gt_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "gt_file", ".", "replace", "(", "'.json'", ",", "'.png'", ")", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "sorted", "(", "imgs_list", ")", ",", "sorted", "(", "ann_list", ")", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.collect_annotations": [[41, 61], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.load_img_info": [[63, 92], ["isinstance", "mmcv.imread", "dict", "funsd_converter.load_json_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.json'", ":", "\n", "        ", "img_info", "=", "load_json_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.load_json_info": [[94, 127], ["mmcv.load", "img_info.update", "max", "max", "dict", "anno_info.append", "len", "min", "min", "math.ceil", "math.ceil", "math.floor", "math.floor", "math.floor", "math.floor", "abs", "abs"], "function", ["None"], ["", "def", "load_json_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "form", "in", "annotation", "[", "'form'", "]", ":", "\n", "        ", "for", "ann", "in", "form", "[", "'words'", "]", ":", "\n", "\n", "# Ignore illegible samples", "\n", "            ", "if", "len", "(", "ann", "[", "'text'", "]", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "ann", "[", "'box'", "]", "\n", "x", "=", "max", "(", "0", ",", "min", "(", "math", ".", "floor", "(", "x1", ")", ",", "math", ".", "floor", "(", "x2", ")", ")", ")", "\n", "y", "=", "max", "(", "0", ",", "min", "(", "math", ".", "floor", "(", "y1", ")", ",", "math", ".", "floor", "(", "y2", ")", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "abs", "(", "x2", "-", "x1", ")", ")", ",", "math", ".", "ceil", "(", "abs", "(", "y2", "-", "y1", ")", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "word", "=", "ann", "[", "'text'", "]", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.generate_ann": [[129, 187], ["os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "os.join", "mmcv.imwrite", "min", "lines.append", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Using jsonl(dict) or str to format annotations\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'dst_imgs'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", ":", "\n", "                ", "continue", "\n", "\n", "", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.parse_args": [[189, 206], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of FUNSD '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of FUNSD'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve_vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.funsd_converter.main": [[208, 221], ["funsd_converter.parse_args", "print", "mmcv.Timer", "funsd_converter.collect_files", "funsd_converter.collect_annotations", "funsd_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'training'", ",", "'test'", "]", ":", "\n", "        ", "print", "(", "f'Processing {split} set...'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert FUNSD annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "split", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.collect_files": [[14, 39], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "imgs_list.append", "ann_list.append", "zip", "os.join", "os.join", "len", "img.replace"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img", ")", ")", "\n", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "'gt_'", "+", "img", ".", "replace", "(", "'jpg'", ",", "'txt'", ")", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.collect_annotations": [[41, 61], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.load_img_info": [[63, 90], ["isinstance", "mmcv.imread", "dict", "detext_converter.load_txt_info", "os.join", "os.join", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.load_txt_info": [[92, 124], ["img_info.update", "open", "f.readlines", "[].replace().strip", "dict", "anno_info.append", "numpy.array().astype().tolist", "[].replace", "numpy.array().astype", "numpy.array", "ann.split", "ann.split"], "function", ["None"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "with", "open", "(", "gt_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "annotations", "=", "f", ".", "readlines", "(", ")", "\n", "for", "ann", "in", "annotations", ":", "\n", "# Annotation format [x1, y1, x2, y2, x3, y3, x4, y4, transcript]", "\n", "            ", "try", ":", "\n", "                ", "bbox", "=", "np", ".", "array", "(", "ann", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", ")", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "", "except", "ValueError", ":", "\n", "# Skip invalid annotation line", "\n", "                ", "continue", "\n", "", "word", "=", "ann", ".", "split", "(", "','", ")", "[", "-", "1", "]", ".", "replace", "(", "'\\n'", ",", "''", ")", ".", "strip", "(", ")", "\n", "\n", "# Skip samples without recog gt", "\n", "if", "word", "==", "'###'", ":", "\n", "                ", "continue", "\n", "", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.generate_ann": [[126, 186], ["os.join", "os.join", "mmcv.mkdir_or_exist", "mmcv.mkdir_or_exist", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "os.join", "os.join", "lines.append", "min", "len", "lines.append", "json.dumps", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ",", "\n", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", "or", "len", "(", "word", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Filter out vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.parse_args": [[188, 205], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and val set of DeText '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of DeText'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.detext_converter.main": [[207, 221], ["detext_converter.parse_args", "print", "mmcv.Timer", "detext_converter.collect_files", "detext_converter.collect_annotations", "detext_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'training'", ",", "'val'", "]", ":", "\n", "        ", "print", "(", "f'Processing {split} set...'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert DeText annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ")", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "split", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.art_converter.parse_args": [[12, 27], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of ArT '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of ArT'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.art_converter.convert_art": [[29, 107], ["os.join", "mmcv.load", "os.join", "mmcv.load.keys", "print", "mmocr.utils.fileio.list_to_file", "os.exists", "Exception", "enumerate", "labels.append", "math.floor", "trn_files.append", "val_files.append", "len", "len", "labels.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "convert_art", "(", "root_path", ",", "split", ",", "ratio", ",", "format", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information and crop the images.\n\n    The annotation format is as the following:\n    {\n        \"gt_2836_0\": [\n            {\n                \"transcription\": \"URDER\",\n                \"points\": [\n                    [25, 51],\n                    [0, 2],\n                    [21, 0],\n                    [42, 43]\n                ],\n                \"language\": \"Latin\",\n                \"illegibility\": false\n            }\n        ], ...\n    }\n\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or val\n        ratio (float): Split ratio for val set\n        format (str): Annotation format, whether be txt or jsonl\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "\n", "'annotations/train_task2_labels.json'", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "\n", "img_prefixes", "=", "annotation", ".", "keys", "(", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "img_prefixes", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "img_prefixes", ",", "[", "]", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "if", "split", "==", "'train'", ":", "\n", "        ", "img_prefixes", "=", "trn_files", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "img_prefixes", "=", "val_files", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "labels", "=", "[", "]", "\n", "for", "prefix", "in", "img_prefixes", ":", "\n", "        ", "text_label", "=", "annotation", "[", "prefix", "]", "[", "0", "]", "[", "'transcription'", "]", "\n", "dst_img_name", "=", "prefix", "+", "'.jpg'", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "labels", ".", "append", "(", "f'crops/{dst_img_name}'", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "labels", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "f'crops/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "\n", "", "", "list_to_file", "(", "dst_label_file", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.art_converter.main": [[109, 126], ["art_converter.parse_args", "print", "art_converter.convert_art", "print", "print", "art_converter.convert_art"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.art_converter.convert_art", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.art_converter.convert_art"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "convert_art", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'train'", ",", "\n", "ratio", "=", "args", ".", "val_ratio", ",", "\n", "format", "=", "args", ".", "format", ")", "\n", "if", "args", ".", "val_ratio", ">", "0", ":", "\n", "        ", "print", "(", "'Processing validation set...'", ")", "\n", "convert_art", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'val'", ",", "\n", "ratio", "=", "args", ".", "val_ratio", ",", "\n", "format", "=", "args", ".", "format", ")", "\n", "", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.collect_files": [[13, 39], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "str", "len", "int"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_file", "=", "'gt_'", "+", "str", "(", "int", "(", "img_file", "[", "2", ":", "6", "]", ")", ")", "+", "'.txt'", "\n", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.collect_annotations": [[41, 61], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.load_img_info": [[63, 92], ["isinstance", "mmcv.imread", "dict", "int", "int", "vintext_converter.load_txt_info", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "int", "(", "osp", ".", "basename", "(", "gt_file", ")", "[", "3", ":", "-", "4", "]", ")", "==", "int", "(", "\n", "osp", ".", "basename", "(", "img_file", ")", "[", "2", ":", "-", "4", "]", ")", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.load_txt_info": [[94, 132], ["img_info.update", "open", "line.strip.strip", "line.strip.split", "dict", "anno_info.append", "int", "len", "len"], "function", ["None"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x1,y1,x2,y2,x3,y3,x4,y4,text\n    118,15,147,15,148,46,118,46,L\u01af\u1ee2NG\n    149,9,165,9,165,43,150,43,T\u1ed0T\n    167,9,180,9,179,43,167,42,\u0110\u1ec2\n    181,12,193,12,193,43,181,43,C\u00d3\n    195,13,215,14,215,46,196,46,VI\u1ec6C\n    217,13,237,14,239,47,217,46,L\u00c0M,\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", "'\\n'", ")", "\n", "ann", "=", "line", ".", "split", "(", "','", ")", "\n", "bbox", "=", "ann", "[", "0", ":", "8", "]", "\n", "word", "=", "line", "[", "len", "(", "','", ".", "join", "(", "bbox", ")", ")", "+", "1", ":", "]", "\n", "bbox", "=", "[", "int", "(", "coord", ")", "for", "coord", "in", "bbox", "]", "\n", "# Ignore hard samples", "\n", "if", "word", "==", "'###'", ":", "\n", "                ", "continue", "\n", "", "assert", "len", "(", "bbox", ")", "==", "8", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann": [[134, 193], ["os.join", "os.join", "os.makedirs", "os.makedirs", "mmocr.utils.fileio.list_to_file", "os.join", "os.join", "mmcv.imread", "os.join", "image_info[].split", "mmocr.datasets.pipelines.crop.crop_img", "mmcv.imwrite", "os.join", "min", "os.join", "os.join", "lines.append", "os.basename", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Using jsonl(dict) or str to format annotations\n    \"\"\"", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "elif", "split", "==", "'unseen_test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'unseen_test_label.{format}'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ",", "\n", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "filename", "=", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "if", "format", "==", "'txt'", ":", "\n", "                ", "lines", ".", "append", "(", "f'{filename} '", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "                ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "filename", ",", "\n", "'text'", ":", "word", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.parse_args": [[195, 212], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of VinText '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of VinText'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.main": [[214, 227], ["vintext_converter.parse_args", "print", "mmcv.Timer", "vintext_converter.collect_files", "vintext_converter.collect_annotations", "vintext_converter.generate_ann", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.vintext_converter.generate_ann"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "for", "split", "in", "[", "'training'", ",", "'test'", ",", "'unseen_test'", "]", ":", "\n", "        ", "print", "(", "f'Processing {split} set...'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n", "print_tmpl", "=", "'It takes {}s to convert VinText annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ")", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "args", ".", "preserve_vertical", ",", "\n", "args", ".", "format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.seg_synthtext_converter.parse_old_label": [[11, 48], ["mmocr.utils.list_from_file", "line.strip().split.strip().split", "os.join", "os.join", "enumerate", "os.exists", "os.exists", "cv2.imread", "mmocr.utils.list_from_file", "ann_line.strip.strip", "line.strip().split.strip", "dict", "char_annos.append", "float", "ann_line.strip.split"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["def", "parse_old_label", "(", "data_root", ",", "in_path", ",", "img_size", "=", "False", ")", ":", "\n", "    ", "imgid2imgname", "=", "{", "}", "\n", "imgid2anno", "=", "{", "}", "\n", "idx", "=", "0", "\n", "for", "line", "in", "list_from_file", "(", "in_path", ")", ":", "\n", "        ", "line", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "img_full_path", "=", "osp", ".", "join", "(", "data_root", ",", "line", "[", "0", "]", ")", "\n", "if", "not", "osp", ".", "exists", "(", "img_full_path", ")", ":", "\n", "            ", "continue", "\n", "", "ann_file", "=", "osp", ".", "join", "(", "data_root", ",", "line", "[", "1", "]", ")", "\n", "if", "not", "osp", ".", "exists", "(", "ann_file", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "img_info", "=", "{", "}", "\n", "img_info", "[", "'file_name'", "]", "=", "line", "[", "0", "]", "\n", "if", "img_size", ":", "\n", "            ", "img", "=", "cv2", ".", "imread", "(", "img_full_path", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "img_info", "[", "'height'", "]", "=", "h", "\n", "img_info", "[", "'width'", "]", "=", "w", "\n", "", "imgid2imgname", "[", "idx", "]", "=", "img_info", "\n", "\n", "imgid2anno", "[", "idx", "]", "=", "[", "]", "\n", "char_annos", "=", "[", "]", "\n", "for", "t", ",", "ann_line", "in", "enumerate", "(", "list_from_file", "(", "ann_file", ")", ")", ":", "\n", "            ", "ann_line", "=", "ann_line", ".", "strip", "(", ")", "\n", "if", "t", "==", "0", ":", "\n", "                ", "img_info", "[", "'text'", "]", "=", "ann_line", "\n", "", "else", ":", "\n", "                ", "char_box", "=", "[", "float", "(", "x", ")", "for", "x", "in", "ann_line", ".", "split", "(", ")", "]", "\n", "char_text", "=", "img_info", "[", "'text'", "]", "[", "t", "-", "1", "]", "\n", "char_ann", "=", "dict", "(", "char_box", "=", "char_box", ",", "char_text", "=", "char_text", ")", "\n", "char_annos", ".", "append", "(", "char_ann", ")", "\n", "", "", "imgid2anno", "[", "idx", "]", "=", "char_annos", "\n", "idx", "+=", "1", "\n", "\n", "", "return", "imgid2imgname", ",", "imgid2anno", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.seg_synthtext_converter.gen_line_dict_file": [[50, 64], ["imgid2imgname.items", "mmocr.utils.list_to_file", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "gen_line_dict_file", "(", "out_path", ",", "imgid2imgname", ",", "imgid2anno", ",", "img_size", "=", "False", ")", ":", "\n", "    ", "lines", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "imgid2imgname", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", "in", "imgid2anno", ":", "\n", "            ", "anno", "=", "imgid2anno", "[", "key", "]", "\n", "line_dict", "=", "{", "}", "\n", "line_dict", "[", "'file_name'", "]", "=", "value", "[", "'file_name'", "]", "\n", "line_dict", "[", "'text'", "]", "=", "value", "[", "'text'", "]", "\n", "if", "img_size", ":", "\n", "                ", "line_dict", "[", "'height'", "]", "=", "value", "[", "'height'", "]", "\n", "line_dict", "[", "'width'", "]", "=", "value", "[", "'width'", "]", "\n", "", "line_dict", "[", "'annotations'", "]", "=", "anno", "\n", "lines", ".", "append", "(", "json", ".", "dumps", "(", "line_dict", ")", ")", "\n", "", "", "list_to_file", "(", "out_path", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.seg_synthtext_converter.parse_args": [[66, 79], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--data-root'", ",", "help", "=", "'data root for both image file and anno file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--in-path'", ",", "\n", "help", "=", "'mapping file of image_name and ann_file,'", "\n", "' \"image_name ann_file\" in each line'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-path'", ",", "help", "=", "'output txt path with line-json format'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.seg_synthtext_converter.main": [[81, 86], ["seg_synthtext_converter.parse_args", "seg_synthtext_converter.parse_old_label", "seg_synthtext_converter.gen_line_dict_file", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.seg_synthtext_converter.parse_old_label", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.gen_line_dict_file"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "imgid2imgname", ",", "imgid2anno", "=", "parse_old_label", "(", "args", ".", "data_root", ",", "args", ".", "in_path", ")", "\n", "gen_line_dict_file", "(", "args", ".", "out_path", ",", "imgid2imgname", ",", "imgid2anno", ")", "\n", "print", "(", "'finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.synthtext_converter.parse_args": [[11, 26], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Crop images in Synthtext-style dataset in '", "\n", "'prepration for MMOCR\\'s use'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'anno_path'", ",", "help", "=", "'Path to gold annotation data (gt.mat)'", ")", "\n", "parser", ".", "add_argument", "(", "'img_path'", ",", "help", "=", "'Path to images'", ")", "\n", "parser", ".", "add_argument", "(", "'out_dir'", ",", "help", "=", "'Path of output images and labels'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--n_proc'", ",", "\n", "default", "=", "1", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'Number of processes to run with'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.synthtext_converter.load_gt_datum": [[28, 75], ["wordBB.transpose", "charBB.transpose", "type", "txt.split", "len", "word_bboxes.append", "len", "len", "char_bboxes.append", "len", "char_bbox_grps.append", "len", "len", "line.split", "max", "max", "round", "round", "len", "len"], "function", ["None"], ["", "def", "load_gt_datum", "(", "datum", ")", ":", "\n", "    ", "img_path", ",", "txt", ",", "wordBB", ",", "charBB", "=", "datum", "\n", "words", "=", "[", "]", "\n", "word_bboxes", "=", "[", "]", "\n", "char_bboxes", "=", "[", "]", "\n", "\n", "# when there's only one word in txt", "\n", "# scipy will load it as a string", "\n", "if", "type", "(", "txt", ")", "is", "str", ":", "\n", "        ", "words", "=", "txt", ".", "split", "(", ")", "\n", "", "else", ":", "\n", "        ", "for", "line", "in", "txt", ":", "\n", "            ", "words", "+=", "line", ".", "split", "(", ")", "\n", "\n", "# From (2, 4, num_boxes) to (num_boxes, 4, 2)", "\n", "", "", "if", "len", "(", "wordBB", ".", "shape", ")", "==", "2", ":", "\n", "        ", "wordBB", "=", "wordBB", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "", "cur_wordBB", "=", "wordBB", ".", "transpose", "(", "2", ",", "1", ",", "0", ")", "\n", "for", "box", "in", "cur_wordBB", ":", "\n", "        ", "word_bboxes", ".", "append", "(", "\n", "[", "max", "(", "round", "(", "coord", ")", ",", "0", ")", "for", "pt", "in", "box", "for", "coord", "in", "pt", "]", ")", "\n", "\n", "# Validate word bboxes.", "\n", "", "if", "len", "(", "words", ")", "!=", "len", "(", "word_bboxes", ")", ":", "\n", "        ", "return", "\n", "\n", "# From (2, 4, num_boxes) to (num_boxes, 4, 2)", "\n", "", "cur_charBB", "=", "charBB", ".", "transpose", "(", "2", ",", "1", ",", "0", ")", "\n", "for", "box", "in", "cur_charBB", ":", "\n", "        ", "char_bboxes", ".", "append", "(", "\n", "[", "max", "(", "round", "(", "coord", ")", ",", "0", ")", "for", "pt", "in", "box", "for", "coord", "in", "pt", "]", ")", "\n", "\n", "", "char_bbox_idx", "=", "0", "\n", "char_bbox_grps", "=", "[", "]", "\n", "\n", "for", "word", "in", "words", ":", "\n", "        ", "temp_bbox", "=", "char_bboxes", "[", "char_bbox_idx", ":", "char_bbox_idx", "+", "len", "(", "word", ")", "]", "\n", "char_bbox_idx", "+=", "len", "(", "word", ")", "\n", "char_bbox_grps", ".", "append", "(", "temp_bbox", ")", "\n", "\n", "# Validate char bboxes.", "\n", "# If the length of the last char bbox is correct, then", "\n", "# all the previous bboxes are also valid", "\n", "", "if", "len", "(", "char_bbox_grps", "[", "len", "(", "words", ")", "-", "1", "]", ")", "!=", "len", "(", "words", "[", "-", "1", "]", ")", ":", "\n", "        ", "return", "\n", "\n", "", "return", "img_path", ",", "words", ",", "word_bboxes", ",", "char_bbox_grps", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.synthtext_converter.load_gt_data": [[77, 85], ["scipy.io.loadmat", "mmcv.track_parallel_progress", "list", "zip"], "function", ["None"], ["", "def", "load_gt_data", "(", "filename", ",", "n_proc", ")", ":", "\n", "    ", "mat_data", "=", "loadmat", "(", "filename", ",", "simplify_cells", "=", "True", ")", "\n", "imnames", "=", "mat_data", "[", "'imnames'", "]", "\n", "txt", "=", "mat_data", "[", "'txt'", "]", "\n", "wordBB", "=", "mat_data", "[", "'wordBB'", "]", "\n", "charBB", "=", "mat_data", "[", "'charBB'", "]", "\n", "return", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_gt_datum", ",", "list", "(", "zip", "(", "imnames", ",", "txt", ",", "wordBB", ",", "charBB", ")", ")", ",", "nproc", "=", "n_proc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.synthtext_converter.process": [[87, 130], ["os.path.split", "mmcv.imread", "os.path.join", "enumerate", "os.path.splitext", "os.path.join", "os.path.exists", "os.path.join", "os.path.join", "numpy.array", "mmcv.imwrite", "os.makedirs", "os.path.exists", "os.path.exists", "int", "int", "int", "int", "open", "output_label_file.write", "min", "max", "min", "max", "output_label_file.write", "tuple", "cbox.tolist"], "function", ["None"], ["", "def", "process", "(", "data", ",", "img_path_prefix", ",", "out_dir", ")", ":", "\n", "    ", "if", "data", "is", "None", ":", "\n", "        ", "return", "\n", "# Dirty hack for multi-processing", "\n", "", "img_path", ",", "words", ",", "word_bboxes", ",", "char_bbox_grps", "=", "data", "\n", "img_dir", ",", "img_name", "=", "os", ".", "path", ".", "split", "(", "img_path", ")", "\n", "img_name", "=", "os", ".", "path", ".", "splitext", "(", "img_name", ")", "[", "0", "]", "\n", "input_img", "=", "mmcv", ".", "imread", "(", "os", ".", "path", ".", "join", "(", "img_path_prefix", ",", "img_path", ")", ")", "\n", "\n", "output_sub_dir", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "img_dir", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output_sub_dir", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "os", ".", "makedirs", "(", "output_sub_dir", ")", "\n", "", "except", "FileExistsError", ":", "\n", "            ", "pass", "# occurs when multi-proessing", "\n", "\n", "", "", "for", "i", ",", "word", "in", "enumerate", "(", "words", ")", ":", "\n", "        ", "output_image_patch_name", "=", "f'{img_name}_{i}.png'", "\n", "output_label_name", "=", "f'{img_name}_{i}.txt'", "\n", "output_image_patch_path", "=", "os", ".", "path", ".", "join", "(", "output_sub_dir", ",", "\n", "output_image_patch_name", ")", "\n", "output_label_path", "=", "os", ".", "path", ".", "join", "(", "output_sub_dir", ",", "output_label_name", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "output_image_patch_path", ")", "and", "os", ".", "path", ".", "exists", "(", "\n", "output_label_path", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "word_bbox", "=", "word_bboxes", "[", "i", "]", "\n", "min_x", ",", "max_x", "=", "int", "(", "min", "(", "word_bbox", "[", ":", ":", "2", "]", ")", ")", ",", "int", "(", "max", "(", "word_bbox", "[", ":", ":", "2", "]", ")", ")", "\n", "min_y", ",", "max_y", "=", "int", "(", "min", "(", "word_bbox", "[", "1", ":", ":", "2", "]", ")", ")", ",", "int", "(", "max", "(", "word_bbox", "[", "1", ":", ":", "2", "]", ")", ")", "\n", "cropped_img", "=", "input_img", "[", "min_y", ":", "max_y", ",", "min_x", ":", "max_x", "]", "\n", "if", "cropped_img", ".", "shape", "[", "0", "]", "<=", "0", "or", "cropped_img", ".", "shape", "[", "1", "]", "<=", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "char_bbox_grp", "=", "np", ".", "array", "(", "char_bbox_grps", "[", "i", "]", ")", "\n", "char_bbox_grp", "[", ":", ",", ":", ":", "2", "]", "-=", "min_x", "\n", "char_bbox_grp", "[", ":", ",", "1", ":", ":", "2", "]", "-=", "min_y", "\n", "\n", "mmcv", ".", "imwrite", "(", "cropped_img", ",", "output_image_patch_path", ")", "\n", "with", "open", "(", "output_label_path", ",", "'w'", ")", "as", "output_label_file", ":", "\n", "            ", "output_label_file", ".", "write", "(", "word", "+", "'\\n'", ")", "\n", "for", "cbox", "in", "char_bbox_grp", ":", "\n", "                ", "output_label_file", ".", "write", "(", "'%d %d %d %d %d %d %d %d\\n'", "%", "\n", "tuple", "(", "cbox", ".", "tolist", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.synthtext_converter.main": [[132, 141], ["synthtext_converter.parse_args", "print", "synthtext_converter.load_gt_data", "functools.partial", "print", "mmcv.track_parallel_progress", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textrecog.synthtext_converter.load_gt_data"], ["", "", "", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "print", "(", "'Loading annoataion data...'", ")", "\n", "data", "=", "load_gt_data", "(", "args", ".", "anno_path", ",", "args", ".", "n_proc", ")", "\n", "process_with_outdir", "=", "partial", "(", "\n", "process", ",", "img_path_prefix", "=", "args", ".", "img_path", ",", "out_dir", "=", "args", ".", "out_dir", ")", "\n", "print", "(", "'Creating cropped images and gold labels...'", ")", "\n", "mmcv", ".", "track_parallel_progress", "(", "process_with_outdir", ",", "data", ",", "nproc", "=", "args", ".", "n_proc", ")", "\n", "print", "(", "'Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_ocr.FPNOCR.__init__": [[23, 56], ["mmcv.runner.BaseModule.__init__", "len", "mmcv.runner.ModuleList", "mmcv.runner.ModuleList", "mmcv.runner.ModuleList", "range", "range", "mmcv.cnn.ConvModule", "fpn_ocr.FPNOCR.lateral_convs.append", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "fpn_ocr.FPNOCR.smooth_convs_1x1.append", "fpn_ocr.FPNOCR.smooth_convs_3x3.append", "dict", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "last_stage_only", "=", "True", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "\n", "self", ".", "last_stage_only", "=", "last_stage_only", "\n", "\n", "self", ".", "lateral_convs", "=", "ModuleList", "(", ")", "\n", "self", ".", "smooth_convs_1x1", "=", "ModuleList", "(", ")", "\n", "self", ".", "smooth_convs_3x3", "=", "ModuleList", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_ins", ")", ":", "\n", "            ", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "out_channels", ",", "1", ",", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ")", "\n", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "self", ".", "num_ins", "-", "1", ")", ":", "\n", "            ", "s_conv_1x1", "=", "ConvModule", "(", "\n", "out_channels", "*", "2", ",", "out_channels", ",", "1", ",", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ")", "\n", "s_conv_3x3", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ")", "\n", "self", ".", "smooth_convs_1x1", ".", "append", "(", "s_conv_1x1", ")", "\n", "self", ".", "smooth_convs_3x3", ".", "append", "(", "s_conv_3x3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_ocr.FPNOCR._upsample_x2": [[57, 59], ["torch.interpolate", "torch.interpolate"], "methods", ["None"], ["", "", "def", "_upsample_x2", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "F", ".", "interpolate", "(", "x", ",", "scale_factor", "=", "2", ",", "mode", "=", "'bilinear'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_ocr.FPNOCR.forward": [[60, 88], ["range", "l_conv", "len", "fpn_ocr.FPNOCR._upsample_x2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "outs.append", "tuple", "tuple", "enumerate", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_ocr.FPNOCR._upsample_x2"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (list[Tensor]): A list of n tensors. Each tensor has the\n                shape of :math:`(N, C_i, H_i, W_i)`. It usually expects 4\n                tensors (C2-C5 features) from ResNet.\n\n        Returns:\n            tuple(Tensor): A tuple of n-1 tensors. Each has the of shape\n            :math:`(N, C_{out}, H_{n-2-i}, W_{n-2-i})`. If\n            ``last_stage_only=True`` (default), the size of the\n            tuple is 1 and only the last element will be returned.\n        \"\"\"", "\n", "lateral_features", "=", "[", "\n", "l_conv", "(", "inputs", "[", "i", "]", ")", "for", "i", ",", "l_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "smooth_convs_3x3", ")", ",", "0", ",", "-", "1", ")", ":", "# 3, 2, 1", "\n", "            ", "last_out", "=", "lateral_features", "[", "-", "1", "]", "if", "len", "(", "outs", ")", "==", "0", "else", "outs", "[", "-", "1", "]", "\n", "upsample", "=", "self", ".", "_upsample_x2", "(", "last_out", ")", "\n", "upsample_cat", "=", "torch", ".", "cat", "(", "(", "upsample", ",", "lateral_features", "[", "i", "-", "1", "]", ")", ",", "\n", "dim", "=", "1", ")", "\n", "smooth_1x1", "=", "self", ".", "smooth_convs_1x1", "[", "i", "-", "1", "]", "(", "upsample_cat", ")", "\n", "smooth_3x3", "=", "self", ".", "smooth_convs_3x3", "[", "i", "-", "1", "]", "(", "smooth_1x1", ")", "\n", "outs", ".", "append", "(", "smooth_3x3", ")", "\n", "\n", "", "return", "tuple", "(", "outs", "[", "-", "1", ":", "]", ")", "if", "self", ".", "last_stage_only", "else", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpnf.FPNF.__init__": [[23, 81], ["dict", "mmcv.runner.BaseModule.__init__", "dict", "dict", "mmcv.runner.ModuleList", "mmcv.runner.ModuleList", "len", "range", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "fpnf.FPNF.lateral_convs.append", "mmcv.cnn.ConvModule", "fpnf.FPNF.fpn_convs.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "[", "256", ",", "512", ",", "1024", ",", "2048", "]", ",", "\n", "out_channels", "=", "256", ",", "\n", "fusion_type", "=", "'concat'", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ",", "distribution", "=", "'uniform'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "conv_cfg", "=", "None", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "\n", "self", ".", "lateral_convs", "=", "ModuleList", "(", ")", "\n", "self", ".", "fpn_convs", "=", "ModuleList", "(", ")", "\n", "self", ".", "backbone_end_level", "=", "len", "(", "in_channels", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "backbone_end_level", ")", ":", "\n", "            ", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "\n", "if", "i", "<", "self", ".", "backbone_end_level", "-", "1", ":", "\n", "                ", "fpn_conv", "=", "ConvModule", "(", "\n", "out_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "self", ".", "fpn_convs", ".", "append", "(", "fpn_conv", ")", "\n", "\n", "", "", "self", ".", "fusion_type", "=", "fusion_type", "\n", "\n", "if", "self", ".", "fusion_type", "==", "'concat'", ":", "\n", "            ", "feature_channels", "=", "1024", "\n", "", "elif", "self", ".", "fusion_type", "==", "'add'", ":", "\n", "            ", "feature_channels", "=", "256", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "self", ".", "output_convs", "=", "ConvModule", "(", "\n", "feature_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpnf.FPNF.forward": [[82, 129], ["mmcv.runner.auto_fp16", "len", "range", "range", "fpnf.FPNF.output_convs", "len", "len", "lateral_conv", "torch.interpolate", "torch.interpolate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "enumerate", "torch.interpolate", "torch.interpolate", "range"], "methods", ["None"], ["", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (list[Tensor]): Each tensor has the shape of\n                :math:`(N, C_i, H_i, W_i)`. It usually expects 4 tensors\n                (C2-C5 features) from ResNet.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, C_{out}, H_0, W_0)` where\n            :math:`C_{out}` is ``out_channels``.\n        \"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "\n", "\n", "# build laterals", "\n", "laterals", "=", "[", "\n", "lateral_conv", "(", "inputs", "[", "i", "]", ")", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "\n", "# build top-down path", "\n", "used_backbone_levels", "=", "len", "(", "laterals", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "# step 1: upsample to level i-1 size and add level i-1", "\n", "            ", "prev_shape", "=", "laterals", "[", "i", "-", "1", "]", ".", "shape", "[", "2", ":", "]", "\n", "laterals", "[", "i", "-", "1", "]", "=", "laterals", "[", "i", "-", "1", "]", "+", "F", ".", "interpolate", "(", "\n", "laterals", "[", "i", "]", ",", "size", "=", "prev_shape", ",", "mode", "=", "'nearest'", ")", "\n", "# step 2: smooth level i-1", "\n", "laterals", "[", "i", "-", "1", "]", "=", "self", ".", "fpn_convs", "[", "i", "-", "1", "]", "(", "laterals", "[", "i", "-", "1", "]", ")", "\n", "\n", "# upsample and cont", "\n", "", "bottom_shape", "=", "laterals", "[", "0", "]", ".", "shape", "[", "2", ":", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "used_backbone_levels", ")", ":", "\n", "            ", "laterals", "[", "i", "]", "=", "F", ".", "interpolate", "(", "\n", "laterals", "[", "i", "]", ",", "size", "=", "bottom_shape", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "", "if", "self", ".", "fusion_type", "==", "'concat'", ":", "\n", "            ", "out", "=", "torch", ".", "cat", "(", "laterals", ",", "1", ")", "\n", "", "elif", "self", ".", "fusion_type", "==", "'add'", ":", "\n", "            ", "out", "=", "laterals", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "used_backbone_levels", ")", ":", "\n", "                ", "out", "+=", "laterals", "[", "i", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "out", "=", "self", ".", "output_convs", "(", "out", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM.__init__": [[17, 25], ["mmcv.runner.BaseModule.__init__", "fpem_ffm.SeparableConv2d", "fpem_ffm.SeparableConv2d", "fpem_ffm.SeparableConv2d", "fpem_ffm.SeparableConv2d", "fpem_ffm.SeparableConv2d", "fpem_ffm.SeparableConv2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", "=", "128", ",", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "up_add1", "=", "SeparableConv2d", "(", "in_channels", ",", "in_channels", ",", "1", ")", "\n", "self", ".", "up_add2", "=", "SeparableConv2d", "(", "in_channels", ",", "in_channels", ",", "1", ")", "\n", "self", ".", "up_add3", "=", "SeparableConv2d", "(", "in_channels", ",", "in_channels", ",", "1", ")", "\n", "self", ".", "down_add1", "=", "SeparableConv2d", "(", "in_channels", ",", "in_channels", ",", "2", ")", "\n", "self", ".", "down_add2", "=", "SeparableConv2d", "(", "in_channels", ",", "in_channels", ",", "2", ")", "\n", "self", ".", "down_add3", "=", "SeparableConv2d", "(", "in_channels", ",", "in_channels", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM.forward": [[26, 45], ["fpem_ffm.FPEM.up_add1", "fpem_ffm.FPEM.up_add2", "fpem_ffm.FPEM.up_add3", "fpem_ffm.FPEM.down_add1", "fpem_ffm.FPEM.down_add2", "fpem_ffm.FPEM.down_add3", "fpem_ffm.FPEM._upsample_add", "fpem_ffm.FPEM._upsample_add", "fpem_ffm.FPEM._upsample_add", "fpem_ffm.FPEM._upsample_add", "fpem_ffm.FPEM._upsample_add", "fpem_ffm.FPEM._upsample_add"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add", "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add", "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add", "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add", "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add", "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add"], ["", "def", "forward", "(", "self", ",", "c2", ",", "c3", ",", "c4", ",", "c5", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            c2, c3, c4, c5 (Tensor): Each has the shape of\n                :math:`(N, C_i, H_i, W_i)`.\n\n        Returns:\n            list[Tensor]: A list of 4 tensors of the same shape as input.\n        \"\"\"", "\n", "# upsample", "\n", "c4", "=", "self", ".", "up_add1", "(", "self", ".", "_upsample_add", "(", "c5", ",", "c4", ")", ")", "# c4 shape", "\n", "c3", "=", "self", ".", "up_add2", "(", "self", ".", "_upsample_add", "(", "c4", ",", "c3", ")", ")", "\n", "c2", "=", "self", ".", "up_add3", "(", "self", ".", "_upsample_add", "(", "c3", ",", "c2", ")", ")", "\n", "\n", "# downsample", "\n", "c3", "=", "self", ".", "down_add1", "(", "self", ".", "_upsample_add", "(", "c3", ",", "c2", ")", ")", "\n", "c4", "=", "self", ".", "down_add2", "(", "self", ".", "_upsample_add", "(", "c4", ",", "c3", ")", ")", "\n", "c5", "=", "self", ".", "down_add3", "(", "self", ".", "_upsample_add", "(", "c5", ",", "c4", ")", ")", "# c4 / 2", "\n", "return", "c2", ",", "c3", ",", "c4", ",", "c5", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM._upsample_add": [[46, 48], ["torch.interpolate", "y.size"], "methods", ["None"], ["", "def", "_upsample_add", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "return", "F", ".", "interpolate", "(", "x", ",", "size", "=", "y", ".", "size", "(", ")", "[", "2", ":", "]", ")", "+", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.SeparableConv2d.__init__": [[52, 66], ["mmcv.runner.BaseModule.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "stride", "=", "1", ",", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "depthwise_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "in_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "stride", "=", "stride", ",", "\n", "groups", "=", "in_channels", ")", "\n", "self", ".", "pointwise_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "in_channels", ",", "out_channels", "=", "out_channels", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.SeparableConv2d.forward": [[67, 73], ["fpem_ffm.SeparableConv2d.depthwise_conv", "fpem_ffm.SeparableConv2d.pointwise_conv", "fpem_ffm.SeparableConv2d.bn", "fpem_ffm.SeparableConv2d.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "depthwise_conv", "(", "x", ")", "\n", "x", "=", "self", ".", "pointwise_conv", "(", "x", ")", "\n", "x", "=", "self", ".", "bn", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM_FFM.__init__": [[88, 121], ["dict", "mmcv.runner.BaseModule.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "mmcv.runner.ModuleList", "range", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "fpem_ffm.FPEM_FFM.fpems.append", "fpem_ffm.FPEM"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "conv_out", "=", "128", ",", "\n", "fpem_repeat", "=", "2", ",", "\n", "align_corners", "=", "False", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ",", "distribution", "=", "'uniform'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "# reduce layers", "\n", "self", ".", "reduce_conv_c2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "in_channels", "[", "0", "]", ",", "\n", "out_channels", "=", "conv_out", ",", "\n", "kernel_size", "=", "1", ")", ",", "nn", ".", "BatchNorm2d", "(", "conv_out", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "reduce_conv_c3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "in_channels", "[", "1", "]", ",", "\n", "out_channels", "=", "conv_out", ",", "\n", "kernel_size", "=", "1", ")", ",", "nn", ".", "BatchNorm2d", "(", "conv_out", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "reduce_conv_c4", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "in_channels", "[", "2", "]", ",", "\n", "out_channels", "=", "conv_out", ",", "\n", "kernel_size", "=", "1", ")", ",", "nn", ".", "BatchNorm2d", "(", "conv_out", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "reduce_conv_c5", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "in_channels", "[", "3", "]", ",", "\n", "out_channels", "=", "conv_out", ",", "\n", "kernel_size", "=", "1", ")", ",", "nn", ".", "BatchNorm2d", "(", "conv_out", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "align_corners", "=", "align_corners", "\n", "self", ".", "fpems", "=", "ModuleList", "(", ")", "\n", "for", "_", "in", "range", "(", "fpem_repeat", ")", ":", "\n", "            ", "self", ".", "fpems", ".", "append", "(", "FPEM", "(", "conv_out", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpem_ffm.FPEM_FFM.forward": [[122, 174], ["fpem_ffm.FPEM_FFM.reduce_conv_c2", "fpem_ffm.FPEM_FFM.reduce_conv_c3", "fpem_ffm.FPEM_FFM.reduce_conv_c4", "fpem_ffm.FPEM_FFM.reduce_conv_c5", "enumerate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "tuple", "fpem", "c2_ffm.size", "c2_ffm.size", "c2_ffm.size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): A list of four tensors of shape\n                :math:`(N, C_i, H_i, W_i)`, representing C2, C3, C4, C5\n                features respectively. :math:`C_i` should matches the number in\n                ``in_channels``.\n\n        Returns:\n            list[Tensor]: Four tensors of shape\n            :math:`(N, C_{out}, H_0, W_0)` where :math:`C_{out}` is\n            ``conv_out``.\n        \"\"\"", "\n", "c2", ",", "c3", ",", "c4", ",", "c5", "=", "x", "\n", "# reduce channel", "\n", "c2", "=", "self", ".", "reduce_conv_c2", "(", "c2", ")", "\n", "c3", "=", "self", ".", "reduce_conv_c3", "(", "c3", ")", "\n", "c4", "=", "self", ".", "reduce_conv_c4", "(", "c4", ")", "\n", "c5", "=", "self", ".", "reduce_conv_c5", "(", "c5", ")", "\n", "\n", "# FPEM", "\n", "for", "i", ",", "fpem", "in", "enumerate", "(", "self", ".", "fpems", ")", ":", "\n", "            ", "c2", ",", "c3", ",", "c4", ",", "c5", "=", "fpem", "(", "c2", ",", "c3", ",", "c4", ",", "c5", ")", "\n", "if", "i", "==", "0", ":", "\n", "                ", "c2_ffm", "=", "c2", "\n", "c3_ffm", "=", "c3", "\n", "c4_ffm", "=", "c4", "\n", "c5_ffm", "=", "c5", "\n", "", "else", ":", "\n", "                ", "c2_ffm", "=", "c2_ffm", "+", "c2", "\n", "c3_ffm", "=", "c3_ffm", "+", "c3", "\n", "c4_ffm", "=", "c4_ffm", "+", "c4", "\n", "c5_ffm", "=", "c5_ffm", "+", "c5", "\n", "\n", "# FFM", "\n", "", "", "c5", "=", "F", ".", "interpolate", "(", "\n", "c5_ffm", ",", "\n", "c2_ffm", ".", "size", "(", ")", "[", "-", "2", ":", "]", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "self", ".", "align_corners", ")", "\n", "c4", "=", "F", ".", "interpolate", "(", "\n", "c4_ffm", ",", "\n", "c2_ffm", ".", "size", "(", ")", "[", "-", "2", ":", "]", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "self", ".", "align_corners", ")", "\n", "c3", "=", "F", ".", "interpolate", "(", "\n", "c3_ffm", ",", "\n", "c2_ffm", ".", "size", "(", ")", "[", "-", "2", ":", "]", ",", "\n", "mode", "=", "'bilinear'", ",", "\n", "align_corners", "=", "self", ".", "align_corners", ")", "\n", "outs", "=", "[", "c2_ffm", ",", "c3", ",", "c4", ",", "c5", "]", "\n", "return", "tuple", "(", "outs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_cat.FPNC.__init__": [[37, 130], ["mmcv.runner.BaseModule.__init__", "isinstance", "len", "mmcv.runner.ModuleList", "mmcv.runner.ModuleList", "range", "dict", "dict", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "fpn_cat.FPNC.lateral_convs.append", "fpn_cat.FPNC.smooth_convs.append", "mmcv.cnn.ConvModule", "dict", "dict", "mmcv.cnn.ConvModule", "dict", "dict", "dict", "dict", "fpn_cat.ScaleChannelSpatialAttention"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "lateral_channels", "=", "256", ",", "\n", "out_channels", "=", "64", ",", "\n", "bias_on_lateral", "=", "False", ",", "\n", "bn_re_on_lateral", "=", "False", ",", "\n", "bias_on_smooth", "=", "False", ",", "\n", "bn_re_on_smooth", "=", "False", ",", "\n", "asf_cfg", "=", "None", ",", "\n", "conv_after_concat", "=", "False", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv'", ")", ",", "\n", "dict", "(", "\n", "type", "=", "'Constant'", ",", "layer", "=", "'BatchNorm'", ",", "val", "=", "1.", ",", "bias", "=", "1e-4", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "list", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "lateral_channels", "=", "lateral_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "num_ins", "=", "len", "(", "in_channels", ")", "\n", "self", ".", "bn_re_on_lateral", "=", "bn_re_on_lateral", "\n", "self", ".", "bn_re_on_smooth", "=", "bn_re_on_smooth", "\n", "self", ".", "asf_cfg", "=", "asf_cfg", "\n", "self", ".", "conv_after_concat", "=", "conv_after_concat", "\n", "self", ".", "lateral_convs", "=", "ModuleList", "(", ")", "\n", "self", ".", "smooth_convs", "=", "ModuleList", "(", ")", "\n", "self", ".", "num_outs", "=", "self", ".", "num_ins", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_ins", ")", ":", "\n", "            ", "norm_cfg", "=", "None", "\n", "act_cfg", "=", "None", "\n", "if", "self", ".", "bn_re_on_lateral", ":", "\n", "                ", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", "\n", "", "l_conv", "=", "ConvModule", "(", "\n", "in_channels", "[", "i", "]", ",", "\n", "lateral_channels", ",", "\n", "1", ",", "\n", "bias", "=", "bias_on_lateral", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "norm_cfg", "=", "None", "\n", "act_cfg", "=", "None", "\n", "if", "self", ".", "bn_re_on_smooth", ":", "\n", "                ", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", "\n", "\n", "", "smooth_conv", "=", "ConvModule", "(", "\n", "lateral_channels", ",", "\n", "out_channels", ",", "\n", "3", ",", "\n", "bias", "=", "bias_on_smooth", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "\n", "self", ".", "lateral_convs", ".", "append", "(", "l_conv", ")", "\n", "self", ".", "smooth_convs", ".", "append", "(", "smooth_conv", ")", "\n", "\n", "", "if", "self", ".", "asf_cfg", "is", "not", "None", ":", "\n", "            ", "self", ".", "asf_conv", "=", "ConvModule", "(", "\n", "out_channels", "*", "self", ".", "num_outs", ",", "\n", "out_channels", "*", "self", ".", "num_outs", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "None", ",", "\n", "inplace", "=", "False", ")", "\n", "if", "self", ".", "asf_cfg", "[", "'attention_type'", "]", "==", "'ScaleChannelSpatial'", ":", "\n", "                ", "self", ".", "asf_attn", "=", "ScaleChannelSpatialAttention", "(", "\n", "self", ".", "out_channels", "*", "self", ".", "num_outs", ",", "\n", "(", "self", ".", "out_channels", "*", "self", ".", "num_outs", ")", "//", "4", ",", "self", ".", "num_outs", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "if", "self", ".", "conv_after_concat", ":", "\n", "            ", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", "\n", "self", ".", "out_conv", "=", "ConvModule", "(", "\n", "out_channels", "*", "self", ".", "num_outs", ",", "\n", "out_channels", "*", "self", ".", "num_outs", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "inplace", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_cat.FPNC.forward": [[131, 179], ["mmcv.runner.auto_fp16", "len", "range", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "len", "lateral_conv", "torch.interpolate", "torch.interpolate", "torch.interpolate", "fpn_cat.FPNC.asf_conv", "fpn_cat.FPNC.asf_attn", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fpn_cat.FPNC.out_conv", "enumerate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "range", "enhanced_feature.append"], "methods", ["None"], ["", "", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (list[Tensor]): Each tensor has the shape of\n                :math:`(N, C_i, H_i, W_i)`. It usually expects 4 tensors\n                (C2-C5 features) from ResNet.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, C_{out}, H_0, W_0)` where\n            :math:`C_{out}` is ``out_channels``.\n        \"\"\"", "\n", "assert", "len", "(", "inputs", ")", "==", "len", "(", "self", ".", "in_channels", ")", "\n", "# build laterals", "\n", "laterals", "=", "[", "\n", "lateral_conv", "(", "inputs", "[", "i", "]", ")", "\n", "for", "i", ",", "lateral_conv", "in", "enumerate", "(", "self", ".", "lateral_convs", ")", "\n", "]", "\n", "used_backbone_levels", "=", "len", "(", "laterals", ")", "\n", "# build top-down path", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "prev_shape", "=", "laterals", "[", "i", "-", "1", "]", ".", "shape", "[", "2", ":", "]", "\n", "laterals", "[", "i", "-", "1", "]", "=", "laterals", "[", "i", "-", "1", "]", "+", "F", ".", "interpolate", "(", "\n", "laterals", "[", "i", "]", ",", "size", "=", "prev_shape", ",", "mode", "=", "'nearest'", ")", "\n", "# build outputs", "\n", "# part 1: from original levels", "\n", "", "outs", "=", "[", "\n", "self", ".", "smooth_convs", "[", "i", "]", "(", "laterals", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "used_backbone_levels", ")", "\n", "]", "\n", "\n", "for", "i", ",", "out", "in", "enumerate", "(", "outs", ")", ":", "\n", "            ", "outs", "[", "i", "]", "=", "F", ".", "interpolate", "(", "\n", "outs", "[", "i", "]", ",", "size", "=", "outs", "[", "0", "]", ".", "shape", "[", "2", ":", "]", ",", "mode", "=", "'nearest'", ")", "\n", "\n", "", "out", "=", "torch", ".", "cat", "(", "outs", ",", "dim", "=", "1", ")", "\n", "if", "self", ".", "asf_cfg", "is", "not", "None", ":", "\n", "            ", "asf_feature", "=", "self", ".", "asf_conv", "(", "out", ")", "\n", "attention", "=", "self", ".", "asf_attn", "(", "asf_feature", ")", "\n", "enhanced_feature", "=", "[", "]", "\n", "for", "i", ",", "out", "in", "enumerate", "(", "outs", ")", ":", "\n", "                ", "enhanced_feature", ".", "append", "(", "attention", "[", ":", ",", "i", ":", "i", "+", "1", "]", "*", "outs", "[", "i", "]", ")", "\n", "", "out", "=", "torch", ".", "cat", "(", "enhanced_feature", ",", "dim", "=", "1", ")", "\n", "\n", "", "if", "self", ".", "conv_after_concat", ":", "\n", "            ", "out", "=", "self", ".", "out_conv", "(", "out", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_cat.ScaleChannelSpatialAttention.__init__": [[194, 252], ["mmcv.runner.BaseModule.__init__", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "mmcv.runner.Sequential", "mmcv.runner.Sequential", "mmcv.cnn.ConvModule", "dict", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "dict", "dict", "dict", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "c_wise_channels", ",", "\n", "out_channels", ",", "\n", "init_cfg", "=", "[", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv'", ",", "bias", "=", "0", ")", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "avg_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "# Channel Wise", "\n", "self", ".", "channel_wise", "=", "Sequential", "(", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "c_wise_channels", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "inplace", "=", "False", ")", ",", "\n", "ConvModule", "(", "\n", "c_wise_channels", ",", "\n", "in_channels", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'Sigmoid'", ")", ",", "\n", "inplace", "=", "False", ")", ")", "\n", "# Spatial Wise", "\n", "self", ".", "spatial_wise", "=", "Sequential", "(", "\n", "ConvModule", "(", "\n", "1", ",", "\n", "1", ",", "\n", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "inplace", "=", "False", ")", ",", "\n", "ConvModule", "(", "\n", "1", ",", "\n", "1", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'Sigmoid'", ")", ",", "\n", "inplace", "=", "False", ")", ")", "\n", "# Attention Wise", "\n", "self", ".", "attention_wise", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "1", ",", "\n", "bias", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "None", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'Sigmoid'", ")", ",", "\n", "inplace", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_cat.ScaleChannelSpatialAttention.forward": [[253, 272], ["mmcv.runner.auto_fp16", "fpn_cat.ScaleChannelSpatialAttention.avg_pool", "fpn_cat.ScaleChannelSpatialAttention.channel_wise", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "fpn_cat.ScaleChannelSpatialAttention.attention_wise", "fpn_cat.ScaleChannelSpatialAttention.spatial_wise"], "methods", ["None"], ["", "@", "auto_fp16", "(", ")", "\n", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (Tensor): A concat FPN feature tensor that has the shape of\n                :math:`(N, C, H, W)`.\n\n        Returns:\n            Tensor: An attention map of shape :math:`(N, C_{out}, H, W)`\n            where :math:`C_{out}` is ``out_channels``.\n        \"\"\"", "\n", "out", "=", "self", ".", "avg_pool", "(", "inputs", ")", "\n", "out", "=", "self", ".", "channel_wise", "(", "out", ")", "\n", "out", "=", "out", "+", "inputs", "\n", "inputs", "=", "torch", ".", "mean", "(", "out", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "out", "=", "self", ".", "spatial_wise", "(", "inputs", ")", "+", "out", "\n", "out", "=", "self", ".", "attention_wise", "(", "out", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_unet.UpBlock.__init__": [[13, 25], ["mmcv.runner.BaseModule.__init__", "isinstance", "isinstance", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ConvTranspose2d", "torch.nn.ConvTranspose2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "assert", "isinstance", "(", "out_channels", ",", "int", ")", "\n", "\n", "self", ".", "conv1x1", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "in_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "self", ".", "conv3x3", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "deconv", "=", "nn", ".", "ConvTranspose2d", "(", "\n", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "4", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_unet.UpBlock.forward": [[26, 31], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "fpn_unet.UpBlock.deconv", "fpn_unet.UpBlock.conv1x1", "fpn_unet.UpBlock.conv3x3"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv1x1", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv3x3"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "conv1x1", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "conv3x3", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "deconv", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_unet.FPN_UNet.__init__": [[50, 79], ["dict", "mmcv.runner.BaseModule.__init__", "isinstance", "torch.nn.ConvTranspose2d", "torch.nn.ConvTranspose2d", "fpn_unet.UpBlock", "fpn_unet.UpBlock", "fpn_unet.UpBlock", "fpn_unet.UpBlock", "len", "min", "range", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Xavier'", ",", "\n", "layer", "=", "[", "'Conv2d'", ",", "'ConvTranspose2d'", "]", ",", "\n", "distribution", "=", "'uniform'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "assert", "len", "(", "in_channels", ")", "==", "4", "\n", "assert", "isinstance", "(", "out_channels", ",", "int", ")", "\n", "\n", "blocks_out_channels", "=", "[", "out_channels", "]", "+", "[", "\n", "min", "(", "out_channels", "*", "2", "**", "i", ",", "256", ")", "for", "i", "in", "range", "(", "4", ")", "\n", "]", "\n", "blocks_in_channels", "=", "[", "blocks_out_channels", "[", "1", "]", "]", "+", "[", "\n", "in_channels", "[", "i", "]", "+", "blocks_out_channels", "[", "i", "+", "2", "]", "for", "i", "in", "range", "(", "3", ")", "\n", "]", "+", "[", "in_channels", "[", "3", "]", "]", "\n", "\n", "self", ".", "up4", "=", "nn", ".", "ConvTranspose2d", "(", "\n", "blocks_in_channels", "[", "4", "]", ",", "\n", "blocks_out_channels", "[", "4", "]", ",", "\n", "kernel_size", "=", "4", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "up_block3", "=", "UpBlock", "(", "blocks_in_channels", "[", "3", "]", ",", "blocks_out_channels", "[", "3", "]", ")", "\n", "self", ".", "up_block2", "=", "UpBlock", "(", "blocks_in_channels", "[", "2", "]", ",", "blocks_out_channels", "[", "2", "]", ")", "\n", "self", ".", "up_block1", "=", "UpBlock", "(", "blocks_in_channels", "[", "1", "]", ",", "blocks_out_channels", "[", "1", "]", ")", "\n", "self", ".", "up_block0", "=", "UpBlock", "(", "blocks_in_channels", "[", "0", "]", ",", "blocks_out_channels", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.necks.fpn_unet.FPN_UNet.forward": [[80, 108], ["torch.relu", "torch.relu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.relu", "torch.relu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.relu", "torch.relu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.relu", "torch.relu", "fpn_unet.FPN_UNet.up_block0", "fpn_unet.FPN_UNet.up4", "fpn_unet.FPN_UNet.up_block3", "fpn_unet.FPN_UNet.up_block2", "fpn_unet.FPN_UNet.up_block1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor] | tuple[Tensor]): A list of four tensors of shape\n                :math:`(N, C_i, H_i, W_i)`, representing C2, C3, C4, C5\n                features respectively. :math:`C_i` should matches the number in\n                ``in_channels``.\n\n        Returns:\n            Tensor: Shape :math:`(N, C, H, W)` where :math:`H=4H_0` and\n            :math:`W=4W_0`.\n        \"\"\"", "\n", "c2", ",", "c3", ",", "c4", ",", "c5", "=", "x", "\n", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "up4", "(", "c5", ")", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "c4", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "up_block3", "(", "x", ")", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "c3", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "up_block2", "(", "x", ")", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "c2", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "up_block1", "(", "x", ")", ")", "\n", "\n", "x", "=", "self", ".", "up_block0", "(", "x", ")", "\n", "# the output should be of the same height and width as backbone input", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.__init__": [[17, 20], ["mmcv.runner.BaseModule.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "fp16_enabled", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.extract_feat": [[21, 25], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "\"\"\"Extract features from images.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.forward_train": [[26, 40], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "forward_train", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (tensor): tensors with shape (N, C, H, W).\n                Typically should be mean centered and std scaled.\n            img_metas (list[dict]): List of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details of the values of these keys, see\n                :class:`mmdet.datasets.pipelines.Collect`.\n            kwargs (keyword arguments): Specific to concrete implementation.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.simple_test": [[41, 44], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.aug_test": [[45, 55], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (list[tensor]): Tensor should have shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (list[list[dict]]): The metadata of images.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.forward_test": [[56, 73], ["isinstance", "base.BaseRecognizer.simple_test", "base.BaseRecognizer.aug_test", "len", "imgs[].size", "len", "len", "imgs[].size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.aug_test"], ["", "def", "forward_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            imgs (tensor | list[tensor]): Tensor should have shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (list[dict] | list[list[dict]]):\n                The outer list indicates images in a batch.\n        \"\"\"", "\n", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "            ", "assert", "len", "(", "imgs", ")", ">", "0", "\n", "assert", "imgs", "[", "0", "]", ".", "size", "(", "0", ")", "==", "1", ",", "(", "'aug test does not support '", "\n", "f'inference with batch size '", "\n", "f'{imgs[0].size(0)}'", ")", "\n", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "return", "self", ".", "aug_test", "(", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "self", ".", "simple_test", "(", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.forward": [[74, 95], ["mmcv.runner.auto_fp16", "isinstance", "base.BaseRecognizer.forward_test", "base.BaseRecognizer.forward_train", "enumerate", "isinstance", "each_img.dim", "each_img.unsqueeze", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train"], ["", "@", "auto_fp16", "(", "apply_to", "=", "(", "'img'", ",", ")", ")", "\n", "def", "forward", "(", "self", ",", "img", ",", "img_metas", ",", "return_loss", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Calls either :func:`forward_train` or :func:`forward_test` depending\n        on whether ``return_loss`` is ``True``.\n\n        Note that img and img_meta are single-nested (i.e. tensor and\n        list[dict]).\n        \"\"\"", "\n", "\n", "if", "return_loss", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "img", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n", "", "if", "isinstance", "(", "img", ",", "list", ")", ":", "\n", "            ", "for", "idx", ",", "each_img", "in", "enumerate", "(", "img", ")", ":", "\n", "                ", "if", "each_img", ".", "dim", "(", ")", "==", "3", ":", "\n", "                    ", "img", "[", "idx", "]", "=", "each_img", ".", "unsqueeze", "(", "0", ")", "\n", "", "", "", "else", ":", "\n", "            ", "if", "len", "(", "img_metas", ")", "==", "1", "and", "isinstance", "(", "img_metas", "[", "0", "]", ",", "list", ")", ":", "\n", "                ", "img_metas", "=", "img_metas", "[", "0", "]", "\n", "\n", "", "", "return", "self", ".", "forward_test", "(", "img", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer._parse_losses": [[96, 130], ["collections.OrderedDict", "losses.items", "sum", "collections.OrderedDict.items", "isinstance", "loss_value.data.clone.data.clone.item", "loss_value.data.clone.data.clone.mean", "isinstance", "torch.is_available", "torch.is_available", "torch.is_initialized", "torch.is_initialized", "loss_value.data.clone.data.clone.data.clone", "torch.all_reduce", "torch.all_reduce", "sum", "TypeError", "collections.OrderedDict.items", "loss_value.data.clone.data.clone.div_", "torch.get_world_size", "torch.get_world_size", "_loss.mean"], "methods", ["None"], ["", "def", "_parse_losses", "(", "self", ",", "losses", ")", ":", "\n", "        ", "\"\"\"Parse the raw outputs (losses) of the network.\n\n        Args:\n            losses (dict): Raw outputs of the network, which usually contain\n                losses and other necessary information.\n\n        Returns:\n            tuple[tensor, dict]: (loss, log_vars), loss is the loss tensor\n                which may be a weighted sum of all losses, log_vars contains\n                all the variables to be sent to the logger.\n        \"\"\"", "\n", "log_vars", "=", "OrderedDict", "(", ")", "\n", "for", "loss_name", ",", "loss_value", "in", "losses", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "loss_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "mean", "(", ")", "\n", "", "elif", "isinstance", "(", "loss_value", ",", "list", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "sum", "(", "_loss", ".", "mean", "(", ")", "for", "_loss", "in", "loss_value", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "f'{loss_name} is not a tensor or list of tensors'", ")", "\n", "\n", "", "", "loss", "=", "sum", "(", "_value", "for", "_key", ",", "_value", "in", "log_vars", ".", "items", "(", ")", "\n", "if", "'loss'", "in", "_key", ")", "\n", "\n", "log_vars", "[", "'loss'", "]", "=", "loss", "\n", "for", "loss_name", ",", "loss_value", "in", "log_vars", ".", "items", "(", ")", ":", "\n", "# reduce loss when distributed training", "\n", "            ", "if", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ":", "\n", "                ", "loss_value", "=", "loss_value", ".", "data", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "loss_value", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ")", "\n", "", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "item", "(", ")", "\n", "\n", "", "return", "loss", ",", "log_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.train_step": [[131, 165], ["base.BaseRecognizer.", "base.BaseRecognizer._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer._parse_losses"], ["", "def", "train_step", "(", "self", ",", "data", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"The iteration step during training.\n\n        This method defines an iteration step during training, except for the\n        back propagation and optimizer update, which are done by an optimizer\n        hook. Note that in some complicated cases or models (e.g. GAN),\n        the whole process (including the back propagation and optimizer update)\n        is also defined by this method.\n\n        Args:\n            data (dict): The outputs of dataloader.\n            optimizer (:obj:`torch.optim.Optimizer` | dict): The optimizer of\n                runner is passed to ``train_step()``. This argument is unused\n                and reserved.\n\n        Returns:\n            dict: It should contain at least 3 keys: ``loss``, ``log_vars``,\n                ``num_samples``.\n\n                - ``loss`` is a tensor for back propagation, which is a\n                weighted sum of multiple losses.\n                - ``log_vars`` contains all the variables to be sent to the\n                logger.\n                - ``num_samples`` indicates the batch size used for\n                averaging the logs (Note: for the\n                DDP model, num_samples refers to the batch size for each GPU).\n        \"\"\"", "\n", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "\n", "outputs", "=", "dict", "(", "\n", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "num_samples", "=", "len", "(", "data", "[", "'img_metas'", "]", ")", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.val_step": [[166, 180], ["base.BaseRecognizer.", "base.BaseRecognizer._parse_losses", "dict", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer._parse_losses"], ["", "def", "val_step", "(", "self", ",", "data", ",", "optimizer", ")", ":", "\n", "        ", "\"\"\"The iteration step during validation.\n\n        This method shares the same signature as :func:`train_step`, but is\n        used during val epochs. Note that the evaluation after training epochs\n        is not implemented by this method, but by an evaluation hook.\n        \"\"\"", "\n", "losses", "=", "self", "(", "**", "data", ")", "\n", "loss", ",", "log_vars", "=", "self", ".", "_parse_losses", "(", "losses", ")", "\n", "\n", "outputs", "=", "dict", "(", "\n", "loss", "=", "loss", ",", "log_vars", "=", "log_vars", ",", "num_samples", "=", "len", "(", "data", "[", "'img_metas'", "]", ")", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.base.BaseRecognizer.show_result": [[181, 233], ["mmcv.imread", "mmocr.core.imshow_text_label.copy", "result.keys", "mmocr.core.imshow_text_label", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label"], ["", "@", "staticmethod", "\n", "def", "show_result", "(", "img", ",", "\n", "result", ",", "\n", "gt_label", "=", "''", ",", "\n", "win_name", "=", "''", ",", "\n", "show", "=", "False", ",", "\n", "wait_time", "=", "0", ",", "\n", "out_file", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Draw `result` on `img`.\n\n        Args:\n            img (str or tensor): The image to be displayed.\n            result (dict): The results to draw on `img`.\n            gt_label (str): Ground truth label of img.\n            win_name (str): The window name.\n            wait_time (int): Value of waitKey param.\n                Default: 0.\n            show (bool): Whether to show the image.\n                Default: False.\n            out_file (str or None): The output filename.\n                Default: None.\n\n        Returns:\n            img (tensor): Only if not `show` or `out_file`.\n        \"\"\"", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "img", "=", "img", ".", "copy", "(", ")", "\n", "pred_label", "=", "None", "\n", "if", "'text'", "in", "result", ".", "keys", "(", ")", ":", "\n", "            ", "pred_label", "=", "result", "[", "'text'", "]", "\n", "\n", "# if out_file specified, do not show image in window", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "            ", "show", "=", "False", "\n", "# draw text label", "\n", "", "if", "pred_label", "is", "not", "None", ":", "\n", "            ", "img", "=", "imshow_text_label", "(", "\n", "img", ",", "\n", "pred_label", ",", "\n", "gt_label", ",", "\n", "show", "=", "show", ",", "\n", "win_name", "=", "win_name", ",", "\n", "wait_time", "=", "wait_time", ",", "\n", "out_file", "=", "out_file", ")", "\n", "\n", "", "if", "not", "(", "show", "or", "out_file", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'show==False and out_file is not specified, only '", "\n", "'result image will be returned'", ")", "\n", "return", "img", "\n", "\n", "", "return", "img", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.abinet.ABINet.__init__": [[20, 82], ["encode_decode_recognizer.EncodeDecodeRecognizer.__init__", "label_convertor.update", "mmocr.models.builder.build_convertor", "mmocr.models.builder.build_backbone", "mmocr.models.builder.build_loss", "mmocr.models.builder.build_preprocessor", "mmocr.models.builder.build_encoder", "decoder.update", "decoder.update", "decoder.update", "decoder.update", "mmocr.models.builder.build_decoder", "warnings.warn", "dict", "mmocr.models.builder.build_fuser", "abinet.ABINet.label_convertor.num_classes"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_backbone", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_preprocessor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_encoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_fuser", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.num_classes"], ["def", "__init__", "(", "self", ",", "\n", "preprocessor", "=", "None", ",", "\n", "backbone", "=", "None", ",", "\n", "encoder", "=", "None", ",", "\n", "decoder", "=", "None", ",", "\n", "iter_size", "=", "1", ",", "\n", "fuser", "=", "None", ",", "\n", "loss", "=", "None", ",", "\n", "label_convertor", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "pretrained", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "EncodeDecodeRecognizer", ",", "self", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "# Label convertor (str2tensor, tensor2str)", "\n", "assert", "label_convertor", "is", "not", "None", "\n", "label_convertor", ".", "update", "(", "max_seq_len", "=", "max_seq_len", ")", "\n", "self", ".", "label_convertor", "=", "build_convertor", "(", "label_convertor", ")", "\n", "\n", "# Preprocessor module, e.g., TPS", "\n", "self", ".", "preprocessor", "=", "None", "\n", "if", "preprocessor", "is", "not", "None", ":", "\n", "            ", "self", ".", "preprocessor", "=", "build_preprocessor", "(", "preprocessor", ")", "\n", "\n", "# Backbone", "\n", "", "assert", "backbone", "is", "not", "None", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "\n", "# Encoder module", "\n", "self", ".", "encoder", "=", "None", "\n", "if", "encoder", "is", "not", "None", ":", "\n", "            ", "self", ".", "encoder", "=", "build_encoder", "(", "encoder", ")", "\n", "\n", "# Decoder module", "\n", "", "self", ".", "decoder", "=", "None", "\n", "if", "decoder", "is", "not", "None", ":", "\n", "            ", "decoder", ".", "update", "(", "num_classes", "=", "self", ".", "label_convertor", ".", "num_classes", "(", ")", ")", "\n", "decoder", ".", "update", "(", "start_idx", "=", "self", ".", "label_convertor", ".", "start_idx", ")", "\n", "decoder", ".", "update", "(", "padding_idx", "=", "self", ".", "label_convertor", ".", "padding_idx", ")", "\n", "decoder", ".", "update", "(", "max_seq_len", "=", "max_seq_len", ")", "\n", "self", ".", "decoder", "=", "build_decoder", "(", "decoder", ")", "\n", "\n", "# Loss", "\n", "", "assert", "loss", "is", "not", "None", "\n", "self", ".", "loss", "=", "build_loss", "(", "loss", ")", "\n", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "warnings", ".", "warn", "(", "'DeprecationWarning: pretrained is a deprecated \\\n                key, please consider using init_cfg'", ")", "\n", "self", ".", "init_cfg", "=", "dict", "(", "type", "=", "'Pretrained'", ",", "checkpoint", "=", "pretrained", ")", "\n", "\n", "", "self", ".", "iter_size", "=", "iter_size", "\n", "\n", "self", ".", "fuser", "=", "None", "\n", "if", "fuser", "is", "not", "None", ":", "\n", "            ", "self", ".", "fuser", "=", "build_fuser", "(", "fuser", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.abinet.ABINet.forward_train": [[83, 136], ["abinet.ABINet.extract_feat", "abinet.ABINet.label_convertor.str2tensor", "range", "dict", "abinet.ABINet.loss", "abinet.ABINet.encoder", "img.size", "abinet.ABINet.decoder", "out_decs.append", "abinet.ABINet.fuser", "out_fusers.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A list of image info dict where each dict\n                contains: 'img_shape', 'filename', and may also contain\n                'ori_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                :class:`mmdet.datasets.pipelines.Collect`.\n\n        Returns:\n            dict[str, tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "            ", "valid_ratio", "=", "1.0", "*", "img_meta", "[", "'resize_shape'", "]", "[", "1", "]", "/", "img", ".", "size", "(", "-", "1", ")", "\n", "img_meta", "[", "'valid_ratio'", "]", "=", "valid_ratio", "\n", "\n", "", "feat", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "gt_labels", "=", "[", "img_meta", "[", "'text'", "]", "for", "img_meta", "in", "img_metas", "]", "\n", "\n", "targets_dict", "=", "self", ".", "label_convertor", ".", "str2tensor", "(", "gt_labels", ")", "\n", "\n", "text_logits", "=", "None", "\n", "out_enc", "=", "None", "\n", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "out_enc", "=", "self", ".", "encoder", "(", "feat", ")", "\n", "text_logits", "=", "out_enc", "[", "'logits'", "]", "\n", "\n", "", "out_decs", "=", "[", "]", "\n", "out_fusers", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "self", ".", "iter_size", ")", ":", "\n", "            ", "if", "self", ".", "decoder", "is", "not", "None", ":", "\n", "                ", "out_dec", "=", "self", ".", "decoder", "(", "\n", "feat", ",", "\n", "text_logits", ",", "\n", "targets_dict", ",", "\n", "img_metas", ",", "\n", "train_mode", "=", "True", ")", "\n", "out_decs", ".", "append", "(", "out_dec", ")", "\n", "\n", "", "if", "self", ".", "fuser", "is", "not", "None", ":", "\n", "                ", "out_fuser", "=", "self", ".", "fuser", "(", "out_enc", "[", "'feature'", "]", ",", "out_dec", "[", "'feature'", "]", ")", "\n", "text_logits", "=", "out_fuser", "[", "'logits'", "]", "\n", "out_fusers", ".", "append", "(", "out_fuser", ")", "\n", "\n", "", "", "outputs", "=", "dict", "(", "\n", "out_enc", "=", "out_enc", ",", "out_decs", "=", "out_decs", ",", "out_fusers", "=", "out_fusers", ")", "\n", "\n", "losses", "=", "self", ".", "loss", "(", "outputs", ",", "targets_dict", ",", "img_metas", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.abinet.ABINet.simple_test": [[137, 193], ["abinet.ABINet.extract_feat", "range", "torch.onnx.is_in_onnx_export", "abinet.ABINet.label_convertor.tensor2idx", "abinet.ABINet.label_convertor.idx2str", "zip", "abinet.ABINet.encoder", "len", "results.append", "img.size", "abinet.ABINet.decoder", "out_decs.append", "abinet.ABINet.fuser", "out_fusers.append", "len", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (torch.Tensor): Image input tensor.\n            img_metas (list[dict]): List of image information.\n\n        Returns:\n            list[str]: Text label result of each image.\n        \"\"\"", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "            ", "valid_ratio", "=", "1.0", "*", "img_meta", "[", "'resize_shape'", "]", "[", "1", "]", "/", "img", ".", "size", "(", "-", "1", ")", "\n", "img_meta", "[", "'valid_ratio'", "]", "=", "valid_ratio", "\n", "\n", "", "feat", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "text_logits", "=", "None", "\n", "out_enc", "=", "None", "\n", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "out_enc", "=", "self", ".", "encoder", "(", "feat", ")", "\n", "text_logits", "=", "out_enc", "[", "'logits'", "]", "\n", "\n", "", "out_decs", "=", "[", "]", "\n", "out_fusers", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "self", ".", "iter_size", ")", ":", "\n", "            ", "if", "self", ".", "decoder", "is", "not", "None", ":", "\n", "                ", "out_dec", "=", "self", ".", "decoder", "(", "\n", "feat", ",", "text_logits", ",", "img_metas", "=", "img_metas", ",", "train_mode", "=", "False", ")", "\n", "out_decs", ".", "append", "(", "out_dec", ")", "\n", "\n", "", "if", "self", ".", "fuser", "is", "not", "None", ":", "\n", "                ", "out_fuser", "=", "self", ".", "fuser", "(", "out_enc", "[", "'feature'", "]", ",", "out_dec", "[", "'feature'", "]", ")", "\n", "text_logits", "=", "out_fuser", "[", "'logits'", "]", "\n", "out_fusers", ".", "append", "(", "out_fuser", ")", "\n", "\n", "", "", "if", "len", "(", "out_fusers", ")", ">", "0", ":", "\n", "            ", "ret", "=", "out_fusers", "[", "-", "1", "]", "\n", "", "elif", "len", "(", "out_decs", ")", ">", "0", ":", "\n", "            ", "ret", "=", "out_decs", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "ret", "=", "out_enc", "\n", "\n", "# early return to avoid post processing", "\n", "", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "            ", "return", "ret", "[", "'logits'", "]", "\n", "\n", "", "label_indexes", ",", "label_scores", "=", "self", ".", "label_convertor", ".", "tensor2idx", "(", "\n", "ret", "[", "'logits'", "]", ",", "img_metas", ")", "\n", "label_strings", "=", "self", ".", "label_convertor", ".", "idx2str", "(", "label_indexes", ")", "\n", "\n", "# flatten batch results", "\n", "results", "=", "[", "]", "\n", "for", "string", ",", "score", "in", "zip", "(", "label_strings", ",", "label_scores", ")", ":", "\n", "            ", "results", ".", "append", "(", "dict", "(", "text", "=", "string", ",", "score", "=", "score", ")", ")", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.seg_recognizer.SegRecognizer.__init__": [[14, 59], ["base.BaseRecognizer.__init__", "mmocr.models.builder.build_convertor", "mmocr.models.builder.build_backbone", "mmocr.models.builder.build_neck", "head.update", "mmocr.models.builder.build_head", "mmocr.models.builder.build_loss", "mmocr.models.builder.build_preprocessor", "warnings.warn", "dict", "seg_recognizer.SegRecognizer.label_convertor.num_classes"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_backbone", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_neck", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_head", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_preprocessor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.num_classes"], ["def", "__init__", "(", "self", ",", "\n", "preprocessor", "=", "None", ",", "\n", "backbone", "=", "None", ",", "\n", "neck", "=", "None", ",", "\n", "head", "=", "None", ",", "\n", "loss", "=", "None", ",", "\n", "label_convertor", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "# Label_convertor", "\n", "assert", "label_convertor", "is", "not", "None", "\n", "self", ".", "label_convertor", "=", "build_convertor", "(", "label_convertor", ")", "\n", "\n", "# Preprocessor module, e.g., TPS", "\n", "self", ".", "preprocessor", "=", "None", "\n", "if", "preprocessor", "is", "not", "None", ":", "\n", "            ", "self", ".", "preprocessor", "=", "build_preprocessor", "(", "preprocessor", ")", "\n", "\n", "# Backbone", "\n", "", "assert", "backbone", "is", "not", "None", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "\n", "# Neck", "\n", "assert", "neck", "is", "not", "None", "\n", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "\n", "\n", "# Head", "\n", "assert", "head", "is", "not", "None", "\n", "head", ".", "update", "(", "num_classes", "=", "self", ".", "label_convertor", ".", "num_classes", "(", ")", ")", "\n", "self", ".", "head", "=", "build_head", "(", "head", ")", "\n", "\n", "# Loss", "\n", "assert", "loss", "is", "not", "None", "\n", "self", ".", "loss", "=", "build_loss", "(", "loss", ")", "\n", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "warnings", ".", "warn", "(", "'DeprecationWarning: pretrained is a deprecated \\\n                key, please consider using init_cfg'", ")", "\n", "self", ".", "init_cfg", "=", "dict", "(", "type", "=", "'Pretrained'", ",", "checkpoint", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.seg_recognizer.SegRecognizer.extract_feat": [[60, 68], ["seg_recognizer.SegRecognizer.backbone", "seg_recognizer.SegRecognizer.preprocessor"], "methods", ["None"], ["", "", "def", "extract_feat", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Directly extract features from the backbone.\"\"\"", "\n", "if", "self", ".", "preprocessor", "is", "not", "None", ":", "\n", "            ", "img", "=", "self", ".", "preprocessor", "(", "img", ")", "\n", "\n", "", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.seg_recognizer.SegRecognizer.forward_train": [[69, 95], ["seg_recognizer.SegRecognizer.extract_feat", "seg_recognizer.SegRecognizer.neck", "seg_recognizer.SegRecognizer.head", "seg_recognizer.SegRecognizer.loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "gt_kernels", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A list of image info dict where each dict\n                contains: 'img_shape', 'filename', and may also contain\n                'ori_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                :class:`mmdet.datasets.pipelines.Collect`.\n\n        Returns:\n            dict[str, tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "\n", "feats", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "out_neck", "=", "self", ".", "neck", "(", "feats", ")", "\n", "\n", "out_head", "=", "self", ".", "head", "(", "out_neck", ")", "\n", "\n", "loss_inputs", "=", "(", "out_neck", ",", "out_head", ",", "gt_kernels", ")", "\n", "\n", "losses", "=", "self", ".", "loss", "(", "*", "loss_inputs", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.seg_recognizer.SegRecognizer.simple_test": [[96, 125], ["seg_recognizer.SegRecognizer.extract_feat", "seg_recognizer.SegRecognizer.neck", "seg_recognizer.SegRecognizer.head", "seg_recognizer.SegRecognizer.label_convertor.tensor2str", "zip", "results.append", "img.size", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.tensor2str"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function without test time augmentation.\n\n        Args:\n            imgs (torch.Tensor): Image input tensor.\n            img_metas (list[dict]): List of image information.\n\n        Returns:\n            list[str]: Text label result of each image.\n        \"\"\"", "\n", "\n", "feat", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "out_neck", "=", "self", ".", "neck", "(", "feat", ")", "\n", "\n", "out_head", "=", "self", ".", "head", "(", "out_neck", ")", "\n", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "            ", "valid_ratio", "=", "1.0", "*", "img_meta", "[", "'resize_shape'", "]", "[", "1", "]", "/", "img", ".", "size", "(", "-", "1", ")", "\n", "img_meta", "[", "'valid_ratio'", "]", "=", "valid_ratio", "\n", "\n", "", "texts", ",", "scores", "=", "self", ".", "label_convertor", ".", "tensor2str", "(", "out_head", ",", "img_metas", ")", "\n", "\n", "# flatten batch results", "\n", "results", "=", "[", "]", "\n", "for", "text", ",", "score", "in", "zip", "(", "texts", ",", "scores", ")", ":", "\n", "            ", "results", ".", "append", "(", "dict", "(", "text", "=", "text", ",", "score", "=", "score", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.seg_recognizer.SegRecognizer.merge_aug_results": [[126, 136], ["dict", "sum", "max", "len"], "methods", ["None"], ["", "def", "merge_aug_results", "(", "self", ",", "aug_results", ")", ":", "\n", "        ", "out_text", ",", "out_score", "=", "''", ",", "-", "1", "\n", "for", "result", "in", "aug_results", ":", "\n", "            ", "text", "=", "result", "[", "0", "]", "[", "'text'", "]", "\n", "score", "=", "sum", "(", "result", "[", "0", "]", "[", "'score'", "]", ")", "/", "max", "(", "1", ",", "len", "(", "text", ")", ")", "\n", "if", "score", ">", "out_score", ":", "\n", "                ", "out_text", "=", "text", "\n", "out_score", "=", "score", "\n", "", "", "out_results", "=", "[", "dict", "(", "text", "=", "out_text", ",", "score", "=", "out_score", ")", "]", "\n", "return", "out_results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.seg_recognizer.SegRecognizer.aug_test": [[137, 151], ["zip", "seg_recognizer.SegRecognizer.merge_aug_results", "seg_recognizer.SegRecognizer.simple_test", "aug_results.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.merge_aug_results", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (list[tensor]): Tensor should have shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (list[list[dict]]): The metadata of images.\n        \"\"\"", "\n", "aug_results", "=", "[", "]", "\n", "for", "img", ",", "img_meta", "in", "zip", "(", "imgs", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "self", ".", "simple_test", "(", "img", ",", "img_meta", ",", "**", "kwargs", ")", "\n", "aug_results", ".", "append", "(", "result", ")", "\n", "\n", "", "return", "self", ".", "merge_aug_results", "(", "aug_results", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.__init__": [[16, 71], ["base.BaseRecognizer.__init__", "label_convertor.update", "mmocr.models.builder.build_convertor", "mmocr.models.builder.build_backbone", "decoder.update", "decoder.update", "decoder.update", "decoder.update", "mmocr.models.builder.build_decoder", "loss.update", "mmocr.models.builder.build_loss", "mmocr.models.builder.build_preprocessor", "mmocr.models.builder.build_encoder", "warnings.warn", "dict", "encode_decode_recognizer.EncodeDecodeRecognizer.label_convertor.num_classes"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_backbone", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_preprocessor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_encoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.num_classes"], ["def", "__init__", "(", "self", ",", "\n", "preprocessor", "=", "None", ",", "\n", "backbone", "=", "None", ",", "\n", "encoder", "=", "None", ",", "\n", "decoder", "=", "None", ",", "\n", "loss", "=", "None", ",", "\n", "label_convertor", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "pretrained", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "# Label convertor (str2tensor, tensor2str)", "\n", "assert", "label_convertor", "is", "not", "None", "\n", "label_convertor", ".", "update", "(", "max_seq_len", "=", "max_seq_len", ")", "\n", "self", ".", "label_convertor", "=", "build_convertor", "(", "label_convertor", ")", "\n", "\n", "# Preprocessor module, e.g., TPS", "\n", "self", ".", "preprocessor", "=", "None", "\n", "if", "preprocessor", "is", "not", "None", ":", "\n", "            ", "self", ".", "preprocessor", "=", "build_preprocessor", "(", "preprocessor", ")", "\n", "\n", "# Backbone", "\n", "", "assert", "backbone", "is", "not", "None", "\n", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "\n", "# Encoder module", "\n", "self", ".", "encoder", "=", "None", "\n", "if", "encoder", "is", "not", "None", ":", "\n", "            ", "self", ".", "encoder", "=", "build_encoder", "(", "encoder", ")", "\n", "\n", "# Decoder module", "\n", "", "assert", "decoder", "is", "not", "None", "\n", "decoder", ".", "update", "(", "num_classes", "=", "self", ".", "label_convertor", ".", "num_classes", "(", ")", ")", "\n", "decoder", ".", "update", "(", "start_idx", "=", "self", ".", "label_convertor", ".", "start_idx", ")", "\n", "decoder", ".", "update", "(", "padding_idx", "=", "self", ".", "label_convertor", ".", "padding_idx", ")", "\n", "decoder", ".", "update", "(", "max_seq_len", "=", "max_seq_len", ")", "\n", "self", ".", "decoder", "=", "build_decoder", "(", "decoder", ")", "\n", "\n", "# Loss", "\n", "assert", "loss", "is", "not", "None", "\n", "loss", ".", "update", "(", "ignore_index", "=", "self", ".", "label_convertor", ".", "padding_idx", ")", "\n", "self", ".", "loss", "=", "build_loss", "(", "loss", ")", "\n", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "\n", "if", "pretrained", "is", "not", "None", ":", "\n", "            ", "warnings", ".", "warn", "(", "'DeprecationWarning: pretrained is a deprecated \\\n                key, please consider using init_cfg'", ")", "\n", "self", ".", "init_cfg", "=", "dict", "(", "type", "=", "'Pretrained'", ",", "checkpoint", "=", "pretrained", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.extract_feat": [[72, 80], ["encode_decode_recognizer.EncodeDecodeRecognizer.backbone", "encode_decode_recognizer.EncodeDecodeRecognizer.preprocessor"], "methods", ["None"], ["", "", "def", "extract_feat", "(", "self", ",", "img", ")", ":", "\n", "        ", "\"\"\"Directly extract features from the backbone.\"\"\"", "\n", "if", "self", ".", "preprocessor", "is", "not", "None", ":", "\n", "            ", "img", "=", "self", ".", "preprocessor", "(", "img", ")", "\n", "\n", "", "x", "=", "self", ".", "backbone", "(", "img", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.forward_train": [[81, 120], ["encode_decode_recognizer.EncodeDecodeRecognizer.extract_feat", "encode_decode_recognizer.EncodeDecodeRecognizer.label_convertor.str2tensor", "encode_decode_recognizer.EncodeDecodeRecognizer.decoder", "encode_decode_recognizer.EncodeDecodeRecognizer.loss", "encode_decode_recognizer.EncodeDecodeRecognizer.encoder", "img.size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A list of image info dict where each dict\n                contains: 'img_shape', 'filename', and may also contain\n                'ori_shape', and 'img_norm_cfg'.\n                For details on the values of these keys see\n                :class:`mmdet.datasets.pipelines.Collect`.\n\n        Returns:\n            dict[str, tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "            ", "valid_ratio", "=", "1.0", "*", "img_meta", "[", "'resize_shape'", "]", "[", "1", "]", "/", "img", ".", "size", "(", "-", "1", ")", "\n", "img_meta", "[", "'valid_ratio'", "]", "=", "valid_ratio", "\n", "\n", "", "feat", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "gt_labels", "=", "[", "img_meta", "[", "'text'", "]", "for", "img_meta", "in", "img_metas", "]", "\n", "\n", "targets_dict", "=", "self", ".", "label_convertor", ".", "str2tensor", "(", "gt_labels", ")", "\n", "\n", "out_enc", "=", "None", "\n", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "out_enc", "=", "self", ".", "encoder", "(", "feat", ",", "img_metas", ")", "\n", "\n", "", "out_dec", "=", "self", ".", "decoder", "(", "\n", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ",", "train_mode", "=", "True", ")", "\n", "\n", "loss_inputs", "=", "(", "\n", "out_dec", ",", "\n", "targets_dict", ",", "\n", "img_metas", ",", "\n", ")", "\n", "losses", "=", "self", ".", "loss", "(", "*", "loss_inputs", ")", "\n", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.simple_test": [[121, 158], ["encode_decode_recognizer.EncodeDecodeRecognizer.extract_feat", "encode_decode_recognizer.EncodeDecodeRecognizer.decoder", "torch.onnx.is_in_onnx_export", "encode_decode_recognizer.EncodeDecodeRecognizer.label_convertor.tensor2idx", "encode_decode_recognizer.EncodeDecodeRecognizer.label_convertor.idx2str", "zip", "encode_decode_recognizer.EncodeDecodeRecognizer.encoder", "results.append", "img.size", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (torch.Tensor): Image input tensor.\n            img_metas (list[dict]): List of image information.\n\n        Returns:\n            list[str]: Text label result of each image.\n        \"\"\"", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "            ", "valid_ratio", "=", "1.0", "*", "img_meta", "[", "'resize_shape'", "]", "[", "1", "]", "/", "img", ".", "size", "(", "-", "1", ")", "\n", "img_meta", "[", "'valid_ratio'", "]", "=", "valid_ratio", "\n", "\n", "", "feat", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "\n", "out_enc", "=", "None", "\n", "if", "self", ".", "encoder", "is", "not", "None", ":", "\n", "            ", "out_enc", "=", "self", ".", "encoder", "(", "feat", ",", "img_metas", ")", "\n", "\n", "", "out_dec", "=", "self", ".", "decoder", "(", "\n", "feat", ",", "out_enc", ",", "None", ",", "img_metas", ",", "train_mode", "=", "False", ")", "\n", "\n", "# early return to avoid post processing", "\n", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "            ", "return", "out_dec", "\n", "\n", "", "label_indexes", ",", "label_scores", "=", "self", ".", "label_convertor", ".", "tensor2idx", "(", "\n", "out_dec", ",", "img_metas", ")", "\n", "label_strings", "=", "self", ".", "label_convertor", ".", "idx2str", "(", "label_indexes", ")", "\n", "\n", "# flatten batch results", "\n", "results", "=", "[", "]", "\n", "for", "string", ",", "score", "in", "zip", "(", "label_strings", ",", "label_scores", ")", ":", "\n", "            ", "results", ".", "append", "(", "dict", "(", "text", "=", "string", ",", "score", "=", "score", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.merge_aug_results": [[159, 169], ["dict", "sum", "max", "len"], "methods", ["None"], ["", "def", "merge_aug_results", "(", "self", ",", "aug_results", ")", ":", "\n", "        ", "out_text", ",", "out_score", "=", "''", ",", "-", "1", "\n", "for", "result", "in", "aug_results", ":", "\n", "            ", "text", "=", "result", "[", "0", "]", "[", "'text'", "]", "\n", "score", "=", "sum", "(", "result", "[", "0", "]", "[", "'score'", "]", ")", "/", "max", "(", "1", ",", "len", "(", "text", ")", ")", "\n", "if", "score", ">", "out_score", ":", "\n", "                ", "out_text", "=", "text", "\n", "out_score", "=", "score", "\n", "", "", "out_results", "=", "[", "dict", "(", "text", "=", "out_text", ",", "score", "=", "out_score", ")", "]", "\n", "return", "out_results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.aug_test": [[170, 184], ["zip", "encode_decode_recognizer.EncodeDecodeRecognizer.merge_aug_results", "encode_decode_recognizer.EncodeDecodeRecognizer.simple_test", "aug_results.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.merge_aug_results", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function as well as time augmentation.\n\n        Args:\n            imgs (list[tensor]): Tensor should have shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (list[list[dict]]): The metadata of images.\n        \"\"\"", "\n", "aug_results", "=", "[", "]", "\n", "for", "img", ",", "img_meta", "in", "zip", "(", "imgs", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "self", ".", "simple_test", "(", "img", ",", "img_meta", ",", "**", "kwargs", ")", "\n", "aug_results", ".", "append", "(", "result", ")", "\n", "\n", "", "return", "self", ".", "merge_aug_results", "(", "aug_results", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.base_preprocessor.BasePreprocessor.forward": [[11, 13], ["None"], "methods", ["None"], ["def", "forward", "(", "self", ",", "x", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.TPSPreprocessor.__init__": [[38, 59], ["base_preprocessor.BasePreprocessor.__init__", "isinstance", "isinstance", "isinstance", "isinstance", "tps_preprocessor.LocalizationNetwork", "tps_preprocessor.GridGenerator"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_fiducial", "=", "20", ",", "\n", "img_size", "=", "(", "32", ",", "100", ")", ",", "\n", "rectified_img_size", "=", "(", "32", ",", "100", ")", ",", "\n", "num_img_channel", "=", "1", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "num_fiducial", ",", "int", ")", "\n", "assert", "num_fiducial", ">", "0", "\n", "assert", "isinstance", "(", "img_size", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "rectified_img_size", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "num_img_channel", ",", "int", ")", "\n", "\n", "self", ".", "num_fiducial", "=", "num_fiducial", "\n", "self", ".", "img_size", "=", "img_size", "\n", "self", ".", "rectified_img_size", "=", "rectified_img_size", "\n", "self", ".", "num_img_channel", "=", "num_img_channel", "\n", "self", ".", "LocalizationNetwork", "=", "LocalizationNetwork", "(", "self", ".", "num_fiducial", ",", "\n", "self", ".", "num_img_channel", ")", "\n", "self", ".", "GridGenerator", "=", "GridGenerator", "(", "self", ".", "num_fiducial", ",", "\n", "self", ".", "rectified_img_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.TPSPreprocessor.forward": [[60, 86], ["tps_preprocessor.TPSPreprocessor.LocalizationNetwork", "tps_preprocessor.TPSPreprocessor.GridGenerator.build_P_prime", "tps_preprocessor.TPSPreprocessor.reshape", "torch.grid_sample", "torch.grid_sample", "torch.grid_sample", "tps_preprocessor.TPSPreprocessor.size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator.build_P_prime"], ["", "def", "forward", "(", "self", ",", "batch_img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batch_img (Tensor): Images to be rectified with size\n                :math:`(N, C, H, W)`.\n\n        Returns:\n            Tensor: Rectified image with size :math:`(N, C, H_r, W_r)`.\n        \"\"\"", "\n", "batch_C_prime", "=", "self", ".", "LocalizationNetwork", "(", "\n", "batch_img", ")", "# batch_size x K x 2", "\n", "build_P_prime", "=", "self", ".", "GridGenerator", ".", "build_P_prime", "(", "\n", "batch_C_prime", ",", "batch_img", ".", "device", "\n", ")", "# batch_size x n (= rectified_img_width x rectified_img_height) x 2", "\n", "build_P_prime_reshape", "=", "build_P_prime", ".", "reshape", "(", "[", "\n", "build_P_prime", ".", "size", "(", "0", ")", ",", "self", ".", "rectified_img_size", "[", "0", "]", ",", "\n", "self", ".", "rectified_img_size", "[", "1", "]", ",", "2", "\n", "]", ")", "\n", "\n", "batch_rectified_img", "=", "F", ".", "grid_sample", "(", "\n", "batch_img", ",", "\n", "build_P_prime_reshape", ",", "\n", "padding_mode", "=", "'border'", ",", "\n", "align_corners", "=", "True", ")", "\n", "\n", "return", "batch_rectified_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.LocalizationNetwork.__init__": [[97, 140], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "tps_preprocessor.LocalizationNetwork.localization_fc2.weight.data.fill_", "numpy.linspace", "numpy.linspace", "numpy.linspace", "numpy.stack", "numpy.stack", "numpy.concatenate", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.from_numpy().float().view", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "int", "int", "int", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "num_fiducial", ",", "num_img_channel", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_fiducial", "=", "num_fiducial", "\n", "self", ".", "num_img_channel", "=", "num_img_channel", "\n", "self", ".", "conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "self", ".", "num_img_channel", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "64", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ",", "# batch_size x 64 x img_height/2 x img_width/2", "\n", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "128", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ",", "# batch_size x 128 x img_h/4 x img_w/4", "\n", "nn", ".", "Conv2d", "(", "128", ",", "256", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "256", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ",", "# batch_size x 256 x img_h/8 x img_w/8", "\n", "nn", ".", "Conv2d", "(", "256", ",", "512", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "512", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "# batch_size x 512", "\n", ")", "\n", "\n", "self", ".", "localization_fc1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "512", ",", "256", ")", ",", "nn", ".", "ReLU", "(", "True", ")", ")", "\n", "self", ".", "localization_fc2", "=", "nn", ".", "Linear", "(", "256", ",", "self", ".", "num_fiducial", "*", "2", ")", "\n", "\n", "# Init fc2 in LocalizationNetwork", "\n", "self", ".", "localization_fc2", ".", "weight", ".", "data", ".", "fill_", "(", "0", ")", "\n", "ctrl_pts_x", "=", "np", ".", "linspace", "(", "-", "1.0", ",", "1.0", ",", "int", "(", "num_fiducial", "/", "2", ")", ")", "\n", "ctrl_pts_y_top", "=", "np", ".", "linspace", "(", "0.0", ",", "-", "1.0", ",", "num", "=", "int", "(", "num_fiducial", "/", "2", ")", ")", "\n", "ctrl_pts_y_bottom", "=", "np", ".", "linspace", "(", "1.0", ",", "0.0", ",", "num", "=", "int", "(", "num_fiducial", "/", "2", ")", ")", "\n", "ctrl_pts_top", "=", "np", ".", "stack", "(", "[", "ctrl_pts_x", ",", "ctrl_pts_y_top", "]", ",", "axis", "=", "1", ")", "\n", "ctrl_pts_bottom", "=", "np", ".", "stack", "(", "[", "ctrl_pts_x", ",", "ctrl_pts_y_bottom", "]", ",", "axis", "=", "1", ")", "\n", "initial_bias", "=", "np", ".", "concatenate", "(", "[", "ctrl_pts_top", ",", "ctrl_pts_bottom", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "localization_fc2", ".", "bias", ".", "data", "=", "torch", ".", "from_numpy", "(", "\n", "initial_bias", ")", ".", "float", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.LocalizationNetwork.forward": [[141, 157], ["batch_img.size", "tps_preprocessor.LocalizationNetwork.conv().view", "tps_preprocessor.LocalizationNetwork.localization_fc2().view", "tps_preprocessor.LocalizationNetwork.conv", "tps_preprocessor.LocalizationNetwork.localization_fc2", "tps_preprocessor.LocalizationNetwork.localization_fc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batch_img", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            batch_img (Tensor): Batch input image of shape\n                :math:`(N, C, H, W)`.\n\n        Returns:\n            Tensor: Predicted coordinates of fiducial points for input batch.\n            The shape is :math:`(N, F, 2)` where :math:`F` is ``num_fiducial``.\n        \"\"\"", "\n", "batch_size", "=", "batch_img", ".", "size", "(", "0", ")", "\n", "features", "=", "self", ".", "conv", "(", "batch_img", ")", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "batch_C_prime", "=", "self", ".", "localization_fc2", "(", "\n", "self", ".", "localization_fc1", "(", "features", ")", ")", ".", "view", "(", "batch_size", ",", "\n", "self", ".", "num_fiducial", ",", "2", ")", "\n", "return", "batch_C_prime", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator.__init__": [[168, 189], ["torch.Module.__init__", "tps_preprocessor.GridGenerator._build_C", "tps_preprocessor.GridGenerator._build_P", "tps_preprocessor.GridGenerator.register_buffer", "tps_preprocessor.GridGenerator.register_buffer", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tps_preprocessor.GridGenerator._build_inv_delta_C", "tps_preprocessor.GridGenerator._build_P_hat"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_C", "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_P", "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_inv_delta_C", "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_P_hat"], ["def", "__init__", "(", "self", ",", "num_fiducial", ",", "rectified_img_size", ")", ":", "\n", "        ", "\"\"\"Generate P_hat and inv_delta_C for later.\"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "1e-6", "\n", "self", ".", "rectified_img_height", "=", "rectified_img_size", "[", "0", "]", "\n", "self", ".", "rectified_img_width", "=", "rectified_img_size", "[", "1", "]", "\n", "self", ".", "num_fiducial", "=", "num_fiducial", "\n", "self", ".", "C", "=", "self", ".", "_build_C", "(", "self", ".", "num_fiducial", ")", "# num_fiducial x 2", "\n", "self", ".", "P", "=", "self", ".", "_build_P", "(", "self", ".", "rectified_img_width", ",", "\n", "self", ".", "rectified_img_height", ")", "\n", "# for multi-gpu, you need register buffer", "\n", "self", ".", "register_buffer", "(", "\n", "'inv_delta_C'", ",", "\n", "torch", ".", "tensor", "(", "self", ".", "_build_inv_delta_C", "(", "\n", "self", ".", "num_fiducial", ",", "\n", "self", ".", "C", ")", ")", ".", "float", "(", ")", ")", "# num_fiducial+3 x num_fiducial+3", "\n", "self", ".", "register_buffer", "(", "'P_hat'", ",", "\n", "torch", ".", "tensor", "(", "\n", "self", ".", "_build_P_hat", "(", "\n", "self", ".", "num_fiducial", ",", "self", ".", "C", ",", "\n", "self", ".", "P", ")", ")", ".", "float", "(", ")", ")", "# n x num_fiducial+3", "\n", "# for fine-tuning with different image width,", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_C": [[199, 208], ["numpy.linspace", "numpy.ones", "numpy.stack", "numpy.stack", "numpy.concatenate", "int", "numpy.ones", "int", "int"], "methods", ["None"], ["", "def", "_build_C", "(", "self", ",", "num_fiducial", ")", ":", "\n", "        ", "\"\"\"Return coordinates of fiducial points in rectified_img; C.\"\"\"", "\n", "ctrl_pts_x", "=", "np", ".", "linspace", "(", "-", "1.0", ",", "1.0", ",", "int", "(", "num_fiducial", "/", "2", ")", ")", "\n", "ctrl_pts_y_top", "=", "-", "1", "*", "np", ".", "ones", "(", "int", "(", "num_fiducial", "/", "2", ")", ")", "\n", "ctrl_pts_y_bottom", "=", "np", ".", "ones", "(", "int", "(", "num_fiducial", "/", "2", ")", ")", "\n", "ctrl_pts_top", "=", "np", ".", "stack", "(", "[", "ctrl_pts_x", ",", "ctrl_pts_y_top", "]", ",", "axis", "=", "1", ")", "\n", "ctrl_pts_bottom", "=", "np", ".", "stack", "(", "[", "ctrl_pts_x", ",", "ctrl_pts_y_bottom", "]", ",", "axis", "=", "1", ")", "\n", "C", "=", "np", ".", "concatenate", "(", "[", "ctrl_pts_top", ",", "ctrl_pts_bottom", "]", ",", "axis", "=", "0", ")", "\n", "return", "C", "# num_fiducial x 2", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_inv_delta_C": [[209, 233], ["numpy.zeros", "range", "numpy.fill_diagonal", "numpy.concatenate", "numpy.linalg.inv", "range", "numpy.log", "numpy.linalg.norm", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.ones", "numpy.zeros", "numpy.transpose", "numpy.zeros", "numpy.ones"], "methods", ["None"], ["", "def", "_build_inv_delta_C", "(", "self", ",", "num_fiducial", ",", "C", ")", ":", "\n", "        ", "\"\"\"Return inv_delta_C which is needed to calculate T.\"\"\"", "\n", "hat_C", "=", "np", ".", "zeros", "(", "(", "num_fiducial", ",", "num_fiducial", ")", ",", "dtype", "=", "float", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "num_fiducial", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", ",", "num_fiducial", ")", ":", "\n", "                ", "r", "=", "np", ".", "linalg", ".", "norm", "(", "C", "[", "i", "]", "-", "C", "[", "j", "]", ")", "\n", "hat_C", "[", "i", ",", "j", "]", "=", "r", "\n", "hat_C", "[", "j", ",", "i", "]", "=", "r", "\n", "", "", "np", ".", "fill_diagonal", "(", "hat_C", ",", "1", ")", "\n", "hat_C", "=", "(", "hat_C", "**", "2", ")", "*", "np", ".", "log", "(", "hat_C", ")", "\n", "# print(C.shape, hat_C.shape)", "\n", "delta_C", "=", "np", ".", "concatenate", "(", "# num_fiducial+3 x num_fiducial+3", "\n", "[", "\n", "np", ".", "concatenate", "(", "[", "np", ".", "ones", "(", "(", "num_fiducial", ",", "1", ")", ")", ",", "C", ",", "hat_C", "]", ",", "\n", "axis", "=", "1", ")", ",", "# num_fiducial x num_fiducial+3", "\n", "np", ".", "concatenate", "(", "[", "np", ".", "zeros", "(", "\n", "(", "2", ",", "3", ")", ")", ",", "np", ".", "transpose", "(", "C", ")", "]", ",", "axis", "=", "1", ")", ",", "# 2 x num_fiducial+3", "\n", "np", ".", "concatenate", "(", "[", "np", ".", "zeros", "(", "\n", "(", "1", ",", "3", ")", ")", ",", "np", ".", "ones", "(", "(", "1", ",", "num_fiducial", ")", ")", "]", ",", "\n", "axis", "=", "1", ")", "# 1 x num_fiducial+3", "\n", "]", ",", "\n", "axis", "=", "0", ")", "\n", "inv_delta_C", "=", "np", ".", "linalg", ".", "inv", "(", "delta_C", ")", "\n", "return", "inv_delta_C", "# num_fiducial+3 x num_fiducial+3", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_P": [[234, 246], ["numpy.stack", "numpy.stack.reshape", "numpy.meshgrid", "numpy.arange", "numpy.arange"], "methods", ["None"], ["", "def", "_build_P", "(", "self", ",", "rectified_img_width", ",", "rectified_img_height", ")", ":", "\n", "        ", "rectified_img_grid_x", "=", "(", "\n", "np", ".", "arange", "(", "-", "rectified_img_width", ",", "rectified_img_width", ",", "2", ")", "+", "\n", "1.0", ")", "/", "rectified_img_width", "# self.rectified_img_width", "\n", "rectified_img_grid_y", "=", "(", "\n", "np", ".", "arange", "(", "-", "rectified_img_height", ",", "rectified_img_height", ",", "2", ")", "+", "\n", "1.0", ")", "/", "rectified_img_height", "# self.rectified_img_height", "\n", "P", "=", "np", ".", "stack", "(", "# self.rectified_img_w x self.rectified_img_h x 2", "\n", "np", ".", "meshgrid", "(", "rectified_img_grid_x", ",", "rectified_img_grid_y", ")", ",", "\n", "axis", "=", "2", ")", "\n", "return", "P", ".", "reshape", "(", "[", "\n", "-", "1", ",", "2", "\n", "]", ")", "# n (= self.rectified_img_width x self.rectified_img_height) x 2", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator._build_P_hat": [[248, 262], ["numpy.tile", "numpy.expand_dims", "numpy.linalg.norm", "numpy.multiply", "numpy.concatenate", "numpy.expand_dims", "numpy.square", "numpy.log", "numpy.ones"], "methods", ["None"], ["", "def", "_build_P_hat", "(", "self", ",", "num_fiducial", ",", "C", ",", "P", ")", ":", "\n", "        ", "n", "=", "P", ".", "shape", "[", "\n", "0", "]", "# n (= self.rectified_img_width x self.rectified_img_height)", "\n", "P_tile", "=", "np", ".", "tile", "(", "np", ".", "expand_dims", "(", "P", ",", "axis", "=", "1", ")", ",", "\n", "(", "1", ",", "num_fiducial", ",", "\n", "1", ")", ")", "# n x 2 -> n x 1 x 2 -> n x num_fiducial x 2", "\n", "C_tile", "=", "np", ".", "expand_dims", "(", "C", ",", "axis", "=", "0", ")", "# 1 x num_fiducial x 2", "\n", "P_diff", "=", "P_tile", "-", "C_tile", "# n x num_fiducial x 2", "\n", "rbf_norm", "=", "np", ".", "linalg", ".", "norm", "(", "\n", "P_diff", ",", "ord", "=", "2", ",", "axis", "=", "2", ",", "keepdims", "=", "False", ")", "# n x num_fiducial", "\n", "rbf", "=", "np", ".", "multiply", "(", "np", ".", "square", "(", "rbf_norm", ")", ",", "\n", "np", ".", "log", "(", "rbf_norm", "+", "self", ".", "eps", ")", ")", "# n x num_fiducial", "\n", "P_hat", "=", "np", ".", "concatenate", "(", "[", "np", ".", "ones", "(", "(", "n", ",", "1", ")", ")", ",", "P", ",", "rbf", "]", ",", "axis", "=", "1", ")", "\n", "return", "P_hat", "# n x num_fiducial+3", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.preprocessor.tps_preprocessor.GridGenerator.build_P_prime": [[263, 276], ["batch_C_prime.size", "tps_preprocessor.GridGenerator.inv_delta_C.repeat", "tps_preprocessor.GridGenerator.P_hat.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float().to", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros().float", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "build_P_prime", "(", "self", ",", "batch_C_prime", ",", "device", "=", "'cuda'", ")", ":", "\n", "        ", "\"\"\"Generate Grid from batch_C_prime [batch_size x num_fiducial x 2]\"\"\"", "\n", "batch_size", "=", "batch_C_prime", ".", "size", "(", "0", ")", "\n", "batch_inv_delta_C", "=", "self", ".", "inv_delta_C", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", "\n", "batch_P_hat", "=", "self", ".", "P_hat", ".", "repeat", "(", "batch_size", ",", "1", ",", "1", ")", "\n", "batch_C_prime_with_zeros", "=", "torch", ".", "cat", "(", "\n", "(", "batch_C_prime", ",", "torch", ".", "zeros", "(", "batch_size", ",", "3", ",", "2", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", ")", ",", "\n", "dim", "=", "1", ")", "# batch_size x num_fiducial+3 x 2", "\n", "batch_T", "=", "torch", ".", "bmm", "(", "\n", "batch_inv_delta_C", ",", "\n", "batch_C_prime_with_zeros", ")", "# batch_size x num_fiducial+3 x 2", "\n", "batch_P_prime", "=", "torch", ".", "bmm", "(", "batch_P_hat", ",", "batch_T", ")", "# batch_size x n x 2", "\n", "return", "batch_P_prime", "# batch_size x n x 2", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.__init__": [[27, 82], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.ReLU", "torch.BatchNorm2d", "conv_layer.conv1x1", "conv_layer.conv3x3", "conv_layer.conv3x3", "conv_layer.conv3x3", "isinstance", "conv_layer.BasicBlock.make_block_plugins", "conv_layer.BasicBlock.make_block_plugins", "conv_layer.BasicBlock.make_block_plugins", "conv_layer.BasicBlock.make_block_plugins"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv1x1", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv3x3", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv3x3", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv3x3", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.make_block_plugins", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.make_block_plugins", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.make_block_plugins", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.make_block_plugins"], ["def", "__init__", "(", "self", ",", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "stride", "=", "1", ",", "\n", "downsample", "=", "None", ",", "\n", "use_conv1x1", "=", "False", ",", "\n", "plugins", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "use_conv1x1", ":", "\n", "            ", "self", ".", "conv1", "=", "conv1x1", "(", "inplanes", ",", "planes", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ",", "stride", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ")", "\n", "\n", "", "self", ".", "with_plugins", "=", "False", "\n", "if", "plugins", ":", "\n", "            ", "if", "isinstance", "(", "plugins", ",", "dict", ")", ":", "\n", "                ", "plugins", "=", "[", "plugins", "]", "\n", "", "self", ".", "with_plugins", "=", "True", "\n", "# collect plugins for conv1/conv2/", "\n", "self", ".", "before_conv1_plugin", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'before_conv1'", "\n", "]", "\n", "self", ".", "after_conv1_plugin", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'after_conv1'", "\n", "]", "\n", "self", ".", "after_conv2_plugin", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'after_conv2'", "\n", "]", "\n", "self", ".", "after_shortcut_plugin", "=", "[", "\n", "plugin", "[", "'cfg'", "]", "for", "plugin", "in", "plugins", "\n", "if", "plugin", "[", "'position'", "]", "==", "'after_shortcut'", "\n", "]", "\n", "\n", "", "self", ".", "planes", "=", "planes", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "            ", "self", ".", "before_conv1_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "inplanes", ",", "self", ".", "before_conv1_plugin", ")", "\n", "self", ".", "after_conv1_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "planes", ",", "self", ".", "after_conv1_plugin", ")", "\n", "self", ".", "after_conv2_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "planes", ",", "self", ".", "after_conv2_plugin", ")", "\n", "self", ".", "after_shortcut_plugin_names", "=", "self", ".", "make_block_plugins", "(", "\n", "planes", ",", "self", ".", "after_shortcut_plugin", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.make_block_plugins": [[83, 106], ["isinstance", "plugin.copy.copy.copy", "mmcv.cnn.build_plugin_layer", "conv_layer.BasicBlock.add_module", "plugin_names.append", "hasattr", "plugin.copy.copy.pop"], "methods", ["None"], ["", "", "def", "make_block_plugins", "(", "self", ",", "in_channels", ",", "plugins", ")", ":", "\n", "        ", "\"\"\"make plugins for block.\n\n        Args:\n            in_channels (int): Input channels of plugin.\n            plugins (list[dict]): List of plugins cfg to build.\n\n        Returns:\n            list[str]: List of the names of plugin.\n        \"\"\"", "\n", "assert", "isinstance", "(", "plugins", ",", "list", ")", "\n", "plugin_names", "=", "[", "]", "\n", "for", "plugin", "in", "plugins", ":", "\n", "            ", "plugin", "=", "plugin", ".", "copy", "(", ")", "\n", "name", ",", "layer", "=", "build_plugin_layer", "(", "\n", "plugin", ",", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "in_channels", ",", "\n", "postfix", "=", "plugin", ".", "pop", "(", "'postfix'", ",", "''", ")", ")", "\n", "assert", "not", "hasattr", "(", "self", ",", "name", ")", ",", "f'duplicate plugin {name}'", "\n", "self", ".", "add_module", "(", "name", ",", "layer", ")", "\n", "plugin_names", ".", "append", "(", "name", ")", "\n", "", "return", "plugin_names", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.forward_plugin": [[107, 112], ["getattr"], "methods", ["None"], ["", "def", "forward_plugin", "(", "self", ",", "x", ",", "plugin_names", ")", ":", "\n", "        ", "out", "=", "x", "\n", "for", "name", "in", "plugin_names", ":", "\n", "            ", "out", "=", "getattr", "(", "self", ",", "name", ")", "(", "x", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.BasicBlock.forward": [[113, 141], ["conv_layer.BasicBlock.conv1", "conv_layer.BasicBlock.bn1", "conv_layer.BasicBlock.relu", "conv_layer.BasicBlock.conv2", "conv_layer.BasicBlock.bn2", "conv_layer.BasicBlock.relu", "conv_layer.BasicBlock.forward_plugin", "conv_layer.BasicBlock.forward_plugin", "conv_layer.BasicBlock.forward_plugin", "conv_layer.BasicBlock.downsample", "conv_layer.BasicBlock.forward_plugin"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "with_plugins", ":", "\n", "            ", "x", "=", "self", ".", "forward_plugin", "(", "x", ",", "self", ".", "before_conv1_plugin_names", ")", "\n", "", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "            ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv1_plugin_names", ")", "\n", "\n", "", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "            ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_conv2_plugin_names", ")", "\n", "\n", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "if", "self", ".", "with_plugins", ":", "\n", "            ", "out", "=", "self", ".", "forward_plugin", "(", "out", ",", "self", ".", "after_shortcut_plugin_names", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.Bottleneck.__init__": [[146, 164], ["torch.Module.__init__", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "3", ",", "stride", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "\n", "planes", ",", "planes", "*", "self", ".", "expansion", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "if", "downsample", ":", "\n", "            ", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "inplanes", ",", "planes", "*", "self", ".", "expansion", ",", "1", ",", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "downsample", "=", "nn", ".", "Sequential", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.Bottleneck.forward": [[165, 183], ["conv_layer.Bottleneck.downsample", "conv_layer.Bottleneck.conv1", "conv_layer.Bottleneck.bn1", "conv_layer.Bottleneck.relu", "conv_layer.Bottleneck.conv2", "conv_layer.Bottleneck.bn2", "conv_layer.Bottleneck.relu", "conv_layer.Bottleneck.conv3", "conv_layer.Bottleneck.bn3", "conv_layer.Bottleneck.relu"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv3x3": [[6, 15], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding.\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "\n", "out_planes", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv1x1": [[17, 21], ["torch.Conv2d"], "function", ["None"], ["", "def", "conv1x1", "(", "in_planes", ",", "out_planes", ")", ":", "\n", "    ", "\"\"\"1x1 convolution with padding.\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.dot_product_attention_layer.DotProductAttentionLayer.__init__": [[9, 13], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim_model", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "scale", "=", "dim_model", "**", "-", "0.5", "if", "dim_model", "is", "not", "None", "else", "1.", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.dot_product_attention_layer.DotProductAttentionLayer.forward": [[14, 29], ["mask.view.view.size", "torch.softmax", "torch.softmax", "torch.softmax", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "glimpse.permute().contiguous.permute().contiguous.permute().contiguous", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "mask.view.view.view", "logits.masked_fill.masked_fill.masked_fill", "value.transpose", "query.permute", "float", "glimpse.permute().contiguous.permute().contiguous.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "query", ",", "key", ",", "value", ",", "mask", "=", "None", ")", ":", "\n", "        ", "n", ",", "seq_len", "=", "mask", ".", "size", "(", ")", "\n", "logits", "=", "torch", ".", "matmul", "(", "query", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ",", "key", ")", "*", "self", ".", "scale", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "mask", "=", "mask", ".", "view", "(", "n", ",", "1", ",", "seq_len", ")", "\n", "logits", "=", "logits", ".", "masked_fill", "(", "mask", ",", "float", "(", "'-inf'", ")", ")", "\n", "\n", "", "weights", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "2", ")", "\n", "\n", "glimpse", "=", "torch", ".", "matmul", "(", "weights", ",", "value", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "\n", "glimpse", "=", "glimpse", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "return", "glimpse", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.lstm_layer.BidirectionalLSTM.__init__": [[7, 12], ["torch.Module.__init__", "torch.LSTM", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nIn", ",", "nHidden", ",", "nOut", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "rnn", "=", "nn", ".", "LSTM", "(", "nIn", ",", "nHidden", ",", "bidirectional", "=", "True", ")", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "nHidden", "*", "2", ",", "nOut", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.lstm_layer.BidirectionalLSTM.forward": [[13, 22], ["lstm_layer.BidirectionalLSTM.rnn", "recurrent.size", "recurrent.view", "lstm_layer.BidirectionalLSTM.embedding", "output.view.view.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "recurrent", ",", "_", "=", "self", ".", "rnn", "(", "input", ")", "\n", "T", ",", "b", ",", "h", "=", "recurrent", ".", "size", "(", ")", "\n", "t_rec", "=", "recurrent", ".", "view", "(", "T", "*", "b", ",", "h", ")", "\n", "\n", "output", "=", "self", ".", "embedding", "(", "t_rec", ")", "# [T * b, nOut]", "\n", "output", "=", "output", ".", "view", "(", "T", ",", "b", ",", "-", "1", ")", "\n", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.position_aware_layer.PositionAwareLayer.__init__": [[7, 24], ["torch.Module.__init__", "torch.LSTM", "torch.Sequential", "torch.Conv2d", "torch.ReLU", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim_model", ",", "rnn_layers", "=", "2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "dim_model", "=", "dim_model", "\n", "\n", "self", ".", "rnn", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "dim_model", ",", "\n", "hidden_size", "=", "dim_model", ",", "\n", "num_layers", "=", "rnn_layers", ",", "\n", "batch_first", "=", "True", ")", "\n", "\n", "self", ".", "mixer", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "dim_model", ",", "dim_model", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "\n", "dim_model", ",", "dim_model", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.position_aware_layer.PositionAwareLayer.forward": [[25, 37], ["img_feature.size", "img_feature.permute().contiguous", "rnn_input.view.view.view", "position_aware_layer.PositionAwareLayer.rnn", "rnn_output.permute().contiguous.permute().contiguous.view", "rnn_output.permute().contiguous.permute().contiguous.permute().contiguous", "position_aware_layer.PositionAwareLayer.mixer", "img_feature.permute", "rnn_output.permute().contiguous.permute().contiguous.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img_feature", ")", ":", "\n", "        ", "n", ",", "c", ",", "h", ",", "w", "=", "img_feature", ".", "size", "(", ")", "\n", "\n", "rnn_input", "=", "img_feature", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "rnn_input", "=", "rnn_input", ".", "view", "(", "n", "*", "h", ",", "w", ",", "c", ")", "\n", "rnn_output", ",", "_", "=", "self", ".", "rnn", "(", "rnn_input", ")", "\n", "rnn_output", "=", "rnn_output", ".", "view", "(", "n", ",", "h", ",", "w", ",", "c", ")", "\n", "rnn_output", "=", "rnn_output", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "\n", "out", "=", "self", ".", "mixer", "(", "rnn_output", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.robust_scanner_fusion_layer.RobustScannerFusionLayer.__init__": [[9, 17], ["mmcv.runner.BaseModule.__init__", "torch.Linear", "torch.Linear", "torch.GLU", "torch.GLU"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim_model", ",", "dim", "=", "-", "1", ",", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "dim_model", "=", "dim_model", "\n", "self", ".", "dim", "=", "dim", "\n", "\n", "self", ".", "linear_layer", "=", "nn", ".", "Linear", "(", "dim_model", "*", "2", ",", "dim_model", "*", "2", ")", "\n", "self", ".", "glu_layer", "=", "nn", ".", "GLU", "(", "dim", "=", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.robust_scanner_fusion_layer.RobustScannerFusionLayer.forward": [[18, 25], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "robust_scanner_fusion_layer.RobustScannerFusionLayer.linear_layer", "robust_scanner_fusion_layer.RobustScannerFusionLayer.glu_layer", "x0.size", "x1.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x0", ",", "x1", ")", ":", "\n", "        ", "assert", "x0", ".", "size", "(", ")", "==", "x1", ".", "size", "(", ")", "\n", "fusion_input", "=", "torch", ".", "cat", "(", "[", "x0", ",", "x1", "]", ",", "self", ".", "dim", ")", "\n", "output", "=", "self", ".", "linear_layer", "(", "fusion_input", ")", "\n", "output", "=", "self", ".", "glu_layer", "(", "output", ")", "\n", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.SatrnEncoderLayer.__init__": [[14, 30], ["mmcv.runner.BaseModule.__init__", "torch.LayerNorm", "torch.LayerNorm", "mmocr.models.common.MultiHeadAttention", "torch.LayerNorm", "torch.LayerNorm", "satrn_layers.LocalityAwareFeedforward"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "d_model", "=", "512", ",", "\n", "d_inner", "=", "512", ",", "\n", "n_head", "=", "8", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "dropout", "=", "0.1", ",", "\n", "qkv_bias", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "attn", "=", "MultiHeadAttention", "(", "\n", "n_head", ",", "d_model", ",", "d_k", ",", "d_v", ",", "qkv_bias", "=", "qkv_bias", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "feed_forward", "=", "LocalityAwareFeedforward", "(", "\n", "d_model", ",", "d_inner", ",", "dropout", "=", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.SatrnEncoderLayer.forward": [[31, 43], ["x.view().transpose.view().transpose.size", "satrn_layers.SatrnEncoderLayer.norm1", "satrn_layers.SatrnEncoderLayer.norm2", "x.view().transpose.view().transpose.transpose().contiguous().view", "satrn_layers.SatrnEncoderLayer.feed_forward", "x.view().transpose.view().transpose.view().transpose", "satrn_layers.SatrnEncoderLayer.attn", "x.view().transpose.view().transpose.transpose().contiguous", "x.view().transpose.view().transpose.view", "x.view().transpose.view().transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2"], ["", "def", "forward", "(", "self", ",", "x", ",", "h", ",", "w", ",", "mask", "=", "None", ")", ":", "\n", "        ", "n", ",", "hw", ",", "c", "=", "x", ".", "size", "(", ")", "\n", "residual", "=", "x", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "residual", "+", "self", ".", "attn", "(", "x", ",", "x", ",", "x", ",", "mask", ")", "\n", "residual", "=", "x", "\n", "x", "=", "self", ".", "norm2", "(", "x", ")", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "n", ",", "c", ",", "h", ",", "w", ")", "\n", "x", "=", "self", ".", "feed_forward", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "n", ",", "c", ",", "hw", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "x", "=", "residual", "+", "x", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.LocalityAwareFeedforward.__init__": [[51, 87], ["mmcv.runner.BaseModule.__init__", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "d_in", ",", "\n", "d_hid", ",", "\n", "dropout", "=", "0.1", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Constant'", ",", "layer", "=", "'BatchNorm2d'", ",", "val", "=", "1", ",", "bias", "=", "0", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "d_in", ",", "\n", "d_hid", ",", "\n", "kernel_size", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "\n", "self", ".", "depthwise_conv", "=", "ConvModule", "(", "\n", "d_hid", ",", "\n", "d_hid", ",", "\n", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "d_hid", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "\n", "self", ".", "conv2", "=", "ConvModule", "(", "\n", "d_hid", ",", "\n", "d_in", ",", "\n", "kernel_size", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "bias", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.LocalityAwareFeedforward.forward": [[88, 94], ["satrn_layers.LocalityAwareFeedforward.conv1", "satrn_layers.LocalityAwareFeedforward.depthwise_conv", "satrn_layers.LocalityAwareFeedforward.conv2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "depthwise_conv", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.Adaptive2DPositionalEncoding.__init__": [[108, 131], ["mmcv.runner.BaseModule.__init__", "satrn_layers.Adaptive2DPositionalEncoding._get_sinusoid_encoding_table", "h_position_encoder.view.view.transpose", "h_position_encoder.view.view.view", "satrn_layers.Adaptive2DPositionalEncoding._get_sinusoid_encoding_table", "w_position_encoder.view.view.transpose", "w_position_encoder.view.view.view", "satrn_layers.Adaptive2DPositionalEncoding.register_buffer", "satrn_layers.Adaptive2DPositionalEncoding.register_buffer", "satrn_layers.Adaptive2DPositionalEncoding.scale_factor_generate", "satrn_layers.Adaptive2DPositionalEncoding.scale_factor_generate", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Dropout", "torch.Dropout", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionalEncoding._get_sinusoid_encoding_table", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionalEncoding._get_sinusoid_encoding_table", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.Adaptive2DPositionalEncoding.scale_factor_generate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.Adaptive2DPositionalEncoding.scale_factor_generate"], ["def", "__init__", "(", "self", ",", "\n", "d_hid", "=", "512", ",", "\n", "n_height", "=", "100", ",", "\n", "n_width", "=", "100", ",", "\n", "dropout", "=", "0.1", ",", "\n", "init_cfg", "=", "[", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "h_position_encoder", "=", "self", ".", "_get_sinusoid_encoding_table", "(", "n_height", ",", "d_hid", ")", "\n", "h_position_encoder", "=", "h_position_encoder", ".", "transpose", "(", "0", ",", "1", ")", "\n", "h_position_encoder", "=", "h_position_encoder", ".", "view", "(", "1", ",", "d_hid", ",", "n_height", ",", "1", ")", "\n", "\n", "w_position_encoder", "=", "self", ".", "_get_sinusoid_encoding_table", "(", "n_width", ",", "d_hid", ")", "\n", "w_position_encoder", "=", "w_position_encoder", ".", "transpose", "(", "0", ",", "1", ")", "\n", "w_position_encoder", "=", "w_position_encoder", ".", "view", "(", "1", ",", "d_hid", ",", "1", ",", "n_width", ")", "\n", "\n", "self", ".", "register_buffer", "(", "'h_position_encoder'", ",", "h_position_encoder", ")", "\n", "self", ".", "register_buffer", "(", "'w_position_encoder'", ",", "w_position_encoder", ")", "\n", "\n", "self", ".", "h_scale", "=", "self", ".", "scale_factor_generate", "(", "d_hid", ")", "\n", "self", ".", "w_scale", "=", "self", ".", "scale_factor_generate", "(", "d_hid", ")", "\n", "self", ".", "pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.Adaptive2DPositionalEncoding._get_sinusoid_encoding_table": [[132, 145], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "denominator.view.view.view", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "numpy.power", "range", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "_get_sinusoid_encoding_table", "(", "self", ",", "n_position", ",", "d_hid", ")", ":", "\n", "        ", "\"\"\"Sinusoid position encoding table.\"\"\"", "\n", "denominator", "=", "torch", ".", "Tensor", "(", "[", "\n", "1.0", "/", "np", ".", "power", "(", "10000", ",", "2", "*", "(", "hid_j", "//", "2", ")", "/", "d_hid", ")", "\n", "for", "hid_j", "in", "range", "(", "d_hid", ")", "\n", "]", ")", "\n", "denominator", "=", "denominator", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "pos_tensor", "=", "torch", ".", "arange", "(", "n_position", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "float", "(", ")", "\n", "sinusoid_table", "=", "pos_tensor", "*", "denominator", "\n", "sinusoid_table", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "sinusoid_table", "[", ":", ",", "0", ":", ":", "2", "]", ")", "\n", "sinusoid_table", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "sinusoid_table", "[", ":", ",", "1", ":", ":", "2", "]", ")", "\n", "\n", "return", "sinusoid_table", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.Adaptive2DPositionalEncoding.scale_factor_generate": [[146, 152], ["torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["None"], ["", "def", "scale_factor_generate", "(", "self", ",", "d_hid", ")", ":", "\n", "        ", "scale_factor", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "d_hid", ",", "d_hid", ",", "kernel_size", "=", "1", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "d_hid", ",", "d_hid", ",", "kernel_size", "=", "1", ")", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "\n", "return", "scale_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.satrn_layers.Adaptive2DPositionalEncoding.forward": [[153, 168], ["x.size", "satrn_layers.Adaptive2DPositionalEncoding.pool", "satrn_layers.Adaptive2DPositionalEncoding.dropout", "satrn_layers.Adaptive2DPositionalEncoding.h_scale", "satrn_layers.Adaptive2DPositionalEncoding.w_scale"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "b", ",", "c", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "\n", "avg_pool", "=", "self", ".", "pool", "(", "x", ")", "\n", "\n", "h_pos_encoding", "=", "self", ".", "h_scale", "(", "avg_pool", ")", "*", "self", ".", "h_position_encoder", "[", ":", ",", ":", ",", ":", "h", ",", ":", "]", "\n", "w_pos_encoding", "=", "self", ".", "w_scale", "(", "avg_pool", ")", "*", "self", ".", "w_position_encoder", "[", ":", ",", ":", ",", ":", ",", ":", "w", "]", "\n", "\n", "out", "=", "x", "+", "h_pos_encoding", "+", "w_pos_encoding", "\n", "\n", "out", "=", "self", ".", "dropout", "(", "out", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.transformer_layers.TFEncoderLayer.__init__": [[30, 54], ["dict", "mmcv.runner.BaseModule.__init__", "mmocr.models.common.modules.MultiHeadAttention", "torch.LayerNorm", "mmocr.models.common.modules.PositionwiseFeedForward", "torch.LayerNorm"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "d_model", "=", "512", ",", "\n", "d_inner", "=", "256", ",", "\n", "n_head", "=", "8", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "dropout", "=", "0.1", ",", "\n", "qkv_bias", "=", "False", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'mmcv.GELU'", ")", ",", "\n", "operation_order", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "attn", "=", "MultiHeadAttention", "(", "\n", "n_head", ",", "d_model", ",", "d_k", ",", "d_v", ",", "qkv_bias", "=", "qkv_bias", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "mlp", "=", "PositionwiseFeedForward", "(", "\n", "d_model", ",", "d_inner", ",", "dropout", "=", "dropout", ",", "act_cfg", "=", "act_cfg", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "\n", "self", ".", "operation_order", "=", "operation_order", "\n", "if", "self", ".", "operation_order", "is", "None", ":", "\n", "            ", "self", ".", "operation_order", "=", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "'ffn'", ")", "\n", "\n", "", "assert", "self", ".", "operation_order", "in", "[", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "'ffn'", ")", ",", "\n", "(", "'self_attn'", ",", "'norm'", ",", "'ffn'", ",", "'norm'", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.transformer_layers.TFEncoderLayer.forward": [[55, 74], ["transformer_layers.TFEncoderLayer.norm1", "transformer_layers.TFEncoderLayer.norm2", "transformer_layers.TFEncoderLayer.attn", "transformer_layers.TFEncoderLayer.mlp", "transformer_layers.TFEncoderLayer.norm1", "transformer_layers.TFEncoderLayer.norm2", "transformer_layers.TFEncoderLayer.attn", "transformer_layers.TFEncoderLayer.mlp"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "operation_order", "==", "(", "'self_attn'", ",", "'norm'", ",", "'ffn'", ",", "'norm'", ")", ":", "\n", "            ", "residual", "=", "x", "\n", "x", "=", "residual", "+", "self", ".", "attn", "(", "x", ",", "x", ",", "x", ",", "mask", ")", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "\n", "residual", "=", "x", "\n", "x", "=", "residual", "+", "self", ".", "mlp", "(", "x", ")", "\n", "x", "=", "self", ".", "norm2", "(", "x", ")", "\n", "", "elif", "self", ".", "operation_order", "==", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "'ffn'", ")", ":", "\n", "            ", "residual", "=", "x", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "residual", "+", "self", ".", "attn", "(", "x", ",", "x", ",", "x", ",", "mask", ")", "\n", "\n", "residual", "=", "x", "\n", "x", "=", "self", ".", "norm2", "(", "x", ")", "\n", "x", "=", "residual", "+", "self", ".", "mlp", "(", "x", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.transformer_layers.TFDecoderLayer.__init__": [[98, 130], ["dict", "torch.Module.__init__", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "mmocr.models.common.modules.MultiHeadAttention", "mmocr.models.common.modules.MultiHeadAttention", "mmocr.models.common.modules.PositionwiseFeedForward"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "d_model", "=", "512", ",", "\n", "d_inner", "=", "256", ",", "\n", "n_head", "=", "8", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "dropout", "=", "0.1", ",", "\n", "qkv_bias", "=", "False", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'mmcv.GELU'", ")", ",", "\n", "operation_order", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "norm1", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm2", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "self", ".", "norm3", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "\n", "self", ".", "self_attn", "=", "MultiHeadAttention", "(", "\n", "n_head", ",", "d_model", ",", "d_k", ",", "d_v", ",", "dropout", "=", "dropout", ",", "qkv_bias", "=", "qkv_bias", ")", "\n", "\n", "self", ".", "enc_attn", "=", "MultiHeadAttention", "(", "\n", "n_head", ",", "d_model", ",", "d_k", ",", "d_v", ",", "dropout", "=", "dropout", ",", "qkv_bias", "=", "qkv_bias", ")", "\n", "\n", "self", ".", "mlp", "=", "PositionwiseFeedForward", "(", "\n", "d_model", ",", "d_inner", ",", "dropout", "=", "dropout", ",", "act_cfg", "=", "act_cfg", ")", "\n", "\n", "self", ".", "operation_order", "=", "operation_order", "\n", "if", "self", ".", "operation_order", "is", "None", ":", "\n", "            ", "self", ".", "operation_order", "=", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "\n", "'enc_dec_attn'", ",", "'norm'", ",", "'ffn'", ")", "\n", "", "assert", "self", ".", "operation_order", "in", "[", "\n", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "'enc_dec_attn'", ",", "'norm'", ",", "'ffn'", ")", ",", "\n", "(", "'self_attn'", ",", "'norm'", ",", "'enc_dec_attn'", ",", "'norm'", ",", "'ffn'", ",", "'norm'", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.transformer_layers.TFDecoderLayer.forward": [[132, 168], ["transformer_layers.TFDecoderLayer.self_attn", "transformer_layers.TFDecoderLayer.norm1", "transformer_layers.TFDecoderLayer.enc_attn", "transformer_layers.TFDecoderLayer.norm2", "transformer_layers.TFDecoderLayer.mlp", "transformer_layers.TFDecoderLayer.norm3", "transformer_layers.TFDecoderLayer.norm1", "transformer_layers.TFDecoderLayer.self_attn", "transformer_layers.TFDecoderLayer.norm2", "transformer_layers.TFDecoderLayer.enc_attn", "transformer_layers.TFDecoderLayer.mlp", "transformer_layers.TFDecoderLayer.norm3"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2"], ["", "def", "forward", "(", "self", ",", "\n", "dec_input", ",", "\n", "enc_output", ",", "\n", "self_attn_mask", "=", "None", ",", "\n", "dec_enc_attn_mask", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "operation_order", "==", "(", "'self_attn'", ",", "'norm'", ",", "'enc_dec_attn'", ",", "\n", "'norm'", ",", "'ffn'", ",", "'norm'", ")", ":", "\n", "            ", "dec_attn_out", "=", "self", ".", "self_attn", "(", "dec_input", ",", "dec_input", ",", "dec_input", ",", "\n", "self_attn_mask", ")", "\n", "dec_attn_out", "+=", "dec_input", "\n", "dec_attn_out", "=", "self", ".", "norm1", "(", "dec_attn_out", ")", "\n", "\n", "enc_dec_attn_out", "=", "self", ".", "enc_attn", "(", "dec_attn_out", ",", "enc_output", ",", "\n", "enc_output", ",", "dec_enc_attn_mask", ")", "\n", "enc_dec_attn_out", "+=", "dec_attn_out", "\n", "enc_dec_attn_out", "=", "self", ".", "norm2", "(", "enc_dec_attn_out", ")", "\n", "\n", "mlp_out", "=", "self", ".", "mlp", "(", "enc_dec_attn_out", ")", "\n", "mlp_out", "+=", "enc_dec_attn_out", "\n", "mlp_out", "=", "self", ".", "norm3", "(", "mlp_out", ")", "\n", "", "elif", "self", ".", "operation_order", "==", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "\n", "'enc_dec_attn'", ",", "'norm'", ",", "'ffn'", ")", ":", "\n", "            ", "dec_input_norm", "=", "self", ".", "norm1", "(", "dec_input", ")", "\n", "dec_attn_out", "=", "self", ".", "self_attn", "(", "dec_input_norm", ",", "dec_input_norm", ",", "\n", "dec_input_norm", ",", "self_attn_mask", ")", "\n", "dec_attn_out", "+=", "dec_input", "\n", "\n", "enc_dec_attn_in", "=", "self", ".", "norm2", "(", "dec_attn_out", ")", "\n", "enc_dec_attn_out", "=", "self", ".", "enc_attn", "(", "enc_dec_attn_in", ",", "enc_output", ",", "\n", "enc_output", ",", "dec_enc_attn_mask", ")", "\n", "enc_dec_attn_out", "+=", "dec_attn_out", "\n", "\n", "mlp_out", "=", "self", ".", "mlp", "(", "self", ".", "norm3", "(", "enc_dec_attn_out", ")", ")", "\n", "mlp_out", "+=", "enc_dec_attn_out", "\n", "\n", "", "return", "mlp_out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.fusers.abi_fuser.ABIFuser.__init__": [[21, 32], ["mmcv.runner.BaseModule.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "d_model", "=", "512", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "num_chars", "=", "90", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "+", "1", "# additional stop token", "\n", "self", ".", "w_att", "=", "nn", ".", "Linear", "(", "2", "*", "d_model", ",", "d_model", ")", "\n", "self", ".", "cls", "=", "nn", ".", "Linear", "(", "d_model", ",", "num_chars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.fusers.abi_fuser.ABIFuser.forward": [[33, 52], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "abi_fuser.ABIFuser.cls", "abi_fuser.ABIFuser.w_att"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "l_feature", ",", "v_feature", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            l_feature: (N, T, E) where T is length, N is batch size and\n                d is dim of model.\n            v_feature: (N, T, E) shape the same as l_feature.\n\n        Returns:\n            A dict with key ``logits``\n            The logits of shape (N, T, C) where N is batch size, T is length\n                and C is the number of characters.\n        \"\"\"", "\n", "f", "=", "torch", ".", "cat", "(", "(", "l_feature", ",", "v_feature", ")", ",", "dim", "=", "2", ")", "\n", "f_att", "=", "torch", ".", "sigmoid", "(", "self", ".", "w_att", "(", "f", ")", ")", "\n", "output", "=", "f_att", "*", "v_feature", "+", "(", "1", "-", "f_att", ")", "*", "l_feature", "\n", "\n", "logits", "=", "self", ".", "cls", "(", "output", ")", "# (N, T, C)", "\n", "\n", "return", "{", "'logits'", ":", "logits", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.ParallelSARDecoder.__init__": [[45, 106], ["base_decoder.BaseDecoder.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "dict", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.GRU", "torch.GRU", "torch.GRU", "torch.LSTM", "torch.LSTM", "torch.LSTM", "int", "int"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", "=", "37", ",", "\n", "enc_bi_rnn", "=", "False", ",", "\n", "dec_bi_rnn", "=", "False", ",", "\n", "dec_do_rnn", "=", "0.0", ",", "\n", "dec_gru", "=", "False", ",", "\n", "d_model", "=", "512", ",", "\n", "d_enc", "=", "512", ",", "\n", "d_k", "=", "64", ",", "\n", "pred_dropout", "=", "0.0", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "mask", "=", "True", ",", "\n", "start_idx", "=", "0", ",", "\n", "padding_idx", "=", "92", ",", "\n", "pred_concat", "=", "False", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "enc_bi_rnn", "=", "enc_bi_rnn", "\n", "self", ".", "d_k", "=", "d_k", "\n", "self", ".", "start_idx", "=", "start_idx", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "mask", "=", "mask", "\n", "self", ".", "pred_concat", "=", "pred_concat", "\n", "\n", "encoder_rnn_out_size", "=", "d_enc", "*", "(", "int", "(", "enc_bi_rnn", ")", "+", "1", ")", "\n", "decoder_rnn_out_size", "=", "encoder_rnn_out_size", "*", "(", "int", "(", "dec_bi_rnn", ")", "+", "1", ")", "\n", "# 2D attention layer", "\n", "self", ".", "conv1x1_1", "=", "nn", ".", "Linear", "(", "decoder_rnn_out_size", ",", "d_k", ")", "\n", "self", ".", "conv3x3_1", "=", "nn", ".", "Conv2d", "(", "\n", "d_model", ",", "d_k", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv1x1_2", "=", "nn", ".", "Linear", "(", "d_k", ",", "1", ")", "\n", "\n", "# Decoder RNN layer", "\n", "kwargs", "=", "dict", "(", "\n", "input_size", "=", "encoder_rnn_out_size", ",", "\n", "hidden_size", "=", "encoder_rnn_out_size", ",", "\n", "num_layers", "=", "2", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "dec_do_rnn", ",", "\n", "bidirectional", "=", "dec_bi_rnn", ")", "\n", "if", "dec_gru", ":", "\n", "            ", "self", ".", "rnn_decoder", "=", "nn", ".", "GRU", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rnn_decoder", "=", "nn", ".", "LSTM", "(", "**", "kwargs", ")", "\n", "\n", "# Decoder input embedding", "\n", "", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "\n", "self", ".", "num_classes", ",", "encoder_rnn_out_size", ",", "padding_idx", "=", "padding_idx", ")", "\n", "\n", "# Prediction layer", "\n", "self", ".", "pred_dropout", "=", "nn", ".", "Dropout", "(", "pred_dropout", ")", "\n", "pred_num_classes", "=", "num_classes", "-", "1", "# ignore padding_idx in prediction", "\n", "if", "pred_concat", ":", "\n", "            ", "fc_in_channel", "=", "decoder_rnn_out_size", "+", "d_model", "+", "encoder_rnn_out_size", "\n", "", "else", ":", "\n", "            ", "fc_in_channel", "=", "d_model", "\n", "", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "fc_in_channel", ",", "pred_num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.ParallelSARDecoder._2d_attention": [[107, 163], ["sar_decoder.ParallelSARDecoder.conv1x1_1", "attn_query.view.view.size", "attn_query.view.view.view", "sar_decoder.ParallelSARDecoder.conv3x3_1", "attn_key.unsqueeze.unsqueeze.unsqueeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "attn_weight.masked_fill.masked_fill.permute().contiguous", "sar_decoder.ParallelSARDecoder.conv1x1_2", "attn_weight.masked_fill.masked_fill.size", "attn_weight.masked_fill.masked_fill.view", "torch.softmax", "torch.softmax", "torch.softmax", "attn_weight.masked_fill.masked_fill.view().permute().contiguous", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "sar_decoder.ParallelSARDecoder.rnn_decoder", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "attn_weight.masked_fill.masked_fill.masked_fill", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "holistic_feat.expand.expand.size", "holistic_feat.expand.expand.expand", "sar_decoder.ParallelSARDecoder.prediction", "sar_decoder.ParallelSARDecoder.prediction", "sar_decoder.ParallelSARDecoder.pred_dropout", "attn_weight.masked_fill.masked_fill.permute", "min", "torch.zeros_like.bool", "torch.zeros_like.bool", "torch.zeros_like.bool", "float", "attn_weight.masked_fill.masked_fill.view().permute", "feat.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "math.ceil", "attn_weight.masked_fill.masked_fill.view"], "methods", ["None"], ["", "def", "_2d_attention", "(", "self", ",", "\n", "decoder_input", ",", "\n", "feat", ",", "\n", "holistic_feat", ",", "\n", "valid_ratios", "=", "None", ")", ":", "\n", "        ", "y", "=", "self", ".", "rnn_decoder", "(", "decoder_input", ")", "[", "0", "]", "\n", "# y: bsz * (seq_len + 1) * hidden_size", "\n", "\n", "attn_query", "=", "self", ".", "conv1x1_1", "(", "y", ")", "# bsz * (seq_len + 1) * attn_size", "\n", "bsz", ",", "seq_len", ",", "attn_size", "=", "attn_query", ".", "size", "(", ")", "\n", "attn_query", "=", "attn_query", ".", "view", "(", "bsz", ",", "seq_len", ",", "attn_size", ",", "1", ",", "1", ")", "\n", "\n", "attn_key", "=", "self", ".", "conv3x3_1", "(", "feat", ")", "\n", "# bsz * attn_size * h * w", "\n", "attn_key", "=", "attn_key", ".", "unsqueeze", "(", "1", ")", "\n", "# bsz * 1 * attn_size * h * w", "\n", "\n", "attn_weight", "=", "torch", ".", "tanh", "(", "torch", ".", "add", "(", "attn_key", ",", "attn_query", ",", "alpha", "=", "1", ")", ")", "\n", "# bsz * (seq_len + 1) * attn_size * h * w", "\n", "attn_weight", "=", "attn_weight", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "4", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "# bsz * (seq_len + 1) * h * w * attn_size", "\n", "attn_weight", "=", "self", ".", "conv1x1_2", "(", "attn_weight", ")", "\n", "# bsz * (seq_len + 1) * h * w * 1", "\n", "bsz", ",", "T", ",", "h", ",", "w", ",", "c", "=", "attn_weight", ".", "size", "(", ")", "\n", "assert", "c", "==", "1", "\n", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "# cal mask of attention weight", "\n", "            ", "attn_mask", "=", "torch", ".", "zeros_like", "(", "attn_weight", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "attn_mask", "[", "i", ",", ":", ",", ":", ",", "valid_width", ":", ",", ":", "]", "=", "1", "\n", "", "attn_weight", "=", "attn_weight", ".", "masked_fill", "(", "attn_mask", ".", "bool", "(", ")", ",", "\n", "float", "(", "'-inf'", ")", ")", "\n", "\n", "", "attn_weight", "=", "attn_weight", ".", "view", "(", "bsz", ",", "T", ",", "-", "1", ")", "\n", "attn_weight", "=", "F", ".", "softmax", "(", "attn_weight", ",", "dim", "=", "-", "1", ")", "\n", "attn_weight", "=", "attn_weight", ".", "view", "(", "bsz", ",", "T", ",", "h", ",", "w", ",", "\n", "c", ")", ".", "permute", "(", "0", ",", "1", ",", "4", ",", "2", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "\n", "attn_feat", "=", "torch", ".", "sum", "(", "\n", "torch", ".", "mul", "(", "feat", ".", "unsqueeze", "(", "1", ")", ",", "attn_weight", ")", ",", "(", "3", ",", "4", ")", ",", "keepdim", "=", "False", ")", "\n", "# bsz * (seq_len + 1) * C", "\n", "\n", "# linear transformation", "\n", "if", "self", ".", "pred_concat", ":", "\n", "            ", "hf_c", "=", "holistic_feat", ".", "size", "(", "-", "1", ")", "\n", "holistic_feat", "=", "holistic_feat", ".", "expand", "(", "bsz", ",", "seq_len", ",", "hf_c", ")", "\n", "y", "=", "self", ".", "prediction", "(", "torch", ".", "cat", "(", "(", "y", ",", "attn_feat", ",", "holistic_feat", ")", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "self", ".", "prediction", "(", "attn_feat", ")", "\n", "# bsz * (seq_len + 1) * num_classes", "\n", "", "if", "self", ".", "train_mode", ":", "\n", "            ", "y", "=", "self", ".", "pred_dropout", "(", "y", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.ParallelSARDecoder.forward_train": [[164, 201], ["targets_dict[].to", "sar_decoder.ParallelSARDecoder.embedding", "out_enc.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "sar_decoder.ParallelSARDecoder._2d_attention", "mmocr.is_type_list", "len", "feat.size", "img_meta.get"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder._2d_attention", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "feat", ".", "size", "(", "0", ")", "\n", "\n", "", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", ".", "to", "(", "feat", ".", "device", ")", "\n", "tgt_embedding", "=", "self", ".", "embedding", "(", "targets", ")", "\n", "# bsz * seq_len * emb_dim", "\n", "out_enc", "=", "out_enc", ".", "unsqueeze", "(", "1", ")", "\n", "# bsz * 1 * emb_dim", "\n", "in_dec", "=", "torch", ".", "cat", "(", "(", "out_enc", ",", "tgt_embedding", ")", ",", "dim", "=", "1", ")", "\n", "# bsz * (seq_len + 1) * C", "\n", "out_dec", "=", "self", ".", "_2d_attention", "(", "\n", "in_dec", ",", "feat", ",", "out_enc", ",", "valid_ratios", "=", "valid_ratios", ")", "\n", "# bsz * (seq_len + 1) * num_classes", "\n", "\n", "return", "out_dec", "[", ":", ",", "1", ":", ",", ":", "]", "# bsz * seq_len * num_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.ParallelSARDecoder.forward_test": [[202, 256], ["feat.size", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "sar_decoder.ParallelSARDecoder.embedding", "start_token.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "out_enc.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "mmocr.is_type_list", "sar_decoder.ParallelSARDecoder._2d_attention", "torch.softmax", "torch.softmax", "torch.softmax", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "sar_decoder.ParallelSARDecoder.embedding", "len", "feat.size", "start_token.unsqueeze().expand.unsqueeze().expand.unsqueeze", "img_meta.get"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder._2d_attention"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "feat", ".", "size", "(", "0", ")", "\n", "\n", "", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "", "seq_len", "=", "self", ".", "max_seq_len", "\n", "\n", "bsz", "=", "feat", ".", "size", "(", "0", ")", "\n", "start_token", "=", "torch", ".", "full", "(", "(", "bsz", ",", ")", ",", "\n", "self", ".", "start_idx", ",", "\n", "device", "=", "feat", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "# bsz", "\n", "start_token", "=", "self", ".", "embedding", "(", "start_token", ")", "\n", "# bsz * emb_dim", "\n", "start_token", "=", "start_token", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "seq_len", ",", "-", "1", ")", "\n", "# bsz * seq_len * emb_dim", "\n", "out_enc", "=", "out_enc", ".", "unsqueeze", "(", "1", ")", "\n", "# bsz * 1 * emb_dim", "\n", "decoder_input", "=", "torch", ".", "cat", "(", "(", "out_enc", ",", "start_token", ")", ",", "dim", "=", "1", ")", "\n", "# bsz * (seq_len + 1) * emb_dim", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "seq_len", "+", "1", ")", ":", "\n", "            ", "decoder_output", "=", "self", ".", "_2d_attention", "(", "\n", "decoder_input", ",", "feat", ",", "out_enc", ",", "valid_ratios", "=", "valid_ratios", ")", "\n", "char_output", "=", "decoder_output", "[", ":", ",", "i", ",", ":", "]", "# bsz * num_classes", "\n", "char_output", "=", "F", ".", "softmax", "(", "char_output", ",", "-", "1", ")", "\n", "outputs", ".", "append", "(", "char_output", ")", "\n", "_", ",", "max_idx", "=", "torch", ".", "max", "(", "char_output", ",", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "char_embedding", "=", "self", ".", "embedding", "(", "max_idx", ")", "# bsz * emb_dim", "\n", "if", "i", "<", "seq_len", ":", "\n", "                ", "decoder_input", "[", ":", ",", "i", "+", "1", ",", ":", "]", "=", "char_embedding", "\n", "\n", "", "", "outputs", "=", "torch", ".", "stack", "(", "outputs", ",", "1", ")", "# bsz * seq_len * num_classes", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder.__init__": [[282, 342], ["base_decoder.BaseDecoder.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.GRUCell", "torch.GRUCell", "torch.GRUCell", "torch.GRUCell", "torch.GRUCell", "torch.GRUCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "int", "int"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", "=", "37", ",", "\n", "enc_bi_rnn", "=", "False", ",", "\n", "dec_bi_rnn", "=", "False", ",", "\n", "dec_gru", "=", "False", ",", "\n", "d_k", "=", "64", ",", "\n", "d_model", "=", "512", ",", "\n", "d_enc", "=", "512", ",", "\n", "pred_dropout", "=", "0.0", ",", "\n", "mask", "=", "True", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "start_idx", "=", "0", ",", "\n", "padding_idx", "=", "92", ",", "\n", "pred_concat", "=", "False", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "enc_bi_rnn", "=", "enc_bi_rnn", "\n", "self", ".", "d_k", "=", "d_k", "\n", "self", ".", "start_idx", "=", "start_idx", "\n", "self", ".", "dec_gru", "=", "dec_gru", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "mask", "=", "mask", "\n", "self", ".", "pred_concat", "=", "pred_concat", "\n", "\n", "encoder_rnn_out_size", "=", "d_enc", "*", "(", "int", "(", "enc_bi_rnn", ")", "+", "1", ")", "\n", "decoder_rnn_out_size", "=", "encoder_rnn_out_size", "*", "(", "int", "(", "dec_bi_rnn", ")", "+", "1", ")", "\n", "# 2D attention layer", "\n", "self", ".", "conv1x1_1", "=", "nn", ".", "Conv2d", "(", "\n", "decoder_rnn_out_size", ",", "d_k", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "self", ".", "conv3x3_1", "=", "nn", ".", "Conv2d", "(", "\n", "d_model", ",", "d_k", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv1x1_2", "=", "nn", ".", "Conv2d", "(", "d_k", ",", "1", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "\n", "# Decoder rnn layer", "\n", "if", "dec_gru", ":", "\n", "            ", "self", ".", "rnn_decoder_layer1", "=", "nn", ".", "GRUCell", "(", "encoder_rnn_out_size", ",", "\n", "encoder_rnn_out_size", ")", "\n", "self", ".", "rnn_decoder_layer2", "=", "nn", ".", "GRUCell", "(", "encoder_rnn_out_size", ",", "\n", "encoder_rnn_out_size", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rnn_decoder_layer1", "=", "nn", ".", "LSTMCell", "(", "encoder_rnn_out_size", ",", "\n", "encoder_rnn_out_size", ")", "\n", "self", ".", "rnn_decoder_layer2", "=", "nn", ".", "LSTMCell", "(", "encoder_rnn_out_size", ",", "\n", "encoder_rnn_out_size", ")", "\n", "\n", "# Decoder input embedding", "\n", "", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "\n", "self", ".", "num_classes", ",", "encoder_rnn_out_size", ",", "padding_idx", "=", "padding_idx", ")", "\n", "\n", "# Prediction layer", "\n", "self", ".", "pred_dropout", "=", "nn", ".", "Dropout", "(", "pred_dropout", ")", "\n", "pred_num_class", "=", "num_classes", "-", "1", "# ignore padding index", "\n", "if", "pred_concat", ":", "\n", "            ", "fc_in_channel", "=", "decoder_rnn_out_size", "+", "d_model", "+", "d_enc", "\n", "", "else", ":", "\n", "            ", "fc_in_channel", "=", "d_model", "\n", "", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "fc_in_channel", ",", "pred_num_class", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder._2d_attention": [[343, 391], ["feat.size", "sar_decoder.SequentialSARDecoder.view", "sar_decoder.SequentialSARDecoder.conv1x1_1", "attn_query.expand.expand.expand", "sar_decoder.SequentialSARDecoder.conv3x3_1", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "sar_decoder.SequentialSARDecoder.conv1x1_2", "attn_weight.masked_fill.masked_fill.size", "torch.softmax", "torch.softmax", "torch.softmax", "attn_weight.masked_fill.masked_fill.view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer1", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer2", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer1", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer2", "sar_decoder.SequentialSARDecoder.size", "sar_decoder.SequentialSARDecoder.size", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.add", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "enumerate", "attn_weight.masked_fill.masked_fill.masked_fill", "attn_weight.masked_fill.masked_fill.view", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "sar_decoder.SequentialSARDecoder.prediction", "sar_decoder.SequentialSARDecoder.prediction", "min", "torch.zeros_like.bool", "torch.zeros_like.bool", "torch.zeros_like.bool", "float", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "math.ceil"], "methods", ["None"], ["", "def", "_2d_attention", "(", "self", ",", "\n", "y_prev", ",", "\n", "feat", ",", "\n", "holistic_feat", ",", "\n", "hx1", ",", "\n", "cx1", ",", "\n", "hx2", ",", "\n", "cx2", ",", "\n", "valid_ratios", "=", "None", ")", ":", "\n", "        ", "_", ",", "_", ",", "h_feat", ",", "w_feat", "=", "feat", ".", "size", "(", ")", "\n", "if", "self", ".", "dec_gru", ":", "\n", "            ", "hx1", "=", "cx1", "=", "self", ".", "rnn_decoder_layer1", "(", "y_prev", ",", "hx1", ")", "\n", "hx2", "=", "cx2", "=", "self", ".", "rnn_decoder_layer2", "(", "hx1", ",", "hx2", ")", "\n", "", "else", ":", "\n", "            ", "hx1", ",", "cx1", "=", "self", ".", "rnn_decoder_layer1", "(", "y_prev", ",", "(", "hx1", ",", "cx1", ")", ")", "\n", "hx2", ",", "cx2", "=", "self", ".", "rnn_decoder_layer2", "(", "hx1", ",", "(", "hx2", ",", "cx2", ")", ")", "\n", "\n", "", "tile_hx2", "=", "hx2", ".", "view", "(", "hx2", ".", "size", "(", "0", ")", ",", "hx2", ".", "size", "(", "1", ")", ",", "1", ",", "1", ")", "\n", "attn_query", "=", "self", ".", "conv1x1_1", "(", "tile_hx2", ")", "# bsz * attn_size * 1 * 1", "\n", "attn_query", "=", "attn_query", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "h_feat", ",", "w_feat", ")", "\n", "attn_key", "=", "self", ".", "conv3x3_1", "(", "feat", ")", "\n", "attn_weight", "=", "torch", ".", "tanh", "(", "torch", ".", "add", "(", "attn_key", ",", "attn_query", ",", "alpha", "=", "1", ")", ")", "\n", "attn_weight", "=", "self", ".", "conv1x1_2", "(", "attn_weight", ")", "\n", "bsz", ",", "c", ",", "h", ",", "w", "=", "attn_weight", ".", "size", "(", ")", "\n", "assert", "c", "==", "1", "\n", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "# cal mask of attention weight", "\n", "            ", "attn_mask", "=", "torch", ".", "zeros_like", "(", "attn_weight", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "attn_mask", "[", "i", ",", ":", ",", ":", ",", "valid_width", ":", "]", "=", "1", "\n", "", "attn_weight", "=", "attn_weight", ".", "masked_fill", "(", "attn_mask", ".", "bool", "(", ")", ",", "\n", "float", "(", "'-inf'", ")", ")", "\n", "\n", "", "attn_weight", "=", "F", ".", "softmax", "(", "attn_weight", ".", "view", "(", "bsz", ",", "-", "1", ")", ",", "dim", "=", "-", "1", ")", "\n", "attn_weight", "=", "attn_weight", ".", "view", "(", "bsz", ",", "c", ",", "h", ",", "w", ")", "\n", "\n", "attn_feat", "=", "torch", ".", "sum", "(", "\n", "torch", ".", "mul", "(", "feat", ",", "attn_weight", ")", ",", "(", "2", ",", "3", ")", ",", "keepdim", "=", "False", ")", "# n * c", "\n", "\n", "# linear transformation", "\n", "if", "self", ".", "pred_concat", ":", "\n", "            ", "y", "=", "self", ".", "prediction", "(", "torch", ".", "cat", "(", "(", "hx2", ",", "attn_feat", ",", "holistic_feat", ")", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "y", "=", "self", ".", "prediction", "(", "attn_feat", ")", "\n", "\n", "", "return", "y", ",", "hx1", ",", "hx1", ",", "hx2", ",", "hx2", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder.forward_train": [[392, 461], ["torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "sar_decoder.SequentialSARDecoder.embedding", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "mmocr.is_type_list", "targets_dict[].to", "sar_decoder.SequentialSARDecoder.embedding", "len", "feat.size", "feat.size", "sar_decoder.SequentialSARDecoder._2d_attention", "torch.stack.append", "torch.stack.append", "torch.stack.append", "img_meta.get", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer1", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer2", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer1", "sar_decoder.SequentialSARDecoder.rnn_decoder_layer2", "sar_decoder.SequentialSARDecoder.pred_dropout", "torch.softmax", "torch.softmax", "torch.softmax", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "sar_decoder.SequentialSARDecoder.embedding"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder._2d_attention"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "feat", ".", "size", "(", "0", ")", "\n", "\n", "", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "", "if", "self", ".", "train_mode", ":", "\n", "            ", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", ".", "to", "(", "feat", ".", "device", ")", "\n", "tgt_embedding", "=", "self", ".", "embedding", "(", "targets", ")", "\n", "\n", "", "outputs", "=", "[", "]", "\n", "start_token", "=", "torch", ".", "full", "(", "(", "feat", ".", "size", "(", "0", ")", ",", ")", ",", "\n", "self", ".", "start_idx", ",", "\n", "device", "=", "feat", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "start_token", "=", "self", ".", "embedding", "(", "start_token", ")", "\n", "for", "i", "in", "range", "(", "-", "1", ",", "self", ".", "max_seq_len", ")", ":", "\n", "            ", "if", "i", "==", "-", "1", ":", "\n", "                ", "if", "self", ".", "dec_gru", ":", "\n", "                    ", "hx1", "=", "cx1", "=", "self", ".", "rnn_decoder_layer1", "(", "out_enc", ")", "\n", "hx2", "=", "cx2", "=", "self", ".", "rnn_decoder_layer2", "(", "hx1", ")", "\n", "", "else", ":", "\n", "                    ", "hx1", ",", "cx1", "=", "self", ".", "rnn_decoder_layer1", "(", "out_enc", ")", "\n", "hx2", ",", "cx2", "=", "self", ".", "rnn_decoder_layer2", "(", "hx1", ")", "\n", "", "if", "not", "self", ".", "train_mode", ":", "\n", "                    ", "y_prev", "=", "start_token", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "train_mode", ":", "\n", "                    ", "y_prev", "=", "tgt_embedding", "[", ":", ",", "i", ",", ":", "]", "\n", "", "y", ",", "hx1", ",", "cx1", ",", "hx2", ",", "cx2", "=", "self", ".", "_2d_attention", "(", "\n", "y_prev", ",", "\n", "feat", ",", "\n", "out_enc", ",", "\n", "hx1", ",", "\n", "cx1", ",", "\n", "hx2", ",", "\n", "cx2", ",", "\n", "valid_ratios", "=", "valid_ratios", ")", "\n", "if", "self", ".", "train_mode", ":", "\n", "                    ", "y", "=", "self", ".", "pred_dropout", "(", "y", ")", "\n", "", "else", ":", "\n", "                    ", "y", "=", "F", ".", "softmax", "(", "y", ",", "-", "1", ")", "\n", "_", ",", "max_idx", "=", "torch", ".", "max", "(", "y", ",", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "char_embedding", "=", "self", ".", "embedding", "(", "max_idx", ")", "\n", "y_prev", "=", "char_embedding", "\n", "", "outputs", ".", "append", "(", "y", ")", "\n", "\n", "", "", "outputs", "=", "torch", ".", "stack", "(", "outputs", ",", "1", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder.forward_test": [[462, 479], ["sar_decoder.SequentialSARDecoder.forward_train", "mmocr.is_type_list", "len", "feat.size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "feat", ".", "size", "(", "0", ")", "\n", "\n", "", "return", "self", ".", "forward_train", "(", "feat", ",", "out_enc", ",", "None", ",", "img_metas", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.robust_scanner_decoder.RobustScannerDecoder.__init__": [[42, 94], ["base_decoder.BaseDecoder.__init__", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "hybrid_decoder.update", "mmocr.models.builder.build_decoder", "position_decoder.update", "position_decoder.update", "position_decoder.update", "position_decoder.update", "position_decoder.update", "position_decoder.update", "position_decoder.update", "mmocr.models.builder.build_decoder", "mmocr.models.textrecog.layers.RobustScannerFusionLayer", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", "=", "None", ",", "\n", "dim_input", "=", "512", ",", "\n", "dim_model", "=", "128", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "start_idx", "=", "0", ",", "\n", "mask", "=", "True", ",", "\n", "padding_idx", "=", "None", ",", "\n", "encode_value", "=", "False", ",", "\n", "hybrid_decoder", "=", "None", ",", "\n", "position_decoder", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "dim_input", "=", "dim_input", "\n", "self", ".", "dim_model", "=", "dim_model", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "encode_value", "=", "encode_value", "\n", "self", ".", "start_idx", "=", "start_idx", "\n", "self", ".", "padding_idx", "=", "padding_idx", "\n", "self", ".", "mask", "=", "mask", "\n", "\n", "# init hybrid decoder", "\n", "hybrid_decoder", ".", "update", "(", "num_classes", "=", "self", ".", "num_classes", ")", "\n", "hybrid_decoder", ".", "update", "(", "dim_input", "=", "self", ".", "dim_input", ")", "\n", "hybrid_decoder", ".", "update", "(", "dim_model", "=", "self", ".", "dim_model", ")", "\n", "hybrid_decoder", ".", "update", "(", "start_idx", "=", "self", ".", "start_idx", ")", "\n", "hybrid_decoder", ".", "update", "(", "padding_idx", "=", "self", ".", "padding_idx", ")", "\n", "hybrid_decoder", ".", "update", "(", "max_seq_len", "=", "self", ".", "max_seq_len", ")", "\n", "hybrid_decoder", ".", "update", "(", "mask", "=", "self", ".", "mask", ")", "\n", "hybrid_decoder", ".", "update", "(", "encode_value", "=", "self", ".", "encode_value", ")", "\n", "hybrid_decoder", ".", "update", "(", "return_feature", "=", "True", ")", "\n", "\n", "self", ".", "hybrid_decoder", "=", "build_decoder", "(", "hybrid_decoder", ")", "\n", "\n", "# init position decoder", "\n", "position_decoder", ".", "update", "(", "num_classes", "=", "self", ".", "num_classes", ")", "\n", "position_decoder", ".", "update", "(", "dim_input", "=", "self", ".", "dim_input", ")", "\n", "position_decoder", ".", "update", "(", "dim_model", "=", "self", ".", "dim_model", ")", "\n", "position_decoder", ".", "update", "(", "max_seq_len", "=", "self", ".", "max_seq_len", ")", "\n", "position_decoder", ".", "update", "(", "mask", "=", "self", ".", "mask", ")", "\n", "position_decoder", ".", "update", "(", "encode_value", "=", "self", ".", "encode_value", ")", "\n", "position_decoder", ".", "update", "(", "return_feature", "=", "True", ")", "\n", "\n", "self", ".", "position_decoder", "=", "build_decoder", "(", "position_decoder", ")", "\n", "\n", "self", ".", "fusion_module", "=", "RobustScannerFusionLayer", "(", "\n", "self", ".", "dim_model", "if", "encode_value", "else", "dim_input", ")", "\n", "\n", "pred_num_classes", "=", "num_classes", "-", "1", "\n", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "dim_model", "if", "encode_value", "else", "dim_input", ",", "\n", "pred_num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.robust_scanner_decoder.RobustScannerDecoder.forward_train": [[95, 120], ["robust_scanner_decoder.RobustScannerDecoder.hybrid_decoder.forward_train", "robust_scanner_decoder.RobustScannerDecoder.position_decoder.forward_train", "robust_scanner_decoder.RobustScannerDecoder.fusion_module", "robust_scanner_decoder.RobustScannerDecoder.prediction"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "hybrid_glimpse", "=", "self", ".", "hybrid_decoder", ".", "forward_train", "(", "\n", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", "\n", "position_glimpse", "=", "self", ".", "position_decoder", ".", "forward_train", "(", "\n", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", "\n", "\n", "fusion_out", "=", "self", ".", "fusion_module", "(", "hybrid_glimpse", ",", "position_glimpse", ")", "\n", "\n", "out", "=", "self", ".", "prediction", "(", "fusion_out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.robust_scanner_decoder.RobustScannerDecoder.forward_test": [[121, 161], ["feat.size", "robust_scanner_decoder.RobustScannerDecoder.position_decoder.forward_test", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "robust_scanner_decoder.RobustScannerDecoder.hybrid_decoder.forward_test_step", "robust_scanner_decoder.RobustScannerDecoder.fusion_module", "robust_scanner_decoder.RobustScannerDecoder.prediction", "torch.softmax", "torch.softmax", "torch.softmax", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "feat.new_ones"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sequence_attention_decoder.SequenceAttentionDecoder.forward_test_step"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: The output logit sequence tensor of shape\n            :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "seq_len", "=", "self", ".", "max_seq_len", "\n", "batch_size", "=", "feat", ".", "size", "(", "0", ")", "\n", "\n", "decode_sequence", "=", "(", "feat", ".", "new_ones", "(", "\n", "(", "batch_size", ",", "seq_len", ")", ")", "*", "self", ".", "start_idx", ")", ".", "long", "(", ")", "\n", "\n", "position_glimpse", "=", "self", ".", "position_decoder", ".", "forward_test", "(", "\n", "feat", ",", "out_enc", ",", "img_metas", ")", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "seq_len", ")", ":", "\n", "            ", "hybrid_glimpse_step", "=", "self", ".", "hybrid_decoder", ".", "forward_test_step", "(", "\n", "feat", ",", "out_enc", ",", "decode_sequence", ",", "i", ",", "img_metas", ")", "\n", "\n", "fusion_out", "=", "self", ".", "fusion_module", "(", "hybrid_glimpse_step", ",", "\n", "position_glimpse", "[", ":", ",", "i", ",", ":", "]", ")", "\n", "\n", "char_out", "=", "self", ".", "prediction", "(", "fusion_out", ")", "\n", "char_out", "=", "F", ".", "softmax", "(", "char_out", ",", "-", "1", ")", "\n", "outputs", ".", "append", "(", "char_out", ")", "\n", "_", ",", "max_idx", "=", "torch", ".", "max", "(", "char_out", ",", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "if", "i", "<", "seq_len", "-", "1", ":", "\n", "                ", "decode_sequence", "[", ":", ",", "i", "+", "1", "]", "=", "max_idx", "\n", "\n", "", "", "outputs", "=", "torch", ".", "stack", "(", "outputs", ",", "1", ")", "\n", "\n", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sequence_attention_decoder.SequenceAttentionDecoder.__init__": [[45, 86], ["base_decoder.BaseDecoder.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.LSTM", "torch.LSTM", "torch.LSTM", "mmocr.models.textrecog.layers.DotProductAttentionLayer", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", "=", "None", ",", "\n", "rnn_layers", "=", "2", ",", "\n", "dim_input", "=", "512", ",", "\n", "dim_model", "=", "128", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "start_idx", "=", "0", ",", "\n", "mask", "=", "True", ",", "\n", "padding_idx", "=", "None", ",", "\n", "dropout", "=", "0", ",", "\n", "return_feature", "=", "False", ",", "\n", "encode_value", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "dim_input", "=", "dim_input", "\n", "self", ".", "dim_model", "=", "dim_model", "\n", "self", ".", "return_feature", "=", "return_feature", "\n", "self", ".", "encode_value", "=", "encode_value", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "start_idx", "=", "start_idx", "\n", "self", ".", "mask", "=", "mask", "\n", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "\n", "self", ".", "num_classes", ",", "self", ".", "dim_model", ",", "padding_idx", "=", "padding_idx", ")", "\n", "\n", "self", ".", "sequence_layer", "=", "nn", ".", "LSTM", "(", "\n", "input_size", "=", "dim_model", ",", "\n", "hidden_size", "=", "dim_model", ",", "\n", "num_layers", "=", "rnn_layers", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "dropout", ")", "\n", "\n", "self", ".", "attention_layer", "=", "DotProductAttentionLayer", "(", ")", "\n", "\n", "self", ".", "prediction", "=", "None", "\n", "if", "not", "self", ".", "return_feature", ":", "\n", "            ", "pred_num_classes", "=", "num_classes", "-", "1", "\n", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "\n", "dim_model", "if", "encode_value", "else", "dim_input", ",", "pred_num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sequence_attention_decoder.SequenceAttentionDecoder.forward_train": [[87, 146], ["targets_dict[].to", "sequence_attention_decoder.SequenceAttentionDecoder.embedding", "out_enc.size", "feat.size", "sequence_attention_decoder.SequenceAttentionDecoder.size", "sequence_attention_decoder.SequenceAttentionDecoder.sequence_layer", "query.permute().contiguous.permute().contiguous.permute().contiguous", "out_enc.view", "sequence_attention_decoder.SequenceAttentionDecoder.attention_layer", "attn_out.permute().contiguous.permute().contiguous.permute().contiguous", "sequence_attention_decoder.SequenceAttentionDecoder.prediction", "feat.view", "query.permute().contiguous.permute().contiguous.new_zeros", "enumerate", "mask.view.view.bool", "mask.view.view.view", "img_meta.get", "query.permute().contiguous.permute().contiguous.permute", "min", "attn_out.permute().contiguous.permute().contiguous.permute", "math.ceil"], "methods", ["None"], ["", "", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)` if\n            ``return_feature=False``. Otherwise it would be the hidden feature\n            before the prediction projection layer, whose shape is\n            :math:`(N, T, D_m)`.\n        \"\"\"", "\n", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", ".", "to", "(", "feat", ".", "device", ")", "\n", "tgt_embedding", "=", "self", ".", "embedding", "(", "targets", ")", "\n", "\n", "n", ",", "c_enc", ",", "h", ",", "w", "=", "out_enc", ".", "size", "(", ")", "\n", "assert", "c_enc", "==", "self", ".", "dim_model", "\n", "_", ",", "c_feat", ",", "_", ",", "_", "=", "feat", ".", "size", "(", ")", "\n", "assert", "c_feat", "==", "self", ".", "dim_input", "\n", "_", ",", "len_q", ",", "c_q", "=", "tgt_embedding", ".", "size", "(", ")", "\n", "assert", "c_q", "==", "self", ".", "dim_model", "\n", "assert", "len_q", "<=", "self", ".", "max_seq_len", "\n", "\n", "query", ",", "_", "=", "self", ".", "sequence_layer", "(", "tgt_embedding", ")", "\n", "query", "=", "query", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "key", "=", "out_enc", ".", "view", "(", "n", ",", "c_enc", ",", "h", "*", "w", ")", "\n", "if", "self", ".", "encode_value", ":", "\n", "            ", "value", "=", "key", "\n", "", "else", ":", "\n", "            ", "value", "=", "feat", ".", "view", "(", "n", ",", "c_feat", ",", "h", "*", "w", ")", "\n", "\n", "", "mask", "=", "None", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "mask", "=", "query", ".", "new_zeros", "(", "(", "n", ",", "h", ",", "w", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", ",", "valid_width", ":", "]", "=", "1", "\n", "", "mask", "=", "mask", ".", "bool", "(", ")", "\n", "mask", "=", "mask", ".", "view", "(", "n", ",", "h", "*", "w", ")", "\n", "\n", "", "attn_out", "=", "self", ".", "attention_layer", "(", "query", ",", "key", ",", "value", ",", "mask", ")", "\n", "attn_out", "=", "attn_out", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "if", "self", ".", "return_feature", ":", "\n", "            ", "return", "attn_out", "\n", "\n", "", "out", "=", "self", ".", "prediction", "(", "attn_out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sequence_attention_decoder.SequenceAttentionDecoder.forward_test": [[147, 178], ["feat.size", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "sequence_attention_decoder.SequenceAttentionDecoder.forward_test_step", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "feat.new_ones"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sequence_attention_decoder.SequenceAttentionDecoder.forward_test_step"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: The output logit sequence tensor of shape\n            :math:`(N, T, C-1)`.\n        \"\"\"", "\n", "seq_len", "=", "self", ".", "max_seq_len", "\n", "batch_size", "=", "feat", ".", "size", "(", "0", ")", "\n", "\n", "decode_sequence", "=", "(", "feat", ".", "new_ones", "(", "\n", "(", "batch_size", ",", "seq_len", ")", ")", "*", "self", ".", "start_idx", ")", ".", "long", "(", ")", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "seq_len", ")", ":", "\n", "            ", "step_out", "=", "self", ".", "forward_test_step", "(", "feat", ",", "out_enc", ",", "decode_sequence", ",", "\n", "i", ",", "img_metas", ")", "\n", "outputs", ".", "append", "(", "step_out", ")", "\n", "_", ",", "max_idx", "=", "torch", ".", "max", "(", "step_out", ",", "dim", "=", "1", ",", "keepdim", "=", "False", ")", "\n", "if", "i", "<", "seq_len", "-", "1", ":", "\n", "                ", "decode_sequence", "[", ":", ",", "i", "+", "1", "]", "=", "max_idx", "\n", "\n", "", "", "outputs", "=", "torch", ".", "stack", "(", "outputs", ",", "1", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sequence_attention_decoder.SequenceAttentionDecoder.forward_test_step": [[179, 238], ["sequence_attention_decoder.SequenceAttentionDecoder.embedding", "out_enc.size", "feat.size", "sequence_attention_decoder.SequenceAttentionDecoder.size", "sequence_attention_decoder.SequenceAttentionDecoder.sequence_layer", "query.permute().contiguous.permute().contiguous.permute().contiguous", "out_enc.view", "sequence_attention_decoder.SequenceAttentionDecoder.attention_layer", "sequence_attention_decoder.SequenceAttentionDecoder.prediction", "torch.softmax", "torch.softmax", "torch.softmax", "feat.view", "query.permute().contiguous.permute().contiguous.new_zeros", "enumerate", "mask.view.view.bool", "mask.view.view.view", "img_meta.get", "query.permute().contiguous.permute().contiguous.permute", "min", "math.ceil"], "methods", ["None"], ["", "def", "forward_test_step", "(", "self", ",", "feat", ",", "out_enc", ",", "decode_sequence", ",", "current_step", ",", "\n", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            decode_sequence (Tensor): Shape :math:`(N, T)`. The tensor that\n                stores history decoding result.\n            current_step (int): Current decoding step.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: Shape :math:`(N, C-1)`. The logit tensor of predicted\n            tokens at current time step.\n        \"\"\"", "\n", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "embed", "=", "self", ".", "embedding", "(", "decode_sequence", ")", "\n", "\n", "n", ",", "c_enc", ",", "h", ",", "w", "=", "out_enc", ".", "size", "(", ")", "\n", "assert", "c_enc", "==", "self", ".", "dim_model", "\n", "_", ",", "c_feat", ",", "_", ",", "_", "=", "feat", ".", "size", "(", ")", "\n", "assert", "c_feat", "==", "self", ".", "dim_input", "\n", "_", ",", "_", ",", "c_q", "=", "embed", ".", "size", "(", ")", "\n", "assert", "c_q", "==", "self", ".", "dim_model", "\n", "\n", "query", ",", "_", "=", "self", ".", "sequence_layer", "(", "embed", ")", "\n", "query", "=", "query", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "key", "=", "out_enc", ".", "view", "(", "n", ",", "c_enc", ",", "h", "*", "w", ")", "\n", "if", "self", ".", "encode_value", ":", "\n", "            ", "value", "=", "key", "\n", "", "else", ":", "\n", "            ", "value", "=", "feat", ".", "view", "(", "n", ",", "c_feat", ",", "h", "*", "w", ")", "\n", "\n", "", "mask", "=", "None", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "mask", "=", "query", ".", "new_zeros", "(", "(", "n", ",", "h", ",", "w", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", ",", "valid_width", ":", "]", "=", "1", "\n", "", "mask", "=", "mask", ".", "bool", "(", ")", "\n", "mask", "=", "mask", ".", "view", "(", "n", ",", "h", "*", "w", ")", "\n", "\n", "# [n, c, l]", "\n", "", "attn_out", "=", "self", ".", "attention_layer", "(", "query", ",", "key", ",", "value", ",", "mask", ")", "\n", "\n", "out", "=", "attn_out", "[", ":", ",", ":", ",", "current_step", "]", "\n", "\n", "if", "self", ".", "return_feature", ":", "\n", "            ", "return", "out", "\n", "\n", "", "out", "=", "self", ".", "prediction", "(", "out", ")", "\n", "out", "=", "F", ".", "softmax", "(", "out", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.__init__": [[20, 27], ["mmocr.is_type_list", "mmocr.is_type_list", "mmocr.equal_len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.equal_len"], ["def", "__init__", "(", "self", ",", "indexes", "=", "[", "1", "]", ",", "scores", "=", "[", "0.9", "]", ")", ":", "\n", "        ", "assert", "utils", ".", "is_type_list", "(", "indexes", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "scores", ",", "float", ")", "\n", "assert", "utils", ".", "equal_len", "(", "indexes", ",", "scores", ")", "\n", "\n", "self", ".", "indexes", "=", "indexes", "\n", "self", ".", "scores", "=", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval": [[28, 32], ["sum"], "methods", ["None"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "\"\"\"Calculate accumulated score.\"\"\"", "\n", "accu_score", "=", "sum", "(", "self", ".", "scores", ")", "\n", "return", "accu_score", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.ParallelSARDecoderWithBS.__init__": [[42, 80], ["ParallelSARDecoder.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "beam_width", "=", "5", ",", "\n", "num_classes", "=", "37", ",", "\n", "enc_bi_rnn", "=", "False", ",", "\n", "dec_bi_rnn", "=", "False", ",", "\n", "dec_do_rnn", "=", "0", ",", "\n", "dec_gru", "=", "False", ",", "\n", "d_model", "=", "512", ",", "\n", "d_enc", "=", "512", ",", "\n", "d_k", "=", "64", ",", "\n", "pred_dropout", "=", "0.0", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "mask", "=", "True", ",", "\n", "start_idx", "=", "0", ",", "\n", "padding_idx", "=", "0", ",", "\n", "pred_concat", "=", "False", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "num_classes", ",", "\n", "enc_bi_rnn", ",", "\n", "dec_bi_rnn", ",", "\n", "dec_do_rnn", ",", "\n", "dec_gru", ",", "\n", "d_model", ",", "\n", "d_enc", ",", "\n", "d_k", ",", "\n", "pred_dropout", ",", "\n", "max_seq_len", ",", "\n", "mask", ",", "\n", "start_idx", ",", "\n", "padding_idx", ",", "\n", "pred_concat", ",", "\n", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "beam_width", ",", "int", ")", "\n", "assert", "beam_width", ">", "0", "\n", "\n", "self", ".", "beam_width", "=", "beam_width", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.ParallelSARDecoderWithBS.forward_test": [[81, 163], ["mmocr.is_type_list", "feat.size", "torch.full", "torch.full", "torch.full", "torch.full", "sar_decoder_with_bs.ParallelSARDecoderWithBS.embedding", "start_token.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "out_enc.unsqueeze.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "queue.PriorityQueue", "sar_decoder_with_bs.DecodeNode", "queue.PriorityQueue.put", "range", "queue.PriorityQueue.get", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "len", "feat.size", "range", "img_meta.get", "start_token.unsqueeze().expand.unsqueeze().expand.unsqueeze", "queue.PriorityQueue.get", "torch.clone", "torch.clone", "torch.clone", "torch.clone", "enumerate", "sar_decoder_with_bs.ParallelSARDecoderWithBS._2d_attention", "torch.softmax", "torch.softmax", "torch.softmax.topk", "range", "queue.PriorityQueue.empty", "queue.PriorityQueue.get", "queue.PriorityQueue.put", "sar_decoder_with_bs.DecodeNode.eval", "torch.full", "torch.full", "torch.full", "torch.full", "sar_decoder_with_bs.ParallelSARDecoderWithBS.embedding", "topk_value.squeeze", "topk_idx.squeeze", "topk_value[].item", "topk_idx[].item", "sar_decoder_with_bs.DecodeNode", "next_nodes.append", "node.eval"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder.SequentialSARDecoder._2d_attention", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "feat", ".", "size", "(", "0", ")", "\n", "\n", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "seq_len", "=", "self", ".", "max_seq_len", "\n", "bsz", "=", "feat", ".", "size", "(", "0", ")", "\n", "assert", "bsz", "==", "1", ",", "'batch size must be 1 for beam search.'", "\n", "\n", "start_token", "=", "torch", ".", "full", "(", "(", "bsz", ",", ")", ",", "\n", "self", ".", "start_idx", ",", "\n", "device", "=", "feat", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "# bsz", "\n", "start_token", "=", "self", ".", "embedding", "(", "start_token", ")", "\n", "# bsz * emb_dim", "\n", "start_token", "=", "start_token", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "seq_len", ",", "-", "1", ")", "\n", "# bsz * seq_len * emb_dim", "\n", "out_enc", "=", "out_enc", ".", "unsqueeze", "(", "1", ")", "\n", "# bsz * 1 * emb_dim", "\n", "decoder_input", "=", "torch", ".", "cat", "(", "(", "out_enc", ",", "start_token", ")", ",", "dim", "=", "1", ")", "\n", "# bsz * (seq_len + 1) * emb_dim", "\n", "\n", "# Initialize beam-search queue", "\n", "q", "=", "PriorityQueue", "(", ")", "\n", "init_node", "=", "DecodeNode", "(", "[", "self", ".", "start_idx", "]", ",", "[", "0.0", "]", ")", "\n", "q", ".", "put", "(", "(", "-", "init_node", ".", "eval", "(", ")", ",", "init_node", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "seq_len", "+", "1", ")", ":", "\n", "            ", "next_nodes", "=", "[", "]", "\n", "beam_width", "=", "self", ".", "beam_width", "if", "i", ">", "1", "else", "1", "\n", "for", "_", "in", "range", "(", "beam_width", ")", ":", "\n", "                ", "_", ",", "node", "=", "q", ".", "get", "(", ")", "\n", "\n", "input_seq", "=", "torch", ".", "clone", "(", "decoder_input", ")", "# bsz * T * emb_dim", "\n", "# fill previous input tokens (step 1...i) in input_seq", "\n", "for", "t", ",", "index", "in", "enumerate", "(", "node", ".", "indexes", ")", ":", "\n", "                    ", "input_token", "=", "torch", ".", "full", "(", "(", "bsz", ",", ")", ",", "\n", "index", ",", "\n", "device", "=", "input_seq", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "input_token", "=", "self", ".", "embedding", "(", "input_token", ")", "# bsz * emb_dim", "\n", "input_seq", "[", ":", ",", "t", "+", "1", ",", ":", "]", "=", "input_token", "\n", "\n", "", "output_seq", "=", "self", ".", "_2d_attention", "(", "\n", "input_seq", ",", "feat", ",", "out_enc", ",", "valid_ratios", "=", "valid_ratios", ")", "\n", "\n", "output_char", "=", "output_seq", "[", ":", ",", "i", ",", ":", "]", "# bsz * num_classes", "\n", "output_char", "=", "F", ".", "softmax", "(", "output_char", ",", "-", "1", ")", "\n", "topk_value", ",", "topk_idx", "=", "output_char", ".", "topk", "(", "self", ".", "beam_width", ",", "dim", "=", "1", ")", "\n", "topk_value", ",", "topk_idx", "=", "topk_value", ".", "squeeze", "(", "0", ")", ",", "topk_idx", ".", "squeeze", "(", "\n", "0", ")", "\n", "\n", "for", "k", "in", "range", "(", "self", ".", "beam_width", ")", ":", "\n", "                    ", "kth_score", "=", "topk_value", "[", "k", "]", ".", "item", "(", ")", "\n", "kth_idx", "=", "topk_idx", "[", "k", "]", ".", "item", "(", ")", "\n", "next_node", "=", "DecodeNode", "(", "node", ".", "indexes", "+", "[", "kth_idx", "]", ",", "\n", "node", ".", "scores", "+", "[", "kth_score", "]", ")", "\n", "delta", "=", "k", "*", "1e-6", "\n", "next_nodes", ".", "append", "(", "\n", "(", "-", "node", ".", "eval", "(", ")", "-", "kth_score", "-", "delta", ",", "next_node", ")", ")", "\n", "# Use minus since priority queue sort", "\n", "# with ascending order", "\n", "\n", "", "", "while", "not", "q", ".", "empty", "(", ")", ":", "\n", "                ", "q", ".", "get", "(", ")", "\n", "\n", "# Put all candidates to queue", "\n", "", "for", "next_node", "in", "next_nodes", ":", "\n", "                ", "q", ".", "put", "(", "next_node", ")", "\n", "\n", "", "", "best_node", "=", "q", ".", "get", "(", ")", "\n", "num_classes", "=", "self", ".", "num_classes", "-", "1", "# ignore padding index", "\n", "outputs", "=", "torch", ".", "zeros", "(", "bsz", ",", "seq_len", ",", "num_classes", ")", "\n", "for", "i", "in", "range", "(", "seq_len", ")", ":", "\n", "            ", "idx", "=", "best_node", "[", "1", "]", ".", "indexes", "[", "i", "+", "1", "]", "\n", "outputs", "[", "0", ",", "i", ",", "idx", "]", "=", "best_node", "[", "1", "]", ".", "scores", "[", "i", "+", "1", "]", "\n", "\n", "", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.base_decoder.BaseDecoder.__init__": [[11, 13], ["mmcv.runner.BaseModule.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "init_cfg", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.base_decoder.BaseDecoder.forward_train": [[14, 16], ["None"], "methods", ["None"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.base_decoder.BaseDecoder.forward_test": [[17, 19], ["None"], "methods", ["None"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.base_decoder.BaseDecoder.forward": [[20, 31], ["base_decoder.BaseDecoder.forward_test", "base_decoder.BaseDecoder.forward_train"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train"], ["", "def", "forward", "(", "self", ",", "\n", "feat", ",", "\n", "out_enc", ",", "\n", "targets_dict", "=", "None", ",", "\n", "img_metas", "=", "None", ",", "\n", "train_mode", "=", "True", ")", ":", "\n", "        ", "self", ".", "train_mode", "=", "train_mode", "\n", "if", "train_mode", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", "\n", "\n", "", "return", "self", ".", "forward_test", "(", "feat", ",", "out_enc", ",", "img_metas", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder.__init__": [[35, 72], ["dict", "base_decoder.BaseDecoder.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "mmocr.models.common.modules.PositionalEncoding", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "abinet_vision_decoder.ABIVisionDecoder._decoder_layer", "abinet_vision_decoder.ABIVisionDecoder._decoder_layer", "abinet_vision_decoder.ABIVisionDecoder._decoder_layer", "abinet_vision_decoder.ABIVisionDecoder._decoder_layer"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._encoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._decoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._decoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._decoder_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._decoder_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "512", ",", "\n", "num_channels", "=", "64", ",", "\n", "attn_height", "=", "8", ",", "\n", "attn_width", "=", "32", ",", "\n", "attn_mode", "=", "'nearest'", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "num_chars", "=", "90", ",", "\n", "init_cfg", "=", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "\n", "# For mini-Unet", "\n", "self", ".", "k_encoder", "=", "nn", ".", "Sequential", "(", "\n", "self", ".", "_encoder_layer", "(", "in_channels", ",", "num_channels", ",", "stride", "=", "(", "1", ",", "2", ")", ")", ",", "\n", "self", ".", "_encoder_layer", "(", "num_channels", ",", "num_channels", ",", "stride", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "self", ".", "_encoder_layer", "(", "num_channels", ",", "num_channels", ",", "stride", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "self", ".", "_encoder_layer", "(", "num_channels", ",", "num_channels", ",", "stride", "=", "(", "2", ",", "2", ")", ")", ")", "\n", "\n", "self", ".", "k_decoder", "=", "nn", ".", "Sequential", "(", "\n", "self", ".", "_decoder_layer", "(", "\n", "num_channels", ",", "num_channels", ",", "scale_factor", "=", "2", ",", "mode", "=", "attn_mode", ")", ",", "\n", "self", ".", "_decoder_layer", "(", "\n", "num_channels", ",", "num_channels", ",", "scale_factor", "=", "2", ",", "mode", "=", "attn_mode", ")", ",", "\n", "self", ".", "_decoder_layer", "(", "\n", "num_channels", ",", "num_channels", ",", "scale_factor", "=", "2", ",", "mode", "=", "attn_mode", ")", ",", "\n", "self", ".", "_decoder_layer", "(", "\n", "num_channels", ",", "\n", "in_channels", ",", "\n", "size", "=", "(", "attn_height", ",", "attn_width", ")", ",", "\n", "mode", "=", "attn_mode", ")", ")", "\n", "\n", "self", ".", "pos_encoder", "=", "PositionalEncoding", "(", "in_channels", ",", "max_seq_len", ")", "\n", "self", ".", "project", "=", "nn", ".", "Linear", "(", "in_channels", ",", "in_channels", ")", "\n", "self", ".", "cls", "=", "nn", ".", "Linear", "(", "in_channels", ",", "num_chars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder.forward_train": [[73, 125], ["feat.size", "range", "range", "feat.new_zeros", "abinet_vision_decoder.ABIVisionDecoder.pos_encoder", "abinet_vision_decoder.ABIVisionDecoder.project", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "v.permute().view.permute().view.permute().view", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "abinet_vision_decoder.ABIVisionDecoder.cls", "len", "features.append", "k.flatten", "torch.softmax.view", "torch.softmax.view", "len", "v.permute().view.permute().view.permute", "len"], "methods", ["None"], ["", "def", "forward_train", "(", "self", ",", "\n", "feat", ",", "\n", "out_enc", "=", "None", ",", "\n", "targets_dict", "=", "None", ",", "\n", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Image features of shape (N, E, H, W).\n\n        Returns:\n            dict: A dict with keys ``feature``, ``logits`` and ``attn_scores``.\n\n            - | feature (Tensor): Shape (N, T, E). Raw visual features for\n                language decoder.\n            - | logits (Tensor): Shape (N, T, C). The raw logits for\n                characters.\n            - | attn_scores (Tensor): Shape (N, T, H, W). Intermediate result\n                for vision-language aligner.\n        \"\"\"", "\n", "# Position Attention", "\n", "N", ",", "E", ",", "H", ",", "W", "=", "feat", ".", "size", "(", ")", "\n", "k", ",", "v", "=", "feat", ",", "feat", "# (N, E, H, W)", "\n", "\n", "# Apply mini U-Net on k", "\n", "features", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "k_encoder", ")", ")", ":", "\n", "            ", "k", "=", "self", ".", "k_encoder", "[", "i", "]", "(", "k", ")", "\n", "features", ".", "append", "(", "k", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "k_decoder", ")", "-", "1", ")", ":", "\n", "            ", "k", "=", "self", ".", "k_decoder", "[", "i", "]", "(", "k", ")", "\n", "k", "=", "k", "+", "features", "[", "len", "(", "self", ".", "k_decoder", ")", "-", "2", "-", "i", "]", "\n", "", "k", "=", "self", ".", "k_decoder", "[", "-", "1", "]", "(", "k", ")", "\n", "\n", "# q = positional encoding", "\n", "zeros", "=", "feat", ".", "new_zeros", "(", "(", "N", ",", "self", ".", "max_seq_len", ",", "E", ")", ")", "# (N, T, E)", "\n", "q", "=", "self", ".", "pos_encoder", "(", "zeros", ")", "# (N, T, E)", "\n", "q", "=", "self", ".", "project", "(", "q", ")", "# (N, T, E)", "\n", "\n", "# Attention encoding", "\n", "attn_scores", "=", "torch", ".", "bmm", "(", "q", ",", "k", ".", "flatten", "(", "2", ",", "3", ")", ")", "# (N, T, (H*W))", "\n", "attn_scores", "=", "attn_scores", "/", "(", "E", "**", "0.5", ")", "\n", "attn_scores", "=", "torch", ".", "softmax", "(", "attn_scores", ",", "dim", "=", "-", "1", ")", "\n", "v", "=", "v", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "view", "(", "N", ",", "-", "1", ",", "E", ")", "# (N, (H*W), E)", "\n", "attn_vecs", "=", "torch", ".", "bmm", "(", "attn_scores", ",", "v", ")", "# (N, T, E)", "\n", "\n", "logits", "=", "self", ".", "cls", "(", "attn_vecs", ")", "\n", "result", "=", "{", "\n", "'feature'", ":", "attn_vecs", ",", "\n", "'logits'", ":", "logits", ",", "\n", "'attn_scores'", ":", "attn_scores", ".", "view", "(", "N", ",", "-", "1", ",", "H", ",", "W", ")", "\n", "}", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder.forward_test": [[126, 128], ["abinet_vision_decoder.ABIVisionDecoder.forward_train"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", "=", "None", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "forward_train", "(", "feat", ",", "out_enc", "=", "out_enc", ",", "img_metas", "=", "img_metas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._encoder_layer": [[129, 143], ["mmcv.cnn.ConvModule", "dict", "dict"], "methods", ["None"], ["", "def", "_encoder_layer", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", ":", "\n", "        ", "return", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_vision_decoder.ABIVisionDecoder._decoder_layer": [[144, 168], ["torch.Sequential", "torch.Sequential", "torch.Upsample", "torch.Upsample", "mmcv.cnn.ConvModule", "dict", "dict"], "methods", ["None"], ["", "def", "_decoder_layer", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "mode", "=", "'nearest'", ",", "\n", "scale_factor", "=", "None", ",", "\n", "size", "=", "None", ")", ":", "\n", "        ", "align_corners", "=", "None", "if", "mode", "==", "'nearest'", "else", "True", "\n", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Upsample", "(", "\n", "size", "=", "size", ",", "\n", "scale_factor", "=", "scale_factor", ",", "\n", "mode", "=", "mode", ",", "\n", "align_corners", "=", "align_corners", ")", ",", "\n", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.__init__": [[42, 80], ["base_decoder.BaseDecoder.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "mmocr.models.common.PositionalEncoding", "torch.Dropout", "torch.Dropout", "torch.Dropout", "mmcv.runner.ModuleList", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.Linear", "torch.Linear", "torch.Linear", "mmocr.models.common.TFDecoderLayer", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_layers", "=", "6", ",", "\n", "d_embedding", "=", "512", ",", "\n", "n_head", "=", "8", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "d_model", "=", "512", ",", "\n", "d_inner", "=", "256", ",", "\n", "n_position", "=", "200", ",", "\n", "dropout", "=", "0.1", ",", "\n", "num_classes", "=", "93", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "start_idx", "=", "1", ",", "\n", "padding_idx", "=", "92", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "padding_idx", "=", "padding_idx", "\n", "self", ".", "start_idx", "=", "start_idx", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "\n", "self", ".", "trg_word_emb", "=", "nn", ".", "Embedding", "(", "\n", "num_classes", ",", "d_embedding", ",", "padding_idx", "=", "padding_idx", ")", "\n", "\n", "self", ".", "position_enc", "=", "PositionalEncoding", "(", "\n", "d_embedding", ",", "n_position", "=", "n_position", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n", "self", ".", "layer_stack", "=", "ModuleList", "(", "[", "\n", "TFDecoderLayer", "(", "\n", "d_model", ",", "d_inner", ",", "n_head", ",", "d_k", ",", "d_v", ",", "dropout", "=", "dropout", ",", "**", "kwargs", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "\n", "]", ")", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ",", "eps", "=", "1e-6", ")", "\n", "\n", "pred_num_class", "=", "num_classes", "-", "1", "# ignore padding_idx", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "d_model", ",", "pred_num_class", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.get_pad_mask": [[81, 85], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_pad_mask", "(", "seq", ",", "pad_idx", ")", ":", "\n", "\n", "        ", "return", "(", "seq", "!=", "pad_idx", ")", ".", "unsqueeze", "(", "-", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.get_subsequent_mask": [[86, 95], ["seq.size", "subsequent_mask.unsqueeze().bool.unsqueeze().bool.unsqueeze().bool", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.triu", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "subsequent_mask.unsqueeze().bool.unsqueeze().bool.unsqueeze"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_subsequent_mask", "(", "seq", ")", ":", "\n", "        ", "\"\"\"For masking out the subsequent info.\"\"\"", "\n", "len_s", "=", "seq", ".", "size", "(", "1", ")", "\n", "subsequent_mask", "=", "1", "-", "torch", ".", "triu", "(", "\n", "torch", ".", "ones", "(", "(", "len_s", ",", "len_s", ")", ",", "device", "=", "seq", ".", "device", ")", ",", "diagonal", "=", "1", ")", "\n", "subsequent_mask", "=", "subsequent_mask", ".", "unsqueeze", "(", "0", ")", ".", "bool", "(", ")", "\n", "\n", "return", "subsequent_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder._attention": [[96, 114], ["nrtr_decoder.NRTRDecoder.trg_word_emb", "nrtr_decoder.NRTRDecoder.position_enc", "nrtr_decoder.NRTRDecoder.dropout", "nrtr_decoder.NRTRDecoder.layer_norm", "nrtr_decoder.NRTRDecoder.get_pad_mask", "nrtr_decoder.NRTRDecoder.get_subsequent_mask", "dec_layer"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.get_pad_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.get_subsequent_mask"], ["", "def", "_attention", "(", "self", ",", "trg_seq", ",", "src", ",", "src_mask", "=", "None", ")", ":", "\n", "        ", "trg_embedding", "=", "self", ".", "trg_word_emb", "(", "trg_seq", ")", "\n", "trg_pos_encoded", "=", "self", ".", "position_enc", "(", "trg_embedding", ")", "\n", "tgt", "=", "self", ".", "dropout", "(", "trg_pos_encoded", ")", "\n", "\n", "trg_mask", "=", "self", ".", "get_pad_mask", "(", "\n", "trg_seq", ",", "\n", "pad_idx", "=", "self", ".", "padding_idx", ")", "&", "self", ".", "get_subsequent_mask", "(", "trg_seq", ")", "\n", "output", "=", "tgt", "\n", "for", "dec_layer", "in", "self", ".", "layer_stack", ":", "\n", "            ", "output", "=", "dec_layer", "(", "\n", "output", ",", "\n", "src", ",", "\n", "self_attn_mask", "=", "trg_mask", ",", "\n", "dec_enc_attn_mask", "=", "src_mask", ")", "\n", "", "output", "=", "self", ".", "layer_norm", "(", "output", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder._get_mask": [[115, 130], ["logit.size", "logit.new_zeros", "enumerate", "img_meta.get", "min", "math.ceil"], "methods", ["None"], ["", "def", "_get_mask", "(", "self", ",", "logit", ",", "img_metas", ")", ":", "\n", "        ", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "\n", "", "N", ",", "T", ",", "_", "=", "logit", ".", "size", "(", ")", "\n", "mask", "=", "None", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "mask", "=", "logit", ".", "new_zeros", "(", "(", "N", ",", "T", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "T", ",", "math", ".", "ceil", "(", "T", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", "valid_width", "]", "=", "1", "\n", "\n", "", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.forward_train": [[131, 152], ["nrtr_decoder.NRTRDecoder._get_mask", "targets_dict[].to", "nrtr_decoder.NRTRDecoder._attention", "nrtr_decoder.NRTRDecoder.classifier"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.nrtr_encoder.NRTREncoder._get_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder._attention"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "r\"\"\"\n        Args:\n            feat (None): Unused.\n            out_enc (Tensor): Encoder output of shape :math:`(N, T, D_m)`\n                where :math:`D_m` is ``d_model``.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: The raw logit tensor. Shape :math:`(N, T, C)`.\n        \"\"\"", "\n", "src_mask", "=", "self", ".", "_get_mask", "(", "out_enc", ",", "img_metas", ")", "\n", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", ".", "to", "(", "out_enc", ".", "device", ")", "\n", "attn_output", "=", "self", ".", "_attention", "(", "targets", ",", "out_enc", ",", "src_mask", "=", "src_mask", ")", "\n", "outputs", "=", "self", ".", "classifier", "(", "attn_output", ")", "\n", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder.forward_test": [[153, 178], ["nrtr_decoder.NRTRDecoder._get_mask", "out_enc.size", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "nrtr_decoder.NRTRDecoder._attention", "torch.softmax", "torch.softmax", "torch.softmax", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "nrtr_decoder.NRTRDecoder.classifier"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.nrtr_encoder.NRTREncoder._get_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.nrtr_decoder.NRTRDecoder._attention"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "src_mask", "=", "self", ".", "_get_mask", "(", "out_enc", ",", "img_metas", ")", "\n", "N", "=", "out_enc", ".", "size", "(", "0", ")", "\n", "init_target_seq", "=", "torch", ".", "full", "(", "(", "N", ",", "self", ".", "max_seq_len", "+", "1", ")", ",", "\n", "self", ".", "padding_idx", ",", "\n", "device", "=", "out_enc", ".", "device", ",", "\n", "dtype", "=", "torch", ".", "long", ")", "\n", "# bsz * seq_len", "\n", "init_target_seq", "[", ":", ",", "0", "]", "=", "self", ".", "start_idx", "\n", "\n", "outputs", "=", "[", "]", "\n", "for", "step", "in", "range", "(", "0", ",", "self", ".", "max_seq_len", ")", ":", "\n", "            ", "decoder_output", "=", "self", ".", "_attention", "(", "\n", "init_target_seq", ",", "out_enc", ",", "src_mask", "=", "src_mask", ")", "\n", "# bsz * seq_len * C", "\n", "step_result", "=", "F", ".", "softmax", "(", "\n", "self", ".", "classifier", "(", "decoder_output", "[", ":", ",", "step", ",", ":", "]", ")", ",", "dim", "=", "-", "1", ")", "\n", "# bsz * num_classes", "\n", "outputs", ".", "append", "(", "step_result", ")", "\n", "_", ",", "step_max_index", "=", "torch", ".", "max", "(", "step_result", ",", "dim", "=", "-", "1", ")", "\n", "init_target_seq", "[", ":", ",", "step", "+", "1", "]", "=", "step_max_index", "\n", "\n", "", "outputs", "=", "torch", ".", "stack", "(", "outputs", ",", "dim", "=", "1", ")", "\n", "\n", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder.__init__": [[38, 91], ["base_decoder.BaseDecoder.__init__", "torch.Linear", "torch.Linear", "mmocr.models.common.modules.PositionalEncoding", "mmocr.models.common.modules.PositionalEncoding", "mmcv.cnn.bricks.transformer.BaseTransformerLayer", "mmcv.runner.ModuleList", "torch.Linear", "torch.Linear", "dict", "dict", "dict", "copy.deepcopy", "range", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "d_model", "=", "512", ",", "\n", "n_head", "=", "8", ",", "\n", "d_inner", "=", "2048", ",", "\n", "n_layers", "=", "4", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "dropout", "=", "0.1", ",", "\n", "detach_tokens", "=", "True", ",", "\n", "num_chars", "=", "90", ",", "\n", "use_self_attn", "=", "False", ",", "\n", "pad_idx", "=", "0", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "detach_tokens", "=", "detach_tokens", "\n", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "\n", "self", ".", "proj", "=", "nn", ".", "Linear", "(", "num_chars", ",", "d_model", ",", "False", ")", "\n", "self", ".", "token_encoder", "=", "PositionalEncoding", "(", "\n", "d_model", ",", "n_position", "=", "self", ".", "max_seq_len", ",", "dropout", "=", "0.1", ")", "\n", "self", ".", "pos_encoder", "=", "PositionalEncoding", "(", "\n", "d_model", ",", "n_position", "=", "self", ".", "max_seq_len", ")", "\n", "self", ".", "pad_idx", "=", "pad_idx", "\n", "\n", "if", "use_self_attn", ":", "\n", "            ", "operation_order", "=", "(", "'self_attn'", ",", "'norm'", ",", "'cross_attn'", ",", "'norm'", ",", "\n", "'ffn'", ",", "'norm'", ")", "\n", "", "else", ":", "\n", "            ", "operation_order", "=", "(", "'cross_attn'", ",", "'norm'", ",", "'ffn'", ",", "'norm'", ")", "\n", "\n", "", "decoder_layer", "=", "BaseTransformerLayer", "(", "\n", "operation_order", "=", "operation_order", ",", "\n", "attn_cfgs", "=", "dict", "(", "\n", "type", "=", "'MultiheadAttention'", ",", "\n", "embed_dims", "=", "d_model", ",", "\n", "num_heads", "=", "n_head", ",", "\n", "attn_drop", "=", "dropout", ",", "\n", "dropout_layer", "=", "dict", "(", "type", "=", "'Dropout'", ",", "drop_prob", "=", "dropout", ")", ",", "\n", ")", ",", "\n", "ffn_cfgs", "=", "dict", "(", "\n", "type", "=", "'FFN'", ",", "\n", "embed_dims", "=", "d_model", ",", "\n", "feedforward_channels", "=", "d_inner", ",", "\n", "ffn_drop", "=", "dropout", ",", "\n", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'LN'", ")", ",", "\n", ")", "\n", "self", ".", "decoder_layers", "=", "ModuleList", "(", "\n", "[", "copy", ".", "deepcopy", "(", "decoder_layer", ")", "for", "_", "in", "range", "(", "n_layers", ")", "]", ")", "\n", "\n", "self", ".", "cls", "=", "nn", ".", "Linear", "(", "d_model", ",", "num_chars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder.forward_train": [[92, 131], ["abinet_language_decoder.ABILanguageDecoder._get_length", "abinet_language_decoder.ABILanguageDecoder.clamp_", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "abinet_language_decoder.ABILanguageDecoder.proj", "abinet_language_decoder.ABILanguageDecoder.token_encoder", "abinet_language_decoder.ABILanguageDecoder._get_padding_mask", "embed.permute.permute.new_zeros", "abinet_language_decoder.ABILanguageDecoder.pos_encoder", "query.permute.permute.permute", "embed.permute.permute.permute", "abinet_language_decoder.ABILanguageDecoder._get_location_mask", "m.permute", "abinet_language_decoder.ABILanguageDecoder.cls", "tokens.detach.detach.detach", "m"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder._get_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder._get_padding_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder._get_location_mask"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "logits", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            logits (Tensor): Raw language logitis. Shape (N, T, C).\n\n        Returns:\n            A dict with keys ``feature`` and ``logits``.\n            feature (Tensor): Shape (N, T, E). Raw textual features for vision\n                language aligner.\n            logits (Tensor): Shape (N, T, C). The raw logits for characters\n                after spell correction.\n        \"\"\"", "\n", "lengths", "=", "self", ".", "_get_length", "(", "logits", ")", "\n", "lengths", ".", "clamp_", "(", "2", ",", "self", ".", "max_seq_len", ")", "\n", "tokens", "=", "torch", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "if", "self", ".", "detach_tokens", ":", "\n", "            ", "tokens", "=", "tokens", ".", "detach", "(", ")", "\n", "", "embed", "=", "self", ".", "proj", "(", "tokens", ")", "# (N, T, E)", "\n", "embed", "=", "self", ".", "token_encoder", "(", "embed", ")", "# (N, T, E)", "\n", "padding_mask", "=", "self", ".", "_get_padding_mask", "(", "lengths", ",", "self", ".", "max_seq_len", ")", "\n", "\n", "zeros", "=", "embed", ".", "new_zeros", "(", "*", "embed", ".", "shape", ")", "\n", "query", "=", "self", ".", "pos_encoder", "(", "zeros", ")", "\n", "query", "=", "query", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# (T, N, E)", "\n", "embed", "=", "embed", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "location_mask", "=", "self", ".", "_get_location_mask", "(", "self", ".", "max_seq_len", ",", "\n", "tokens", ".", "device", ")", "\n", "output", "=", "query", "\n", "for", "m", "in", "self", ".", "decoder_layers", ":", "\n", "            ", "output", "=", "m", "(", "\n", "query", "=", "output", ",", "\n", "key", "=", "embed", ",", "\n", "value", "=", "embed", ",", "\n", "attn_masks", "=", "location_mask", ",", "\n", "key_padding_mask", "=", "padding_mask", ")", "\n", "", "output", "=", "output", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "# (N, T, E)", "\n", "\n", "logits", "=", "self", ".", "cls", "(", "output", ")", "# (N, T, C)", "\n", "return", "{", "'feature'", ":", "output", ",", "'logits'", ":", "logits", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder.forward_test": [[132, 134], ["abinet_language_decoder.ABILanguageDecoder.forward_train"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "return", "self", ".", "forward_train", "(", "feat", ",", "out_enc", ",", "None", ",", "img_metas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder._get_length": [[135, 149], ["torch.where.any", "torch.where.any", "torch.where", "torch.where", "torch.where", "torch.where", "logit.argmax", "torch.where.new_tensor", "torch.where.new_tensor", "torch.where.cumsum", "torch.where.cumsum"], "methods", ["None"], ["", "def", "_get_length", "(", "self", ",", "logit", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"Greedy decoder to obtain length from logit.\n\n        Returns the first location of padding index or the length of the entire\n        tensor otherwise.\n        \"\"\"", "\n", "# out as a boolean vector indicating the existence of end token(s)", "\n", "out", "=", "(", "logit", ".", "argmax", "(", "dim", "=", "-", "1", ")", "==", "self", ".", "pad_idx", ")", "\n", "abn", "=", "out", ".", "any", "(", "dim", ")", "\n", "# Get the first index of end token", "\n", "out", "=", "(", "(", "out", ".", "cumsum", "(", "dim", ")", "==", "1", ")", "&", "out", ")", ".", "max", "(", "dim", ")", "[", "1", "]", "\n", "out", "=", "out", "+", "1", "\n", "out", "=", "torch", ".", "where", "(", "abn", ",", "out", ",", "out", ".", "new_tensor", "(", "logit", ".", "shape", "[", "1", "]", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder._get_location_mask": [[150, 166], ["torch.eye", "torch.eye", "torch.eye", "torch.eye", "mask.float().masked_fill.float().masked_fill.float().masked_fill", "float", "mask.float().masked_fill.float().masked_fill.float"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_location_mask", "(", "seq_len", ",", "device", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate location masks given input sequence length.\n\n        Args:\n            seq_len (int): The length of input sequence to transformer.\n            device (torch.device or str, optional): The device on which the\n                masks will be placed.\n\n        Returns:\n            Tensor: A mask tensor of shape (seq_len, seq_len) with -infs on\n            diagonal and zeros elsewhere.\n        \"\"\"", "\n", "mask", "=", "torch", ".", "eye", "(", "seq_len", ",", "device", "=", "device", ")", "\n", "mask", "=", "mask", ".", "float", "(", ")", ".", "masked_fill", "(", "mask", "==", "1", ",", "float", "(", "'-inf'", ")", ")", "\n", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.abinet_language_decoder.ABILanguageDecoder._get_padding_mask": [[167, 182], ["length.unsqueeze.unsqueeze.unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_get_padding_mask", "(", "length", ",", "max_length", ")", ":", "\n", "        ", "\"\"\"Generate padding masks.\n\n        Args:\n            length (Tensor): Shape :math:`(N,)`.\n            max_length (int): The maximum sequence length :math:`T`.\n\n        Returns:\n            Tensor: A bool tensor of shape :math:`(N, T)` with Trues on\n            elements located over the length, or Falses elsewhere.\n        \"\"\"", "\n", "length", "=", "length", ".", "unsqueeze", "(", "-", "1", ")", "\n", "grid", "=", "torch", ".", "arange", "(", "0", ",", "max_length", ",", "device", "=", "length", ".", "device", ")", ".", "unsqueeze", "(", "0", ")", "\n", "return", "grid", ">=", "length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.position_attention_decoder.PositionAttentionDecoder.__init__": [[42, 74], ["base_decoder.BaseDecoder.__init__", "torch.Embedding", "torch.Embedding", "mmocr.models.textrecog.layers.PositionAwareLayer", "mmocr.models.textrecog.layers.DotProductAttentionLayer", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_classes", "=", "None", ",", "\n", "rnn_layers", "=", "2", ",", "\n", "dim_input", "=", "512", ",", "\n", "dim_model", "=", "128", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "mask", "=", "True", ",", "\n", "return_feature", "=", "False", ",", "\n", "encode_value", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "dim_input", "=", "dim_input", "\n", "self", ".", "dim_model", "=", "dim_model", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "return_feature", "=", "return_feature", "\n", "self", ".", "encode_value", "=", "encode_value", "\n", "self", ".", "mask", "=", "mask", "\n", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "self", ".", "max_seq_len", "+", "1", ",", "self", ".", "dim_model", ")", "\n", "\n", "self", ".", "position_aware_module", "=", "PositionAwareLayer", "(", "\n", "self", ".", "dim_model", ",", "rnn_layers", ")", "\n", "\n", "self", ".", "attention_layer", "=", "DotProductAttentionLayer", "(", ")", "\n", "\n", "self", ".", "prediction", "=", "None", "\n", "if", "not", "self", ".", "return_feature", ":", "\n", "            ", "pred_num_classes", "=", "num_classes", "-", "1", "\n", "self", ".", "prediction", "=", "nn", ".", "Linear", "(", "\n", "dim_model", "if", "encode_value", "else", "dim_input", ",", "pred_num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.position_attention_decoder.PositionAttentionDecoder._get_position_index": [[75, 80], ["torch.arange", "torch.arange", "torch.arange", "torch.arange", "position_index.long.long.repeat", "position_index.long.long.long"], "methods", ["None"], ["", "", "def", "_get_position_index", "(", "self", ",", "length", ",", "batch_size", ",", "device", "=", "None", ")", ":", "\n", "        ", "position_index", "=", "torch", ".", "arange", "(", "0", ",", "length", ",", "device", "=", "device", ")", "\n", "position_index", "=", "position_index", ".", "repeat", "(", "[", "batch_size", ",", "1", "]", ")", "\n", "position_index", "=", "position_index", ".", "long", "(", ")", "\n", "return", "position_index", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.position_attention_decoder.PositionAttentionDecoder.forward_train": [[81, 141], ["targets_dict[].to", "out_enc.size", "feat.size", "targets_dict[].to.size", "position_attention_decoder.PositionAttentionDecoder._get_position_index", "position_attention_decoder.PositionAttentionDecoder.position_aware_module", "position_attention_decoder.PositionAttentionDecoder.embedding", "query.permute().contiguous.permute().contiguous.permute().contiguous", "position_attention_decoder.PositionAttentionDecoder.view", "position_attention_decoder.PositionAttentionDecoder.attention_layer", "attn_out.permute().contiguous.permute().contiguous.permute().contiguous", "position_attention_decoder.PositionAttentionDecoder.prediction", "out_enc.view", "feat.view", "query.permute().contiguous.permute().contiguous.new_zeros", "enumerate", "mask.view.view.bool", "mask.view.view.view", "img_meta.get", "query.permute().contiguous.permute().contiguous.permute", "min", "attn_out.permute().contiguous.permute().contiguous.permute", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.position_attention_decoder.PositionAttentionDecoder._get_position_index"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)` if\n            ``return_feature=False``. Otherwise it will be the hidden feature\n            before the prediction projection layer, whose shape is\n            :math:`(N, T, D_m)`.\n        \"\"\"", "\n", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "targets", "=", "targets_dict", "[", "'padded_targets'", "]", ".", "to", "(", "feat", ".", "device", ")", "\n", "\n", "#", "\n", "n", ",", "c_enc", ",", "h", ",", "w", "=", "out_enc", ".", "size", "(", ")", "\n", "assert", "c_enc", "==", "self", ".", "dim_model", "\n", "_", ",", "c_feat", ",", "_", ",", "_", "=", "feat", ".", "size", "(", ")", "\n", "assert", "c_feat", "==", "self", ".", "dim_input", "\n", "_", ",", "len_q", "=", "targets", ".", "size", "(", ")", "\n", "assert", "len_q", "<=", "self", ".", "max_seq_len", "\n", "\n", "position_index", "=", "self", ".", "_get_position_index", "(", "len_q", ",", "n", ",", "feat", ".", "device", ")", "\n", "\n", "position_out_enc", "=", "self", ".", "position_aware_module", "(", "out_enc", ")", "\n", "\n", "query", "=", "self", ".", "embedding", "(", "position_index", ")", "\n", "query", "=", "query", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "key", "=", "position_out_enc", ".", "view", "(", "n", ",", "c_enc", ",", "h", "*", "w", ")", "\n", "if", "self", ".", "encode_value", ":", "\n", "            ", "value", "=", "out_enc", ".", "view", "(", "n", ",", "c_enc", ",", "h", "*", "w", ")", "\n", "", "else", ":", "\n", "            ", "value", "=", "feat", ".", "view", "(", "n", ",", "c_feat", ",", "h", "*", "w", ")", "\n", "\n", "", "mask", "=", "None", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "mask", "=", "query", ".", "new_zeros", "(", "(", "n", ",", "h", ",", "w", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", ",", "valid_width", ":", "]", "=", "1", "\n", "", "mask", "=", "mask", ".", "bool", "(", ")", "\n", "mask", "=", "mask", ".", "view", "(", "n", ",", "h", "*", "w", ")", "\n", "\n", "", "attn_out", "=", "self", ".", "attention_layer", "(", "query", ",", "key", ",", "value", ",", "mask", ")", "\n", "attn_out", "=", "attn_out", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "# [n, len_q, dim_v]", "\n", "\n", "if", "self", ".", "return_feature", ":", "\n", "            ", "return", "attn_out", "\n", "\n", "", "return", "self", ".", "prediction", "(", "attn_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.position_attention_decoder.PositionAttentionDecoder.forward_test": [[142, 195], ["out_enc.size", "feat.size", "position_attention_decoder.PositionAttentionDecoder._get_position_index", "position_attention_decoder.PositionAttentionDecoder.position_aware_module", "position_attention_decoder.PositionAttentionDecoder.embedding", "query.permute().contiguous.permute().contiguous.permute().contiguous", "position_attention_decoder.PositionAttentionDecoder.view", "position_attention_decoder.PositionAttentionDecoder.attention_layer", "attn_out.permute().contiguous.permute().contiguous.permute().contiguous", "position_attention_decoder.PositionAttentionDecoder.prediction", "out_enc.view", "feat.view", "query.permute().contiguous.permute().contiguous.new_zeros", "enumerate", "mask.view.view.bool", "mask.view.view.view", "img_meta.get", "query.permute().contiguous.permute().contiguous.permute", "min", "attn_out.permute().contiguous.permute().contiguous.permute", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.position_attention_decoder.PositionAttentionDecoder._get_position_index"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            out_enc (Tensor): Encoder output of shape\n                :math:`(N, D_m, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A raw logit tensor of shape :math:`(N, T, C-1)` if\n            ``return_feature=False``. Otherwise it would be the hidden feature\n            before the prediction projection layer, whose shape is\n            :math:`(N, T, D_m)`.\n        \"\"\"", "\n", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "seq_len", "=", "self", ".", "max_seq_len", "\n", "n", ",", "c_enc", ",", "h", ",", "w", "=", "out_enc", ".", "size", "(", ")", "\n", "assert", "c_enc", "==", "self", ".", "dim_model", "\n", "_", ",", "c_feat", ",", "_", ",", "_", "=", "feat", ".", "size", "(", ")", "\n", "assert", "c_feat", "==", "self", ".", "dim_input", "\n", "\n", "position_index", "=", "self", ".", "_get_position_index", "(", "seq_len", ",", "n", ",", "feat", ".", "device", ")", "\n", "\n", "position_out_enc", "=", "self", ".", "position_aware_module", "(", "out_enc", ")", "\n", "\n", "query", "=", "self", ".", "embedding", "(", "position_index", ")", "\n", "query", "=", "query", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "key", "=", "position_out_enc", ".", "view", "(", "n", ",", "c_enc", ",", "h", "*", "w", ")", "\n", "if", "self", ".", "encode_value", ":", "\n", "            ", "value", "=", "out_enc", ".", "view", "(", "n", ",", "c_enc", ",", "h", "*", "w", ")", "\n", "", "else", ":", "\n", "            ", "value", "=", "feat", ".", "view", "(", "n", ",", "c_feat", ",", "h", "*", "w", ")", "\n", "\n", "", "mask", "=", "None", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "mask", "=", "query", ".", "new_zeros", "(", "(", "n", ",", "h", ",", "w", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", ",", "valid_width", ":", "]", "=", "1", "\n", "", "mask", "=", "mask", ".", "bool", "(", ")", "\n", "mask", "=", "mask", ".", "view", "(", "n", ",", "h", "*", "w", ")", "\n", "\n", "", "attn_out", "=", "self", ".", "attention_layer", "(", "query", ",", "key", ",", "value", ",", "mask", ")", "\n", "attn_out", "=", "attn_out", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "if", "self", ".", "return_feature", ":", "\n", "            ", "return", "attn_out", "\n", "\n", "", "return", "self", ".", "prediction", "(", "attn_out", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.Embeddings.__init__": [[23, 27], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "d_model", ",", "vocab", ")", ":", "\n", "        ", "super", "(", "Embeddings", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "lut", "=", "nn", ".", "Embedding", "(", "vocab", ",", "d_model", ")", "\n", "self", ".", "d_model", "=", "d_model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.Embeddings.forward": [[28, 31], ["master_decoder.Embeddings.lut", "math.sqrt"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "input", ")", ":", "\n", "        ", "x", "=", "input", "[", "0", "]", "\n", "return", "self", ".", "lut", "(", "x", ")", "*", "math", ".", "sqrt", "(", "self", ".", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.__init__": [[57, 113], ["base_decoder.BaseDecoder.__init__", "mmcv.cnn.bricks.transformer.BaseTransformerLayer", "mmcv.runner.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "master_decoder.Embeddings", "mmocr.models.common.modules.PositionalEncoding", "mmocr.models.common.modules.PositionalEncoding", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "dict", "dict", "dict", "copy.deepcopy", "range", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "start_idx", ",", "\n", "padding_idx", ",", "\n", "num_classes", "=", "93", ",", "\n", "n_layers", "=", "3", ",", "\n", "n_head", "=", "8", ",", "\n", "d_model", "=", "512", ",", "\n", "feat_size", "=", "6", "*", "40", ",", "\n", "d_inner", "=", "2048", ",", "\n", "attn_drop", "=", "0.", ",", "\n", "ffn_drop", "=", "0.", ",", "\n", "feat_pe_drop", "=", "0.2", ",", "\n", "max_seq_len", "=", "30", ",", "\n", "init_cfg", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "MasterDecoder", ",", "self", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "operation_order", "=", "(", "'norm'", ",", "'self_attn'", ",", "'norm'", ",", "'cross_attn'", ",", "'norm'", ",", "\n", "'ffn'", ")", "\n", "decoder_layer", "=", "BaseTransformerLayer", "(", "\n", "operation_order", "=", "operation_order", ",", "\n", "attn_cfgs", "=", "dict", "(", "\n", "type", "=", "'MultiheadAttention'", ",", "\n", "embed_dims", "=", "d_model", ",", "\n", "num_heads", "=", "n_head", ",", "\n", "attn_drop", "=", "attn_drop", ",", "\n", "dropout_layer", "=", "dict", "(", "type", "=", "'Dropout'", ",", "drop_prob", "=", "attn_drop", ")", ",", "\n", ")", ",", "\n", "ffn_cfgs", "=", "dict", "(", "\n", "type", "=", "'FFN'", ",", "\n", "embed_dims", "=", "d_model", ",", "\n", "feedforward_channels", "=", "d_inner", ",", "\n", "ffn_drop", "=", "ffn_drop", ",", "\n", "dropout_layer", "=", "dict", "(", "type", "=", "'Dropout'", ",", "drop_prob", "=", "ffn_drop", ")", ",", "\n", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'LN'", ")", ",", "\n", "batch_first", "=", "True", ",", "\n", ")", "\n", "self", ".", "decoder_layers", "=", "ModuleList", "(", "\n", "[", "copy", ".", "deepcopy", "(", "decoder_layer", ")", "for", "_", "in", "range", "(", "n_layers", ")", "]", ")", "\n", "\n", "self", ".", "cls", "=", "nn", ".", "Linear", "(", "d_model", ",", "num_classes", ")", "\n", "\n", "self", ".", "SOS", "=", "start_idx", "\n", "self", ".", "PAD", "=", "padding_idx", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "feat_size", "=", "feat_size", "\n", "self", ".", "n_head", "=", "n_head", "\n", "\n", "self", ".", "embedding", "=", "Embeddings", "(", "d_model", "=", "d_model", ",", "vocab", "=", "num_classes", ")", "\n", "self", ".", "positional_encoding", "=", "PositionalEncoding", "(", "\n", "d_hid", "=", "d_model", ",", "n_position", "=", "self", ".", "max_seq_len", "+", "1", ")", "\n", "self", ".", "feat_positional_encoding", "=", "PositionalEncoding", "(", "\n", "d_hid", "=", "d_model", ",", "n_position", "=", "self", ".", "feat_size", ",", "dropout", "=", "feat_pe_drop", ")", "\n", "self", ".", "norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.make_mask": [[114, 138], ["tgt.size", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "torch.tril", "tgt_mask.view.view.clone", "tgt_mask.view.view.float().masked_fill_", "tgt_mask.view.view.masked_fill_", "tgt_mask.view.view.repeat", "tgt_mask.view.view.view", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "tgt_mask.view.view.float"], "methods", ["None"], ["", "def", "make_mask", "(", "self", ",", "tgt", ",", "device", ")", ":", "\n", "        ", "\"\"\"Make mask for self attention.\n\n        Args:\n            tgt (Tensor): Shape [N, l_tgt]\n            device (torch.Device): Mask device.\n\n        Returns:\n            Tensor: Mask of shape [N * self.n_head, l_tgt, l_tgt]\n        \"\"\"", "\n", "\n", "trg_pad_mask", "=", "(", "tgt", "!=", "self", ".", "PAD", ")", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "3", ")", ".", "bool", "(", ")", "\n", "tgt_len", "=", "tgt", ".", "size", "(", "1", ")", "\n", "trg_sub_mask", "=", "torch", ".", "tril", "(", "\n", "torch", ".", "ones", "(", "(", "tgt_len", ",", "tgt_len", ")", ",", "dtype", "=", "torch", ".", "bool", ",", "device", "=", "device", ")", ")", "\n", "tgt_mask", "=", "trg_pad_mask", "&", "trg_sub_mask", "\n", "\n", "# inverse for mmcv's BaseTransformerLayer", "\n", "tril_mask", "=", "tgt_mask", ".", "clone", "(", ")", "\n", "tgt_mask", "=", "tgt_mask", ".", "float", "(", ")", ".", "masked_fill_", "(", "tril_mask", "==", "0", ",", "-", "1e9", ")", "\n", "tgt_mask", "=", "tgt_mask", ".", "masked_fill_", "(", "tril_mask", ",", "0", ")", "\n", "tgt_mask", "=", "tgt_mask", ".", "repeat", "(", "1", ",", "self", ".", "n_head", ",", "1", ",", "1", ")", "\n", "tgt_mask", "=", "tgt_mask", ".", "view", "(", "-", "1", ",", "tgt_len", ",", "tgt_len", ")", "\n", "return", "tgt_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode": [[139, 148], ["master_decoder.MasterDecoder.embedding", "master_decoder.MasterDecoder.positional_encoding", "master_decoder.MasterDecoder.norm", "master_decoder.MasterDecoder.cls", "layer"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "input", ",", "feature", ",", "src_mask", ",", "tgt_mask", ")", ":", "\n", "        ", "x", "=", "self", ".", "embedding", "(", "input", ")", "\n", "x", "=", "self", ".", "positional_encoding", "(", "x", ")", "\n", "attn_masks", "=", "[", "tgt_mask", ",", "src_mask", "]", "\n", "for", "layer", "in", "self", ".", "decoder_layers", ":", "\n", "            ", "x", "=", "layer", "(", "\n", "query", "=", "x", ",", "key", "=", "feature", ",", "value", "=", "feature", ",", "attn_masks", "=", "attn_masks", ")", "\n", "", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "return", "self", ".", "cls", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.greedy_forward": [[149, 160], ["range", "master_decoder.MasterDecoder.make_mask", "master_decoder.MasterDecoder.decode", "torch.softmax", "torch.softmax", "torch.softmax", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "next_word[].unsqueeze"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.make_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode"], ["", "def", "greedy_forward", "(", "self", ",", "SOS", ",", "feature", ")", ":", "\n", "        ", "input", "=", "SOS", "\n", "output", "=", "None", "\n", "for", "_", "in", "range", "(", "self", ".", "max_seq_len", ")", ":", "\n", "            ", "target_mask", "=", "self", ".", "make_mask", "(", "input", ",", "device", "=", "feature", ".", "device", ")", "\n", "out", "=", "self", ".", "decode", "(", "input", ",", "feature", ",", "None", ",", "target_mask", ")", "\n", "output", "=", "out", "\n", "prob", "=", "F", ".", "softmax", "(", "out", ",", "dim", "=", "-", "1", ")", "\n", "_", ",", "next_word", "=", "torch", ".", "max", "(", "prob", ",", "dim", "=", "-", "1", ")", "\n", "input", "=", "torch", ".", "cat", "(", "[", "input", ",", "next_word", "[", ":", ",", "-", "1", "]", ".", "unsqueeze", "(", "-", "1", ")", "]", ",", "dim", "=", "1", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.forward_train": [[161, 192], ["isinstance", "master_decoder.MasterDecoder.make_mask", "master_decoder.MasterDecoder.decode", "len", "feat.permute.permute.view", "feat.permute.permute.permute", "master_decoder.MasterDecoder.feat_positional_encoding", "targets_dict[].to", "targets_dict.to"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.make_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode"], ["", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): The feature map from backbone of shape\n                :math:`(N, E, H, W)`.\n            out_enc (Tensor): Encoder output.\n            targets_dict (dict): A dict with the key ``padded_targets``, a\n                tensor of shape :math:`(N, T)`. Each element is the index of a\n                character.\n            img_metas: Unused.\n\n        Returns:\n            Tensor: Raw logit tensor of shape :math:`(N, T, C)`.\n        \"\"\"", "\n", "\n", "# flatten 2D feature map", "\n", "if", "len", "(", "feat", ".", "shape", ")", ">", "3", ":", "\n", "            ", "b", ",", "c", ",", "h", ",", "w", "=", "feat", ".", "shape", "\n", "feat", "=", "feat", ".", "view", "(", "b", ",", "c", ",", "h", "*", "w", ")", "\n", "feat", "=", "feat", ".", "permute", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "", "out_enc", "=", "self", ".", "feat_positional_encoding", "(", "feat", ")", "if", "out_enc", "is", "None", "else", "out_enc", "\n", "\n", "device", "=", "feat", ".", "device", "\n", "if", "isinstance", "(", "targets_dict", ",", "dict", ")", ":", "\n", "            ", "padded_targets", "=", "targets_dict", "[", "'padded_targets'", "]", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "            ", "padded_targets", "=", "targets_dict", ".", "to", "(", "device", ")", "\n", "", "src_mask", "=", "None", "\n", "tgt_mask", "=", "self", ".", "make_mask", "(", "padded_targets", ",", "device", "=", "out_enc", ".", "device", ")", "\n", "return", "self", ".", "decode", "(", "padded_targets", ",", "out_enc", ",", "src_mask", ",", "tgt_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.forward_test": [[193, 219], ["torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "torch.zeros().long().to", "SOS.unsqueeze.unsqueeze.unsqueeze", "master_decoder.MasterDecoder.greedy_forward", "len", "feat.permute.permute.view", "feat.permute.permute.permute", "master_decoder.MasterDecoder.feat_positional_encoding", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros().long", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.greedy_forward"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): The feature map from backbone of shape\n                :math:`(N, E, H, W)`.\n            out_enc (Tensor): Encoder output.\n            img_metas: Unused.\n\n        Returns:\n            Tensor: Raw logit tensor of shape :math:`(N, T, C)`.\n        \"\"\"", "\n", "\n", "# flatten 2D feature map", "\n", "if", "len", "(", "feat", ".", "shape", ")", ">", "3", ":", "\n", "            ", "b", ",", "c", ",", "h", ",", "w", "=", "feat", ".", "shape", "\n", "feat", "=", "feat", ".", "view", "(", "b", ",", "c", ",", "h", "*", "w", ")", "\n", "feat", "=", "feat", ".", "permute", "(", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "", "out_enc", "=", "self", ".", "feat_positional_encoding", "(", "feat", ")", "if", "out_enc", "is", "None", "else", "out_enc", "\n", "\n", "batch_size", "=", "out_enc", ".", "shape", "[", "0", "]", "\n", "SOS", "=", "torch", ".", "zeros", "(", "batch_size", ")", ".", "long", "(", ")", ".", "to", "(", "out_enc", ".", "device", ")", "\n", "SOS", "[", ":", "]", "=", "self", ".", "SOS", "\n", "SOS", "=", "SOS", ".", "unsqueeze", "(", "1", ")", "\n", "output", "=", "self", ".", "greedy_forward", "(", "SOS", ",", "out_enc", ")", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.clones": [[16, 19], ["torch.ModuleList", "copy.deepcopy", "range"], "function", ["None"], ["def", "clones", "(", "module", ",", "N", ")", ":", "\n", "    ", "\"\"\"Produce N identical layers.\"\"\"", "\n", "return", "nn", ".", "ModuleList", "(", "[", "copy", ".", "deepcopy", "(", "module", ")", "for", "_", "in", "range", "(", "N", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.crnn_decoder.CRNNDecoder.__init__": [[21, 38], ["dict", "base_decoder.BaseDecoder.__init__", "mmcv.runner.Sequential", "torch.Conv2d", "mmocr.models.textrecog.layers.BidirectionalLSTM", "mmocr.models.textrecog.layers.BidirectionalLSTM"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "None", ",", "\n", "num_classes", "=", "None", ",", "\n", "rnn_flag", "=", "False", ",", "\n", "init_cfg", "=", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "rnn_flag", "=", "rnn_flag", "\n", "\n", "if", "rnn_flag", ":", "\n", "            ", "self", ".", "decoder", "=", "Sequential", "(", "\n", "BidirectionalLSTM", "(", "in_channels", ",", "256", ",", "256", ")", ",", "\n", "BidirectionalLSTM", "(", "256", ",", "256", ",", "num_classes", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "decoder", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "num_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.crnn_decoder.CRNNDecoder.forward_train": [[39, 60], ["feat.size", "feat.squeeze", "x.permute().contiguous.permute().contiguous.permute", "crnn_decoder.CRNNDecoder.decoder", "x.permute().contiguous.permute().contiguous.permute().contiguous", "crnn_decoder.CRNNDecoder.decoder", "x.permute().contiguous.permute().contiguous.permute().contiguous", "x.permute().contiguous.permute().contiguous.size", "x.permute().contiguous.permute().contiguous.view", "x.permute().contiguous.permute().contiguous.permute", "x.permute().contiguous.permute().contiguous.permute"], "methods", ["None"], ["", "", "def", "forward_train", "(", "self", ",", "feat", ",", "out_enc", ",", "targets_dict", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): A Tensor of shape :math:`(N, H, 1, W)`.\n\n        Returns:\n            Tensor: The raw logit tensor. Shape :math:`(N, W, C)` where\n            :math:`C` is ``num_classes``.\n        \"\"\"", "\n", "assert", "feat", ".", "size", "(", "2", ")", "==", "1", ",", "'feature height must be 1'", "\n", "if", "self", ".", "rnn_flag", ":", "\n", "            ", "x", "=", "feat", ".", "squeeze", "(", "2", ")", "# [N, C, W]", "\n", "x", "=", "x", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "# [W, N, C]", "\n", "x", "=", "self", ".", "decoder", "(", "x", ")", "# [W, N, C]", "\n", "outputs", "=", "x", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "decoder", "(", "feat", ")", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "n", ",", "w", ",", "c", ",", "h", "=", "x", ".", "size", "(", ")", "\n", "outputs", "=", "x", ".", "view", "(", "n", ",", "w", ",", "c", "*", "h", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.crnn_decoder.CRNNDecoder.forward_test": [[61, 71], ["crnn_decoder.CRNNDecoder.forward_train"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train"], ["", "def", "forward_test", "(", "self", ",", "feat", ",", "out_enc", ",", "img_metas", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): A Tensor of shape :math:`(N, H, 1, W)`.\n\n        Returns:\n            Tensor: The raw logit tensor. Shape :math:`(N, W, C)` where\n            :math:`C` is ``num_classes``.\n        \"\"\"", "\n", "return", "self", ".", "forward_train", "(", "feat", ",", "out_enc", ",", "None", ",", "img_metas", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.fc_decoder.FCDecoder.__init__": [[20, 33], ["mmcv.runner.BaseModule.__init__", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_labels", "=", "None", ",", "\n", "hidden_dropout_prob", "=", "0.1", ",", "\n", "hidden_size", "=", "768", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "num_labels", "=", "num_labels", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "hidden_dropout_prob", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "num_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.fc_decoder.FCDecoder.forward": [[34, 42], ["fc_decoder.FCDecoder.dropout", "fc_decoder.FCDecoder.classifier", "torch.softmax", "torch.softmax", "torch.softmax.detach().cpu().numpy", "numpy.argmax().tolist", "torch.softmax.detach().cpu", "numpy.argmax", "torch.softmax.detach"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "sequence_output", "=", "outputs", "[", "0", "]", "\n", "sequence_output", "=", "self", ".", "dropout", "(", "sequence_output", ")", "\n", "logits", "=", "self", ".", "classifier", "(", "sequence_output", ")", "\n", "softmax", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "2", ")", "\n", "preds", "=", "softmax", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "preds", "=", "np", ".", "argmax", "(", "preds", ",", "axis", "=", "2", ")", ".", "tolist", "(", ")", "\n", "return", "logits", ",", "preds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.nrtr_modality_transformer.NRTRModalityTransform.__init__": [[11, 38], ["mmcv.runner.BaseModule.__init__", "torch.Conv2d", "torch.ReLU", "torch.BatchNorm2d", "torch.Conv2d", "torch.ReLU", "torch.BatchNorm2d", "torch.Linear", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "input_channels", "=", "3", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "conv_1", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "input_channels", ",", "\n", "out_channels", "=", "32", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "relu_1", "=", "nn", ".", "ReLU", "(", "True", ")", "\n", "self", ".", "bn_1", "=", "nn", ".", "BatchNorm2d", "(", "32", ")", "\n", "\n", "self", ".", "conv_2", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "32", ",", "\n", "out_channels", "=", "64", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "relu_2", "=", "nn", ".", "ReLU", "(", "True", ")", "\n", "self", ".", "bn_2", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "512", ",", "512", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.nrtr_modality_transformer.NRTRModalityTransform.forward": [[39, 57], ["nrtr_modality_transformer.NRTRModalityTransform.conv_1", "nrtr_modality_transformer.NRTRModalityTransform.relu_1", "nrtr_modality_transformer.NRTRModalityTransform.bn_1", "nrtr_modality_transformer.NRTRModalityTransform.conv_2", "nrtr_modality_transformer.NRTRModalityTransform.relu_2", "nrtr_modality_transformer.NRTRModalityTransform.bn_2", "x.permute().contiguous().view.permute().contiguous().view.size", "x.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "nrtr_modality_transformer.NRTRModalityTransform.linear", "x.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "x.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "x.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "x.permute().contiguous().view.permute().contiguous().view.permute", "x.permute().contiguous().view.permute().contiguous().view.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv_1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn_1", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv_2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn_2", "(", "x", ")", "\n", "\n", "n", ",", "c", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "3", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "n", ",", "w", ",", "h", "*", "c", ")", "\n", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "n", ",", "-", "1", ",", "1", ",", "w", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.very_deep_vgg.VeryDeepVgg.__init__": [[18, 65], ["mmcv.runner.BaseModule.__init__", "mmcv.runner.Sequential", "very_deep_vgg.VeryDeepVgg.__init__.conv_relu"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "leaky_relu", "=", "True", ",", "\n", "input_channels", "=", "3", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "ks", "=", "[", "3", ",", "3", ",", "3", ",", "3", ",", "3", ",", "3", ",", "2", "]", "\n", "ps", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", "]", "\n", "ss", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "\n", "nm", "=", "[", "64", ",", "128", ",", "256", ",", "256", ",", "512", ",", "512", ",", "512", "]", "\n", "\n", "self", ".", "channels", "=", "nm", "\n", "\n", "# cnn = nn.Sequential()", "\n", "cnn", "=", "Sequential", "(", ")", "\n", "\n", "def", "conv_relu", "(", "i", ",", "batch_normalization", "=", "False", ")", ":", "\n", "            ", "n_in", "=", "input_channels", "if", "i", "==", "0", "else", "nm", "[", "i", "-", "1", "]", "\n", "n_out", "=", "nm", "[", "i", "]", "\n", "cnn", ".", "add_module", "(", "'conv{0}'", ".", "format", "(", "i", ")", ",", "\n", "nn", ".", "Conv2d", "(", "n_in", ",", "n_out", ",", "ks", "[", "i", "]", ",", "ss", "[", "i", "]", ",", "ps", "[", "i", "]", ")", ")", "\n", "if", "batch_normalization", ":", "\n", "                ", "cnn", ".", "add_module", "(", "'batchnorm{0}'", ".", "format", "(", "i", ")", ",", "nn", ".", "BatchNorm2d", "(", "n_out", ")", ")", "\n", "", "if", "leaky_relu", ":", "\n", "                ", "cnn", ".", "add_module", "(", "'relu{0}'", ".", "format", "(", "i", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", ")", "\n", "", "else", ":", "\n", "                ", "cnn", ".", "add_module", "(", "'relu{0}'", ".", "format", "(", "i", ")", ",", "nn", ".", "ReLU", "(", "True", ")", ")", "\n", "\n", "", "", "conv_relu", "(", "0", ")", "\n", "cnn", ".", "add_module", "(", "'pooling{0}'", ".", "format", "(", "0", ")", ",", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ")", "# 64x16x64", "\n", "conv_relu", "(", "1", ")", "\n", "cnn", ".", "add_module", "(", "'pooling{0}'", ".", "format", "(", "1", ")", ",", "nn", ".", "MaxPool2d", "(", "2", ",", "2", ")", ")", "# 128x8x32", "\n", "conv_relu", "(", "2", ",", "True", ")", "\n", "conv_relu", "(", "3", ")", "\n", "cnn", ".", "add_module", "(", "'pooling{0}'", ".", "format", "(", "2", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "(", "2", ",", "2", ")", ",", "(", "2", ",", "1", ")", ",", "(", "0", ",", "1", ")", ")", ")", "# 256x4x16", "\n", "conv_relu", "(", "4", ",", "True", ")", "\n", "conv_relu", "(", "5", ")", "\n", "cnn", ".", "add_module", "(", "'pooling{0}'", ".", "format", "(", "3", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "(", "2", ",", "2", ")", ",", "(", "2", ",", "1", ")", ",", "(", "0", ",", "1", ")", ")", ")", "# 512x2x16", "\n", "conv_relu", "(", "6", ",", "True", ")", "# 512x1x16", "\n", "\n", "self", ".", "cnn", "=", "cnn", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.very_deep_vgg.VeryDeepVgg.out_channels": [[66, 68], ["None"], "methods", ["None"], ["", "def", "out_channels", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "channels", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.very_deep_vgg.VeryDeepVgg.forward": [[69, 80], ["very_deep_vgg.VeryDeepVgg.cnn"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (Tensor): Images of shape :math:`(N, C, H, W)`.\n\n        Returns:\n            Tensor: The feature Tensor of shape :math:`(N, 512, H/32, (W/4+1)`.\n        \"\"\"", "\n", "output", "=", "self", ".", "cnn", "(", "x", ")", "\n", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.shallow_cnn.ShallowCNN.__init__": [[23, 53], ["mmcv.runner.BaseModule.__init__", "isinstance", "isinstance", "mmcv.cnn.ConvModule", "mmcv.cnn.ConvModule", "torch.MaxPool2d", "dict", "dict", "dict", "dict", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "input_channels", "=", "1", ",", "\n", "hidden_dim", "=", "512", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "input_channels", ",", "int", ")", "\n", "assert", "isinstance", "(", "hidden_dim", ",", "int", ")", "\n", "\n", "self", ".", "conv1", "=", "ConvModule", "(", "\n", "input_channels", ",", "\n", "hidden_dim", "//", "2", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "self", ".", "conv2", "=", "ConvModule", "(", "\n", "hidden_dim", "//", "2", ",", "\n", "hidden_dim", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "self", ".", "pool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.shallow_cnn.ShallowCNN.forward": [[54, 70], ["shallow_cnn.ShallowCNN.conv1", "shallow_cnn.ShallowCNN.pool", "shallow_cnn.ShallowCNN.conv2", "shallow_cnn.ShallowCNN.pool"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (Tensor): Input image feature :math:`(N, D_i, H, W)`.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, D_m, H/4, W/4)`.\n        \"\"\"", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "pool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "pool", "(", "x", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet_abi.ResNetABI.__init__": [[28, 71], ["mmcv.runner.BaseModule.__init__", "isinstance", "isinstance", "mmocr.is_type_list", "mmocr.is_type_list", "isinstance", "resnet_abi.ResNetABI._make_stem_layer", "enumerate", "dict", "dict", "len", "len", "isinstance", "resnet_abi.ResNetABI._make_layer", "resnet_abi.ResNetABI.add_module", "resnet_abi.ResNetABI.res_layers.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_stem_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "32", ",", "\n", "base_channels", "=", "32", ",", "\n", "arch_settings", "=", "[", "3", ",", "4", ",", "6", ",", "6", ",", "3", "]", ",", "\n", "strides", "=", "[", "2", ",", "1", ",", "2", ",", "1", ",", "1", "]", ",", "\n", "out_indices", "=", "None", ",", "\n", "last_stage_pool", "=", "False", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Constant'", ",", "val", "=", "1", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "assert", "isinstance", "(", "stem_channels", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "arch_settings", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "strides", ",", "int", ")", "\n", "assert", "len", "(", "arch_settings", ")", "==", "len", "(", "strides", ")", "\n", "assert", "out_indices", "is", "None", "or", "isinstance", "(", "out_indices", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "last_stage_pool", ",", "bool", ")", "\n", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "self", ".", "last_stage_pool", "=", "last_stage_pool", "\n", "self", ".", "block", "=", "BasicBlock", "\n", "self", ".", "inplanes", "=", "stem_channels", "\n", "\n", "self", ".", "_make_stem_layer", "(", "in_channels", ",", "stem_channels", ")", "\n", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "planes", "=", "base_channels", "\n", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "arch_settings", ")", ":", "\n", "            ", "stride", "=", "strides", "[", "i", "]", "\n", "res_layer", "=", "self", ".", "_make_layer", "(", "\n", "block", "=", "self", ".", "block", ",", "\n", "inplanes", "=", "self", ".", "inplanes", ",", "\n", "planes", "=", "planes", ",", "\n", "blocks", "=", "num_blocks", ",", "\n", "stride", "=", "stride", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "self", ".", "block", ".", "expansion", "\n", "planes", "*=", "2", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet_abi.ResNetABI._make_layer": [[72, 92], ["layers.append", "range", "mmcv.runner.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.BatchNorm2d", "block"], "methods", ["None"], ["", "", "def", "_make_layer", "(", "self", ",", "block", ",", "inplanes", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "inplanes", "!=", "planes", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "1", ",", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", ")", ",", "\n", ")", "\n", "", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "use_conv1x1", "=", "True", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ")", ")", "\n", "inplanes", "=", "planes", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "inplanes", ",", "planes", ",", "use_conv1x1", "=", "True", ")", ")", "\n", "\n", "", "return", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet_abi.ResNetABI._make_stem_layer": [[93, 98], ["torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["None"], ["", "def", "_make_stem_layer", "(", "self", ",", "in_channels", ",", "stem_channels", ")", ":", "\n", "        ", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "stem_channels", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "stem_channels", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet_abi.ResNetABI.forward": [[99, 122], ["resnet_abi.ResNetABI.conv1", "resnet_abi.ResNetABI.bn1", "resnet_abi.ResNetABI.relu1", "enumerate", "getattr", "getattr.", "tuple", "outs.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (Tensor): Image tensor of shape :math:`(N, 3, H, W)`.\n\n        Returns:\n            Tensor or list[Tensor]: Feature tensor. Its shape depends on\n            ResNetABI's config. It can be a list of feature outputs at specific\n            layers if ``out_indices`` is specified.\n        \"\"\"", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "res_layers", ")", ":", "\n", "            ", "res_layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "x", "=", "res_layer", "(", "x", ")", "\n", "if", "self", ".", "out_indices", "and", "i", "in", "self", ".", "out_indices", ":", "\n", "                ", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "", "return", "tuple", "(", "outs", ")", "if", "self", ".", "out_indices", "else", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet31_ocr.ResNet31OCR.__init__": [[24, 92], ["dict", "mmcv.runner.BaseModule.__init__", "isinstance", "mmocr.is_type_list", "mmocr.is_type_list", "isinstance", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.MaxPool2d", "resnet31_ocr.ResNet31OCR._make_layer", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.MaxPool2d", "resnet31_ocr.ResNet31OCR._make_layer", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.MaxPool2d", "resnet31_ocr.ResNet31OCR._make_layer", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "resnet31_ocr.ResNet31OCR._make_layer", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "dict", "dict", "isinstance", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer"], ["def", "__init__", "(", "self", ",", "\n", "base_channels", "=", "3", ",", "\n", "layers", "=", "[", "1", ",", "2", ",", "5", ",", "3", "]", ",", "\n", "channels", "=", "[", "64", ",", "128", ",", "256", ",", "256", ",", "512", ",", "512", ",", "512", "]", ",", "\n", "out_indices", "=", "None", ",", "\n", "stage4_pool_cfg", "=", "dict", "(", "kernel_size", "=", "(", "2", ",", "1", ")", ",", "stride", "=", "(", "2", ",", "1", ")", ")", ",", "\n", "last_stage_pool", "=", "False", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "base_channels", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "layers", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "channels", ",", "int", ")", "\n", "assert", "out_indices", "is", "None", "or", "isinstance", "(", "out_indices", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "last_stage_pool", ",", "bool", ")", "\n", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "self", ".", "last_stage_pool", "=", "last_stage_pool", "\n", "\n", "# conv 1 (Conv, Conv)", "\n", "self", ".", "conv1_1", "=", "nn", ".", "Conv2d", "(", "\n", "base_channels", ",", "channels", "[", "0", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "channels", "[", "0", "]", ")", "\n", "self", ".", "relu1_1", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "self", ".", "conv1_2", "=", "nn", ".", "Conv2d", "(", "\n", "channels", "[", "0", "]", ",", "channels", "[", "1", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn1_2", "=", "nn", ".", "BatchNorm2d", "(", "channels", "[", "1", "]", ")", "\n", "self", ".", "relu1_2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# conv 2 (Max-pooling, Residual block, Conv)", "\n", "self", ".", "pool2", "=", "nn", ".", "MaxPool2d", "(", "\n", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "ceil_mode", "=", "True", ")", "\n", "self", ".", "block2", "=", "self", ".", "_make_layer", "(", "channels", "[", "1", "]", ",", "channels", "[", "2", "]", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "\n", "channels", "[", "2", "]", ",", "channels", "[", "2", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "channels", "[", "2", "]", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# conv 3 (Max-pooling, Residual block, Conv)", "\n", "self", ".", "pool3", "=", "nn", ".", "MaxPool2d", "(", "\n", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "ceil_mode", "=", "True", ")", "\n", "self", ".", "block3", "=", "self", ".", "_make_layer", "(", "channels", "[", "2", "]", ",", "channels", "[", "3", "]", ",", "layers", "[", "1", "]", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "\n", "channels", "[", "3", "]", ",", "channels", "[", "3", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "channels", "[", "3", "]", ")", "\n", "self", ".", "relu3", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# conv 4 (Max-pooling, Residual block, Conv)", "\n", "self", ".", "pool4", "=", "nn", ".", "MaxPool2d", "(", "padding", "=", "0", ",", "ceil_mode", "=", "True", ",", "**", "stage4_pool_cfg", ")", "\n", "self", ".", "block4", "=", "self", ".", "_make_layer", "(", "channels", "[", "3", "]", ",", "channels", "[", "4", "]", ",", "layers", "[", "2", "]", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "\n", "channels", "[", "4", "]", ",", "channels", "[", "4", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm2d", "(", "channels", "[", "4", "]", ")", "\n", "self", ".", "relu4", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "# conv 5 ((Max-pooling), Residual block, Conv)", "\n", "self", ".", "pool5", "=", "None", "\n", "if", "self", ".", "last_stage_pool", ":", "\n", "            ", "self", ".", "pool5", "=", "nn", ".", "MaxPool2d", "(", "\n", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "ceil_mode", "=", "True", ")", "# 1/16", "\n", "", "self", ".", "block5", "=", "self", ".", "_make_layer", "(", "channels", "[", "4", "]", ",", "channels", "[", "5", "]", ",", "layers", "[", "3", "]", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv2d", "(", "\n", "channels", "[", "5", "]", ",", "channels", "[", "5", "]", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn5", "=", "nn", ".", "BatchNorm2d", "(", "channels", "[", "5", "]", ")", "\n", "self", ".", "relu5", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet31_ocr.ResNet31OCR._make_layer": [[93, 113], ["range", "mmcv.runner.Sequential", "layers.append", "mmcv.runner.Sequential", "mmocr.models.textrecog.layers.BasicBlock", "torch.Conv2d", "torch.BatchNorm2d"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "input_channels", ",", "output_channels", ",", "blocks", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "blocks", ")", ":", "\n", "            ", "downsample", "=", "None", "\n", "if", "input_channels", "!=", "output_channels", ":", "\n", "                ", "downsample", "=", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "input_channels", ",", "\n", "output_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "output_channels", ")", ",", "\n", ")", "\n", "", "layers", ".", "append", "(", "\n", "BasicBlock", "(", "\n", "input_channels", ",", "output_channels", ",", "downsample", "=", "downsample", ")", ")", "\n", "input_channels", "=", "output_channels", "\n", "\n", "", "return", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet31_ocr.ResNet31OCR.forward": [[114, 146], ["resnet31_ocr.ResNet31OCR.conv1_1", "resnet31_ocr.ResNet31OCR.bn1_1", "resnet31_ocr.ResNet31OCR.relu1_1", "resnet31_ocr.ResNet31OCR.conv1_2", "resnet31_ocr.ResNet31OCR.bn1_2", "resnet31_ocr.ResNet31OCR.relu1_2", "range", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr.", "getattr.", "getattr.", "getattr.", "outs.append", "tuple", "getattr."], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "x", "=", "self", ".", "conv1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv1_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1_2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "layer_index", "=", "i", "+", "2", "\n", "pool_layer", "=", "getattr", "(", "self", ",", "f'pool{layer_index}'", ")", "\n", "block_layer", "=", "getattr", "(", "self", ",", "f'block{layer_index}'", ")", "\n", "conv_layer", "=", "getattr", "(", "self", ",", "f'conv{layer_index}'", ")", "\n", "bn_layer", "=", "getattr", "(", "self", ",", "f'bn{layer_index}'", ")", "\n", "relu_layer", "=", "getattr", "(", "self", ",", "f'relu{layer_index}'", ")", "\n", "\n", "if", "pool_layer", "is", "not", "None", ":", "\n", "                ", "x", "=", "pool_layer", "(", "x", ")", "\n", "", "x", "=", "block_layer", "(", "x", ")", "\n", "x", "=", "conv_layer", "(", "x", ")", "\n", "x", "=", "bn_layer", "(", "x", ")", "\n", "x", "=", "relu_layer", "(", "x", ")", "\n", "\n", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "out_indices", "is", "not", "None", ":", "\n", "            ", "return", "tuple", "(", "[", "outs", "[", "i", "]", "for", "i", "in", "self", ".", "out_indices", "]", ")", "\n", "\n", "", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.__init__": [[29, 81], ["mmcv.runner.BaseModule.__init__", "isinstance", "mmocr.is_type_list", "mmocr.is_type_list", "resnet.ResNet._make_stem_layer", "len", "enumerate", "dict", "dict", "isinstance", "mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_type_list", "len", "len", "len", "isinstance", "resnet.ResNet._make_layer", "resnet.ResNet.add_module", "resnet.ResNet.res_layers.append", "resnet.ResNet._make_stage_plugins"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_stem_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_stage_plugins"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "stem_channels", ",", "\n", "block_cfgs", ",", "\n", "arch_layers", ",", "\n", "arch_channels", ",", "\n", "strides", ",", "\n", "out_indices", "=", "None", ",", "\n", "plugins", "=", "None", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Constant'", ",", "val", "=", "1", ",", "layer", "=", "'BatchNorm2d'", ")", ",", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "assert", "isinstance", "(", "stem_channels", ",", "int", ")", "or", "utils", ".", "is_type_list", "(", "\n", "stem_channels", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "arch_layers", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "arch_channels", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "strides", ",", "tuple", ")", "or", "utils", ".", "is_type_list", "(", "\n", "strides", ",", "int", ")", "\n", "assert", "len", "(", "arch_layers", ")", "==", "len", "(", "arch_channels", ")", "==", "len", "(", "strides", ")", "\n", "assert", "out_indices", "is", "None", "or", "isinstance", "(", "out_indices", ",", "(", "list", ",", "tuple", ")", ")", "\n", "\n", "self", ".", "out_indices", "=", "out_indices", "\n", "self", ".", "_make_stem_layer", "(", "in_channels", ",", "stem_channels", ")", "\n", "self", ".", "num_stages", "=", "len", "(", "arch_layers", ")", "\n", "self", ".", "use_plugins", "=", "False", "\n", "self", ".", "arch_channels", "=", "arch_channels", "\n", "self", ".", "res_layers", "=", "[", "]", "\n", "if", "plugins", "is", "not", "None", ":", "\n", "            ", "self", ".", "plugin_ahead_names", "=", "[", "]", "\n", "self", ".", "plugin_after_names", "=", "[", "]", "\n", "self", ".", "use_plugins", "=", "True", "\n", "", "for", "i", ",", "num_blocks", "in", "enumerate", "(", "arch_layers", ")", ":", "\n", "            ", "stride", "=", "strides", "[", "i", "]", "\n", "channel", "=", "arch_channels", "[", "i", "]", "\n", "\n", "if", "self", ".", "use_plugins", ":", "\n", "                ", "self", ".", "_make_stage_plugins", "(", "plugins", ",", "stage_idx", "=", "i", ")", "\n", "\n", "", "res_layer", "=", "self", ".", "_make_layer", "(", "\n", "block_cfgs", "=", "block_cfgs", ",", "\n", "inplanes", "=", "self", ".", "inplanes", ",", "\n", "planes", "=", "channel", ",", "\n", "blocks", "=", "num_blocks", ",", "\n", "stride", "=", "stride", ",", "\n", ")", "\n", "self", ".", "inplanes", "=", "channel", "\n", "layer_name", "=", "f'layer{i + 1}'", "\n", "self", ".", "add_module", "(", "layer_name", ",", "res_layer", ")", "\n", "self", ".", "res_layers", ".", "append", "(", "layer_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_layer": [[82, 116], ["block_cfgs.copy", "isinstance", "layers.append", "range", "mmcv.runner.Sequential", "mmcv.cnn.ConvModule", "block_cfgs.copy.pop", "ValueError", "block", "layers.append", "block", "dict"], "methods", ["None"], ["", "", "def", "_make_layer", "(", "self", ",", "block_cfgs", ",", "inplanes", ",", "planes", ",", "blocks", ",", "stride", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "downsample", "=", "None", "\n", "block_cfgs_", "=", "block_cfgs", ".", "copy", "(", ")", "\n", "if", "isinstance", "(", "stride", ",", "int", ")", ":", "\n", "            ", "stride", "=", "(", "stride", ",", "stride", ")", "\n", "\n", "", "if", "stride", "[", "0", "]", "!=", "1", "or", "stride", "[", "1", "]", "!=", "1", "or", "inplanes", "!=", "planes", ":", "\n", "            ", "downsample", "=", "ConvModule", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "1", ",", "\n", "stride", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "None", ")", "\n", "\n", "", "if", "block_cfgs_", "[", "'type'", "]", "==", "'BasicBlock'", ":", "\n", "            ", "block", "=", "BasicBlock", "\n", "block_cfgs_", ".", "pop", "(", "'type'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'{} not implement yet'", ".", "format", "(", "block", "[", "'type'", "]", ")", ")", "\n", "\n", "", "layers", ".", "append", "(", "\n", "block", "(", "\n", "inplanes", ",", "\n", "planes", ",", "\n", "stride", "=", "stride", ",", "\n", "downsample", "=", "downsample", ",", "\n", "**", "block_cfgs_", ")", ")", "\n", "inplanes", "=", "planes", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "inplanes", ",", "planes", ",", "**", "block_cfgs_", ")", ")", "\n", "\n", "", "return", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_stem_layer": [[117, 135], ["isinstance", "enumerate", "mmcv.runner.Sequential", "mmcv.cnn.ConvModule", "stem_layers.append", "dict", "dict"], "methods", ["None"], ["", "def", "_make_stem_layer", "(", "self", ",", "in_channels", ",", "stem_channels", ")", ":", "\n", "        ", "if", "isinstance", "(", "stem_channels", ",", "int", ")", ":", "\n", "            ", "stem_channels", "=", "[", "stem_channels", "]", "\n", "", "stem_layers", "=", "[", "]", "\n", "for", "_", ",", "channels", "in", "enumerate", "(", "stem_channels", ")", ":", "\n", "            ", "stem_layer", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", "\n", "in_channels", "=", "channels", "\n", "stem_layers", ".", "append", "(", "stem_layer", ")", "\n", "", "self", ".", "stem_layers", "=", "Sequential", "(", "*", "stem_layers", ")", "\n", "self", ".", "inplanes", "=", "stem_channels", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet._make_stage_plugins": [[136, 201], ["resnet.ResNet.plugin_ahead_names.append", "resnet.ResNet.plugin_after_names.append", "plugin.copy.copy.copy", "plugin.copy.copy.pop", "plugin.copy.copy.pop", "len", "mmcv.cnn.build_plugin_layer", "resnet.ResNet.plugin_ahead_names[].append", "resnet.ResNet.add_module", "mmcv.cnn.build_plugin_layer", "resnet.ResNet.plugin_after_names[].append", "resnet.ResNet.add_module", "ValueError"], "methods", ["None"], ["", "def", "_make_stage_plugins", "(", "self", ",", "plugins", ",", "stage_idx", ")", ":", "\n", "        ", "\"\"\"Make plugins for ResNet ``stage_idx`` th stage.\n\n        Currently we support inserting ``nn.Maxpooling``,\n        ``mmcv.cnn.Convmodule``into the backbone. Originally designed\n        for ResNet31-like architectures.\n\n        Examples:\n            >>> plugins=[\n            ...     dict(cfg=dict(type=\"Maxpooling\", arg=(2,2)),\n            ...          stages=(True, True, False, False),\n            ...          position='before_stage'),\n            ...     dict(cfg=dict(type=\"Maxpooling\", arg=(2,1)),\n            ...          stages=(False, False, True, Flase),\n            ...          position='before_stage'),\n            ...     dict(cfg=dict(\n            ...              type='ConvModule',\n            ...              kernel_size=3,\n            ...              stride=1,\n            ...              padding=1,\n            ...              norm_cfg=dict(type='BN'),\n            ...              act_cfg=dict(type='ReLU')),\n            ...          stages=(True, True, True, True),\n            ...          position='after_stage')]\n\n        Suppose ``stage_idx=1``, the structure of stage would be:\n\n        .. code-block:: none\n\n            Maxpooling -> A set of Basicblocks -> ConvModule\n\n        Args:\n            plugins (list[dict]): List of plugins cfg to build.\n            stage_idx (int): Index of stage to build\n\n        Returns:\n            list[dict]: Plugins for current stage\n        \"\"\"", "\n", "in_channels", "=", "self", ".", "arch_channels", "[", "stage_idx", "]", "\n", "self", ".", "plugin_ahead_names", ".", "append", "(", "[", "]", ")", "\n", "self", ".", "plugin_after_names", ".", "append", "(", "[", "]", ")", "\n", "for", "plugin", "in", "plugins", ":", "\n", "            ", "plugin", "=", "plugin", ".", "copy", "(", ")", "\n", "stages", "=", "plugin", ".", "pop", "(", "'stages'", ",", "None", ")", "\n", "position", "=", "plugin", ".", "pop", "(", "'position'", ",", "None", ")", "\n", "assert", "stages", "is", "None", "or", "len", "(", "stages", ")", "==", "self", ".", "num_stages", "\n", "if", "stages", "[", "stage_idx", "]", ":", "\n", "                ", "if", "position", "==", "'before_stage'", ":", "\n", "                    ", "name", ",", "layer", "=", "build_plugin_layer", "(", "\n", "plugin", "[", "'cfg'", "]", ",", "\n", "f'_before_stage_{stage_idx+1}'", ",", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "in_channels", ")", "\n", "self", ".", "plugin_ahead_names", "[", "stage_idx", "]", ".", "append", "(", "name", ")", "\n", "self", ".", "add_module", "(", "name", ",", "layer", ")", "\n", "", "elif", "position", "==", "'after_stage'", ":", "\n", "                    ", "name", ",", "layer", "=", "build_plugin_layer", "(", "\n", "plugin", "[", "'cfg'", "]", ",", "\n", "f'_after_stage_{stage_idx+1}'", ",", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "in_channels", ")", "\n", "self", ".", "plugin_after_names", "[", "stage_idx", "]", ".", "append", "(", "name", ")", "\n", "self", ".", "add_module", "(", "name", ",", "layer", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'uncorrect plugin position'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin": [[202, 207], ["getattr"], "methods", ["None"], ["", "", "", "", "def", "forward_plugin", "(", "self", ",", "x", ",", "plugin_name", ")", ":", "\n", "        ", "out", "=", "x", "\n", "for", "name", "in", "plugin_name", ":", "\n", "            ", "out", "=", "getattr", "(", "self", ",", "name", ")", "(", "out", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward": [[208, 233], ["resnet.ResNet.stem_layers", "enumerate", "getattr", "tuple", "getattr.", "resnet.ResNet.forward_plugin", "getattr.", "resnet.ResNet.forward_plugin", "outs.append", "outs.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.resnet.ResNet.forward_plugin"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args: x (Tensor): Image tensor of shape :math:`(N, 3, H, W)`.\n\n        Returns:\n            Tensor or list[Tensor]: Feature tensor. It can be a list of\n            feature outputs at specific layers if ``out_indices`` is specified.\n        \"\"\"", "\n", "x", "=", "self", ".", "stem_layers", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "i", ",", "layer_name", "in", "enumerate", "(", "self", ".", "res_layers", ")", ":", "\n", "            ", "res_layer", "=", "getattr", "(", "self", ",", "layer_name", ")", "\n", "if", "not", "self", ".", "use_plugins", ":", "\n", "                ", "x", "=", "res_layer", "(", "x", ")", "\n", "if", "self", ".", "out_indices", "and", "i", "in", "self", ".", "out_indices", ":", "\n", "                    ", "outs", ".", "append", "(", "x", ")", "\n", "", "", "else", ":", "\n", "                ", "x", "=", "self", ".", "forward_plugin", "(", "x", ",", "self", ".", "plugin_ahead_names", "[", "i", "]", ")", "\n", "x", "=", "res_layer", "(", "x", ")", "\n", "x", "=", "self", ".", "forward_plugin", "(", "x", ",", "self", ".", "plugin_after_names", "[", "i", "]", ")", "\n", "if", "self", ".", "out_indices", "and", "i", "in", "self", ".", "out_indices", ":", "\n", "                    ", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "", "", "return", "tuple", "(", "outs", ")", "if", "self", ".", "out_indices", "else", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UpConvBlock.__init__": [[51, 100], ["dict", "dict", "dict", "torch.Module.__init__", "conv_block", "mmocr.models.builder.build_upsample_layer", "mmcv.cnn.ConvModule"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_upsample_layer"], ["def", "__init__", "(", "self", ",", "\n", "conv_block", ",", "\n", "in_channels", ",", "\n", "skip_channels", ",", "\n", "out_channels", ",", "\n", "num_convs", "=", "2", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "upsample_cfg", "=", "dict", "(", "type", "=", "'InterpConv'", ")", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "dcn", "is", "None", ",", "'Not implemented yet.'", "\n", "assert", "plugins", "is", "None", ",", "'Not implemented yet.'", "\n", "\n", "self", ".", "conv_block", "=", "conv_block", "(", "\n", "in_channels", "=", "2", "*", "skip_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "num_convs", "=", "num_convs", ",", "\n", "stride", "=", "stride", ",", "\n", "dilation", "=", "dilation", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", "\n", "if", "upsample_cfg", "is", "not", "None", ":", "\n", "            ", "self", ".", "upsample", "=", "build_upsample_layer", "(", "\n", "cfg", "=", "upsample_cfg", ",", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "skip_channels", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "upsample", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "skip_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UpConvBlock.forward": [[101, 109], ["unet.UpConvBlock.upsample", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "unet.UpConvBlock.conv_block"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "skip", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "x", "=", "self", ".", "upsample", "(", "x", ")", "\n", "out", "=", "torch", ".", "cat", "(", "[", "skip", ",", "x", "]", ",", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "conv_block", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.BasicConvBlock.__init__": [[141, 173], ["dict", "dict", "torch.Module.__init__", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "convs.append", "mmcv.cnn.ConvModule"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "num_convs", "=", "2", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "dcn", "is", "None", ",", "'Not implemented yet.'", "\n", "assert", "plugins", "is", "None", ",", "'Not implemented yet.'", "\n", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "convs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_convs", ")", ":", "\n", "            ", "convs", ".", "append", "(", "\n", "ConvModule", "(", "\n", "in_channels", "=", "in_channels", "if", "i", "==", "0", "else", "out_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", "if", "i", "==", "0", "else", "1", ",", "\n", "dilation", "=", "1", "if", "i", "==", "0", "else", "dilation", ",", "\n", "padding", "=", "1", "if", "i", "==", "0", "else", "dilation", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", ")", "\n", "\n", "", "self", ".", "convs", "=", "nn", ".", "Sequential", "(", "*", "convs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.BasicConvBlock.forward": [[174, 182], ["torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "unet.BasicConvBlock.convs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "self", ".", "convs", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "convs", "(", "x", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.DeconvModule.__init__": [[203, 235], ["dict", "dict", "torch.Module.__init__", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "mmcv.cnn.build_norm_layer", "mmocr.models.builder.build_activation_layer", "torch.Sequential", "torch.Sequential", "torch.Sequential"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_activation_layer"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "with_cp", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "*", ",", "\n", "kernel_size", "=", "4", ",", "\n", "scale_factor", "=", "2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "(", "\n", "kernel_size", "-", "scale_factor", ">=", "0", "\n", "and", "(", "kernel_size", "-", "scale_factor", ")", "%", "2", "==", "0", ")", ",", "(", "\n", "f'kernel_size should be greater than or equal to scale_factor '", "\n", "f'and (kernel_size - scale_factor) should be even numbers, '", "\n", "f'while the kernel size is {kernel_size} and scale_factor is '", "\n", "f'{scale_factor}.'", ")", "\n", "\n", "stride", "=", "scale_factor", "\n", "padding", "=", "(", "kernel_size", "-", "scale_factor", ")", "//", "2", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "deconv", "=", "nn", ".", "ConvTranspose2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ")", "\n", "\n", "_", ",", "norm", "=", "build_norm_layer", "(", "norm_cfg", ",", "out_channels", ")", "\n", "activate", "=", "build_activation_layer", "(", "act_cfg", ")", "\n", "self", ".", "deconv_upsamping", "=", "nn", ".", "Sequential", "(", "deconv", ",", "norm", ",", "activate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.DeconvModule.forward": [[236, 244], ["torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "unet.DeconvModule.deconv_upsamping"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "self", ".", "deconv_upsamping", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "deconv_upsamping", "(", "x", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.InterpConv.__init__": [[278, 309], ["dict", "dict", "dict", "torch.Module.__init__", "mmcv.cnn.ConvModule", "torch.Upsample", "torch.Upsample", "torch.Upsample", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "with_cp", "=", "False", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "*", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "conv_first", "=", "False", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "upsample_cfg", "=", "dict", "(", "\n", "scale_factor", "=", "2", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "with_cp", "=", "with_cp", "\n", "conv", "=", "ConvModule", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ")", "\n", "upsample", "=", "nn", ".", "Upsample", "(", "**", "upsample_cfg", ")", "\n", "if", "conv_first", ":", "\n", "            ", "self", ".", "interp_upsample", "=", "nn", ".", "Sequential", "(", "conv", ",", "upsample", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "interp_upsample", "=", "nn", ".", "Sequential", "(", "upsample", ",", "conv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.InterpConv.forward": [[310, 318], ["torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "unet.InterpConv.interp_upsample"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\"\"\"", "\n", "\n", "if", "self", ".", "with_cp", "and", "x", ".", "requires_grad", ":", "\n", "            ", "out", "=", "cp", ".", "checkpoint", "(", "self", ".", "interp_upsample", ",", "x", ")", "\n", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "interp_upsample", "(", "x", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.__init__": [[376, 481], ["dict", "dict", "dict", "mmcv.runner.BaseModule.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "dict", "dict", "len", "len", "len", "len", "len", "len", "enc_conv_block.append", "unet.UNet.encoder.append", "len", "len", "len", "len", "len", "len", "unet.UNet.decoder.append", "unet.BasicConvBlock", "torch.Sequential", "torch.Sequential", "torch.Sequential", "enc_conv_block.append", "unet.UpConvBlock", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "3", ",", "\n", "base_channels", "=", "64", ",", "\n", "num_stages", "=", "5", ",", "\n", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "enc_num_convs", "=", "(", "2", ",", "2", ",", "2", ",", "2", ",", "2", ")", ",", "\n", "dec_num_convs", "=", "(", "2", ",", "2", ",", "2", ",", "2", ")", ",", "\n", "downsamples", "=", "(", "True", ",", "True", ",", "True", ",", "True", ")", ",", "\n", "enc_dilations", "=", "(", "1", ",", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "dec_dilations", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "with_cp", "=", "False", ",", "\n", "conv_cfg", "=", "None", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ",", "\n", "upsample_cfg", "=", "dict", "(", "type", "=", "'InterpConv'", ")", ",", "\n", "norm_eval", "=", "False", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "\n", "type", "=", "'Constant'", ",", "\n", "layer", "=", "[", "'_BatchNorm'", ",", "'GroupNorm'", "]", ",", "\n", "val", "=", "1", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "dcn", "is", "None", ",", "'Not implemented yet.'", "\n", "assert", "plugins", "is", "None", ",", "'Not implemented yet.'", "\n", "assert", "len", "(", "strides", ")", "==", "num_stages", ",", "(", "\n", "'The length of strides should be equal to num_stages, '", "\n", "f'while the strides is {strides}, the length of '", "\n", "f'strides is {len(strides)}, and the num_stages is '", "\n", "f'{num_stages}.'", ")", "\n", "assert", "len", "(", "enc_num_convs", ")", "==", "num_stages", ",", "(", "\n", "'The length of enc_num_convs should be equal to num_stages, '", "\n", "f'while the enc_num_convs is {enc_num_convs}, the length of '", "\n", "f'enc_num_convs is {len(enc_num_convs)}, and the num_stages is '", "\n", "f'{num_stages}.'", ")", "\n", "assert", "len", "(", "dec_num_convs", ")", "==", "(", "num_stages", "-", "1", ")", ",", "(", "\n", "'The length of dec_num_convs should be equal to (num_stages-1), '", "\n", "f'while the dec_num_convs is {dec_num_convs}, the length of '", "\n", "f'dec_num_convs is {len(dec_num_convs)}, and the num_stages is '", "\n", "f'{num_stages}.'", ")", "\n", "assert", "len", "(", "downsamples", ")", "==", "(", "num_stages", "-", "1", ")", ",", "(", "\n", "'The length of downsamples should be equal to (num_stages-1), '", "\n", "f'while the downsamples is {downsamples}, the length of '", "\n", "f'downsamples is {len(downsamples)}, and the num_stages is '", "\n", "f'{num_stages}.'", ")", "\n", "assert", "len", "(", "enc_dilations", ")", "==", "num_stages", ",", "(", "\n", "'The length of enc_dilations should be equal to num_stages, '", "\n", "f'while the enc_dilations is {enc_dilations}, the length of '", "\n", "f'enc_dilations is {len(enc_dilations)}, and the num_stages is '", "\n", "f'{num_stages}.'", ")", "\n", "assert", "len", "(", "dec_dilations", ")", "==", "(", "num_stages", "-", "1", ")", ",", "(", "\n", "'The length of dec_dilations should be equal to (num_stages-1), '", "\n", "f'while the dec_dilations is {dec_dilations}, the length of '", "\n", "f'dec_dilations is {len(dec_dilations)}, and the num_stages is '", "\n", "f'{num_stages}.'", ")", "\n", "self", ".", "num_stages", "=", "num_stages", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "downsamples", "=", "downsamples", "\n", "self", ".", "norm_eval", "=", "norm_eval", "\n", "self", ".", "base_channels", "=", "base_channels", "\n", "\n", "self", ".", "encoder", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "decoder", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_stages", ")", ":", "\n", "            ", "enc_conv_block", "=", "[", "]", "\n", "if", "i", "!=", "0", ":", "\n", "                ", "if", "strides", "[", "i", "]", "==", "1", "and", "downsamples", "[", "i", "-", "1", "]", ":", "\n", "                    ", "enc_conv_block", ".", "append", "(", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ")", ")", "\n", "", "upsample", "=", "(", "strides", "[", "i", "]", "!=", "1", "or", "downsamples", "[", "i", "-", "1", "]", ")", "\n", "self", ".", "decoder", ".", "append", "(", "\n", "UpConvBlock", "(", "\n", "conv_block", "=", "BasicConvBlock", ",", "\n", "in_channels", "=", "base_channels", "*", "2", "**", "i", ",", "\n", "skip_channels", "=", "base_channels", "*", "2", "**", "(", "i", "-", "1", ")", ",", "\n", "out_channels", "=", "base_channels", "*", "2", "**", "(", "i", "-", "1", ")", ",", "\n", "num_convs", "=", "dec_num_convs", "[", "i", "-", "1", "]", ",", "\n", "stride", "=", "1", ",", "\n", "dilation", "=", "dec_dilations", "[", "i", "-", "1", "]", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "upsample_cfg", "=", "upsample_cfg", "if", "upsample", "else", "None", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", ")", "\n", "\n", "", "enc_conv_block", ".", "append", "(", "\n", "BasicConvBlock", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "base_channels", "*", "2", "**", "i", ",", "\n", "num_convs", "=", "enc_num_convs", "[", "i", "]", ",", "\n", "stride", "=", "strides", "[", "i", "]", ",", "\n", "dilation", "=", "enc_dilations", "[", "i", "]", ",", "\n", "with_cp", "=", "with_cp", ",", "\n", "conv_cfg", "=", "conv_cfg", ",", "\n", "norm_cfg", "=", "norm_cfg", ",", "\n", "act_cfg", "=", "act_cfg", ",", "\n", "dcn", "=", "None", ",", "\n", "plugins", "=", "None", ")", ")", "\n", "self", ".", "encoder", ".", "append", "(", "(", "nn", ".", "Sequential", "(", "*", "enc_conv_block", ")", ")", ")", "\n", "in_channels", "=", "base_channels", "*", "2", "**", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.forward": [[482, 494], ["unet.UNet._check_input_divisible", "reversed", "enc", "enc_outs.append", "range", "dec_outs.append", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet._check_input_divisible"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "_check_input_divisible", "(", "x", ")", "\n", "enc_outs", "=", "[", "]", "\n", "for", "enc", "in", "self", ".", "encoder", ":", "\n", "            ", "x", "=", "enc", "(", "x", ")", "\n", "enc_outs", ".", "append", "(", "x", ")", "\n", "", "dec_outs", "=", "[", "x", "]", "\n", "for", "i", "in", "reversed", "(", "range", "(", "len", "(", "self", ".", "decoder", ")", ")", ")", ":", "\n", "            ", "x", "=", "self", ".", "decoder", "[", "i", "]", "(", "enc_outs", "[", "i", "]", ",", "x", ")", "\n", "dec_outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "dec_outs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train": [[495, 504], ["super().train", "unet.UNet.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"Convert the model into training mode while keep normalization layer\n        freezed.\"\"\"", "\n", "super", "(", ")", ".", "train", "(", "mode", ")", "\n", "if", "mode", "and", "self", ".", "norm_eval", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "# trick: eval have effect on BatchNorm only", "\n", "                ", "if", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                    ", "m", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet._check_input_divisible": [[505, 514], ["range"], "methods", ["None"], ["", "", "", "", "def", "_check_input_divisible", "(", "self", ",", "x", ")", ":", "\n", "        ", "h", ",", "w", "=", "x", ".", "shape", "[", "-", "2", ":", "]", "\n", "whole_downsample_rate", "=", "1", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_stages", ")", ":", "\n", "            ", "if", "self", ".", "strides", "[", "i", "]", "==", "2", "or", "self", ".", "downsamples", "[", "i", "-", "1", "]", ":", "\n", "                ", "whole_downsample_rate", "*=", "2", "\n", "", "", "assert", "(", "\n", "h", "%", "whole_downsample_rate", "==", "0", "and", "w", "%", "whole_downsample_rate", "==", "0", "\n", ")", ",", "(", "f'The input image size {(h, w)} should be divisible by the whole '", "\n", "f'downsample rate {whole_downsample_rate}, when num_stages is '", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.plugins.common.Maxpool2d.__init__": [[17, 20], ["torch.Module.__init__", "torch.MaxPool2d", "torch.MaxPool2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "kernel_size", ",", "stride", ",", "padding", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "Maxpool2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", ",", "stride", ",", "padding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.plugins.common.Maxpool2d.forward": [[21, 30], ["common.Maxpool2d.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (Tensor): Input feature map\n\n        Returns:\n            Tensor: The tensor after Maxpooling layer.\n        \"\"\"", "\n", "return", "self", ".", "model", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.plugins.common.GCAModule.__init__": [[48, 98], ["torch.Module.__init__", "int", "int", "torch.Conv2d", "torch.Conv2d", "torch.Softmax", "torch.Softmax", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.LayerNorm", "torch.LayerNorm", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LayerNorm", "torch.LayerNorm", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.LayerNorm", "torch.LayerNorm", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "ratio", ",", "\n", "n_head", ",", "\n", "pooling_type", "=", "'att'", ",", "\n", "scale_attn", "=", "False", ",", "\n", "fusion_type", "=", "'channel_add'", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "GCAModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "pooling_type", "in", "[", "'avg'", ",", "'att'", "]", "\n", "assert", "fusion_type", "in", "[", "'channel_add'", ",", "'channel_mul'", ",", "'channel_concat'", "]", "\n", "\n", "# in_channels must be divided by headers evenly", "\n", "assert", "in_channels", "%", "n_head", "==", "0", "and", "in_channels", ">=", "8", "\n", "\n", "self", ".", "n_head", "=", "n_head", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "ratio", "=", "ratio", "\n", "self", ".", "planes", "=", "int", "(", "in_channels", "*", "ratio", ")", "\n", "self", ".", "pooling_type", "=", "pooling_type", "\n", "self", ".", "fusion_type", "=", "fusion_type", "\n", "self", ".", "scale_attn", "=", "scale_attn", "\n", "self", ".", "single_header_inplanes", "=", "int", "(", "in_channels", "/", "n_head", ")", "\n", "\n", "if", "pooling_type", "==", "'att'", ":", "\n", "            ", "self", ".", "conv_mask", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "single_header_inplanes", ",", "1", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "2", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "avg_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "\n", "", "if", "fusion_type", "==", "'channel_add'", ":", "\n", "            ", "self", ".", "channel_add_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "self", ".", "planes", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "LayerNorm", "(", "[", "self", ".", "planes", ",", "1", ",", "1", "]", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "self", ".", "planes", ",", "self", ".", "in_channels", ",", "kernel_size", "=", "1", ")", ")", "\n", "", "elif", "fusion_type", "==", "'channel_concat'", ":", "\n", "            ", "self", ".", "channel_concat_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "self", ".", "planes", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "LayerNorm", "(", "[", "self", ".", "planes", ",", "1", ",", "1", "]", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "self", ".", "planes", ",", "self", ".", "in_channels", ",", "kernel_size", "=", "1", ")", ")", "\n", "# for concat", "\n", "self", ".", "cat_conv", "=", "nn", ".", "Conv2d", "(", "\n", "2", "*", "self", ".", "in_channels", ",", "self", ".", "in_channels", ",", "kernel_size", "=", "1", ")", "\n", "", "elif", "fusion_type", "==", "'channel_mul'", ":", "\n", "            ", "self", ".", "channel_mul_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "self", ".", "planes", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "LayerNorm", "(", "[", "self", ".", "planes", ",", "1", ",", "1", "]", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "self", ".", "planes", ",", "self", ".", "in_channels", ",", "kernel_size", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.plugins.common.GCAModule.spatial_pool": [[99, 142], ["x.view.view.size", "x.view.view.view", "input_x.unsqueeze.unsqueeze.view", "input_x.unsqueeze.unsqueeze.unsqueeze", "common.GCAModule.conv_mask", "context_mask.unsqueeze.unsqueeze.view", "common.GCAModule.softmax", "context_mask.unsqueeze.unsqueeze.unsqueeze", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "common.GCAModule.view", "common.GCAModule.avg_pool", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["None"], ["", "", "def", "spatial_pool", "(", "self", ",", "x", ")", ":", "\n", "        ", "batch", ",", "channel", ",", "height", ",", "width", "=", "x", ".", "size", "(", ")", "\n", "if", "self", ".", "pooling_type", "==", "'att'", ":", "\n", "# [N*headers, C', H , W] C = headers * C'", "\n", "            ", "x", "=", "x", ".", "view", "(", "batch", "*", "self", ".", "n_head", ",", "self", ".", "single_header_inplanes", ",", "\n", "height", ",", "width", ")", "\n", "input_x", "=", "x", "\n", "\n", "# [N*headers, C', H * W] C = headers * C'", "\n", "input_x", "=", "input_x", ".", "view", "(", "batch", "*", "self", ".", "n_head", ",", "\n", "self", ".", "single_header_inplanes", ",", "height", "*", "width", ")", "\n", "\n", "# [N*headers, 1, C', H * W]", "\n", "input_x", "=", "input_x", ".", "unsqueeze", "(", "1", ")", "\n", "# [N*headers, 1, H, W]", "\n", "context_mask", "=", "self", ".", "conv_mask", "(", "x", ")", "\n", "# [N*headers, 1, H * W]", "\n", "context_mask", "=", "context_mask", ".", "view", "(", "batch", "*", "self", ".", "n_head", ",", "1", ",", "\n", "height", "*", "width", ")", "\n", "\n", "# scale variance", "\n", "if", "self", ".", "scale_attn", "and", "self", ".", "n_head", ">", "1", ":", "\n", "                ", "context_mask", "=", "context_mask", "/", "torch", ".", "sqrt", "(", "self", ".", "single_header_inplanes", ")", "\n", "\n", "# [N*headers, 1, H * W]", "\n", "", "context_mask", "=", "self", ".", "softmax", "(", "context_mask", ")", "\n", "\n", "# [N*headers, 1, H * W, 1]", "\n", "context_mask", "=", "context_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "# [N*headers, 1, C', 1] =", "\n", "# [N*headers, 1, C', H * W] * [N*headers, 1, H * W, 1]", "\n", "context", "=", "torch", ".", "matmul", "(", "input_x", ",", "context_mask", ")", "\n", "\n", "# [N, headers * C', 1, 1]", "\n", "context", "=", "context", ".", "view", "(", "batch", ",", "\n", "self", ".", "n_head", "*", "self", ".", "single_header_inplanes", ",", "\n", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "# [N, C, 1, 1]", "\n", "            ", "context", "=", "self", ".", "avg_pool", "(", "x", ")", "\n", "\n", "", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.plugins.common.GCAModule.forward": [[143, 172], ["common.GCAModule.spatial_pool", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "common.GCAModule.channel_mul_conv", "common.GCAModule.channel_add_conv", "common.GCAModule.channel_concat_conv", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "common.GCAModule.cat_conv", "torch.functional.layer_norm", "torch.functional.layer_norm", "torch.functional.relu", "torch.functional.relu", "common.GCAModule.expand"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.plugins.common.GCAModule.spatial_pool"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# [N, C, 1, 1]", "\n", "        ", "context", "=", "self", ".", "spatial_pool", "(", "x", ")", "\n", "out", "=", "x", "\n", "\n", "if", "self", ".", "fusion_type", "==", "'channel_mul'", ":", "\n", "# [N, C, 1, 1]", "\n", "            ", "channel_mul_term", "=", "torch", ".", "sigmoid", "(", "self", ".", "channel_mul_conv", "(", "context", ")", ")", "\n", "out", "=", "out", "*", "channel_mul_term", "\n", "", "elif", "self", ".", "fusion_type", "==", "'channel_add'", ":", "\n", "# [N, C, 1, 1]", "\n", "            ", "channel_add_term", "=", "self", ".", "channel_add_conv", "(", "context", ")", "\n", "out", "=", "out", "+", "channel_add_term", "\n", "", "else", ":", "\n", "# [N, C, 1, 1]", "\n", "            ", "channel_concat_term", "=", "self", ".", "channel_concat_conv", "(", "context", ")", "\n", "\n", "# use concat", "\n", "_", ",", "C1", ",", "_", ",", "_", "=", "channel_concat_term", ".", "shape", "\n", "N", ",", "C2", ",", "H", ",", "W", "=", "out", ".", "shape", "\n", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "\n", "channel_concat_term", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "H", ",", "W", ")", "]", ",", "\n", "dim", "=", "1", ")", "\n", "out", "=", "self", ".", "cat_conv", "(", "out", ")", "\n", "out", "=", "nn", ".", "functional", ".", "layer_norm", "(", "out", ",", "[", "self", ".", "in_channels", ",", "H", ",", "W", "]", ")", "\n", "out", "=", "nn", ".", "functional", ".", "relu", "(", "out", ")", "\n", "\n", "", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.abinet_vision_model.ABIVisionModel.__init__": [[20, 28], ["dict", "dict", "dict", "base_encoder.BaseEncoder.__init__", "mmocr.models.builder.build_encoder", "mmocr.models.builder.build_decoder"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_encoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder"], ["def", "__init__", "(", "self", ",", "\n", "encoder", "=", "dict", "(", "type", "=", "'TransformerEncoder'", ")", ",", "\n", "decoder", "=", "dict", "(", "type", "=", "'ABIVisionDecoder'", ")", ",", "\n", "init_cfg", "=", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "encoder", "=", "build_encoder", "(", "encoder", ")", "\n", "self", ".", "decoder", "=", "build_decoder", "(", "decoder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.abinet_vision_model.ABIVisionModel.forward": [[29, 46], ["abinet_vision_model.ABIVisionModel.encoder", "abinet_vision_model.ABIVisionModel.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Images of shape (N, E, H, W).\n\n        Returns:\n            dict: A dict with keys ``feature``, ``logits`` and ``attn_scores``.\n\n            - | feature (Tensor): Shape (N, T, E). Raw visual features for\n                language decoder.\n            - | logits (Tensor): Shape (N, T, C). The raw logits for\n                characters. C is the number of characters.\n            - | attn_scores (Tensor): Shape (N, T, H, W). Intermediate result\n                for vision-language aligner.\n        \"\"\"", "\n", "feat", "=", "self", ".", "encoder", "(", "feat", ")", "\n", "return", "self", ".", "decoder", "(", "feat", "=", "feat", ",", "out_enc", "=", "None", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.channel_reduction_encoder.ChannelReductionEncoder.__init__": [[18, 26], ["dict", "base_encoder.BaseEncoder.__init__", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "init_cfg", "=", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "self", ".", "layer", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.channel_reduction_encoder.ChannelReductionEncoder.forward": [[27, 38], ["channel_reduction_encoder.ChannelReductionEncoder.layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Image features with the shape of\n                :math:`(N, C_{in}, H, W)`.\n            img_metas (None): Unused.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, C_{out}, H, W)`.\n        \"\"\"", "\n", "return", "self", ".", "layer", "(", "feat", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.sar_encoder.SAREncoder.__init__": [[29, 70], ["base_encoder.BaseEncoder.__init__", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "dict", "torch.Linear", "torch.Linear", "torch.Linear", "dict", "dict", "torch.GRU", "torch.GRU", "torch.GRU", "torch.LSTM", "torch.LSTM", "torch.LSTM", "int"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "enc_bi_rnn", "=", "False", ",", "\n", "enc_do_rnn", "=", "0.0", ",", "\n", "enc_gru", "=", "False", ",", "\n", "d_model", "=", "512", ",", "\n", "d_enc", "=", "512", ",", "\n", "mask", "=", "True", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "isinstance", "(", "enc_bi_rnn", ",", "bool", ")", "\n", "assert", "isinstance", "(", "enc_do_rnn", ",", "(", "int", ",", "float", ")", ")", "\n", "assert", "0", "<=", "enc_do_rnn", "<", "1.0", "\n", "assert", "isinstance", "(", "enc_gru", ",", "bool", ")", "\n", "assert", "isinstance", "(", "d_model", ",", "int", ")", "\n", "assert", "isinstance", "(", "d_enc", ",", "int", ")", "\n", "assert", "isinstance", "(", "mask", ",", "bool", ")", "\n", "\n", "self", ".", "enc_bi_rnn", "=", "enc_bi_rnn", "\n", "self", ".", "enc_do_rnn", "=", "enc_do_rnn", "\n", "self", ".", "mask", "=", "mask", "\n", "\n", "# LSTM Encoder", "\n", "kwargs", "=", "dict", "(", "\n", "input_size", "=", "d_model", ",", "\n", "hidden_size", "=", "d_enc", ",", "\n", "num_layers", "=", "2", ",", "\n", "batch_first", "=", "True", ",", "\n", "dropout", "=", "enc_do_rnn", ",", "\n", "bidirectional", "=", "enc_bi_rnn", ")", "\n", "if", "enc_gru", ":", "\n", "            ", "self", ".", "rnn_encoder", "=", "nn", ".", "GRU", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rnn_encoder", "=", "nn", ".", "LSTM", "(", "**", "kwargs", ")", "\n", "\n", "# global feature transformation", "\n", "", "encoder_rnn_out_size", "=", "d_enc", "*", "(", "int", "(", "enc_bi_rnn", ")", "+", "1", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "encoder_rnn_out_size", ",", "encoder_rnn_out_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.sar_encoder.SAREncoder.forward": [[71, 112], ["feat.size", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "feat_v.permute().contiguous.permute().contiguous.squeeze", "feat_v.permute().contiguous.permute().contiguous.permute().contiguous", "sar_encoder.SAREncoder.linear", "mmocr.is_type_list", "sar_encoder.SAREncoder.rnn_encoder", "sar_encoder.SAREncoder.size", "enumerate", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "len", "feat.size", "feat_v.permute().contiguous.permute().contiguous.permute", "torch.stack.append", "torch.stack.append", "torch.stack.append", "img_meta.get", "min", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "forward", "(", "self", ",", "feat", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Tensor of shape :math:`(N, D_i, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, D_m)`.\n        \"\"\"", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "feat", ".", "size", "(", "0", ")", "\n", "\n", "", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "if", "self", ".", "mask", "else", "None", "\n", "\n", "", "h_feat", "=", "feat", ".", "size", "(", "2", ")", "\n", "feat_v", "=", "F", ".", "max_pool2d", "(", "\n", "feat", ",", "kernel_size", "=", "(", "h_feat", ",", "1", ")", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "feat_v", "=", "feat_v", ".", "squeeze", "(", "2", ")", "# bsz * C * W", "\n", "feat_v", "=", "feat_v", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "# bsz * W * C", "\n", "\n", "holistic_feat", "=", "self", ".", "rnn_encoder", "(", "feat_v", ")", "[", "0", "]", "# bsz * T * C", "\n", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "valid_hf", "=", "[", "]", "\n", "T", "=", "holistic_feat", ".", "size", "(", "1", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_step", "=", "min", "(", "T", ",", "math", ".", "ceil", "(", "T", "*", "valid_ratio", ")", ")", "-", "1", "\n", "valid_hf", ".", "append", "(", "holistic_feat", "[", "i", ",", "valid_step", ",", ":", "]", ")", "\n", "", "valid_hf", "=", "torch", ".", "stack", "(", "valid_hf", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "valid_hf", "=", "holistic_feat", "[", ":", ",", "-", "1", ",", ":", "]", "# bsz * C", "\n", "\n", "", "holistic_feat", "=", "self", ".", "linear", "(", "valid_hf", ")", "# bsz * C", "\n", "\n", "return", "holistic_feat", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.nrtr_encoder.NRTREncoder.__init__": [[31, 49], ["base_encoder.BaseEncoder.__init__", "mmcv.runner.ModuleList", "torch.LayerNorm", "mmocr.models.common.TFEncoderLayer", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_layers", "=", "6", ",", "\n", "n_head", "=", "8", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "d_model", "=", "512", ",", "\n", "d_inner", "=", "256", ",", "\n", "dropout", "=", "0.1", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "layer_stack", "=", "ModuleList", "(", "[", "\n", "TFEncoderLayer", "(", "\n", "d_model", ",", "d_inner", ",", "n_head", ",", "d_k", ",", "d_v", ",", "dropout", "=", "dropout", ",", "**", "kwargs", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "\n", "]", ")", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.nrtr_encoder.NRTREncoder._get_mask": [[50, 65], ["logit.size", "logit.new_zeros", "enumerate", "img_meta.get", "min", "math.ceil"], "methods", ["None"], ["", "def", "_get_mask", "(", "self", ",", "logit", ",", "img_metas", ")", ":", "\n", "        ", "valid_ratios", "=", "None", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "\n", "", "N", ",", "T", ",", "_", "=", "logit", ".", "size", "(", ")", "\n", "mask", "=", "None", "\n", "if", "valid_ratios", "is", "not", "None", ":", "\n", "            ", "mask", "=", "logit", ".", "new_zeros", "(", "(", "N", ",", "T", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "                ", "valid_width", "=", "min", "(", "T", ",", "math", ".", "ceil", "(", "T", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", "valid_width", "]", "=", "1", "\n", "\n", "", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.nrtr_encoder.NRTREncoder.forward": [[66, 88], ["feat.view().permute().contiguous.view().permute().contiguous.size", "feat.view().permute().contiguous.view().permute().contiguous.view().permute().contiguous", "nrtr_encoder.NRTREncoder._get_mask", "nrtr_encoder.NRTREncoder.layer_norm", "enc_layer", "feat.view().permute().contiguous.view().permute().contiguous.view().permute", "feat.view().permute().contiguous.view().permute().contiguous.view"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.nrtr_encoder.NRTREncoder._get_mask"], ["", "def", "forward", "(", "self", ",", "feat", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "r\"\"\"\n        Args:\n            feat (Tensor): Backbone output of shape :math:`(N, C, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: The encoder output tensor. Shape :math:`(N, T, C)`.\n        \"\"\"", "\n", "n", ",", "c", ",", "h", ",", "w", "=", "feat", ".", "size", "(", ")", "\n", "\n", "feat", "=", "feat", ".", "view", "(", "n", ",", "c", ",", "h", "*", "w", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "mask", "=", "self", ".", "_get_mask", "(", "feat", ",", "img_metas", ")", "\n", "\n", "output", "=", "feat", "\n", "for", "enc_layer", "in", "self", ".", "layer_stack", ":", "\n", "            ", "output", "=", "enc_layer", "(", "output", ",", "mask", ")", "\n", "", "output", "=", "self", ".", "layer_norm", "(", "output", ")", "\n", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.base_encoder.BaseEncoder.forward": [[11, 13], ["None"], "methods", ["None"], ["def", "forward", "(", "self", ",", "feat", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "feat", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.satrn_encoder.SatrnEncoder.__init__": [[32, 56], ["base_encoder.BaseEncoder.__init__", "mmocr.models.textrecog.layers.Adaptive2DPositionalEncoding", "mmcv.runner.ModuleList", "torch.LayerNorm", "mmocr.models.textrecog.layers.SatrnEncoderLayer", "range"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_layers", "=", "12", ",", "\n", "n_head", "=", "8", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "d_model", "=", "512", ",", "\n", "n_position", "=", "100", ",", "\n", "d_inner", "=", "256", ",", "\n", "dropout", "=", "0.1", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "position_enc", "=", "Adaptive2DPositionalEncoding", "(", "\n", "d_hid", "=", "d_model", ",", "\n", "n_height", "=", "n_position", ",", "\n", "n_width", "=", "n_position", ",", "\n", "dropout", "=", "dropout", ")", "\n", "self", ".", "layer_stack", "=", "ModuleList", "(", "[", "\n", "SatrnEncoderLayer", "(", "\n", "d_model", ",", "d_inner", ",", "n_head", ",", "d_k", ",", "d_v", ",", "dropout", "=", "dropout", ")", "\n", "for", "_", "in", "range", "(", "n_layers", ")", "\n", "]", ")", "\n", "self", ".", "layer_norm", "=", "nn", ".", "LayerNorm", "(", "d_model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.satrn_encoder.SatrnEncoder.forward": [[57, 87], ["satrn_encoder.SatrnEncoder.position_enc", "feat.view.view.size", "feat.view.view.new_zeros", "enumerate", "mask.view.view.view", "feat.view.view.view", "feat.view.view.permute().contiguous", "satrn_encoder.SatrnEncoder.layer_norm", "min", "enc_layer", "range", "img_meta.get", "math.ceil", "feat.view.view.permute", "feat.view.view.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feat", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feat (Tensor): Feature tensor of shape :math:`(N, D_m, H, W)`.\n            img_metas (dict): A dict that contains meta information of input\n                images. Preferably with the key ``valid_ratio``.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, T, D_m)`.\n        \"\"\"", "\n", "valid_ratios", "=", "[", "1.0", "for", "_", "in", "range", "(", "feat", ".", "size", "(", "0", ")", ")", "]", "\n", "if", "img_metas", "is", "not", "None", ":", "\n", "            ", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "\n", "", "feat", "+=", "self", ".", "position_enc", "(", "feat", ")", "\n", "n", ",", "c", ",", "h", ",", "w", "=", "feat", ".", "size", "(", ")", "\n", "mask", "=", "feat", ".", "new_zeros", "(", "(", "n", ",", "h", ",", "w", ")", ")", "\n", "for", "i", ",", "valid_ratio", "in", "enumerate", "(", "valid_ratios", ")", ":", "\n", "            ", "valid_width", "=", "min", "(", "w", ",", "math", ".", "ceil", "(", "w", "*", "valid_ratio", ")", ")", "\n", "mask", "[", "i", ",", ":", ",", ":", "valid_width", "]", "=", "1", "\n", "", "mask", "=", "mask", ".", "view", "(", "n", ",", "h", "*", "w", ")", "\n", "feat", "=", "feat", ".", "view", "(", "n", ",", "c", ",", "h", "*", "w", ")", "\n", "\n", "output", "=", "feat", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "for", "enc_layer", "in", "self", ".", "layer_stack", ":", "\n", "            ", "output", "=", "enc_layer", "(", "output", ",", "h", ",", "w", ",", "mask", ")", "\n", "", "output", "=", "self", ".", "layer_norm", "(", "output", ")", "\n", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.transformer.TransformerEncoder.__init__": [[26, 58], ["mmcv.runner.BaseModule.__init__", "mmocr.models.common.modules.PositionalEncoding", "mmcv.cnn.bricks.transformer.BaseTransformerLayer", "mmcv.runner.ModuleList", "dict", "dict", "dict", "copy.deepcopy", "range", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_layers", "=", "2", ",", "\n", "n_head", "=", "8", ",", "\n", "d_model", "=", "512", ",", "\n", "d_inner", "=", "2048", ",", "\n", "dropout", "=", "0.1", ",", "\n", "max_len", "=", "8", "*", "32", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "\n", "assert", "d_model", "%", "n_head", "==", "0", ",", "'d_model must be divisible by n_head'", "\n", "\n", "self", ".", "pos_encoder", "=", "PositionalEncoding", "(", "d_model", ",", "n_position", "=", "max_len", ")", "\n", "encoder_layer", "=", "BaseTransformerLayer", "(", "\n", "operation_order", "=", "(", "'self_attn'", ",", "'norm'", ",", "'ffn'", ",", "'norm'", ")", ",", "\n", "attn_cfgs", "=", "dict", "(", "\n", "type", "=", "'MultiheadAttention'", ",", "\n", "embed_dims", "=", "d_model", ",", "\n", "num_heads", "=", "n_head", ",", "\n", "attn_drop", "=", "dropout", ",", "\n", "dropout_layer", "=", "dict", "(", "type", "=", "'Dropout'", ",", "drop_prob", "=", "dropout", ")", ",", "\n", ")", ",", "\n", "ffn_cfgs", "=", "dict", "(", "\n", "type", "=", "'FFN'", ",", "\n", "embed_dims", "=", "d_model", ",", "\n", "feedforward_channels", "=", "d_inner", ",", "\n", "ffn_drop", "=", "dropout", ",", "\n", ")", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'LN'", ")", ",", "\n", ")", "\n", "self", ".", "transformer", "=", "ModuleList", "(", "\n", "[", "copy", ".", "deepcopy", "(", "encoder_layer", ")", "for", "_", "in", "range", "(", "n_layers", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.transformer.TransformerEncoder.forward": [[59, 75], ["m.view().transpose", "transformer.TransformerEncoder.pos_encoder", "m.transpose", "m.permute().view", "m", "m.view", "m.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feature", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feature (Tensor): Feature tensor of shape :math:`(N, D_m, H, W)`.\n\n        Returns:\n            Tensor: Features of shape :math:`(N, D_m, H, W)`.\n        \"\"\"", "\n", "n", ",", "c", ",", "h", ",", "w", "=", "feature", ".", "shape", "\n", "feature", "=", "feature", ".", "view", "(", "n", ",", "c", ",", "-", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "# (n, h*w, c)", "\n", "feature", "=", "self", ".", "pos_encoder", "(", "feature", ")", "# (n, h*w, c)", "\n", "feature", "=", "feature", ".", "transpose", "(", "0", ",", "1", ")", "# (h*w, n, c)", "\n", "for", "m", "in", "self", ".", "transformer", ":", "\n", "            ", "feature", "=", "m", "(", "feature", ")", "\n", "", "feature", "=", "feature", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "view", "(", "n", ",", "c", ",", "h", ",", "w", ")", "\n", "return", "feature", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.bert_encoder.BertEncoder.__init__": [[29, 64], ["dict", "mmcv.runner.BaseModule.__init__", "mmocr.models.ner.utils.bert.BertModel", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "num_hidden_layers", "=", "12", ",", "\n", "initializer_range", "=", "0.02", ",", "\n", "vocab_size", "=", "21128", ",", "\n", "hidden_size", "=", "768", ",", "\n", "max_position_embeddings", "=", "128", ",", "\n", "type_vocab_size", "=", "2", ",", "\n", "layer_norm_eps", "=", "1e-12", ",", "\n", "hidden_dropout_prob", "=", "0.1", ",", "\n", "output_attentions", "=", "False", ",", "\n", "output_hidden_states", "=", "False", ",", "\n", "num_attention_heads", "=", "12", ",", "\n", "attention_probs_dropout_prob", "=", "0.1", ",", "\n", "intermediate_size", "=", "3072", ",", "\n", "hidden_act_cfg", "=", "dict", "(", "type", "=", "'GeluNew'", ")", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Xavier'", ",", "layer", "=", "'Conv2d'", ")", ",", "\n", "dict", "(", "type", "=", "'Uniform'", ",", "layer", "=", "'BatchNorm2d'", ")", "\n", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "bert", "=", "BertModel", "(", "\n", "num_hidden_layers", "=", "num_hidden_layers", ",", "\n", "initializer_range", "=", "initializer_range", ",", "\n", "vocab_size", "=", "vocab_size", ",", "\n", "hidden_size", "=", "hidden_size", ",", "\n", "max_position_embeddings", "=", "max_position_embeddings", ",", "\n", "type_vocab_size", "=", "type_vocab_size", ",", "\n", "layer_norm_eps", "=", "layer_norm_eps", ",", "\n", "hidden_dropout_prob", "=", "hidden_dropout_prob", ",", "\n", "output_attentions", "=", "output_attentions", ",", "\n", "output_hidden_states", "=", "output_hidden_states", ",", "\n", "num_attention_heads", "=", "num_attention_heads", ",", "\n", "attention_probs_dropout_prob", "=", "attention_probs_dropout_prob", ",", "\n", "intermediate_size", "=", "intermediate_size", ",", "\n", "hidden_act_cfg", "=", "hidden_act_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.encoders.bert_encoder.BertEncoder.forward": [[65, 77], ["results[].to", "results[].to", "results[].to", "bert_encoder.BertEncoder.bert", "next", "bert_encoder.BertEncoder.bert.parameters"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "results", ")", ":", "\n", "\n", "        ", "device", "=", "next", "(", "self", ".", "bert", ".", "parameters", "(", ")", ")", ".", "device", "\n", "input_ids", "=", "results", "[", "'input_ids'", "]", ".", "to", "(", "device", ")", "\n", "attention_masks", "=", "results", "[", "'attention_masks'", "]", ".", "to", "(", "device", ")", "\n", "token_type_ids", "=", "results", "[", "'token_type_ids'", "]", ".", "to", "(", "device", ")", "\n", "\n", "outputs", "=", "self", ".", "bert", "(", "\n", "input_ids", "=", "input_ids", ",", "\n", "attention_masks", "=", "attention_masks", ",", "\n", "token_type_ids", "=", "token_type_ids", ")", "\n", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.__init__": [[33, 59], ["isinstance", "isinstance", "enumerate", "len", "len", "mmocr.utils.list_from_file", "line.strip.strip.strip", "list", "set", "enumerate", "len", "ValueError", "base.BaseConvertor.idx2char.append", "list", "NotImplementedError", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["\n", "pass", "\n", "\n", "", "@", "abstractmethod", "\n", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n", "", "@", "abstractmethod", "\n", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Test function with test time augmentation.\n\n        Args:\n            imgs (list[tensor]): Tensor should have shape NxCxHxW,\n                which contains all images in the batch.\n            img_metas (list[list[dict]]): The metadata of images.\n        \"\"\"", "\n", "pass", "\n", "\n", "", "def", "forward_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.num_classes": [[60, 63], ["len"], "methods", ["None"], ["\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx": [[64, 90], ["isinstance", "indexes.append", "string.lower.lower.lower", "base.BaseConvertor.char2idx.get", "index.append", "Exception"], "methods", ["None"], ["if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "            ", "assert", "len", "(", "imgs", ")", ">", "0", "\n", "assert", "imgs", "[", "0", "]", ".", "size", "(", "0", ")", "==", "1", ",", "(", "'aug test does not support '", "\n", "f'inference with batch size '", "\n", "f'{imgs[0].size(0)}'", ")", "\n", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "return", "self", ".", "aug_test", "(", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n", "", "return", "self", ".", "simple_test", "(", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n", "", "@", "auto_fp16", "(", "apply_to", "=", "(", "'img'", ",", ")", ")", "\n", "def", "forward", "(", "self", ",", "img", ",", "img_metas", ",", "return_loss", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Calls either :func:`forward_train` or :func:`forward_test` depending\n        on whether ``return_loss`` is ``True``.\n\n        Note that img and img_meta are single-nested (i.e. tensor and\n        list[dict]).\n        \"\"\"", "\n", "\n", "if", "return_loss", ":", "\n", "            ", "return", "self", ".", "forward_train", "(", "img", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n", "", "if", "isinstance", "(", "img", ",", "list", ")", ":", "\n", "            ", "for", "idx", ",", "each_img", "in", "enumerate", "(", "img", ")", ":", "\n", "                ", "if", "each_img", ".", "dim", "(", ")", "==", "3", ":", "\n", "                    ", "img", "[", "idx", "]", "=", "each_img", ".", "unsqueeze", "(", "0", ")", "\n", "", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2tensor": [[91, 101], ["None"], "methods", ["None"], ["            ", "if", "len", "(", "img_metas", ")", "==", "1", "and", "isinstance", "(", "img_metas", "[", "0", "]", ",", "list", ")", ":", "\n", "                ", "img_metas", "=", "img_metas", "[", "0", "]", "\n", "\n", "", "", "return", "self", ".", "forward_test", "(", "img", ",", "img_metas", ",", "**", "kwargs", ")", "\n", "\n", "", "def", "_parse_losses", "(", "self", ",", "losses", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str": [[102, 118], ["isinstance", "strings.append"], "methods", ["None"], ["\n", "log_vars", "=", "OrderedDict", "(", ")", "\n", "for", "loss_name", ",", "loss_value", "in", "losses", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "loss_value", ",", "torch", ".", "Tensor", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "mean", "(", ")", "\n", "", "elif", "isinstance", "(", "loss_value", ",", "list", ")", ":", "\n", "                ", "log_vars", "[", "loss_name", "]", "=", "sum", "(", "_loss", ".", "mean", "(", ")", "for", "_loss", "in", "loss_value", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "f'{loss_name} is not a tensor or list of tensors'", ")", "\n", "\n", "", "", "loss", "=", "sum", "(", "_value", "for", "_key", ",", "_value", "in", "log_vars", ".", "items", "(", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.tensor2idx": [[119, 129], ["None"], "methods", ["None"], ["if", "'loss'", "in", "_key", ")", "\n", "\n", "log_vars", "[", "'loss'", "]", "=", "loss", "\n", "for", "loss_name", ",", "loss_value", "in", "log_vars", ".", "items", "(", ")", ":", "\n", "# reduce loss when distributed training", "\n", "            ", "if", "dist", ".", "is_available", "(", ")", "and", "dist", ".", "is_initialized", "(", ")", ":", "\n", "                ", "loss_value", "=", "loss_value", ".", "data", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "loss_value", ".", "div_", "(", "dist", ".", "get_world_size", "(", ")", ")", ")", "\n", "", "log_vars", "[", "loss_name", "]", "=", "loss_value", ".", "item", "(", ")", "\n", "\n", "", "return", "loss", ",", "log_vars", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.attn.AttnConvertor.__init__": [[27, 47], ["base.BaseConvertor.__init__", "isinstance", "isinstance", "isinstance", "attn.AttnConvertor.update_dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.update_dict"], ["def", "__init__", "(", "self", ",", "\n", "dict_type", "=", "'DICT90'", ",", "\n", "dict_file", "=", "None", ",", "\n", "dict_list", "=", "None", ",", "\n", "with_unknown", "=", "True", ",", "\n", "max_seq_len", "=", "40", ",", "\n", "lower", "=", "False", ",", "\n", "start_end_same", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "dict_type", ",", "dict_file", ",", "dict_list", ")", "\n", "assert", "isinstance", "(", "with_unknown", ",", "bool", ")", "\n", "assert", "isinstance", "(", "max_seq_len", ",", "int", ")", "\n", "assert", "isinstance", "(", "lower", ",", "bool", ")", "\n", "\n", "self", ".", "with_unknown", "=", "with_unknown", "\n", "self", ".", "max_seq_len", "=", "max_seq_len", "\n", "self", ".", "lower", "=", "lower", "\n", "self", ".", "start_end_same", "=", "start_end_same", "\n", "\n", "self", ".", "update_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.attn.AttnConvertor.update_dict": [[48, 74], ["attn.AttnConvertor.idx2char.append", "attn.AttnConvertor.idx2char.append", "enumerate", "attn.AttnConvertor.idx2char.append", "len", "attn.AttnConvertor.idx2char.append", "len", "len", "len"], "methods", ["None"], ["", "def", "update_dict", "(", "self", ")", ":", "\n", "        ", "start_end_token", "=", "'<BOS/EOS>'", "\n", "unknown_token", "=", "'<UKN>'", "\n", "padding_token", "=", "'<PAD>'", "\n", "\n", "# unknown", "\n", "self", ".", "unknown_idx", "=", "None", "\n", "if", "self", ".", "with_unknown", ":", "\n", "            ", "self", ".", "idx2char", ".", "append", "(", "unknown_token", ")", "\n", "self", ".", "unknown_idx", "=", "len", "(", "self", ".", "idx2char", ")", "-", "1", "\n", "\n", "# BOS/EOS", "\n", "", "self", ".", "idx2char", ".", "append", "(", "start_end_token", ")", "\n", "self", ".", "start_idx", "=", "len", "(", "self", ".", "idx2char", ")", "-", "1", "\n", "if", "not", "self", ".", "start_end_same", ":", "\n", "            ", "self", ".", "idx2char", ".", "append", "(", "start_end_token", ")", "\n", "", "self", ".", "end_idx", "=", "len", "(", "self", ".", "idx2char", ")", "-", "1", "\n", "\n", "# padding", "\n", "self", ".", "idx2char", ".", "append", "(", "padding_token", ")", "\n", "self", ".", "padding_idx", "=", "len", "(", "self", ".", "idx2char", ")", "-", "1", "\n", "\n", "# update char2idx", "\n", "self", ".", "char2idx", "=", "{", "}", "\n", "for", "idx", ",", "char", "in", "enumerate", "(", "self", ".", "idx2char", ")", ":", "\n", "            ", "self", ".", "char2idx", "[", "char", "]", "=", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.attn.AttnConvertor.str2tensor": [[75, 109], ["mmocr.is_type_list", "attn.AttnConvertor.str2idx", "torch.stack().long", "torch.LongTensor", "tensors.append", "torch.LongTensor().fill_", "torch.LongTensor().fill_.size", "torch.stack().long.append", "torch.stack", "torch.LongTensor", "torch.ones", "torch.LongTensor.size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx"], ["", "", "def", "str2tensor", "(", "self", ",", "strings", ")", ":", "\n", "        ", "\"\"\"\n        Convert text-string into tensor.\n        Args:\n            strings (list[str]): ['hello', 'world']\n        Returns:\n            dict (str: Tensor | list[tensor]):\n                tensors (list[Tensor]): [torch.Tensor([1,2,3,3,4]),\n                                                    torch.Tensor([5,4,6,3,7])]\n                padded_targets (Tensor(bsz * max_seq_len))\n        \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "strings", ",", "str", ")", "\n", "\n", "tensors", ",", "padded_targets", "=", "[", "]", ",", "[", "]", "\n", "indexes", "=", "self", ".", "str2idx", "(", "strings", ")", "\n", "for", "index", "in", "indexes", ":", "\n", "            ", "tensor", "=", "torch", ".", "LongTensor", "(", "index", ")", "\n", "tensors", ".", "append", "(", "tensor", ")", "\n", "# target tensor for loss", "\n", "src_target", "=", "torch", ".", "LongTensor", "(", "tensor", ".", "size", "(", "0", ")", "+", "2", ")", ".", "fill_", "(", "0", ")", "\n", "src_target", "[", "-", "1", "]", "=", "self", ".", "end_idx", "\n", "src_target", "[", "0", "]", "=", "self", ".", "start_idx", "\n", "src_target", "[", "1", ":", "-", "1", "]", "=", "tensor", "\n", "padded_target", "=", "(", "torch", ".", "ones", "(", "self", ".", "max_seq_len", ")", "*", "\n", "self", ".", "padding_idx", ")", ".", "long", "(", ")", "\n", "char_num", "=", "src_target", ".", "size", "(", "0", ")", "\n", "if", "char_num", ">", "self", ".", "max_seq_len", ":", "\n", "                ", "padded_target", "=", "src_target", "[", ":", "self", ".", "max_seq_len", "]", "\n", "", "else", ":", "\n", "                ", "padded_target", "[", ":", "char_num", "]", "=", "src_target", "\n", "", "padded_targets", ".", "append", "(", "padded_target", ")", "\n", "", "padded_targets", "=", "torch", ".", "stack", "(", "padded_targets", ",", "0", ")", ".", "long", "(", ")", "\n", "\n", "return", "{", "'targets'", ":", "tensors", ",", "'padded_targets'", ":", "padded_targets", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.attn.AttnConvertor.tensor2idx": [[110, 143], ["outputs.size", "range", "seq.softmax.softmax.softmax", "torch.max", "max_idx.cpu().detach().numpy().tolist", "max_value.cpu().detach().numpy().tolist", "zip", "indexes.append", "scores.append", "str_index.append", "str_score.append", "max_idx.cpu().detach().numpy", "max_value.cpu().detach().numpy", "max_idx.cpu().detach", "max_value.cpu().detach", "max_idx.cpu", "max_value.cpu"], "methods", ["None"], ["", "def", "tensor2idx", "(", "self", ",", "outputs", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Convert output tensor to text-index\n        Args:\n            outputs (tensor): model outputs with size: N * T * C\n            img_metas (list[dict]): Each dict contains one image info.\n        Returns:\n            indexes (list[list[int]]): [[1,2,3,3,4], [5,4,6,3,7]]\n            scores (list[list[float]]): [[0.9,0.8,0.95,0.97,0.94],\n                                         [0.9,0.9,0.98,0.97,0.96]]\n        \"\"\"", "\n", "batch_size", "=", "outputs", ".", "size", "(", "0", ")", "\n", "ignore_indexes", "=", "[", "self", ".", "padding_idx", "]", "\n", "indexes", ",", "scores", "=", "[", "]", ",", "[", "]", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "seq", "=", "outputs", "[", "idx", ",", ":", ",", ":", "]", "\n", "seq", "=", "seq", ".", "softmax", "(", "dim", "=", "-", "1", ")", "\n", "max_value", ",", "max_idx", "=", "torch", ".", "max", "(", "seq", ",", "-", "1", ")", "\n", "str_index", ",", "str_score", "=", "[", "]", ",", "[", "]", "\n", "output_index", "=", "max_idx", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "output_score", "=", "max_value", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "for", "char_index", ",", "char_score", "in", "zip", "(", "output_index", ",", "output_score", ")", ":", "\n", "                ", "if", "char_index", "in", "ignore_indexes", ":", "\n", "                    ", "continue", "\n", "", "if", "char_index", "==", "self", ".", "end_idx", ":", "\n", "                    ", "break", "\n", "", "str_index", ".", "append", "(", "char_index", ")", "\n", "str_score", ".", "append", "(", "char_score", ")", "\n", "\n", "", "indexes", ".", "append", "(", "str_index", ")", "\n", "scores", ".", "append", "(", "str_score", ")", "\n", "\n", "", "return", "indexes", ",", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.__init__": [[26, 40], ["base.BaseConvertor.__init__", "isinstance", "isinstance", "ctc.CTCConvertor.update_dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.update_dict"], ["def", "__init__", "(", "self", ",", "\n", "dict_type", "=", "'DICT90'", ",", "\n", "dict_file", "=", "None", ",", "\n", "dict_list", "=", "None", ",", "\n", "with_unknown", "=", "True", ",", "\n", "lower", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "dict_type", ",", "dict_file", ",", "dict_list", ")", "\n", "assert", "isinstance", "(", "with_unknown", ",", "bool", ")", "\n", "assert", "isinstance", "(", "lower", ",", "bool", ")", "\n", "\n", "self", ".", "with_unknown", "=", "with_unknown", "\n", "self", ".", "lower", "=", "lower", "\n", "self", ".", "update_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.update_dict": [[41, 57], ["ctc.CTCConvertor.idx2char.insert", "enumerate", "ctc.CTCConvertor.idx2char.append", "len"], "methods", ["None"], ["", "def", "update_dict", "(", "self", ")", ":", "\n", "# CTC-blank", "\n", "        ", "blank_token", "=", "'<BLK>'", "\n", "self", ".", "blank_idx", "=", "0", "\n", "self", ".", "idx2char", ".", "insert", "(", "0", ",", "blank_token", ")", "\n", "\n", "# unknown", "\n", "self", ".", "unknown_idx", "=", "None", "\n", "if", "self", ".", "with_unknown", ":", "\n", "            ", "self", ".", "idx2char", ".", "append", "(", "'<UKN>'", ")", "\n", "self", ".", "unknown_idx", "=", "len", "(", "self", ".", "idx2char", ")", "-", "1", "\n", "\n", "# update char2idx", "\n", "", "self", ".", "char2idx", "=", "{", "}", "\n", "for", "idx", ",", "char", "in", "enumerate", "(", "self", ".", "idx2char", ")", ":", "\n", "            ", "self", ".", "char2idx", "[", "char", "]", "=", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.str2tensor": [[58, 84], ["mmocr.is_type_list", "ctc.CTCConvertor.str2idx", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "torch.IntTensor", "tensors.append", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx"], ["", "", "def", "str2tensor", "(", "self", ",", "strings", ")", ":", "\n", "        ", "\"\"\"Convert text-string to ctc-loss input tensor.\n\n        Args:\n            strings (list[str]): ['hello', 'world'].\n        Returns:\n            dict (str: tensor | list[tensor]):\n                tensors (list[tensor]): [torch.Tensor([1,2,3,3,4]),\n                    torch.Tensor([5,4,6,3,7])].\n                flatten_targets (tensor): torch.Tensor([1,2,3,3,4,5,4,6,3,7]).\n                target_lengths (tensor): torch.IntTensot([5,5]).\n        \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "strings", ",", "str", ")", "\n", "\n", "tensors", "=", "[", "]", "\n", "indexes", "=", "self", ".", "str2idx", "(", "strings", ")", "\n", "for", "index", "in", "indexes", ":", "\n", "            ", "tensor", "=", "torch", ".", "IntTensor", "(", "index", ")", "\n", "tensors", ".", "append", "(", "tensor", ")", "\n", "", "target_lengths", "=", "torch", ".", "IntTensor", "(", "[", "len", "(", "t", ")", "for", "t", "in", "tensors", "]", ")", "\n", "flatten_target", "=", "torch", ".", "cat", "(", "tensors", ")", "\n", "\n", "return", "{", "\n", "'targets'", ":", "tensors", ",", "\n", "'flatten_targets'", ":", "flatten_target", ",", "\n", "'target_lengths'", ":", "target_lengths", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx": [[86, 146], ["mmocr.is_type_list", "isinstance", "output.cpu().detach.cpu().detach.size", "torch.softmax", "torch.softmax", "output.cpu().detach.cpu().detach.cpu().detach", "output.cpu().detach.cpu().detach.topk", "output.cpu().detach.cpu().detach.size", "range", "len", "output.cpu().detach.cpu().detach.size", "img_meta.get", "min", "range", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "indexes_topk.append", "scores_topk.append", "indexes.append", "scores.append", "output.cpu().detach.cpu().detach.cpu", "math.ceil", "pred[].item", "torch.index_select.numpy().tolist", "torch.index_select.numpy().tolist", "torch.index_select.numpy().tolist", "torch.index_select.numpy().tolist", "torch.LongTensor.append", "torch.LongTensor.append", "torch.index_select.numpy", "torch.index_select.numpy", "torch.index_select.numpy", "torch.index_select.numpy"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "tensor2idx", "(", "self", ",", "output", ",", "img_metas", ",", "topk", "=", "1", ",", "return_topk", "=", "False", ")", ":", "\n", "        ", "\"\"\"Convert model output tensor to index-list.\n        Args:\n            output (tensor): The model outputs with size: N * T * C.\n            img_metas (list[dict]): Each dict contains one image info.\n            topk (int): The highest k classes to be returned.\n            return_topk (bool): Whether to return topk or just top1.\n        Returns:\n            indexes (list[list[int]]): [[1,2,3,3,4], [5,4,6,3,7]].\n            scores (list[list[float]]): [[0.9,0.8,0.95,0.97,0.94],\n                [0.9,0.9,0.98,0.97,0.96]]\n                (\n                    indexes_topk (list[list[list[int]->len=topk]]):\n                    scores_topk (list[list[list[float]->len=topk]])\n                ).\n        \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "output", ".", "size", "(", "0", ")", "\n", "assert", "isinstance", "(", "topk", ",", "int", ")", "\n", "assert", "topk", ">=", "1", "\n", "\n", "valid_ratios", "=", "[", "\n", "img_meta", ".", "get", "(", "'valid_ratio'", ",", "1.0", ")", "for", "img_meta", "in", "img_metas", "\n", "]", "\n", "\n", "batch_size", "=", "output", ".", "size", "(", "0", ")", "\n", "output", "=", "F", ".", "softmax", "(", "output", ",", "dim", "=", "2", ")", "\n", "output", "=", "output", ".", "cpu", "(", ")", ".", "detach", "(", ")", "\n", "batch_topk_value", ",", "batch_topk_idx", "=", "output", ".", "topk", "(", "topk", ",", "dim", "=", "2", ")", "\n", "batch_max_idx", "=", "batch_topk_idx", "[", ":", ",", ":", ",", "0", "]", "\n", "scores_topk", ",", "indexes_topk", "=", "[", "]", ",", "[", "]", "\n", "scores", ",", "indexes", "=", "[", "]", ",", "[", "]", "\n", "feat_len", "=", "output", ".", "size", "(", "1", ")", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "valid_ratio", "=", "valid_ratios", "[", "b", "]", "\n", "decode_len", "=", "min", "(", "feat_len", ",", "math", ".", "ceil", "(", "feat_len", "*", "valid_ratio", ")", ")", "\n", "pred", "=", "batch_max_idx", "[", "b", ",", ":", "]", "\n", "select_idx", "=", "[", "]", "\n", "prev_idx", "=", "self", ".", "blank_idx", "\n", "for", "t", "in", "range", "(", "decode_len", ")", ":", "\n", "                ", "tmp_value", "=", "pred", "[", "t", "]", ".", "item", "(", ")", "\n", "if", "tmp_value", "not", "in", "(", "prev_idx", ",", "self", ".", "blank_idx", ")", ":", "\n", "                    ", "select_idx", ".", "append", "(", "t", ")", "\n", "", "prev_idx", "=", "tmp_value", "\n", "", "select_idx", "=", "torch", ".", "LongTensor", "(", "select_idx", ")", "\n", "topk_value", "=", "torch", ".", "index_select", "(", "batch_topk_value", "[", "b", ",", ":", ",", ":", "]", ",", "0", ",", "\n", "select_idx", ")", "# valid_seqlen * topk", "\n", "topk_idx", "=", "torch", ".", "index_select", "(", "batch_topk_idx", "[", "b", ",", ":", ",", ":", "]", ",", "0", ",", "\n", "select_idx", ")", "\n", "topk_idx_list", ",", "topk_value_list", "=", "topk_idx", ".", "numpy", "(", ")", ".", "tolist", "(", "\n", ")", ",", "topk_value", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "indexes_topk", ".", "append", "(", "topk_idx_list", ")", "\n", "scores_topk", ".", "append", "(", "topk_value_list", ")", "\n", "indexes", ".", "append", "(", "[", "x", "[", "0", "]", "for", "x", "in", "topk_idx_list", "]", ")", "\n", "scores", ".", "append", "(", "[", "x", "[", "0", "]", "for", "x", "in", "topk_value_list", "]", ")", "\n", "\n", "", "if", "return_topk", ":", "\n", "            ", "return", "indexes_topk", ",", "scores_topk", "\n", "\n", "", "return", "indexes", ",", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.__init__": [[25, 39], ["base.BaseConvertor.__init__", "isinstance", "isinstance", "seg.SegConvertor.update_dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.update_dict"], ["def", "__init__", "(", "self", ",", "\n", "dict_type", "=", "'DICT36'", ",", "\n", "dict_file", "=", "None", ",", "\n", "dict_list", "=", "None", ",", "\n", "with_unknown", "=", "True", ",", "\n", "lower", "=", "False", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "dict_type", ",", "dict_file", ",", "dict_list", ")", "\n", "assert", "isinstance", "(", "with_unknown", ",", "bool", ")", "\n", "assert", "isinstance", "(", "lower", ",", "bool", ")", "\n", "\n", "self", ".", "with_unknown", "=", "with_unknown", "\n", "self", ".", "lower", "=", "lower", "\n", "self", ".", "update_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.update_dict": [[40, 54], ["seg.SegConvertor.idx2char.insert", "enumerate", "seg.SegConvertor.idx2char.append", "len"], "methods", ["None"], ["", "def", "update_dict", "(", "self", ")", ":", "\n", "# background", "\n", "        ", "self", ".", "idx2char", ".", "insert", "(", "0", ",", "'<BG>'", ")", "\n", "\n", "# unknown", "\n", "self", ".", "unknown_idx", "=", "None", "\n", "if", "self", ".", "with_unknown", ":", "\n", "            ", "self", ".", "idx2char", ".", "append", "(", "'<UKN>'", ")", "\n", "self", ".", "unknown_idx", "=", "len", "(", "self", ".", "idx2char", ")", "-", "1", "\n", "\n", "# update char2idx", "\n", "", "self", ".", "char2idx", "=", "{", "}", "\n", "for", "idx", ",", "char", "in", "enumerate", "(", "self", ".", "idx2char", ")", ":", "\n", "            ", "self", ".", "char2idx", "[", "char", "]", "=", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.seg.SegConvertor.tensor2str": [[55, 128], ["mmocr.is_type_list", "range", "len", "output.size", "output.size", "output[].detach", "int", "torch.argmax().cpu().numpy().astype", "numpy.where().astype", "cv2.connectedComponentsWithStats", "range", "sorted", "texts.append", "scores.append", "range", "sorted.append", "chars.append", "char_scores.append", "torch.argmax().cpu().numpy", "numpy.where", "len", "numpy.sum", "len", "output.size", "torch.argmax().cpu", "torch.argmax"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "", "def", "tensor2str", "(", "self", ",", "output", ",", "img_metas", "=", "None", ")", ":", "\n", "        ", "\"\"\"Convert model output tensor to string labels.\n        Args:\n            output (tensor): Model outputs with size: N * C * H * W\n            img_metas (list[dict]): Each dict contains one image info.\n        Returns:\n            texts (list[str]): Decoded text labels.\n            scores (list[list[float]]): Decoded chars scores.\n        \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "len", "(", "img_metas", ")", "==", "output", ".", "size", "(", "0", ")", "\n", "\n", "texts", ",", "scores", "=", "[", "]", ",", "[", "]", "\n", "for", "b", "in", "range", "(", "output", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "seg_pred", "=", "output", "[", "b", "]", ".", "detach", "(", ")", "\n", "valid_width", "=", "int", "(", "\n", "output", ".", "size", "(", "-", "1", ")", "*", "img_metas", "[", "b", "]", "[", "'valid_ratio'", "]", "+", "1", ")", "\n", "seg_res", "=", "torch", ".", "argmax", "(", "\n", "seg_pred", "[", ":", ",", ":", ",", ":", "valid_width", "]", ",", "\n", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "seg_thr", "=", "np", ".", "where", "(", "seg_res", "==", "0", ",", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "_", ",", "labels", ",", "stats", ",", "centroids", "=", "cv2", ".", "connectedComponentsWithStats", "(", "\n", "seg_thr", ")", "\n", "\n", "component_num", "=", "stats", ".", "shape", "[", "0", "]", "\n", "\n", "all_res", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "component_num", ")", ":", "\n", "                ", "temp_loc", "=", "(", "labels", "==", "i", ")", "\n", "temp_value", "=", "seg_res", "[", "temp_loc", "]", "\n", "temp_center", "=", "centroids", "[", "i", "]", "\n", "\n", "temp_max_num", "=", "0", "\n", "temp_max_cls", "=", "-", "1", "\n", "temp_total_num", "=", "0", "\n", "for", "c", "in", "range", "(", "len", "(", "self", ".", "idx2char", ")", ")", ":", "\n", "                    ", "c_num", "=", "np", ".", "sum", "(", "temp_value", "==", "c", ")", "\n", "temp_total_num", "+=", "c_num", "\n", "if", "c_num", ">", "temp_max_num", ":", "\n", "                        ", "temp_max_num", "=", "c_num", "\n", "temp_max_cls", "=", "c", "\n", "\n", "", "", "if", "temp_max_cls", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "temp_max_score", "=", "1.0", "*", "temp_max_num", "/", "temp_total_num", "\n", "all_res", ".", "append", "(", "\n", "[", "temp_max_cls", ",", "temp_center", ",", "temp_max_num", ",", "temp_max_score", "]", ")", "\n", "\n", "", "all_res", "=", "sorted", "(", "all_res", ",", "key", "=", "lambda", "s", ":", "s", "[", "1", "]", "[", "0", "]", ")", "\n", "chars", ",", "char_scores", "=", "[", "]", ",", "[", "]", "\n", "for", "res", "in", "all_res", ":", "\n", "                ", "temp_area", "=", "res", "[", "2", "]", "\n", "if", "temp_area", "<", "20", ":", "\n", "                    ", "continue", "\n", "", "temp_char_index", "=", "res", "[", "0", "]", "\n", "if", "temp_char_index", ">=", "len", "(", "self", ".", "idx2char", ")", ":", "\n", "                    ", "temp_char", "=", "''", "\n", "", "elif", "temp_char_index", "<=", "0", ":", "\n", "                    ", "temp_char", "=", "''", "\n", "", "elif", "temp_char_index", "==", "self", ".", "unknown_idx", ":", "\n", "                    ", "temp_char", "=", "''", "\n", "", "else", ":", "\n", "                    ", "temp_char", "=", "self", ".", "idx2char", "[", "temp_char_index", "]", "\n", "", "chars", ".", "append", "(", "temp_char", ")", "\n", "char_scores", ".", "append", "(", "res", "[", "3", "]", ")", "\n", "\n", "", "text", "=", "''", ".", "join", "(", "chars", ")", "\n", "\n", "texts", ".", "append", "(", "text", ")", "\n", "scores", ".", "append", "(", "char_scores", ")", "\n", "\n", "", "return", "texts", ",", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor": [[28, 69], ["mmocr.is_type_list", "abi.ABIConvertor.str2idx", "torch.stack().long", "torch.LongTensor", "tensors.append", "torch.LongTensor().fill_", "torch.LongTensor().fill_.size", "torch.stack().long.append", "torch.stack", "torch.LongTensor", "torch.ones", "torch.LongTensor.size"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx"], ["def", "str2tensor", "(", "self", ",", "strings", ")", ":", "\n", "        ", "\"\"\"\n        Convert text-string into tensor. Different from\n        :obj:`mmocr.models.textrecog.convertors.AttnConvertor`, the targets\n        field returns target index no longer than max_seq_len (EOS token\n        included).\n\n        Args:\n            strings (list[str]): For instance, ['hello', 'world']\n\n        Returns:\n            dict: A dict with two tensors.\n\n            - | targets (list[Tensor]): [torch.Tensor([1,2,3,3,4,8]),\n                torch.Tensor([5,4,6,3,7,8])]\n            - | padded_targets (Tensor): Tensor of shape\n                (bsz * max_seq_len)).\n        \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "strings", ",", "str", ")", "\n", "\n", "tensors", ",", "padded_targets", "=", "[", "]", ",", "[", "]", "\n", "indexes", "=", "self", ".", "str2idx", "(", "strings", ")", "\n", "for", "index", "in", "indexes", ":", "\n", "            ", "tensor", "=", "torch", ".", "LongTensor", "(", "index", "[", ":", "self", ".", "max_seq_len", "-", "1", "]", "+", "\n", "[", "self", ".", "end_idx", "]", ")", "\n", "tensors", ".", "append", "(", "tensor", ")", "\n", "# target tensor for loss", "\n", "src_target", "=", "torch", ".", "LongTensor", "(", "tensor", ".", "size", "(", "0", ")", "+", "1", ")", ".", "fill_", "(", "0", ")", "\n", "src_target", "[", "0", "]", "=", "self", ".", "start_idx", "\n", "src_target", "[", "1", ":", "]", "=", "tensor", "\n", "padded_target", "=", "(", "torch", ".", "ones", "(", "self", ".", "max_seq_len", ")", "*", "\n", "self", ".", "padding_idx", ")", ".", "long", "(", ")", "\n", "char_num", "=", "src_target", ".", "size", "(", "0", ")", "\n", "if", "char_num", ">", "self", ".", "max_seq_len", ":", "\n", "                ", "padded_target", "=", "src_target", "[", ":", "self", ".", "max_seq_len", "]", "\n", "", "else", ":", "\n", "                ", "padded_target", "[", ":", "char_num", "]", "=", "src_target", "\n", "", "padded_targets", ".", "append", "(", "padded_target", ")", "\n", "", "padded_targets", "=", "torch", ".", "stack", "(", "padded_targets", ",", "0", ")", ".", "long", "(", ")", "\n", "\n", "return", "{", "'targets'", ":", "tensors", ",", "'padded_targets'", ":", "padded_targets", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.__init__": [[23, 55], ["mmocr.utils.list_from_file", "len", "enumerate", "len", "ner_convertor.NerConvertor.word2ids.update", "ner_convertor.NerConvertor._generate_labelid_dict", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor._generate_labelid_dict"], ["def", "__init__", "(", "self", ",", "\n", "annotation_type", "=", "'bio'", ",", "\n", "vocab_file", "=", "None", ",", "\n", "categories", "=", "None", ",", "\n", "max_len", "=", "None", ",", "\n", "unknown_id", "=", "100", ",", "\n", "start_id", "=", "101", ",", "\n", "end_id", "=", "102", ")", ":", "\n", "        ", "self", ".", "annotation_type", "=", "annotation_type", "\n", "self", ".", "categories", "=", "categories", "\n", "self", ".", "word2ids", "=", "{", "}", "\n", "self", ".", "max_len", "=", "max_len", "\n", "self", ".", "unknown_id", "=", "unknown_id", "\n", "self", ".", "start_id", "=", "start_id", "\n", "self", ".", "end_id", "=", "end_id", "\n", "assert", "self", ".", "max_len", ">", "2", "\n", "assert", "self", ".", "annotation_type", "in", "[", "'bio'", ",", "'bioes'", "]", "\n", "\n", "vocabs", "=", "list_from_file", "(", "vocab_file", ")", "\n", "self", ".", "vocab_size", "=", "len", "(", "vocabs", ")", "\n", "for", "idx", ",", "vocab", "in", "enumerate", "(", "vocabs", ")", ":", "\n", "            ", "self", ".", "word2ids", ".", "update", "(", "{", "vocab", ":", "idx", "}", ")", "\n", "\n", "", "if", "self", ".", "annotation_type", "==", "'bio'", ":", "\n", "            ", "self", ".", "label2id_dict", ",", "self", ".", "id2label", ",", "self", ".", "ignore_id", "=", "self", ".", "_generate_labelid_dict", "(", ")", "\n", "", "elif", "self", ".", "annotation_type", "==", "'bioes'", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Bioes format is not supported yet!'", ")", "\n", "\n", "", "assert", "self", ".", "ignore_id", "is", "not", "None", "\n", "assert", "self", ".", "id2label", "is", "not", "None", "\n", "self", ".", "num_labels", "=", "len", "(", "self", ".", "id2label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor._generate_labelid_dict": [[56, 76], ["len", "enumerate", "label2id_dict.update", "id2label_dict.update", "id2label_dict.update"], "methods", ["None"], ["", "def", "_generate_labelid_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generate a dictionary that maps input to ID and ID to output.\"\"\"", "\n", "num_classes", "=", "len", "(", "self", ".", "categories", ")", "\n", "label2id_dict", "=", "{", "}", "\n", "ignore_id", "=", "2", "*", "num_classes", "+", "1", "\n", "id2label_dict", "=", "{", "\n", "0", ":", "'X'", ",", "\n", "ignore_id", ":", "'O'", ",", "\n", "2", "*", "num_classes", "+", "2", ":", "'[START]'", ",", "\n", "2", "*", "num_classes", "+", "3", ":", "'[END]'", "\n", "}", "\n", "\n", "for", "index", ",", "category", "in", "enumerate", "(", "self", ".", "categories", ")", ":", "\n", "            ", "start_label", "=", "index", "+", "1", "\n", "end_label", "=", "index", "+", "1", "+", "num_classes", "\n", "label2id_dict", ".", "update", "(", "{", "category", ":", "[", "start_label", ",", "end_label", "]", "}", ")", "\n", "id2label_dict", ".", "update", "(", "{", "start_label", ":", "'B-'", "+", "category", "}", ")", "\n", "id2label_dict", ".", "update", "(", "{", "end_label", ":", "'I-'", "+", "category", "}", ")", "\n", "\n", "", "return", "label2id_dict", ",", "id2label_dict", ",", "ignore_id", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_text2id": [[77, 102], ["text.lower", "min", "range", "len", "ids.append", "ids.append"], "methods", ["None"], ["", "def", "convert_text2id", "(", "self", ",", "text", ")", ":", "\n", "        ", "\"\"\"Convert characters to ids.\n\n        If the input is uppercase,\n            convert to lowercase first.\n        Args:\n            text (list[char]): Annotations of one paragraph.\n        Returns:\n            input_ids (list): Corresponding IDs after conversion.\n        \"\"\"", "\n", "ids", "=", "[", "]", "\n", "for", "word", "in", "text", ".", "lower", "(", ")", ":", "\n", "            ", "if", "word", "in", "self", ".", "word2ids", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "word2ids", "[", "word", "]", ")", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "unknown_id", ")", "\n", "# Text that exceeds the maximum length is truncated.", "\n", "", "", "valid_len", "=", "min", "(", "len", "(", "text", ")", ",", "self", ".", "max_len", ")", "\n", "input_ids", "=", "[", "0", "]", "*", "self", ".", "max_len", "\n", "input_ids", "[", "0", "]", "=", "self", ".", "start_id", "\n", "for", "i", "in", "range", "(", "1", ",", "valid_len", "+", "1", ")", ":", "\n", "            ", "input_ids", "[", "i", "]", "=", "ids", "[", "i", "-", "1", "]", "\n", "", "input_ids", "[", "i", "+", "1", "]", "=", "self", ".", "end_id", "\n", "\n", "return", "input_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_entity2label": [[103, 126], ["range", "min", "len", "range", "len"], "methods", ["None"], ["", "def", "convert_entity2label", "(", "self", ",", "label", ",", "text_len", ")", ":", "\n", "        ", "\"\"\"Convert labeled entities to ids.\n\n        Args:\n            label (dict): Labels of entities.\n            text_len (int): The length of input text.\n        Returns:\n            labels (list): Label ids of an input text.\n        \"\"\"", "\n", "labels", "=", "[", "0", "]", "*", "self", ".", "max_len", "\n", "for", "j", "in", "range", "(", "min", "(", "text_len", "+", "2", ",", "self", ".", "max_len", ")", ")", ":", "\n", "            ", "labels", "[", "j", "]", "=", "self", ".", "ignore_id", "\n", "", "categories", "=", "label", "\n", "for", "key", "in", "categories", ":", "\n", "            ", "for", "text", "in", "categories", "[", "key", "]", ":", "\n", "                ", "for", "place", "in", "categories", "[", "key", "]", "[", "text", "]", ":", "\n", "# Remove the label position beyond the maximum length.", "\n", "                    ", "if", "place", "[", "0", "]", "+", "1", "<", "len", "(", "labels", ")", ":", "\n", "                        ", "labels", "[", "place", "[", "0", "]", "+", "1", "]", "=", "self", ".", "label2id_dict", "[", "key", "]", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "place", "[", "0", "]", "+", "1", ",", "place", "[", "1", "]", "+", "1", ")", ":", "\n", "                            ", "if", "i", "+", "1", "<", "len", "(", "labels", ")", ":", "\n", "                                ", "labels", "[", "i", "+", "1", "]", "=", "self", ".", "label2id_dict", "[", "key", "]", "[", "1", "]", "\n", "", "", "", "", "", "", "return", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_pred2entities": [[127, 174], ["masks.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "isinstance", "enumerate", "enumerate", "pred_entities.append", "masks.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "isinstance", "tag.startswith", "NotImplementedError", "masks.detach().cpu().numpy.detach().cpu().numpy.detach", "numpy.array", "entities.append", "tag.split", "entities.append", "tag.startswith", "tag.split", "entities.append", "entities.append", "len", "len"], "methods", ["None"], ["", "def", "convert_pred2entities", "(", "self", ",", "preds", ",", "masks", ")", ":", "\n", "        ", "\"\"\"Gets entities from preds.\n\n        Args:\n            preds (list): Sequence of preds.\n            masks (tensor): The valid part is 1 and the invalid part is 0.\n        Returns:\n            pred_entities (list): List of [[[entity_type,\n                                entity_start, entity_end]]].\n        \"\"\"", "\n", "\n", "masks", "=", "masks", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_entities", "=", "[", "]", "\n", "assert", "isinstance", "(", "preds", ",", "list", ")", "\n", "for", "index", ",", "pred", "in", "enumerate", "(", "preds", ")", ":", "\n", "            ", "entities", "=", "[", "]", "\n", "entity", "=", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "\n", "results", "=", "(", "masks", "[", "index", "]", "[", "1", ":", "]", "*", "np", ".", "array", "(", "pred", "[", "1", ":", "]", ")", ")", ".", "tolist", "(", ")", "\n", "for", "index", ",", "tag", "in", "enumerate", "(", "results", ")", ":", "\n", "                ", "if", "not", "isinstance", "(", "tag", ",", "str", ")", ":", "\n", "                    ", "tag", "=", "self", ".", "id2label", "[", "tag", "]", "\n", "", "if", "self", ".", "annotation_type", "==", "'bio'", ":", "\n", "                    ", "if", "tag", ".", "startswith", "(", "'B-'", ")", ":", "\n", "                        ", "if", "entity", "[", "2", "]", "!=", "-", "1", "and", "entity", "[", "1", "]", "<", "entity", "[", "2", "]", ":", "\n", "                            ", "entities", ".", "append", "(", "entity", ")", "\n", "", "entity", "=", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "\n", "entity", "[", "1", "]", "=", "index", "\n", "entity", "[", "0", "]", "=", "tag", ".", "split", "(", "'-'", ")", "[", "1", "]", "\n", "entity", "[", "2", "]", "=", "index", "\n", "if", "index", "==", "len", "(", "results", ")", "-", "1", "and", "entity", "[", "1", "]", "<", "entity", "[", "2", "]", ":", "\n", "                            ", "entities", ".", "append", "(", "entity", ")", "\n", "", "", "elif", "tag", ".", "startswith", "(", "'I-'", ")", "and", "entity", "[", "1", "]", "!=", "-", "1", ":", "\n", "                        ", "_type", "=", "tag", ".", "split", "(", "'-'", ")", "[", "1", "]", "\n", "if", "_type", "==", "entity", "[", "0", "]", ":", "\n", "                            ", "entity", "[", "2", "]", "=", "index", "\n", "\n", "", "if", "index", "==", "len", "(", "results", ")", "-", "1", "and", "entity", "[", "1", "]", "<", "entity", "[", "2", "]", ":", "\n", "                            ", "entities", ".", "append", "(", "entity", ")", "\n", "", "", "else", ":", "\n", "                        ", "if", "entity", "[", "2", "]", "!=", "-", "1", "and", "entity", "[", "1", "]", "<", "entity", "[", "2", "]", ":", "\n", "                            ", "entities", ".", "append", "(", "entity", ")", "\n", "", "entity", "=", "[", "-", "1", ",", "-", "1", ",", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "(", "\n", "'The data format is not supported yet!'", ")", "\n", "", "", "pred_entities", ".", "append", "(", "entities", ")", "\n", "", "return", "pred_entities", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lv_converter.collect_files": [[12, 46], ["isinstance", "os.listdir", "os.listdir", "list", "len", "print", "os.listdir", "os.listdir", "zip", "os.join", "os.join", "os.listdir", "os.listdir", "os.isdir", "crt_file.endswith", "len", "os.join", "os.join", "os.path.exists", "os.path.exists", "crt_file.replace", "ann_list.append", "imgs_list.append"], "function", ["None"], ["\n", "assert", "isinstance", "(", "root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "# LV has already provided txt format annos", "\n", "        ", "return", "\n", "\n", "", "if", "format", "==", "'jsonl'", ":", "\n", "        ", "lines", "=", "[", "]", "\n", "with", "open", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.txt'", ")", ",", "\n", "'r'", ",", "\n", "encoding", "=", "'\"utf-8-sig'", ")", "as", "f", ":", "\n", "            ", "annos", "=", "f", ".", "readlines", "(", ")", "\n", "", "for", "anno", "in", "annos", ":", "\n", "            ", "if", "anno", ":", "\n", "# Text may contain spaces", "\n", "                ", "dst_img_name", ",", "word", "=", "anno", ".", "split", "(", "'png '", ")", "\n", "word", "=", "word", ".", "strip", "(", "'\\n'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lv_converter.collect_annotations": [[48, 68], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "dst_img_name", "+", "'png'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "list_to_file", "(", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", ",", "lines", ")", "\n", "\n", "\n", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of Lecture Video DB'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of Lecture Video DB'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lv_converter.load_img_info": [[70, 100], ["isinstance", "mmcv.imread", "dict", "os.path.split", "os.path.split", "lv_converter.load_xml_info", "os.basename().split", "os.basename().split", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info"], ["\n", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'train'", ",", "'val'", ",", "'test'", "]", ":", "\n", "        ", "convert_annotations", "(", "root_path", ",", "split", ",", "args", ".", "format", ")", "\n", "print", "(", "f'{split} split converted.'", ")", "\n", "\n", "\n", "", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lv_converter.load_xml_info": [[102, 153], ["xml.parse", "ET.parse.getroot", "obj.getroot.iter", "img_info.update", "max", "max", "int", "int", "dict", "anno_info.append", "int", "int", "abs", "abs", "ET.parse.find().find", "ET.parse.find().find", "ET.parse.find().find", "ET.parse.find().find", "ET.parse.find", "ET.parse.find", "ET.parse.find", "ET.parse.find"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lv_converter.parse_args": [[155, 163], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lv_converter.main": [[165, 177], ["lv_converter.parse_args", "print", "mmcv.Timer", "lv_converter.collect_files", "lv_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rects_converter.collect_files": [[12, 51], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "ann_list.append", "imgs_list.append", "zip", "enumerate", "os.join", "os.join", "ann_file.replace", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "ann_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "ann_file", ".", "replace", "(", "'json'", ",", "'jpg'", ")", ")", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rects_converter.collect_annotations": [[53, 72], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rects_converter.load_img_info": [[74, 102], ["isinstance", "mmcv.imread", "dict", "rects_converter.load_json_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.json'", ":", "\n", "        ", "img_info", "=", "load_json_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rects_converter.load_json_info": [[104, 166], ["mmcv.load", "img_info.update", "max", "max", "abs", "abs", "dict", "anno_info.append", "min", "min", "max", "max"], "function", ["None"], ["\n", "\n", "", "def", "load_json_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n\n    {\n        \"chars\": [\n            {\n                \"ignore\": 0,\n                \"transcription\": \"H\",\n                \"points\": [25, 175, 112, 175, 112, 286, 25, 286]\n            },\n            {\n                \"ignore\": 0,\n                \"transcription\": \"O\",\n                \"points\": [102, 182, 210, 182, 210, 273, 102, 273]\n            }, ...\n        ]\n        \"lines\": [\n            {\n                \"ignore\": 0,\n                \"transcription\": \"HOKI\",\n                \"points\": [23, 173, 327, 180, 327, 290, 23, 283]\n            },\n            {\n                \"ignore\": 0,\n                \"transcription\": \"TEA\",\n                \"points\": [368, 180, 621, 180, 621, 294, 368, 294]\n            }, ...\n        ]\n    }\n\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "annotation", "[", "'lines'", "]", ":", "\n", "        ", "if", "line", "[", "'ignore'", "]", "==", "1", ":", "\n", "            ", "continue", "\n", "", "segmentation", "=", "line", "[", "'points'", "]", "\n", "word", "=", "line", "[", "'transcription'", "]", "\n", "anno", "=", "dict", "(", "bbox", "=", "segmentation", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rects_converter.parse_args": [[168, 178], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "print", "(", "'Cropping images...'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rects_converter.main": [[180, 202], ["rects_converter.parse_args", "rects_converter.collect_files", "rects_converter.collect_annotations", "os.join", "os.join", "mmcv.Timer", "mmocr.utils.convert_annotations", "len", "rects_converter.collect_annotations", "os.join", "mmcv.Timer", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.sroie_converter.collect_files": [[12, 42], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "sorted", "sorted", "gt_file.replace", "len"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "gt_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "# Filtering repeated and missing images", "\n", "        ", "if", "'('", "in", "gt_file", "or", "gt_file", "==", "'X51006619570.txt'", ":", "\n", "            ", "continue", "\n", "", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "gt_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "gt_file", ".", "replace", "(", "'.txt'", ",", "'.jpg'", ")", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "sorted", "(", "imgs_list", ")", ",", "sorted", "(", "ann_list", ")", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.sroie_converter.collect_annotations": [[44, 65], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.sroie_converter.load_img_info": [[67, 97], ["isinstance", "mmcv.imread", "dict", "sroie_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.sroie_converter.load_txt_info": [[99, 137], ["img_info.update", "open", "f.readlines", "max", "max", "dict", "anno_info.append", "numpy.array().astype().tolist", "min", "min", "max", "max", "numpy.array().astype", "numpy.array", "ann.split"], "function", ["None"], ["\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Annotation Format\n    x1, y1, x2, y2, x3, y3, x4, y4, transcript\n\n    Args:\n        gt_file (list): The list of tuples (image_file, groundtruth_file)\n        img_info (int): The dict of the img and annotation information\n\n    Returns:\n        img_info (list): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'unicode_escape'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "for", "ann", "in", "f", ".", "readlines", "(", ")", ":", "\n", "# skip invalid annotation line", "\n", "            ", "try", ":", "\n", "                ", "bbox", "=", "np", ".", "array", "(", "ann", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", ")", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "", "except", "ValueError", ":", "\n", "\n", "                ", "continue", "\n", "", "word", "=", "ann", ".", "split", "(", "','", ")", "[", "-", "1", "]", ".", "replace", "(", "'\\n'", ",", "''", ")", ".", "strip", "(", ")", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.sroie_converter.parse_args": [[139, 147], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.sroie_converter.main": [[149, 163], ["sroie_converter.parse_args", "print", "mmcv.Timer", "sroie_converter.collect_files", "sroie_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ",", "\n", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.cocotext_converter.parse_args": [[11, 17], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of COCO Text v2 '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of COCO Text v2'", ")", "\n", "parser", ".", "add_argument", "(", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.cocotext_converter.collect_cocotext_info": [[19, 107], ["os.join", "mmcv.load", "enumerate", "os.exists", "Exception", "annotation[].values", "print", "img_info.update", "img_infos.append", "len", "dict", "anno_info.append", "str", "max", "max", "math.ceil", "math.ceil", "max", "len", "str", "math.floor", "math.floor", "int", "len", "annotation[].values", "len"], "function", ["None"], ["parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ",", "ignore_image_root", ",", "\n", "preserve_vertical", ",", "split", ",", "format", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "src_image_root", ",", "img_info", "[", "'file_name'", "]", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "text_label", "=", "ann", "[", "'utf8_string'", "]", "\n", "\n", "# Ignore illegible or non-English words", "\n", "if", "ann", "[", "'language'", "]", "==", "'not english'", ":", "\n", "            ", "continue", "\n", "", "if", "ann", "[", "'legibility'", "]", "==", "'illegible'", ":", "\n", "            ", "continue", "\n", "\n", "", "x", ",", "y", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "\n", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'train'", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "labels", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "return", "labels", "\n", "\n", "\n", "", "def", "convert_cocotext", "(", "root_path", ",", "\n", "split", ",", "\n", "preserve_vertical", ",", "\n", "format", ",", "\n", "nproc", ",", "\n", "img_start_idx", "=", "0", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.cocotext_converter.main": [[109, 120], ["cocotext_converter.parse_args", "print", "cocotext_converter.collect_cocotext_info", "mmocr.utils.convert_annotations", "print", "cocotext_converter.collect_cocotext_info", "mmocr.utils.convert_annotations", "print", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.cocotext_converter.collect_cocotext_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.cocotext_converter.collect_cocotext_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.icdar_converter.collect_files": [[14, 45], ["isinstance", "isinstance", "len", "print", "imgs_list.extend", "files.append", "glob.glob", "os.join", "len", "os.splitext", "os.basename"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir(str): The image directory\n        gt_dir(str): The groundtruth directory\n\n    Returns:\n        files(list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "# note that we handle png and jpg only. Pls convert others such as gif to", "\n", "# jpg or png offline", "\n", "suffixes", "=", "[", "'.png'", ",", "'.PNG'", ",", "'.jpg'", ",", "'.JPG'", ",", "'.jpeg'", ",", "'.JPEG'", "]", "\n", "imgs_list", "=", "[", "]", "\n", "for", "suffix", "in", "suffixes", ":", "\n", "        ", "imgs_list", ".", "extend", "(", "glob", ".", "glob", "(", "osp", ".", "join", "(", "img_dir", ",", "'*'", "+", "suffix", ")", ")", ")", "\n", "\n", "", "files", "=", "[", "]", "\n", "for", "img_file", "in", "imgs_list", ":", "\n", "        ", "gt_file", "=", "gt_dir", "+", "'/gt_'", "+", "osp", ".", "splitext", "(", "\n", "osp", ".", "basename", "(", "img_file", ")", ")", "[", "0", "]", "+", "'.txt'", "\n", "files", ".", "append", "(", "(", "img_file", ",", "gt_file", ")", ")", "\n", "", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.icdar_converter.collect_annotations": [[47, 71], ["isinstance", "isinstance", "isinstance", "functools.partial", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "dataset", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files(list): The list of tuples (image_file, groundtruth_file)\n        dataset(str): The dataset name, icdar2015 or icdar2017\n        nproc(int): The number of process to collect annotations\n\n    Returns:\n        images(list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "dataset", ",", "str", ")", "\n", "assert", "dataset", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "load_img_info_with_dataset", "=", "partial", "(", "load_img_info", ",", "dataset", "=", "dataset", ")", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info_with_dataset", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info_with_dataset", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.icdar_converter.load_img_info": [[73, 137], ["isinstance", "isinstance", "mmcv.imread", "os.basename", "dict", "mmocr.utils.list_from_file", "line.strip.strip", "line.strip.split", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "os.dirname", "mmocr.utils.list_from_file", "NotImplementedError", "int", "print", "os.join", "os.join", "numpy.array", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["", "def", "load_img_info", "(", "files", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files(tuple): The tuple of (img_file, groundtruth_file)\n        dataset(str): Dataset name, icdar2015 or icdar2017\n\n    Returns:\n        img_info(dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "dataset", ",", "str", ")", "\n", "assert", "dataset", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "# read imgs with ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "if", "dataset", "==", "'icdar2017'", ":", "\n", "        ", "gt_list", "=", "list_from_file", "(", "gt_file", ")", "\n", "", "elif", "dataset", "==", "'icdar2015'", ":", "\n", "        ", "gt_list", "=", "list_from_file", "(", "gt_file", ",", "encoding", "=", "'utf-8-sig'", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "f'Not support {dataset}'", ")", "\n", "\n", "", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "gt_list", ":", "\n", "# each line has one ploygen (4 vetices), and others.", "\n", "# e.g., 695,885,866,888,867,1146,696,1143,Latin,9", "\n", "        ", "line", "=", "line", ".", "strip", "(", ")", "\n", "strs", "=", "line", ".", "split", "(", "','", ")", "\n", "category_id", "=", "1", "\n", "xy", "=", "[", "int", "(", "x", ")", "for", "x", "in", "strs", "[", "0", ":", "8", "]", "]", "\n", "coordinates", "=", "np", ".", "array", "(", "xy", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "iscrowd", "=", "0", "\n", "# set iscrowd to 1 to ignore 1.", "\n", "if", "(", "dataset", "==", "'icdar2015'", "\n", "and", "strs", "[", "8", "]", "==", "'###'", ")", "or", "(", "dataset", "==", "'icdar2017'", "\n", "and", "strs", "[", "9", "]", "==", "'###'", ")", ":", "\n", "            ", "iscrowd", "=", "1", "\n", "print", "(", "'ignore text'", ")", "\n", "\n", "", "area", "=", "polygon", ".", "area", "\n", "# convert to COCO style XYWH format", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", "-", "min_x", ",", "max_y", "-", "min_y", "]", "\n", "\n", "anno", "=", "dict", "(", "\n", "iscrowd", "=", "iscrowd", ",", "\n", "category_id", "=", "category_id", ",", "\n", "bbox", "=", "bbox", ",", "\n", "area", "=", "area", ",", "\n", "segmentation", "=", "[", "xy", "]", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "", "split_name", "=", "osp", ".", "basename", "(", "osp", ".", "dirname", "(", "img_file", ")", ")", "\n", "img_info", "=", "dict", "(", "\n", "# remove img_prefix for filename", "\n", "file_name", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "anno_info", "=", "anno_info", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.icdar_converter.parse_args": [[139, 156], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert Icdar2015 or Icdar2017 annotations to COCO format'", "\n", ")", "\n", "parser", ".", "add_argument", "(", "'icdar_path'", ",", "help", "=", "'icdar root path'", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--out-dir'", ",", "help", "=", "'output path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-d'", ",", "'--dataset'", ",", "required", "=", "True", ",", "help", "=", "'icdar2017 or icdar2015'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--split-list'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'a list of splits. e.g., \"--split-list training test\"'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.icdar_converter.main": [[158, 180], ["icdar_converter.parse_args", "mmcv.mkdir_or_exist", "os.join", "os.join", "set_name.items", "set_name.update", "os.exists", "print", "os.join", "mmcv.Timer", "icdar_converter.collect_files", "icdar_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "icdar_path", "=", "args", ".", "icdar_path", "\n", "out_dir", "=", "args", ".", "out_dir", "if", "args", ".", "out_dir", "else", "icdar_path", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_dir", ")", "\n", "\n", "img_dir", "=", "osp", ".", "join", "(", "icdar_path", ",", "'imgs'", ")", "\n", "gt_dir", "=", "osp", ".", "join", "(", "icdar_path", ",", "'annotations'", ")", "\n", "\n", "set_name", "=", "{", "}", "\n", "for", "split", "in", "args", ".", "split_list", ":", "\n", "        ", "set_name", ".", "update", "(", "{", "split", ":", "'instances_'", "+", "split", "+", "'.json'", "}", ")", "\n", "assert", "osp", ".", "exists", "(", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ")", "\n", "\n", "", "for", "split", ",", "json_name", "in", "set_name", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "f'Converting {split} into {json_name}'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert icdar annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ",", "osp", ".", "join", "(", "gt_dir", ",", "split", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "\n", "files", ",", "args", ".", "dataset", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "convert_annotations", "(", "image_infos", ",", "osp", ".", "join", "(", "out_dir", ",", "json_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.parse_args": [[12, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["from", "mmocr", ".", "utils", ".", "fileio", "import", "list_to_file", "\n", "\n", "\n", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training, validation and test set of IMGUR '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of IMGUR'", ")", "\n", "parser", ".", "add_argument", "(", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.collect_imgur_info": [[21, 80], ["os.join", "mmcv.load", "annotation[].keys", "enumerate", "os.exists", "Exception", "os.join", "mmcv.imread", "dict", "dict.update", "img_infos.append", "print", "os.exists", "numpy.fromstring", "imgur_converter.convert_oriented_box", "max", "max", "dict", "anno_info.append", "math.floor", "math.floor", "math.floor", "math.floor", "min", "min", "max", "max", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.convert_oriented_box"], ["default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "\n", "\n", "", "def", "collect_imgur_info", "(", "root_path", ",", "annotation_filename", ",", "print_every", "=", "1000", ")", ":", "\n", "\n", "    ", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "annotation_filename", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "images", "=", "annotation", "[", "'index_to_ann_map'", "]", ".", "keys", "(", ")", "\n", "img_infos", "=", "[", "]", "\n", "for", "i", ",", "img_name", "in", "enumerate", "(", "images", ")", ":", "\n", "        ", "if", "i", ">=", "0", "and", "i", "%", "print_every", "==", "0", ":", "\n", "            ", "print", "(", "f'{i}/{len(images)}'", ")", "\n", "\n", "", "img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "img_name", "+", "'.jpg'", ")", "\n", "\n", "# Skip not exist images", "\n", "if", "not", "osp", ".", "exists", "(", "img_path", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "img", "=", "mmcv", ".", "imread", "(", "img_path", ",", "'unchanged'", ")", "\n", "\n", "# Skip broken images", "\n", "if", "img", "is", "None", ":", "\n", "            ", "continue", "\n", "\n", "", "img_info", "=", "dict", "(", "\n", "file_name", "=", "img_name", "+", "'.jpg'", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ")", "\n", "\n", "anno_info", "=", "[", "]", "\n", "for", "ann_id", "in", "annotation", "[", "'index_to_ann_map'", "]", "[", "img_name", "]", ":", "\n", "            ", "ann", "=", "annotation", "[", "'ann_id'", "]", "[", "ann_id", "]", "\n", "\n", "# The original annotation is oriented rects [x, y, w, h, a]", "\n", "box", "=", "np", ".", "fromstring", "(", "\n", "ann", "[", "'bounding_box'", "]", "[", "1", ":", "-", "2", "]", ",", "sep", "=", "','", ",", "dtype", "=", "float", ")", "\n", "bbox", "=", "convert_oriented_box", "(", "box", ")", "\n", "word", "=", "ann", "[", "'word'", "]", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "img_infos", ".", "append", "(", "img_info", ")", "\n", "\n", "", "return", "img_infos", "\n", "\n", "\n", "", "def", "convert_oriented_box", "(", "box", ")", ":", "\n", "\n", "    ", "x_ctr", ",", "y_ctr", ",", "width", ",", "height", ",", "angle", "=", "box", "[", ":", "5", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.convert_oriented_box": [[82, 98], ["numpy.array", "numpy.array", "np.array.dot", "numpy.array", "imgur_converter.get_best_begin_point_single", "get_best_begin_point_single.tolist", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.get_best_begin_point_single"], ["\n", "tl_x", ",", "tl_y", ",", "br_x", ",", "br_y", "=", "-", "width", "/", "2", ",", "-", "height", "/", "2", ",", "width", "/", "2", ",", "height", "/", "2", "\n", "rect", "=", "np", ".", "array", "(", "[", "[", "tl_x", ",", "br_x", ",", "br_x", ",", "tl_x", "]", ",", "[", "tl_y", ",", "tl_y", ",", "br_y", ",", "br_y", "]", "]", ")", "\n", "R", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "angle", ")", ",", "-", "np", ".", "sin", "(", "angle", ")", "]", ",", "\n", "[", "np", ".", "sin", "(", "angle", ")", ",", "np", ".", "cos", "(", "angle", ")", "]", "]", ")", "\n", "poly", "=", "R", ".", "dot", "(", "rect", ")", "\n", "x0", ",", "x1", ",", "x2", ",", "x3", "=", "poly", "[", "0", ",", ":", "4", "]", "+", "x_ctr", "\n", "y0", ",", "y1", ",", "y2", ",", "y3", "=", "poly", "[", "1", ",", ":", "4", "]", "+", "y_ctr", "\n", "poly", "=", "np", ".", "array", "(", "[", "x0", ",", "y0", ",", "x1", ",", "y1", ",", "x2", ",", "y2", ",", "x3", ",", "y3", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "poly", "=", "get_best_begin_point_single", "(", "poly", ")", "\n", "\n", "return", "poly", ".", "tolist", "(", ")", "\n", "\n", "\n", "", "def", "get_best_begin_point_single", "(", "coordinate", ")", ":", "\n", "\n", "    ", "x1", ",", "y1", ",", "x2", ",", "y2", ",", "x3", ",", "y3", ",", "x4", ",", "y4", "=", "coordinate", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.get_best_begin_point_single": [[100, 126], ["min", "min", "max", "max", "range", "numpy.array().reshape", "imgur_converter.cal_line_length", "numpy.array", "imgur_converter.cal_line_length", "imgur_converter.cal_line_length", "imgur_converter.cal_line_length"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length"], ["ymin", "=", "min", "(", "y1", ",", "y2", ",", "y3", ",", "y4", ")", "\n", "xmax", "=", "max", "(", "x1", ",", "x2", ",", "x3", ",", "x4", ")", "\n", "ymax", "=", "max", "(", "y1", ",", "y2", ",", "y3", ",", "y4", ")", "\n", "combine", "=", "[", "[", "[", "x1", ",", "y1", "]", ",", "[", "x2", ",", "y2", "]", ",", "[", "x3", ",", "y3", "]", ",", "[", "x4", ",", "y4", "]", "]", ",", "\n", "[", "[", "x2", ",", "y2", "]", ",", "[", "x3", ",", "y3", "]", ",", "[", "x4", ",", "y4", "]", ",", "[", "x1", ",", "y1", "]", "]", ",", "\n", "[", "[", "x3", ",", "y3", "]", ",", "[", "x4", ",", "y4", "]", ",", "[", "x1", ",", "y1", "]", ",", "[", "x2", ",", "y2", "]", "]", ",", "\n", "[", "[", "x4", ",", "y4", "]", ",", "[", "x1", ",", "y1", "]", ",", "[", "x2", ",", "y2", "]", ",", "[", "x3", ",", "y3", "]", "]", "]", "\n", "dst_coordinate", "=", "[", "[", "xmin", ",", "ymin", "]", ",", "[", "xmax", ",", "ymin", "]", ",", "[", "xmax", ",", "ymax", "]", ",", "[", "xmin", ",", "ymax", "]", "]", "\n", "force", "=", "100000000.0", "\n", "force_flag", "=", "0", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "temp_force", "=", "cal_line_length", "(", "combine", "[", "i", "]", "[", "0", "]", ",", "dst_coordinate", "[", "0", "]", ")", "+", "cal_line_length", "(", "combine", "[", "i", "]", "[", "1", "]", ",", "dst_coordinate", "[", "1", "]", ")", "+", "cal_line_length", "(", "combine", "[", "i", "]", "[", "2", "]", ",", "dst_coordinate", "[", "2", "]", ")", "+", "cal_line_length", "(", "combine", "[", "i", "]", "[", "3", "]", ",", "dst_coordinate", "[", "3", "]", ")", "\n", "if", "temp_force", "<", "force", ":", "\n", "            ", "force", "=", "temp_force", "\n", "force_flag", "=", "i", "\n", "", "", "if", "force_flag", "!=", "0", ":", "\n", "        ", "pass", "\n", "\n", "", "return", "np", ".", "array", "(", "combine", "[", "force_flag", "]", ")", ".", "reshape", "(", "8", ")", "\n", "\n", "\n", "", "def", "cal_line_length", "(", "point1", ",", "point2", ")", ":", "\n", "\n", "    ", "return", "math", ".", "sqrt", "(", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.cal_line_length": [[128, 133], ["math.sqrt", "math.pow", "math.pow"], "function", ["None"], ["math", ".", "pow", "(", "point1", "[", "1", "]", "-", "point2", "[", "1", "]", ",", "2", ")", ")", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "format", ")", ":", "\n", "\n", "    ", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.main": [[135, 146], ["imgur_converter.parse_args", "print", "mmcv.Timer", "imgur_converter.collect_imgur_info", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.imgur_converter.collect_imgur_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.mtwi_converter.collect_files": [[14, 67], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "os.join", "ann_list.append", "imgs_list.append", "zip", "enumerate", "ann_file.replace", "os.join", "mmcv.imread", "print", "PIL.Image.open", "img.convert.convert", "img.convert.save", "print", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.kie.closeset_to_openset.convert"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "ann_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "img_file", "=", "osp", ".", "join", "(", "img_dir", ",", "ann_file", ".", "replace", "(", "'txt'", ",", "'jpg'", ")", ")", "\n", "# This dataset contains some images obtained from .gif,", "\n", "# which cannot be loaded by mmcv.imread(), convert them", "\n", "# to RGB mode.", "\n", "try", ":", "\n", "            ", "if", "mmcv", ".", "imread", "(", "img_file", ")", "is", "None", ":", "\n", "                ", "print", "(", "f'Convert {img_file} to RGB mode.'", ")", "\n", "img", "=", "Image", ".", "open", "(", "img_file", ")", "\n", "img", "=", "img", ".", "convert", "(", "'RGB'", ")", "\n", "img", ".", "save", "(", "img_file", ")", "\n", "", "", "except", "cv2", ".", "error", ":", "\n", "            ", "print", "(", "f'Skip broken img {img_file}'", ")", "\n", "continue", "\n", "\n", "", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "img_file", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.mtwi_converter.collect_annotations": [[69, 88], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.mtwi_converter.load_img_info": [[90, 118], ["isinstance", "mmcv.imread", "dict", "mtwi_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.mtwi_converter.load_txt_info": [[120, 162], ["img_info.update", "open", "f.readlines", "[].rstrip", "max", "max", "abs", "abs", "dict", "anno_info.append", "line.split", "math.floor", "min", "min", "float", "max", "max", "line.split"], "function", ["None"], ["\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x1,y1,x2,y2,x3,y3,x4,y4,text\n\n    45.45,226.83,11.87,181.79,183.84,13.1,233.79,49.95,\u65f6\u5c1a\u888b\u888b\n    345.98,311.18,345.98,347.21,462.26,347.21,462.26,311.18,73774\n    462.26,292.34,461.44,299.71,502.39,299.71,502.39,292.34,73/74/737\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "anno_info", "=", "[", "]", "\n", "with", "open", "(", "gt_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "for", "line", "in", "lines", ":", "\n", "        ", "points", "=", "line", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", "\n", "word", "=", "line", ".", "split", "(", "','", ")", "[", "8", "]", ".", "rstrip", "(", "'\\n'", ")", "\n", "if", "word", "==", "'###'", ":", "\n", "            ", "continue", "\n", "", "bbox", "=", "[", "math", ".", "floor", "(", "float", "(", "pt", ")", ")", "for", "pt", "in", "points", "]", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.mtwi_converter.parse_args": [[164, 174], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "print", "(", "'Cropping images...'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.mtwi_converter.main": [[176, 198], ["mtwi_converter.parse_args", "mtwi_converter.collect_files", "mtwi_converter.collect_annotations", "os.join", "os.join", "mmcv.Timer", "mmocr.utils.convert_annotations", "len", "mtwi_converter.collect_annotations", "os.join", "mmcv.Timer", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Skip vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'training'", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.collect_files": [[11, 37], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "img_file.split", "len"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_file", "=", "img_file", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'_gt_ocr.txt'", "\n", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.collect_annotations": [[39, 59], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.load_img_info": [[61, 90], ["isinstance", "mmcv.imread", "dict", "bid_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.basename", "os.basename", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'_'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "\n", "'_'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "basename", "(", "img_file", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "basename", "(", "gt_file", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.load_txt_info": [[92, 131], ["img_info.update", "open", "line.strip.strip", "line.strip.split", "dict", "anno_info.append", "int"], "function", ["None"], ["\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x, y, w, h, text\n    977, 152, 16, 49, NOME\n    962, 143, 12, 323, APPINHANESI BLAZEK PASSOTTO\n    906, 446, 12, 94, 206940361\n    905, 641, 12, 44, SPTC\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'latin1'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", "'\\n'", ")", "\n", "# Ignore hard samples", "\n", "if", "line", "[", "0", "]", "==", "'['", "or", "line", "[", "0", "]", "==", "'x'", ":", "\n", "                ", "continue", "\n", "", "ann", "=", "line", ".", "split", "(", "','", ")", "\n", "bbox", "=", "ann", "[", "0", ":", "4", "]", "\n", "bbox", "=", "[", "int", "(", "coord", ")", "for", "coord", "in", "bbox", "]", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "bbox", "\n", "# in case ',' exists in label", "\n", "word", "=", "','", ".", "join", "(", "ann", "[", "4", ":", "]", ")", "if", "len", "(", "ann", "[", "4", ":", "]", ")", ">", "1", "else", "ann", "[", "4", "]", "\n", "# remove the initial space", "\n", "word", "=", "word", ".", "strip", "(", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.split_train_val_list": [[133, 150], ["len", "int"], "function", ["None"], ["return", "img_info", "\n", "\n", "\n", "", "def", "split_train_val_list", "(", "full_list", ",", "val_ratio", ")", ":", "\n", "    ", "\"\"\"Split list by val_ratio.\n\n    Args:\n        full_list (list): List to be splited\n        val_ratio (float): Split ratio for val set\n\n    return:\n        list(list, list): Train_list and val_list\n    \"\"\"", "\n", "n_total", "=", "len", "(", "full_list", ")", "\n", "offset", "=", "int", "(", "n_total", "*", "val_ratio", ")", "\n", "if", "n_total", "==", "0", "or", "offset", "<", "1", ":", "\n", "        ", "return", "[", "]", ",", "full_list", "\n", "", "val_list", "=", "full_list", "[", ":", "offset", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.parse_args": [[152, 162], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["return", "[", "train_list", ",", "val_list", "]", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "image_infos", ",", "preserve_vertical", ",", "val_ratio", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.bid_converter.main": [[164, 181], ["bid_converter.parse_args", "mmcv.Timer", "bid_converter.collect_files", "bid_converter.collect_annotations", "enumerate", "os.join", "os.join", "bid_converter.split_train_val_list", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.split_train_val_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["\n", "\n", "assert", "val_ratio", "<=", "1.", "\n", "\n", "if", "val_ratio", ":", "\n", "        ", "image_infos", "=", "split_train_val_list", "(", "image_infos", ",", "val_ratio", ")", "\n", "splits", "=", "[", "'training'", ",", "'val'", "]", "\n", "\n", "", "else", ":", "\n", "        ", "image_infos", "=", "[", "image_infos", "]", "\n", "splits", "=", "[", "'training'", "]", "\n", "\n", "", "for", "i", ",", "split", "in", "enumerate", "(", "splits", ")", ":", "\n", "        ", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.collect_files": [[15, 56], ["isinstance", "isinstance", "imgs_list.extend", "len", "print", "glob.glob", "files.append", "len", "print", "os.join", "files.append", "len", "os.splitext", "len", "os.basename", "os.splitext", "os.basename"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "split", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir(str): The image directory\n        gt_dir(str): The groundtruth directory\n        split(str): The split of dataset. Namely: training or test\n\n    Returns:\n        files(list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "# note that we handle png and jpg only. Pls convert others such as gif to", "\n", "# jpg or png offline", "\n", "suffixes", "=", "[", "'.png'", ",", "'.PNG'", ",", "'.jpg'", ",", "'.JPG'", ",", "'.jpeg'", ",", "'.JPEG'", "]", "\n", "\n", "imgs_list", "=", "[", "]", "\n", "for", "suffix", "in", "suffixes", ":", "\n", "        ", "imgs_list", ".", "extend", "(", "glob", ".", "glob", "(", "osp", ".", "join", "(", "img_dir", ",", "'*'", "+", "suffix", ")", ")", ")", "\n", "\n", "", "files", "=", "[", "]", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "for", "img_file", "in", "imgs_list", ":", "\n", "            ", "gt_file", "=", "gt_dir", "+", "'/'", "+", "osp", ".", "splitext", "(", "\n", "osp", ".", "basename", "(", "img_file", ")", ")", "[", "0", "]", "+", "'.xml'", "\n", "files", ".", "append", "(", "(", "img_file", ",", "gt_file", ")", ")", "\n", "", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "for", "img_file", "in", "imgs_list", ":", "\n", "            ", "gt_file", "=", "gt_dir", "+", "'/000'", "+", "osp", ".", "splitext", "(", "\n", "osp", ".", "basename", "(", "img_file", ")", ")", "[", "0", "]", "+", "'.txt'", "\n", "files", ".", "append", "(", "(", "img_file", ",", "gt_file", ")", ")", "\n", "", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.collect_annotations": [[58, 81], ["isinstance", "isinstance", "isinstance", "functools.partial", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "collect_annotations", "(", "files", ",", "split", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files(list): The list of tuples (image_file, groundtruth_file)\n        split(str): The split of dataset. Namely: training or test\n        nproc(int): The number of process to collect annotations\n\n    Returns:\n        images(list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "load_img_info_with_split", "=", "partial", "(", "load_img_info", ",", "split", "=", "split", ")", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info_with_split", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info_with_split", ",", "files", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.load_txt_info": [[83, 113], ["mmocr.utils.list_from_file", "img_info.update", "line.strip.strip", "line.strip.split", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "int", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "list_from_file", "(", "gt_file", ")", ":", "\n", "# each line has one ploygen (n vetices), and one text.", "\n", "# e.g., 695,885,866,888,867,1146,696,1143,####Latin 9", "\n", "        ", "line", "=", "line", ".", "strip", "(", ")", "\n", "strs", "=", "line", ".", "split", "(", "','", ")", "\n", "category_id", "=", "1", "\n", "assert", "strs", "[", "28", "]", "[", "0", "]", "==", "'#'", "\n", "xy", "=", "[", "int", "(", "x", ")", "for", "x", "in", "strs", "[", "0", ":", "28", "]", "]", "\n", "assert", "len", "(", "xy", ")", "==", "28", "\n", "coordinates", "=", "np", ".", "array", "(", "xy", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "iscrowd", "=", "0", "\n", "area", "=", "polygon", ".", "area", "\n", "# convert to COCO style XYWH format", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", "-", "min_x", ",", "max_y", "-", "min_y", "]", "\n", "text", "=", "strs", "[", "28", "]", "[", "4", ":", "]", "\n", "\n", "anno", "=", "dict", "(", "\n", "iscrowd", "=", "iscrowd", ",", "\n", "category_id", "=", "category_id", ",", "\n", "bbox", "=", "bbox", ",", "\n", "area", "=", "area", ",", "\n", "text", "=", "text", ",", "\n", "segmentation", "=", "[", "xy", "]", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.load_xml_info": [[115, 153], ["xml.parse", "ET.parse.getroot", "img_info.update", "segs.strip().split", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "int", "len", "int", "int", "int", "int", "segs.strip", "numpy.array"], "function", ["None"], ["", "def", "load_xml_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "\n", "    ", "obj", "=", "ET", ".", "parse", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "image", "in", "obj", ".", "getroot", "(", ")", ":", "# image", "\n", "        ", "for", "box", "in", "image", ":", "# image", "\n", "            ", "h", "=", "box", ".", "attrib", "[", "'height'", "]", "\n", "w", "=", "box", ".", "attrib", "[", "'width'", "]", "\n", "x", "=", "box", ".", "attrib", "[", "'left'", "]", "\n", "y", "=", "box", ".", "attrib", "[", "'top'", "]", "\n", "text", "=", "box", "[", "0", "]", ".", "text", "\n", "segs", "=", "box", "[", "1", "]", ".", "text", "\n", "pts", "=", "segs", ".", "strip", "(", ")", ".", "split", "(", "','", ")", "\n", "pts", "=", "[", "int", "(", "x", ")", "for", "x", "in", "pts", "]", "\n", "assert", "len", "(", "pts", ")", "==", "28", "\n", "# pts = []", "\n", "# for iter in range(2,len(box)):", "\n", "#    pts.extend([int(box[iter].attrib['x']),", "\n", "#  int(box[iter].attrib['y'])])", "\n", "iscrowd", "=", "0", "\n", "category_id", "=", "1", "\n", "bbox", "=", "[", "int", "(", "x", ")", ",", "int", "(", "y", ")", ",", "int", "(", "w", ")", ",", "int", "(", "h", ")", "]", "\n", "\n", "coordinates", "=", "np", ".", "array", "(", "pts", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "area", "=", "polygon", ".", "area", "\n", "anno", "=", "dict", "(", "\n", "iscrowd", "=", "iscrowd", ",", "\n", "category_id", "=", "category_id", ",", "\n", "bbox", "=", "bbox", ",", "\n", "area", "=", "area", ",", "\n", "text", "=", "text", ",", "\n", "segmentation", "=", "[", "pts", "]", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.load_img_info": [[155, 189], ["isinstance", "isinstance", "mmcv.imread", "os.basename", "dict", "os.dirname", "ctw1500_converter.load_xml_info", "os.join", "os.join", "ctw1500_converter.load_txt_info", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["", "def", "load_img_info", "(", "files", ",", "split", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files(tuple): The tuple of (img_file, groundtruth_file)\n        split(str): The split of dataset: training or test\n\n    Returns:\n        img_info(dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "# read imgs with ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "split_name", "=", "osp", ".", "basename", "(", "osp", ".", "dirname", "(", "img_file", ")", ")", "\n", "img_info", "=", "dict", "(", "\n", "# remove img_prefix for filename", "\n", "file_name", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "# anno_info=anno_info,", "\n", "segm_file", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "img_info", "=", "load_xml_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.parse_args": [[191, 205], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert ctw1500 annotations to COCO format'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'ctw1500 root path'", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--out-dir'", ",", "help", "=", "'output path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--split-list'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'a list of splits. e.g., \"--split-list training test\"'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ctw1500_converter.main": [[207, 228], ["ctw1500_converter.parse_args", "mmcv.mkdir_or_exist", "os.join", "os.join", "set_name.items", "set_name.update", "os.exists", "print", "os.join", "mmcv.Timer", "ctw1500_converter.collect_files", "ctw1500_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "out_dir", "=", "args", ".", "out_dir", "if", "args", ".", "out_dir", "else", "root_path", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_dir", ")", "\n", "\n", "img_dir", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", "\n", "gt_dir", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", "\n", "\n", "set_name", "=", "{", "}", "\n", "for", "split", "in", "args", ".", "split_list", ":", "\n", "        ", "set_name", ".", "update", "(", "{", "split", ":", "'instances_'", "+", "split", "+", "'.json'", "}", ")", "\n", "assert", "osp", ".", "exists", "(", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ")", "\n", "\n", "", "for", "split", ",", "json_name", "in", "set_name", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "f'Converting {split} into {json_name}'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "print_tmpl", "=", "'It takes {}s to convert icdar annotation'", ")", ":", "\n", "            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ",", "osp", ".", "join", "(", "gt_dir", ",", "split", ")", ",", "split", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "split", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "convert_annotations", "(", "image_infos", ",", "osp", ".", "join", "(", "out_dir", ",", "json_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.convert_gif": [[12, 23], ["PIL.Image.open", "img_path.replace", "Image.open.save", "os.remove", "os.remove", "print"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.collect_files": [[25, 55], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "os.join", "img.endswith", "imgs_list.append", "ann_list.append", "zip", "ic11_converter.convert_gif", "img_path.replace.replace", "os.join", "sorted", "sorted", "len", "img.split"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.convert_gif"], ["\n", "assert", "isinstance", "(", "root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "with", "open", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "\n", "f'Challenge1_{split}_Task3_GT.txt'", ")", ",", "\n", "'r'", ",", "\n", "encoding", "=", "'\"utf-8-sig'", ")", "as", "f", ":", "\n", "        ", "annos", "=", "f", ".", "readlines", "(", ")", "\n", "", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "split", ".", "lower", "(", ")", ")", "\n", "for", "anno", "in", "annos", ":", "\n", "# text may contain comma ','", "\n", "        ", "dst_img_name", ",", "word", "=", "anno", ".", "split", "(", "', \"'", ")", "\n", "word", "=", "word", ".", "replace", "(", "'\"\\n'", ",", "''", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.collect_annotations": [[57, 77], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "list_to_file", "(", "osp", ".", "join", "(", "root_path", ",", "f'{split.lower()}_label.{format}'", ")", ",", "lines", ")", "\n", "\n", "\n", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of IC11'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of IC11'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.load_img_info": [[79, 106], ["isinstance", "mmcv.imread", "dict", "ic11_converter.load_txt_info", "os.join", "os.join", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'Train'", ",", "'Test'", "]", ":", "\n", "        ", "convert_annotations", "(", "root_path", ",", "split", ",", "args", ".", "format", ")", "\n", "print", "(", "f'{split} split converted.'", ")", "\n", "\n", "\n", "", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.load_txt_info": [[108, 143], ["img_info.update", "open", "f.readlines", "max", "max", "dict", "anno_info.append", "line.split", "int", "int", "int", "int"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.parse_args": [[145, 153], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic11_converter.main": [[155, 169], ["ic11_converter.parse_args", "print", "mmcv.Timer", "ic11_converter.collect_files", "ic11_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lsvt_converter.parse_args": [[11, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of LSVT '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of LSVT'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lsvt_converter.collect_lsvt_info": [[21, 111], ["os.join", "mmcv.load", "mmcv.load.keys", "print", "enumerate", "os.exists", "Exception", "enumerate", "os.join", "mmcv.imread", "dict", "dict.update", "img_infos.append", "print", "os.exists", "dict", "anno_info.append", "math.floor", "trn_files.append", "val_files.append", "len", "len", "os.join", "os.join", "segmentation.append", "segmentation.append", "min", "min", "os.basename", "os.basename", "max", "max", "max", "max", "len"], "function", ["None"], ["parser", ".", "add_argument", "(", "\n", "'--preserve-vertical'", ",", "\n", "help", "=", "'Preserve samples containing vertical texts'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "process_img", "(", "args", ",", "dst_image_root", ",", "ignore_image_root", ",", "preserve_vertical", ",", "\n", "split", ",", "format", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "img_info", "[", "'file_name'", "]", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "segmentation", "=", "[", "]", "\n", "for", "x", ",", "y", "in", "ann", "[", "'points'", "]", ":", "\n", "            ", "segmentation", ".", "append", "(", "max", "(", "0", ",", "x", ")", ")", "\n", "segmentation", ".", "append", "(", "max", "(", "0", ",", "y", ")", ")", "\n", "", "xs", ",", "ys", "=", "segmentation", "[", ":", ":", "2", "]", ",", "segmentation", "[", "1", ":", ":", "2", "]", "\n", "x", ",", "y", "=", "min", "(", "xs", ")", ",", "min", "(", "ys", ")", "\n", "w", ",", "h", "=", "max", "(", "xs", ")", "-", "x", ",", "max", "(", "ys", ")", "-", "y", "\n", "text_label", "=", "ann", "[", "'transcription'", "]", "\n", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "\n", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'train'", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "            ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "labels", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "", "return", "labels", "\n", "\n", "\n", "", "def", "convert_lsvt", "(", "root_path", ",", "\n", "split", ",", "\n", "ratio", ",", "\n", "preserve_vertical", ",", "\n", "format", ",", "\n", "nproc", ",", "\n", "img_start_idx", "=", "0", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information and crop the images.\n\n    The annotation format is as the following:\n    [\n        {'gt_1234': # 'gt_1234' is file name\n            [\n                {\n                    'transcription': '\u4e00\u7ad9\u5f0f\u8d2d\u7269\u4e2d\u5fc3',\n                    'points': [[45, 272], [215, 273], [212, 296], [45, 290]]\n                    'illegibility': False\n                }, ...\n            ]\n        }\n    ]\n\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or val\n        ratio (float): Split ratio for val set\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, whether be txt or jsonl\n        nproc (int): The number of process to collect annotations\n        img_start_idx (int): Index of start image\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations/train_full_labels.json'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lsvt_converter.main": [[113, 126], ["lsvt_converter.parse_args", "print", "lsvt_converter.collect_lsvt_info", "mmocr.utils.convert_annotations", "print", "os.join", "print", "lsvt_converter.collect_lsvt_info", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lsvt_converter.collect_lsvt_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.lsvt_converter.collect_lsvt_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "src_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic13_converter.collect_files": [[11, 38], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "os.join", "imgs_list.append", "ann_list.append", "splits.append", "zip", "os.join", "sorted", "sorted", "len", "img.split"], "function", ["None"], ["\n", "assert", "isinstance", "(", "root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "split", ",", "str", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "with", "open", "(", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "\n", "f'Challenge2_{split}_Task3_GT.txt'", ")", ",", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic13_converter.collect_annotations": [[40, 60], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["encoding", "=", "'\"utf-8-sig'", ")", "as", "f", ":", "\n", "        ", "annos", "=", "f", ".", "readlines", "(", ")", "\n", "", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "split", ".", "lower", "(", ")", ")", "\n", "for", "anno", "in", "annos", ":", "\n", "# text may contain comma ','", "\n", "        ", "dst_img_name", ",", "word", "=", "anno", ".", "split", "(", "', \"'", ")", "\n", "word", "=", "word", ".", "replace", "(", "'\"\\n'", ",", "''", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "lines", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "\n", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "word", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic13_converter.load_img_info": [[62, 96], ["isinstance", "mmcv.imread", "dict", "ic13_converter.load_txt_info", "os.join", "os.join", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and test set of IC13'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of IC13'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "\n", "for", "split", "in", "[", "'Train'", ",", "'Test'", "]", ":", "\n", "        ", "convert_annotations", "(", "root_path", ",", "split", ",", "args", ".", "format", ")", "\n", "print", "(", "f'{split} split converted.'", ")", "\n", "\n", "\n", "", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic13_converter.load_txt_info": [[98, 136], ["img_info.update", "open", "f.readlines", "max", "max", "dict", "anno_info.append", "line.split", "int", "int", "int", "int"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic13_converter.parse_args": [[138, 146], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ic13_converter.main": [[148, 162], ["ic13_converter.parse_args", "print", "mmcv.Timer", "ic13_converter.collect_files", "ic13_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.collect_files": [[12, 39], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "os.join", "os.path.exists", "os.path.exists", "zip", "ann_list.append", "imgs_list.append", "os.join", "len", "img_file.split"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_path", "=", "osp", ".", "join", "(", "gt_dir", ",", "img_file", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'.xml'", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "ann_path", ")", ":", "\n", "            ", "ann_list", ".", "append", "(", "ann_path", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.collect_annotations": [[41, 61], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.load_img_info": [[63, 96], ["isinstance", "mmcv.imread", "dict", "ilst_converter.load_xml_info", "os.basename().split", "os.basename().split", "print", "os.splitext", "os.join", "os.join", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "try", ":", "\n", "        ", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "        ", "print", "(", "f'Skip broken img {img_file}'", ")", "\n", "return", "None", "\n", "\n", "", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.xml'", ":", "\n", "        ", "img_info", "=", "load_xml_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.load_xml_info": [[98, 151], ["xml.parse", "ET.parse.getroot", "obj.getroot.iter", "img_info.update", "int", "int", "int", "int", "max", "max", "dict", "anno_info.append", "object.find", "min", "min", "abs", "abs", "len", "object.find().find", "object.find().find", "object.find().find", "object.find().find", "object.find", "object.find", "object.find", "object.find"], "function", ["None"], ["\n", "\n", "", "def", "load_xml_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    <annotations>\n    ...\n        <object>\n            <name>SMT</name>\n            <pose>Unspecified</pose>\n            <truncated>0</truncated>\n            <difficult>0</difficult>\n            <bndbox>\n                <xmin>157</xmin>\n                <ymin>294</ymin>\n                <xmax>237</xmax>\n                <ymax>357</ymax>\n            </bndbox>\n        <object>\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "obj", "=", "ET", ".", "parse", "(", "gt_file", ")", "\n", "root", "=", "obj", ".", "getroot", "(", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "object", "in", "root", ".", "iter", "(", "'object'", ")", ":", "\n", "        ", "word", "=", "object", ".", "find", "(", "'name'", ")", ".", "text", "\n", "x1", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'xmin'", ")", ".", "text", ")", "\n", "y1", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'ymin'", ")", ".", "text", ")", "\n", "x2", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'xmax'", ")", ".", "text", ")", "\n", "y2", "=", "int", "(", "object", ".", "find", "(", "'bndbox'", ")", ".", "find", "(", "'ymax'", ")", ".", "text", ")", "\n", "\n", "x", "=", "max", "(", "0", ",", "min", "(", "x1", ",", "x2", ")", ")", "\n", "y", "=", "max", "(", "0", ",", "min", "(", "y1", ",", "y2", ")", ")", "\n", "w", ",", "h", "=", "abs", "(", "x2", "-", "x1", ")", ",", "abs", "(", "y2", "-", "y1", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "split_train_val_list", "(", "full_list", ",", "val_ratio", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.split_train_val_list": [[153, 171], ["len", "int"], "function", ["None"], ["\n", "n_total", "=", "len", "(", "full_list", ")", "\n", "offset", "=", "int", "(", "n_total", "*", "val_ratio", ")", "\n", "if", "n_total", "==", "0", "or", "offset", "<", "1", ":", "\n", "        ", "return", "[", "]", ",", "full_list", "\n", "", "val_list", "=", "full_list", "[", ":", "offset", "]", "\n", "train_list", "=", "full_list", "[", "offset", ":", "]", "\n", "return", "[", "train_list", ",", "val_list", "]", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "image_infos", ",", "preserve_vertical", ",", "val_ratio", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.parse_args": [[173, 183], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "assert", "val_ratio", "<=", "1.", "\n", "\n", "if", "val_ratio", ":", "\n", "        ", "image_infos", "=", "split_train_val_list", "(", "image_infos", ",", "val_ratio", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.main": [[185, 202], ["ilst_converter.parse_args", "mmcv.Timer", "ilst_converter.collect_files", "ilst_converter.collect_annotations", "enumerate", "os.join", "os.join", "ilst_converter.split_train_val_list", "mmocr.utils.convert_annotations", "list", "os.join", "filter"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.ilst_converter.split_train_val_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["\n", "", "else", ":", "\n", "        ", "image_infos", "=", "[", "image_infos", "]", "\n", "splits", "=", "[", "'training'", "]", "\n", "\n", "", "for", "i", ",", "split", "in", "enumerate", "(", "splits", ")", ":", "\n", "        ", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", "[", "i", "]", ":", "\n", "            ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.textocr_converter.parse_args": [[11, 17], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of TextOCR '", "\n", "'by cropping box image.'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of TextOCR'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.textocr_converter.collect_textocr_info": [[19, 59], ["os.join", "mmcv.load", "enumerate", "os.exists", "Exception", "annotation[].values", "img_info.update", "img_infos.append", "print", "dict", "anno_info.append", "max", "max", "math.ceil", "math.ceil", "max", "math.floor", "math.floor", "int", "len", "annotation[].values"], "function", ["None"], ["'n_proc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes to run'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_info", ",", "anns", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "osp", ".", "join", "(", "src_image_root", ",", "img_info", "[", "'file_name'", "]", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "ann_idx", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "        ", "text_label", "=", "ann", "[", "'utf8_string'", "]", "\n", "\n", "# Ignore illegible or non-English words", "\n", "if", "text_label", "==", "'.'", ":", "\n", "            ", "continue", "\n", "\n", "", "x", ",", "y", ",", "w", ",", "h", "=", "ann", "[", "'bbox'", "]", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "dst_img_name", "=", "f'img_{img_idx}_{ann_idx}.jpg'", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "labels", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "return", "labels", "\n", "\n", "\n", "", "def", "convert_textocr", "(", "root_path", ",", "\n", "dst_image_path", ",", "\n", "dst_label_filename", ",", "\n", "annotation_filename", ",", "\n", "img_start_idx", "=", "0", ",", "\n", "nproc", "=", "1", ")", ":", "\n", "\n", "    ", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "annotation_filename", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "", "src_image_root", "=", "root_path", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.textocr_converter.main": [[61, 72], ["textocr_converter.parse_args", "print", "textocr_converter.collect_textocr_info", "mmocr.utils.convert_annotations", "print", "textocr_converter.collect_textocr_info", "mmocr.utils.convert_annotations", "print", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.textocr_converter.collect_textocr_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.textocr_converter.collect_textocr_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "dst_label_filename", ")", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "dst_image_path", ")", "\n", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "\n", "process_img_with_path", "=", "partial", "(", "\n", "process_img", ",", "\n", "src_image_root", "=", "src_image_root", ",", "\n", "dst_image_root", "=", "dst_image_root", ")", "\n", "tasks", "=", "[", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_level_info": [[12, 35], ["numpy.array", "shapely.geometry.Polygon", "dict"], "function", ["None"], ["from", "mmocr", ".", "utils", ".", "fileio", "import", "list_to_file", "\n", "\n", "\n", "def", "seg2bbox", "(", "seg", ")", ":", "\n", "    ", "\"\"\"Convert segmentation to bbox.\n\n    Args:\n        seg (list(int | float)): A set of coordinates\n    \"\"\"", "\n", "if", "len", "(", "seg", ")", "==", "4", ":", "\n", "        ", "min_x", "=", "min", "(", "seg", "[", "0", "]", ",", "seg", "[", "2", "]", ",", "seg", "[", "4", "]", ",", "seg", "[", "6", "]", ")", "\n", "max_x", "=", "max", "(", "seg", "[", "0", "]", ",", "seg", "[", "2", "]", ",", "seg", "[", "4", "]", ",", "seg", "[", "6", "]", ")", "\n", "min_y", "=", "min", "(", "seg", "[", "1", "]", ",", "seg", "[", "3", "]", ",", "seg", "[", "5", "]", ",", "seg", "[", "7", "]", ")", "\n", "max_y", "=", "max", "(", "seg", "[", "1", "]", ",", "seg", "[", "3", "]", ",", "seg", "[", "5", "]", ",", "seg", "[", "7", "]", ")", "\n", "", "else", ":", "\n", "        ", "seg", "=", "np", ".", "array", "(", "seg", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "seg", ")", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", "-", "min_x", ",", "max_y", "-", "min_y", "]", "\n", "return", "bbox", "\n", "\n", "\n", "", "def", "process_level", "(", "\n", "src_img", ",", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_hiertext_info": [[37, 122], ["os.join", "enumerate", "os.exists", "Exception", "json.load", "img_info.update", "img_infos.append", "open", "print", "hiertext_converter.collect_level_info", "anno_info.append", "len", "hiertext_converter.collect_level_info", "anno_info.append", "hiertext_converter.collect_level_info", "anno_info.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_level_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_level_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_level_info"], ["dst_image_root", ",", "\n", "ignore_image_root", ",", "\n", "preserve_vertical", ",", "\n", "split", ",", "\n", "format", ",", "\n", "para_idx", ",", "\n", "img_idx", ",", "\n", "line_idx", ",", "\n", "word_idx", "=", "None", ",", "\n", ")", ":", "\n", "    ", "vertices", "=", "annotation", "[", "'vertices'", "]", "\n", "text_label", "=", "annotation", "[", "'text'", "]", "\n", "segmentation", "=", "[", "i", "for", "j", "in", "vertices", "for", "i", "in", "j", "]", "\n", "x", ",", "y", ",", "w", ",", "h", "=", "seg2bbox", "(", "segmentation", ")", "\n", "x", ",", "y", "=", "max", "(", "0", ",", "math", ".", "floor", "(", "x", ")", ")", ",", "max", "(", "0", ",", "math", ".", "floor", "(", "y", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "w", ")", ",", "math", ".", "ceil", "(", "h", ")", "\n", "dst_img", "=", "src_img", "[", "y", ":", "y", "+", "h", ",", "x", ":", "x", "+", "w", "]", "\n", "if", "word_idx", ":", "\n", "        ", "dst_img_name", "=", "f'img_{img_idx}_{para_idx}_{line_idx}_{word_idx}.jpg'", "\n", "", "else", ":", "\n", "        ", "dst_img_name", "=", "f'img_{img_idx}_{para_idx}_{line_idx}.jpg'", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", "and", "split", "==", "'train'", ":", "\n", "        ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "        ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "        ", "label", "=", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", "\n", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "        ", "label", "=", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "f'{osp.basename(dst_image_root)}/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "label", "\n", "\n", "\n", "", "def", "process_img", "(", "args", ",", "src_image_root", ",", "dst_image_root", ",", "ignore_image_root", ",", "level", ",", "\n", "preserve_vertical", ",", "split", ",", "format", ")", ":", "\n", "# Dirty hack for multi-processing", "\n", "    ", "img_idx", ",", "img_annos", "=", "args", "\n", "src_img", "=", "mmcv", ".", "imread", "(", "\n", "osp", ".", "join", "(", "src_image_root", ",", "img_annos", "[", "'image_id'", "]", "+", "'.jpg'", ")", ")", "\n", "labels", "=", "[", "]", "\n", "for", "para_idx", ",", "paragraph", "in", "enumerate", "(", "img_annos", "[", "'paragraphs'", "]", ")", ":", "\n", "        ", "for", "line_idx", ",", "line", "in", "enumerate", "(", "paragraph", "[", "'lines'", "]", ")", ":", "\n", "            ", "if", "level", "==", "'line'", ":", "\n", "# Ignore illegible words", "\n", "                ", "if", "line", "[", "'legible'", "]", ":", "\n", "\n", "                    ", "label", "=", "process_level", "(", "src_img", ",", "line", ",", "dst_image_root", ",", "\n", "ignore_image_root", ",", "preserve_vertical", ",", "\n", "split", ",", "format", ",", "para_idx", ",", "img_idx", ",", "\n", "line_idx", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "", "elif", "level", "==", "'word'", ":", "\n", "                ", "for", "word_idx", ",", "word", "in", "enumerate", "(", "line", "[", "'words'", "]", ")", ":", "\n", "                    ", "if", "not", "word", "[", "'legible'", "]", ":", "\n", "                        ", "continue", "\n", "", "label", "=", "process_level", "(", "src_img", ",", "word", ",", "dst_image_root", ",", "\n", "ignore_image_root", ",", "preserve_vertical", ",", "\n", "split", ",", "format", ",", "para_idx", ",", "img_idx", ",", "\n", "line_idx", ",", "word_idx", ")", "\n", "labels", ".", "append", "(", "label", ")", "\n", "", "", "", "", "return", "labels", "\n", "\n", "\n", "", "def", "convert_hiertext", "(", "\n", "root_path", ",", "\n", "split", ",", "\n", "level", ",", "\n", "preserve_vertical", ",", "\n", "format", ",", "\n", "nproc", ",", "\n", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.parse_args": [[124, 135], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.main": [[137, 148], ["hiertext_converter.parse_args", "print", "hiertext_converter.collect_hiertext_info", "mmocr.utils.convert_annotations", "print", "hiertext_converter.collect_hiertext_info", "mmocr.utils.convert_annotations", "print", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_hiertext_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.hiertext_converter.collect_hiertext_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.collect_files": [[13, 53], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "ann_list.append", "imgs_list.append", "zip", "enumerate", "os.join", "os.join", "sorted", "sorted", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len", "img_file.split"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "img_file", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'.xml'", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "sorted", "(", "imgs_list", ")", ",", "sorted", "(", "ann_list", ")", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.collect_annotations": [[55, 75], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_img_info": [[77, 106], ["isinstance", "mmcv.imread", "dict", "kaist_converter.load_xml_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.xml'", ":", "\n", "        ", "img_info", "=", "load_xml_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.load_xml_info": [[108, 160], ["xml.parse", "ET.parse.getroot", "obj.getroot.iter", "img_info.update", "dict", "anno_info.append", "max", "max", "int", "int", "int", "int"], "function", ["None"], ["\n", "\n", "", "def", "load_xml_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Annotation Format\n    <image>\n        <imageName>DSC02306.JPG</imageName>\n        <resolution x=\"640\" y=\"480\" />\n        <words>\n            <word x=\"61\" y=\"140\" width=\"566\" height=\"107\">\n                <character x=\"61\" y=\"147\" width=\"75\" height=\"94\" char=\"C\" />\n                <character x=\"173\" y=\"147\" width=\"77\" height=\"93\" char=\"L\" />\n                <character x=\"251\" y=\"146\" width=\"83\" height=\"96\" char=\"A\" />\n                <character x=\"335\" y=\"146\" width=\"75\" height=\"97\" char=\"V\" />\n                <character x=\"409\" y=\"140\" width=\"52\" height=\"105\" char=\"I\" />\n                <character x=\"464\" y=\"147\" width=\"76\" height=\"96\" char=\"T\" />\n                <character x=\"538\" y=\"154\" width=\"89\" height=\"93\" char=\"A\" />\n            </word>\n        </words>\n        <illumination>no</illumination>\n        <difficulty>2</difficulty>\n        <tag>\n        </tag>\n    </image>\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "obj", "=", "ET", ".", "parse", "(", "gt_file", ")", "\n", "root", "=", "obj", ".", "getroot", "(", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "word", "in", "root", ".", "iter", "(", "'word'", ")", ":", "\n", "        ", "x", ",", "y", "=", "max", "(", "0", ",", "int", "(", "word", ".", "attrib", "[", "'x'", "]", ")", ")", ",", "max", "(", "0", ",", "int", "(", "word", ".", "attrib", "[", "'y'", "]", ")", ")", "\n", "w", ",", "h", "=", "int", "(", "word", ".", "attrib", "[", "'width'", "]", ")", ",", "int", "(", "word", ".", "attrib", "[", "'height'", "]", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "chars", "=", "[", "]", "\n", "for", "character", "in", "word", ".", "iter", "(", "'character'", ")", ":", "\n", "            ", "chars", ".", "append", "(", "character", ".", "attrib", "[", "'char'", "]", ")", "\n", "", "word", "=", "''", ".", "join", "(", "chars", ")", "\n", "if", "len", "(", "word", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.parse_args": [[162, 172], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.kaist_converter.main": [[174, 196], ["kaist_converter.parse_args", "kaist_converter.collect_files", "kaist_converter.collect_annotations", "os.join", "os.join", "mmcv.Timer", "mmocr.utils.convert_annotations", "len", "kaist_converter.collect_annotations", "os.join", "mmcv.Timer", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.naf_converter.collect_files": [[10, 47], ["isinstance", "isinstance", "isinstance", "list", "len", "print", "zip", "os.join", "os.join", "imgs_list.append", "ann_list.append", "img.replace", "len", "os.exists", "os.exists"], "function", ["None"], ["from", "mmocr", ".", "utils", ".", "fileio", "import", "list_to_file", "\n", "\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "split_info", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        split_info (dict): The split information for train/val/test\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "split_info", ",", "dict", ")", "\n", "assert", "split_info", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "group", "in", "split_info", ":", "\n", "        ", "for", "img", "in", "split_info", "[", "group", "]", ":", "\n", "            ", "image_path", "=", "osp", ".", "join", "(", "img_dir", ",", "img", ")", "\n", "anno_path", "=", "osp", ".", "join", "(", "gt_dir", ",", "'groups'", ",", "group", ",", "\n", "img", ".", "replace", "(", "'jpg'", ",", "'json'", ")", ")", "\n", "\n", "# Filtering out the missing images", "\n", "if", "not", "osp", ".", "exists", "(", "image_path", ")", "or", "not", "osp", ".", "exists", "(", "anno_path", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "imgs_list", ".", "append", "(", "image_path", ")", "\n", "ann_list", ".", "append", "(", "anno_path", ")", "\n", "\n", "", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.naf_converter.collect_annotations": [[49, 69], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["return", "files", "\n", "\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.naf_converter.load_img_info": [[71, 100], ["isinstance", "mmcv.imread", "dict", "naf_converter.load_json_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info"], ["", "return", "images", "\n", "\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# Read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.json'", ":", "\n", "        ", "img_info", "=", "load_json_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.naf_converter.load_json_info": [[102, 163], ["isinstance", "isinstance", "mmcv.load", "img_info.update", "dict", "anno_info.append", "xs.append", "ys.append", "segmentation.append", "segmentation.append", "max", "max", "min", "min", "max", "max"], "function", ["None"], ["", "return", "img_info", "\n", "\n", "\n", "", "def", "load_json_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Annotation Format\n    {\n        'filedBBs': [{\n            'poly_points': [[435,1406], [466,1406], [466,1439], [435,1439]],\n            \"type\": \"fieldCheckBox\",\n            \"id\": \"f0\",\n            \"isBlank\": 1, # 0:text,1:handwriting,2:print,3:blank,4:signature,\n        }], ...\n        \"transcriptions\":{\n            \"f38\": \"CASE NUMBER\",\n            \"f29\": \"July 1, 1949\",\n            \"t20\": \"RANK\",\n            \"t19\": \"COMPANY\",\n            ...\n        }\n    }\n\n    Some special characters are used in the transcription:\n    \"\u00abtext\u00bb\" indicates that \"text\" had a strikethrough\n    \"\u00bf\" indicates the transcriber could not read a character\n    \"\u00a7\" indicates the whole line or word was illegible\n    \"\" (empty string) is if the field was blank\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "gt_file", ",", "str", ")", "\n", "assert", "isinstance", "(", "img_info", ",", "dict", ")", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "\n", "# 'textBBs' contains the printed texts of the table while 'fieldBBs'", "\n", "#  contains the text filled by human.", "\n", "for", "box_type", "in", "[", "'textBBs'", ",", "'fieldBBs'", "]", ":", "\n", "# NAF dataset only provides transcription GT for 'filedBBs', the", "\n", "# 'textBBs' is only used for detection task.", "\n", "        ", "if", "box_type", "==", "'textBBs'", ":", "\n", "            ", "continue", "\n", "", "for", "anno", "in", "annotation", "[", "box_type", "]", ":", "\n", "# Skip images containing detection annotations only", "\n", "            ", "if", "'transcriptions'", "not", "in", "annotation", ".", "keys", "(", ")", ":", "\n", "                ", "continue", "\n", "# Skip boxes without recognition GT", "\n", "", "if", "anno", "[", "'id'", "]", "not", "in", "annotation", "[", "'transcriptions'", "]", ".", "keys", "(", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "word", "=", "annotation", "[", "'transcriptions'", "]", "[", "anno", "[", "'id'", "]", "]", "\n", "# Skip blank boxes", "\n", "if", "len", "(", "word", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.naf_converter.parse_args": [[165, 173], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.naf_converter.main": [[175, 192], ["naf_converter.parse_args", "mmcv.load", "mmcv.load.pop", "mmcv.load.pop", "os.join", "print", "mmcv.Timer", "naf_converter.collect_files", "naf_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n        preserve_vertical (bool): Whether to preserve vertical texts\n        format (str): Annotation format, should be either 'txt' or 'jsonl'\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rctw_converter.collect_files": [[12, 51], ["isinstance", "isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "print", "ann_list.append", "imgs_list.append", "zip", "enumerate", "os.join", "os.join", "ann_file.replace", "len", "math.floor", "trn_files.append", "val_files.append", "len", "len"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ",", "ratio", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n        ratio (float): Split ratio for val set\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "assert", "isinstance", "(", "ratio", ",", "float", ")", "\n", "assert", "ratio", "<", "1.0", ",", "'val_ratio should be a float between 0.0 to 1.0'", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "ann_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "ann_file", ".", "replace", "(", "'txt'", ",", "'jpg'", ")", ")", ")", "\n", "\n", "", "all_files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "all_files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(all_files)} images from {img_dir}'", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "all_files", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "all_files", ",", "[", "]", "\n", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rctw_converter.collect_annotations": [[53, 72], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rctw_converter.load_img_info": [[74, 102], ["isinstance", "mmcv.imread", "dict", "rctw_converter.load_txt_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rctw_converter.load_txt_info": [[104, 152], ["img_info.update", "open", "f.readlines", "[].rstrip().strip", "max", "max", "abs", "abs", "dict", "anno_info.append", "line.split", "int", "min", "min", "[].rstrip", "max", "max", "line.split", "line.split"], "function", ["None"], ["\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x1, y1, x2, y2, x3, y3, x4, y4, difficult, text\n\n    390,902,1856,902,1856,1225,390,1225,0,\"\u91d1\u6c0f\u773c\u955c\"\n    1875,1170,2149,1170,2149,1245,1875,1245,0,\"\u521b\u4e8e1989\"\n    2054,1277,2190,1277,2190,1323,2054,1323,0,\"\u57ce\u5efa\u5e97\"\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "anno_info", "=", "[", "]", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'utf-8-sig'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "for", "line", "in", "lines", ":", "\n", "        ", "points", "=", "line", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", "\n", "word", "=", "line", ".", "split", "(", "','", ")", "[", "9", "]", ".", "rstrip", "(", "'\\n'", ")", ".", "strip", "(", "'\"'", ")", "\n", "difficult", "=", "1", "if", "line", ".", "split", "(", "','", ")", "[", "8", "]", "!=", "'0'", "else", "0", "\n", "bbox", "=", "[", "int", "(", "pt", ")", "for", "pt", "in", "points", "]", "\n", "\n", "if", "word", "==", "'###'", "or", "difficult", "==", "1", ":", "\n", "            ", "continue", "\n", "\n", "", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rctw_converter.parse_args": [[154, 164], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.rctw_converter.main": [[166, 188], ["rctw_converter.parse_args", "rctw_converter.collect_files", "os.join", "os.join", "mmcv.Timer", "rctw_converter.collect_annotations", "mmocr.utils.convert_annotations", "len", "os.join", "mmcv.Timer", "rctw_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "# Filter out vertical texts", "\n", "", "if", "not", "preserve_vertical", "and", "h", "/", "w", ">", "2", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "ignore_image_root", ",", "dst_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.collect_files": [[18, 51], ["isinstance", "isinstance", "sorted", "sorted", "list", "len", "print", "sorted.extend", "zip", "glob.glob", "os.join", "os.join", "os.listdir", "os.listdir", "len"], "function", ["None"], ["def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files(list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "# note that we handle png and jpg only. Pls convert others such as gif to", "\n", "# jpg or png offline", "\n", "suffixes", "=", "[", "'.png'", ",", "'.PNG'", ",", "'.jpg'", ",", "'.JPG'", ",", "'.jpeg'", ",", "'.JPEG'", "]", "\n", "# suffixes = ['.png']", "\n", "\n", "imgs_list", "=", "[", "]", "\n", "for", "suffix", "in", "suffixes", ":", "\n", "        ", "imgs_list", ".", "extend", "(", "glob", ".", "glob", "(", "osp", ".", "join", "(", "img_dir", ",", "'*'", "+", "suffix", ")", ")", ")", "\n", "\n", "", "imgs_list", "=", "sorted", "(", "imgs_list", ")", "\n", "ann_list", "=", "sorted", "(", "\n", "[", "osp", ".", "join", "(", "gt_dir", ",", "gt_file", ")", "for", "gt_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", "]", ")", "\n", "\n", "files", "=", "[", "(", "img_file", ",", "gt_file", ")", "\n", "for", "(", "img_file", ",", "gt_file", ")", "in", "zip", "(", "imgs_list", ",", "ann_list", ")", "]", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n", "return", "files", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.collect_annotations": [[53, 73], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n", "", "return", "images", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.get_contours_mat": [[75, 122], ["isinstance", "scipy.loadmat", "scio.loadmat.keys", "enumerate", "scio.loadmat.get", "numpy.array", "numpy.array", "len", "words.append", "range", "contours.append", "scio.loadmat.get", "numpy.concatenate", "contour.append", "contour.append", "numpy.asarray", "len"], "function", ["None"], ["\n", "", "def", "get_contours_mat", "(", "gt_path", ")", ":", "\n", "    ", "\"\"\"Get the contours and words for each ground_truth mat file.\n\n    Args:\n        gt_path (str): The relative path of the ground_truth mat file\n\n    Returns:\n        contours (list[lists]): A list of lists of contours\n            for the text instances\n        words (list[list]): A list of lists of words (string)\n            for the text instances\n    \"\"\"", "\n", "assert", "isinstance", "(", "gt_path", ",", "str", ")", "\n", "\n", "contours", "=", "[", "]", "\n", "words", "=", "[", "]", "\n", "data", "=", "scio", ".", "loadmat", "(", "gt_path", ")", "\n", "# 'gt' for the latest version; 'polygt' for the legacy version", "\n", "keys", "=", "data", ".", "keys", "(", ")", "\n", "if", "'gt'", "in", "keys", ":", "\n", "        ", "data_polygt", "=", "data", ".", "get", "(", "'gt'", ")", "\n", "", "elif", "'polygt'", "in", "keys", ":", "\n", "        ", "data_polygt", "=", "data", ".", "get", "(", "'polygt'", ")", "\n", "\n", "", "for", "i", ",", "lines", "in", "enumerate", "(", "data_polygt", ")", ":", "\n", "        ", "X", "=", "np", ".", "array", "(", "lines", "[", "1", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "lines", "[", "3", "]", ")", "\n", "\n", "point_num", "=", "len", "(", "X", "[", "0", "]", ")", "\n", "word", "=", "lines", "[", "4", "]", "\n", "if", "len", "(", "word", ")", "==", "0", "or", "word", "==", "'#'", ":", "\n", "            ", "word", "=", "'###'", "\n", "", "else", ":", "\n", "            ", "word", "=", "word", "[", "0", "]", "\n", "\n", "", "words", ".", "append", "(", "word", ")", "\n", "\n", "arr", "=", "np", ".", "concatenate", "(", "[", "X", ",", "Y", "]", ")", ".", "T", "\n", "contour", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "point_num", ")", ":", "\n", "            ", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "0", "]", ")", "\n", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "1", "]", ")", "\n", "", "contours", ".", "append", "(", "np", ".", "asarray", "(", "contour", ")", ")", "\n", "\n", "", "return", "contours", ",", "words", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.load_mat_info": [[124, 165], ["isinstance", "isinstance", "totaltext_converter.get_contours_mat", "zip", "img_info.update", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.get_contours_mat"], ["    ", "\"\"\"Load the information of one ground truth in .mat format.\n\n    Args:\n        img_info (dict): The dict of only the image information\n        gt_file (str): The relative path of the ground_truth mat\n            file for one image\n\n    Returns:\n        img_info(dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_info", ",", "dict", ")", "\n", "assert", "isinstance", "(", "gt_file", ",", "str", ")", "\n", "\n", "contours", ",", "words", "=", "get_contours_mat", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "contour", ",", "word", "in", "zip", "(", "contours", ",", "words", ")", ":", "\n", "        ", "if", "contour", ".", "shape", "[", "0", "]", "==", "2", "or", "word", "==", "'###'", ":", "\n", "            ", "continue", "\n", "", "coordinates", "=", "np", ".", "array", "(", "contour", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "\n", "# convert to COCO style XYWH format", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", "]", "\n", "anno", "=", "dict", "(", "word", "=", "word", ",", "bbox", "=", "bbox", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "process_line", "(", "line", ",", "contours", ",", "words", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.process_line": [[167, 214], ["re.sub", "re.sub", "re.sub", "yaml.safe_load.replace", "yaml.safe_load", "numpy.array", "numpy.array", "words.append", "len", "range", "contours.append", "len", "str", "numpy.concatenate", "contour.append", "contour.append", "numpy.asarray", "line.replace().replace", "len", "eval", "line.replace"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["\n", "\n", "line", "=", "'{'", "+", "line", ".", "replace", "(", "'[['", ",", "'['", ")", ".", "replace", "(", "']]'", ",", "']'", ")", "+", "'}'", "\n", "ann_dict", "=", "re", ".", "sub", "(", "'([0-9]) +([0-9])'", ",", "r'\\1,\\2'", ",", "line", ")", "\n", "ann_dict", "=", "re", ".", "sub", "(", "'([0-9]) +([ 0-9])'", ",", "r'\\1,\\2'", ",", "ann_dict", ")", "\n", "ann_dict", "=", "re", ".", "sub", "(", "'([0-9]) -([0-9])'", ",", "r'\\1,-\\2'", ",", "ann_dict", ")", "\n", "ann_dict", "=", "ann_dict", ".", "replace", "(", "\"[u',']\"", ",", "\"[u'#']\"", ")", "\n", "ann_dict", "=", "yaml", ".", "safe_load", "(", "ann_dict", ")", "\n", "\n", "X", "=", "np", ".", "array", "(", "[", "ann_dict", "[", "'x'", "]", "]", ")", "\n", "Y", "=", "np", ".", "array", "(", "[", "ann_dict", "[", "'y'", "]", "]", ")", "\n", "\n", "if", "len", "(", "ann_dict", "[", "'transcriptions'", "]", ")", "==", "0", ":", "\n", "        ", "word", "=", "'###'", "\n", "", "else", ":", "\n", "        ", "word", "=", "ann_dict", "[", "'transcriptions'", "]", "[", "0", "]", "\n", "if", "len", "(", "ann_dict", "[", "'transcriptions'", "]", ")", ">", "1", ":", "\n", "            ", "for", "ann_word", "in", "ann_dict", "[", "'transcriptions'", "]", "[", "1", ":", "]", ":", "\n", "                ", "word", "+=", "','", "+", "ann_word", "\n", "", "", "word", "=", "str", "(", "eval", "(", "word", ")", ")", "\n", "", "words", ".", "append", "(", "word", ")", "\n", "\n", "point_num", "=", "len", "(", "X", "[", "0", "]", ")", "\n", "\n", "arr", "=", "np", ".", "concatenate", "(", "[", "X", ",", "Y", "]", ")", ".", "T", "\n", "contour", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "point_num", ")", ":", "\n", "        ", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "0", "]", ")", "\n", "contour", ".", "append", "(", "arr", "[", "i", "]", "[", "1", "]", ")", "\n", "", "contours", ".", "append", "(", "np", ".", "asarray", "(", "contour", ")", ")", "\n", "\n", "return", "contours", ",", "words", "\n", "\n", "\n", "", "def", "get_contours_txt", "(", "gt_path", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.get_contours_txt": [[216, 254], ["isinstance", "open", "enumerate", "line.strip.strip", "totaltext_converter.process_line", "totaltext_converter.process_line", "line.strip.startswith"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.process_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.process_line"], ["assert", "isinstance", "(", "gt_path", ",", "str", ")", "\n", "\n", "contours", "=", "[", "]", "\n", "words", "=", "[", "]", "\n", "\n", "with", "open", "(", "gt_path", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "tmp_line", "=", "''", "\n", "for", "idx", ",", "line", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "idx", "==", "0", ":", "\n", "                ", "tmp_line", "=", "line", "\n", "continue", "\n", "", "if", "not", "line", ".", "startswith", "(", "'x:'", ")", ":", "\n", "                ", "tmp_line", "+=", "' '", "+", "line", "\n", "continue", "\n", "", "else", ":", "\n", "                ", "complete_line", "=", "tmp_line", "\n", "tmp_line", "=", "line", "\n", "", "contours", ",", "words", "=", "process_line", "(", "complete_line", ",", "contours", ",", "words", ")", "\n", "\n", "", "if", "tmp_line", "!=", "''", ":", "\n", "            ", "contours", ",", "words", "=", "process_line", "(", "tmp_line", ",", "contours", ",", "words", ")", "\n", "\n", "", "for", "word", "in", "words", ":", "\n", "            ", "if", "word", "==", "'#'", ":", "\n", "                ", "word", "=", "'###'", "\n", "\n", "", "", "", "return", "contours", ",", "words", "\n", "\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.load_txt_info": [[256, 295], ["totaltext_converter.get_contours_txt", "zip", "img_info.update", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.get_contours_txt"], ["\n", "\n", "contours", ",", "words", "=", "get_contours_txt", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "contour", ",", "word", "in", "zip", "(", "contours", ",", "words", ")", ":", "\n", "        ", "if", "contour", ".", "shape", "[", "0", "]", "==", "2", "or", "word", "==", "'###'", ":", "\n", "            ", "continue", "\n", "", "coordinates", "=", "np", ".", "array", "(", "contour", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "polygon", "=", "Polygon", "(", "coordinates", ")", "\n", "\n", "# convert to COCO style XYWH format", "\n", "min_x", ",", "min_y", ",", "max_x", ",", "max_y", "=", "polygon", ".", "bounds", "\n", "bbox", "=", "[", "min_x", ",", "min_y", ",", "max_x", ",", "min_y", ",", "max_x", ",", "max_y", ",", "min_x", ",", "max_y", "]", "\n", "anno", "=", "dict", "(", "word", "=", "word", ",", "bbox", "=", "bbox", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ")", ":", "\n", "    ", "\"\"\"Generate cropped annotations and label txt file.\n\n    Args:\n        root_path (str): The relative path of the totaltext file\n        split (str): The split of dataset. Namely: training or test\n        image_infos (list[dict]): A list of dicts of the img and\n            annotation information\n    \"\"\"", "\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'dst_imgs'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "'train_label.txt'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "'test_label.txt'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.load_png_info": [[297, 340], ["isinstance", "isinstance", "cv2.imread", "cv2.findContours", "img_info.update", "numpy.array().flatten().tolist", "numpy.array().reshape", "shapely.geometry.Polygon", "dict", "anno_info.append", "numpy.array().flatten", "numpy.array", "numpy.array"], "function", ["None"], ["image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "osp", ".", "splitext", "(", "image_info", "[", "'file_name'", "]", ")", "[", "0", "]", ".", "split", "(", "'/'", ")", "[", "1", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ")", "\n", "\n", "# Skip invalid annotations", "\n", "if", "min", "(", "dst_img", ".", "shape", ")", "==", "0", "or", "word", "==", "'###'", ":", "\n", "                ", "continue", "\n", "\n", "", "dst_img_name", "=", "f'{src_img_root}_{index}.png'", "\n", "index", "+=", "1", "\n", "dst_img_path", "=", "osp", ".", "join", "(", "dst_image_root", ",", "dst_img_name", ")", "\n", "mmcv", ".", "imwrite", "(", "dst_img", ",", "dst_img_path", ")", "\n", "lines", ".", "append", "(", "f'{osp.basename(dst_image_root)}/{dst_img_name} '", "\n", "f'{word}'", ")", "\n", "", "", "list_to_file", "(", "dst_label_file", ",", "lines", ")", "\n", "\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "# read imgs with ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "split_name", "=", "osp", ".", "basename", "(", "osp", ".", "dirname", "(", "img_file", ")", ")", "\n", "img_info", "=", "dict", "(", "\n", "# remove img_prefix for filename", "\n", "file_name", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "# anno_info=anno_info,", "\n", "segm_file", "=", "osp", ".", "join", "(", "split_name", ",", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.load_img_info": [[342, 374], ["isinstance", "mmcv.imread", "os.basename", "dict", "os.dirname", "totaltext_converter.load_mat_info", "os.join", "os.join", "os.splitext", "totaltext_converter.load_txt_info", "os.basename", "os.basename", "os.splitext"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.load_mat_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["        ", "img_info", "=", "load_mat_info", "(", "img_info", ",", "gt_file", ")", "\n", "", "elif", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "img_info", "\n", "\n", "\n", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert totaltext annotations to COCO format'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Totaltext root path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of process'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "img_dir", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ")", "\n", "gt_dir", "=", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ")", "\n", "\n", "set_name", "=", "{", "}", "\n", "for", "split", "in", "[", "'training'", ",", "'test'", "]", ":", "\n", "        ", "set_name", ".", "update", "(", "{", "split", ":", "split", "+", "'_label'", "+", "'.txt'", "}", ")", "\n", "assert", "osp", ".", "exists", "(", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ")", "\n", "\n", "", "for", "split", ",", "ann_name", "in", "set_name", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "f'Converting {split} into {ann_name}'", ")", "\n", "with", "mmcv", ".", "Timer", "(", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.parse_args": [[376, 384], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["            ", "files", "=", "collect_files", "(", "\n", "osp", ".", "join", "(", "img_dir", ",", "split", ")", ",", "osp", ".", "join", "(", "gt_dir", ",", "split", ")", ")", "\n", "image_infos", "=", "collect_annotations", "(", "files", ",", "nproc", "=", "args", ".", "nproc", ")", "\n", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ")", "\n", "\n", "\n", "", "", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.totaltext_converter.main": [[386, 405], ["totaltext_converter.parse_args", "os.join", "os.join", "set_name.items", "set_name.update", "os.exists", "print", "os.join", "mmcv.Timer", "totaltext_converter.collect_files", "totaltext_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.collect_files": [[12, 37], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "sorted", "sorted", "gt_file.replace", "len"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "gt_file", "in", "os", ".", "listdir", "(", "gt_dir", ")", ":", "\n", "        ", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "gt_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "gt_file", ".", "replace", "(", "'.json'", ",", "'.png'", ")", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "sorted", "(", "imgs_list", ")", ",", "sorted", "(", "ann_list", ")", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.collect_annotations": [[39, 59], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_img_info": [[61, 90], ["isinstance", "mmcv.imread", "dict", "funsd_converter.load_json_info", "os.basename().split", "os.basename().split", "os.join", "os.join", "os.splitext", "os.basename", "os.basename", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "osp", ".", "basename", "(", "gt_file", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "==", "osp", ".", "basename", "(", "img_file", ")", ".", "split", "(", "\n", "'.'", ")", "[", "0", "]", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.json'", ":", "\n", "        ", "img_info", "=", "load_json_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.load_json_info": [[92, 128], ["mmcv.load", "img_info.update", "max", "max", "dict", "anno_info.append", "min", "min", "math.ceil", "math.ceil", "len", "math.floor", "math.floor", "math.floor", "math.floor", "abs", "abs"], "function", ["None"], ["\n", "\n", "", "def", "load_json_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation", "=", "mmcv", ".", "load", "(", "gt_file", ")", "\n", "anno_info", "=", "[", "]", "\n", "for", "form", "in", "annotation", "[", "'form'", "]", ":", "\n", "        ", "for", "ann", "in", "form", "[", "'words'", "]", ":", "\n", "\n", "# Ignore illegible samples", "\n", "            ", "if", "len", "(", "ann", "[", "'text'", "]", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "ann", "[", "'box'", "]", "\n", "x", "=", "max", "(", "0", ",", "min", "(", "math", ".", "floor", "(", "x1", ")", ",", "math", ".", "floor", "(", "x2", ")", ")", ")", "\n", "y", "=", "max", "(", "0", ",", "min", "(", "math", ".", "floor", "(", "y1", ")", ",", "math", ".", "floor", "(", "y2", ")", ")", ")", "\n", "w", ",", "h", "=", "math", ".", "ceil", "(", "abs", "(", "x2", "-", "x1", ")", ")", ",", "math", ".", "ceil", "(", "abs", "(", "y2", "-", "y1", ")", ")", "\n", "bbox", "=", "[", "x", ",", "y", ",", "x", "+", "w", ",", "y", ",", "x", "+", "w", ",", "y", "+", "h", ",", "x", ",", "y", "+", "h", "]", "\n", "word", "=", "ann", "[", "'text'", "]", "\n", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.parse_args": [[130, 138], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.funsd_converter.main": [[140, 154], ["funsd_converter.parse_args", "print", "mmcv.Timer", "funsd_converter.collect_files", "funsd_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'dst_imgs'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.detext_converter.collect_files": [[12, 37], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "imgs_list.append", "ann_list.append", "zip", "os.join", "os.join", "len", "img.replace"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img", ")", ")", "\n", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "'gt_'", "+", "img", ".", "replace", "(", "'jpg'", ",", "'txt'", ")", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.detext_converter.collect_annotations": [[39, 59], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.detext_converter.load_img_info": [[61, 88], ["isinstance", "mmcv.imread", "dict", "detext_converter.load_txt_info", "os.join", "os.join", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.detext_converter.load_txt_info": [[90, 131], ["img_info.update", "open", "f.readlines", "max", "max", "[].replace().strip", "dict", "anno_info.append", "numpy.array().astype().tolist", "min", "min", "max", "max", "[].replace", "numpy.array().astype", "numpy.array", "ann.split", "ann.split"], "function", ["None"], ["\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "with", "open", "(", "gt_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "annotations", "=", "f", ".", "readlines", "(", ")", "\n", "for", "ann", "in", "annotations", ":", "\n", "# Annotation format [x1, y1, x2, y2, x3, y3, x4, y4, transcript]", "\n", "            ", "try", ":", "\n", "                ", "bbox", "=", "np", ".", "array", "(", "ann", ".", "split", "(", "','", ")", "[", "0", ":", "8", "]", ")", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "", "except", "ValueError", ":", "\n", "# Skip invalid annotation line", "\n", "                ", "continue", "\n", "", "word", "=", "ann", ".", "split", "(", "','", ")", "[", "-", "1", "]", ".", "replace", "(", "'\\n'", ",", "''", ")", ".", "strip", "(", ")", "\n", "\n", "# Skip samples without recog gt", "\n", "if", "word", "==", "'###'", ":", "\n", "                ", "continue", "\n", "", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.detext_converter.parse_args": [[133, 141], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.detext_converter.main": [[143, 158], ["detext_converter.parse_args", "print", "mmcv.Timer", "detext_converter.collect_files", "detext_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'val_label.{format}'", ")", "\n", "", "mmcv", ".", "mkdir_or_exist", "(", "dst_image_root", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "ignore_image_root", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ",", "\n", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.art_converter.parse_args": [[11, 19], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Generate training and validation set of ArT '", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root dir path of ArT'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--val-ratio'", ",", "help", "=", "'Split ratio for val set'", ",", "default", "=", "0.0", ",", "type", "=", "float", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.art_converter.collect_art_info": [[21, 126], ["os.join", "mmcv.load", "mmcv.load.keys", "print", "enumerate", "os.exists", "Exception", "enumerate", "os.join", "mmcv.imread", "dict", "dict.update", "img_infos.append", "print", "os.exists", "dict", "anno_info.append", "math.floor", "trn_files.append", "val_files.append", "len", "len", "os.join", "os.join", "segmentation.append", "segmentation.append", "min", "min", "os.basename", "os.basename", "max", "max", "max", "max", "len"], "function", ["None"], ["'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "convert_art", "(", "root_path", ",", "split", ",", "ratio", ",", "format", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information and crop the images.\n\n    The annotation format is as the following:\n    {\n        \"gt_2836_0\": [\n            {\n                \"transcription\": \"URDER\",\n                \"points\": [\n                    [25, 51],\n                    [0, 2],\n                    [21, 0],\n                    [42, 43]\n                ],\n                \"language\": \"Latin\",\n                \"illegibility\": false\n            }\n        ], ...\n    }\n\n\n    Args:\n        root_path (str): The root path of the dataset\n        split (str): The split of dataset. Namely: training or val\n        ratio (float): Split ratio for val set\n        format (str): Annotation format, whether be txt or jsonl\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "annotation_path", "=", "osp", ".", "join", "(", "root_path", ",", "\n", "'annotations/train_task2_labels.json'", ")", "\n", "if", "not", "osp", ".", "exists", "(", "annotation_path", ")", ":", "\n", "        ", "raise", "Exception", "(", "\n", "f'{annotation_path} not exists, please check and try again.'", ")", "\n", "\n", "", "annotation", "=", "mmcv", ".", "load", "(", "annotation_path", ")", "\n", "# outputs", "\n", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'{split}_label.{format}'", ")", "\n", "\n", "img_prefixes", "=", "annotation", ".", "keys", "(", ")", "\n", "\n", "trn_files", ",", "val_files", "=", "[", "]", ",", "[", "]", "\n", "if", "ratio", ">", "0", ":", "\n", "        ", "for", "i", ",", "file", "in", "enumerate", "(", "img_prefixes", ")", ":", "\n", "            ", "if", "i", "%", "math", ".", "floor", "(", "1", "/", "ratio", ")", ":", "\n", "                ", "trn_files", ".", "append", "(", "file", ")", "\n", "", "else", ":", "\n", "                ", "val_files", ".", "append", "(", "file", ")", "\n", "", "", "", "else", ":", "\n", "        ", "trn_files", ",", "val_files", "=", "img_prefixes", ",", "[", "]", "\n", "", "print", "(", "f'training #{len(trn_files)}, val #{len(val_files)}'", ")", "\n", "\n", "if", "split", "==", "'train'", ":", "\n", "        ", "img_prefixes", "=", "trn_files", "\n", "", "elif", "split", "==", "'val'", ":", "\n", "        ", "img_prefixes", "=", "val_files", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "labels", "=", "[", "]", "\n", "for", "prefix", "in", "img_prefixes", ":", "\n", "        ", "text_label", "=", "annotation", "[", "prefix", "]", "[", "0", "]", "[", "'transcription'", "]", "\n", "dst_img_name", "=", "prefix", "+", "'.jpg'", "\n", "\n", "if", "format", "==", "'txt'", ":", "\n", "            ", "labels", ".", "append", "(", "f'crops/{dst_img_name}'", "f' {text_label}'", ")", "\n", "", "elif", "format", "==", "'jsonl'", ":", "\n", "            ", "labels", ".", "append", "(", "\n", "json", ".", "dumps", "(", "\n", "{", "\n", "'filename'", ":", "f'crops/{dst_img_name}'", ",", "\n", "'text'", ":", "text_label", "\n", "}", ",", "\n", "ensure_ascii", "=", "False", ")", ")", "\n", "\n", "", "", "list_to_file", "(", "dst_label_file", ",", "labels", ")", "\n", "\n", "\n", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "print", "(", "'Processing training set...'", ")", "\n", "convert_art", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'train'", ",", "\n", "ratio", "=", "args", ".", "val_ratio", ",", "\n", "format", "=", "args", ".", "format", ")", "\n", "if", "args", ".", "val_ratio", ">", "0", ":", "\n", "        ", "print", "(", "'Processing validation set...'", ")", "\n", "convert_art", "(", "\n", "root_path", "=", "root_path", ",", "\n", "split", "=", "'val'", ",", "\n", "ratio", "=", "args", ".", "val_ratio", ",", "\n", "format", "=", "args", ".", "format", ")", "\n", "", "print", "(", "'Finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.art_converter.main": [[128, 141], ["art_converter.parse_args", "print", "art_converter.collect_art_info", "mmocr.utils.convert_annotations", "print", "os.join", "print", "art_converter.collect_art_info", "mmocr.utils.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.art_converter.collect_art_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.art_converter.collect_art_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files": [[11, 37], ["isinstance", "isinstance", "os.listdir", "os.listdir", "list", "len", "print", "ann_list.append", "imgs_list.append", "zip", "os.join", "os.join", "str", "len", "int"], "function", ["None"], ["\n", "\n", "def", "collect_files", "(", "img_dir", ",", "gt_dir", ")", ":", "\n", "    ", "\"\"\"Collect all images and their corresponding groundtruth files.\n\n    Args:\n        img_dir (str): The image directory\n        gt_dir (str): The groundtruth directory\n\n    Returns:\n        files (list): The list of tuples (img_file, groundtruth_file)\n    \"\"\"", "\n", "assert", "isinstance", "(", "img_dir", ",", "str", ")", "\n", "assert", "img_dir", "\n", "assert", "isinstance", "(", "gt_dir", ",", "str", ")", "\n", "assert", "gt_dir", "\n", "\n", "ann_list", ",", "imgs_list", "=", "[", "]", ",", "[", "]", "\n", "for", "img_file", "in", "os", ".", "listdir", "(", "img_dir", ")", ":", "\n", "        ", "ann_file", "=", "'gt_'", "+", "str", "(", "int", "(", "img_file", "[", "2", ":", "6", "]", ")", ")", "+", "'.txt'", "\n", "ann_list", ".", "append", "(", "osp", ".", "join", "(", "gt_dir", ",", "ann_file", ")", ")", "\n", "imgs_list", ".", "append", "(", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", ")", "\n", "\n", "", "files", "=", "list", "(", "zip", "(", "imgs_list", ",", "ann_list", ")", ")", "\n", "assert", "len", "(", "files", ")", ",", "f'No images found in {img_dir}'", "\n", "print", "(", "f'Loaded {len(files)} images from {img_dir}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations": [[39, 59], ["isinstance", "isinstance", "mmcv.track_parallel_progress", "mmcv.track_progress"], "function", ["None"], ["\n", "\n", "", "def", "collect_annotations", "(", "files", ",", "nproc", "=", "1", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    Args:\n        files (list): The list of tuples (image_file, groundtruth_file)\n        nproc (int): The number of process to collect annotations\n\n    Returns:\n        images (list): The list of image information dicts\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "list", ")", "\n", "assert", "isinstance", "(", "nproc", ",", "int", ")", "\n", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_img_info", ",", "files", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "images", "=", "mmcv", ".", "track_progress", "(", "load_img_info", ",", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_img_info": [[61, 90], ["isinstance", "mmcv.imread", "dict", "int", "int", "vintext_converter.load_txt_info", "os.basename", "os.basename", "os.splitext", "os.basename", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info"], ["\n", "\n", "", "def", "load_img_info", "(", "files", ")", ":", "\n", "    ", "\"\"\"Load the information of one image.\n\n    Args:\n        files (tuple): The tuple of (img_file, groundtruth_file)\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "assert", "isinstance", "(", "files", ",", "tuple", ")", "\n", "\n", "img_file", ",", "gt_file", "=", "files", "\n", "assert", "int", "(", "osp", ".", "basename", "(", "gt_file", ")", "[", "3", ":", "-", "4", "]", ")", "==", "int", "(", "\n", "osp", ".", "basename", "(", "img_file", ")", "[", "2", ":", "-", "4", "]", ")", "\n", "# read imgs while ignoring orientations", "\n", "img", "=", "mmcv", ".", "imread", "(", "img_file", ",", "'unchanged'", ")", "\n", "\n", "img_info", "=", "dict", "(", "\n", "file_name", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "img_file", ")", ")", ",", "\n", "height", "=", "img", ".", "shape", "[", "0", "]", ",", "\n", "width", "=", "img", ".", "shape", "[", "1", "]", ",", "\n", "segm_file", "=", "osp", ".", "join", "(", "osp", ".", "basename", "(", "gt_file", ")", ")", ")", "\n", "\n", "if", "osp", ".", "splitext", "(", "gt_file", ")", "[", "1", "]", "==", "'.txt'", ":", "\n", "        ", "img_info", "=", "load_txt_info", "(", "gt_file", ",", "img_info", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.load_txt_info": [[92, 141], ["img_info.update", "open", "line.strip.strip", "line.strip.split", "min", "max", "min", "max", "dict", "anno_info.append", "int", "len"], "function", ["None"], ["\n", "\n", "", "def", "load_txt_info", "(", "gt_file", ",", "img_info", ")", ":", "\n", "    ", "\"\"\"Collect the annotation information.\n\n    The annotation format is as the following:\n    x1,y1,x2,y2,x3,y3,x4,y4,text\n    118,15,147,15,148,46,118,46,L\u01af\u1ee2NG\n    149,9,165,9,165,43,150,43,T\u1ed0T\n    167,9,180,9,179,43,167,42,\u0110\u1ec2\n    181,12,193,12,193,43,181,43,C\u00d3\n    195,13,215,14,215,46,196,46,VI\u1ec6C\n    217,13,237,14,239,47,217,46,L\u00c0M,\n\n    Args:\n        gt_file (str): The path to ground-truth\n        img_info (dict): The dict of the img and annotation information\n\n    Returns:\n        img_info (dict): The dict of the img and annotation information\n    \"\"\"", "\n", "\n", "with", "open", "(", "gt_file", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "anno_info", "=", "[", "]", "\n", "for", "line", "in", "f", ":", "\n", "            ", "line", "=", "line", ".", "strip", "(", "'\\n'", ")", "\n", "ann", "=", "line", ".", "split", "(", "','", ")", "\n", "bbox", "=", "ann", "[", "0", ":", "8", "]", "\n", "word", "=", "line", "[", "len", "(", "','", ".", "join", "(", "bbox", ")", ")", "+", "1", ":", "]", "\n", "bbox", "=", "[", "int", "(", "coord", ")", "for", "coord", "in", "bbox", "]", "\n", "# Ignore hard samples", "\n", "if", "word", "==", "'###'", ":", "\n", "                ", "continue", "\n", "", "assert", "len", "(", "bbox", ")", "==", "8", "\n", "anno", "=", "dict", "(", "bbox", "=", "bbox", ",", "word", "=", "word", ")", "\n", "anno_info", ".", "append", "(", "anno", ")", "\n", "\n", "", "", "img_info", ".", "update", "(", "anno_info", "=", "anno_info", ")", "\n", "\n", "return", "img_info", "\n", "\n", "\n", "", "def", "generate_ann", "(", "root_path", ",", "split", ",", "image_infos", ",", "preserve_vertical", ",", "format", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.parse_args": [[143, 151], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "dst_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'crops'", ",", "split", ")", "\n", "ignore_image_root", "=", "osp", ".", "join", "(", "root_path", ",", "'ignores'", ",", "split", ")", "\n", "if", "split", "==", "'training'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'train_label.{format}'", ")", "\n", "", "elif", "split", "==", "'test'", ":", "\n", "        ", "dst_label_file", "=", "osp", ".", "join", "(", "root_path", ",", "f'test_label.{format}'", ")", "\n", "", "elif", "split", "==", "'unseen_test'", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.main": [[153, 167], ["vintext_converter.parse_args", "print", "mmcv.Timer", "vintext_converter.collect_files", "vintext_converter.collect_annotations", "mmocr.utils.convert_annotations", "os.join", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_files", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.vintext_converter.collect_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "os", ".", "makedirs", "(", "dst_image_root", ",", "exist_ok", "=", "True", ")", "\n", "\n", "lines", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "index", "=", "1", "\n", "src_img_path", "=", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "split", ",", "\n", "image_info", "[", "'file_name'", "]", ")", "\n", "image", "=", "mmcv", ".", "imread", "(", "src_img_path", ")", "\n", "src_img_root", "=", "image_info", "[", "'file_name'", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "for", "anno", "in", "image_info", "[", "'anno_info'", "]", ":", "\n", "            ", "word", "=", "anno", "[", "'word'", "]", "\n", "dst_img", "=", "crop_img", "(", "image", ",", "anno", "[", "'bbox'", "]", ",", "0", ",", "0", ")", "\n", "h", ",", "w", ",", "_", "=", "dst_img", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.trace_boundary": [[16, 41], ["mmocr.utils.check_argument.is_type_list", "numpy.concatenate().astype", "range", "numpy.concatenate", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["'anno_path'", ",", "help", "=", "'Path to gold annotation data (gt.mat)'", ")", "\n", "parser", ".", "add_argument", "(", "'img_path'", ",", "help", "=", "'Path to images'", ")", "\n", "parser", ".", "add_argument", "(", "'out_dir'", ",", "help", "=", "'Path of output images and labels'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--n_proc'", ",", "\n", "default", "=", "1", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'Number of processes to run with'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n", "\n", "", "def", "load_gt_datum", "(", "datum", ")", ":", "\n", "    ", "img_path", ",", "txt", ",", "wordBB", ",", "charBB", "=", "datum", "\n", "words", "=", "[", "]", "\n", "word_bboxes", "=", "[", "]", "\n", "char_bboxes", "=", "[", "]", "\n", "\n", "# when there's only one word in txt", "\n", "# scipy will load it as a string", "\n", "if", "type", "(", "txt", ")", "is", "str", ":", "\n", "        ", "words", "=", "txt", ".", "split", "(", ")", "\n", "", "else", ":", "\n", "        ", "for", "line", "in", "txt", ":", "\n", "            ", "words", "+=", "line", ".", "split", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.match_bbox_char_str": [[43, 98], ["isinstance", "isinstance", "isinstance", "np.expand_dims.astype", "np.expand_dims.astype", "numpy.transpose", "numpy.transpose", "numpy.cumsum", "enumerate", "range", "len", "numpy.expand_dims", "len", "numpy.expand_dims", "shapely.geometry.Polygon", "s.split", "len", "range", "numpy.ndarray", "poly_boundary_list.append", "range", "range", "range", "range", "range", "poly_char_idx_list[].append", "poly_char_list[].append", "poly_charbox_list[].append", "len", "len", "synthtext_converter.trace_boundary"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.trace_boundary"], ["", "", "if", "len", "(", "wordBB", ".", "shape", ")", "==", "2", ":", "\n", "        ", "wordBB", "=", "wordBB", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "", "cur_wordBB", "=", "wordBB", ".", "transpose", "(", "2", ",", "1", ",", "0", ")", "\n", "for", "box", "in", "cur_wordBB", ":", "\n", "        ", "word_bboxes", ".", "append", "(", "\n", "[", "max", "(", "round", "(", "coord", ")", ",", "0", ")", "for", "pt", "in", "box", "for", "coord", "in", "pt", "]", ")", "\n", "\n", "# Validate word bboxes.", "\n", "", "if", "len", "(", "words", ")", "!=", "len", "(", "word_bboxes", ")", ":", "\n", "        ", "return", "\n", "\n", "# From (2, 4, num_boxes) to (num_boxes, 4, 2)", "\n", "", "cur_charBB", "=", "charBB", ".", "transpose", "(", "2", ",", "1", ",", "0", ")", "\n", "for", "box", "in", "cur_charBB", ":", "\n", "        ", "char_bboxes", ".", "append", "(", "\n", "[", "max", "(", "round", "(", "coord", ")", ",", "0", ")", "for", "pt", "in", "box", "for", "coord", "in", "pt", "]", ")", "\n", "\n", "", "char_bbox_idx", "=", "0", "\n", "char_bbox_grps", "=", "[", "]", "\n", "\n", "for", "word", "in", "words", ":", "\n", "        ", "temp_bbox", "=", "char_bboxes", "[", "char_bbox_idx", ":", "char_bbox_idx", "+", "len", "(", "word", ")", "]", "\n", "char_bbox_idx", "+=", "len", "(", "word", ")", "\n", "char_bbox_grps", ".", "append", "(", "temp_bbox", ")", "\n", "\n", "# Validate char bboxes.", "\n", "# If the length of the last char bbox is correct, then", "\n", "# all the previous bboxes are also valid", "\n", "", "if", "len", "(", "char_bbox_grps", "[", "len", "(", "words", ")", "-", "1", "]", ")", "!=", "len", "(", "words", "[", "-", "1", "]", ")", ":", "\n", "        ", "return", "\n", "\n", "", "return", "img_path", ",", "words", ",", "word_bboxes", ",", "char_bbox_grps", "\n", "\n", "\n", "", "def", "load_gt_data", "(", "filename", ",", "n_proc", ")", ":", "\n", "    ", "mat_data", "=", "loadmat", "(", "filename", ",", "simplify_cells", "=", "True", ")", "\n", "imnames", "=", "mat_data", "[", "'imnames'", "]", "\n", "txt", "=", "mat_data", "[", "'txt'", "]", "\n", "wordBB", "=", "mat_data", "[", "'wordBB'", "]", "\n", "charBB", "=", "mat_data", "[", "'charBB'", "]", "\n", "return", "mmcv", ".", "track_parallel_progress", "(", "\n", "load_gt_datum", ",", "list", "(", "zip", "(", "imnames", ",", "txt", ",", "wordBB", ",", "charBB", ")", ")", ",", "nproc", "=", "n_proc", ")", "\n", "\n", "\n", "", "def", "process", "(", "data", ",", "img_path_prefix", ",", "out_dir", ")", ":", "\n", "    ", "if", "data", "is", "None", ":", "\n", "        ", "return", "\n", "# Dirty hack for multi-processing", "\n", "", "img_path", ",", "words", ",", "word_bboxes", ",", "char_bbox_grps", "=", "data", "\n", "img_dir", ",", "img_name", "=", "os", ".", "path", ".", "split", "(", "img_path", ")", "\n", "img_name", "=", "os", ".", "path", ".", "splitext", "(", "img_name", ")", "[", "0", "]", "\n", "input_img", "=", "mmcv", ".", "imread", "(", "os", ".", "path", ".", "join", "(", "img_path_prefix", ",", "img_path", ")", ")", "\n", "\n", "output_sub_dir", "=", "os", ".", "path", ".", "join", "(", "out_dir", ",", "img_dir", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output_sub_dir", ")", ":", "\n", "        ", "try", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.convert_annotations": [[100, 156], ["isinstance", "isinstance", "isinstance", "time.time", "scipy.io.loadmat", "len", "lmdb.open", "lmdb.open.begin", "range", "str().encode", "txn.put", "int", "os.join", "mmcv.imread", "synthtext_converter.match_bbox_char_str", "range", "json.dumps", "txn.put", "print", "len", "dict", "img_json[].append", "str().encode", "json.dumps.encode", "str", "time.time", "poly_boundary_list[].flatten().tolist", "str", "poly_boundary_list[].flatten"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.match_bbox_char_str"], ["", "except", "FileExistsError", ":", "\n", "            ", "pass", "# occurs when multi-proessing", "\n", "\n", "", "", "for", "i", ",", "word", "in", "enumerate", "(", "words", ")", ":", "\n", "        ", "output_image_patch_name", "=", "f'{img_name}_{i}.png'", "\n", "output_label_name", "=", "f'{img_name}_{i}.txt'", "\n", "output_image_patch_path", "=", "os", ".", "path", ".", "join", "(", "output_sub_dir", ",", "\n", "output_image_patch_name", ")", "\n", "output_label_path", "=", "os", ".", "path", ".", "join", "(", "output_sub_dir", ",", "output_label_name", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "output_image_patch_path", ")", "and", "os", ".", "path", ".", "exists", "(", "\n", "output_label_path", ")", ":", "\n", "            ", "continue", "\n", "\n", "", "word_bbox", "=", "word_bboxes", "[", "i", "]", "\n", "min_x", ",", "max_x", "=", "int", "(", "min", "(", "word_bbox", "[", ":", ":", "2", "]", ")", ")", ",", "int", "(", "max", "(", "word_bbox", "[", ":", ":", "2", "]", ")", ")", "\n", "min_y", ",", "max_y", "=", "int", "(", "min", "(", "word_bbox", "[", "1", ":", ":", "2", "]", ")", ")", ",", "int", "(", "max", "(", "word_bbox", "[", "1", ":", ":", "2", "]", ")", ")", "\n", "cropped_img", "=", "input_img", "[", "min_y", ":", "max_y", ",", "min_x", ":", "max_x", "]", "\n", "if", "cropped_img", ".", "shape", "[", "0", "]", "<=", "0", "or", "cropped_img", ".", "shape", "[", "1", "]", "<=", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "char_bbox_grp", "=", "np", ".", "array", "(", "char_bbox_grps", "[", "i", "]", ")", "\n", "char_bbox_grp", "[", ":", ",", ":", ":", "2", "]", "-=", "min_x", "\n", "char_bbox_grp", "[", ":", ",", "1", ":", ":", "2", "]", "-=", "min_y", "\n", "\n", "mmcv", ".", "imwrite", "(", "cropped_img", ",", "output_image_patch_path", ")", "\n", "with", "open", "(", "output_label_path", ",", "'w'", ")", "as", "output_label_file", ":", "\n", "            ", "output_label_file", ".", "write", "(", "word", "+", "'\\n'", ")", "\n", "for", "cbox", "in", "char_bbox_grp", ":", "\n", "                ", "output_label_file", ".", "write", "(", "'%d %d %d %d %d %d %d %d\\n'", "%", "\n", "tuple", "(", "cbox", ".", "tolist", "(", ")", ")", ")", "\n", "\n", "\n", "", "", "", "", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "print", "(", "'Loading annoataion data...'", ")", "\n", "data", "=", "load_gt_data", "(", "args", ".", "anno_path", ",", "args", ".", "n_proc", ")", "\n", "process_with_outdir", "=", "partial", "(", "\n", "process", ",", "img_path_prefix", "=", "args", ".", "img_path", ",", "out_dir", "=", "args", ".", "out_dir", ")", "\n", "print", "(", "'Creating cropped images and gold labels...'", ")", "\n", "mmcv", ".", "track_parallel_progress", "(", "process_with_outdir", ",", "data", ",", "nproc", "=", "args", ".", "n_proc", ")", "\n", "print", "(", "'Done'", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "main", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.parse_args": [[158, 165], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.synthtext_converter.main": [[167, 176], ["synthtext_converter.parse_args", "mmcv.mkdir_or_exist", "os.join", "synthtext_converter.convert_annotations", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.parse_coco_json": [[10, 33], ["mmcv.load", "img_ids.append", "imgid2anno.keys", "imgid2anno[].append"], "function", ["None"], ["def", "parse_coco_json", "(", "in_path", ")", ":", "\n", "    ", "json_obj", "=", "mmcv", ".", "load", "(", "in_path", ")", "\n", "image_infos", "=", "json_obj", "[", "'images'", "]", "\n", "annotations", "=", "json_obj", "[", "'annotations'", "]", "\n", "imgid2imgname", "=", "{", "}", "\n", "img_ids", "=", "[", "]", "\n", "for", "image_info", "in", "image_infos", ":", "\n", "        ", "imgid2imgname", "[", "image_info", "[", "'id'", "]", "]", "=", "image_info", "\n", "img_ids", ".", "append", "(", "image_info", "[", "'id'", "]", ")", "\n", "", "imgid2anno", "=", "{", "}", "\n", "for", "img_id", "in", "img_ids", ":", "\n", "        ", "imgid2anno", "[", "img_id", "]", "=", "[", "]", "\n", "", "for", "anno", "in", "annotations", ":", "\n", "        ", "img_id", "=", "anno", "[", "'image_id'", "]", "\n", "new_anno", "=", "{", "}", "\n", "new_anno", "[", "'iscrowd'", "]", "=", "anno", "[", "'iscrowd'", "]", "\n", "new_anno", "[", "'category_id'", "]", "=", "anno", "[", "'category_id'", "]", "\n", "new_anno", "[", "'bbox'", "]", "=", "anno", "[", "'bbox'", "]", "\n", "new_anno", "[", "'segmentation'", "]", "=", "anno", "[", "'segmentation'", "]", "\n", "if", "img_id", "in", "imgid2anno", ".", "keys", "(", ")", ":", "\n", "            ", "imgid2anno", "[", "img_id", "]", ".", "append", "(", "new_anno", ")", "\n", "\n", "", "", "return", "imgid2imgname", ",", "imgid2anno", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.gen_line_dict_file": [[35, 47], ["imgid2imgname.items", "mmocr.utils.list_to_file", "lines.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "gen_line_dict_file", "(", "out_path", ",", "imgid2imgname", ",", "imgid2anno", ")", ":", "\n", "    ", "lines", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "imgid2imgname", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", "in", "imgid2anno", ":", "\n", "            ", "anno", "=", "imgid2anno", "[", "key", "]", "\n", "line_dict", "=", "{", "}", "\n", "line_dict", "[", "'file_name'", "]", "=", "value", "[", "'file_name'", "]", "\n", "line_dict", "[", "'height'", "]", "=", "value", "[", "'height'", "]", "\n", "line_dict", "[", "'width'", "]", "=", "value", "[", "'width'", "]", "\n", "line_dict", "[", "'annotations'", "]", "=", "anno", "\n", "lines", ".", "append", "(", "json", ".", "dumps", "(", "line_dict", ")", ")", "\n", "", "", "list_to_file", "(", "out_path", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.parse_args": [[49, 57], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'--in-path'", ",", "help", "=", "'input json path with coco format'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-path'", ",", "help", "=", "'output txt path with line-json format'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.main": [[59, 64], ["coco_to_line_dict.parse_args", "coco_to_line_dict.parse_coco_json", "coco_to_line_dict.gen_line_dict_file", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.parse_coco_json", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet.coco_to_line_dict.gen_line_dict_file"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "imgid2imgname", ",", "imgid2anno", "=", "parse_coco_json", "(", "args", ".", "in_path", ")", "\n", "gen_line_dict_file", "(", "args", ".", "out_path", ",", "imgid2imgname", ",", "imgid2anno", ")", "\n", "print", "(", "'finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.textsnake.TextSnake.__init__": [[15, 28], ["single_stage_text_detector.SingleStageTextDetector.__init__", "text_detector_mixin.TextDetectorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "\n", "init_cfg", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.drrg.DRRG.__init__": [[15, 28], ["single_stage_text_detector.SingleStageTextDetector.__init__", "text_detector_mixin.TextDetectorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "\n", "init_cfg", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.drrg.DRRG.forward_train": [[29, 47], ["drrg.DRRG.extract_feat", "kwargs.pop", "drrg.DRRG.bbox_head", "drrg.DRRG.bbox_head.loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A List of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details of the values of these keys see\n                :class:`mmdet.datasets.pipelines.Collect`.\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "gt_comp_attribs", "=", "kwargs", ".", "pop", "(", "'gt_comp_attribs'", ")", "\n", "preds", "=", "self", ".", "bbox_head", "(", "x", ",", "gt_comp_attribs", ")", "\n", "losses", "=", "self", ".", "bbox_head", ".", "loss", "(", "preds", ",", "**", "kwargs", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.drrg.DRRG.simple_test": [[48, 55], ["drrg.DRRG.extract_feat", "drrg.DRRG.bbox_head.single_test", "drrg.DRRG.bbox_head.get_boundary"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.single_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "\n", "        ", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "outs", "=", "self", ".", "bbox_head", ".", "single_test", "(", "x", ")", "\n", "boundaries", "=", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "outs", ",", "img_metas", ",", "rescale", ")", "\n", "\n", "return", "[", "boundaries", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.dbnet.DBNet.__init__": [[15, 28], ["single_stage_text_detector.SingleStageTextDetector.__init__", "text_detector_mixin.TextDetectorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "\n", "init_cfg", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.fcenet.FCENet.__init__": [[16, 29], ["single_stage_text_detector.SingleStageTextDetector.__init__", "text_detector_mixin.TextDetectorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "\n", "init_cfg", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.fcenet.FCENet.simple_test": [[30, 36], ["fcenet.FCENet.extract_feat", "fcenet.FCENet.bbox_head", "fcenet.FCENet.bbox_head.get_boundary"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "boundaries", "=", "self", ".", "bbox_head", ".", "get_boundary", "(", "outs", ",", "img_metas", ",", "rescale", ")", "\n", "\n", "return", "[", "boundaries", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.single_stage_text_detector.SingleStageTextDetector.__init__": [[12, 22], ["mmocr.models.common.detectors.SingleStageDetector.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "init_cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.single_stage_text_detector.SingleStageTextDetector.forward_train": [[23, 40], ["single_stage_text_detector.SingleStageTextDetector.extract_feat", "single_stage_text_detector.SingleStageTextDetector.bbox_head", "single_stage_text_detector.SingleStageTextDetector.bbox_head.loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            img (Tensor): Input images of shape (N, C, H, W).\n                Typically these should be mean centered and std scaled.\n            img_metas (list[dict]): A list of image info dict where each dict\n                has: 'img_shape', 'scale_factor', 'flip', and may also contain\n                'filename', 'ori_shape', 'pad_shape', and 'img_norm_cfg'.\n                For details on the values of these keys, see\n                :class:`mmdet.datasets.pipelines.Collect`.\n        Returns:\n            dict[str, Tensor]: A dictionary of loss components.\n        \"\"\"", "\n", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "preds", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "losses", "=", "self", ".", "bbox_head", ".", "loss", "(", "preds", ",", "**", "kwargs", ")", "\n", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.single_stage_text_detector.SingleStageTextDetector.simple_test": [[41, 62], ["single_stage_text_detector.SingleStageTextDetector.extract_feat", "single_stage_text_detector.SingleStageTextDetector.bbox_head", "torch.onnx.is_in_onnx_export", "len", "single_stage_text_detector.SingleStageTextDetector.bbox_head.get_boundary", "single_stage_text_detector.SingleStageTextDetector.bbox_head.get_boundary", "range", "outs[].unsqueeze", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "rescale", "=", "False", ")", ":", "\n", "        ", "x", "=", "self", ".", "extract_feat", "(", "img", ")", "\n", "outs", "=", "self", ".", "bbox_head", "(", "x", ")", "\n", "\n", "# early return to avoid post processing", "\n", "if", "torch", ".", "onnx", ".", "is_in_onnx_export", "(", ")", ":", "\n", "            ", "return", "outs", "\n", "\n", "", "if", "len", "(", "img_metas", ")", ">", "1", ":", "\n", "            ", "boundaries", "=", "[", "\n", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "(", "outs", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", ",", "\n", "[", "img_metas", "[", "i", "]", "]", ",", "rescale", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "img_metas", ")", ")", "\n", "]", "\n", "\n", "", "else", ":", "\n", "            ", "boundaries", "=", "[", "\n", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "outs", ",", "img_metas", ",", "rescale", ")", "\n", "]", "\n", "\n", "", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.panet.PANet.__init__": [[15, 28], ["single_stage_text_detector.SingleStageTextDetector.__init__", "text_detector_mixin.TextDetectorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "\n", "init_cfg", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.psenet.PSENet.__init__": [[15, 28], ["single_stage_text_detector.SingleStageTextDetector.__init__", "text_detector_mixin.TextDetectorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", ",", "\n", "bbox_head", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "backbone", ",", "neck", ",", "bbox_head", ",", "\n", "train_cfg", ",", "test_cfg", ",", "pretrained", ",", "\n", "init_cfg", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.ocr_mask_rcnn.OCRMaskRCNN.__init__": [[13, 37], ["text_detector_mixin.TextDetectorMixin.__init__", "mmdet.models.detectors.MaskRCNN.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "rpn_head", ",", "\n", "roi_head", ",", "\n", "train_cfg", ",", "\n", "test_cfg", ",", "\n", "neck", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "text_repr_type", "=", "'quad'", ",", "\n", "show_score", "=", "False", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "MaskRCNN", ".", "__init__", "(", "\n", "self", ",", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "rpn_head", "=", "rpn_head", ",", "\n", "roi_head", "=", "roi_head", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "pretrained", "=", "pretrained", ",", "\n", "init_cfg", "=", "init_cfg", ")", "\n", "assert", "text_repr_type", "in", "[", "'quad'", ",", "'poly'", "]", "\n", "self", ".", "text_repr_type", "=", "text_repr_type", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.ocr_mask_rcnn.OCRMaskRCNN.get_boundary": [[38, 61], ["isinstance", "len", "range", "dict", "mmocr.core.seg2boundary", "boundaries.append"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.seg2boundary"], ["", "def", "get_boundary", "(", "self", ",", "results", ")", ":", "\n", "        ", "\"\"\"Convert segmentation into text boundaries.\n\n        Args:\n           results (tuple): The result tuple. The first element is\n               segmentation while the second is its scores.\n        Returns:\n           dict: A result dict containing 'boundary_result'.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "results", ",", "tuple", ")", "\n", "\n", "instance_num", "=", "len", "(", "results", "[", "1", "]", "[", "0", "]", ")", "\n", "boundaries", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "instance_num", ")", ":", "\n", "            ", "seg", "=", "results", "[", "1", "]", "[", "0", "]", "[", "i", "]", "\n", "score", "=", "results", "[", "0", "]", "[", "0", "]", "[", "i", "]", "[", "-", "1", "]", "\n", "boundary", "=", "seg2boundary", "(", "seg", ",", "self", ".", "text_repr_type", ",", "score", ")", "\n", "if", "boundary", "is", "not", "None", ":", "\n", "                ", "boundaries", ".", "append", "(", "boundary", ")", "\n", "\n", "", "", "results", "=", "dict", "(", "boundary_result", "=", "boundaries", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.ocr_mask_rcnn.OCRMaskRCNN.simple_test": [[62, 70], ["super().simple_test", "ocr_mask_rcnn.OCRMaskRCNN.get_boundary", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "proposals", "=", "None", ",", "rescale", "=", "False", ")", ":", "\n", "\n", "        ", "results", "=", "super", "(", ")", ".", "simple_test", "(", "img", ",", "img_metas", ",", "proposals", ",", "rescale", ")", "\n", "\n", "boundaries", "=", "self", ".", "get_boundary", "(", "results", "[", "0", "]", ")", "\n", "boundaries", "=", "boundaries", "if", "isinstance", "(", "boundaries", ",", "\n", "list", ")", "else", "[", "boundaries", "]", "\n", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.__init__": [[16, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "show_score", ")", ":", "\n", "        ", "self", ".", "show_score", "=", "show_score", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result": [[19, 82], ["mmcv.imread", "img.copy.copy.copy", "result.keys", "mmocr.core.imshow_pred_boundary", "warnings.warn", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_pred_boundary"], ["", "def", "show_result", "(", "self", ",", "\n", "img", ",", "\n", "result", ",", "\n", "score_thr", "=", "0.5", ",", "\n", "bbox_color", "=", "'green'", ",", "\n", "text_color", "=", "'green'", ",", "\n", "thickness", "=", "1", ",", "\n", "font_scale", "=", "0.5", ",", "\n", "win_name", "=", "''", ",", "\n", "show", "=", "False", ",", "\n", "wait_time", "=", "0", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "        ", "\"\"\"Draw `result` over `img`.\n\n        Args:\n            img (str or Tensor): The image to be displayed.\n            result (dict): The results to draw over `img`.\n            score_thr (float, optional): Minimum score of bboxes to be shown.\n                Default: 0.3.\n            bbox_color (str or tuple or :obj:`Color`): Color of bbox lines.\n            text_color (str or tuple or :obj:`Color`): Color of texts.\n            thickness (int): Thickness of lines.\n            font_scale (float): Font scales of texts.\n            win_name (str): The window name.\n            wait_time (int): Value of waitKey param.\n                Default: 0.\n            show (bool): Whether to show the image.\n                Default: False.\n            out_file (str or None): The filename to write the image.\n                Default: None.imshow_pred_boundary`\n        \"\"\"", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "img", "=", "img", ".", "copy", "(", ")", "\n", "boundaries", "=", "None", "\n", "labels", "=", "None", "\n", "if", "'boundary_result'", "in", "result", ".", "keys", "(", ")", ":", "\n", "            ", "boundaries", "=", "result", "[", "'boundary_result'", "]", "\n", "labels", "=", "[", "0", "]", "*", "len", "(", "boundaries", ")", "\n", "\n", "# if out_file specified, do not show image in window", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "            ", "show", "=", "False", "\n", "# draw bounding boxes", "\n", "", "if", "boundaries", "is", "not", "None", ":", "\n", "            ", "imshow_pred_boundary", "(", "\n", "img", ",", "\n", "boundaries", ",", "\n", "labels", ",", "\n", "score_thr", "=", "score_thr", ",", "\n", "boundary_color", "=", "bbox_color", ",", "\n", "text_color", "=", "text_color", ",", "\n", "thickness", "=", "thickness", ",", "\n", "font_scale", "=", "font_scale", ",", "\n", "win_name", "=", "win_name", ",", "\n", "show", "=", "show", ",", "\n", "wait_time", "=", "wait_time", ",", "\n", "out_file", "=", "out_file", ",", "\n", "show_score", "=", "self", ".", "show_score", ")", "\n", "\n", "", "if", "not", "(", "show", "or", "out_file", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'show==False and out_file is not specified, '", "\n", "'result image will be returned'", ")", "\n", "", "return", "img", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.single_stage.SingleStageDetector.__init__": [[19, 40], ["mmdet.models.detectors.SingleStageDetector.__init__", "mmocr.models.builder.build_backbone", "bbox_head.update", "bbox_head.update", "mmocr.models.builder.build_head", "warnings.warn", "mmocr.models.builder.build_neck"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_backbone", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_head", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_neck"], ["def", "__init__", "(", "self", ",", "\n", "backbone", ",", "\n", "neck", "=", "None", ",", "\n", "bbox_head", "=", "None", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "pretrained", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", "MMDET_SingleStageDetector", ",", "self", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "if", "pretrained", ":", "\n", "            ", "warnings", ".", "warn", "(", "'DeprecationWarning: pretrained is deprecated, '", "\n", "'please use \"init_cfg\" instead'", ")", "\n", "backbone", ".", "pretrained", "=", "pretrained", "\n", "", "self", ".", "backbone", "=", "build_backbone", "(", "backbone", ")", "\n", "if", "neck", "is", "not", "None", ":", "\n", "            ", "self", ".", "neck", "=", "build_neck", "(", "neck", ")", "\n", "", "bbox_head", ".", "update", "(", "train_cfg", "=", "train_cfg", ")", "\n", "bbox_head", ".", "update", "(", "test_cfg", "=", "test_cfg", ")", "\n", "self", ".", "bbox_head", "=", "build_head", "(", "bbox_head", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.__init__": [[42, 77], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "len", "mmcv.ops.RoIAlignRotated", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "k_at_hops", ",", "num_adjacent_linkages", ",", "node_geo_feat_len", ",", "\n", "pooling_scale", ",", "pooling_output_size", ",", "nms_thr", ",", "min_width", ",", "\n", "max_width", ",", "comp_shrink_ratio", ",", "comp_w_h_ratio", ",", "comp_score_thr", ",", "\n", "text_region_thr", ",", "center_region_thr", ",", "center_region_area_thr", ")", ":", "\n", "\n", "        ", "assert", "len", "(", "k_at_hops", ")", "==", "2", "\n", "assert", "isinstance", "(", "k_at_hops", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "num_adjacent_linkages", ",", "int", ")", "\n", "assert", "isinstance", "(", "node_geo_feat_len", ",", "int", ")", "\n", "assert", "isinstance", "(", "pooling_scale", ",", "float", ")", "\n", "assert", "isinstance", "(", "pooling_output_size", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "nms_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "min_width", ",", "float", ")", "\n", "assert", "isinstance", "(", "max_width", ",", "float", ")", "\n", "assert", "isinstance", "(", "comp_shrink_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "comp_w_h_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "comp_score_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "text_region_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "center_region_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "center_region_area_thr", ",", "int", ")", "\n", "\n", "self", ".", "k_at_hops", "=", "k_at_hops", "\n", "self", ".", "active_connection", "=", "num_adjacent_linkages", "\n", "self", ".", "local_graph_depth", "=", "len", "(", "self", ".", "k_at_hops", ")", "\n", "self", ".", "node_geo_feat_dim", "=", "node_geo_feat_len", "\n", "self", ".", "pooling", "=", "RoIAlignRotated", "(", "pooling_output_size", ",", "pooling_scale", ")", "\n", "self", ".", "nms_thr", "=", "nms_thr", "\n", "self", ".", "min_width", "=", "min_width", "\n", "self", ".", "max_width", "=", "max_width", "\n", "self", ".", "comp_shrink_ratio", "=", "comp_shrink_ratio", "\n", "self", ".", "comp_w_h_ratio", "=", "comp_w_h_ratio", "\n", "self", ".", "comp_score_thr", "=", "comp_score_thr", "\n", "self", ".", "text_region_thr", "=", "text_region_thr", "\n", "self", ".", "center_region_thr", "=", "center_region_thr", "\n", "self", ".", "center_region_area_thr", "=", "center_region_area_thr", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.propose_comps": [[78, 131], ["numpy.argwhere", "sin_map[].reshape", "cos_map[].reshape", "numpy.clip", "numpy.hstack().astype", "score_map[].reshape", "numpy.hstack", "top_height_map[].reshape", "bot_height_map[].reshape", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.hstack", "numpy.argsort", "numpy.hstack"], "methods", ["None"], ["", "def", "propose_comps", "(", "self", ",", "score_map", ",", "top_height_map", ",", "bot_height_map", ",", "sin_map", ",", "\n", "cos_map", ",", "comp_score_thr", ",", "min_width", ",", "max_width", ",", "\n", "comp_shrink_ratio", ",", "comp_w_h_ratio", ")", ":", "\n", "        ", "\"\"\"Propose text components.\n\n        Args:\n            score_map (ndarray): The score map for NMS.\n            top_height_map (ndarray): The predicted text height map from each\n                pixel in text center region to top sideline.\n            bot_height_map (ndarray): The predicted text height map from each\n                pixel in text center region to bottom sideline.\n            sin_map (ndarray): The predicted sin(theta) map.\n            cos_map (ndarray): The predicted cos(theta) map.\n            comp_score_thr (float): The score threshold of text component.\n            min_width (float): The minimum width of text components.\n            max_width (float): The maximum width of text components.\n            comp_shrink_ratio (float): The shrink ratio of text components.\n            comp_w_h_ratio (float): The width to height ratio of text\n                components.\n\n        Returns:\n            text_comps (ndarray): The text components.\n        \"\"\"", "\n", "\n", "comp_centers", "=", "np", ".", "argwhere", "(", "score_map", ">", "comp_score_thr", ")", "\n", "comp_centers", "=", "comp_centers", "[", "np", ".", "argsort", "(", "comp_centers", "[", ":", ",", "0", "]", ")", "]", "\n", "y", "=", "comp_centers", "[", ":", ",", "0", "]", "\n", "x", "=", "comp_centers", "[", ":", ",", "1", "]", "\n", "\n", "top_height", "=", "top_height_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "*", "comp_shrink_ratio", "\n", "bot_height", "=", "bot_height_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "*", "comp_shrink_ratio", "\n", "sin", "=", "sin_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "cos", "=", "cos_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "top_mid_pts", "=", "comp_centers", "+", "np", ".", "hstack", "(", "\n", "[", "top_height", "*", "sin", ",", "top_height", "*", "cos", "]", ")", "\n", "bot_mid_pts", "=", "comp_centers", "-", "np", ".", "hstack", "(", "\n", "[", "bot_height", "*", "sin", ",", "bot_height", "*", "cos", "]", ")", "\n", "\n", "width", "=", "(", "top_height", "+", "bot_height", ")", "*", "comp_w_h_ratio", "\n", "width", "=", "np", ".", "clip", "(", "width", ",", "min_width", ",", "max_width", ")", "\n", "r", "=", "width", "/", "2", "\n", "\n", "tl", "=", "top_mid_pts", "[", ":", ",", ":", ":", "-", "1", "]", "-", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "tr", "=", "top_mid_pts", "[", ":", ",", ":", ":", "-", "1", "]", "+", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "br", "=", "bot_mid_pts", "[", ":", ",", ":", ":", "-", "1", "]", "+", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "bl", "=", "bot_mid_pts", "[", ":", ",", ":", ":", "-", "1", "]", "-", "np", ".", "hstack", "(", "[", "-", "r", "*", "sin", ",", "r", "*", "cos", "]", ")", "\n", "text_comps", "=", "np", ".", "hstack", "(", "[", "tl", ",", "tr", ",", "br", ",", "bl", "]", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "score", "=", "score_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "text_comps", "=", "np", ".", "hstack", "(", "[", "text_comps", ",", "score", "]", ")", "\n", "\n", "return", "text_comps", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.propose_comps_and_attribs": [[132, 237], ["numpy.sqrt", "mmocr.models.textdet.postprocess.utils.fill_hole", "cv2.findContours", "numpy.vstack", "text_comps[].reshape", "numpy.mean().astype", "numpy.array().reshape", "numpy.hstack", "numpy.clip", "sin_map[].reshape", "cos_map[].reshape", "x.reshape.reshape.reshape", "y.reshape.reshape.reshape", "numpy.hstack", "mmocr.models.textdet.postprocess.utils.fill_hole.astype", "numpy.zeros", "cv2.drawContours", "proposal_local_graph.ProposalLocalGraphs.propose_comps", "lanms.merge_quadrangle_n9", "numpy.zeros", "text_comps[].reshape().astype", "cv2.drawContours", "len", "numpy.clip", "numpy.clip", "numpy.min().astype", "numpy.max().astype", "numpy.zeros", "cv2.fillPoly", "numpy.array().reshape.append", "top_height_map[].reshape", "bot_height_map[].reshape", "numpy.zeros.sum", "comp_list.append", "numpy.mean", "cv2.mean", "numpy.array", "text_comps[].reshape", "numpy.zeros.sum", "numpy.min", "numpy.max", "text_comp_box.astype"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fill_hole", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.propose_comps"], ["", "def", "propose_comps_and_attribs", "(", "self", ",", "text_region_map", ",", "center_region_map", ",", "\n", "top_height_map", ",", "bot_height_map", ",", "sin_map", ",", "\n", "cos_map", ")", ":", "\n", "        ", "\"\"\"Generate text components and attributes.\n\n        Args:\n            text_region_map (ndarray): The predicted text region probability\n                map.\n            center_region_map (ndarray): The predicted text center region\n                probability map.\n            top_height_map (ndarray): The predicted text height map from each\n                pixel in text center region to top sideline.\n            bot_height_map (ndarray): The predicted text height map from each\n                pixel in text center region to bottom sideline.\n            sin_map (ndarray): The predicted sin(theta) map.\n            cos_map (ndarray): The predicted cos(theta) map.\n\n        Returns:\n            comp_attribs (ndarray): The text component attributes.\n            text_comps (ndarray): The text components.\n        \"\"\"", "\n", "\n", "assert", "(", "text_region_map", ".", "shape", "==", "center_region_map", ".", "shape", "==", "\n", "top_height_map", ".", "shape", "==", "bot_height_map", ".", "shape", "==", "sin_map", ".", "shape", "\n", "==", "cos_map", ".", "shape", ")", "\n", "text_mask", "=", "text_region_map", ">", "self", ".", "text_region_thr", "\n", "center_region_mask", "=", "(", "center_region_map", ">", "\n", "self", ".", "center_region_thr", ")", "*", "text_mask", "\n", "\n", "scale", "=", "np", ".", "sqrt", "(", "1.0", "/", "(", "sin_map", "**", "2", "+", "cos_map", "**", "2", "+", "1e-8", ")", ")", "\n", "sin_map", ",", "cos_map", "=", "sin_map", "*", "scale", ",", "cos_map", "*", "scale", "\n", "\n", "center_region_mask", "=", "fill_hole", "(", "center_region_mask", ")", "\n", "center_region_contours", ",", "_", "=", "cv2", ".", "findContours", "(", "\n", "center_region_mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cv2", ".", "RETR_TREE", ",", "\n", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "\n", "\n", "mask_sz", "=", "center_region_map", ".", "shape", "\n", "comp_list", "=", "[", "]", "\n", "for", "contour", "in", "center_region_contours", ":", "\n", "            ", "current_center_mask", "=", "np", ".", "zeros", "(", "mask_sz", ")", "\n", "cv2", ".", "drawContours", "(", "current_center_mask", ",", "[", "contour", "]", ",", "-", "1", ",", "1", ",", "-", "1", ")", "\n", "if", "current_center_mask", ".", "sum", "(", ")", "<=", "self", ".", "center_region_area_thr", ":", "\n", "                ", "continue", "\n", "", "score_map", "=", "text_region_map", "*", "current_center_mask", "\n", "\n", "text_comps", "=", "self", ".", "propose_comps", "(", "score_map", ",", "top_height_map", ",", "\n", "bot_height_map", ",", "sin_map", ",", "cos_map", ",", "\n", "self", ".", "comp_score_thr", ",", "\n", "self", ".", "min_width", ",", "self", ".", "max_width", ",", "\n", "self", ".", "comp_shrink_ratio", ",", "\n", "self", ".", "comp_w_h_ratio", ")", "\n", "\n", "text_comps", "=", "la_nms", "(", "text_comps", ",", "self", ".", "nms_thr", ")", "\n", "text_comp_mask", "=", "np", ".", "zeros", "(", "mask_sz", ")", "\n", "text_comp_boxes", "=", "text_comps", "[", ":", ",", ":", "8", "]", ".", "reshape", "(", "\n", "(", "-", "1", ",", "4", ",", "2", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "cv2", ".", "drawContours", "(", "text_comp_mask", ",", "text_comp_boxes", ",", "-", "1", ",", "1", ",", "-", "1", ")", "\n", "if", "(", "text_comp_mask", "*", "text_mask", ")", ".", "sum", "(", ")", "<", "text_comp_mask", ".", "sum", "(", ")", "*", "0.5", ":", "\n", "                ", "continue", "\n", "", "if", "text_comps", ".", "shape", "[", "-", "1", "]", ">", "0", ":", "\n", "                ", "comp_list", ".", "append", "(", "text_comps", ")", "\n", "\n", "", "", "if", "len", "(", "comp_list", ")", "<=", "0", ":", "\n", "            ", "return", "None", ",", "None", "\n", "\n", "", "text_comps", "=", "np", ".", "vstack", "(", "comp_list", ")", "\n", "text_comp_boxes", "=", "text_comps", "[", ":", ",", ":", "8", "]", ".", "reshape", "(", "(", "-", "1", ",", "4", ",", "2", ")", ")", "\n", "centers", "=", "np", ".", "mean", "(", "text_comp_boxes", ",", "axis", "=", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "x", "=", "centers", "[", ":", ",", "0", "]", "\n", "y", "=", "centers", "[", ":", ",", "1", "]", "\n", "\n", "scores", "=", "[", "]", "\n", "for", "text_comp_box", "in", "text_comp_boxes", ":", "\n", "            ", "text_comp_box", "[", ":", ",", "0", "]", "=", "np", ".", "clip", "(", "text_comp_box", "[", ":", ",", "0", "]", ",", "0", ",", "\n", "mask_sz", "[", "1", "]", "-", "1", ")", "\n", "text_comp_box", "[", ":", ",", "1", "]", "=", "np", ".", "clip", "(", "text_comp_box", "[", ":", ",", "1", "]", ",", "0", ",", "\n", "mask_sz", "[", "0", "]", "-", "1", ")", "\n", "min_coord", "=", "np", ".", "min", "(", "text_comp_box", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "max_coord", "=", "np", ".", "max", "(", "text_comp_box", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "text_comp_box", "=", "text_comp_box", "-", "min_coord", "\n", "box_sz", "=", "(", "max_coord", "-", "min_coord", "+", "1", ")", "\n", "temp_comp_mask", "=", "np", ".", "zeros", "(", "(", "box_sz", "[", "1", "]", ",", "box_sz", "[", "0", "]", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "cv2", ".", "fillPoly", "(", "temp_comp_mask", ",", "[", "text_comp_box", ".", "astype", "(", "np", ".", "int32", ")", "]", ",", "1", ")", "\n", "temp_region_patch", "=", "text_region_map", "[", "min_coord", "[", "1", "]", ":", "(", "max_coord", "[", "1", "]", "+", "\n", "1", ")", ",", "\n", "min_coord", "[", "0", "]", ":", "(", "max_coord", "[", "0", "]", "+", "\n", "1", ")", "]", "\n", "score", "=", "cv2", ".", "mean", "(", "temp_region_patch", ",", "temp_comp_mask", ")", "[", "0", "]", "\n", "scores", ".", "append", "(", "score", ")", "\n", "", "scores", "=", "np", ".", "array", "(", "scores", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "text_comps", "=", "np", ".", "hstack", "(", "[", "text_comps", "[", ":", ",", ":", "-", "1", "]", ",", "scores", "]", ")", "\n", "\n", "h", "=", "top_height_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "+", "bot_height_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "w", "=", "np", ".", "clip", "(", "h", "*", "self", ".", "comp_w_h_ratio", ",", "self", ".", "min_width", ",", "self", ".", "max_width", ")", "\n", "sin", "=", "sin_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "cos", "=", "cos_map", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "x", "=", "x", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "y", "=", "y", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "comp_attribs", "=", "np", ".", "hstack", "(", "[", "x", ",", "y", ",", "h", ",", "w", ",", "cos", ",", "sin", "]", ")", "\n", "\n", "return", "comp_attribs", ",", "text_comps", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.generate_local_graphs": [[238, 348], ["enumerate", "max", "enumerate", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "set", "set.discard", "list", "list.insert", "pivot_local_graphs.append", "pivot_knns.append", "len", "torch.tensor().long().to", "numpy.zeros", "utils.normalize_adjacent_matrix", "torch.zeros", "torch.from_numpy", "torch.cat", "torch.tensor", "torch.cat", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "set.update", "list", "len", "set", "enumerate", "torch.tensor().long", "torch.zeros", "torch.zeros", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.normalize_adjacent_matrix"], ["", "def", "generate_local_graphs", "(", "self", ",", "sorted_dist_inds", ",", "node_feats", ")", ":", "\n", "        ", "\"\"\"Generate local graphs and graph convolution network input data.\n\n        Args:\n            sorted_dist_inds (ndarray): The node indices sorted according to\n                the Euclidean distance.\n            node_feats (tensor): The features of nodes in graph.\n\n        Returns:\n            local_graphs_node_feats (tensor): The features of nodes in local\n                graphs.\n            adjacent_matrices (tensor): The adjacent matrices.\n            pivots_knn_inds (tensor): The k-nearest neighbor indices in\n                local graphs.\n            pivots_local_graphs (tensor): The indices of nodes in local\n                graphs.\n        \"\"\"", "\n", "\n", "assert", "sorted_dist_inds", ".", "ndim", "==", "2", "\n", "assert", "(", "sorted_dist_inds", ".", "shape", "[", "0", "]", "==", "sorted_dist_inds", ".", "shape", "[", "1", "]", "==", "\n", "node_feats", ".", "shape", "[", "0", "]", ")", "\n", "\n", "knn_graph", "=", "sorted_dist_inds", "[", ":", ",", "1", ":", "self", ".", "k_at_hops", "[", "0", "]", "+", "1", "]", "\n", "pivot_local_graphs", "=", "[", "]", "\n", "pivot_knns", "=", "[", "]", "\n", "device", "=", "node_feats", ".", "device", "\n", "\n", "for", "pivot_ind", ",", "knn", "in", "enumerate", "(", "knn_graph", ")", ":", "\n", "\n", "            ", "local_graph_neighbors", "=", "set", "(", "knn", ")", "\n", "\n", "for", "neighbor_ind", "in", "knn", ":", "\n", "                ", "local_graph_neighbors", ".", "update", "(", "\n", "set", "(", "sorted_dist_inds", "[", "neighbor_ind", ",", "\n", "1", ":", "self", ".", "k_at_hops", "[", "1", "]", "+", "1", "]", ")", ")", "\n", "\n", "", "local_graph_neighbors", ".", "discard", "(", "pivot_ind", ")", "\n", "pivot_local_graph", "=", "list", "(", "local_graph_neighbors", ")", "\n", "pivot_local_graph", ".", "insert", "(", "0", ",", "pivot_ind", ")", "\n", "pivot_knn", "=", "[", "pivot_ind", "]", "+", "list", "(", "knn", ")", "\n", "\n", "pivot_local_graphs", ".", "append", "(", "pivot_local_graph", ")", "\n", "pivot_knns", ".", "append", "(", "pivot_knn", ")", "\n", "\n", "", "num_max_nodes", "=", "max", "(", "[", "\n", "len", "(", "pivot_local_graph", ")", "for", "pivot_local_graph", "in", "pivot_local_graphs", "\n", "]", ")", "\n", "\n", "local_graphs_node_feat", "=", "[", "]", "\n", "adjacent_matrices", "=", "[", "]", "\n", "pivots_knn_inds", "=", "[", "]", "\n", "pivots_local_graphs", "=", "[", "]", "\n", "\n", "for", "graph_ind", ",", "pivot_knn", "in", "enumerate", "(", "pivot_knns", ")", ":", "\n", "            ", "pivot_local_graph", "=", "pivot_local_graphs", "[", "graph_ind", "]", "\n", "num_nodes", "=", "len", "(", "pivot_local_graph", ")", "\n", "pivot_ind", "=", "pivot_local_graph", "[", "0", "]", "\n", "node2ind_map", "=", "{", "j", ":", "i", "for", "i", ",", "j", "in", "enumerate", "(", "pivot_local_graph", ")", "}", "\n", "\n", "knn_inds", "=", "torch", ".", "tensor", "(", "[", "node2ind_map", "[", "i", "]", "\n", "for", "i", "in", "pivot_knn", "[", "1", ":", "]", "]", ")", ".", "long", "(", ")", ".", "to", "(", "device", ")", "\n", "pivot_feats", "=", "node_feats", "[", "pivot_ind", "]", "\n", "normalized_feats", "=", "node_feats", "[", "pivot_local_graph", "]", "-", "pivot_feats", "\n", "\n", "adjacent_matrix", "=", "np", ".", "zeros", "(", "(", "num_nodes", ",", "num_nodes", ")", ")", "\n", "for", "node", "in", "pivot_local_graph", ":", "\n", "                ", "neighbors", "=", "sorted_dist_inds", "[", "node", ",", "\n", "1", ":", "self", ".", "active_connection", "+", "1", "]", "\n", "for", "neighbor", "in", "neighbors", ":", "\n", "                    ", "if", "neighbor", "in", "pivot_local_graph", ":", "\n", "                        ", "adjacent_matrix", "[", "node2ind_map", "[", "node", "]", ",", "\n", "node2ind_map", "[", "neighbor", "]", "]", "=", "1", "\n", "adjacent_matrix", "[", "node2ind_map", "[", "neighbor", "]", ",", "\n", "node2ind_map", "[", "node", "]", "]", "=", "1", "\n", "\n", "", "", "", "adjacent_matrix", "=", "normalize_adjacent_matrix", "(", "adjacent_matrix", ")", "\n", "pad_adjacent_matrix", "=", "torch", ".", "zeros", "(", "(", "num_max_nodes", ",", "num_max_nodes", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ",", "\n", "device", "=", "device", ")", "\n", "pad_adjacent_matrix", "[", ":", "num_nodes", ",", ":", "num_nodes", "]", "=", "torch", ".", "from_numpy", "(", "\n", "adjacent_matrix", ")", "\n", "\n", "pad_normalized_feats", "=", "torch", ".", "cat", "(", "[", "\n", "normalized_feats", ",", "\n", "torch", ".", "zeros", "(", "\n", "(", "num_max_nodes", "-", "num_nodes", ",", "normalized_feats", ".", "shape", "[", "1", "]", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ",", "\n", "device", "=", "device", ")", "\n", "]", ",", "\n", "dim", "=", "0", ")", "\n", "\n", "local_graph_nodes", "=", "torch", ".", "tensor", "(", "pivot_local_graph", ")", "\n", "local_graph_nodes", "=", "torch", ".", "cat", "(", "[", "\n", "local_graph_nodes", ",", "\n", "torch", ".", "zeros", "(", "num_max_nodes", "-", "num_nodes", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "]", ",", "\n", "dim", "=", "-", "1", ")", "\n", "\n", "local_graphs_node_feat", ".", "append", "(", "pad_normalized_feats", ")", "\n", "adjacent_matrices", ".", "append", "(", "pad_adjacent_matrix", ")", "\n", "pivots_knn_inds", ".", "append", "(", "knn_inds", ")", "\n", "pivots_local_graphs", ".", "append", "(", "local_graph_nodes", ")", "\n", "\n", "", "local_graphs_node_feat", "=", "torch", ".", "stack", "(", "local_graphs_node_feat", ",", "0", ")", "\n", "adjacent_matrices", "=", "torch", ".", "stack", "(", "adjacent_matrices", ",", "0", ")", "\n", "pivots_knn_inds", "=", "torch", ".", "stack", "(", "pivots_knn_inds", ",", "0", ")", "\n", "pivots_local_graphs", "=", "torch", ".", "stack", "(", "pivots_local_graphs", ",", "0", ")", "\n", "\n", "return", "(", "local_graphs_node_feat", ",", "adjacent_matrices", ",", "pivots_knn_inds", ",", "\n", "pivots_local_graphs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.__call__": [[349, 415], ["torch.sigmoid().data.cpu().numpy", "torch.sigmoid().data.cpu().numpy", "preds[].data.cpu().numpy", "preds[].data.cpu().numpy", "preds[].data.cpu().numpy", "preds[].data.cpu().numpy", "proposal_local_graph.ProposalLocalGraphs.propose_comps_and_attribs", "utils.euclidean_distance_matrix", "utils.feature_embedding", "torch.from_numpy().to", "numpy.zeros", "comp_attribs.astype.astype.astype", "angle.reshape.reshape.reshape", "numpy.hstack", "torch.from_numpy().to", "proposal_local_graph.ProposalLocalGraphs.pooling", "content_feats.view().to.view().to.view().to", "torch.cat", "numpy.argsort", "proposal_local_graph.ProposalLocalGraphs.generate_local_graphs", "torch.squeeze", "numpy.arccos", "numpy.sign", "torch.sigmoid().data.cpu", "torch.sigmoid().data.cpu", "preds[].data.cpu", "preds[].data.cpu", "preds[].data.cpu", "preds[].data.cpu", "len", "torch.from_numpy", "torch.from_numpy", "content_feats.view().to.view().to.view", "torch.sigmoid", "torch.sigmoid"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.proposal_local_graph.ProposalLocalGraphs.propose_comps_and_attribs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.euclidean_distance_matrix", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.feature_embedding", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.generate_local_graphs"], ["", "def", "__call__", "(", "self", ",", "preds", ",", "feat_maps", ")", ":", "\n", "        ", "\"\"\"Generate local graphs and graph convolutional network input data.\n\n        Args:\n            preds (tensor): The predicted maps.\n            feat_maps (tensor): The feature maps to extract content feature of\n                text components.\n\n        Returns:\n            none_flag (bool): The flag showing whether the number of proposed\n                text components is 0.\n            local_graphs_node_feats (tensor): The features of nodes in local\n                graphs.\n            adjacent_matrices (tensor): The adjacent matrices.\n            pivots_knn_inds (tensor): The k-nearest neighbor indices in\n                local graphs.\n            pivots_local_graphs (tensor): The indices of nodes in local\n                graphs.\n            text_comps (ndarray): The predicted text components.\n        \"\"\"", "\n", "\n", "if", "preds", ".", "ndim", "==", "4", ":", "\n", "            ", "assert", "preds", ".", "shape", "[", "0", "]", "==", "1", "\n", "preds", "=", "torch", ".", "squeeze", "(", "preds", ")", "\n", "", "pred_text_region", "=", "torch", ".", "sigmoid", "(", "preds", "[", "0", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_center_region", "=", "torch", ".", "sigmoid", "(", "preds", "[", "1", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_sin_map", "=", "preds", "[", "2", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_cos_map", "=", "preds", "[", "3", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_top_height_map", "=", "preds", "[", "4", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "pred_bot_height_map", "=", "preds", "[", "5", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "device", "=", "preds", ".", "device", "\n", "\n", "comp_attribs", ",", "text_comps", "=", "self", ".", "propose_comps_and_attribs", "(", "\n", "pred_text_region", ",", "pred_center_region", ",", "pred_top_height_map", ",", "\n", "pred_bot_height_map", ",", "pred_sin_map", ",", "pred_cos_map", ")", "\n", "\n", "if", "comp_attribs", "is", "None", "or", "len", "(", "comp_attribs", ")", "<", "2", ":", "\n", "            ", "none_flag", "=", "True", "\n", "return", "none_flag", ",", "(", "0", ",", "0", ",", "0", ",", "0", ",", "0", ")", "\n", "\n", "", "comp_centers", "=", "comp_attribs", "[", ":", ",", "0", ":", "2", "]", "\n", "distance_matrix", "=", "euclidean_distance_matrix", "(", "comp_centers", ",", "comp_centers", ")", "\n", "\n", "geo_feats", "=", "feature_embedding", "(", "comp_attribs", ",", "self", ".", "node_geo_feat_dim", ")", "\n", "geo_feats", "=", "torch", ".", "from_numpy", "(", "geo_feats", ")", ".", "to", "(", "preds", ".", "device", ")", "\n", "\n", "batch_id", "=", "np", ".", "zeros", "(", "(", "comp_attribs", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "comp_attribs", "=", "comp_attribs", ".", "astype", "(", "np", ".", "float32", ")", "\n", "angle", "=", "np", ".", "arccos", "(", "comp_attribs", "[", ":", ",", "-", "2", "]", ")", "*", "np", ".", "sign", "(", "comp_attribs", "[", ":", ",", "-", "1", "]", ")", "\n", "angle", "=", "angle", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "rotated_rois", "=", "np", ".", "hstack", "(", "[", "batch_id", ",", "comp_attribs", "[", ":", ",", ":", "-", "2", "]", ",", "angle", "]", ")", "\n", "rois", "=", "torch", ".", "from_numpy", "(", "rotated_rois", ")", ".", "to", "(", "device", ")", "\n", "\n", "content_feats", "=", "self", ".", "pooling", "(", "feat_maps", ",", "rois", ")", "\n", "content_feats", "=", "content_feats", ".", "view", "(", "content_feats", ".", "shape", "[", "0", "]", ",", "\n", "-", "1", ")", ".", "to", "(", "device", ")", "\n", "node_feats", "=", "torch", ".", "cat", "(", "[", "content_feats", ",", "geo_feats", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "sorted_dist_inds", "=", "np", ".", "argsort", "(", "distance_matrix", ",", "axis", "=", "1", ")", "\n", "(", "local_graphs_node_feat", ",", "adjacent_matrices", ",", "pivots_knn_inds", ",", "\n", "pivots_local_graphs", ")", "=", "self", ".", "generate_local_graphs", "(", "\n", "sorted_dist_inds", ",", "node_feats", ")", "\n", "\n", "none_flag", "=", "False", "\n", "return", "none_flag", ",", "(", "local_graphs_node_feat", ",", "adjacent_matrices", ",", "\n", "pivots_knn_inds", ",", "pivots_local_graphs", ",", "text_comps", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.gcn.MeanAggregator.forward": [[10, 13], ["torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "features", ",", "A", ")", ":", "\n", "        ", "x", "=", "torch", ".", "bmm", "(", "A", ",", "features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.gcn.GraphConv.__init__": [[17, 26], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.constant_", "torch.nn.init.constant_", "torch.nn.init.constant_", "gcn.MeanAggregator", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_dim", "*", "2", ",", "out_dim", ")", ")", "\n", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_dim", ")", ")", "\n", "init", ".", "xavier_uniform_", "(", "self", ".", "weight", ")", "\n", "init", ".", "constant_", "(", "self", ".", "bias", ",", "0", ")", "\n", "self", ".", "aggregator", "=", "MeanAggregator", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.gcn.GraphConv.forward": [[27, 35], ["gcn.GraphConv.aggregator", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "features", ",", "A", ")", ":", "\n", "        ", "b", ",", "n", ",", "d", "=", "features", ".", "shape", "\n", "assert", "d", "==", "self", ".", "in_dim", "\n", "agg_feats", "=", "self", ".", "aggregator", "(", "features", ",", "A", ")", "\n", "cat_feats", "=", "torch", ".", "cat", "(", "[", "features", ",", "agg_feats", "]", ",", "dim", "=", "2", ")", "\n", "out", "=", "torch", ".", "einsum", "(", "'bnd,df->bnf'", ",", "cat_feats", ",", "self", ".", "weight", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", "+", "self", ".", "bias", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.gcn.GCN.__init__": [[45, 54], ["torch.Module.__init__", "torch.BatchNorm1d().float", "torch.BatchNorm1d().float", "torch.BatchNorm1d().float", "gcn.GraphConv", "gcn.GraphConv", "gcn.GraphConv", "gcn.GraphConv", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "feat_len", ")", ":", "\n", "        ", "super", "(", "GCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn0", "=", "nn", ".", "BatchNorm1d", "(", "feat_len", ",", "affine", "=", "False", ")", ".", "float", "(", ")", "\n", "self", ".", "conv1", "=", "GraphConv", "(", "feat_len", ",", "512", ")", "\n", "self", ".", "conv2", "=", "GraphConv", "(", "512", ",", "256", ")", "\n", "self", ".", "conv3", "=", "GraphConv", "(", "256", ",", "128", ")", "\n", "self", ".", "conv4", "=", "GraphConv", "(", "128", ",", "64", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "64", ",", "32", ")", ",", "nn", ".", "PReLU", "(", "32", ")", ",", "nn", ".", "Linear", "(", "32", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.gcn.GCN.forward": [[55, 77], ["gcn.GCN.view", "gcn.GCN.bn0", "gcn.GCN.view", "gcn.GCN.conv1", "gcn.GCN.conv2", "gcn.GCN.conv3", "gcn.GCN.conv4", "knn_inds.size", "gcn.GCN.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "edge_feat.view.view.view", "gcn.GCN.classifier"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "A", ",", "knn_inds", ")", ":", "\n", "\n", "        ", "num_local_graphs", ",", "num_max_nodes", ",", "feat_len", "=", "x", ".", "shape", "\n", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "feat_len", ")", "\n", "x", "=", "self", ".", "bn0", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "num_local_graphs", ",", "num_max_nodes", ",", "feat_len", ")", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ",", "A", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ",", "A", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ",", "A", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ",", "A", ")", "\n", "k", "=", "knn_inds", ".", "size", "(", "-", "1", ")", "\n", "mid_feat_len", "=", "x", ".", "size", "(", "-", "1", ")", "\n", "edge_feat", "=", "torch", ".", "zeros", "(", "(", "num_local_graphs", ",", "k", ",", "mid_feat_len", ")", ",", "\n", "device", "=", "x", ".", "device", ")", "\n", "for", "graph_ind", "in", "range", "(", "num_local_graphs", ")", ":", "\n", "            ", "edge_feat", "[", "graph_ind", ",", ":", ",", ":", "]", "=", "x", "[", "graph_ind", ",", "knn_inds", "[", "graph_ind", "]", "]", "\n", "", "edge_feat", "=", "edge_feat", ".", "view", "(", "-", "1", ",", "mid_feat_len", ")", "\n", "pred", "=", "self", ".", "classifier", "(", "edge_feat", ")", "\n", "\n", "return", "pred", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.__init__": [[30, 46], ["all", "isinstance", "isinstance", "isinstance", "all", "isinstance", "mmcv.ops.RoIAlignRotated", "len", "isinstance", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "k_at_hops", ",", "num_adjacent_linkages", ",", "node_geo_feat_len", ",", "\n", "pooling_scale", ",", "pooling_output_size", ",", "local_graph_thr", ")", ":", "\n", "\n", "        ", "assert", "len", "(", "k_at_hops", ")", "==", "2", "\n", "assert", "all", "(", "isinstance", "(", "n", ",", "int", ")", "for", "n", "in", "k_at_hops", ")", "\n", "assert", "isinstance", "(", "num_adjacent_linkages", ",", "int", ")", "\n", "assert", "isinstance", "(", "node_geo_feat_len", ",", "int", ")", "\n", "assert", "isinstance", "(", "pooling_scale", ",", "float", ")", "\n", "assert", "all", "(", "isinstance", "(", "n", ",", "int", ")", "for", "n", "in", "pooling_output_size", ")", "\n", "assert", "isinstance", "(", "local_graph_thr", ",", "float", ")", "\n", "\n", "self", ".", "k_at_hops", "=", "k_at_hops", "\n", "self", ".", "num_adjacent_linkages", "=", "num_adjacent_linkages", "\n", "self", ".", "node_geo_feat_dim", "=", "node_geo_feat_len", "\n", "self", ".", "pooling", "=", "RoIAlignRotated", "(", "pooling_output_size", ",", "pooling_scale", ")", "\n", "self", ".", "local_graph_thr", "=", "local_graph_thr", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.generate_local_graphs": [[47, 114], ["enumerate", "set", "set.discard", "list", "list.insert", "set.update", "list", "pivot_local_graphs.append", "pivot_knns.append", "enumerate", "set", "len", "len", "pivot_local_graphs.append", "pivot_knns.append", "set().union", "set().intersection", "set", "set", "set", "set"], "methods", ["None"], ["", "def", "generate_local_graphs", "(", "self", ",", "sorted_dist_inds", ",", "gt_comp_labels", ")", ":", "\n", "        ", "\"\"\"Generate local graphs for GCN to predict which instance a text\n        component belongs to.\n\n        Args:\n            sorted_dist_inds (ndarray): The complete graph node indices, which\n                is sorted according to the Euclidean distance.\n            gt_comp_labels(ndarray): The ground truth labels define the\n                instance to which the text components (nodes in graphs) belong.\n\n        Returns:\n            pivot_local_graphs(list[list[int]]): The list of local graph\n                neighbor indices of pivots.\n            pivot_knns(list[list[int]]): The list of k-nearest neighbor indices\n                of pivots.\n        \"\"\"", "\n", "\n", "assert", "sorted_dist_inds", ".", "ndim", "==", "2", "\n", "assert", "(", "sorted_dist_inds", ".", "shape", "[", "0", "]", "==", "sorted_dist_inds", ".", "shape", "[", "1", "]", "==", "\n", "gt_comp_labels", ".", "shape", "[", "0", "]", ")", "\n", "\n", "knn_graph", "=", "sorted_dist_inds", "[", ":", ",", "1", ":", "self", ".", "k_at_hops", "[", "0", "]", "+", "1", "]", "\n", "pivot_local_graphs", "=", "[", "]", "\n", "pivot_knns", "=", "[", "]", "\n", "for", "pivot_ind", ",", "knn", "in", "enumerate", "(", "knn_graph", ")", ":", "\n", "\n", "            ", "local_graph_neighbors", "=", "set", "(", "knn", ")", "\n", "\n", "for", "neighbor_ind", "in", "knn", ":", "\n", "                ", "local_graph_neighbors", ".", "update", "(", "\n", "set", "(", "sorted_dist_inds", "[", "neighbor_ind", ",", "\n", "1", ":", "self", ".", "k_at_hops", "[", "1", "]", "+", "1", "]", ")", ")", "\n", "\n", "", "local_graph_neighbors", ".", "discard", "(", "pivot_ind", ")", "\n", "pivot_local_graph", "=", "list", "(", "local_graph_neighbors", ")", "\n", "pivot_local_graph", ".", "insert", "(", "0", ",", "pivot_ind", ")", "\n", "pivot_knn", "=", "[", "pivot_ind", "]", "+", "list", "(", "knn", ")", "\n", "\n", "if", "pivot_ind", "<", "1", ":", "\n", "                ", "pivot_local_graphs", ".", "append", "(", "pivot_local_graph", ")", "\n", "pivot_knns", ".", "append", "(", "pivot_knn", ")", "\n", "", "else", ":", "\n", "                ", "add_flag", "=", "True", "\n", "for", "graph_ind", ",", "added_knn", "in", "enumerate", "(", "pivot_knns", ")", ":", "\n", "                    ", "added_pivot_ind", "=", "added_knn", "[", "0", "]", "\n", "added_local_graph", "=", "pivot_local_graphs", "[", "graph_ind", "]", "\n", "\n", "union", "=", "len", "(", "\n", "set", "(", "pivot_local_graph", "[", "1", ":", "]", ")", ".", "union", "(", "\n", "set", "(", "added_local_graph", "[", "1", ":", "]", ")", ")", ")", "\n", "intersect", "=", "len", "(", "\n", "set", "(", "pivot_local_graph", "[", "1", ":", "]", ")", ".", "intersection", "(", "\n", "set", "(", "added_local_graph", "[", "1", ":", "]", ")", ")", ")", "\n", "local_graph_iou", "=", "intersect", "/", "(", "union", "+", "1e-8", ")", "\n", "\n", "if", "(", "local_graph_iou", ">", "self", ".", "local_graph_thr", "\n", "and", "pivot_ind", "in", "added_knn", "\n", "and", "gt_comp_labels", "[", "added_pivot_ind", "]", "\n", "==", "gt_comp_labels", "[", "pivot_ind", "]", "\n", "and", "gt_comp_labels", "[", "pivot_ind", "]", "!=", "0", ")", ":", "\n", "                        ", "add_flag", "=", "False", "\n", "break", "\n", "", "", "if", "add_flag", ":", "\n", "                    ", "pivot_local_graphs", ".", "append", "(", "pivot_local_graph", ")", "\n", "pivot_knns", ".", "append", "(", "pivot_knn", ")", "\n", "\n", "", "", "", "return", "pivot_local_graphs", ",", "pivot_knns", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.generate_gcn_input": [[115, 222], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "max", "enumerate", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "enumerate", "len", "len", "torch.tensor", "numpy.zeros", "utils.normalize_adjacent_matrix", "torch.zeros", "torch.from_numpy", "torch.cat", "torch.from_numpy", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "enumerate", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.normalize_adjacent_matrix"], ["", "def", "generate_gcn_input", "(", "self", ",", "node_feat_batch", ",", "node_label_batch", ",", "\n", "local_graph_batch", ",", "knn_batch", ",", "\n", "sorted_dist_ind_batch", ")", ":", "\n", "        ", "\"\"\"Generate graph convolution network input data.\n\n        Args:\n            node_feat_batch (List[Tensor]): The batched graph node features.\n            node_label_batch (List[ndarray]): The batched text component\n                labels.\n            local_graph_batch (List[List[list[int]]]): The local graph node\n                indices of image batch.\n            knn_batch (List[List[list[int]]]): The knn graph node indices of\n                image batch.\n            sorted_dist_ind_batch (list[ndarray]): The node indices sorted\n                according to the Euclidean distance.\n\n        Returns:\n            local_graphs_node_feat (Tensor): The node features of graph.\n            adjacent_matrices (Tensor): The adjacent matrices of local graphs.\n            pivots_knn_inds (Tensor): The k-nearest neighbor indices in\n                local graph.\n            gt_linkage (Tensor): The surpervision signal of GCN for linkage\n                prediction.\n        \"\"\"", "\n", "assert", "isinstance", "(", "node_feat_batch", ",", "list", ")", "\n", "assert", "isinstance", "(", "node_label_batch", ",", "list", ")", "\n", "assert", "isinstance", "(", "local_graph_batch", ",", "list", ")", "\n", "assert", "isinstance", "(", "knn_batch", ",", "list", ")", "\n", "assert", "isinstance", "(", "sorted_dist_ind_batch", ",", "list", ")", "\n", "\n", "num_max_nodes", "=", "max", "(", "[", "\n", "len", "(", "pivot_local_graph", ")", "for", "pivot_local_graphs", "in", "local_graph_batch", "\n", "for", "pivot_local_graph", "in", "pivot_local_graphs", "\n", "]", ")", "\n", "\n", "local_graphs_node_feat", "=", "[", "]", "\n", "adjacent_matrices", "=", "[", "]", "\n", "pivots_knn_inds", "=", "[", "]", "\n", "pivots_gt_linkage", "=", "[", "]", "\n", "\n", "for", "batch_ind", ",", "sorted_dist_inds", "in", "enumerate", "(", "sorted_dist_ind_batch", ")", ":", "\n", "            ", "node_feats", "=", "node_feat_batch", "[", "batch_ind", "]", "\n", "pivot_local_graphs", "=", "local_graph_batch", "[", "batch_ind", "]", "\n", "pivot_knns", "=", "knn_batch", "[", "batch_ind", "]", "\n", "node_labels", "=", "node_label_batch", "[", "batch_ind", "]", "\n", "device", "=", "node_feats", ".", "device", "\n", "\n", "for", "graph_ind", ",", "pivot_knn", "in", "enumerate", "(", "pivot_knns", ")", ":", "\n", "                ", "pivot_local_graph", "=", "pivot_local_graphs", "[", "graph_ind", "]", "\n", "num_nodes", "=", "len", "(", "pivot_local_graph", ")", "\n", "pivot_ind", "=", "pivot_local_graph", "[", "0", "]", "\n", "node2ind_map", "=", "{", "j", ":", "i", "for", "i", ",", "j", "in", "enumerate", "(", "pivot_local_graph", ")", "}", "\n", "\n", "knn_inds", "=", "torch", ".", "tensor", "(", "\n", "[", "node2ind_map", "[", "i", "]", "for", "i", "in", "pivot_knn", "[", "1", ":", "]", "]", ")", "\n", "pivot_feats", "=", "node_feats", "[", "pivot_ind", "]", "\n", "normalized_feats", "=", "node_feats", "[", "pivot_local_graph", "]", "-", "pivot_feats", "\n", "\n", "adjacent_matrix", "=", "np", ".", "zeros", "(", "(", "num_nodes", ",", "num_nodes", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "node", "in", "pivot_local_graph", ":", "\n", "                    ", "neighbors", "=", "sorted_dist_inds", "[", "node", ",", "\n", "1", ":", "self", ".", "num_adjacent_linkages", "+", "\n", "1", "]", "\n", "for", "neighbor", "in", "neighbors", ":", "\n", "                        ", "if", "neighbor", "in", "pivot_local_graph", ":", "\n", "\n", "                            ", "adjacent_matrix", "[", "node2ind_map", "[", "node", "]", ",", "\n", "node2ind_map", "[", "neighbor", "]", "]", "=", "1", "\n", "adjacent_matrix", "[", "node2ind_map", "[", "neighbor", "]", ",", "\n", "node2ind_map", "[", "node", "]", "]", "=", "1", "\n", "\n", "", "", "", "adjacent_matrix", "=", "normalize_adjacent_matrix", "(", "adjacent_matrix", ")", "\n", "pad_adjacent_matrix", "=", "torch", ".", "zeros", "(", "\n", "(", "num_max_nodes", ",", "num_max_nodes", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ",", "\n", "device", "=", "device", ")", "\n", "pad_adjacent_matrix", "[", ":", "num_nodes", ",", ":", "num_nodes", "]", "=", "torch", ".", "from_numpy", "(", "\n", "adjacent_matrix", ")", "\n", "\n", "pad_normalized_feats", "=", "torch", ".", "cat", "(", "[", "\n", "normalized_feats", ",", "\n", "torch", ".", "zeros", "(", "\n", "(", "num_max_nodes", "-", "num_nodes", ",", "normalized_feats", ".", "shape", "[", "1", "]", ")", ",", "\n", "dtype", "=", "torch", ".", "float", ",", "\n", "device", "=", "device", ")", "\n", "]", ",", "\n", "dim", "=", "0", ")", "\n", "\n", "local_graph_labels", "=", "node_labels", "[", "pivot_local_graph", "]", "\n", "knn_labels", "=", "local_graph_labels", "[", "knn_inds", "]", "\n", "link_labels", "=", "(", "(", "node_labels", "[", "pivot_ind", "]", "==", "knn_labels", ")", "&", "\n", "(", "node_labels", "[", "pivot_ind", "]", ">", "0", ")", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "link_labels", "=", "torch", ".", "from_numpy", "(", "link_labels", ")", "\n", "\n", "local_graphs_node_feat", ".", "append", "(", "pad_normalized_feats", ")", "\n", "adjacent_matrices", ".", "append", "(", "pad_adjacent_matrix", ")", "\n", "pivots_knn_inds", ".", "append", "(", "knn_inds", ")", "\n", "pivots_gt_linkage", ".", "append", "(", "link_labels", ")", "\n", "\n", "", "", "local_graphs_node_feat", "=", "torch", ".", "stack", "(", "local_graphs_node_feat", ",", "0", ")", "\n", "adjacent_matrices", "=", "torch", ".", "stack", "(", "adjacent_matrices", ",", "0", ")", "\n", "pivots_knn_inds", "=", "torch", ".", "stack", "(", "pivots_knn_inds", ",", "0", ")", "\n", "pivots_gt_linkage", "=", "torch", ".", "stack", "(", "pivots_gt_linkage", ",", "0", ")", "\n", "\n", "return", "(", "local_graphs_node_feat", ",", "adjacent_matrices", ",", "pivots_knn_inds", ",", "\n", "pivots_gt_linkage", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.__call__": [[223, 298], ["isinstance", "range", "local_graph.LocalGraphs.generate_gcn_input", "int", "comp_attribs[].astype", "utils.euclidean_distance_matrix", "numpy.clip", "angle.reshape.reshape.reshape", "numpy.hstack", "torch.from_numpy().to", "local_graph.LocalGraphs.pooling", "content_feats.view().to.view().to.view().to", "utils.feature_embedding", "torch.from_numpy().to", "torch.cat", "numpy.argsort", "local_graph.LocalGraphs.generate_local_graphs", "node_feat_batch.append", "node_label_batch.append", "local_graph_batch.append", "knn_batch.append", "sorted_dist_inds_batch.append", "numpy.zeros", "numpy.arccos", "numpy.sign", "feat_maps[].unsqueeze", "torch.from_numpy", "content_feats.view().to.view().to.view", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.generate_gcn_input", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.euclidean_distance_matrix", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.feature_embedding", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.local_graph.LocalGraphs.generate_local_graphs"], ["", "def", "__call__", "(", "self", ",", "feat_maps", ",", "comp_attribs", ")", ":", "\n", "        ", "\"\"\"Generate local graphs as GCN input.\n\n        Args:\n            feat_maps (Tensor): The feature maps to extract the content\n                features of text components.\n            comp_attribs (ndarray): The text component attributes.\n\n        Returns:\n            local_graphs_node_feat (Tensor): The node features of graph.\n            adjacent_matrices (Tensor): The adjacent matrices of local graphs.\n            pivots_knn_inds (Tensor): The k-nearest neighbor indices in local\n                graph.\n            gt_linkage (Tensor): The surpervision signal of GCN for linkage\n                prediction.\n        \"\"\"", "\n", "\n", "assert", "isinstance", "(", "feat_maps", ",", "torch", ".", "Tensor", ")", "\n", "assert", "comp_attribs", ".", "ndim", "==", "3", "\n", "assert", "comp_attribs", ".", "shape", "[", "2", "]", "==", "8", "\n", "\n", "sorted_dist_inds_batch", "=", "[", "]", "\n", "local_graph_batch", "=", "[", "]", "\n", "knn_batch", "=", "[", "]", "\n", "node_feat_batch", "=", "[", "]", "\n", "node_label_batch", "=", "[", "]", "\n", "device", "=", "feat_maps", ".", "device", "\n", "\n", "for", "batch_ind", "in", "range", "(", "comp_attribs", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "num_comps", "=", "int", "(", "comp_attribs", "[", "batch_ind", ",", "0", ",", "0", "]", ")", "\n", "comp_geo_attribs", "=", "comp_attribs", "[", "batch_ind", ",", ":", "num_comps", ",", "1", ":", "7", "]", "\n", "node_labels", "=", "comp_attribs", "[", "batch_ind", ",", ":", "num_comps", ",", "\n", "7", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "comp_centers", "=", "comp_geo_attribs", "[", ":", ",", "0", ":", "2", "]", "\n", "distance_matrix", "=", "euclidean_distance_matrix", "(", "\n", "comp_centers", ",", "comp_centers", ")", "\n", "\n", "batch_id", "=", "np", ".", "zeros", "(", "\n", "(", "comp_geo_attribs", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "*", "batch_ind", "\n", "comp_geo_attribs", "[", ":", ",", "-", "2", "]", "=", "np", ".", "clip", "(", "comp_geo_attribs", "[", ":", ",", "-", "2", "]", ",", "-", "1", ",", "1", ")", "\n", "angle", "=", "np", ".", "arccos", "(", "comp_geo_attribs", "[", ":", ",", "-", "2", "]", ")", "*", "np", ".", "sign", "(", "\n", "comp_geo_attribs", "[", ":", ",", "-", "1", "]", ")", "\n", "angle", "=", "angle", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "rotated_rois", "=", "np", ".", "hstack", "(", "\n", "[", "batch_id", ",", "comp_geo_attribs", "[", ":", ",", ":", "-", "2", "]", ",", "angle", "]", ")", "\n", "rois", "=", "torch", ".", "from_numpy", "(", "rotated_rois", ")", ".", "to", "(", "device", ")", "\n", "content_feats", "=", "self", ".", "pooling", "(", "feat_maps", "[", "batch_ind", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "rois", ")", "\n", "\n", "content_feats", "=", "content_feats", ".", "view", "(", "content_feats", ".", "shape", "[", "0", "]", ",", "\n", "-", "1", ")", ".", "to", "(", "feat_maps", ".", "device", ")", "\n", "geo_feats", "=", "feature_embedding", "(", "comp_geo_attribs", ",", "\n", "self", ".", "node_geo_feat_dim", ")", "\n", "geo_feats", "=", "torch", ".", "from_numpy", "(", "geo_feats", ")", ".", "to", "(", "device", ")", "\n", "node_feats", "=", "torch", ".", "cat", "(", "[", "content_feats", ",", "geo_feats", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "sorted_dist_inds", "=", "np", ".", "argsort", "(", "distance_matrix", ",", "axis", "=", "1", ")", "\n", "pivot_local_graphs", ",", "pivot_knns", "=", "self", ".", "generate_local_graphs", "(", "\n", "sorted_dist_inds", ",", "node_labels", ")", "\n", "\n", "node_feat_batch", ".", "append", "(", "node_feats", ")", "\n", "node_label_batch", ".", "append", "(", "node_labels", ")", "\n", "local_graph_batch", ".", "append", "(", "pivot_local_graphs", ")", "\n", "knn_batch", ".", "append", "(", "pivot_knns", ")", "\n", "sorted_dist_inds_batch", ".", "append", "(", "sorted_dist_inds", ")", "\n", "\n", "", "(", "node_feats", ",", "adjacent_matrices", ",", "knn_inds", ",", "gt_linkage", ")", "=", "self", ".", "generate_gcn_input", "(", "node_feat_batch", ",", "\n", "node_label_batch", ",", "\n", "local_graph_batch", ",", "\n", "knn_batch", ",", "\n", "sorted_dist_inds_batch", ")", "\n", "\n", "return", "node_feats", ",", "adjacent_matrices", ",", "knn_inds", ",", "gt_linkage", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.normalize_adjacent_matrix": [[5, 26], ["numpy.sum", "numpy.clip", "numpy.power().flatten", "numpy.diag", "A.dot().transpose().dot", "numpy.eye", "numpy.power", "numpy.isinf", "A.dot().transpose", "A.dot"], "function", ["None"], ["import", "mmcv", "\n", "import", "numpy", "as", "np", "\n", "import", "torch", "\n", "from", "mmdet", ".", "datasets", "import", "replace_ImageToTensor", "\n", "\n", "from", "mmocr", ".", "utils", "import", "is_2dlist", ",", "is_type_list", "\n", "\n", "\n", "def", "update_pipeline", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "pipeline", "is", "not", "None", ":", "\n", "            ", "cfg", ".", "pipeline", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", ")", "\n", "", "", "else", ":", "\n", "        ", "cfg", ".", "pipeline", "[", "idx", "]", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", "[", "idx", "]", ")", "\n", "\n", "\n", "", "", "def", "replace_image_to_tensor", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Replace 'ImageToTensor' to 'DefaultFormatBundle'.\"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.euclidean_distance_matrix": [[28, 53], ["numpy.less", "numpy.sqrt", "numpy.ones", "numpy.ones", "A.dot"], "function", ["None"], ["for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n", "                ", "update_pipeline", "(", "dataset", ")", "\n", "\n", "", "", "", "return", "cfg", "\n", "\n", "\n", "", "def", "update_pipeline_recog", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "warning_msg", "=", "'Remove \"MultiRotateAugOCR\" to support batch '", "+", "'inference since samples_per_gpu > 1.'", "\n", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "get", "(", "'pipeline'", ",", "\n", "None", ")", "and", "cfg", ".", "pipeline", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.feature_embedding": [[55, 108], ["isinstance", "numpy.array().reshape", "numpy.repeat", "numpy.hstack", "numpy.expand_dims", "numpy.concatenate", "numpy.sin", "numpy.cos", "numpy.array().reshape", "numpy.repeat", "numpy.sin", "numpy.cos", "numpy.transpose().reshape().astype", "numpy.expand_dims", "numpy.transpose().reshape", "numpy.expand_dims", "numpy.array", "numpy.zeros", "numpy.array", "numpy.transpose().reshape", "numpy.transpose", "numpy.power", "numpy.power", "numpy.transpose", "range", "range"], "function", ["None"], ["", "", "else", ":", "\n", "        ", "if", "cfg", "[", "idx", "]", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", "[", "idx", "]", "=", "[", "cfg", "[", "idx", "]", "[", "0", "]", ",", "*", "cfg", "[", "idx", "]", "[", "1", "]", ".", "transforms", "]", "\n", "\n", "\n", "", "", "", "def", "disable_text_recog_aug_test", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Remove aug_test from test pipeline for text recognition.\n\n    Args:\n        cfg (mmcv.Config): Input config.\n        set_types (list[str]): Type of dataset source. Should be\n            None or sublist of ['test', 'val'].\n    \"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "warnings", ".", "simplefilter", "(", "'once'", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "dataset_type", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "type", "\n", "if", "dataset_type", "not", "in", "[", "\n", "'ConcatDataset'", ",", "'UniformConcatDataset'", ",", "'OCRDataset'", ",", "\n", "'OCRSegDataset'", "\n", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ".", "pipeline", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline_recog", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n", "                ", "update_pipeline_recog", "(", "dataset", ")", "\n", "\n", "", "", "", "return", "cfg", "\n", "\n", "\n", "", "def", "tensor2grayimgs", "(", "tensor", ",", "mean", "=", "(", "127", ",", ")", ",", "std", "=", "(", "127", ",", ")", ",", "**", "kwargs", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.ScaledDotProductAttention.__init__": [[19, 23], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "temperature", ",", "attn_dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "attn_dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.ScaledDotProductAttention.forward": [[24, 35], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "transformer_module.ScaledDotProductAttention.dropout", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "k.transpose", "attn.masked_fill.masked_fill.masked_fill", "torch.softmax", "torch.softmax", "torch.softmax", "float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "k", ",", "v", ",", "mask", "=", "None", ")", ":", "\n", "\n", "        ", "attn", "=", "torch", ".", "matmul", "(", "q", "/", "self", ".", "temperature", ",", "k", ".", "transpose", "(", "2", ",", "3", ")", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "attn", "=", "attn", ".", "masked_fill", "(", "mask", "==", "0", ",", "float", "(", "'-inf'", ")", ")", "\n", "\n", "", "attn", "=", "self", ".", "dropout", "(", "F", ".", "softmax", "(", "attn", ",", "dim", "=", "-", "1", ")", ")", "\n", "output", "=", "torch", ".", "matmul", "(", "attn", ",", "v", ")", "\n", "\n", "return", "output", ",", "attn", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.MultiHeadAttention.__init__": [[51, 74], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "transformer_module.ScaledDotProductAttention", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_head", "=", "8", ",", "\n", "d_model", "=", "512", ",", "\n", "d_k", "=", "64", ",", "\n", "d_v", "=", "64", ",", "\n", "dropout", "=", "0.1", ",", "\n", "qkv_bias", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_head", "=", "n_head", "\n", "self", ".", "d_k", "=", "d_k", "\n", "self", ".", "d_v", "=", "d_v", "\n", "\n", "self", ".", "dim_k", "=", "n_head", "*", "d_k", "\n", "self", ".", "dim_v", "=", "n_head", "*", "d_v", "\n", "\n", "self", ".", "linear_q", "=", "nn", ".", "Linear", "(", "self", ".", "dim_k", ",", "self", ".", "dim_k", ",", "bias", "=", "qkv_bias", ")", "\n", "self", ".", "linear_k", "=", "nn", ".", "Linear", "(", "self", ".", "dim_k", ",", "self", ".", "dim_k", ",", "bias", "=", "qkv_bias", ")", "\n", "self", ".", "linear_v", "=", "nn", ".", "Linear", "(", "self", ".", "dim_v", ",", "self", ".", "dim_v", ",", "bias", "=", "qkv_bias", ")", "\n", "\n", "self", ".", "attention", "=", "ScaledDotProductAttention", "(", "d_k", "**", "0.5", ",", "dropout", ")", "\n", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "self", ".", "dim_v", ",", "d_model", ",", "bias", "=", "qkv_bias", ")", "\n", "self", ".", "proj_drop", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.MultiHeadAttention.forward": [[75, 100], ["transformer_module.MultiHeadAttention.size", "transformer_module.MultiHeadAttention.size", "transformer_module.MultiHeadAttention.linear_q().view", "transformer_module.MultiHeadAttention.linear_k().view", "transformer_module.MultiHeadAttention.linear_v().view", "transformer_module.MultiHeadAttention.attention", "transformer_module.MultiHeadAttention.transpose().contiguous().view", "transformer_module.MultiHeadAttention.fc", "transformer_module.MultiHeadAttention.proj_drop", "transformer_module.MultiHeadAttention.transpose", "transformer_module.MultiHeadAttention.transpose", "transformer_module.MultiHeadAttention.transpose", "transformer_module.MultiHeadAttention.linear_q", "transformer_module.MultiHeadAttention.linear_k", "transformer_module.MultiHeadAttention.linear_v", "mask.unsqueeze().unsqueeze.unsqueeze().unsqueeze.dim", "mask.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze", "transformer_module.MultiHeadAttention.transpose().contiguous", "mask.unsqueeze().unsqueeze.unsqueeze().unsqueeze.dim", "mask.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze().unsqueeze", "transformer_module.MultiHeadAttention.transpose", "mask.unsqueeze().unsqueeze.unsqueeze().unsqueeze.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "k", ",", "v", ",", "mask", "=", "None", ")", ":", "\n", "        ", "batch_size", ",", "len_q", ",", "_", "=", "q", ".", "size", "(", ")", "\n", "_", ",", "len_k", ",", "_", "=", "k", ".", "size", "(", ")", "\n", "\n", "q", "=", "self", ".", "linear_q", "(", "q", ")", ".", "view", "(", "batch_size", ",", "len_q", ",", "self", ".", "n_head", ",", "self", ".", "d_k", ")", "\n", "k", "=", "self", ".", "linear_k", "(", "k", ")", ".", "view", "(", "batch_size", ",", "len_k", ",", "self", ".", "n_head", ",", "self", ".", "d_k", ")", "\n", "v", "=", "self", ".", "linear_v", "(", "v", ")", ".", "view", "(", "batch_size", ",", "len_k", ",", "self", ".", "n_head", ",", "self", ".", "d_v", ")", "\n", "\n", "q", ",", "k", ",", "v", "=", "q", ".", "transpose", "(", "1", ",", "2", ")", ",", "k", ".", "transpose", "(", "1", ",", "2", ")", ",", "v", ".", "transpose", "(", "1", ",", "2", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "if", "mask", ".", "dim", "(", ")", "==", "3", ":", "\n", "                ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", "\n", "", "elif", "mask", ".", "dim", "(", ")", "==", "2", ":", "\n", "                ", "mask", "=", "mask", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "", "attn_out", ",", "_", "=", "self", ".", "attention", "(", "q", ",", "k", ",", "v", ",", "mask", "=", "mask", ")", "\n", "\n", "attn_out", "=", "attn_out", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "batch_size", ",", "len_q", ",", "self", ".", "dim_v", ")", "\n", "\n", "attn_out", "=", "self", ".", "fc", "(", "attn_out", ")", "\n", "attn_out", "=", "self", ".", "proj_drop", "(", "attn_out", ")", "\n", "\n", "return", "attn_out", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionwiseFeedForward.__init__": [[114, 120], ["dict", "torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "mmocr.models.builder.build_activation_layer", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_activation_layer"], ["def", "__init__", "(", "self", ",", "d_in", ",", "d_hid", ",", "dropout", "=", "0.1", ",", "act_cfg", "=", "dict", "(", "type", "=", "'Relu'", ")", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "w_1", "=", "nn", ".", "Linear", "(", "d_in", ",", "d_hid", ")", "\n", "self", ".", "w_2", "=", "nn", ".", "Linear", "(", "d_hid", ",", "d_in", ")", "\n", "self", ".", "act", "=", "build_activation_layer", "(", "act_cfg", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionwiseFeedForward.forward": [[121, 128], ["transformer_module.PositionwiseFeedForward.w_1", "transformer_module.PositionwiseFeedForward.act", "transformer_module.PositionwiseFeedForward.w_2", "transformer_module.PositionwiseFeedForward.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "w_1", "(", "x", ")", "\n", "x", "=", "self", ".", "act", "(", "x", ")", "\n", "x", "=", "self", ".", "w_2", "(", "x", ")", "\n", "x", "=", "self", ".", "dropout", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionalEncoding.__init__": [[133, 142], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "torch.Dropout", "transformer_module.PositionalEncoding.register_buffer", "transformer_module.PositionalEncoding._get_sinusoid_encoding_table"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionalEncoding._get_sinusoid_encoding_table"], ["def", "__init__", "(", "self", ",", "d_hid", "=", "512", ",", "n_position", "=", "200", ",", "dropout", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "\n", "# Not a parameter", "\n", "# Position table of shape (1, n_position, d_hid)", "\n", "self", ".", "register_buffer", "(", "\n", "'position_table'", ",", "\n", "self", ".", "_get_sinusoid_encoding_table", "(", "n_position", ",", "d_hid", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionalEncoding._get_sinusoid_encoding_table": [[143, 156], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "denominator.view.view.view", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.arange().unsqueeze().float", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "torch.cos", "sinusoid_table.unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "numpy.power", "range", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "_get_sinusoid_encoding_table", "(", "self", ",", "n_position", ",", "d_hid", ")", ":", "\n", "        ", "\"\"\"Sinusoid position encoding table.\"\"\"", "\n", "denominator", "=", "torch", ".", "Tensor", "(", "[", "\n", "1.0", "/", "np", ".", "power", "(", "10000", ",", "2", "*", "(", "hid_j", "//", "2", ")", "/", "d_hid", ")", "\n", "for", "hid_j", "in", "range", "(", "d_hid", ")", "\n", "]", ")", "\n", "denominator", "=", "denominator", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "pos_tensor", "=", "torch", ".", "arange", "(", "n_position", ")", ".", "unsqueeze", "(", "-", "1", ")", ".", "float", "(", ")", "\n", "sinusoid_table", "=", "pos_tensor", "*", "denominator", "\n", "sinusoid_table", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "sinusoid_table", "[", ":", ",", "0", ":", ":", "2", "]", ")", "\n", "sinusoid_table", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "sinusoid_table", "[", ":", ",", "1", ":", ":", "2", "]", ")", "\n", "\n", "return", "sinusoid_table", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.transformer_module.PositionalEncoding.forward": [[157, 165], ["transformer_module.PositionalEncoding.dropout", "transformer_module.PositionalEncoding.position_table[].clone().detach", "transformer_module.PositionalEncoding.position_table[].clone", "x.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (Tensor): Tensor of shape (batch_size, pos_len, d_hid, ...)\n        \"\"\"", "\n", "self", ".", "device", "=", "x", ".", "device", "\n", "x", "=", "x", "+", "self", ".", "position_table", "[", ":", ",", ":", "x", ".", "size", "(", "1", ")", "]", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "return", "self", ".", "dropout", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.__init__": [[47, 150], ["dict", "dict", "dict", "mmcv.runner.BaseModule.__init__", "head_mixin.HeadMixin.__init__", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "mmocr.models.builder.build_loss", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "mmocr.models.textdet.modules.LocalGraphs", "mmocr.models.textdet.modules.ProposalLocalGraphs", "mmocr.models.textdet.modules.GCN", "kwargs.get", "dict", "kwargs.get", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "k_at_hops", "=", "(", "8", ",", "4", ")", ",", "\n", "num_adjacent_linkages", "=", "3", ",", "\n", "node_geo_feat_len", "=", "120", ",", "\n", "pooling_scale", "=", "1.0", ",", "\n", "pooling_output_size", "=", "(", "4", ",", "3", ")", ",", "\n", "nms_thr", "=", "0.3", ",", "\n", "min_width", "=", "8.0", ",", "\n", "max_width", "=", "24.0", ",", "\n", "comp_shrink_ratio", "=", "1.03", ",", "\n", "comp_ratio", "=", "0.4", ",", "\n", "comp_score_thr", "=", "0.3", ",", "\n", "text_region_thr", "=", "0.2", ",", "\n", "center_region_thr", "=", "0.2", ",", "\n", "center_region_area_thr", "=", "50", ",", "\n", "local_graph_thr", "=", "0.7", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'DRRGLoss'", ")", ",", "\n", "postprocessor", "=", "dict", "(", "type", "=", "'DRRGPostprocessor'", ",", "link_thr", "=", "0.85", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Normal'", ",", "\n", "override", "=", "dict", "(", "name", "=", "'out_conv'", ")", ",", "\n", "mean", "=", "0", ",", "\n", "std", "=", "0.01", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "old_keys", "=", "[", "'text_repr_type'", ",", "'decoding_type'", ",", "'link_thr'", "]", "\n", "for", "key", "in", "old_keys", ":", "\n", "            ", "if", "kwargs", ".", "get", "(", "key", ",", "None", ")", ":", "\n", "                ", "postprocessor", "[", "key", "]", "=", "kwargs", ".", "get", "(", "key", ")", "\n", "warnings", ".", "warn", "(", "\n", "f'{key} is deprecated, please specify '", "\n", "'it in postprocessor config dict. See '", "\n", "'https://github.com/open-mmlab/mmocr/pull/640'", "\n", "' for details.'", ",", "UserWarning", ")", "\n", "", "", "BaseModule", ".", "__init__", "(", "self", ",", "init_cfg", "=", "init_cfg", ")", "\n", "HeadMixin", ".", "__init__", "(", "self", ",", "loss", ",", "postprocessor", ")", "\n", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "assert", "isinstance", "(", "k_at_hops", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "num_adjacent_linkages", ",", "int", ")", "\n", "assert", "isinstance", "(", "node_geo_feat_len", ",", "int", ")", "\n", "assert", "isinstance", "(", "pooling_scale", ",", "float", ")", "\n", "assert", "isinstance", "(", "pooling_output_size", ",", "tuple", ")", "\n", "assert", "isinstance", "(", "comp_shrink_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "nms_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "min_width", ",", "float", ")", "\n", "assert", "isinstance", "(", "max_width", ",", "float", ")", "\n", "assert", "isinstance", "(", "comp_ratio", ",", "float", ")", "\n", "assert", "isinstance", "(", "comp_score_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "text_region_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "center_region_thr", ",", "float", ")", "\n", "assert", "isinstance", "(", "center_region_area_thr", ",", "int", ")", "\n", "assert", "isinstance", "(", "local_graph_thr", ",", "float", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "6", "\n", "self", ".", "downsample_ratio", "=", "1.0", "\n", "self", ".", "k_at_hops", "=", "k_at_hops", "\n", "self", ".", "num_adjacent_linkages", "=", "num_adjacent_linkages", "\n", "self", ".", "node_geo_feat_len", "=", "node_geo_feat_len", "\n", "self", ".", "pooling_scale", "=", "pooling_scale", "\n", "self", ".", "pooling_output_size", "=", "pooling_output_size", "\n", "self", ".", "comp_shrink_ratio", "=", "comp_shrink_ratio", "\n", "self", ".", "nms_thr", "=", "nms_thr", "\n", "self", ".", "min_width", "=", "min_width", "\n", "self", ".", "max_width", "=", "max_width", "\n", "self", ".", "comp_ratio", "=", "comp_ratio", "\n", "self", ".", "comp_score_thr", "=", "comp_score_thr", "\n", "self", ".", "text_region_thr", "=", "text_region_thr", "\n", "self", ".", "center_region_thr", "=", "center_region_thr", "\n", "self", ".", "center_region_area_thr", "=", "center_region_area_thr", "\n", "self", ".", "local_graph_thr", "=", "local_graph_thr", "\n", "self", ".", "loss_module", "=", "build_loss", "(", "loss", ")", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n", "self", ".", "out_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ")", "\n", "\n", "self", ".", "graph_train", "=", "LocalGraphs", "(", "self", ".", "k_at_hops", ",", "\n", "self", ".", "num_adjacent_linkages", ",", "\n", "self", ".", "node_geo_feat_len", ",", "\n", "self", ".", "pooling_scale", ",", "\n", "self", ".", "pooling_output_size", ",", "\n", "self", ".", "local_graph_thr", ")", "\n", "\n", "self", ".", "graph_test", "=", "ProposalLocalGraphs", "(", "\n", "self", ".", "k_at_hops", ",", "self", ".", "num_adjacent_linkages", ",", "self", ".", "node_geo_feat_len", ",", "\n", "self", ".", "pooling_scale", ",", "self", ".", "pooling_output_size", ",", "self", ".", "nms_thr", ",", "\n", "self", ".", "min_width", ",", "self", ".", "max_width", ",", "self", ".", "comp_shrink_ratio", ",", "\n", "self", ".", "comp_ratio", ",", "self", ".", "comp_score_thr", ",", "self", ".", "text_region_thr", ",", "\n", "self", ".", "center_region_thr", ",", "self", ".", "center_region_area_thr", ")", "\n", "\n", "pool_w", ",", "pool_h", "=", "self", ".", "pooling_output_size", "\n", "node_feat_len", "=", "(", "pool_w", "*", "pool_h", ")", "*", "(", "\n", "self", ".", "in_channels", "+", "self", ".", "out_channels", ")", "+", "self", ".", "node_geo_feat_len", "\n", "self", ".", "gcn", "=", "GCN", "(", "node_feat_len", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.forward": [[151, 176], ["drrg_head.DRRGHead.out_conv", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "drrg_head.DRRGHead.graph_train", "drrg_head.DRRGHead.gcn", "numpy.stack"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "gt_comp_attribs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (Tensor): Shape of :math:`(N, C, H, W)`.\n            gt_comp_attribs (list[ndarray]): The padded text component\n                attributes. Shape: (num_component, 8).\n\n        Returns:\n            tuple: Returns (pred_maps, (gcn_pred, gt_labels)).\n\n                - | pred_maps (Tensor): Prediction map with shape\n                    :math:`(N, C_{out}, H, W)`.\n                - | gcn_pred (Tensor): Prediction from GCN module, with\n                    shape :math:`(N, 2)`.\n                - | gt_labels (Tensor): Ground-truth label with shape\n                    :math:`(N, 8)`.\n        \"\"\"", "\n", "pred_maps", "=", "self", ".", "out_conv", "(", "inputs", ")", "\n", "feat_maps", "=", "torch", ".", "cat", "(", "[", "inputs", ",", "pred_maps", "]", ",", "dim", "=", "1", ")", "\n", "node_feats", ",", "adjacent_matrices", ",", "knn_inds", ",", "gt_labels", "=", "self", ".", "graph_train", "(", "\n", "feat_maps", ",", "np", ".", "stack", "(", "gt_comp_attribs", ")", ")", "\n", "\n", "gcn_pred", "=", "self", ".", "gcn", "(", "node_feats", ",", "adjacent_matrices", ",", "knn_inds", ")", "\n", "\n", "return", "pred_maps", ",", "(", "gcn_pred", ",", "gt_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.single_test": [[177, 226], ["drrg_head.DRRGHead.out_conv", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "drrg_head.DRRGHead.graph_test", "drrg_head.DRRGHead.gcn", "torch.softmax", "torch.softmax", "torch.softmax", "pivot_local_graphs.long().squeeze().cpu().numpy.long().squeeze().cpu().numpy.long().squeeze().cpu().numpy", "enumerate", "numpy.asarray", "numpy.asarray", "enumerate", "pivot_local_graphs.long().squeeze().cpu().numpy.long().squeeze().cpu().numpy.long().squeeze().cpu", "numpy.asarray.append", "numpy.asarray.append", "pred_labels[].item", "pivot_local_graphs.long().squeeze().cpu().numpy.long().squeeze().cpu().numpy.long().squeeze", "neighbor_ind.item", "pivot_local_graphs.long().squeeze().cpu().numpy.long().squeeze().cpu().numpy.long"], "methods", ["None"], ["", "def", "single_test", "(", "self", ",", "feat_maps", ")", ":", "\n", "        ", "r\"\"\"\n        Args:\n            feat_maps (Tensor): Shape of :math:`(N, C, H, W)`.\n\n        Returns:\n            tuple: Returns (edge, score, text_comps).\n\n                - | edge (ndarray): The edge array of shape :math:`(N, 2)`\n                    where each row is a pair of text component indices\n                    that makes up an edge in graph.\n                - | score (ndarray): The score array of shape :math:`(N,)`,\n                    corresponding to the edge above.\n                - | text_comps (ndarray): The text components of shape\n                    :math:`(N, 9)` where each row corresponds to one box and\n                    its score: (x1, y1, x2, y2, x3, y3, x4, y4, score).\n        \"\"\"", "\n", "pred_maps", "=", "self", ".", "out_conv", "(", "feat_maps", ")", "\n", "feat_maps", "=", "torch", ".", "cat", "(", "[", "feat_maps", ",", "pred_maps", "]", ",", "dim", "=", "1", ")", "\n", "\n", "none_flag", ",", "graph_data", "=", "self", ".", "graph_test", "(", "pred_maps", ",", "feat_maps", ")", "\n", "\n", "(", "local_graphs_node_feat", ",", "adjacent_matrices", ",", "pivots_knn_inds", ",", "\n", "pivot_local_graphs", ",", "text_comps", ")", "=", "graph_data", "\n", "\n", "if", "none_flag", ":", "\n", "            ", "return", "None", ",", "None", ",", "None", "\n", "\n", "", "gcn_pred", "=", "self", ".", "gcn", "(", "local_graphs_node_feat", ",", "adjacent_matrices", ",", "\n", "pivots_knn_inds", ")", "\n", "pred_labels", "=", "F", ".", "softmax", "(", "gcn_pred", ",", "dim", "=", "1", ")", "\n", "\n", "edges", "=", "[", "]", "\n", "scores", "=", "[", "]", "\n", "pivot_local_graphs", "=", "pivot_local_graphs", ".", "long", "(", ")", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "pivot_ind", ",", "pivot_local_graph", "in", "enumerate", "(", "pivot_local_graphs", ")", ":", "\n", "            ", "pivot", "=", "pivot_local_graph", "[", "0", "]", "\n", "for", "k_ind", ",", "neighbor_ind", "in", "enumerate", "(", "pivots_knn_inds", "[", "pivot_ind", "]", ")", ":", "\n", "                ", "neighbor", "=", "pivot_local_graph", "[", "neighbor_ind", ".", "item", "(", ")", "]", "\n", "edges", ".", "append", "(", "[", "pivot", ",", "neighbor", "]", ")", "\n", "scores", ".", "append", "(", "\n", "pred_labels", "[", "pivot_ind", "*", "pivots_knn_inds", ".", "shape", "[", "1", "]", "+", "k_ind", ",", "\n", "1", "]", ".", "item", "(", ")", ")", "\n", "\n", "", "", "edges", "=", "np", ".", "asarray", "(", "edges", ")", "\n", "scores", "=", "np", ".", "asarray", "(", "scores", ")", "\n", "\n", "return", "edges", ",", "scores", ",", "text_comps", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.get_boundary": [[227, 258], ["mmocr.utils.check_argument.is_type_list", "isinstance", "dict", "drrg_head.DRRGHead.postprocessor", "drrg_head.DRRGHead.resize_boundary"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.resize_boundary"], ["", "def", "get_boundary", "(", "self", ",", "edges", ",", "scores", ",", "text_comps", ",", "img_metas", ",", "rescale", ")", ":", "\n", "        ", "\"\"\"Compute text boundaries via post processing.\n\n        Args:\n            edges (ndarray): The edge array of shape N * 2, each row is a pair\n                of text component indices that makes up an edge in graph.\n            scores (ndarray): The edge score array.\n            text_comps (ndarray): The text components.\n            img_metas (list[dict]): The image meta infos.\n            rescale (bool): Rescale boundaries to the original image\n                resolution.\n\n        Returns:\n            dict: The result dict containing key `boundary_result`.\n        \"\"\"", "\n", "\n", "assert", "check_argument", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "isinstance", "(", "rescale", ",", "bool", ")", "\n", "\n", "boundaries", "=", "[", "]", "\n", "if", "edges", "is", "not", "None", ":", "\n", "            ", "boundaries", "=", "self", ".", "postprocessor", "(", "edges", ",", "scores", ",", "text_comps", ")", "\n", "\n", "", "if", "rescale", ":", "\n", "            ", "boundaries", "=", "self", ".", "resize_boundary", "(", "\n", "boundaries", ",", "\n", "1.0", "/", "self", ".", "downsample_ratio", "/", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", ")", "\n", "\n", "", "results", "=", "dict", "(", "boundary_result", "=", "boundaries", ")", "\n", "\n", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.pan_head.PANHead.__init__": [[29, 72], ["dict", "dict", "dict", "mmcv.runner.BaseModule.__init__", "head_mixin.HeadMixin.__init__", "mmocr.utils.check_argument.is_type_list", "isinstance", "torch.Conv2d", "torch.Conv2d", "kwargs.get", "dict", "kwargs.get", "warnings.warn", "numpy.sum", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "downsample_ratio", "=", "0.25", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'PANLoss'", ")", ",", "\n", "postprocessor", "=", "dict", "(", "\n", "type", "=", "'PANPostprocessor'", ",", "text_repr_type", "=", "'poly'", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Normal'", ",", "\n", "mean", "=", "0", ",", "\n", "std", "=", "0.01", ",", "\n", "override", "=", "dict", "(", "name", "=", "'out_conv'", ")", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "old_keys", "=", "[", "'text_repr_type'", ",", "'decoding_type'", "]", "\n", "for", "key", "in", "old_keys", ":", "\n", "            ", "if", "kwargs", ".", "get", "(", "key", ",", "None", ")", ":", "\n", "                ", "postprocessor", "[", "key", "]", "=", "kwargs", ".", "get", "(", "key", ")", "\n", "warnings", ".", "warn", "(", "\n", "f'{key} is deprecated, please specify '", "\n", "'it in postprocessor config dict. See '", "\n", "'https://github.com/open-mmlab/mmocr/pull/640'", "\n", "' for details.'", ",", "UserWarning", ")", "\n", "\n", "", "", "BaseModule", ".", "__init__", "(", "self", ",", "init_cfg", "=", "init_cfg", ")", "\n", "HeadMixin", ".", "__init__", "(", "self", ",", "loss", ",", "postprocessor", ")", "\n", "\n", "assert", "check_argument", ".", "is_type_list", "(", "in_channels", ",", "int", ")", "\n", "assert", "isinstance", "(", "out_channels", ",", "int", ")", "\n", "\n", "assert", "0", "<=", "downsample_ratio", "<=", "1", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "downsample_ratio", "=", "downsample_ratio", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n", "self", ".", "out_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "np", ".", "sum", "(", "np", ".", "array", "(", "in_channels", ")", ")", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "kernel_size", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.pan_head.PANHead.forward": [[73, 91], ["isinstance", "pan_head.PANHead.out_conv", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "r\"\"\"\n        Args:\n            inputs (list[Tensor] | Tensor): Each tensor has the shape of\n                :math:`(N, C_i, W, H)`, where :math:`\\sum_iC_i=C_{in}` and\n                :math:`C_{in}` is ``input_channels``.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, C_{out}, W, H)` where\n            :math:`C_{out}` is ``output_channels``.\n        \"\"\"", "\n", "if", "isinstance", "(", "inputs", ",", "tuple", ")", ":", "\n", "            ", "outputs", "=", "torch", ".", "cat", "(", "inputs", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "outputs", "=", "inputs", "\n", "", "outputs", "=", "self", ".", "out_conv", "(", "outputs", ")", "\n", "\n", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.__init__": [[18, 24], ["isinstance", "isinstance", "mmocr.models.builder.build_loss", "mmocr.models.builder.build_postprocessor"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_postprocessor"], ["def", "__init__", "(", "self", ",", "loss", ",", "postprocessor", ")", ":", "\n", "        ", "assert", "isinstance", "(", "loss", ",", "dict", ")", "\n", "assert", "isinstance", "(", "postprocessor", ",", "dict", ")", "\n", "\n", "self", ".", "loss_module", "=", "build_loss", "(", "loss", ")", "\n", "self", ".", "postprocessor", "=", "build_postprocessor", "(", "postprocessor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.resize_boundary": [[25, 48], ["mmocr.utils.check_argument.is_2dlist", "isinstance", "len", "mmocr.utils.check_argument.valid_boundary", "numpy.array", "numpy.tile().reshape", "numpy.tile", "int"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary"], ["", "def", "resize_boundary", "(", "self", ",", "boundaries", ",", "scale_factor", ")", ":", "\n", "        ", "\"\"\"Rescale boundaries via scale_factor.\n\n        Args:\n            boundaries (list[list[float]]): The boundary list. Each boundary\n                has :math:`2k+1` elements with :math:`k>=4`.\n            scale_factor (ndarray): The scale factor of size :math:`(4,)`.\n\n        Returns:\n            list[list[float]]: The scaled boundaries.\n        \"\"\"", "\n", "assert", "check_argument", ".", "is_2dlist", "(", "boundaries", ")", "\n", "assert", "isinstance", "(", "scale_factor", ",", "np", ".", "ndarray", ")", "\n", "assert", "scale_factor", ".", "shape", "[", "0", "]", "==", "4", "\n", "\n", "for", "b", "in", "boundaries", ":", "\n", "            ", "sz", "=", "len", "(", "b", ")", "\n", "check_argument", ".", "valid_boundary", "(", "b", ",", "True", ")", "\n", "b", "[", ":", "sz", "-", "\n", "1", "]", "=", "(", "np", ".", "array", "(", "b", "[", ":", "sz", "-", "1", "]", ")", "*", "\n", "(", "np", ".", "tile", "(", "scale_factor", "[", ":", "2", "]", ",", "int", "(", "\n", "(", "sz", "-", "1", ")", "/", "2", ")", ")", ".", "reshape", "(", "1", ",", "sz", "-", "1", ")", ")", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "", "return", "boundaries", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.get_boundary": [[49, 78], ["mmocr.utils.check_argument.is_type_list", "isinstance", "score_maps.squeeze.squeeze.squeeze", "head_mixin.HeadMixin.postprocessor", "dict", "head_mixin.HeadMixin.resize_boundary"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.resize_boundary"], ["", "def", "get_boundary", "(", "self", ",", "score_maps", ",", "img_metas", ",", "rescale", ")", ":", "\n", "        ", "\"\"\"Compute text boundaries via post processing.\n\n        Args:\n            score_maps (Tensor): The text score map.\n            img_metas (dict): The image meta info.\n            rescale (bool): Rescale boundaries to the original image resolution\n                if true, and keep the score_maps resolution if false.\n\n        Returns:\n            dict: A dict where boundary results are stored in\n            ``boundary_result``.\n        \"\"\"", "\n", "\n", "assert", "check_argument", ".", "is_type_list", "(", "img_metas", ",", "dict", ")", "\n", "assert", "isinstance", "(", "rescale", ",", "bool", ")", "\n", "\n", "score_maps", "=", "score_maps", ".", "squeeze", "(", ")", "\n", "boundaries", "=", "self", ".", "postprocessor", "(", "score_maps", ")", "\n", "\n", "if", "rescale", ":", "\n", "            ", "boundaries", "=", "self", ".", "resize_boundary", "(", "\n", "boundaries", ",", "\n", "1.0", "/", "self", ".", "downsample_ratio", "/", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", ")", "\n", "\n", "", "results", "=", "dict", "(", "\n", "boundary_result", "=", "boundaries", ",", "filename", "=", "img_metas", "[", "0", "]", "[", "'filename'", "]", ")", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss": [[79, 92], ["head_mixin.HeadMixin.loss_module"], "methods", ["None"], ["", "def", "loss", "(", "self", ",", "pred_maps", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Compute the loss for scene text detection.\n\n        Args:\n            pred_maps (Tensor): The input score maps of shape\n                :math:`(NxCxHxW)`.\n\n        Returns:\n            dict: The dict for losses.\n        \"\"\"", "\n", "losses", "=", "self", ".", "loss_module", "(", "pred_maps", ",", "self", ".", "downsample_ratio", ",", "**", "kwargs", ")", "\n", "\n", "return", "losses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.textsnake_head.TextSnakeHead.__init__": [[29, 69], ["dict", "dict", "dict", "mmcv.runner.BaseModule.__init__", "head_mixin.HeadMixin.__init__", "isinstance", "torch.Conv2d", "kwargs.get", "dict", "kwargs.get", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", "=", "5", ",", "\n", "downsample_ratio", "=", "1.0", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'TextSnakeLoss'", ")", ",", "\n", "postprocessor", "=", "dict", "(", "\n", "type", "=", "'TextSnakePostprocessor'", ",", "text_repr_type", "=", "'poly'", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Normal'", ",", "\n", "override", "=", "dict", "(", "name", "=", "'out_conv'", ")", ",", "\n", "mean", "=", "0", ",", "\n", "std", "=", "0.01", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "old_keys", "=", "[", "'text_repr_type'", ",", "'decoding_type'", "]", "\n", "for", "key", "in", "old_keys", ":", "\n", "            ", "if", "kwargs", ".", "get", "(", "key", ",", "None", ")", ":", "\n", "                ", "postprocessor", "[", "key", "]", "=", "kwargs", ".", "get", "(", "key", ")", "\n", "warnings", ".", "warn", "(", "\n", "f'{key} is deprecated, please specify '", "\n", "'it in postprocessor config dict. See '", "\n", "'https://github.com/open-mmlab/mmocr/pull/640 '", "\n", "'for details.'", ",", "UserWarning", ")", "\n", "", "", "BaseModule", ".", "__init__", "(", "self", ",", "init_cfg", "=", "init_cfg", ")", "\n", "HeadMixin", ".", "__init__", "(", "self", ",", "loss", ",", "postprocessor", ")", "\n", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "out_channels", "=", "out_channels", "\n", "self", ".", "downsample_ratio", "=", "downsample_ratio", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "\n", "self", ".", "out_conv", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", "=", "self", ".", "in_channels", ",", "\n", "out_channels", "=", "self", ".", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.textsnake_head.TextSnakeHead.forward": [[70, 82], ["textsnake_head.TextSnakeHead.out_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (Tensor): Shape :math:`(N, C_{in}, H, W)`, where\n                :math:`C_{in}` is ``in_channels``. :math:`H` and :math:`W`\n                should be the same as the input of backbone.\n\n        Returns:\n            Tensor: A tensor of shape :math:`(N, 5, H, W)`.\n        \"\"\"", "\n", "outputs", "=", "self", ".", "out_conv", "(", "inputs", ")", "\n", "return", "outputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.__init__": [[29, 103], ["dict", "dict", "dict", "kwargs.get", "mmcv.runner.BaseModule.__init__", "head_mixin.HeadMixin.__init__", "isinstance", "torch.Conv2d", "torch.Conv2d", "kwargs.get", "kwargs.get", "warnings.warn", "kwargs.get", "warnings.warn", "dict", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "scales", ",", "\n", "fourier_degree", "=", "5", ",", "\n", "nms_thr", "=", "0.1", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'FCELoss'", ",", "num_sample", "=", "50", ")", ",", "\n", "postprocessor", "=", "dict", "(", "\n", "type", "=", "'FCEPostprocessor'", ",", "\n", "text_repr_type", "=", "'poly'", ",", "\n", "num_reconstr_points", "=", "50", ",", "\n", "alpha", "=", "1.0", ",", "\n", "beta", "=", "2.0", ",", "\n", "score_thr", "=", "0.3", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Normal'", ",", "\n", "mean", "=", "0", ",", "\n", "std", "=", "0.01", ",", "\n", "override", "=", "[", "\n", "dict", "(", "name", "=", "'out_conv_cls'", ")", ",", "\n", "dict", "(", "name", "=", "'out_conv_reg'", ")", "\n", "]", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "old_keys", "=", "[", "\n", "'text_repr_type'", ",", "'decoding_type'", ",", "'num_reconstr_points'", ",", "'alpha'", ",", "\n", "'beta'", ",", "'score_thr'", "\n", "]", "\n", "for", "key", "in", "old_keys", ":", "\n", "            ", "if", "kwargs", ".", "get", "(", "key", ",", "None", ")", ":", "\n", "                ", "postprocessor", "[", "key", "]", "=", "kwargs", ".", "get", "(", "key", ")", "\n", "warnings", ".", "warn", "(", "\n", "f'{key} is deprecated, please specify '", "\n", "'it in postprocessor config dict. See '", "\n", "'https://github.com/open-mmlab/mmocr/pull/640'", "\n", "' for details.'", ",", "UserWarning", ")", "\n", "", "", "if", "kwargs", ".", "get", "(", "'num_sample'", ",", "None", ")", ":", "\n", "            ", "loss", "[", "'num_sample'", "]", "=", "kwargs", ".", "get", "(", "'num_sample'", ")", "\n", "warnings", ".", "warn", "(", "\n", "'num_sample is deprecated, please specify '", "\n", "'it in loss config dict. See '", "\n", "'https://github.com/open-mmlab/mmocr/pull/640'", "\n", "' for details.'", ",", "UserWarning", ")", "\n", "", "BaseModule", ".", "__init__", "(", "self", ",", "init_cfg", "=", "init_cfg", ")", "\n", "loss", "[", "'fourier_degree'", "]", "=", "fourier_degree", "\n", "postprocessor", "[", "'fourier_degree'", "]", "=", "fourier_degree", "\n", "postprocessor", "[", "'nms_thr'", "]", "=", "nms_thr", "\n", "HeadMixin", ".", "__init__", "(", "self", ",", "loss", ",", "postprocessor", ")", "\n", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "\n", "self", ".", "downsample_ratio", "=", "1.0", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "scales", "=", "scales", "\n", "self", ".", "fourier_degree", "=", "fourier_degree", "\n", "\n", "self", ".", "nms_thr", "=", "nms_thr", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "out_channels_cls", "=", "4", "\n", "self", ".", "out_channels_reg", "=", "(", "2", "*", "self", ".", "fourier_degree", "+", "1", ")", "*", "2", "\n", "\n", "self", ".", "out_conv_cls", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "out_channels_cls", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "self", ".", "out_conv_reg", "=", "nn", ".", "Conv2d", "(", "\n", "self", ".", "in_channels", ",", "\n", "self", ".", "out_channels_reg", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.forward": [[104, 120], ["mmdet.core.multi_apply", "len", "range"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "feats", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            feats (list[Tensor]): Each tensor has the shape of :math:`(N, C_i,\n                H_i, W_i)`.\n\n        Returns:\n            list[[Tensor, Tensor]]: Each pair of tensors corresponds to the\n            classification result and regression result computed from the input\n            tensor with the same index. They have the shapes of :math:`(N,\n            C_{cls,i}, H_i, W_i)` and :math:`(N, C_{out,i}, H_i, W_i)`.\n        \"\"\"", "\n", "cls_res", ",", "reg_res", "=", "multi_apply", "(", "self", ".", "forward_single", ",", "feats", ")", "\n", "level_num", "=", "len", "(", "cls_res", ")", "\n", "preds", "=", "[", "[", "cls_res", "[", "i", "]", ",", "reg_res", "[", "i", "]", "]", "for", "i", "in", "range", "(", "level_num", ")", "]", "\n", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.forward_single": [[121, 125], ["fce_head.FCEHead.out_conv_cls", "fce_head.FCEHead.out_conv_reg"], "methods", ["None"], ["", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "cls_predict", "=", "self", ".", "out_conv_cls", "(", "x", ")", "\n", "reg_predict", "=", "self", ".", "out_conv_reg", "(", "x", ")", "\n", "return", "cls_predict", ",", "reg_predict", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary": [[126, 144], ["enumerate", "postprocess.utils.poly_nms", "dict", "len", "len", "fce_head.FCEHead.resize_boundary", "fce_head.FCEHead._get_boundary_single"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.poly_nms", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.resize_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead._get_boundary_single"], ["", "def", "get_boundary", "(", "self", ",", "score_maps", ",", "img_metas", ",", "rescale", ")", ":", "\n", "        ", "assert", "len", "(", "score_maps", ")", "==", "len", "(", "self", ".", "scales", ")", "\n", "\n", "boundaries", "=", "[", "]", "\n", "for", "idx", ",", "score_map", "in", "enumerate", "(", "score_maps", ")", ":", "\n", "            ", "scale", "=", "self", ".", "scales", "[", "idx", "]", "\n", "boundaries", "=", "boundaries", "+", "self", ".", "_get_boundary_single", "(", "\n", "score_map", ",", "scale", ")", "\n", "\n", "# nms", "\n", "", "boundaries", "=", "poly_nms", "(", "boundaries", ",", "self", ".", "nms_thr", ")", "\n", "\n", "if", "rescale", ":", "\n", "            ", "boundaries", "=", "self", ".", "resize_boundary", "(", "\n", "boundaries", ",", "1.0", "/", "img_metas", "[", "0", "]", "[", "'scale_factor'", "]", ")", "\n", "\n", "", "results", "=", "dict", "(", "boundary_result", "=", "boundaries", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead._get_boundary_single": [[145, 150], ["fce_head.FCEHead.postprocessor", "len"], "methods", ["None"], ["", "def", "_get_boundary_single", "(", "self", ",", "score_map", ",", "scale", ")", ":", "\n", "        ", "assert", "len", "(", "score_map", ")", "==", "2", "\n", "assert", "score_map", "[", "1", "]", ".", "shape", "[", "1", "]", "==", "4", "*", "self", ".", "fourier_degree", "+", "2", "\n", "\n", "return", "self", ".", "postprocessor", "(", "score_map", ",", "scale", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.pse_head.PSEHead.__init__": [[21, 43], ["dict", "dict", "PANHead.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "downsample_ratio", "=", "0.25", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'PSELoss'", ")", ",", "\n", "postprocessor", "=", "dict", "(", "\n", "type", "=", "'PSEPostprocessor'", ",", "text_repr_type", "=", "'poly'", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "downsample_ratio", "=", "downsample_ratio", ",", "\n", "loss", "=", "loss", ",", "\n", "postprocessor", "=", "postprocessor", ",", "\n", "train_cfg", "=", "train_cfg", ",", "\n", "test_cfg", "=", "test_cfg", ",", "\n", "init_cfg", "=", "init_cfg", ",", "\n", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.__init__": [[26, 68], ["dict", "dict", "mmcv.runner.BaseModule.__init__", "head_mixin.HeadMixin.__init__", "isinstance", "mmcv.runner.Sequential", "db_head.DBHead._init_thr", "dict", "dict", "kwargs.get", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.Sigmoid", "torch.Sigmoid", "kwargs.get", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead._init_thr"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "with_bias", "=", "False", ",", "\n", "downsample_ratio", "=", "1.0", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'DBLoss'", ")", ",", "\n", "postprocessor", "=", "dict", "(", "type", "=", "'DBPostprocessor'", ",", "text_repr_type", "=", "'quad'", ")", ",", "\n", "init_cfg", "=", "[", "\n", "dict", "(", "type", "=", "'Kaiming'", ",", "layer", "=", "'Conv'", ")", ",", "\n", "dict", "(", "type", "=", "'Constant'", ",", "layer", "=", "'BatchNorm'", ",", "val", "=", "1.", ",", "bias", "=", "1e-4", ")", "\n", "]", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "old_keys", "=", "[", "'text_repr_type'", ",", "'decoding_type'", "]", "\n", "for", "key", "in", "old_keys", ":", "\n", "            ", "if", "kwargs", ".", "get", "(", "key", ",", "None", ")", ":", "\n", "                ", "postprocessor", "[", "key", "]", "=", "kwargs", ".", "get", "(", "key", ")", "\n", "warnings", ".", "warn", "(", "\n", "f'{key} is deprecated, please specify '", "\n", "'it in postprocessor config dict. See '", "\n", "'https://github.com/open-mmlab/mmocr/pull/640'", "\n", "' for details.'", ",", "UserWarning", ")", "\n", "", "", "BaseModule", ".", "__init__", "(", "self", ",", "init_cfg", "=", "init_cfg", ")", "\n", "HeadMixin", ".", "__init__", "(", "self", ",", "loss", ",", "postprocessor", ")", "\n", "\n", "assert", "isinstance", "(", "in_channels", ",", "int", ")", "\n", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "train_cfg", "=", "train_cfg", "\n", "self", ".", "test_cfg", "=", "test_cfg", "\n", "self", ".", "downsample_ratio", "=", "downsample_ratio", "\n", "\n", "self", ".", "binarize", "=", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "in_channels", "//", "4", ",", "3", ",", "bias", "=", "with_bias", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "in_channels", "//", "4", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "ConvTranspose2d", "(", "in_channels", "//", "4", ",", "in_channels", "//", "4", ",", "2", ",", "2", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "in_channels", "//", "4", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "ConvTranspose2d", "(", "in_channels", "//", "4", ",", "1", ",", "2", ",", "2", ")", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "\n", "self", ".", "threshold", "=", "self", ".", "_init_thr", "(", "in_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.diff_binarize": [[69, 71], ["torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "torch.reciprocal", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "diff_binarize", "(", "self", ",", "prob_map", ",", "thr_map", ",", "k", ")", ":", "\n", "        ", "return", "torch", ".", "reciprocal", "(", "1.0", "+", "torch", ".", "exp", "(", "-", "k", "*", "(", "prob_map", "-", "thr_map", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward": [[72, 85], ["db_head.DBHead.binarize", "db_head.DBHead.threshold", "db_head.DBHead.diff_binarize", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.diff_binarize"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs (Tensor): Shape (batch_size, hidden_size, h, w).\n\n        Returns:\n            Tensor: A tensor of the same shape as input.\n        \"\"\"", "\n", "prob_map", "=", "self", ".", "binarize", "(", "inputs", ")", "\n", "thr_map", "=", "self", ".", "threshold", "(", "inputs", ")", "\n", "binary_map", "=", "self", ".", "diff_binarize", "(", "prob_map", ",", "thr_map", ",", "k", "=", "50", ")", "\n", "outputs", "=", "torch", ".", "cat", "(", "(", "prob_map", ",", "thr_map", ",", "binary_map", ")", ",", "dim", "=", "1", ")", "\n", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead._init_thr": [[86, 96], ["mmcv.runner.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["None"], ["", "def", "_init_thr", "(", "self", ",", "inner_channels", ",", "bias", "=", "False", ")", ":", "\n", "        ", "in_channels", "=", "inner_channels", "\n", "seq", "=", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "inner_channels", "//", "4", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "bias", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "inner_channels", "//", "4", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "ConvTranspose2d", "(", "inner_channels", "//", "4", ",", "inner_channels", "//", "4", ",", "2", ",", "2", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "inner_channels", "//", "4", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "ConvTranspose2d", "(", "inner_channels", "//", "4", ",", "1", ",", "2", ",", "2", ")", ",", "nn", ".", "Sigmoid", "(", ")", ")", "\n", "return", "seq", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.pse_postprocessor.PSEPostprocessor.__init__": [[26, 44], ["base_postprocessor.BasePostprocessor.__init__", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "text_repr_type", "=", "'poly'", ",", "\n", "min_kernel_confidence", "=", "0.5", ",", "\n", "min_text_avg_confidence", "=", "0.85", ",", "\n", "min_kernel_area", "=", "0", ",", "\n", "min_text_area", "=", "16", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "text_repr_type", ")", "\n", "\n", "assert", "0", "<=", "min_kernel_confidence", "<=", "1", "\n", "assert", "0", "<=", "min_text_avg_confidence", "<=", "1", "\n", "assert", "isinstance", "(", "min_kernel_area", ",", "int", ")", "\n", "assert", "isinstance", "(", "min_text_area", ",", "int", ")", "\n", "\n", "self", ".", "min_kernel_confidence", "=", "min_kernel_confidence", "\n", "self", ".", "min_text_avg_confidence", "=", "min_text_avg_confidence", "\n", "self", ".", "min_kernel_area", "=", "min_kernel_area", "\n", "self", ".", "min_text_area", "=", "min_text_area", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.pse_postprocessor.PSEPostprocessor.__call__": [[45, 89], ["torch.sigmoid", "score.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu().numpy().astype", "kernel_masks.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu().numpy().astype", "cv2.connectedComponents", "mmcv.ops.contour_expand", "numpy.array", "numpy.max", "range", "torch.sigmoid.dim", "numpy.mean", "mmocr.core.points2boundary", "score.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu().numpy", "kernel_masks.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu().numpy", "numpy.array().transpose", "pse_postprocessor.PSEPostprocessor.is_valid_instance", "boundaries.append", "score.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu", "kernel_masks.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu", "numpy.array", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.base_postprocessor.BasePostprocessor.is_valid_instance"], ["", "def", "__call__", "(", "self", ",", "preds", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            preds (Tensor): Prediction map with shape :math:`(C, H, W)`.\n\n        Returns:\n            list[list[float]]: The instance boundary and its confidence.\n        \"\"\"", "\n", "assert", "preds", ".", "dim", "(", ")", "==", "3", "\n", "\n", "preds", "=", "torch", ".", "sigmoid", "(", "preds", ")", "# text confidence", "\n", "\n", "score", "=", "preds", "[", "0", ",", ":", ",", ":", "]", "\n", "masks", "=", "preds", ">", "self", ".", "min_kernel_confidence", "\n", "text_mask", "=", "masks", "[", "0", ",", ":", ",", ":", "]", "\n", "kernel_masks", "=", "masks", "[", "0", ":", ",", ":", ",", ":", "]", "*", "text_mask", "\n", "\n", "score", "=", "score", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "kernel_masks", "=", "kernel_masks", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "region_num", ",", "labels", "=", "cv2", ".", "connectedComponents", "(", "\n", "kernel_masks", "[", "-", "1", "]", ",", "connectivity", "=", "4", ")", "\n", "\n", "labels", "=", "contour_expand", "(", "kernel_masks", ",", "labels", ",", "self", ".", "min_kernel_area", ",", "\n", "region_num", ")", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "label_num", "=", "np", ".", "max", "(", "labels", ")", "\n", "boundaries", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "label_num", "+", "1", ")", ":", "\n", "            ", "points", "=", "np", ".", "array", "(", "np", ".", "where", "(", "labels", "==", "i", ")", ")", ".", "transpose", "(", "(", "1", ",", "0", ")", ")", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "area", "=", "points", ".", "shape", "[", "0", "]", "\n", "score_instance", "=", "np", ".", "mean", "(", "score", "[", "labels", "==", "i", "]", ")", "\n", "if", "not", "self", ".", "is_valid_instance", "(", "area", ",", "score_instance", ",", "\n", "self", ".", "min_text_area", ",", "\n", "self", ".", "min_text_avg_confidence", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "vertices_confidence", "=", "points2boundary", "(", "points", ",", "self", ".", "text_repr_type", ",", "\n", "score_instance", ")", "\n", "if", "vertices_confidence", "is", "not", "None", ":", "\n", "                ", "boundaries", ".", "append", "(", "vertices_confidence", ")", "\n", "\n", "", "", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.pan_postprocessor.PANPostprocessor.__init__": [[25, 38], ["base_postprocessor.BasePostprocessor.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "text_repr_type", "=", "'poly'", ",", "\n", "min_text_confidence", "=", "0.5", ",", "\n", "min_kernel_confidence", "=", "0.5", ",", "\n", "min_text_avg_confidence", "=", "0.85", ",", "\n", "min_text_area", "=", "16", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "text_repr_type", ")", "\n", "\n", "self", ".", "min_text_confidence", "=", "min_text_confidence", "\n", "self", ".", "min_kernel_confidence", "=", "min_kernel_confidence", "\n", "self", ".", "min_text_avg_confidence", "=", "min_text_avg_confidence", "\n", "self", ".", "min_text_area", "=", "min_text_area", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.pan_postprocessor.PANPostprocessor.__call__": [[39, 86], ["torch.sigmoid", "preds.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "preds[].astype", "preds[].transpose", "cv2.connectedComponents", "cv2.findContours", "numpy.zeros", "cv2.drawContours", "mmcv.ops.pixel_group", "preds.detach().cpu().numpy.detach().cpu().numpy.dim", "kernel.astype", "numpy.array().reshape", "mmocr.core.points2boundary", "preds.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "pan_postprocessor.PANPostprocessor.is_valid_instance", "boundaries.append", "numpy.array", "preds.detach().cpu().numpy.detach().cpu().numpy.detach"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.base_postprocessor.BasePostprocessor.is_valid_instance"], ["", "def", "__call__", "(", "self", ",", "preds", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            preds (Tensor): Prediction map with shape :math:`(C, H, W)`.\n\n        Returns:\n            list[list[float]]: The instance boundary and its confidence.\n        \"\"\"", "\n", "assert", "preds", ".", "dim", "(", ")", "==", "3", "\n", "\n", "preds", "[", ":", "2", ",", ":", ",", ":", "]", "=", "torch", ".", "sigmoid", "(", "preds", "[", ":", "2", ",", ":", ",", ":", "]", ")", "\n", "preds", "=", "preds", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "text_score", "=", "preds", "[", "0", "]", ".", "astype", "(", "np", ".", "float32", ")", "\n", "text", "=", "preds", "[", "0", "]", ">", "self", ".", "min_text_confidence", "\n", "kernel", "=", "(", "preds", "[", "1", "]", ">", "self", ".", "min_kernel_confidence", ")", "*", "text", "\n", "embeddings", "=", "preds", "[", "2", ":", "]", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "# (h, w, 4)", "\n", "\n", "region_num", ",", "labels", "=", "cv2", ".", "connectedComponents", "(", "\n", "kernel", ".", "astype", "(", "np", ".", "uint8", ")", ",", "connectivity", "=", "4", ")", "\n", "contours", ",", "_", "=", "cv2", ".", "findContours", "(", "(", "kernel", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "\n", "cv2", ".", "RETR_LIST", ",", "cv2", ".", "CHAIN_APPROX_NONE", ")", "\n", "kernel_contours", "=", "np", ".", "zeros", "(", "text", ".", "shape", ",", "dtype", "=", "'uint8'", ")", "\n", "cv2", ".", "drawContours", "(", "kernel_contours", ",", "contours", ",", "-", "1", ",", "255", ")", "\n", "text_points", "=", "pixel_group", "(", "text_score", ",", "text", ",", "embeddings", ",", "labels", ",", "\n", "kernel_contours", ",", "region_num", ",", "\n", "self", ".", "min_text_avg_confidence", ")", "\n", "\n", "boundaries", "=", "[", "]", "\n", "for", "text_point", "in", "text_points", ":", "\n", "            ", "text_confidence", "=", "text_point", "[", "0", "]", "\n", "text_point", "=", "text_point", "[", "2", ":", "]", "\n", "text_point", "=", "np", ".", "array", "(", "text_point", ",", "dtype", "=", "int", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "area", "=", "text_point", ".", "shape", "[", "0", "]", "\n", "\n", "if", "not", "self", ".", "is_valid_instance", "(", "area", ",", "text_confidence", ",", "\n", "self", ".", "min_text_area", ",", "\n", "self", ".", "min_text_avg_confidence", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "vertices_confidence", "=", "points2boundary", "(", "text_point", ",", "\n", "self", ".", "text_repr_type", ",", "\n", "text_confidence", ")", "\n", "if", "vertices_confidence", "is", "not", "None", ":", "\n", "                ", "boundaries", ".", "append", "(", "vertices_confidence", ")", "\n", "\n", "", "", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.fce_postprocessor.FCEPostprocessor.__init__": [[29, 45], ["base_postprocessor.BasePostprocessor.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "fourier_degree", ",", "\n", "num_reconstr_points", ",", "\n", "text_repr_type", "=", "'poly'", ",", "\n", "alpha", "=", "1.0", ",", "\n", "beta", "=", "2.0", ",", "\n", "score_thr", "=", "0.3", ",", "\n", "nms_thr", "=", "0.1", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "text_repr_type", ")", "\n", "self", ".", "fourier_degree", "=", "fourier_degree", "\n", "self", ".", "num_reconstr_points", "=", "num_reconstr_points", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "score_thr", "=", "score_thr", "\n", "self", ".", "nms_thr", "=", "nms_thr", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.fce_postprocessor.FCEPostprocessor.__call__": [[46, 111], ["isinstance", "cls_pred[].softmax().data.cpu().numpy", "cls_pred[].softmax().data.cpu().numpy", "[].permute().data.cpu().numpy", "utils.fill_hole", "cv2.findContours", "numpy.zeros_like", "utils.poly_nms", "len", "utils.fill_hole.astype", "numpy.zeros_like.copy().astype", "cv2.drawContours", "numpy.argwhere", "utils.fourier2poly", "score_map[].reshape", "utils.poly_nms", "cls_pred[].softmax().data.cpu", "cls_pred[].softmax().data.cpu", "[].permute().data.cpu", "numpy.hstack().tolist", "numpy.array().reshape().astype", "cv2.boxPoints", "numpy.int0", "new_boundaries.append", "numpy.zeros_like.copy", "cv2.minAreaRect", "numpy.hstack", "numpy.array().reshape", "numpy.int0.reshape().tolist", "cls_pred[].softmax", "cls_pred[].softmax", "[].permute", "numpy.array", "numpy.int0.reshape"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fill_hole", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.poly_nms", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fourier2poly", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.poly_nms"], ["", "def", "__call__", "(", "self", ",", "preds", ",", "scale", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            preds (list[Tensor]): Classification prediction and regression\n                prediction.\n            scale (float): Scale of current layer.\n\n        Returns:\n            list[list[float]]: The instance boundary and confidence.\n        \"\"\"", "\n", "assert", "isinstance", "(", "preds", ",", "list", ")", "\n", "assert", "len", "(", "preds", ")", "==", "2", "\n", "\n", "cls_pred", "=", "preds", "[", "0", "]", "[", "0", "]", "\n", "tr_pred", "=", "cls_pred", "[", "0", ":", "2", "]", ".", "softmax", "(", "dim", "=", "0", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "tcl_pred", "=", "cls_pred", "[", "2", ":", "]", ".", "softmax", "(", "dim", "=", "0", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "reg_pred", "=", "preds", "[", "1", "]", "[", "0", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "x_pred", "=", "reg_pred", "[", ":", ",", ":", ",", ":", "2", "*", "self", ".", "fourier_degree", "+", "1", "]", "\n", "y_pred", "=", "reg_pred", "[", ":", ",", ":", ",", "2", "*", "self", ".", "fourier_degree", "+", "1", ":", "]", "\n", "\n", "score_pred", "=", "(", "tr_pred", "[", "1", "]", "**", "self", ".", "alpha", ")", "*", "(", "tcl_pred", "[", "1", "]", "**", "self", ".", "beta", ")", "\n", "tr_pred_mask", "=", "(", "score_pred", ")", ">", "self", ".", "score_thr", "\n", "tr_mask", "=", "fill_hole", "(", "tr_pred_mask", ")", "\n", "\n", "tr_contours", ",", "_", "=", "cv2", ".", "findContours", "(", "\n", "tr_mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cv2", ".", "RETR_TREE", ",", "\n", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "# opencv4", "\n", "\n", "mask", "=", "np", ".", "zeros_like", "(", "tr_mask", ")", "\n", "boundaries", "=", "[", "]", "\n", "for", "cont", "in", "tr_contours", ":", "\n", "            ", "deal_map", "=", "mask", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "int8", ")", "\n", "cv2", ".", "drawContours", "(", "deal_map", ",", "[", "cont", "]", ",", "-", "1", ",", "1", ",", "-", "1", ")", "\n", "\n", "score_map", "=", "score_pred", "*", "deal_map", "\n", "score_mask", "=", "score_map", ">", "0", "\n", "xy_text", "=", "np", ".", "argwhere", "(", "score_mask", ")", "\n", "dxy", "=", "xy_text", "[", ":", ",", "1", "]", "+", "xy_text", "[", ":", ",", "0", "]", "*", "1j", "\n", "\n", "x", ",", "y", "=", "x_pred", "[", "score_mask", "]", ",", "y_pred", "[", "score_mask", "]", "\n", "c", "=", "x", "+", "y", "*", "1j", "\n", "c", "[", ":", ",", "self", ".", "fourier_degree", "]", "=", "c", "[", ":", ",", "self", ".", "fourier_degree", "]", "+", "dxy", "\n", "c", "*=", "scale", "\n", "\n", "polygons", "=", "fourier2poly", "(", "c", ",", "self", ".", "num_reconstr_points", ")", "\n", "score", "=", "score_map", "[", "score_mask", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "polygons", "=", "poly_nms", "(", "\n", "np", ".", "hstack", "(", "(", "polygons", ",", "score", ")", ")", ".", "tolist", "(", ")", ",", "self", ".", "nms_thr", ")", "\n", "\n", "boundaries", "=", "boundaries", "+", "polygons", "\n", "\n", "", "boundaries", "=", "poly_nms", "(", "boundaries", ",", "self", ".", "nms_thr", ")", "\n", "\n", "if", "self", ".", "text_repr_type", "==", "'quad'", ":", "\n", "            ", "new_boundaries", "=", "[", "]", "\n", "for", "boundary", "in", "boundaries", ":", "\n", "                ", "poly", "=", "np", ".", "array", "(", "boundary", "[", ":", "-", "1", "]", ")", ".", "reshape", "(", "-", "1", ",", "\n", "2", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "score", "=", "boundary", "[", "-", "1", "]", "\n", "points", "=", "cv2", ".", "boxPoints", "(", "cv2", ".", "minAreaRect", "(", "poly", ")", ")", "\n", "points", "=", "np", ".", "int0", "(", "points", ")", "\n", "new_boundaries", ".", "append", "(", "points", ".", "reshape", "(", "-", "1", ")", ".", "tolist", "(", ")", "+", "[", "score", "]", ")", "\n", "\n", "", "", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.db_postprocessor.DBPostprocessor.__init__": [[28, 44], ["base_postprocessor.BasePostprocessor.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "text_repr_type", "=", "'poly'", ",", "\n", "mask_thr", "=", "0.3", ",", "\n", "min_text_score", "=", "0.3", ",", "\n", "min_text_width", "=", "5", ",", "\n", "unclip_ratio", "=", "1.5", ",", "\n", "epsilon_ratio", "=", "0.01", ",", "\n", "max_candidates", "=", "3000", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "text_repr_type", ")", "\n", "self", ".", "mask_thr", "=", "mask_thr", "\n", "self", ".", "min_text_score", "=", "min_text_score", "\n", "self", ".", "min_text_width", "=", "min_text_width", "\n", "self", ".", "unclip_ratio", "=", "unclip_ratio", "\n", "self", ".", "epsilon_ratio", "=", "epsilon_ratio", "\n", "self", ".", "max_candidates", "=", "max_candidates", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.db_postprocessor.DBPostprocessor.__call__": [[45, 95], ["prob_map.data.cpu().numpy().astype", "text_mask.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu().numpy().astype", "cv2.findContours", "enumerate", "preds.dim", "cv2.approxPolyDP", "cv2.approxPolyDP.reshape", "utils.box_score_fast", "utils.unclip", "poly.flatten().tolist.flatten().tolist.reshape", "prob_map.data.cpu().numpy", "text_mask.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu().numpy", "cv2.arcLength", "isinstance", "mmocr.core.points2boundary", "boundaries.append", "len", "poly.flatten().tolist.flatten().tolist.flatten().tolist", "prob_map.data.cpu", "text_mask.data.cpu().numpy().astype.data.cpu().numpy().astype.data.cpu", "len", "poly.flatten().tolist.flatten().tolist.flatten"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.box_score_fast", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.unclip", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary"], ["", "def", "__call__", "(", "self", ",", "preds", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            preds (Tensor): Prediction map with shape :math:`(C, H, W)`.\n\n        Returns:\n            list[list[float]]: The predicted text boundaries.\n        \"\"\"", "\n", "assert", "preds", ".", "dim", "(", ")", "==", "3", "\n", "\n", "prob_map", "=", "preds", "[", "0", ",", ":", ",", ":", "]", "\n", "text_mask", "=", "prob_map", ">", "self", ".", "mask_thr", "\n", "\n", "score_map", "=", "prob_map", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "text_mask", "=", "text_mask", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "# to numpy", "\n", "\n", "contours", ",", "_", "=", "cv2", ".", "findContours", "(", "(", "text_mask", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "\n", "cv2", ".", "RETR_LIST", ",", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "\n", "\n", "boundaries", "=", "[", "]", "\n", "for", "i", ",", "poly", "in", "enumerate", "(", "contours", ")", ":", "\n", "            ", "if", "i", ">", "self", ".", "max_candidates", ":", "\n", "                ", "break", "\n", "", "epsilon", "=", "self", ".", "epsilon_ratio", "*", "cv2", ".", "arcLength", "(", "poly", ",", "True", ")", "\n", "approx", "=", "cv2", ".", "approxPolyDP", "(", "poly", ",", "epsilon", ",", "True", ")", "\n", "points", "=", "approx", ".", "reshape", "(", "(", "-", "1", ",", "2", ")", ")", "\n", "if", "points", ".", "shape", "[", "0", "]", "<", "4", ":", "\n", "                ", "continue", "\n", "", "score", "=", "box_score_fast", "(", "score_map", ",", "points", ")", "\n", "if", "score", "<", "self", ".", "min_text_score", ":", "\n", "                ", "continue", "\n", "", "poly", "=", "unclip", "(", "points", ",", "unclip_ratio", "=", "self", ".", "unclip_ratio", ")", "\n", "if", "len", "(", "poly", ")", "==", "0", "or", "isinstance", "(", "poly", "[", "0", "]", ",", "list", ")", ":", "\n", "                ", "continue", "\n", "", "poly", "=", "poly", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "\n", "if", "self", ".", "text_repr_type", "==", "'quad'", ":", "\n", "                ", "poly", "=", "points2boundary", "(", "poly", ",", "self", ".", "text_repr_type", ",", "score", ",", "\n", "self", ".", "min_text_width", ")", "\n", "", "elif", "self", ".", "text_repr_type", "==", "'poly'", ":", "\n", "                ", "poly", "=", "poly", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "if", "score", "is", "not", "None", ":", "\n", "                    ", "poly", "=", "poly", "+", "[", "score", "]", "\n", "", "if", "len", "(", "poly", ")", "<", "8", ":", "\n", "                    ", "poly", "=", "None", "\n", "\n", "", "", "if", "poly", "is", "not", "None", ":", "\n", "                ", "boundaries", ".", "append", "(", "poly", ")", "\n", "\n", "", "", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.drrg_postprocessor.DRRGPostprocessor.__init__": [[16, 19], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "link_thr", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "isinstance", "(", "link_thr", ",", "float", ")", "\n", "self", ".", "link_thr", "=", "link_thr", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.drrg_postprocessor.DRRGPostprocessor.__call__": [[20, 42], ["utils.graph_propagation", "utils.connected_components", "utils.clusters2labels", "utils.remove_single", "utils.comps2boundaries", "len", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.graph_propagation", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.connected_components", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.clusters2labels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.remove_single", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.comps2boundaries"], ["", "def", "__call__", "(", "self", ",", "edges", ",", "scores", ",", "text_comps", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            edges (ndarray): The edge array of shape N * 2, each row is a node\n                index pair that makes up an edge in graph.\n            scores (ndarray): The edge score array of shape (N,).\n            text_comps (ndarray): The text components.\n\n        Returns:\n            List[list[float]]: The predicted boundaries of text instances.\n        \"\"\"", "\n", "assert", "len", "(", "edges", ")", "==", "len", "(", "scores", ")", "\n", "assert", "text_comps", ".", "ndim", "==", "2", "\n", "assert", "text_comps", ".", "shape", "[", "1", "]", "==", "9", "\n", "\n", "vertices", ",", "score_dict", "=", "graph_propagation", "(", "edges", ",", "scores", ",", "text_comps", ")", "\n", "clusters", "=", "connected_components", "(", "vertices", ",", "score_dict", ",", "self", ".", "link_thr", ")", "\n", "pred_labels", "=", "clusters2labels", "(", "clusters", ",", "text_comps", ".", "shape", "[", "0", "]", ")", "\n", "text_comps", ",", "pred_labels", "=", "remove_single", "(", "text_comps", ",", "pred_labels", ")", "\n", "boundaries", "=", "comps2boundaries", "(", "text_comps", ",", "pred_labels", ")", "\n", "\n", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.textsnake_postprocessor.TextSnakePostprocessor.__init__": [[30, 45], ["base_postprocessor.BasePostprocessor.__init__"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "text_repr_type", "=", "'poly'", ",", "\n", "min_text_region_confidence", "=", "0.6", ",", "\n", "min_center_region_confidence", "=", "0.2", ",", "\n", "min_center_area", "=", "30", ",", "\n", "disk_overlap_thr", "=", "0.03", ",", "\n", "radius_shrink_ratio", "=", "1.03", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "text_repr_type", ")", "\n", "assert", "text_repr_type", "==", "'poly'", "\n", "self", ".", "min_text_region_confidence", "=", "min_text_region_confidence", "\n", "self", ".", "min_center_region_confidence", "=", "min_center_region_confidence", "\n", "self", ".", "min_center_area", "=", "min_center_area", "\n", "self", ".", "disk_overlap_thr", "=", "disk_overlap_thr", "\n", "self", ".", "radius_shrink_ratio", "=", "radius_shrink_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.textsnake_postprocessor.TextSnakePostprocessor.__call__": [[46, 116], ["torch.sigmoid", "preds.detach().cpu().numpy.detach().cpu().numpy.detach().cpu().numpy", "numpy.sqrt", "utils.fill_hole().astype", "cv2.findContours", "preds.detach().cpu().numpy.detach().cpu().numpy.dim", "numpy.zeros", "cv2.drawContours", "skimage.morphology.skeletonize", "numpy.argwhere", "pred_cos[].reshape", "pred_sin[].reshape", "pred_radius[].reshape", "utils.centralize", "pred_center_score[].reshape", "numpy.hstack", "utils.merge_disks", "numpy.zeros", "cv2.findContours", "preds.detach().cpu().numpy.detach().cpu().numpy.detach().cpu", "utils.fill_hole", "cv2.contourArea", "numpy.sum", "contours[].flatten().tolist", "boundaries.append", "numpy.fliplr", "cv2.circle", "numpy.sum", "len", "cv2.contourArea", "preds.detach().cpu().numpy.detach().cpu().numpy.detach", "int", "contours[].flatten", "int", "int"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.centralize", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.merge_disks", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fill_hole"], ["", "def", "__call__", "(", "self", ",", "preds", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            preds (Tensor): Prediction map with shape :math:`(C, H, W)`.\n\n        Returns:\n            list[list[float]]: The instance boundary and its confidence.\n        \"\"\"", "\n", "assert", "preds", ".", "dim", "(", ")", "==", "3", "\n", "\n", "preds", "[", ":", "2", ",", ":", ",", ":", "]", "=", "torch", ".", "sigmoid", "(", "preds", "[", ":", "2", ",", ":", ",", ":", "]", ")", "\n", "preds", "=", "preds", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "pred_text_score", "=", "preds", "[", "0", "]", "\n", "pred_text_mask", "=", "pred_text_score", ">", "self", ".", "min_text_region_confidence", "\n", "pred_center_score", "=", "preds", "[", "1", "]", "*", "pred_text_score", "\n", "pred_center_mask", "=", "pred_center_score", ">", "self", ".", "min_center_region_confidence", "\n", "pred_sin", "=", "preds", "[", "2", "]", "\n", "pred_cos", "=", "preds", "[", "3", "]", "\n", "pred_radius", "=", "preds", "[", "4", "]", "\n", "mask_sz", "=", "pred_text_mask", ".", "shape", "\n", "\n", "scale", "=", "np", ".", "sqrt", "(", "1.0", "/", "(", "pred_sin", "**", "2", "+", "pred_cos", "**", "2", "+", "1e-8", ")", ")", "\n", "pred_sin", "=", "pred_sin", "*", "scale", "\n", "pred_cos", "=", "pred_cos", "*", "scale", "\n", "\n", "pred_center_mask", "=", "fill_hole", "(", "pred_center_mask", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "center_contours", ",", "_", "=", "cv2", ".", "findContours", "(", "pred_center_mask", ",", "cv2", ".", "RETR_TREE", ",", "\n", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "\n", "\n", "boundaries", "=", "[", "]", "\n", "for", "contour", "in", "center_contours", ":", "\n", "            ", "if", "cv2", ".", "contourArea", "(", "contour", ")", "<", "self", ".", "min_center_area", ":", "\n", "                ", "continue", "\n", "", "instance_center_mask", "=", "np", ".", "zeros", "(", "mask_sz", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "cv2", ".", "drawContours", "(", "instance_center_mask", ",", "[", "contour", "]", ",", "-", "1", ",", "1", ",", "-", "1", ")", "\n", "skeleton", "=", "skeletonize", "(", "instance_center_mask", ")", "\n", "skeleton_yx", "=", "np", ".", "argwhere", "(", "skeleton", ">", "0", ")", "\n", "y", ",", "x", "=", "skeleton_yx", "[", ":", ",", "0", "]", ",", "skeleton_yx", "[", ":", ",", "1", "]", "\n", "cos", "=", "pred_cos", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "sin", "=", "pred_sin", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "radius", "=", "pred_radius", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "center_line_yx", "=", "centralize", "(", "skeleton_yx", ",", "cos", ",", "-", "sin", ",", "radius", ",", "\n", "instance_center_mask", ")", "\n", "y", ",", "x", "=", "center_line_yx", "[", ":", ",", "0", "]", ",", "center_line_yx", "[", ":", ",", "1", "]", "\n", "radius", "=", "(", "pred_radius", "[", "y", ",", "x", "]", "*", "self", ".", "radius_shrink_ratio", ")", ".", "reshape", "(", "\n", "(", "-", "1", ",", "1", ")", ")", "\n", "score", "=", "pred_center_score", "[", "y", ",", "x", "]", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "instance_disks", "=", "np", ".", "hstack", "(", "\n", "[", "np", ".", "fliplr", "(", "center_line_yx", ")", ",", "radius", ",", "score", "]", ")", "\n", "instance_disks", "=", "merge_disks", "(", "instance_disks", ",", "self", ".", "disk_overlap_thr", ")", "\n", "\n", "instance_mask", "=", "np", ".", "zeros", "(", "mask_sz", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "x", ",", "y", ",", "radius", ",", "score", "in", "instance_disks", ":", "\n", "                ", "if", "radius", ">", "1", ":", "\n", "                    ", "cv2", ".", "circle", "(", "instance_mask", ",", "(", "int", "(", "x", ")", ",", "int", "(", "y", ")", ")", ",", "int", "(", "radius", ")", ",", "1", ",", "\n", "-", "1", ")", "\n", "", "", "contours", ",", "_", "=", "cv2", ".", "findContours", "(", "instance_mask", ",", "cv2", ".", "RETR_TREE", ",", "\n", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "\n", "\n", "score", "=", "np", ".", "sum", "(", "instance_mask", "*", "pred_text_score", ")", "/", "(", "\n", "np", ".", "sum", "(", "instance_mask", ")", "+", "1e-8", ")", "\n", "if", "(", "len", "(", "contours", ")", ">", "0", "and", "cv2", ".", "contourArea", "(", "contours", "[", "0", "]", ")", ">", "0", "\n", "and", "contours", "[", "0", "]", ".", "size", ">", "8", ")", ":", "\n", "                ", "boundary", "=", "contours", "[", "0", "]", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "boundaries", ".", "append", "(", "boundary", "+", "[", "score", "]", ")", "\n", "\n", "", "", "return", "boundaries", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.base_postprocessor.BasePostprocessor.__init__": [[6, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "text_repr_type", "=", "'poly'", ")", ":", "\n", "        ", "assert", "text_repr_type", "in", "[", "'poly'", ",", "'quad'", "\n", "]", ",", "f'Invalid text repr type {text_repr_type}'", "\n", "\n", "self", ".", "text_repr_type", "=", "text_repr_type", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.base_postprocessor.BasePostprocessor.is_valid_instance": [[12, 16], ["bool"], "methods", ["None"], ["", "def", "is_valid_instance", "(", "self", ",", "area", ",", "confidence", ",", "area_thresh", ",", "\n", "confidence_thresh", ")", ":", "\n", "\n", "        ", "return", "bool", "(", "area", ">=", "area_thresh", "and", "confidence", ">", "confidence_thresh", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.Node.__init__": [[167, 170], ["set"], "methods", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.Node.ind": [[171, 174], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.Node.links": [[175, 178], ["set"], "methods", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.Node.add_link": [[179, 182], ["utils.Node.__links.add", "link_node.__links.add"], "methods", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.filter_instance": [[15, 17], ["bool"], "function", ["None"], ["        ", "if", "cfg", ".", "pipeline", "is", "not", "None", ":", "\n", "            ", "cfg", ".", "pipeline", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", ")", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.box_score_fast": [[19, 32], ["_box.copy", "numpy.clip", "numpy.clip", "numpy.clip", "numpy.clip", "numpy.zeros", "cv2.fillPoly", "numpy.floor().astype", "numpy.ceil().astype", "numpy.floor().astype", "numpy.ceil().astype", "_box.copy.reshape().astype", "cv2.mean", "numpy.floor", "numpy.ceil", "numpy.floor", "numpy.ceil", "_box.copy.reshape", "box[].min", "box[].max", "box[].min", "box[].max"], "function", ["None"], ["\n", "\n", "", "", "def", "replace_image_to_tensor", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Replace 'ImageToTensor' to 'DefaultFormatBundle'.\"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.unclip": [[34, 41], ["shapely.geometry.Polygon", "pyclipper.PyclipperOffset", "pyclipper.PyclipperOffset.AddPath", "numpy.array", "pyclipper.PyclipperOffset.Execute"], "function", ["None"], ["            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fill_hole": [[43, 54], ["numpy.zeros", "input_mask.copy", "numpy.zeros", "cv2.floodFill", "canvas[].astype"], "function", ["None"], ["\n", "", "", "", "return", "cfg", "\n", "\n", "\n", "", "def", "update_pipeline_recog", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "warning_msg", "=", "'Remove \"MultiRotateAugOCR\" to support batch '", "+", "'inference since samples_per_gpu > 1.'", "\n", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "get", "(", "'pipeline'", ",", "\n", "None", ")", "and", "cfg", ".", "pipeline", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", ".", "pipeline", "=", "[", "cfg", ".", "pipeline", "[", "0", "]", ",", "*", "cfg", ".", "pipeline", "[", "1", "]", ".", "transforms", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.centralize": [[56, 84], ["numpy.ones", "numpy.any", "numpy.ones", "numpy.any", "numpy.array", "numpy.hstack", "numpy.array", "numpy.array", "len", "len", "np.ones.reshape", "np.ones.reshape", "numpy.clip", "numpy.clip", "numpy.clip", "numpy.clip"], "function", ["None"], ["        ", "if", "cfg", "[", "idx", "]", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", "[", "idx", "]", "=", "[", "cfg", "[", "idx", "]", "[", "0", "]", ",", "*", "cfg", "[", "idx", "]", "[", "1", "]", ".", "transforms", "]", "\n", "\n", "\n", "", "", "", "def", "disable_text_recog_aug_test", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Remove aug_test from test pipeline for text recognition.\n\n    Args:\n        cfg (mmcv.Config): Input config.\n        set_types (list[str]): Type of dataset source. Should be\n            None or sublist of ['test', 'val'].\n    \"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "warnings", ".", "simplefilter", "(", "'once'", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "dataset_type", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "type", "\n", "if", "dataset_type", "not", "in", "[", "\n", "'ConcatDataset'", ",", "'UniformConcatDataset'", ",", "'OCRDataset'", ",", "\n", "'OCRSegDataset'", "\n", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.merge_disks": [[86, 115], ["numpy.vstack", "scores.argsort", "numpy.linalg.norm", "np.vstack.append", "numpy.hstack", "np.vstack.append", "np.vstack.append", "numpy.where", "numpy.mean", "numpy.where"], "function", ["None"], ["            ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ".", "pipeline", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline_recog", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n", "                ", "update_pipeline_recog", "(", "dataset", ")", "\n", "\n", "", "", "", "return", "cfg", "\n", "\n", "\n", "", "def", "tensor2grayimgs", "(", "tensor", ",", "mean", "=", "(", "127", ",", ")", ",", "std", "=", "(", "127", ",", ")", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Convert tensor to 1-channel gray images.\n\n    Args:\n        tensor (torch.Tensor): Tensor that contains multiple images, shape (\n            N, C, H, W).\n        mean (tuple[float], optional): Mean of images. Defaults to (127).\n        std (tuple[float], optional): Standard deviation of images.\n            Defaults to (127).\n\n    Returns:\n        list[np.ndarray]: A list that contains multiple images.\n    \"\"\"", "\n", "\n", "assert", "torch", ".", "is_tensor", "(", "tensor", ")", "and", "tensor", ".", "ndim", "==", "4", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.poly_nms": [[117, 139], ["isinstance", "numpy.array", "sorted", "len", "keep_poly.append", "numpy.delete", "numpy.zeros", "range", "numpy.where", "numpy.delete", "range", "polygons[].tolist", "len", "mmocr.core.evaluation.utils.boundary_iou", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou"], ["\n", "num_imgs", "=", "tensor", ".", "size", "(", "0", ")", "\n", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "imgs", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "num_imgs", ")", ":", "\n", "        ", "img", "=", "tensor", "[", "img_id", ",", "...", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "img", "=", "mmcv", ".", "imdenormalize", "(", "img", ",", "mean", ",", "std", ",", "to_bgr", "=", "False", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "imgs", ".", "append", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", "\n", "", "return", "imgs", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fourier2poly": [[141, 163], ["numpy.zeros", "numpy.zeros", "np.zeros.astype().reshape", "numpy.fft.ifft", "len", "len", "len", "np.zeros.astype", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.graph_propagation": [[184, 232], ["isinstance", "numpy.sort", "enumerate", "numpy.sort", "numpy.arange", "numpy.unique", "numpy.ones", "utils.Node", "vertices[].add_link", "text_comps[].reshape", "text_comps[].reshape", "numpy.mean", "numpy.mean", "numpy.linalg.norm", "np.sort.flatten", "numpy.max"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.Node.add_link"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.connected_components": [[234, 269], ["isinstance", "all", "isinstance", "isinstance", "set", "set.pop", "clusters.append", "isinstance", "node_queue.pop", "set", "set.difference_update", "set.difference_update", "cluster.update", "node_queue.extend", "list", "tuple", "sorted"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.clusters2labels": [[271, 294], ["isinstance", "all", "all", "isinstance", "numpy.zeros", "enumerate", "isinstance", "isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.remove_single": [[296, 324], ["numpy.zeros_like", "numpy.unique", "numpy.sum", "range", "len", "numpy.where"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2": [[326, 328], ["None"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.min_connect_path": [[330, 382], ["isinstance", "all", "all", "points.copy", "points.copy.remove", "functools.reduce", "sorted", "min", "min", "set", "isinstance", "isinstance", "utils.norm2", "utils.norm2", "edge_dict0.keys", "edge_dict1.keys", "sorted.insert", "points.copy.remove", "sorted.append", "points.copy.remove", "points.index", "points.index", "points.index", "points.index"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.norm2"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.in_contour": [[384, 388], ["cv2.pointPolygonTest", "int", "int"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fix_corner": [[390, 431], ["isinstance", "all", "isinstance", "all", "numpy.array", "utils.in_contour", "top_line.insert", "bot_line.insert", "utils.in_contour", "top_line.append", "bot_line.append", "isinstance", "isinstance", "start_box[].tolist", "start_box[].tolist", "utils.in_contour", "top_line.insert", "bot_line.insert", "end_box[].tolist", "end_box[].tolist", "utils.in_contour", "top_line.append", "bot_line.append", "start_box[].tolist", "start_box[].tolist", "end_box[].tolist", "end_box[].tolist"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.in_contour", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.in_contour", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.in_contour", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.in_contour"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.comps2boundaries": [[433, 483], ["range", "len", "len", "len", "numpy.where", "text_comps[].reshape().astype", "numpy.mean", "boundaries.append", "int", "numpy.max", "text_comps[].reshape", "numpy.mean().astype().tolist", "utils.min_connect_path", "numpy.mean().astype().tolist", "numpy.mean().astype().tolist", "utils.fix_corner", "text_comp_boxes[].astype().tolist", "text_comp_boxes[].astype().tolist", "numpy.mean().astype", "numpy.mean().astype", "numpy.mean().astype", "text_comp_boxes[].astype", "text_comp_boxes[].astype", "numpy.mean", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.min_connect_path", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.fix_corner"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.__init__": [[11, 29], ["mmocr.models.textrecog.recognizer.base.BaseRecognizer.__init__", "mmocr.models.builder.build_convertor", "mmocr.models.builder.build_encoder", "decoder.update", "mmocr.models.builder.build_decoder", "loss.update", "mmocr.models.builder.build_loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_convertor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_encoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_decoder", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_loss"], ["def", "__init__", "(", "self", ",", "\n", "encoder", ",", "\n", "decoder", ",", "\n", "loss", ",", "\n", "label_convertor", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ",", "\n", "init_cfg", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "init_cfg", "=", "init_cfg", ")", "\n", "self", ".", "label_convertor", "=", "build_convertor", "(", "label_convertor", ")", "\n", "\n", "self", ".", "encoder", "=", "build_encoder", "(", "encoder", ")", "\n", "\n", "decoder", ".", "update", "(", "num_labels", "=", "self", ".", "label_convertor", ".", "num_labels", ")", "\n", "self", ".", "decoder", "=", "build_decoder", "(", "decoder", ")", "\n", "\n", "loss", ".", "update", "(", "num_labels", "=", "self", ".", "label_convertor", ".", "num_labels", ")", "\n", "self", ".", "loss", "=", "build_loss", "(", "loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.extract_feat": [[30, 34], ["NotImplementedError"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "\"\"\"Extract features from images.\"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "'Extract feature module is not implemented yet.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_train": [[35, 40], ["ner_classifier.NerClassifier.encoder", "ner_classifier.NerClassifier.decoder", "ner_classifier.NerClassifier.loss"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.loss"], ["", "def", "forward_train", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "encode_out", "=", "self", ".", "encoder", "(", "img_metas", ")", "\n", "logits", ",", "_", "=", "self", ".", "decoder", "(", "encode_out", ")", "\n", "loss", "=", "self", ".", "loss", "(", "logits", ",", "img_metas", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_test": [[41, 47], ["ner_classifier.NerClassifier.encoder", "ner_classifier.NerClassifier.decoder", "ner_classifier.NerClassifier.label_convertor.convert_pred2entities"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_pred2entities"], ["", "def", "forward_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "encode_out", "=", "self", ".", "encoder", "(", "img_metas", ")", "\n", "_", ",", "preds", "=", "self", ".", "decoder", "(", "encode_out", ")", "\n", "pred_entities", "=", "self", ".", "label_convertor", ".", "convert_pred2entities", "(", "\n", "preds", ",", "img_metas", "[", "'attention_masks'", "]", ")", "\n", "return", "pred_entities", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.aug_test": [[48, 50], ["NotImplementedError"], "methods", ["None"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Augmentation test is not implemented yet.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.simple_test": [[51, 53], ["NotImplementedError"], "methods", ["None"], ["", "def", "simple_test", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Simple test is not implemented yet.'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.extract": [[11, 47], ["os.join", "os.listdir", "os.listdir", "os.join", "extract_kaist.extract_zipfile", "os.listdir", "os.listdir", "os.join", "file.endswith", "os.path.join", "os.path.join", "xml.parse", "file.replace", "os.join", "os.exists", "shutil.move", "shutil.move", "os.join", "os.join", "str().zfill", "str().zfill", "str", "str"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.extract_zipfile"], ["def", "extract", "(", "root_path", ")", ":", "\n", "    ", "idx", "=", "0", "\n", "for", "language", "in", "[", "'English'", ",", "'Korean'", ",", "'Mixed'", "]", ":", "\n", "        ", "for", "camera", "in", "[", "'Digital_Camera'", ",", "'Mobile_Phone'", "]", ":", "\n", "            ", "crt_path", "=", "osp", ".", "join", "(", "root_path", ",", "'KAIST'", ",", "language", ",", "camera", ")", "\n", "zips", "=", "os", ".", "listdir", "(", "crt_path", ")", "\n", "for", "zip", "in", "zips", ":", "\n", "                ", "extracted_path", "=", "osp", ".", "join", "(", "root_path", ",", "'tmp'", ",", "zip", ")", "\n", "extract_zipfile", "(", "osp", ".", "join", "(", "crt_path", ",", "zip", ")", ",", "extracted_path", ")", "\n", "for", "file", "in", "os", ".", "listdir", "(", "extracted_path", ")", ":", "\n", "                    ", "if", "file", ".", "endswith", "(", "'xml'", ")", ":", "\n", "                        ", "src_ann", "=", "os", ".", "path", ".", "join", "(", "extracted_path", ",", "file", ")", "\n", "# Filtering broken annotations", "\n", "try", ":", "\n", "                            ", "ET", ".", "parse", "(", "src_ann", ")", "\n", "", "except", "ParseError", ":", "\n", "                            ", "continue", "\n", "", "src_img", "=", "None", "\n", "img_names", "=", "[", "\n", "file", ".", "replace", "(", "'xml'", ",", "suffix", ")", "\n", "for", "suffix", "in", "[", "'jpg'", ",", "'JPG'", "]", "\n", "]", "\n", "for", "im", "in", "img_names", ":", "\n", "                            ", "img_path", "=", "osp", ".", "join", "(", "extracted_path", ",", "im", ")", "\n", "if", "osp", ".", "exists", "(", "img_path", ")", ":", "\n", "                                ", "src_img", "=", "img_path", "\n", "", "", "if", "src_img", ":", "\n", "                            ", "shutil", ".", "move", "(", "\n", "src_ann", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'annotations'", ",", "\n", "str", "(", "idx", ")", ".", "zfill", "(", "5", ")", "+", "'.xml'", ")", ")", "\n", "shutil", ".", "move", "(", "\n", "src_img", ",", "\n", "osp", ".", "join", "(", "root_path", ",", "'imgs'", ",", "\n", "str", "(", "idx", ")", ".", "zfill", "(", "5", ")", "+", "'.jpg'", ")", ")", "\n", "idx", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.extract_zipfile": [[49, 56], ["zipfile.ZipFile", "zipfile.ZipFile.namelist", "zipfile.ZipFile.extract", "os.remove", "os.remove"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.extract"], ["", "", "", "", "", "", "", "def", "extract_zipfile", "(", "zip_path", ",", "dst_dir", ",", "delete", "=", "True", ")", ":", "\n", "\n", "    ", "files", "=", "zipfile", ".", "ZipFile", "(", "zip_path", ")", "\n", "for", "file", "in", "files", ".", "namelist", "(", ")", ":", "\n", "        ", "files", ".", "extract", "(", "file", ",", "dst_dir", ")", "\n", "", "if", "delete", ":", "\n", "        ", "os", ".", "remove", "(", "zip_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.parse_args": [[58, 63], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Extract KAIST zips'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'Root path of KAIST'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.main": [[65, 72], ["extract_kaist.parse_args", "os.exists", "extract_kaist.extract", "shutil.rmtree", "shutil.rmtree", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.extract_kaist.extract"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "assert", "osp", ".", "exists", "(", "root_path", ")", "\n", "extract", "(", "root_path", ")", "\n", "shutil", ".", "rmtree", "(", "osp", ".", "join", "(", "args", ".", "root_path", ",", "'tmp'", ")", ")", "\n", "shutil", ".", "rmtree", "(", "osp", ".", "join", "(", "args", ".", "root_path", ",", "'KAIST'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.digit2text": [[25, 36], ["res.append", "print", "res.append"], "function", ["None"], ["def", "digit2text", "(", "rec", ")", ":", "\n", "    ", "res", "=", "[", "]", "\n", "for", "d", "in", "rec", ":", "\n", "        ", "assert", "d", "<=", "EOS", "\n", "if", "d", "==", "EOS", ":", "\n", "            ", "break", "\n", "", "if", "d", "==", "UNK", ":", "\n", "            ", "print", "(", "'Warning: Has a UNK character'", ")", "\n", "res", ".", "append", "(", "'\u53e3'", ")", "# Or any special character not in the target dict", "\n", "", "res", ".", "append", "(", "dict95", "[", "d", "]", ")", "\n", "", "return", "''", ".", "join", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.modify_annotation": [[38, 47], ["curvedsyntext_converter.digit2text", "mmocr.utils.bezier_to_polygon", "numpy.asarray().reshape().tolist", "ann.pop", "numpy.asarray().reshape", "numpy.asarray", "mmocr.utils.sort_points"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.digit2text", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.bezier_to_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.sort_points"], ["", "def", "modify_annotation", "(", "ann", ",", "num_sample", ",", "start_img_id", "=", "0", ",", "start_ann_id", "=", "0", ")", ":", "\n", "    ", "ann", "[", "'text'", "]", "=", "digit2text", "(", "ann", ".", "pop", "(", "'rec'", ")", ")", "\n", "# Get hide egmentation points", "\n", "polygon_pts", "=", "bezier_to_polygon", "(", "ann", "[", "'bezier_pts'", "]", ",", "num_sample", "=", "num_sample", ")", "\n", "ann", "[", "'segmentation'", "]", "=", "np", ".", "asarray", "(", "sort_points", "(", "polygon_pts", ")", ")", ".", "reshape", "(", "\n", "1", ",", "-", "1", ")", ".", "tolist", "(", ")", "\n", "ann", "[", "'image_id'", "]", "+=", "start_img_id", "\n", "ann", "[", "'id'", "]", "+=", "start_ann_id", "\n", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.modify_image_info": [[49, 53], ["os.join"], "function", ["None"], ["", "def", "modify_image_info", "(", "image_info", ",", "path_prefix", ",", "start_img_id", "=", "0", ")", ":", "\n", "    ", "image_info", "[", "'file_name'", "]", "=", "osp", ".", "join", "(", "path_prefix", ",", "image_info", "[", "'file_name'", "]", ")", "\n", "image_info", "[", "'id'", "]", "+=", "start_img_id", "\n", "return", "image_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.parse_args": [[55, 70], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert CurvedSynText150k to COCO format'", ")", "\n", "parser", ".", "add_argument", "(", "'root_path'", ",", "help", "=", "'CurvedSynText150k  root path'", ")", "\n", "parser", ".", "add_argument", "(", "'-o'", ",", "'--out-dir'", ",", "help", "=", "'Output path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-n'", ",", "\n", "'--num-sample'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "4", ",", "\n", "help", "=", "'Number of sample points at each Bezier curve.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'Number of processes'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations": [[72, 99], ["functools.partial", "functools.partial", "mmcv.track_parallel_progress", "mmcv.track_parallel_progress", "mmcv.track_progress", "mmcv.track_progress"], "function", ["None"], ["", "def", "convert_annotations", "(", "data", ",", "\n", "path_prefix", ",", "\n", "num_sample", ",", "\n", "nproc", ",", "\n", "start_img_id", "=", "0", ",", "\n", "start_ann_id", "=", "0", ")", ":", "\n", "    ", "modify_image_info_with_params", "=", "partial", "(", "\n", "modify_image_info", ",", "path_prefix", "=", "path_prefix", ",", "start_img_id", "=", "start_img_id", ")", "\n", "modify_annotation_with_params", "=", "partial", "(", "\n", "modify_annotation", ",", "\n", "num_sample", "=", "num_sample", ",", "\n", "start_img_id", "=", "start_img_id", ",", "\n", "start_ann_id", "=", "start_ann_id", ")", "\n", "if", "nproc", ">", "1", ":", "\n", "        ", "data", "[", "'annotations'", "]", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "modify_annotation_with_params", ",", "data", "[", "'annotations'", "]", ",", "nproc", "=", "nproc", ")", "\n", "data", "[", "'images'", "]", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "modify_image_info_with_params", ",", "data", "[", "'images'", "]", ",", "nproc", "=", "nproc", ")", "\n", "", "else", ":", "\n", "        ", "data", "[", "'annotations'", "]", "=", "mmcv", ".", "track_progress", "(", "\n", "modify_annotation_with_params", ",", "data", "[", "'annotations'", "]", ")", "\n", "data", "[", "'images'", "]", "=", "mmcv", ".", "track_progress", "(", "\n", "modify_image_info_with_params", ",", "\n", "data", "[", "'images'", "]", ",", "\n", ")", "\n", "", "data", "[", "'categories'", "]", "=", "[", "{", "'id'", ":", "1", ",", "'name'", ":", "'text'", "}", "]", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.main": [[101, 126], ["curvedsyntext_converter.parse_args", "mmcv.mkdir_or_exist", "mmcv.load", "curvedsyntext_converter.convert_annotations", "mmcv.load", "curvedsyntext_converter.convert_annotations", "mmcv.dump", "os.join", "os.join", "os.join", "max", "max"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.curvedsyntext_converter.convert_annotations"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "root_path", "=", "args", ".", "root_path", "\n", "out_dir", "=", "args", ".", "out_dir", "if", "args", ".", "out_dir", "else", "root_path", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_dir", ")", "\n", "\n", "anns", "=", "mmcv", ".", "load", "(", "osp", ".", "join", "(", "root_path", ",", "'train1.json'", ")", ")", "\n", "data1", "=", "convert_annotations", "(", "anns", ",", "'syntext_word_eng'", ",", "args", ".", "num_sample", ",", "\n", "args", ".", "nproc", ")", "\n", "\n", "# Get the maximum image id from data1", "\n", "start_img_id", "=", "max", "(", "data1", "[", "'images'", "]", ",", "key", "=", "lambda", "x", ":", "x", "[", "'id'", "]", ")", "[", "'id'", "]", "+", "1", "\n", "start_ann_id", "=", "max", "(", "data1", "[", "'annotations'", "]", ",", "key", "=", "lambda", "x", ":", "x", "[", "'id'", "]", ")", "[", "'id'", "]", "+", "1", "\n", "anns", "=", "mmcv", ".", "load", "(", "osp", ".", "join", "(", "root_path", ",", "'train2.json'", ")", ")", "\n", "data2", "=", "convert_annotations", "(", "\n", "anns", ",", "\n", "'emcs_imgs'", ",", "\n", "args", ".", "num_sample", ",", "\n", "args", ".", "nproc", ",", "\n", "start_img_id", "=", "start_img_id", ",", "\n", "start_ann_id", "=", "start_ann_id", ")", "\n", "\n", "data1", "[", "'images'", "]", "+=", "data2", "[", "'images'", "]", "\n", "data1", "[", "'annotations'", "]", "+=", "data2", "[", "'annotations'", "]", "\n", "mmcv", ".", "dump", "(", "data1", ",", "osp", ".", "join", "(", "out_dir", ",", "'instances_training.json'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.labelme_converter.parse_labelme_json": [[15, 135], ["mmcv.load", "os.basename", "os.join", "det_line_json_list.append", "mmcv.imread", "os.join", "mmcv.mkdir_or_exist", "annos.append", "json.dumps", "os.splitext", "warnings.warn", "poly.extend", "max", "min", "max", "min", "min", "min", "mmocr.datasets.pipelines.crop.crop_img", "os.join", "mmcv.imwrite", "warnings.warn", "len", "recog_crop_line_str_list.append", "mmocr.datasets.pipelines.crop.warp_img", "os.join", "mmcv.imwrite", "int", "len", "min", "max", "min", "max", "len", "recog_crop_line_str_list.append", "recog_warp_line_str_list.append", "len", "json.dumps", "recog_warp_line_str_list.append", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.warp_img"], ["def", "parse_labelme_json", "(", "json_file", ",", "\n", "img_dir", ",", "\n", "out_dir", ",", "\n", "tasks", ",", "\n", "ignore_marker", "=", "'###'", ",", "\n", "recog_format", "=", "'jsonl'", ",", "\n", "warp_flag", "=", "False", ")", ":", "\n", "    ", "invalid_res", "=", "[", "[", "]", ",", "[", "]", ",", "[", "]", "]", "\n", "\n", "json_obj", "=", "mmcv", ".", "load", "(", "json_file", ")", "\n", "\n", "img_file", "=", "osp", ".", "basename", "(", "json_obj", "[", "'imagePath'", "]", ")", "\n", "img_full_path", "=", "osp", ".", "join", "(", "img_dir", ",", "img_file", ")", "\n", "\n", "img_width", "=", "json_obj", "[", "'imageWidth'", "]", "\n", "img_height", "=", "json_obj", "[", "'imageHeight'", "]", "\n", "if", "'recog'", "in", "tasks", ":", "\n", "        ", "src_img", "=", "mmcv", ".", "imread", "(", "img_full_path", ")", "\n", "img_basename", "=", "osp", ".", "splitext", "(", "img_file", ")", "[", "0", "]", "\n", "sub_dir", "=", "osp", ".", "join", "(", "out_dir", ",", "'crops'", ",", "img_basename", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "sub_dir", ")", "\n", "\n", "", "det_line_json_list", "=", "[", "]", "\n", "recog_crop_line_str_list", "=", "[", "]", "\n", "recog_warp_line_str_list", "=", "[", "]", "\n", "\n", "shape_info", "=", "json_obj", "[", "'shapes'", "]", "\n", "idx", "=", "0", "\n", "annos", "=", "[", "]", "\n", "for", "box_info", "in", "shape_info", ":", "\n", "        ", "shape", "=", "box_info", "[", "'shape_type'", "]", "\n", "if", "shape", "not", "in", "[", "'rectangle'", ",", "'polygon'", "]", ":", "\n", "            ", "msg", "=", "'Only \\'rectangle\\' and \\'polygon\\' boxes are supported. '", "\n", "msg", "+=", "f'Boxes with {shape} will be discarded.'", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "return", "invalid_res", "\n", "", "poly", "=", "[", "]", "\n", "box_points", "=", "box_info", "[", "'points'", "]", "\n", "for", "point", "in", "box_points", ":", "\n", "            ", "poly", ".", "extend", "(", "[", "int", "(", "x", ")", "for", "x", "in", "point", "]", ")", "\n", "", "x_list", "=", "poly", "[", "0", ":", ":", "2", "]", "\n", "y_list", "=", "poly", "[", "1", ":", ":", "2", "]", "\n", "quad", "=", "[", "]", "\n", "if", "shape", "==", "'rectangle'", ":", "\n", "            ", "warp_flag", "=", "False", "\n", "quad", "=", "[", "\n", "poly", "[", "0", "]", ",", "poly", "[", "1", "]", ",", "poly", "[", "2", "]", ",", "poly", "[", "1", "]", ",", "poly", "[", "2", "]", ",", "poly", "[", "3", "]", ",", "poly", "[", "0", "]", ",", "\n", "poly", "[", "3", "]", "\n", "]", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "poly", ")", "<", "8", "or", "len", "(", "poly", ")", "%", "2", "!=", "0", ":", "\n", "                ", "msg", "=", "f'Invalid polygon {poly}. '", "\n", "msg", "+=", "'The polygon is expected to have 8 or more than 8 '", "\n", "msg", "+=", "'even number of coordinates in MMOCR.'", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "return", "invalid_res", "\n", "", "if", "len", "(", "poly", ")", "==", "8", ":", "\n", "                ", "quad", "=", "poly", "\n", "", "else", ":", "\n", "                ", "warp_flag", "=", "False", "\n", "x_min", ",", "x_max", ",", "y_min", ",", "y_max", "=", "min", "(", "x_list", ")", ",", "max", "(", "x_list", ")", ",", "min", "(", "\n", "y_list", ")", ",", "max", "(", "y_list", ")", "\n", "quad", "=", "[", "x_min", ",", "y_min", ",", "x_max", ",", "y_min", ",", "x_max", ",", "y_max", ",", "x_min", ",", "y_max", "]", "\n", "", "", "text_label", "=", "box_info", "[", "'label'", "]", "\n", "# for textdet", "\n", "anno", "=", "{", "}", "\n", "anno", "[", "'iscrowd'", "]", "=", "0", "if", "text_label", "!=", "ignore_marker", "else", "1", "\n", "anno", "[", "'category_id'", "]", "=", "1", "\n", "w", "=", "max", "(", "x_list", ")", "-", "min", "(", "x_list", ")", "\n", "h", "=", "max", "(", "y_list", ")", "-", "min", "(", "y_list", ")", "\n", "anno", "[", "'bbox'", "]", "=", "[", "min", "(", "x_list", ")", ",", "min", "(", "y_list", ")", ",", "w", ",", "h", "]", "\n", "if", "shape", "==", "'rectangle'", ":", "\n", "            ", "anno", "[", "'segmentation'", "]", "=", "[", "quad", "]", "\n", "", "else", ":", "\n", "            ", "anno", "[", "'segmentation'", "]", "=", "[", "poly", "]", "\n", "", "anno", "[", "'text'", "]", "=", "text_label", "\n", "annos", ".", "append", "(", "anno", ")", "\n", "# for textrecog", "\n", "if", "'recog'", "in", "tasks", ":", "\n", "            ", "if", "text_label", "==", "ignore_marker", "or", "len", "(", "text_label", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "cropped_img", "=", "crop_img", "(", "src_img", ",", "quad", ")", "\n", "img_path_cropped_img", "=", "osp", ".", "join", "(", "sub_dir", ",", "f'crop_{idx}.jpg'", ")", "\n", "mmcv", ".", "imwrite", "(", "cropped_img", ",", "img_path_cropped_img", ")", "\n", "if", "recog_format", "==", "'txt'", ":", "\n", "                ", "recog_crop_line_str_list", ".", "append", "(", "\n", "f'{img_path_cropped_img} {text_label}'", ")", "\n", "", "elif", "recog_format", "==", "'jsonl'", ":", "\n", "                ", "recog_crop_line_str_list", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "img_path_cropped_img", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "if", "warp_flag", ":", "\n", "                ", "warpped_img", "=", "warp_img", "(", "src_img", ",", "quad", ")", "\n", "img_path_warpped_img", "=", "osp", ".", "join", "(", "sub_dir", ",", "f'warp_{idx}.jpg'", ")", "\n", "mmcv", ".", "imwrite", "(", "warpped_img", ",", "img_path_warpped_img", ")", "\n", "if", "recog_format", "==", "'txt'", ":", "\n", "                    ", "recog_warp_line_str_list", ".", "append", "(", "\n", "f'{img_path_warpped_img} {text_label}'", ")", "\n", "", "elif", "recog_format", "==", "'jsonl'", ":", "\n", "                    ", "recog_warp_line_str_list", ".", "append", "(", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "img_path_warpped_img", ",", "\n", "'text'", ":", "text_label", "\n", "}", ")", ")", "\n", "", "", "", "idx", "+=", "1", "\n", "\n", "", "line_json", "=", "{", "\n", "'file_name'", ":", "img_file", ",", "\n", "'height'", ":", "img_height", ",", "\n", "'width'", ":", "img_width", ",", "\n", "'annotations'", ":", "annos", "\n", "}", "\n", "det_line_json_list", ".", "append", "(", "json", ".", "dumps", "(", "line_json", ",", "ensure_ascii", "=", "False", ")", ")", "\n", "\n", "return", "[", "\n", "det_line_json_list", ",", "recog_crop_line_str_list", ",", "recog_warp_line_str_list", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.labelme_converter.process": [[138, 187], ["mmcv.mkdir_or_exist", "glob.glob", "functools.partial", "mmcv.mkdir_or_exist", "os.join", "mmocr.utils.list_to_file", "os.join", "mmcv.track_progress", "mmcv.track_parallel_progress", "total_det_line_json_list.extend", "os.join", "mmocr.utils.list_to_file", "total_recog_crop_line_str.extend", "total_recog_warp_line_str.extend", "os.join", "mmocr.utils.list_to_file"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "process", "(", "json_dir", ",", "\n", "img_dir", ",", "\n", "out_dir", ",", "\n", "tasks", "=", "[", "'det'", "]", ",", "\n", "nproc", "=", "1", ",", "\n", "recog_format", "=", "'jsonl'", ",", "\n", "warp", "=", "False", ")", ":", "\n", "    ", "mmcv", ".", "mkdir_or_exist", "(", "out_dir", ")", "\n", "\n", "json_file_list", "=", "glob", ".", "glob", "(", "osp", ".", "join", "(", "json_dir", ",", "'*.json'", ")", ")", "\n", "\n", "parse_labelme_json_func", "=", "partial", "(", "\n", "parse_labelme_json", ",", "\n", "img_dir", "=", "img_dir", ",", "\n", "out_dir", "=", "out_dir", ",", "\n", "tasks", "=", "tasks", ",", "\n", "recog_format", "=", "recog_format", ",", "\n", "warp_flag", "=", "warp", ")", "\n", "\n", "if", "nproc", "<=", "1", ":", "\n", "        ", "total_results", "=", "mmcv", ".", "track_progress", "(", "parse_labelme_json_func", ",", "\n", "json_file_list", ")", "\n", "", "else", ":", "\n", "        ", "total_results", "=", "mmcv", ".", "track_parallel_progress", "(", "\n", "parse_labelme_json_func", ",", "\n", "json_file_list", ",", "\n", "keep_order", "=", "True", ",", "\n", "nproc", "=", "nproc", ")", "\n", "\n", "", "total_det_line_json_list", "=", "[", "]", "\n", "total_recog_crop_line_str", "=", "[", "]", "\n", "total_recog_warp_line_str", "=", "[", "]", "\n", "for", "res", "in", "total_results", ":", "\n", "        ", "total_det_line_json_list", ".", "extend", "(", "res", "[", "0", "]", ")", "\n", "if", "'recog'", "in", "tasks", ":", "\n", "            ", "total_recog_crop_line_str", ".", "extend", "(", "res", "[", "1", "]", ")", "\n", "total_recog_warp_line_str", ".", "extend", "(", "res", "[", "2", "]", ")", "\n", "\n", "", "", "mmcv", ".", "mkdir_or_exist", "(", "out_dir", ")", "\n", "det_out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "'instances_training.txt'", ")", "\n", "list_to_file", "(", "det_out_file", ",", "total_det_line_json_list", ")", "\n", "\n", "if", "'recog'", "in", "tasks", ":", "\n", "        ", "recog_out_file_crop", "=", "osp", ".", "join", "(", "out_dir", ",", "f'train_label.{recog_format}'", ")", "\n", "list_to_file", "(", "recog_out_file_crop", ",", "total_recog_crop_line_str", ")", "\n", "if", "warp", ":", "\n", "            ", "recog_out_file_warp", "=", "osp", ".", "join", "(", "out_dir", ",", "\n", "f'warp_train_label.{recog_format}'", ")", "\n", "list_to_file", "(", "recog_out_file_warp", ",", "total_recog_warp_line_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.labelme_converter.parse_args": [[189, 212], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'json_dir'", ",", "help", "=", "'Root dir for labelme json file.'", ")", "\n", "parser", ".", "add_argument", "(", "'image_dir'", ",", "help", "=", "'Root dir for image file.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'out_dir'", ",", "help", "=", "'Dir to save annotations in mmocr format.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--tasks'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Tasks to be processed, can be only \"det\" or both: \"det recog\"'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--nproc'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'Number of process.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--format'", ",", "\n", "default", "=", "'jsonl'", ",", "\n", "help", "=", "'Use jsonl or string to format recognition annotations'", ",", "\n", "choices", "=", "[", "'jsonl'", ",", "'txt'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--warp'", ",", "\n", "help", "=", "'Store warpped img for recognition task'", ",", "\n", "action", "=", "'store_true'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.labelme_converter.main": [[214, 221], ["labelme_converter.parse_args", "labelme_converter.process", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.common.labelme_converter.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "process", "(", "args", ".", "json_dir", ",", "args", ".", "image_dir", ",", "args", ".", "out_dir", ",", "args", ".", "tasks", ",", "\n", "args", ".", "nproc", ",", "args", ".", "format", ",", "args", ".", "warp", ")", "\n", "\n", "print", "(", "'finish'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.overlay_mask_img": [[18, 37], ["isinstance", "isinstance", "cv2.findContours", "cv2.drawContours", "mask.astype"], "function", ["None"], ["def", "overlay_mask_img", "(", "img", ",", "mask", ")", ":", "\n", "    ", "\"\"\"Draw mask boundaries on image for visualization.\n\n    Args:\n        img (ndarray): The input image.\n        mask (ndarray): The instance mask.\n\n    Returns:\n        img (ndarray): The output image with instance boundaries on it.\n    \"\"\"", "\n", "assert", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", "\n", "assert", "isinstance", "(", "mask", ",", "np", ".", "ndarray", ")", "\n", "\n", "contours", ",", "_", "=", "cv2", ".", "findContours", "(", "\n", "mask", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cv2", ".", "RETR_EXTERNAL", ",", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "\n", "\n", "cv2", ".", "drawContours", "(", "img", ",", "contours", ",", "-", "1", ",", "(", "0", ",", "255", ",", "0", ")", ",", "1", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature": [[39, 69], ["mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_none_or_type", "mmocr.equal_len", "len", "math.ceil", "enumerate", "math.sqrt", "zip", "matplotlib.pyplot.subplot", "matplotlib.pyplot.title", "matplotlib.pyplot.imshow", "matplotlib.pyplot.show", "matplotlib.pyplot.savefig", "f.astype.astype"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.equal_len"], ["", "def", "show_feature", "(", "features", ",", "names", ",", "to_uint8", ",", "out_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Visualize a list of feature maps.\n\n    Args:\n        features (list(ndarray)): The feature map list.\n        names (list(str)): The visualized title list.\n        to_uint8 (list(1|0)): The list indicating whether to convent\n            feature maps to uint8.\n        out_file (str): The output file name. If set to None,\n            the output image will be shown without saving.\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "features", ",", "np", ".", "ndarray", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "names", ",", "str", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "to_uint8", ",", "int", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "out_file", ",", "str", ")", "\n", "assert", "utils", ".", "equal_len", "(", "features", ",", "names", ",", "to_uint8", ")", "\n", "\n", "num", "=", "len", "(", "features", ")", "\n", "row", "=", "col", "=", "math", ".", "ceil", "(", "math", ".", "sqrt", "(", "num", ")", ")", "\n", "\n", "for", "i", ",", "(", "f", ",", "n", ")", "in", "enumerate", "(", "zip", "(", "features", ",", "names", ")", ")", ":", "\n", "        ", "plt", ".", "subplot", "(", "row", ",", "col", ",", "i", "+", "1", ")", "\n", "plt", ".", "title", "(", "n", ")", "\n", "if", "to_uint8", "[", "i", "]", ":", "\n", "            ", "f", "=", "f", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "plt", ".", "imshow", "(", "f", ")", "\n", "", "if", "out_file", "is", "None", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "savefig", "(", "out_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_img_boundary": [[71, 88], ["isinstance", "mmocr.is_type_list", "cv2.polylines", "matplotlib.pyplot.imshow", "matplotlib.pyplot.show", "numpy.array().astype().reshape", "numpy.array().astype", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "", "def", "show_img_boundary", "(", "img", ",", "boundary", ")", ":", "\n", "    ", "\"\"\"Show image and instance boundaires.\n\n    Args:\n        img (ndarray): The input image.\n        boundary (list[float or int]): The input boundary.\n    \"\"\"", "\n", "assert", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "boundary", ",", "(", "int", ",", "float", ")", ")", "\n", "\n", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "np", ".", "array", "(", "boundary", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "(", "0", ",", "255", ",", "0", ")", ",", "\n", "thickness", "=", "1", ")", "\n", "plt", ".", "imshow", "(", "img", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_pred_gt": [[90, 144], ["mmocr.is_2dlist", "mmocr.is_2dlist", "isinstance", "isinstance", "isinstance", "mmocr.is_none_or_type", "numpy.max", "mmcv.color_val", "mmcv.color_val", "numpy.array().reshape", "int", "int", "numpy.ones", "cv2.polylines", "cv2.polylines", "mmcv.imshow", "mmcv.imwrite", "numpy.array", "numpy.array().astype().reshape", "numpy.array().astype().reshape", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type"], ["", "def", "show_pred_gt", "(", "preds", ",", "\n", "gts", ",", "\n", "show", "=", "False", ",", "\n", "win_name", "=", "''", ",", "\n", "wait_time", "=", "0", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Show detection and ground truth for one image.\n\n    Args:\n        preds (list[list[float]]): The detection boundary list.\n        gts (list[list[float]]): The ground truth boundary list.\n        show (bool): Whether to show the image.\n        win_name (str): The window name.\n        wait_time (int): The value of waitKey param.\n        out_file (str): The filename of the output.\n    \"\"\"", "\n", "assert", "utils", ".", "is_2dlist", "(", "preds", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "gts", ")", "\n", "assert", "isinstance", "(", "show", ",", "bool", ")", "\n", "assert", "isinstance", "(", "win_name", ",", "str", ")", "\n", "assert", "isinstance", "(", "wait_time", ",", "int", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "out_file", ",", "str", ")", "\n", "\n", "p_xy", "=", "[", "p", "for", "boundary", "in", "preds", "for", "p", "in", "boundary", "]", "\n", "gt_xy", "=", "[", "g", "for", "gt", "in", "gts", "for", "g", "in", "gt", "]", "\n", "\n", "max_xy", "=", "np", ".", "max", "(", "np", ".", "array", "(", "p_xy", "+", "gt_xy", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", ",", "axis", "=", "0", ")", "\n", "\n", "width", "=", "int", "(", "max_xy", "[", "0", "]", ")", "+", "100", "\n", "height", "=", "int", "(", "max_xy", "[", "1", "]", ")", "+", "100", "\n", "\n", "img", "=", "np", ".", "ones", "(", "(", "height", ",", "width", ",", "3", ")", ",", "np", ".", "int8", ")", "*", "255", "\n", "pred_color", "=", "mmcv", ".", "color_val", "(", "'red'", ")", "\n", "gt_color", "=", "mmcv", ".", "color_val", "(", "'blue'", ")", "\n", "thickness", "=", "1", "\n", "\n", "for", "boundary", "in", "preds", ":", "\n", "        ", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "np", ".", "array", "(", "boundary", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "pred_color", ",", "\n", "thickness", "=", "thickness", ")", "\n", "", "for", "gt", "in", "gts", ":", "\n", "        ", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "np", ".", "array", "(", "gt", ")", ".", "astype", "(", "np", ".", "int32", ")", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "gt_color", ",", "\n", "thickness", "=", "thickness", ")", "\n", "", "if", "show", ":", "\n", "        ", "mmcv", ".", "imshow", "(", "img", ",", "win_name", ",", "wait_time", ")", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "img", ",", "out_file", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_pred_boundary": [[146, 217], ["isinstance", "mmocr.is_2dlist", "mmocr.is_type_list", "mmocr.equal_len", "mmocr.valid_boundary", "mmcv.imread", "numpy.array", "mmcv.color_val", "mmcv.color_val", "zip", "len", "warnings.warn", "numpy.array().astype", "cv2.polylines", "mmcv.imshow", "mmcv.imwrite", "cv2.putText", "numpy.where", "numpy.where", "numpy.where", "numpy.array", "np.array().astype.reshape"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.equal_len", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary"], ["", "def", "imshow_pred_boundary", "(", "img", ",", "\n", "boundaries_with_scores", ",", "\n", "labels", ",", "\n", "score_thr", "=", "0", ",", "\n", "boundary_color", "=", "'blue'", ",", "\n", "text_color", "=", "'blue'", ",", "\n", "thickness", "=", "1", ",", "\n", "font_scale", "=", "0.5", ",", "\n", "show", "=", "True", ",", "\n", "win_name", "=", "''", ",", "\n", "wait_time", "=", "0", ",", "\n", "out_file", "=", "None", ",", "\n", "show_score", "=", "False", ")", ":", "\n", "    ", "\"\"\"Draw boundaries and class labels (with scores) on an image.\n\n    Args:\n        img (str or ndarray): The image to be displayed.\n        boundaries_with_scores (list[list[float]]): Boundaries with scores.\n        labels (list[int]): Labels of boundaries.\n        score_thr (float): Minimum score of boundaries to be shown.\n        boundary_color (str or tuple or :obj:`Color`): Color of boundaries.\n        text_color (str or tuple or :obj:`Color`): Color of texts.\n        thickness (int): Thickness of lines.\n        font_scale (float): Font scales of texts.\n        show (bool): Whether to show the image.\n        win_name (str): The window name.\n        wait_time (int): Value of waitKey param.\n        out_file (str or None): The filename of the output.\n        show_score (bool): Whether to show text instance score.\n    \"\"\"", "\n", "assert", "isinstance", "(", "img", ",", "(", "str", ",", "np", ".", "ndarray", ")", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "boundaries_with_scores", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "labels", ",", "int", ")", "\n", "assert", "utils", ".", "equal_len", "(", "boundaries_with_scores", ",", "labels", ")", "\n", "if", "len", "(", "boundaries_with_scores", ")", "==", "0", ":", "\n", "        ", "warnings", ".", "warn", "(", "'0 text found in '", "+", "out_file", ")", "\n", "return", "None", "\n", "\n", "", "utils", ".", "valid_boundary", "(", "boundaries_with_scores", "[", "0", "]", ")", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "\n", "scores", "=", "np", ".", "array", "(", "[", "b", "[", "-", "1", "]", "for", "b", "in", "boundaries_with_scores", "]", ")", "\n", "inds", "=", "scores", ">", "score_thr", "\n", "boundaries", "=", "[", "boundaries_with_scores", "[", "i", "]", "[", ":", "-", "1", "]", "for", "i", "in", "np", ".", "where", "(", "inds", ")", "[", "0", "]", "]", "\n", "scores", "=", "[", "scores", "[", "i", "]", "for", "i", "in", "np", ".", "where", "(", "inds", ")", "[", "0", "]", "]", "\n", "labels", "=", "[", "labels", "[", "i", "]", "for", "i", "in", "np", ".", "where", "(", "inds", ")", "[", "0", "]", "]", "\n", "\n", "boundary_color", "=", "mmcv", ".", "color_val", "(", "boundary_color", ")", "\n", "text_color", "=", "mmcv", ".", "color_val", "(", "text_color", ")", "\n", "font_scale", "=", "0.5", "\n", "\n", "for", "boundary", ",", "score", "in", "zip", "(", "boundaries", ",", "scores", ")", ":", "\n", "        ", "boundary_int", "=", "np", ".", "array", "(", "boundary", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "\n", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "boundary_int", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "boundary_color", ",", "\n", "thickness", "=", "thickness", ")", "\n", "\n", "if", "show_score", ":", "\n", "            ", "label_text", "=", "f'{score:.02f}'", "\n", "cv2", ".", "putText", "(", "img", ",", "label_text", ",", "\n", "(", "boundary_int", "[", "0", "]", ",", "boundary_int", "[", "1", "]", "-", "2", ")", ",", "\n", "cv2", ".", "FONT_HERSHEY_COMPLEX", ",", "font_scale", ",", "text_color", ")", "\n", "", "", "if", "show", ":", "\n", "        ", "mmcv", ".", "imshow", "(", "img", ",", "win_name", ",", "wait_time", ")", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "img", ",", "out_file", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_char_boundary": [[219, 294], ["isinstance", "mmocr.is_2dlist", "mmocr.is_2dlist", "mmocr.is_3dlist", "mmocr.is_2dlist", "mmocr.equal_len", "mmcv.imread", "mmcv.color_val", "zip", "mmcv.color_val", "mmcv.color_val", "numpy.array", "numpy.array", "text_box.reshape().astype.reshape().astype", "cv2.polylines", "cv2.putText", "mmcv.imshow", "mmcv.imwrite", "cv2.polylines", "numpy.array", "b.astype.astype", "cv2.polylines", "text_box.reshape().astype.reshape", "text_box.reshape().astype.reshape", "np.array.reshape", "b.astype.reshape"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.equal_len"], ["", "def", "imshow_text_char_boundary", "(", "img", ",", "\n", "text_quads", ",", "\n", "boundaries", ",", "\n", "char_quads", ",", "\n", "chars", ",", "\n", "show", "=", "False", ",", "\n", "thickness", "=", "1", ",", "\n", "font_scale", "=", "0.5", ",", "\n", "win_name", "=", "''", ",", "\n", "wait_time", "=", "-", "1", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Draw text boxes and char boxes on img.\n\n    Args:\n        img (str or ndarray): The img to be displayed.\n        text_quads (list[list[int|float]]): The text boxes.\n        boundaries (list[list[int|float]]): The boundary list.\n        char_quads (list[list[list[int|float]]]): A 2d list of char boxes.\n            char_quads[i] is for the ith text, and char_quads[i][j] is the jth\n            char of the ith text.\n        chars (list[list[char]]). The string for each text box.\n        thickness (int): Thickness of lines.\n        font_scale (float): Font scales of texts.\n        show (bool): Whether to show the image.\n        win_name (str): The window name.\n        wait_time (int): Value of waitKey param.\n        out_file (str or None): The filename of the output.\n    \"\"\"", "\n", "assert", "isinstance", "(", "img", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "text_quads", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "boundaries", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "char_quads", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "chars", ")", "\n", "assert", "utils", ".", "equal_len", "(", "text_quads", ",", "char_quads", ",", "boundaries", ")", "\n", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "char_color", "=", "[", "mmcv", ".", "color_val", "(", "'blue'", ")", ",", "mmcv", ".", "color_val", "(", "'green'", ")", "]", "\n", "text_color", "=", "mmcv", ".", "color_val", "(", "'red'", ")", "\n", "text_inx", "=", "0", "\n", "for", "text_box", ",", "boundary", ",", "char_box", ",", "txt", "in", "zip", "(", "text_quads", ",", "boundaries", ",", "\n", "char_quads", ",", "chars", ")", ":", "\n", "        ", "text_box", "=", "np", ".", "array", "(", "text_box", ")", "\n", "boundary", "=", "np", ".", "array", "(", "boundary", ")", "\n", "\n", "text_box", "=", "text_box", ".", "reshape", "(", "-", "1", ",", "2", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "text_box", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "text_color", ",", "\n", "thickness", "=", "thickness", ")", "\n", "if", "boundary", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "boundary", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "text_color", ",", "\n", "thickness", "=", "thickness", ")", "\n", "\n", "", "for", "b", "in", "char_box", ":", "\n", "            ", "b", "=", "np", ".", "array", "(", "b", ")", "\n", "c", "=", "char_color", "[", "text_inx", "%", "2", "]", "\n", "b", "=", "b", ".", "astype", "(", "np", ".", "int32", ")", "\n", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "b", ".", "reshape", "(", "-", "1", ",", "1", ",", "2", ")", "]", ",", "True", ",", "color", "=", "c", ",", "thickness", "=", "thickness", ")", "\n", "\n", "", "label_text", "=", "''", ".", "join", "(", "txt", ")", "\n", "cv2", ".", "putText", "(", "img", ",", "label_text", ",", "(", "text_box", "[", "0", ",", "0", "]", ",", "text_box", "[", "0", ",", "1", "]", "-", "2", ")", ",", "\n", "cv2", ".", "FONT_HERSHEY_COMPLEX", ",", "font_scale", ",", "text_color", ")", "\n", "text_inx", "=", "text_inx", "+", "1", "\n", "\n", "", "if", "show", ":", "\n", "        ", "mmcv", ".", "imshow", "(", "img", ",", "win_name", ",", "wait_time", ")", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "img", ",", "out_file", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.tile_image": [[296, 321], ["isinstance", "enumerate", "numpy.zeros", "len", "sum", "max", "len", "cv2.cvtColor"], "function", ["None"], ["", "def", "tile_image", "(", "images", ")", ":", "\n", "    ", "\"\"\"Combined multiple images to one vertically.\n\n    Args:\n        images (list[np.ndarray]): Images to be combined.\n    \"\"\"", "\n", "assert", "isinstance", "(", "images", ",", "list", ")", "\n", "assert", "len", "(", "images", ")", ">", "0", "\n", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "images", ")", ":", "\n", "        ", "if", "len", "(", "images", "[", "i", "]", ".", "shape", ")", "==", "2", ":", "\n", "            ", "images", "[", "i", "]", "=", "cv2", ".", "cvtColor", "(", "images", "[", "i", "]", ",", "cv2", ".", "COLOR_GRAY2BGR", ")", "\n", "\n", "", "", "widths", "=", "[", "img", ".", "shape", "[", "1", "]", "for", "img", "in", "images", "]", "\n", "heights", "=", "[", "img", ".", "shape", "[", "0", "]", "for", "img", "in", "images", "]", "\n", "h", ",", "w", "=", "sum", "(", "heights", ")", ",", "max", "(", "widths", ")", "\n", "vis_img", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "offset_y", "=", "0", "\n", "for", "image", "in", "images", ":", "\n", "        ", "img_h", ",", "img_w", "=", "image", ".", "shape", "[", ":", "2", "]", "\n", "vis_img", "[", "offset_y", ":", "(", "offset_y", "+", "img_h", ")", ",", "0", ":", "img_w", ",", ":", "]", "=", "image", "\n", "offset_y", "+=", "img_h", "\n", "\n", "", "return", "vis_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label": [[323, 381], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "mmcv.imread", "int", "cv2.resize", "visualize.is_contain_chinese", "visualize.tile_image", "visualize.draw_texts_by_pil", "cv2.putText", "visualize.is_contain_chinese", "images.append", "mmcv.imshow", "mmcv.imwrite", "numpy.ones", "visualize.draw_texts_by_pil", "cv2.putText", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.is_contain_chinese", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.tile_image", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.is_contain_chinese", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil"], ["", "def", "imshow_text_label", "(", "img", ",", "\n", "pred_label", ",", "\n", "gt_label", ",", "\n", "show", "=", "False", ",", "\n", "win_name", "=", "''", ",", "\n", "wait_time", "=", "-", "1", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Draw predicted texts and ground truth texts on images.\n\n    Args:\n        img (str or np.ndarray): Image filename or loaded image.\n        pred_label (str): Predicted texts.\n        gt_label (str): Ground truth texts.\n        show (bool): Whether to show the image.\n        win_name (str): The window name.\n        wait_time (int): Value of waitKey param.\n        out_file (str): The filename of the output.\n    \"\"\"", "\n", "assert", "isinstance", "(", "img", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", "\n", "assert", "isinstance", "(", "pred_label", ",", "str", ")", "\n", "assert", "isinstance", "(", "gt_label", ",", "str", ")", "\n", "assert", "isinstance", "(", "show", ",", "bool", ")", "\n", "assert", "isinstance", "(", "win_name", ",", "str", ")", "\n", "assert", "isinstance", "(", "wait_time", ",", "int", ")", "\n", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "\n", "src_h", ",", "src_w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "resize_height", "=", "64", "\n", "resize_width", "=", "int", "(", "1.0", "*", "src_w", "/", "src_h", "*", "resize_height", ")", "\n", "img", "=", "cv2", ".", "resize", "(", "img", ",", "(", "resize_width", ",", "resize_height", ")", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "\n", "if", "is_contain_chinese", "(", "pred_label", ")", ":", "\n", "        ", "pred_img", "=", "draw_texts_by_pil", "(", "img", ",", "[", "pred_label", "]", ",", "None", ")", "\n", "", "else", ":", "\n", "        ", "pred_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "cv2", ".", "putText", "(", "pred_img", ",", "pred_label", ",", "(", "5", ",", "40", ")", ",", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "\n", "0.9", ",", "(", "0", ",", "0", ",", "255", ")", ",", "2", ")", "\n", "", "images", "=", "[", "pred_img", ",", "img", "]", "\n", "\n", "if", "gt_label", "!=", "''", ":", "\n", "        ", "if", "is_contain_chinese", "(", "gt_label", ")", ":", "\n", "            ", "gt_img", "=", "draw_texts_by_pil", "(", "img", ",", "[", "gt_label", "]", ",", "None", ")", "\n", "", "else", ":", "\n", "            ", "gt_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "cv2", ".", "putText", "(", "gt_img", ",", "gt_label", ",", "(", "5", ",", "40", ")", ",", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "\n", "0.9", ",", "(", "255", ",", "0", ",", "0", ")", ",", "2", ")", "\n", "", "images", ".", "append", "(", "gt_img", ")", "\n", "\n", "", "img", "=", "tile_image", "(", "images", ")", "\n", "\n", "if", "show", ":", "\n", "        ", "mmcv", ".", "imshow", "(", "img", ",", "win_name", ",", "wait_time", ")", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "img", ",", "out_file", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_node": [[383, 447], ["mmcv.imread", "torch.max", "max_idx.numpy().tolist", "max_value.numpy().tolist", "enumerate", "visualize.draw_texts_by_pil", "result[].detach().cpu", "numpy.array", "cv2.polylines", "int", "int", "str", "texts.append", "int", "len", "text_boxes.append", "numpy.ones", "numpy.ones", "mmcv.imshow", "mmcv.imwrite", "max_idx.numpy", "max_value.numpy", "min", "min", "min", "result[].detach", "np.array.reshape", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil"], ["", "def", "imshow_node", "(", "img", ",", "\n", "result", ",", "\n", "boxes", ",", "\n", "idx_to_cls", "=", "{", "}", ",", "\n", "show", "=", "False", ",", "\n", "win_name", "=", "''", ",", "\n", "wait_time", "=", "-", "1", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "\n", "    ", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "\n", "max_value", ",", "max_idx", "=", "torch", ".", "max", "(", "result", "[", "'nodes'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "-", "1", ")", "\n", "node_pred_label", "=", "max_idx", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "node_pred_score", "=", "max_value", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "texts", ",", "text_boxes", "=", "[", "]", ",", "[", "]", "\n", "for", "i", ",", "box", "in", "enumerate", "(", "boxes", ")", ":", "\n", "        ", "new_box", "=", "[", "[", "box", "[", "0", "]", ",", "box", "[", "1", "]", "]", ",", "[", "box", "[", "2", "]", ",", "box", "[", "1", "]", "]", ",", "[", "box", "[", "2", "]", ",", "box", "[", "3", "]", "]", ",", "\n", "[", "box", "[", "0", "]", ",", "box", "[", "3", "]", "]", "]", "\n", "Pts", "=", "np", ".", "array", "(", "[", "new_box", "]", ",", "np", ".", "int32", ")", "\n", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "Pts", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "2", ")", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "(", "255", ",", "255", ",", "0", ")", ",", "\n", "thickness", "=", "1", ")", "\n", "x_min", "=", "int", "(", "min", "(", "[", "point", "[", "0", "]", "for", "point", "in", "new_box", "]", ")", ")", "\n", "y_min", "=", "int", "(", "min", "(", "[", "point", "[", "1", "]", "for", "point", "in", "new_box", "]", ")", ")", "\n", "\n", "# text", "\n", "pred_label", "=", "str", "(", "node_pred_label", "[", "i", "]", ")", "\n", "if", "pred_label", "in", "idx_to_cls", ":", "\n", "            ", "pred_label", "=", "idx_to_cls", "[", "pred_label", "]", "\n", "", "pred_score", "=", "'{:.2f}'", ".", "format", "(", "node_pred_score", "[", "i", "]", ")", "\n", "text", "=", "pred_label", "+", "'('", "+", "pred_score", "+", "')'", "\n", "texts", ".", "append", "(", "text", ")", "\n", "\n", "# text box", "\n", "font_size", "=", "int", "(", "\n", "min", "(", "\n", "abs", "(", "new_box", "[", "3", "]", "[", "1", "]", "-", "new_box", "[", "0", "]", "[", "1", "]", ")", ",", "\n", "abs", "(", "new_box", "[", "1", "]", "[", "0", "]", "-", "new_box", "[", "0", "]", "[", "0", "]", ")", ")", ")", "\n", "char_num", "=", "len", "(", "text", ")", "\n", "text_box", "=", "[", "\n", "x_min", "*", "2", ",", "y_min", ",", "x_min", "*", "2", "+", "font_size", "*", "char_num", ",", "y_min", ",", "\n", "x_min", "*", "2", "+", "font_size", "*", "char_num", ",", "y_min", "+", "font_size", ",", "x_min", "*", "2", ",", "\n", "y_min", "+", "font_size", "\n", "]", "\n", "text_boxes", ".", "append", "(", "text_box", ")", "\n", "\n", "", "pred_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", "*", "2", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "pred_img", "=", "draw_texts_by_pil", "(", "\n", "pred_img", ",", "texts", ",", "text_boxes", ",", "draw_box", "=", "False", ",", "on_ori_img", "=", "True", ")", "\n", "\n", "vis_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", "*", "3", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "vis_img", "[", ":", ",", ":", "w", "]", "=", "img", "\n", "vis_img", "[", ":", ",", "w", ":", "]", "=", "pred_img", "\n", "\n", "if", "show", ":", "\n", "        ", "mmcv", ".", "imshow", "(", "vis_img", ",", "win_name", ",", "wait_time", ")", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "vis_img", ",", "out_file", ")", "\n", "\n", "", "return", "vis_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.gen_color": [[449, 456], ["None"], "function", ["None"], ["", "def", "gen_color", "(", ")", ":", "\n", "    ", "\"\"\"Generate BGR color schemes.\"\"\"", "\n", "color_list", "=", "[", "(", "101", ",", "67", ",", "254", ")", ",", "(", "154", ",", "157", ",", "252", ")", ",", "(", "173", ",", "205", ",", "249", ")", ",", "\n", "(", "123", ",", "151", ",", "138", ")", ",", "(", "187", ",", "200", ",", "178", ")", ",", "(", "148", ",", "137", ",", "69", ")", ",", "\n", "(", "169", ",", "200", ",", "200", ")", ",", "(", "155", ",", "175", ",", "131", ")", ",", "(", "154", ",", "194", ",", "182", ")", ",", "\n", "(", "178", ",", "190", ",", "137", ")", ",", "(", "140", ",", "211", ",", "222", ")", ",", "(", "83", ",", "156", ",", "222", ")", "]", "\n", "return", "color_list", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_polygons": [[458, 480], ["img.copy", "visualize.gen_color", "enumerate", "numpy.array().reshape().astype", "cv2.drawContours", "cv2.addWeighted", "numpy.array", "numpy.array().reshape", "numpy.array", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.gen_color"], ["", "def", "draw_polygons", "(", "img", ",", "polys", ")", ":", "\n", "    ", "\"\"\"Draw polygons on image.\n\n    Args:\n        img (np.ndarray): The original image.\n        polys (list[list[float]]): Detected polygons.\n    Return:\n        out_img (np.ndarray): Visualized image.\n    \"\"\"", "\n", "dst_img", "=", "img", ".", "copy", "(", ")", "\n", "color_list", "=", "gen_color", "(", ")", "\n", "out_img", "=", "dst_img", "\n", "for", "idx", ",", "poly", "in", "enumerate", "(", "polys", ")", ":", "\n", "        ", "poly", "=", "np", ".", "array", "(", "poly", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "2", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "cv2", ".", "drawContours", "(", "\n", "img", ",", "\n", "np", ".", "array", "(", "[", "poly", "]", ")", ",", "\n", "-", "1", ",", "\n", "color_list", "[", "idx", "%", "len", "(", "color_list", ")", "]", ",", "\n", "thickness", "=", "cv2", ".", "FILLED", ")", "\n", "out_img", "=", "cv2", ".", "addWeighted", "(", "dst_img", ",", "0.5", ",", "img", ",", "0.5", ",", "0", ")", "\n", "", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.get_optimal_font_scale": [[482, 499], ["reversed", "range", "cv2.getTextSize"], "function", ["None"], ["", "def", "get_optimal_font_scale", "(", "text", ",", "width", ")", ":", "\n", "    ", "\"\"\"Get optimal font scale for cv2.putText.\n\n    Args:\n        text (str): Text in one box.\n        width (int): The box width.\n    \"\"\"", "\n", "for", "scale", "in", "reversed", "(", "range", "(", "0", ",", "60", ",", "1", ")", ")", ":", "\n", "        ", "textSize", "=", "cv2", ".", "getTextSize", "(", "\n", "text", ",", "\n", "fontFace", "=", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "\n", "fontScale", "=", "scale", "/", "10", ",", "\n", "thickness", "=", "1", ")", "\n", "new_width", "=", "textSize", "[", "0", "]", "[", "0", "]", "\n", "if", "new_width", "<=", "width", ":", "\n", "            ", "return", "scale", "/", "10", "\n", "", "", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts": [[501, 543], ["visualize.gen_color", "enumerate", "len", "len", "zip", "int", "int", "visualize.get_optimal_font_scale", "cv2.putText", "numpy.ones", "numpy.array", "cv2.polylines", "min", "int", "numpy.mean", "zip", "np.array.reshape", "numpy.array", "max", "min", "max", "min", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.gen_color", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.get_optimal_font_scale"], ["", "def", "draw_texts", "(", "img", ",", "texts", ",", "boxes", "=", "None", ",", "draw_box", "=", "True", ",", "on_ori_img", "=", "False", ")", ":", "\n", "    ", "\"\"\"Draw boxes and texts on empty img.\n\n    Args:\n        img (np.ndarray): The original image.\n        texts (list[str]): Recognized texts.\n        boxes (list[list[float]]): Detected bounding boxes.\n        draw_box (bool): Whether draw box or not. If False, draw text only.\n        on_ori_img (bool): If True, draw box and text on input image,\n            else, on a new empty image.\n    Return:\n        out_img (np.ndarray): Visualized image.\n    \"\"\"", "\n", "color_list", "=", "gen_color", "(", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "if", "boxes", "is", "None", ":", "\n", "        ", "boxes", "=", "[", "[", "0", ",", "0", ",", "w", ",", "0", ",", "w", ",", "h", ",", "0", ",", "h", "]", "]", "\n", "", "assert", "len", "(", "texts", ")", "==", "len", "(", "boxes", ")", "\n", "\n", "if", "on_ori_img", ":", "\n", "        ", "out_img", "=", "img", "\n", "", "else", ":", "\n", "        ", "out_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "", "for", "idx", ",", "(", "box", ",", "text", ")", "in", "enumerate", "(", "zip", "(", "boxes", ",", "texts", ")", ")", ":", "\n", "        ", "if", "draw_box", ":", "\n", "            ", "new_box", "=", "[", "[", "x", ",", "y", "]", "for", "x", ",", "y", "in", "zip", "(", "box", "[", "0", ":", ":", "2", "]", ",", "box", "[", "1", ":", ":", "2", "]", ")", "]", "\n", "Pts", "=", "np", ".", "array", "(", "[", "new_box", "]", ",", "np", ".", "int32", ")", "\n", "cv2", ".", "polylines", "(", "\n", "out_img", ",", "[", "Pts", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "2", ")", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "color_list", "[", "idx", "%", "len", "(", "color_list", ")", "]", ",", "\n", "thickness", "=", "1", ")", "\n", "", "min_x", "=", "int", "(", "min", "(", "box", "[", "0", ":", ":", "2", "]", ")", ")", "\n", "max_y", "=", "int", "(", "\n", "np", ".", "mean", "(", "np", ".", "array", "(", "box", "[", "1", ":", ":", "2", "]", ")", ")", "+", "0.2", "*", "\n", "(", "max", "(", "box", "[", "1", ":", ":", "2", "]", ")", "-", "min", "(", "box", "[", "1", ":", ":", "2", "]", ")", ")", ")", "\n", "font_scale", "=", "get_optimal_font_scale", "(", "\n", "text", ",", "int", "(", "max", "(", "box", "[", "0", ":", ":", "2", "]", ")", "-", "min", "(", "box", "[", "0", ":", ":", "2", "]", ")", ")", ")", "\n", "cv2", ".", "putText", "(", "out_img", ",", "text", ",", "(", "min_x", ",", "max_y", ")", ",", "cv2", ".", "FONT_HERSHEY_SIMPLEX", ",", "\n", "font_scale", ",", "(", "0", ",", "0", ",", "0", ")", ",", "1", ")", "\n", "\n", "", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil": [[545, 627], ["visualize.gen_color", "PIL.ImageDraw.Draw", "enumerate", "cv2.cvtColor", "len", "len", "len", "PIL.Image.fromarray", "PIL.Image.new", "zip", "tuple", "os.path.split", "os.path.join", "PIL.ImageFont.truetype", "ImageDraw.Draw.text", "text_sizes.append", "numpy.asarray", "cv2.cvtColor", "len", "min", "max", "min", "max", "ImageDraw.Draw.line", "os.path.abspath", "os.path.exists", "print", "urllib.request.urlretrieve", "shutil.move", "max", "int", "ImageFont.truetype.getsize", "list", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.gen_color"], ["", "def", "draw_texts_by_pil", "(", "img", ",", "\n", "texts", ",", "\n", "boxes", "=", "None", ",", "\n", "draw_box", "=", "True", ",", "\n", "on_ori_img", "=", "False", ",", "\n", "font_size", "=", "None", ",", "\n", "fill_color", "=", "None", ",", "\n", "draw_pos", "=", "None", ",", "\n", "return_text_size", "=", "False", ")", ":", "\n", "    ", "\"\"\"Draw boxes and texts on empty image, especially for Chinese.\n\n    Args:\n        img (np.ndarray): The original image.\n        texts (list[str]): Recognized texts.\n        boxes (list[list[float]]): Detected bounding boxes.\n        draw_box (bool): Whether draw box or not. If False, draw text only.\n        on_ori_img (bool): If True, draw box and text on input image,\n            else on a new empty image.\n        font_size (int, optional): Size to create a font object for a font.\n        fill_color (tuple(int), optional): Fill color for text.\n        draw_pos (list[tuple(int)], optional): Start point to draw each text.\n        return_text_size (bool): If True, return the list of text size.\n\n    Returns:\n        (np.ndarray, list[tuple]) or np.ndarray: Return a tuple\n        ``(out_img, text_sizes)``, where ``out_img`` is the output image\n        with texts drawn on it and ``text_sizes`` are the size of drawing\n        texts. If ``return_text_size`` is False, only the output image will be\n        returned.\n    \"\"\"", "\n", "\n", "color_list", "=", "gen_color", "(", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "if", "boxes", "is", "None", ":", "\n", "        ", "boxes", "=", "[", "[", "0", ",", "0", ",", "w", ",", "0", ",", "w", ",", "h", ",", "0", ",", "h", "]", "]", "\n", "", "if", "draw_pos", "is", "None", ":", "\n", "        ", "draw_pos", "=", "[", "None", "for", "_", "in", "texts", "]", "\n", "", "assert", "len", "(", "boxes", ")", "==", "len", "(", "texts", ")", "==", "len", "(", "draw_pos", ")", "\n", "\n", "if", "fill_color", "is", "None", ":", "\n", "        ", "fill_color", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "\n", "", "if", "on_ori_img", ":", "\n", "        ", "out_img", "=", "Image", ".", "fromarray", "(", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2RGB", ")", ")", "\n", "", "else", ":", "\n", "        ", "out_img", "=", "Image", ".", "new", "(", "'RGB'", ",", "(", "w", ",", "h", ")", ",", "color", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "", "out_draw", "=", "ImageDraw", ".", "Draw", "(", "out_img", ")", "\n", "\n", "text_sizes", "=", "[", "]", "\n", "for", "idx", ",", "(", "box", ",", "text", ",", "ori_point", ")", "in", "enumerate", "(", "zip", "(", "boxes", ",", "texts", ",", "draw_pos", ")", ")", ":", "\n", "        ", "if", "len", "(", "text", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "min_x", ",", "max_x", "=", "min", "(", "box", "[", "0", ":", ":", "2", "]", ")", ",", "max", "(", "box", "[", "0", ":", ":", "2", "]", ")", "\n", "min_y", ",", "max_y", "=", "min", "(", "box", "[", "1", ":", ":", "2", "]", ")", ",", "max", "(", "box", "[", "1", ":", ":", "2", "]", ")", "\n", "color", "=", "tuple", "(", "list", "(", "color_list", "[", "idx", "%", "len", "(", "color_list", ")", "]", ")", "[", ":", ":", "-", "1", "]", ")", "\n", "if", "draw_box", ":", "\n", "            ", "out_draw", ".", "line", "(", "box", ",", "fill", "=", "color", ",", "width", "=", "1", ")", "\n", "", "dirname", ",", "_", "=", "os", ".", "path", ".", "split", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", "\n", "font_path", "=", "os", ".", "path", ".", "join", "(", "dirname", ",", "'font.TTF'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "font_path", ")", ":", "\n", "            ", "url", "=", "(", "'https://download.openmmlab.com/mmocr/data/font.TTF'", ")", "\n", "print", "(", "f'Downloading {url} ...'", ")", "\n", "local_filename", ",", "_", "=", "urllib", ".", "request", ".", "urlretrieve", "(", "url", ")", "\n", "shutil", ".", "move", "(", "local_filename", ",", "font_path", ")", "\n", "", "tmp_font_size", "=", "font_size", "\n", "if", "tmp_font_size", "is", "None", ":", "\n", "            ", "box_width", "=", "max", "(", "max_x", "-", "min_x", ",", "max_y", "-", "min_y", ")", "\n", "tmp_font_size", "=", "int", "(", "0.9", "*", "box_width", "/", "len", "(", "text", ")", ")", "\n", "", "fnt", "=", "ImageFont", ".", "truetype", "(", "font_path", ",", "tmp_font_size", ")", "\n", "if", "ori_point", "is", "None", ":", "\n", "            ", "ori_point", "=", "(", "min_x", "+", "1", ",", "min_y", "+", "1", ")", "\n", "", "out_draw", ".", "text", "(", "ori_point", ",", "text", ",", "font", "=", "fnt", ",", "fill", "=", "fill_color", ")", "\n", "text_sizes", ".", "append", "(", "fnt", ".", "getsize", "(", "text", ")", ")", "\n", "\n", "", "del", "out_draw", "\n", "\n", "out_img", "=", "cv2", ".", "cvtColor", "(", "np", ".", "asarray", "(", "out_img", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "\n", "if", "return_text_size", ":", "\n", "        ", "return", "out_img", ",", "text_sizes", "\n", "\n", "", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.is_contain_chinese": [[629, 641], ["None"], "function", ["None"], ["", "def", "is_contain_chinese", "(", "check_str", ")", ":", "\n", "    ", "\"\"\"Check whether string contains Chinese or not.\n\n    Args:\n        check_str (str): String to be checked.\n\n    Return True if contains Chinese, else False.\n    \"\"\"", "\n", "for", "ch", "in", "check_str", ":", "\n", "        ", "if", "u'\\u4e00'", "<=", "ch", "<=", "u'\\u9fff'", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.det_recog_show_result": [[643, 674], ["mmcv.imread", "visualize.draw_polygons", "visualize.is_contain_chinese", "numpy.ones", "boxes.append", "texts.append", "visualize.draw_texts_by_pil", "visualize.draw_texts", "mmcv.imwrite"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_polygons", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.is_contain_chinese", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts"], ["", "def", "det_recog_show_result", "(", "img", ",", "end2end_res", ",", "out_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Draw `result`(boxes and texts) on `img`.\n\n    Args:\n        img (str or np.ndarray): The image to be displayed.\n        end2end_res (dict): Text detect and recognize results.\n        out_file (str): Image path where the visualized image should be saved.\n    Return:\n        out_img (np.ndarray): Visualized image.\n    \"\"\"", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "boxes", ",", "texts", "=", "[", "]", ",", "[", "]", "\n", "for", "res", "in", "end2end_res", "[", "'result'", "]", ":", "\n", "        ", "boxes", ".", "append", "(", "res", "[", "'box'", "]", ")", "\n", "texts", ".", "append", "(", "res", "[", "'text'", "]", ")", "\n", "", "box_vis_img", "=", "draw_polygons", "(", "img", ",", "boxes", ")", "\n", "\n", "if", "is_contain_chinese", "(", "''", ".", "join", "(", "texts", ")", ")", ":", "\n", "        ", "text_vis_img", "=", "draw_texts_by_pil", "(", "img", ",", "texts", ",", "boxes", ")", "\n", "", "else", ":", "\n", "        ", "text_vis_img", "=", "draw_texts", "(", "img", ",", "texts", ",", "boxes", ")", "\n", "\n", "", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "out_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", "*", "2", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "out_img", "[", ":", ",", ":", "w", ",", ":", "]", "=", "box_vis_img", "\n", "out_img", "[", ":", ",", "w", ":", ",", ":", "]", "=", "text_vis_img", "\n", "\n", "if", "out_file", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "out_img", ",", "out_file", ")", "\n", "\n", "", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_edge_result": [[676, 820], ["result[].detach().cpu", "result[].size", "[].view", "result_pairs.sort", "zip", "numpy.ones", "pairs[].numpy().tolist", "pairs[].numpy().tolist", "torch.max", "cv2.putText", "visualize.draw_texts_by_pil", "result[].detach", "zip", "visualize.draw_texts_by_pil", "cv2.arrowedLine", "int", "cv2.arrowedLine", "int", "int", "result[].detach().cpu", "torch.max", "pairs[].numpy", "pairs[].numpy", "int", "numpy.ones", "numpy.ones", "result[].detach"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_texts_by_pil"], ["", "def", "draw_edge_result", "(", "img", ",", "result", ",", "edge_thresh", "=", "0.5", ",", "keynode_thresh", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Draw text and their relationship on empty images.\n\n    Args:\n        img (np.ndarray): The original image.\n        result (dict): The result of model forward_test, including:\n            - img_metas (list[dict]): List of meta information dictionary.\n            - nodes (Tensor): Node prediction with size:\n                number_node * node_classes.\n            - edges (Tensor): Edge prediction with size: number_edge * 2.\n        edge_thresh (float): Score threshold for edge classification.\n        keynode_thresh (float): Score threshold for node\n            (``key``) classification.\n\n    Returns:\n        np.ndarray: The image with key, value and relation drawn on it.\n    \"\"\"", "\n", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "\n", "vis_area_width", "=", "w", "//", "3", "*", "2", "\n", "vis_area_height", "=", "h", "\n", "dist_key_to_value", "=", "vis_area_width", "//", "2", "\n", "dist_pair_to_pair", "=", "30", "\n", "\n", "bbox_x1", "=", "dist_pair_to_pair", "\n", "bbox_y1", "=", "0", "\n", "\n", "new_w", "=", "vis_area_width", "\n", "new_h", "=", "vis_area_height", "\n", "pred_edge_img", "=", "np", ".", "ones", "(", "(", "new_h", ",", "new_w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "\n", "nodes", "=", "result", "[", "'nodes'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "texts", "=", "result", "[", "'img_metas'", "]", "[", "0", "]", "[", "'ori_texts'", "]", "\n", "num_nodes", "=", "result", "[", "'nodes'", "]", ".", "size", "(", "0", ")", "\n", "edges", "=", "result", "[", "'edges'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", "[", ":", ",", "-", "1", "]", ".", "view", "(", "num_nodes", ",", "num_nodes", ")", "\n", "\n", "# (i, j) will be a valid pair", "\n", "# either edge_score(node_i->node_j) > edge_thresh", "\n", "# or edge_score(node_j->node_i) > edge_thresh", "\n", "pairs", "=", "(", "torch", ".", "max", "(", "edges", ",", "edges", ".", "T", ")", ">", "edge_thresh", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "\n", "pairs", "=", "(", "pairs", "[", "0", "]", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ",", "pairs", "[", "1", "]", ".", "numpy", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "# 1. \"for n1, n2 in zip(*pairs) if n1 < n2\":", "\n", "#     Only (n1, n2) will be included if n1 < n2 but not (n2, n1), to", "\n", "#     avoid duplication.", "\n", "# 2. \"(n1, n2) if nodes[n1, 1] > nodes[n1, 2]\":", "\n", "#     nodes[n1, 1] is the score that this node is predicted as key,", "\n", "#     nodes[n1, 2] is the score that this node is predicted as value.", "\n", "#     If nodes[n1, 1] > nodes[n1, 2], n1 will be the index of key,", "\n", "#     so that n2 will be the index of value.", "\n", "result_pairs", "=", "[", "(", "n1", ",", "n2", ")", "if", "nodes", "[", "n1", ",", "1", "]", ">", "nodes", "[", "n1", ",", "2", "]", "else", "(", "n2", ",", "n1", ")", "\n", "for", "n1", ",", "n2", "in", "zip", "(", "*", "pairs", ")", "if", "n1", "<", "n2", "]", "\n", "\n", "result_pairs", ".", "sort", "(", ")", "\n", "result_pairs_score", "=", "[", "\n", "torch", ".", "max", "(", "edges", "[", "n1", ",", "n2", "]", ",", "edges", "[", "n2", ",", "n1", "]", ")", "for", "n1", ",", "n2", "in", "result_pairs", "\n", "]", "\n", "\n", "key_current_idx", "=", "-", "1", "\n", "pos_current", "=", "(", "-", "1", ",", "-", "1", ")", "\n", "newline_flag", "=", "False", "\n", "\n", "key_font_size", "=", "15", "\n", "value_font_size", "=", "15", "\n", "key_font_color", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "value_font_color", "=", "(", "0", ",", "0", ",", "255", ")", "\n", "arrow_color", "=", "(", "0", ",", "0", ",", "255", ")", "\n", "score_color", "=", "(", "0", ",", "255", ",", "0", ")", "\n", "for", "pair", ",", "pair_score", "in", "zip", "(", "result_pairs", ",", "result_pairs_score", ")", ":", "\n", "        ", "key_idx", "=", "pair", "[", "0", "]", "\n", "if", "nodes", "[", "key_idx", ",", "1", "]", "<", "keynode_thresh", ":", "\n", "            ", "continue", "\n", "", "if", "key_idx", "!=", "key_current_idx", ":", "\n", "# move y-coords down for a new key", "\n", "            ", "bbox_y1", "+=", "10", "\n", "# enlarge blank area to show key-value info", "\n", "if", "newline_flag", ":", "\n", "                ", "bbox_x1", "+=", "vis_area_width", "\n", "tmp_img", "=", "np", ".", "ones", "(", "\n", "(", "new_h", ",", "new_w", "+", "vis_area_width", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "tmp_img", "[", ":", "new_h", ",", ":", "new_w", "]", "=", "pred_edge_img", "\n", "pred_edge_img", "=", "tmp_img", "\n", "new_w", "+=", "vis_area_width", "\n", "newline_flag", "=", "False", "\n", "bbox_y1", "=", "10", "\n", "", "", "key_text", "=", "texts", "[", "key_idx", "]", "\n", "key_pos", "=", "(", "bbox_x1", ",", "bbox_y1", ")", "\n", "value_idx", "=", "pair", "[", "1", "]", "\n", "value_text", "=", "texts", "[", "value_idx", "]", "\n", "value_pos", "=", "(", "bbox_x1", "+", "dist_key_to_value", ",", "bbox_y1", ")", "\n", "if", "key_idx", "!=", "key_current_idx", ":", "\n", "# draw text for a new key", "\n", "            ", "key_current_idx", "=", "key_idx", "\n", "pred_edge_img", ",", "text_sizes", "=", "draw_texts_by_pil", "(", "\n", "pred_edge_img", ",", "[", "key_text", "]", ",", "\n", "draw_box", "=", "False", ",", "\n", "on_ori_img", "=", "True", ",", "\n", "font_size", "=", "key_font_size", ",", "\n", "fill_color", "=", "key_font_color", ",", "\n", "draw_pos", "=", "[", "key_pos", "]", ",", "\n", "return_text_size", "=", "True", ")", "\n", "pos_right_bottom", "=", "(", "key_pos", "[", "0", "]", "+", "text_sizes", "[", "0", "]", "[", "0", "]", ",", "\n", "key_pos", "[", "1", "]", "+", "text_sizes", "[", "0", "]", "[", "1", "]", ")", "\n", "pos_current", "=", "(", "pos_right_bottom", "[", "0", "]", "+", "5", ",", "bbox_y1", "+", "10", ")", "\n", "pred_edge_img", "=", "cv2", ".", "arrowedLine", "(", "\n", "pred_edge_img", ",", "(", "pos_right_bottom", "[", "0", "]", "+", "5", ",", "bbox_y1", "+", "10", ")", ",", "\n", "(", "bbox_x1", "+", "dist_key_to_value", "-", "5", ",", "bbox_y1", "+", "10", ")", ",", "arrow_color", ",", "\n", "1", ")", "\n", "score_pos_x", "=", "int", "(", "\n", "(", "pos_right_bottom", "[", "0", "]", "+", "bbox_x1", "+", "dist_key_to_value", ")", "/", "2.", ")", "\n", "score_pos_y", "=", "bbox_y1", "+", "10", "-", "int", "(", "key_font_size", "*", "0.3", ")", "\n", "", "else", ":", "\n", "# draw arrow from key to value", "\n", "            ", "if", "newline_flag", ":", "\n", "                ", "tmp_img", "=", "np", ".", "ones", "(", "(", "new_h", "+", "dist_pair_to_pair", ",", "new_w", ",", "3", ")", ",", "\n", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "tmp_img", "[", ":", "new_h", ",", ":", "new_w", "]", "=", "pred_edge_img", "\n", "pred_edge_img", "=", "tmp_img", "\n", "new_h", "+=", "dist_pair_to_pair", "\n", "", "pred_edge_img", "=", "cv2", ".", "arrowedLine", "(", "pred_edge_img", ",", "pos_current", ",", "\n", "(", "bbox_x1", "+", "dist_key_to_value", "-", "5", ",", "\n", "bbox_y1", "+", "10", ")", ",", "arrow_color", ",", "1", ")", "\n", "score_pos_x", "=", "int", "(", "\n", "(", "pos_current", "[", "0", "]", "+", "bbox_x1", "+", "dist_key_to_value", "-", "5", ")", "/", "2.", ")", "\n", "score_pos_y", "=", "int", "(", "(", "pos_current", "[", "1", "]", "+", "bbox_y1", "+", "10", ")", "/", "2.", ")", "\n", "# draw edge score", "\n", "", "cv2", ".", "putText", "(", "pred_edge_img", ",", "'{:.2f}'", ".", "format", "(", "pair_score", ")", ",", "\n", "(", "score_pos_x", ",", "score_pos_y", ")", ",", "cv2", ".", "FONT_HERSHEY_COMPLEX", ",", "0.4", ",", "\n", "score_color", ")", "\n", "# draw text for value", "\n", "pred_edge_img", "=", "draw_texts_by_pil", "(", "\n", "pred_edge_img", ",", "[", "value_text", "]", ",", "\n", "draw_box", "=", "False", ",", "\n", "on_ori_img", "=", "True", ",", "\n", "font_size", "=", "value_font_size", ",", "\n", "fill_color", "=", "value_font_color", ",", "\n", "draw_pos", "=", "[", "value_pos", "]", ",", "\n", "return_text_size", "=", "False", ")", "\n", "bbox_y1", "+=", "dist_pair_to_pair", "\n", "if", "bbox_y1", "+", "dist_pair_to_pair", ">=", "new_h", ":", "\n", "            ", "newline_flag", "=", "True", "\n", "\n", "", "", "return", "pred_edge_img", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_edge": [[822, 889], ["mmcv.imread", "visualize.gen_color", "enumerate", "visualize.draw_edge_result", "max", "numpy.zeros", "numpy.array", "cv2.polylines", "mmcv.imshow", "mmcv.imwrite", "mmcv.dump", "result[].detach().cpu", "result[].detach().cpu", "np.array.reshape", "result[].detach", "result[].detach", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.gen_color", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.draw_edge_result"], ["", "def", "imshow_edge", "(", "img", ",", "\n", "result", ",", "\n", "boxes", ",", "\n", "show", "=", "False", ",", "\n", "win_name", "=", "''", ",", "\n", "wait_time", "=", "-", "1", ",", "\n", "out_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Display the prediction results of the nodes and edges of the KIE model.\n\n    Args:\n        img (np.ndarray): The original image.\n        result (dict): The result of model forward_test, including:\n            - img_metas (list[dict]): List of meta information dictionary.\n            - nodes (Tensor): Node prediction with size: \\\n                number_node * node_classes.\n            - edges (Tensor): Edge prediction with size: number_edge * 2.\n        boxes (list): The text boxes corresponding to the nodes.\n        show (bool): Whether to show the image. Default: False.\n        win_name (str): The window name. Default: ''\n        wait_time (float): Value of waitKey param. Default: 0.\n        out_file (str or None): The filename to write the image.\n            Default: None.\n\n    Returns:\n        np.ndarray: The image with key, value and relation drawn on it.\n    \"\"\"", "\n", "img", "=", "mmcv", ".", "imread", "(", "img", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "color_list", "=", "gen_color", "(", ")", "\n", "\n", "for", "i", ",", "box", "in", "enumerate", "(", "boxes", ")", ":", "\n", "        ", "new_box", "=", "[", "[", "box", "[", "0", "]", ",", "box", "[", "1", "]", "]", ",", "[", "box", "[", "2", "]", ",", "box", "[", "1", "]", "]", ",", "[", "box", "[", "2", "]", ",", "box", "[", "3", "]", "]", ",", "\n", "[", "box", "[", "0", "]", ",", "box", "[", "3", "]", "]", "]", "\n", "Pts", "=", "np", ".", "array", "(", "[", "new_box", "]", ",", "np", ".", "int32", ")", "\n", "cv2", ".", "polylines", "(", "\n", "img", ",", "[", "Pts", ".", "reshape", "(", "(", "-", "1", ",", "1", ",", "2", ")", ")", "]", ",", "\n", "True", ",", "\n", "color", "=", "color_list", "[", "i", "%", "len", "(", "color_list", ")", "]", ",", "\n", "thickness", "=", "1", ")", "\n", "\n", "", "pred_img_h", "=", "h", "\n", "pred_img_w", "=", "w", "\n", "\n", "pred_edge_img", "=", "draw_edge_result", "(", "img", ",", "result", ")", "\n", "pred_img_h", "=", "max", "(", "pred_img_h", ",", "pred_edge_img", ".", "shape", "[", "0", "]", ")", "\n", "pred_img_w", "+=", "pred_edge_img", ".", "shape", "[", "1", "]", "\n", "\n", "vis_img", "=", "np", ".", "zeros", "(", "(", "pred_img_h", ",", "pred_img_w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "vis_img", "[", ":", "h", ",", ":", "w", "]", "=", "img", "\n", "vis_img", "[", ":", ",", "w", ":", "]", "=", "255", "\n", "\n", "height_t", ",", "width_t", "=", "pred_edge_img", ".", "shape", "[", ":", "2", "]", "\n", "vis_img", "[", ":", "height_t", ",", "w", ":", "(", "w", "+", "width_t", ")", "]", "=", "pred_edge_img", "\n", "\n", "if", "show", ":", "\n", "        ", "mmcv", ".", "imshow", "(", "vis_img", ",", "win_name", ",", "wait_time", ")", "\n", "", "if", "out_file", "is", "not", "None", ":", "\n", "        ", "mmcv", ".", "imwrite", "(", "vis_img", ",", "out_file", ")", "\n", "res_dic", "=", "{", "\n", "'boxes'", ":", "boxes", ",", "\n", "'nodes'", ":", "result", "[", "'nodes'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "'edges'", ":", "result", "[", "'edges'", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ",", "\n", "'metas'", ":", "result", "[", "'img_metas'", "]", "[", "0", "]", "\n", "}", "\n", "mmcv", ".", "dump", "(", "res_dic", ",", "f'{out_file}_res.pkl'", ")", "\n", "\n", "", "return", "vis_img", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary": [[8, 52], ["isinstance", "cv2.minAreaRect", "cv2.boxPoints", "len", "min", "numpy.zeros", "cv2.findContours", "list", "numpy.max", "numpy.max", "contours[].flatten().tolist", "cv2.boxPoints.flatten().tolist", "contours[].flatten", "cv2.boxPoints.flatten"], "function", ["None"], ["def", "points2boundary", "(", "points", ",", "text_repr_type", ",", "text_score", "=", "None", ",", "min_width", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"Convert a text mask represented by point coordinates sequence into a\n    text boundary.\n\n    Args:\n        points (ndarray): Mask index of size (n, 2).\n        text_repr_type (str): Text instance encoding type\n            ('quad' for quadrangle or 'poly' for polygon).\n        text_score (float): Text score.\n\n    Returns:\n        boundary (list[float]): The text boundary point coordinates (x, y)\n            list. Return None if no text boundary found.\n    \"\"\"", "\n", "assert", "isinstance", "(", "points", ",", "np", ".", "ndarray", ")", "\n", "assert", "points", ".", "shape", "[", "1", "]", "==", "2", "\n", "assert", "text_repr_type", "in", "[", "'quad'", ",", "'poly'", "]", "\n", "assert", "text_score", "is", "None", "or", "0", "<=", "text_score", "<=", "1", "\n", "\n", "if", "text_repr_type", "==", "'quad'", ":", "\n", "        ", "rect", "=", "cv2", ".", "minAreaRect", "(", "points", ")", "\n", "vertices", "=", "cv2", ".", "boxPoints", "(", "rect", ")", "\n", "boundary", "=", "[", "]", "\n", "if", "min", "(", "rect", "[", "1", "]", ")", ">", "min_width", ":", "\n", "            ", "boundary", "=", "[", "p", "for", "p", "in", "vertices", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "]", "\n", "\n", "", "", "elif", "text_repr_type", "==", "'poly'", ":", "\n", "\n", "        ", "height", "=", "np", ".", "max", "(", "points", "[", ":", ",", "1", "]", ")", "+", "10", "\n", "width", "=", "np", ".", "max", "(", "points", "[", ":", ",", "0", "]", ")", "+", "10", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ")", ",", "np", ".", "uint8", ")", "\n", "mask", "[", "points", "[", ":", ",", "1", "]", ",", "points", "[", ":", ",", "0", "]", "]", "=", "255", "\n", "\n", "contours", ",", "_", "=", "cv2", ".", "findContours", "(", "mask", ",", "cv2", ".", "RETR_EXTERNAL", ",", "\n", "cv2", ".", "CHAIN_APPROX_SIMPLE", ")", "\n", "boundary", "=", "list", "(", "contours", "[", "0", "]", ".", "flatten", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "", "if", "text_score", "is", "not", "None", ":", "\n", "        ", "boundary", "=", "boundary", "+", "[", "text_score", "]", "\n", "", "if", "len", "(", "boundary", ")", "<", "8", ":", "\n", "        ", "return", "None", "\n", "\n", "", "return", "boundary", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.seg2boundary": [[54, 78], ["isinstance", "isinstance", "numpy.where", "numpy.concatenate().reshape().transpose", "len", "mask.points2boundary", "numpy.concatenate().reshape", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary"], ["", "def", "seg2boundary", "(", "seg", ",", "text_repr_type", ",", "text_score", "=", "None", ")", ":", "\n", "    ", "\"\"\"Convert a segmentation mask to a text boundary.\n\n    Args:\n        seg (ndarray): The segmentation mask.\n        text_repr_type (str): Text instance encoding type\n            ('quad' for quadrangle or 'poly' for polygon).\n        text_score (float): The text score.\n\n    Returns:\n        boundary (list): The text boundary. Return None if no text found.\n    \"\"\"", "\n", "assert", "isinstance", "(", "seg", ",", "np", ".", "ndarray", ")", "\n", "assert", "isinstance", "(", "text_repr_type", ",", "str", ")", "\n", "assert", "text_score", "is", "None", "or", "0", "<=", "text_score", "<=", "1", "\n", "\n", "points", "=", "np", ".", "where", "(", "seg", ")", "\n", "# x, y order", "\n", "points", "=", "np", ".", "concatenate", "(", "[", "points", "[", "1", "]", ",", "points", "[", "0", "]", "]", ")", ".", "reshape", "(", "2", ",", "-", "1", ")", ".", "transpose", "(", ")", "\n", "boundary", "=", "None", "\n", "if", "len", "(", "points", ")", "!=", "0", ":", "\n", "        ", "boundary", "=", "points2boundary", "(", "points", ",", "text_repr_type", ",", "text_score", ")", "\n", "\n", "", "return", "boundary", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.extract_boundary": [[80, 103], ["isinstance", "mmocr.is_2dlist", "result.keys"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "extract_boundary", "(", "result", ")", ":", "\n", "    ", "\"\"\"Extract boundaries and their scores from result.\n\n    Args:\n        result (dict): The detection result with the key 'boundary_result'\n            of one image.\n\n    Returns:\n        boundaries_with_scores (list[list[float]]): The boundary and score\n            list.\n        boundaries (list[list[float]]): The boundary list.\n        scores (list[float]): The boundary score list.\n    \"\"\"", "\n", "assert", "isinstance", "(", "result", ",", "dict", ")", "\n", "assert", "'boundary_result'", "in", "result", ".", "keys", "(", ")", "\n", "\n", "boundaries_with_scores", "=", "result", "[", "'boundary_result'", "]", "\n", "assert", "utils", ".", "is_2dlist", "(", "boundaries_with_scores", ")", "\n", "\n", "boundaries", "=", "[", "b", "[", ":", "-", "1", "]", "for", "b", "in", "boundaries_with_scores", "]", "\n", "scores", "=", "[", "b", "[", "-", "1", "]", "for", "b", "in", "boundaries_with_scores", "]", "\n", "\n", "return", "(", "boundaries_with_scores", ",", "boundaries", ",", "scores", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou": [[8, 118], ["mmocr.is_3dlist", "mmocr.is_3dlist", "mmocr.is_3dlist", "len", "range", "utils.compute_hmean", "len", "len", "len", "len", "len", "len", "utils.ignore_pred", "utils.compute_hmean", "img_results.append", "utils.points2polygon", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "range", "len", "range", "range", "range", "len", "utils.poly_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou"], ["def", "eval_hmean_iou", "(", "pred_boxes", ",", "\n", "gt_boxes", ",", "\n", "gt_ignored_boxes", ",", "\n", "iou_thr", "=", "0.5", ",", "\n", "precision_thr", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Evaluate hmean of text detection using IOU standard.\n\n    Args:\n        pred_boxes (list[list[list[float]]]): Text boxes for an img list. Each\n            box has 2k (>=8) values.\n        gt_boxes (list[list[list[float]]]): Ground truth text boxes for an img\n            list. Each box has 2k (>=8) values.\n        gt_ignored_boxes (list[list[list[float]]]): Ignored ground truth text\n            boxes for an img list. Each box has 2k (>=8) values.\n        iou_thr (float): Iou threshold when one (gt_box, det_box) pair is\n            matched.\n        precision_thr (float): Precision threshold when one (gt_box, det_box)\n            pair is matched.\n\n    Returns:\n        hmean (tuple[dict]): Tuple of dicts indicates the hmean for the dataset\n            and all images.\n    \"\"\"", "\n", "assert", "utils", ".", "is_3dlist", "(", "pred_boxes", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "gt_boxes", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "gt_ignored_boxes", ")", "\n", "assert", "0", "<=", "iou_thr", "<=", "1", "\n", "assert", "0", "<=", "precision_thr", "<=", "1", "\n", "\n", "img_num", "=", "len", "(", "pred_boxes", ")", "\n", "assert", "img_num", "==", "len", "(", "gt_boxes", ")", "\n", "assert", "img_num", "==", "len", "(", "gt_ignored_boxes", ")", "\n", "\n", "dataset_gt_num", "=", "0", "\n", "dataset_pred_num", "=", "0", "\n", "dataset_hit_num", "=", "0", "\n", "\n", "img_results", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "img_num", ")", ":", "\n", "        ", "gt", "=", "gt_boxes", "[", "i", "]", "\n", "gt_ignored", "=", "gt_ignored_boxes", "[", "i", "]", "\n", "pred", "=", "pred_boxes", "[", "i", "]", "\n", "\n", "gt_num", "=", "len", "(", "gt", ")", "\n", "gt_ignored_num", "=", "len", "(", "gt_ignored", ")", "\n", "pred_num", "=", "len", "(", "pred", ")", "\n", "\n", "hit_num", "=", "0", "\n", "\n", "# get gt polygons.", "\n", "gt_all", "=", "gt", "+", "gt_ignored", "\n", "gt_polys", "=", "[", "eval_utils", ".", "points2polygon", "(", "p", ")", "for", "p", "in", "gt_all", "]", "\n", "gt_ignored_index", "=", "[", "gt_num", "+", "i", "for", "i", "in", "range", "(", "len", "(", "gt_ignored", ")", ")", "]", "\n", "gt_num", "=", "len", "(", "gt_polys", ")", "\n", "pred_polys", ",", "_", ",", "pred_ignored_index", "=", "eval_utils", ".", "ignore_pred", "(", "\n", "pred", ",", "gt_ignored_index", ",", "gt_polys", ",", "precision_thr", ")", "\n", "\n", "# match.", "\n", "if", "gt_num", ">", "0", "and", "pred_num", ">", "0", ":", "\n", "            ", "sz", "=", "[", "gt_num", ",", "pred_num", "]", "\n", "iou_mat", "=", "np", ".", "zeros", "(", "sz", ")", "\n", "\n", "gt_hit", "=", "np", ".", "zeros", "(", "gt_num", ",", "np", ".", "int8", ")", "\n", "pred_hit", "=", "np", ".", "zeros", "(", "pred_num", ",", "np", ".", "int8", ")", "\n", "\n", "for", "gt_id", "in", "range", "(", "gt_num", ")", ":", "\n", "                ", "for", "pred_id", "in", "range", "(", "pred_num", ")", ":", "\n", "                    ", "gt_pol", "=", "gt_polys", "[", "gt_id", "]", "\n", "det_pol", "=", "pred_polys", "[", "pred_id", "]", "\n", "\n", "iou_mat", "[", "gt_id", ",", "\n", "pred_id", "]", "=", "eval_utils", ".", "poly_iou", "(", "det_pol", ",", "gt_pol", ")", "\n", "\n", "", "", "for", "gt_id", "in", "range", "(", "gt_num", ")", ":", "\n", "                ", "for", "pred_id", "in", "range", "(", "pred_num", ")", ":", "\n", "                    ", "if", "(", "gt_hit", "[", "gt_id", "]", "!=", "0", "or", "pred_hit", "[", "pred_id", "]", "!=", "0", "\n", "or", "gt_id", "in", "gt_ignored_index", "\n", "or", "pred_id", "in", "pred_ignored_index", ")", ":", "\n", "                        ", "continue", "\n", "", "if", "iou_mat", "[", "gt_id", ",", "pred_id", "]", ">", "iou_thr", ":", "\n", "                        ", "gt_hit", "[", "gt_id", "]", "=", "1", "\n", "pred_hit", "[", "pred_id", "]", "=", "1", "\n", "hit_num", "+=", "1", "\n", "\n", "", "", "", "", "gt_care_number", "=", "gt_num", "-", "gt_ignored_num", "\n", "pred_care_number", "=", "pred_num", "-", "len", "(", "pred_ignored_index", ")", "\n", "\n", "r", ",", "p", ",", "h", "=", "eval_utils", ".", "compute_hmean", "(", "hit_num", ",", "hit_num", ",", "gt_care_number", ",", "\n", "pred_care_number", ")", "\n", "\n", "img_results", ".", "append", "(", "{", "'recall'", ":", "r", ",", "'precision'", ":", "p", ",", "'hmean'", ":", "h", "}", ")", "\n", "\n", "dataset_hit_num", "+=", "hit_num", "\n", "dataset_gt_num", "+=", "gt_care_number", "\n", "dataset_pred_num", "+=", "pred_care_number", "\n", "\n", "", "dataset_r", ",", "dataset_p", ",", "dataset_h", "=", "eval_utils", ".", "compute_hmean", "(", "\n", "dataset_hit_num", ",", "dataset_hit_num", ",", "dataset_gt_num", ",", "dataset_pred_num", ")", "\n", "\n", "dataset_results", "=", "{", "\n", "'num_gts'", ":", "dataset_gt_num", ",", "\n", "'num_dets'", ":", "dataset_pred_num", ",", "\n", "'num_match'", ":", "dataset_hit_num", ",", "\n", "'recall'", ":", "dataset_r", ",", "\n", "'precision'", ":", "dataset_p", ",", "\n", "'hmean'", ":", "dataset_h", "\n", "}", "\n", "\n", "return", "dataset_results", ",", "img_results", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.kie_metric.compute_f1_score": [[5, 29], ["preds.size", "torch.LongTensor", "torch.bincount().view().float", "torch.diag", "f1[].cpu().numpy", "sorted", "torch.bincount().view().float.sum().clamp", "torch.bincount().view().float.sum().clamp", "torch.bincount().view", "f1[].cpu", "set", "set", "torch.bincount().view().float.sum", "torch.bincount().view().float.sum", "range", "torch.bincount", "preds.argmax"], "function", ["None"], ["def", "compute_f1_score", "(", "preds", ",", "gts", ",", "ignores", "=", "[", "]", ")", ":", "\n", "    ", "\"\"\"Compute the F1-score of prediction.\n\n    Args:\n        preds (Tensor): The predicted probability NxC map\n            with N and C being the sample number and class\n            number respectively.\n        gts (Tensor): The ground truth vector of size N.\n        ignores (list): The index set of classes that are ignored when\n            reporting results.\n            Note: all samples are participated in computing.\n\n     Returns:\n        The numpy list of f1-scores of valid classes.\n    \"\"\"", "\n", "C", "=", "preds", ".", "size", "(", "1", ")", "\n", "classes", "=", "torch", ".", "LongTensor", "(", "sorted", "(", "set", "(", "range", "(", "C", ")", ")", "-", "set", "(", "ignores", ")", ")", ")", "\n", "hist", "=", "torch", ".", "bincount", "(", "\n", "gts", "*", "C", "+", "preds", ".", "argmax", "(", "1", ")", ",", "minlength", "=", "C", "**", "2", ")", ".", "view", "(", "C", ",", "C", ")", ".", "float", "(", ")", "\n", "diag", "=", "torch", ".", "diag", "(", "hist", ")", "\n", "recalls", "=", "diag", "/", "hist", ".", "sum", "(", "1", ")", ".", "clamp", "(", "min", "=", "1", ")", "\n", "precisions", "=", "diag", "/", "hist", ".", "sum", "(", "0", ")", ".", "clamp", "(", "min", "=", "1", ")", "\n", "f1", "=", "2", "*", "recalls", "*", "precisions", "/", "(", "recalls", "+", "precisions", ")", ".", "clamp", "(", "min", "=", "1e-8", ")", "\n", "return", "f1", "[", "classes", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric.gt_label2entity": [[5, 24], ["label.items", "gt_entities.append", "value.items", "line_entities.append"], "function", ["None"], ["def", "gt_label2entity", "(", "gt_infos", ")", ":", "\n", "    ", "\"\"\"Get all entities from ground truth infos.\n    Args:\n        gt_infos (list[dict]): Ground-truth information contains text and\n            label.\n    Returns:\n        gt_entities (list[list]): Original labeled entities in groundtruth.\n                    [[category,start_position,end_position]]\n    \"\"\"", "\n", "gt_entities", "=", "[", "]", "\n", "for", "gt_info", "in", "gt_infos", ":", "\n", "        ", "line_entities", "=", "[", "]", "\n", "label", "=", "gt_info", "[", "'label'", "]", "\n", "for", "key", ",", "value", "in", "label", ".", "items", "(", ")", ":", "\n", "            ", "for", "_", ",", "places", "in", "value", ".", "items", "(", ")", ":", "\n", "                ", "for", "place", "in", "places", ":", "\n", "                    ", "line_entities", ".", "append", "(", "[", "key", ",", "place", "[", "0", "]", ",", "place", "[", "1", "]", "]", ")", "\n", "", "", "", "gt_entities", ".", "append", "(", "line_entities", ")", "\n", "", "return", "gt_entities", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric._compute_f1": [[26, 44], ["None"], "function", ["None"], ["", "def", "_compute_f1", "(", "origin", ",", "found", ",", "right", ")", ":", "\n", "    ", "\"\"\"Calculate recall, precision, f1-score.\n\n    Args:\n        origin (int): Original entities in groundtruth.\n        found (int): Predicted entities from model.\n        right (int): Predicted entities that\n                        can match to the original annotation.\n    Returns:\n        recall (float): Metric of recall.\n        precision (float): Metric of precision.\n        f1 (float): Metric of f1-score.\n    \"\"\"", "\n", "recall", "=", "0", "if", "origin", "==", "0", "else", "(", "right", "/", "origin", ")", "\n", "precision", "=", "0", "if", "found", "==", "0", "else", "(", "right", "/", "found", ")", "\n", "f1", "=", "0.", "if", "recall", "+", "precision", "==", "0", "else", "(", "2", "*", "precision", "*", "recall", ")", "/", "(", "\n", "precision", "+", "recall", ")", "\n", "return", "recall", ",", "precision", ",", "f1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric.compute_f1_all": [[46, 91], ["enumerate", "collections.Counter", "collections.Counter", "collections.Counter", "collections.Counter.items", "len", "len", "len", "ner_metric._compute_f1", "origins.extend", "founds.extend", "rights.extend", "collections.Counter.get", "collections.Counter.get", "ner_metric._compute_f1"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric._compute_f1", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric._compute_f1"], ["", "def", "compute_f1_all", "(", "pred_entities", ",", "gt_entities", ")", ":", "\n", "    ", "\"\"\"Calculate precision, recall and F1-score for all categories.\n\n    Args:\n        pred_entities: The predicted entities from model.\n        gt_entities: The entities of ground truth file.\n    Returns:\n        class_info (dict): precision,recall, f1-score in total\n                        and each categories.\n    \"\"\"", "\n", "origins", "=", "[", "]", "\n", "founds", "=", "[", "]", "\n", "rights", "=", "[", "]", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "pred_entities", ")", ":", "\n", "        ", "origins", ".", "extend", "(", "gt_entities", "[", "i", "]", ")", "\n", "founds", ".", "extend", "(", "pred_entities", "[", "i", "]", ")", "\n", "rights", ".", "extend", "(", "[", "\n", "pre_entity", "for", "pre_entity", "in", "pred_entities", "[", "i", "]", "\n", "if", "pre_entity", "in", "gt_entities", "[", "i", "]", "\n", "]", ")", "\n", "\n", "", "class_info", "=", "{", "}", "\n", "origin_counter", "=", "Counter", "(", "[", "x", "[", "0", "]", "for", "x", "in", "origins", "]", ")", "\n", "found_counter", "=", "Counter", "(", "[", "x", "[", "0", "]", "for", "x", "in", "founds", "]", ")", "\n", "right_counter", "=", "Counter", "(", "[", "x", "[", "0", "]", "for", "x", "in", "rights", "]", ")", "\n", "for", "type_", ",", "count", "in", "origin_counter", ".", "items", "(", ")", ":", "\n", "        ", "origin", "=", "count", "\n", "found", "=", "found_counter", ".", "get", "(", "type_", ",", "0", ")", "\n", "right", "=", "right_counter", ".", "get", "(", "type_", ",", "0", ")", "\n", "recall", ",", "precision", ",", "f1", "=", "_compute_f1", "(", "origin", ",", "found", ",", "right", ")", "\n", "class_info", "[", "type_", "]", "=", "{", "\n", "'precision'", ":", "precision", ",", "\n", "'recall'", ":", "recall", ",", "\n", "'f1-score'", ":", "f1", "\n", "}", "\n", "", "origin", "=", "len", "(", "origins", ")", "\n", "found", "=", "len", "(", "founds", ")", "\n", "right", "=", "len", "(", "rights", ")", "\n", "recall", ",", "precision", ",", "f1", "=", "_compute_f1", "(", "origin", ",", "found", ",", "right", ")", "\n", "class_info", "[", "'all'", "]", "=", "{", "\n", "'precision'", ":", "precision", ",", "\n", "'recall'", ":", "recall", ",", "\n", "'f1-score'", ":", "f1", "\n", "}", "\n", "return", "class_info", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric.eval_ner_f1": [[93, 116], ["ner_metric.gt_label2entity", "enumerate", "ner_metric.compute_f1_all", "len", "len", "pred_entities.append", "len", "len", "line_entities.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric.gt_label2entity", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ner_metric.compute_f1_all"], ["", "def", "eval_ner_f1", "(", "results", ",", "gt_infos", ")", ":", "\n", "    ", "\"\"\"Evaluate for ner task.\n\n    Args:\n        results (list): Predict results of entities.\n        gt_infos (list[dict]): Ground-truth information which contains\n                            text and label.\n    Returns:\n        class_info (dict): precision,recall, f1-score of total\n                            and each catogory.\n    \"\"\"", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "gt_infos", ")", "\n", "gt_entities", "=", "gt_label2entity", "(", "gt_infos", ")", "\n", "pred_entities", "=", "[", "]", "\n", "for", "i", ",", "gt_info", "in", "enumerate", "(", "gt_infos", ")", ":", "\n", "        ", "line_entities", "=", "[", "]", "\n", "for", "result", "in", "results", "[", "i", "]", ":", "\n", "            ", "line_entities", ".", "append", "(", "result", ")", "\n", "", "pred_entities", ".", "append", "(", "line_entities", ")", "\n", "", "assert", "len", "(", "pred_entities", ")", "==", "len", "(", "gt_entities", ")", "\n", "class_info", "=", "compute_f1_all", "(", "pred_entities", ",", "gt_entities", ")", "\n", "\n", "return", "class_info", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.cal_true_positive_char": [[10, 29], ["difflib.SequenceMatcher", "difflib.SequenceMatcher.get_opcodes"], "function", ["None"], ["def", "cal_true_positive_char", "(", "pred", ",", "gt", ")", ":", "\n", "    ", "\"\"\"Calculate correct character number in prediction.\n\n    Args:\n        pred (str): Prediction text.\n        gt (str): Ground truth text.\n\n    Returns:\n        true_positive_char_num (int): The true positive number.\n    \"\"\"", "\n", "\n", "all_opt", "=", "SequenceMatcher", "(", "None", ",", "pred", ",", "gt", ")", "\n", "true_positive_char_num", "=", "0", "\n", "for", "opt", ",", "_", ",", "_", ",", "s2", ",", "e2", "in", "all_opt", ".", "get_opcodes", "(", ")", ":", "\n", "        ", "if", "opt", "==", "'equal'", ":", "\n", "            ", "true_positive_char_num", "+=", "(", "e2", "-", "s2", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "", "", "return", "true_positive_char_num", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.count_matches": [[31, 80], ["re.compile", "zip", "gt_text.lower", "pred_text.lower", "re.compile.sub", "re.compile.sub", "rapidfuzz.distance.Levenshtein.normalized_distance", "len", "len", "ocr_metric.cal_true_positive_char", "max", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.cal_true_positive_char"], ["", "def", "count_matches", "(", "pred_texts", ",", "gt_texts", ")", ":", "\n", "    ", "\"\"\"Count the various match number for metric calculation.\n\n    Args:\n        pred_texts (list[str]): Predicted text string.\n        gt_texts (list[str]): Ground truth text string.\n\n    Returns:\n        match_res: (dict[str: int]): Match number used for\n            metric calculation.\n    \"\"\"", "\n", "match_res", "=", "{", "\n", "'gt_char_num'", ":", "0", ",", "\n", "'pred_char_num'", ":", "0", ",", "\n", "'true_positive_char_num'", ":", "0", ",", "\n", "'gt_word_num'", ":", "0", ",", "\n", "'match_word_num'", ":", "0", ",", "\n", "'match_word_ignore_case'", ":", "0", ",", "\n", "'match_word_ignore_case_symbol'", ":", "0", "\n", "}", "\n", "comp", "=", "re", ".", "compile", "(", "'[^A-Z^a-z^0-9^\\u4e00-\\u9fa5]'", ")", "\n", "norm_ed_sum", "=", "0.0", "\n", "for", "pred_text", ",", "gt_text", "in", "zip", "(", "pred_texts", ",", "gt_texts", ")", ":", "\n", "        ", "if", "gt_text", "==", "pred_text", ":", "\n", "            ", "match_res", "[", "'match_word_num'", "]", "+=", "1", "\n", "", "gt_text_lower", "=", "gt_text", ".", "lower", "(", ")", "\n", "pred_text_lower", "=", "pred_text", ".", "lower", "(", ")", "\n", "if", "gt_text_lower", "==", "pred_text_lower", ":", "\n", "            ", "match_res", "[", "'match_word_ignore_case'", "]", "+=", "1", "\n", "", "gt_text_lower_ignore", "=", "comp", ".", "sub", "(", "''", ",", "gt_text_lower", ")", "\n", "pred_text_lower_ignore", "=", "comp", ".", "sub", "(", "''", ",", "pred_text_lower", ")", "\n", "if", "gt_text_lower_ignore", "==", "pred_text_lower_ignore", ":", "\n", "            ", "match_res", "[", "'match_word_ignore_case_symbol'", "]", "+=", "1", "\n", "", "match_res", "[", "'gt_word_num'", "]", "+=", "1", "\n", "\n", "norm_ed_sum", "+=", "Levenshtein", ".", "normalized_distance", "(", "pred_text_lower_ignore", ",", "\n", "gt_text_lower_ignore", ")", "\n", "\n", "# number to calculate char level recall & precision", "\n", "match_res", "[", "'gt_char_num'", "]", "+=", "len", "(", "gt_text_lower_ignore", ")", "\n", "match_res", "[", "'pred_char_num'", "]", "+=", "len", "(", "pred_text_lower_ignore", ")", "\n", "true_positive_char_num", "=", "cal_true_positive_char", "(", "\n", "pred_text_lower_ignore", ",", "gt_text_lower_ignore", ")", "\n", "match_res", "[", "'true_positive_char_num'", "]", "+=", "true_positive_char_num", "\n", "\n", "", "normalized_edit_distance", "=", "norm_ed_sum", "/", "max", "(", "1", ",", "len", "(", "gt_texts", ")", ")", "\n", "match_res", "[", "'ned'", "]", "=", "normalized_edit_distance", "\n", "\n", "return", "match_res", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.eval_ocr_metric": [[82, 166], ["isinstance", "isinstance", "set", "metric.issubset", "ocr_metric.count_matches", "eval_res.items", "len", "len", "isinstance", "mmocr.utils.is_type_list", "isinstance", "set", "set", "float"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.count_matches", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "eval_ocr_metric", "(", "pred_texts", ",", "gt_texts", ",", "metric", "=", "'acc'", ")", ":", "\n", "    ", "\"\"\"Evaluate the text recognition performance with metric: word accuracy and\n    1-N.E.D. See https://rrc.cvc.uab.es/?ch=14&com=tasks for details.\n\n    Args:\n        pred_texts (list[str]): Text strings of prediction.\n        gt_texts (list[str]): Text strings of ground truth.\n        metric (str | list[str]): Metric(s) to be evaluated. Options are:\n\n            - 'word_acc': Accuracy at word level.\n            - 'word_acc_ignore_case': Accuracy at word level, ignoring letter\n              case.\n            - 'word_acc_ignore_case_symbol': Accuracy at word level, ignoring\n              letter case and symbol. (Default metric for academic evaluation)\n            - 'char_recall': Recall at character level, ignoring\n              letter case and symbol.\n            - 'char_precision': Precision at character level, ignoring\n              letter case and symbol.\n            - 'one_minus_ned': 1 - normalized_edit_distance\n\n            In particular, if ``metric == 'acc'``, results on all metrics above\n            will be reported.\n\n    Returns:\n        dict{str: float}: Result dict for text recognition, keys could be some\n        of the following: ['word_acc', 'word_acc_ignore_case',\n        'word_acc_ignore_case_symbol', 'char_recall', 'char_precision',\n        '1-N.E.D'].\n    \"\"\"", "\n", "assert", "isinstance", "(", "pred_texts", ",", "list", ")", "\n", "assert", "isinstance", "(", "gt_texts", ",", "list", ")", "\n", "assert", "len", "(", "pred_texts", ")", "==", "len", "(", "gt_texts", ")", "\n", "\n", "assert", "isinstance", "(", "metric", ",", "str", ")", "or", "is_type_list", "(", "metric", ",", "str", ")", "\n", "if", "metric", "==", "'acc'", "or", "metric", "==", "[", "'acc'", "]", ":", "\n", "        ", "metric", "=", "[", "\n", "'word_acc'", ",", "'word_acc_ignore_case'", ",", "'word_acc_ignore_case_symbol'", ",", "\n", "'char_recall'", ",", "'char_precision'", ",", "'one_minus_ned'", "\n", "]", "\n", "", "metric", "=", "set", "(", "[", "metric", "]", ")", "if", "isinstance", "(", "metric", ",", "str", ")", "else", "set", "(", "metric", ")", "\n", "\n", "supported_metrics", "=", "set", "(", "[", "\n", "'word_acc'", ",", "'word_acc_ignore_case'", ",", "'word_acc_ignore_case_symbol'", ",", "\n", "'char_recall'", ",", "'char_precision'", ",", "'one_minus_ned'", "\n", "]", ")", "\n", "assert", "metric", ".", "issubset", "(", "supported_metrics", ")", "\n", "\n", "match_res", "=", "count_matches", "(", "pred_texts", ",", "gt_texts", ")", "\n", "eps", "=", "1e-8", "\n", "eval_res", "=", "{", "}", "\n", "\n", "if", "'char_recall'", "in", "metric", ":", "\n", "        ", "char_recall", "=", "1.0", "*", "match_res", "[", "'true_positive_char_num'", "]", "/", "(", "\n", "eps", "+", "match_res", "[", "'gt_char_num'", "]", ")", "\n", "eval_res", "[", "'char_recall'", "]", "=", "char_recall", "\n", "\n", "", "if", "'char_precision'", "in", "metric", ":", "\n", "        ", "char_precision", "=", "1.0", "*", "match_res", "[", "'true_positive_char_num'", "]", "/", "(", "\n", "eps", "+", "match_res", "[", "'pred_char_num'", "]", ")", "\n", "eval_res", "[", "'char_precision'", "]", "=", "char_precision", "\n", "\n", "", "if", "'word_acc'", "in", "metric", ":", "\n", "        ", "word_acc", "=", "1.0", "*", "match_res", "[", "'match_word_num'", "]", "/", "(", "\n", "eps", "+", "match_res", "[", "'gt_word_num'", "]", ")", "\n", "eval_res", "[", "'word_acc'", "]", "=", "word_acc", "\n", "\n", "", "if", "'word_acc_ignore_case'", "in", "metric", ":", "\n", "        ", "word_acc_ignore_case", "=", "1.0", "*", "match_res", "[", "'match_word_ignore_case'", "]", "/", "(", "\n", "eps", "+", "match_res", "[", "'gt_word_num'", "]", ")", "\n", "eval_res", "[", "'word_acc_ignore_case'", "]", "=", "word_acc_ignore_case", "\n", "\n", "", "if", "'word_acc_ignore_case_symbol'", "in", "metric", ":", "\n", "        ", "word_acc_ignore_case_symbol", "=", "1.0", "*", "match_res", "[", "\n", "'match_word_ignore_case_symbol'", "]", "/", "(", "\n", "eps", "+", "match_res", "[", "'gt_word_num'", "]", ")", "\n", "eval_res", "[", "'word_acc_ignore_case_symbol'", "]", "=", "word_acc_ignore_case_symbol", "\n", "\n", "", "if", "'one_minus_ned'", "in", "metric", ":", "\n", "        ", "eval_res", "[", "'1-N.E.D'", "]", "=", "1.0", "-", "match_res", "[", "'ned'", "]", "\n", "\n", "", "for", "key", ",", "value", "in", "eval_res", ".", "items", "(", ")", ":", "\n", "        ", "eval_res", "[", "key", "]", "=", "float", "(", "'{:.4f}'", ".", "format", "(", "value", ")", ")", "\n", "\n", "", "return", "eval_res", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.output_ranklist": [[16, 44], ["mmocr.is_type_list", "mmocr.is_type_list", "isinstance", "out_file.endswith", "enumerate", "sorted", "mmcv.dump", "sorted.append", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["def", "output_ranklist", "(", "img_results", ",", "img_infos", ",", "out_file", ")", ":", "\n", "    ", "\"\"\"Output the worst results for debugging.\n\n    Args:\n        img_results (list[dict]): Image result list.\n        img_infos (list[dict]): Image information list.\n        out_file (str): The output file path.\n\n    Returns:\n        sorted_results (list[dict]): Image results sorted by hmean.\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "img_results", ",", "dict", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "img_infos", ",", "dict", ")", "\n", "assert", "isinstance", "(", "out_file", ",", "str", ")", "\n", "assert", "out_file", ".", "endswith", "(", "'json'", ")", "\n", "\n", "sorted_results", "=", "[", "]", "\n", "for", "idx", ",", "result", "in", "enumerate", "(", "img_results", ")", ":", "\n", "        ", "name", "=", "img_infos", "[", "idx", "]", "[", "'file_name'", "]", "\n", "img_result", "=", "result", "\n", "img_result", "[", "'file_name'", "]", "=", "name", "\n", "sorted_results", ".", "append", "(", "img_result", ")", "\n", "", "sorted_results", "=", "sorted", "(", "\n", "sorted_results", ",", "key", "=", "itemgetter", "(", "'hmean'", ")", ",", "reverse", "=", "False", ")", "\n", "\n", "mmcv", ".", "dump", "(", "sorted_results", ",", "file", "=", "out_file", ")", "\n", "\n", "return", "sorted_results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.get_gt_masks": [[46, 77], ["mmocr.is_type_list", "gt_masks.append", "gt_masks_ignore.append", "mask_gt.append", "mask_gt_ignore.append", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "get_gt_masks", "(", "ann_infos", ")", ":", "\n", "    ", "\"\"\"Get ground truth masks and ignored masks.\n\n    Args:\n        ann_infos (list[dict]): Each dict contains annotation\n            infos of one image, containing following keys:\n            masks, masks_ignore.\n    Returns:\n        gt_masks (list[list[list[int]]]): Ground truth masks.\n        gt_masks_ignore (list[list[list[int]]]): Ignored masks.\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "ann_infos", ",", "dict", ")", "\n", "\n", "gt_masks", "=", "[", "]", "\n", "gt_masks_ignore", "=", "[", "]", "\n", "for", "ann_info", "in", "ann_infos", ":", "\n", "        ", "masks", "=", "ann_info", "[", "'masks'", "]", "\n", "mask_gt", "=", "[", "]", "\n", "for", "mask", "in", "masks", ":", "\n", "            ", "assert", "len", "(", "mask", "[", "0", "]", ")", ">=", "8", "and", "len", "(", "mask", "[", "0", "]", ")", "%", "2", "==", "0", "\n", "mask_gt", ".", "append", "(", "mask", "[", "0", "]", ")", "\n", "", "gt_masks", ".", "append", "(", "mask_gt", ")", "\n", "\n", "masks_ignore", "=", "ann_info", "[", "'masks_ignore'", "]", "\n", "mask_gt_ignore", "=", "[", "]", "\n", "for", "mask_ignore", "in", "masks_ignore", ":", "\n", "            ", "assert", "len", "(", "mask_ignore", "[", "0", "]", ")", ">=", "8", "and", "len", "(", "mask_ignore", "[", "0", "]", ")", "%", "2", "==", "0", "\n", "mask_gt_ignore", ".", "append", "(", "mask_ignore", "[", "0", "]", ")", "\n", "", "gt_masks_ignore", ".", "append", "(", "mask_gt_ignore", ")", "\n", "\n", "", "return", "gt_masks", ",", "gt_masks_ignore", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean": [[79, 173], ["mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_type_list", "isinstance", "float", "float", "float", "hmean.get_gt_masks", "warnings.warn", "len", "len", "len", "mmocr.core.mask.extract_boundary", "mmocr.core.evaluation.utils.filter_2dlist_result", "preds.append", "pred_scores.append", "mmcv.utils.print_log", "dict", "numpy.arange", "len", "mmocr.valid_boundary", "min", "mmocr.core.evaluation.utils.select_top_boundary", "mmcv.utils.print_log", "mmocr.core.evaluation.hmean_iou.eval_hmean_iou", "hmean.output_ranklist", "mmocr.core.evaluation.hmean_ic13.eval_hmean_ic13"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.get_gt_masks", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.extract_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.filter_2dlist_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.select_top_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.output_ranklist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13"], ["", "def", "eval_hmean", "(", "results", ",", "\n", "img_infos", ",", "\n", "ann_infos", ",", "\n", "metrics", "=", "{", "'hmean-iou'", "}", ",", "\n", "score_thr", "=", "None", ",", "\n", "min_score_thr", "=", "0.3", ",", "\n", "max_score_thr", "=", "0.9", ",", "\n", "step", "=", "0.1", ",", "\n", "rank_list", "=", "None", ",", "\n", "logger", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Evaluation in hmean metric. It conducts grid search over a range of\n    boundary score thresholds and reports the best result.\n\n    Args:\n        results (list[dict]): Each dict corresponds to one image,\n            containing the following keys: boundary_result\n        img_infos (list[dict]): Each dict corresponds to one image,\n            containing the following keys: filename, height, width\n        ann_infos (list[dict]): Each dict corresponds to one image,\n            containing the following keys: masks, masks_ignore\n        score_thr (float): Deprecated. Please use min_score_thr instead.\n        min_score_thr (float): Minimum score threshold of prediction map.\n        max_score_thr (float): Maximum score threshold of prediction map.\n        step (float): The spacing between score thresholds.\n        metrics (set{str}): Hmean metric set, should be one or all of\n            {'hmean-iou', 'hmean-ic13'}\n    Returns:\n        dict[str: float]\n    \"\"\"", "\n", "assert", "utils", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "img_infos", ",", "dict", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "ann_infos", ",", "dict", ")", "\n", "\n", "if", "score_thr", ":", "\n", "        ", "warnings", ".", "warn", "(", "'score_thr is deprecated. Please use min_score_thr '", "\n", "'instead.'", ")", "\n", "min_score_thr", "=", "score_thr", "\n", "\n", "", "assert", "0", "<=", "min_score_thr", "<=", "max_score_thr", "<=", "1", "\n", "assert", "0", "<=", "step", "<=", "1", "\n", "assert", "len", "(", "results", ")", "==", "len", "(", "img_infos", ")", "==", "len", "(", "ann_infos", ")", "\n", "assert", "isinstance", "(", "metrics", ",", "set", ")", "\n", "\n", "min_score_thr", "=", "float", "(", "min_score_thr", ")", "\n", "max_score_thr", "=", "float", "(", "max_score_thr", ")", "\n", "step", "=", "float", "(", "step", ")", "\n", "\n", "gts", ",", "gts_ignore", "=", "get_gt_masks", "(", "ann_infos", ")", "\n", "\n", "preds", "=", "[", "]", "\n", "pred_scores", "=", "[", "]", "\n", "for", "result", "in", "results", ":", "\n", "        ", "_", ",", "texts", ",", "scores", "=", "extract_boundary", "(", "result", ")", "\n", "if", "len", "(", "texts", ")", ">", "0", ":", "\n", "            ", "assert", "utils", ".", "valid_boundary", "(", "texts", "[", "0", "]", ",", "False", ")", "\n", "", "valid_texts", ",", "valid_text_scores", "=", "filter_2dlist_result", "(", "\n", "texts", ",", "scores", ",", "min_score_thr", ")", "\n", "preds", ".", "append", "(", "valid_texts", ")", "\n", "pred_scores", ".", "append", "(", "valid_text_scores", ")", "\n", "\n", "", "eval_results", "=", "{", "}", "\n", "\n", "for", "metric", "in", "metrics", ":", "\n", "        ", "msg", "=", "f'Evaluating {metric}...'", "\n", "if", "logger", "is", "None", ":", "\n", "            ", "msg", "=", "'\\n'", "+", "msg", "\n", "", "print_log", "(", "msg", ",", "logger", "=", "logger", ")", "\n", "best_result", "=", "dict", "(", "hmean", "=", "-", "1", ")", "\n", "for", "thr", "in", "np", ".", "arange", "(", "min_score_thr", ",", "min", "(", "max_score_thr", "+", "step", ",", "1.0", ")", ",", "\n", "step", ")", ":", "\n", "            ", "top_preds", "=", "select_top_boundary", "(", "preds", ",", "pred_scores", ",", "thr", ")", "\n", "if", "metric", "==", "'hmean-iou'", ":", "\n", "                ", "result", ",", "img_result", "=", "hmean_iou", ".", "eval_hmean_iou", "(", "\n", "top_preds", ",", "gts", ",", "gts_ignore", ")", "\n", "", "elif", "metric", "==", "'hmean-ic13'", ":", "\n", "                ", "result", ",", "img_result", "=", "hmean_ic13", ".", "eval_hmean_ic13", "(", "\n", "top_preds", ",", "gts", ",", "gts_ignore", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "if", "rank_list", "is", "not", "None", ":", "\n", "                ", "output_ranklist", "(", "img_result", ",", "img_infos", ",", "rank_list", ")", "\n", "\n", "", "print_log", "(", "\n", "'thr {0:.2f}, recall: {1[recall]:.3f}, '", "\n", "'precision: {1[precision]:.3f}, '", "\n", "'hmean: {1[hmean]:.3f}'", ".", "format", "(", "thr", ",", "result", ")", ",", "\n", "logger", "=", "logger", ")", "\n", "if", "result", "[", "'hmean'", "]", ">", "best_result", "[", "'hmean'", "]", ":", "\n", "                ", "best_result", "=", "result", "\n", "", "", "eval_results", "[", "metric", "+", "':recall'", "]", "=", "best_result", "[", "'recall'", "]", "\n", "eval_results", "[", "metric", "+", "':precision'", "]", "=", "best_result", "[", "'precision'", "]", "\n", "eval_results", "[", "metric", "+", "':hmean'", "]", "=", "best_result", "[", "'hmean'", "]", "\n", "", "return", "eval_results", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.compute_recall_precision": [[8, 45], ["isinstance", "isinstance", "len", "len", "numpy.zeros", "numpy.zeros", "range", "range", "utils.poly_intersection"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection"], ["def", "compute_recall_precision", "(", "gt_polys", ",", "pred_polys", ")", ":", "\n", "    ", "\"\"\"Compute the recall and the precision matrices between gt and predicted\n    polygons.\n\n    Args:\n        gt_polys (list[Polygon]): List of gt polygons.\n        pred_polys (list[Polygon]): List of predicted polygons.\n\n    Returns:\n        recall (ndarray): Recall matrix of size gt_num x det_num.\n        precision (ndarray): Precision matrix of size gt_num x det_num.\n    \"\"\"", "\n", "assert", "isinstance", "(", "gt_polys", ",", "list", ")", "\n", "assert", "isinstance", "(", "pred_polys", ",", "list", ")", "\n", "\n", "gt_num", "=", "len", "(", "gt_polys", ")", "\n", "det_num", "=", "len", "(", "pred_polys", ")", "\n", "sz", "=", "[", "gt_num", ",", "det_num", "]", "\n", "\n", "recall", "=", "np", ".", "zeros", "(", "sz", ")", "\n", "precision", "=", "np", ".", "zeros", "(", "sz", ")", "\n", "# compute area recall and precision for each (gt, det) pair", "\n", "# in one img", "\n", "for", "gt_id", "in", "range", "(", "gt_num", ")", ":", "\n", "        ", "for", "pred_id", "in", "range", "(", "det_num", ")", ":", "\n", "            ", "gt", "=", "gt_polys", "[", "gt_id", "]", "\n", "det", "=", "pred_polys", "[", "pred_id", "]", "\n", "\n", "inter_area", "=", "eval_utils", ".", "poly_intersection", "(", "det", ",", "gt", ")", "\n", "gt_area", "=", "gt", ".", "area", "\n", "det_area", "=", "det", ".", "area", "\n", "if", "gt_area", "!=", "0", ":", "\n", "                ", "recall", "[", "gt_id", ",", "pred_id", "]", "=", "inter_area", "/", "gt_area", "\n", "", "if", "det_area", "!=", "0", ":", "\n", "                ", "precision", "[", "gt_id", ",", "pred_id", "]", "=", "inter_area", "/", "det_area", "\n", "\n", "", "", "", "return", "recall", ",", "precision", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13": [[47, 218], ["mmocr.is_3dlist", "mmocr.is_3dlist", "mmocr.is_3dlist", "len", "range", "utils.compute_hmean", "len", "len", "len", "len", "len", "len", "utils.ignore_pred", "utils.compute_hmean", "img_results.append", "utils.points2polygon", "numpy.zeros().tolist", "numpy.zeros().tolist", "hmean_ic13.compute_recall_precision", "range", "range", "range", "len", "range", "range", "utils.one2many_match_ic13", "utils.many2one_match_ic13", "len", "numpy.zeros", "numpy.zeros", "utils.one2one_match_ic13", "numpy.array", "numpy.array", "utils.box_center_distance", "len", "len", "utils.box_diag", "utils.box_diag"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.compute_recall_precision", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_center_distance", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_diag", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_diag"], ["", "def", "eval_hmean_ic13", "(", "det_boxes", ",", "\n", "gt_boxes", ",", "\n", "gt_ignored_boxes", ",", "\n", "precision_thr", "=", "0.4", ",", "\n", "recall_thr", "=", "0.8", ",", "\n", "center_dist_thr", "=", "1.0", ",", "\n", "one2one_score", "=", "1.", ",", "\n", "one2many_score", "=", "0.8", ",", "\n", "many2one_score", "=", "1.", ")", ":", "\n", "    ", "\"\"\"Evaluate hmean of text detection using the icdar2013 standard.\n\n    Args:\n        det_boxes (list[list[list[float]]]): List of arrays of shape (n, 2k).\n            Each element is the det_boxes for one img. k>=4.\n        gt_boxes (list[list[list[float]]]): List of arrays of shape (m, 2k).\n            Each element is the gt_boxes for one img. k>=4.\n        gt_ignored_boxes (list[list[list[float]]]): List of arrays of\n            (l, 2k). Each element is the ignored gt_boxes for one img. k>=4.\n        precision_thr (float): Precision threshold of the iou of one\n            (gt_box, det_box) pair.\n        recall_thr (float): Recall threshold of the iou of one\n            (gt_box, det_box) pair.\n        center_dist_thr (float): Distance threshold of one (gt_box, det_box)\n            center point pair.\n        one2one_score (float): Reward when one gt matches one det_box.\n        one2many_score (float): Reward when one gt matches many det_boxes.\n        many2one_score (float): Reward when many gts match one det_box.\n\n    Returns:\n        hmean (tuple[dict]): Tuple of dicts which encodes the hmean for\n        the dataset and all images.\n    \"\"\"", "\n", "assert", "utils", ".", "is_3dlist", "(", "det_boxes", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "gt_boxes", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "gt_ignored_boxes", ")", "\n", "\n", "assert", "0", "<=", "precision_thr", "<=", "1", "\n", "assert", "0", "<=", "recall_thr", "<=", "1", "\n", "assert", "center_dist_thr", ">", "0", "\n", "assert", "0", "<=", "one2one_score", "<=", "1", "\n", "assert", "0", "<=", "one2many_score", "<=", "1", "\n", "assert", "0", "<=", "many2one_score", "<=", "1", "\n", "\n", "img_num", "=", "len", "(", "det_boxes", ")", "\n", "assert", "img_num", "==", "len", "(", "gt_boxes", ")", "\n", "assert", "img_num", "==", "len", "(", "gt_ignored_boxes", ")", "\n", "\n", "dataset_gt_num", "=", "0", "\n", "dataset_pred_num", "=", "0", "\n", "dataset_hit_recall", "=", "0.0", "\n", "dataset_hit_prec", "=", "0.0", "\n", "\n", "img_results", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "img_num", ")", ":", "\n", "        ", "gt", "=", "gt_boxes", "[", "i", "]", "\n", "gt_ignored", "=", "gt_ignored_boxes", "[", "i", "]", "\n", "pred", "=", "det_boxes", "[", "i", "]", "\n", "\n", "gt_num", "=", "len", "(", "gt", ")", "\n", "ignored_num", "=", "len", "(", "gt_ignored", ")", "\n", "pred_num", "=", "len", "(", "pred", ")", "\n", "\n", "accum_recall", "=", "0.", "\n", "accum_precision", "=", "0.", "\n", "\n", "gt_points", "=", "gt", "+", "gt_ignored", "\n", "gt_polys", "=", "[", "eval_utils", ".", "points2polygon", "(", "p", ")", "for", "p", "in", "gt_points", "]", "\n", "gt_ignored_index", "=", "[", "gt_num", "+", "i", "for", "i", "in", "range", "(", "len", "(", "gt_ignored", ")", ")", "]", "\n", "gt_num", "=", "len", "(", "gt_polys", ")", "\n", "\n", "pred_polys", ",", "pred_points", ",", "pred_ignored_index", "=", "eval_utils", ".", "ignore_pred", "(", "\n", "pred", ",", "gt_ignored_index", ",", "gt_polys", ",", "precision_thr", ")", "\n", "\n", "if", "pred_num", ">", "0", "and", "gt_num", ">", "0", ":", "\n", "\n", "            ", "gt_hit", "=", "np", ".", "zeros", "(", "gt_num", ",", "np", ".", "int8", ")", ".", "tolist", "(", ")", "\n", "pred_hit", "=", "np", ".", "zeros", "(", "pred_num", ",", "np", ".", "int8", ")", ".", "tolist", "(", ")", "\n", "\n", "# compute area recall and precision for each (gt, pred) pair", "\n", "# in one img.", "\n", "recall_mat", ",", "precision_mat", "=", "compute_recall_precision", "(", "\n", "gt_polys", ",", "pred_polys", ")", "\n", "\n", "# match one gt to one pred box.", "\n", "for", "gt_id", "in", "range", "(", "gt_num", ")", ":", "\n", "                ", "for", "pred_id", "in", "range", "(", "pred_num", ")", ":", "\n", "                    ", "if", "(", "gt_hit", "[", "gt_id", "]", "!=", "0", "or", "pred_hit", "[", "pred_id", "]", "!=", "0", "\n", "or", "gt_id", "in", "gt_ignored_index", "\n", "or", "pred_id", "in", "pred_ignored_index", ")", ":", "\n", "                        ", "continue", "\n", "", "match", "=", "eval_utils", ".", "one2one_match_ic13", "(", "\n", "gt_id", ",", "pred_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "precision_thr", ")", "\n", "\n", "if", "match", ":", "\n", "                        ", "gt_point", "=", "np", ".", "array", "(", "gt_points", "[", "gt_id", "]", ")", "\n", "det_point", "=", "np", ".", "array", "(", "pred_points", "[", "pred_id", "]", ")", "\n", "\n", "norm_dist", "=", "eval_utils", ".", "box_center_distance", "(", "\n", "det_point", ",", "gt_point", ")", "\n", "norm_dist", "/=", "eval_utils", ".", "box_diag", "(", "\n", "det_point", ")", "+", "eval_utils", ".", "box_diag", "(", "gt_point", ")", "\n", "norm_dist", "*=", "2.0", "\n", "\n", "if", "norm_dist", "<", "center_dist_thr", ":", "\n", "                            ", "gt_hit", "[", "gt_id", "]", "=", "1", "\n", "pred_hit", "[", "pred_id", "]", "=", "1", "\n", "accum_recall", "+=", "one2one_score", "\n", "accum_precision", "+=", "one2one_score", "\n", "\n", "# match one gt to many det boxes.", "\n", "", "", "", "", "for", "gt_id", "in", "range", "(", "gt_num", ")", ":", "\n", "                ", "if", "gt_id", "in", "gt_ignored_index", ":", "\n", "                    ", "continue", "\n", "", "match", ",", "match_det_set", "=", "eval_utils", ".", "one2many_match_ic13", "(", "\n", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "precision_thr", ",", "gt_hit", ",", "pred_hit", ",", "pred_ignored_index", ")", "\n", "\n", "if", "match", ":", "\n", "                    ", "gt_hit", "[", "gt_id", "]", "=", "1", "\n", "accum_recall", "+=", "one2many_score", "\n", "accum_precision", "+=", "one2many_score", "*", "len", "(", "match_det_set", ")", "\n", "for", "pred_id", "in", "match_det_set", ":", "\n", "                        ", "pred_hit", "[", "pred_id", "]", "=", "1", "\n", "\n", "# match many gt to one det box. One pair of (det,gt) are matched", "\n", "# successfully if their recall, precision, normalized distance", "\n", "# meet some thresholds.", "\n", "", "", "", "for", "pred_id", "in", "range", "(", "pred_num", ")", ":", "\n", "                ", "if", "pred_id", "in", "pred_ignored_index", ":", "\n", "                    ", "continue", "\n", "\n", "", "match", ",", "match_gt_set", "=", "eval_utils", ".", "many2one_match_ic13", "(", "\n", "pred_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "precision_thr", ",", "gt_hit", ",", "pred_hit", ",", "gt_ignored_index", ")", "\n", "\n", "if", "match", ":", "\n", "                    ", "pred_hit", "[", "pred_id", "]", "=", "1", "\n", "accum_recall", "+=", "many2one_score", "*", "len", "(", "match_gt_set", ")", "\n", "accum_precision", "+=", "many2one_score", "\n", "for", "gt_id", "in", "match_gt_set", ":", "\n", "                        ", "gt_hit", "[", "gt_id", "]", "=", "1", "\n", "\n", "", "", "", "", "gt_care_number", "=", "gt_num", "-", "ignored_num", "\n", "pred_care_number", "=", "pred_num", "-", "len", "(", "pred_ignored_index", ")", "\n", "\n", "r", ",", "p", ",", "h", "=", "eval_utils", ".", "compute_hmean", "(", "accum_recall", ",", "accum_precision", ",", "\n", "gt_care_number", ",", "pred_care_number", ")", "\n", "\n", "img_results", ".", "append", "(", "{", "'recall'", ":", "r", ",", "'precision'", ":", "p", ",", "'hmean'", ":", "h", "}", ")", "\n", "\n", "dataset_gt_num", "+=", "gt_care_number", "\n", "dataset_pred_num", "+=", "pred_care_number", "\n", "dataset_hit_recall", "+=", "accum_recall", "\n", "dataset_hit_prec", "+=", "accum_precision", "\n", "\n", "", "total_r", ",", "total_p", ",", "total_h", "=", "eval_utils", ".", "compute_hmean", "(", "\n", "dataset_hit_recall", ",", "dataset_hit_prec", ",", "dataset_gt_num", ",", "dataset_pred_num", ")", "\n", "\n", "dataset_results", "=", "{", "\n", "'num_gts'", ":", "dataset_gt_num", ",", "\n", "'num_dets'", ":", "dataset_pred_num", ",", "\n", "'num_recall'", ":", "dataset_hit_recall", ",", "\n", "'num_precision'", ":", "dataset_hit_prec", ",", "\n", "'recall'", ":", "total_r", ",", "\n", "'precision'", ":", "total_p", ",", "\n", "'hmean'", ":", "total_h", "\n", "}", "\n", "\n", "return", "dataset_results", ",", "img_results", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred": [[8, 55], ["isinstance", "isinstance", "isinstance", "len", "enumerate", "utils.points2polygon", "pred_polys.append", "pred_points.append", "utils.poly_intersection", "pred_ignored_index.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection"], ["from", "mmdet", ".", "datasets", "import", "replace_ImageToTensor", "\n", "\n", "from", "mmocr", ".", "utils", "import", "is_2dlist", ",", "is_type_list", "\n", "\n", "\n", "def", "update_pipeline", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "pipeline", "is", "not", "None", ":", "\n", "            ", "cfg", ".", "pipeline", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", ")", "\n", "", "", "else", ":", "\n", "        ", "cfg", ".", "pipeline", "[", "idx", "]", "=", "replace_ImageToTensor", "(", "cfg", ".", "pipeline", "[", "idx", "]", ")", "\n", "\n", "\n", "", "", "def", "replace_image_to_tensor", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Replace 'ImageToTensor' to 'DefaultFormatBundle'.\"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline", "(", "cfg", ".", "data", "[", "set_type", "]", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n", "                ", "update_pipeline", "(", "dataset", ")", "\n", "\n", "", "", "", "return", "cfg", "\n", "\n", "\n", "", "def", "update_pipeline_recog", "(", "cfg", ",", "idx", "=", "None", ")", ":", "\n", "    ", "warning_msg", "=", "'Remove \"MultiRotateAugOCR\" to support batch '", "+", "'inference since samples_per_gpu > 1.'", "\n", "if", "idx", "is", "None", ":", "\n", "        ", "if", "cfg", ".", "get", "(", "'pipeline'", ",", "\n", "None", ")", "and", "cfg", ".", "pipeline", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", ".", "pipeline", "=", "[", "cfg", ".", "pipeline", "[", "0", "]", ",", "*", "cfg", ".", "pipeline", "[", "1", "]", ".", "transforms", "]", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean": [[57, 95], ["isinstance", "isinstance", "isinstance", "isinstance", "float", "float"], "function", ["None"], ["            ", "warnings", ".", "warn", "(", "warning_msg", ")", "\n", "cfg", "[", "idx", "]", "=", "[", "cfg", "[", "idx", "]", "[", "0", "]", ",", "*", "cfg", "[", "idx", "]", "[", "1", "]", ".", "transforms", "]", "\n", "\n", "\n", "", "", "", "def", "disable_text_recog_aug_test", "(", "cfg", ",", "set_types", "=", "None", ")", ":", "\n", "    ", "\"\"\"Remove aug_test from test pipeline for text recognition.\n\n    Args:\n        cfg (mmcv.Config): Input config.\n        set_types (list[str]): Type of dataset source. Should be\n            None or sublist of ['test', 'val'].\n    \"\"\"", "\n", "assert", "set_types", "is", "None", "or", "isinstance", "(", "set_types", ",", "list", ")", "\n", "if", "set_types", "is", "None", ":", "\n", "        ", "set_types", "=", "[", "'val'", ",", "'test'", "]", "\n", "\n", "", "cfg", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "warnings", ".", "simplefilter", "(", "'once'", ")", "\n", "for", "set_type", "in", "set_types", ":", "\n", "        ", "assert", "set_type", "in", "[", "'val'", ",", "'test'", "]", "\n", "dataset_type", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "type", "\n", "if", "dataset_type", "not", "in", "[", "\n", "'ConcatDataset'", ",", "'UniformConcatDataset'", ",", "'OCRDataset'", ",", "\n", "'OCRSegDataset'", "\n", "]", ":", "\n", "            ", "continue", "\n", "\n", "", "uniform_pipeline", "=", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'pipeline'", ",", "None", ")", "\n", "if", "is_type_list", "(", "uniform_pipeline", ",", "dict", ")", ":", "\n", "            ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ")", "\n", "", "elif", "is_2dlist", "(", "uniform_pipeline", ")", ":", "\n", "            ", "for", "idx", ",", "_", "in", "enumerate", "(", "uniform_pipeline", ")", ":", "\n", "                ", "update_pipeline_recog", "(", "cfg", ".", "data", "[", "set_type", "]", ".", "pipeline", ",", "idx", ")", "\n", "\n", "", "", "for", "dataset", "in", "cfg", ".", "data", "[", "set_type", "]", ".", "get", "(", "'datasets'", ",", "[", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "dataset", ",", "list", ")", ":", "\n", "                ", "for", "each_dataset", "in", "dataset", ":", "\n", "                    ", "update_pipeline_recog", "(", "each_dataset", ")", "\n", "", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box2polygon": [[97, 117], ["isinstance", "isinstance", "numpy.array", "np.array.reshape", "shapely.geometry.Polygon", "numpy.array"], "function", ["None"], ["\n", "", "", "", "return", "cfg", "\n", "\n", "\n", "", "def", "tensor2grayimgs", "(", "tensor", ",", "mean", "=", "(", "127", ",", ")", ",", "std", "=", "(", "127", ",", ")", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Convert tensor to 1-channel gray images.\n\n    Args:\n        tensor (torch.Tensor): Tensor that contains multiple images, shape (\n            N, C, H, W).\n        mean (tuple[float], optional): Mean of images. Defaults to (127).\n        std (tuple[float], optional): Standard deviation of images.\n            Defaults to (127).\n\n    Returns:\n        list[np.ndarray]: A list that contains multiple images.\n    \"\"\"", "\n", "\n", "assert", "torch", ".", "is_tensor", "(", "tensor", ")", "and", "tensor", ".", "ndim", "==", "4", "\n", "assert", "tensor", ".", "size", "(", "1", ")", "==", "len", "(", "mean", ")", "==", "len", "(", "std", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon": [[119, 137], ["isinstance", "isinstance", "np.array.reshape", "shapely.geometry.Polygon", "numpy.array"], "function", ["None"], ["mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "imgs", "=", "[", "]", "\n", "for", "img_id", "in", "range", "(", "num_imgs", ")", ":", "\n", "        ", "img", "=", "tensor", "[", "img_id", ",", "...", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "img", "=", "mmcv", ".", "imdenormalize", "(", "img", ",", "mean", ",", "std", ",", "to_bgr", "=", "False", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "imgs", ".", "append", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", "\n", "", "return", "imgs", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_make_valid": [[139, 150], ["poly.buffer"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection": [[152, 185], ["isinstance", "isinstance", "isinstance", "isinstance", "utils.poly_make_valid", "utils.poly_make_valid", "poly_make_valid.intersection"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_make_valid", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_make_valid"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union": [[187, 221], ["isinstance", "isinstance", "isinstance", "isinstance", "utils.poly_make_valid", "utils.poly_make_valid", "poly_make_valid.union"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_make_valid", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_make_valid"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou": [[223, 241], ["mmocr.valid_boundary", "mmocr.valid_boundary", "utils.points2polygon", "utils.points2polygon", "utils.poly_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou": [[243, 260], ["isinstance", "isinstance", "utils.poly_intersection", "utils.poly_union"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13": [[262, 307], ["isinstance", "isinstance", "isinstance", "isinstance", "range", "range"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13": [[309, 353], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "range", "det_ids.append"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13": [[355, 399], ["isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "range", "gt_ids.append"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points_center": [[401, 408], ["isinstance", "points.reshape.reshape", "numpy.mean"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance": [[410, 421], ["isinstance", "isinstance", "numpy.square", "numpy.sum", "numpy.sqrt"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_center_distance": [[423, 427], ["isinstance", "isinstance", "utils.point_distance", "utils.points_center", "utils.points_center"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points_center", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points_center"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_diag": [[429, 434], ["isinstance", "utils.point_distance"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.filter_2dlist_result": [[436, 457], ["isinstance", "isinstance", "len", "len", "numpy.array", "[].tolist", "[].tolist", "numpy.where", "numpy.where"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.filter_result": [[459, 480], ["isinstance"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.select_top_boundary": [[482, 515], ["isinstance", "isinstance", "isinstance", "zip", "len", "len", "len", "selected_boundaries.append", "selected_boundaries.append", "len", "len", "range", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.select_bboxes_via_score": [[517, 548], ["isinstance", "isinstance", "isinstance", "zip", "len", "len", "len", "selected_bboxes.append", "selected_bboxes.append", "len", "range", "len"], "function", ["None"], []], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeDetector.__init__": [[41, 81], ["mmocr.models.textdet.detectors.single_stage_text_detector.SingleStageTextDetector.__init__", "mmocr.models.textdet.detectors.text_detector_mixin.TextDetectorMixin.__init__", "ort.SessionOptions", "os.exists", "ort.InferenceSession", "ort.InferenceSession.set_providers", "ort.InferenceSession.io_binding", "cfg.model.pop", "get_onnxruntime_op_path", "ort.SessionOptions.register_custom_ops_library", "ort.get_device", "providers.insert", "options.insert", "deploy_utils.ONNXRuntimeDetector.io_binding.bind_output", "warnings.warn", "ort.InferenceSession.get_outputs"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "onnx_file", ":", "str", ",", "\n", "cfg", ":", "Any", ",", "\n", "device_id", ":", "int", ",", "\n", "show_score", ":", "bool", "=", "False", ")", ":", "\n", "        ", "if", "'type'", "in", "cfg", ".", "model", ":", "\n", "            ", "cfg", ".", "model", ".", "pop", "(", "'type'", ")", "\n", "", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "**", "(", "cfg", ".", "model", ")", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "import", "onnxruntime", "as", "ort", "\n", "\n", "# get the custom op path", "\n", "ort_custom_op_path", "=", "''", "\n", "try", ":", "\n", "            ", "from", "mmcv", ".", "ops", "import", "get_onnxruntime_op_path", "\n", "ort_custom_op_path", "=", "get_onnxruntime_op_path", "(", ")", "\n", "", "except", "(", "ImportError", ",", "ModuleNotFoundError", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'If input model has custom op from mmcv, \\\n                you may have to build mmcv with ONNXRuntime from source.'", ")", "\n", "", "session_options", "=", "ort", ".", "SessionOptions", "(", ")", "\n", "# register custom op for onnxruntime", "\n", "if", "osp", ".", "exists", "(", "ort_custom_op_path", ")", ":", "\n", "            ", "session_options", ".", "register_custom_ops_library", "(", "ort_custom_op_path", ")", "\n", "", "sess", "=", "ort", ".", "InferenceSession", "(", "onnx_file", ",", "session_options", ")", "\n", "providers", "=", "[", "'CPUExecutionProvider'", "]", "\n", "options", "=", "[", "{", "}", "]", "\n", "is_cuda_available", "=", "ort", ".", "get_device", "(", ")", "==", "'GPU'", "\n", "if", "is_cuda_available", ":", "\n", "            ", "providers", ".", "insert", "(", "0", ",", "'CUDAExecutionProvider'", ")", "\n", "options", ".", "insert", "(", "0", ",", "{", "'device_id'", ":", "device_id", "}", ")", "\n", "\n", "", "sess", ".", "set_providers", "(", "providers", ",", "options", ")", "\n", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "device_id", "=", "device_id", "\n", "self", ".", "io_binding", "=", "sess", ".", "io_binding", "(", ")", "\n", "self", ".", "output_names", "=", "[", "_", ".", "name", "for", "_", "in", "sess", ".", "get_outputs", "(", ")", "]", "\n", "for", "name", "in", "self", ".", "output_names", ":", "\n", "            ", "self", ".", "io_binding", ".", "bind_output", "(", "name", ")", "\n", "", "self", ".", "cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeDetector.forward_train": [[82, 84], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeDetector.aug_test": [[85, 87], ["NotImplementedError"], "methods", ["None"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeDetector.extract_feat": [[88, 90], ["NotImplementedError"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeDetector.simple_test": [[91, 111], ["deploy_utils.inference_with_session", "torch.from_numpy", "len", "deploy_utils.ONNXRuntimeDetector.bbox_head.get_boundary", "deploy_utils.ONNXRuntimeDetector.bbox_head.get_boundary", "range", "onnx_pred[].unsqueeze", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.inference_with_session", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "def", "simple_test", "(", "self", ",", "\n", "img", ":", "torch", ".", "Tensor", ",", "\n", "img_metas", ":", "Iterable", ",", "\n", "rescale", ":", "bool", "=", "False", ")", ":", "\n", "        ", "onnx_pred", "=", "inference_with_session", "(", "self", ".", "sess", ",", "self", ".", "io_binding", ",", "'input'", ",", "\n", "self", ".", "output_names", ",", "img", ")", "\n", "onnx_pred", "=", "torch", ".", "from_numpy", "(", "onnx_pred", "[", "0", "]", ")", "\n", "if", "len", "(", "img_metas", ")", ">", "1", ":", "\n", "            ", "boundaries", "=", "[", "\n", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "(", "onnx_pred", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", ",", "\n", "[", "img_metas", "[", "i", "]", "]", ",", "rescale", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "img_metas", ")", ")", "\n", "]", "\n", "\n", "", "else", ":", "\n", "            ", "boundaries", "=", "[", "\n", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "onnx_pred", ",", "img_metas", ",", "rescale", ")", "\n", "]", "\n", "\n", "", "return", "boundaries", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeRecognizer.__init__": [[117, 156], ["mmocr.models.textrecog.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.__init__", "ort.SessionOptions", "os.exists", "ort.InferenceSession", "ort.InferenceSession.set_providers", "ort.InferenceSession.io_binding", "cfg.model.pop", "get_onnxruntime_op_path", "ort.SessionOptions.register_custom_ops_library", "ort.get_device", "providers.insert", "options.insert", "deploy_utils.ONNXRuntimeRecognizer.io_binding.bind_output", "warnings.warn", "ort.InferenceSession.get_outputs"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "onnx_file", ":", "str", ",", "\n", "cfg", ":", "Any", ",", "\n", "device_id", ":", "int", ",", "\n", "show_score", ":", "bool", "=", "False", ")", ":", "\n", "        ", "if", "'type'", "in", "cfg", ".", "model", ":", "\n", "            ", "cfg", ".", "model", ".", "pop", "(", "'type'", ")", "\n", "", "EncodeDecodeRecognizer", ".", "__init__", "(", "self", ",", "**", "(", "cfg", ".", "model", ")", ")", "\n", "import", "onnxruntime", "as", "ort", "\n", "\n", "# get the custom op path", "\n", "ort_custom_op_path", "=", "''", "\n", "try", ":", "\n", "            ", "from", "mmcv", ".", "ops", "import", "get_onnxruntime_op_path", "\n", "ort_custom_op_path", "=", "get_onnxruntime_op_path", "(", ")", "\n", "", "except", "(", "ImportError", ",", "ModuleNotFoundError", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'If input model has custom op from mmcv, \\\n                you may have to build mmcv with ONNXRuntime from source.'", ")", "\n", "", "session_options", "=", "ort", ".", "SessionOptions", "(", ")", "\n", "# register custom op for onnxruntime", "\n", "if", "osp", ".", "exists", "(", "ort_custom_op_path", ")", ":", "\n", "            ", "session_options", ".", "register_custom_ops_library", "(", "ort_custom_op_path", ")", "\n", "", "sess", "=", "ort", ".", "InferenceSession", "(", "onnx_file", ",", "session_options", ")", "\n", "providers", "=", "[", "'CPUExecutionProvider'", "]", "\n", "options", "=", "[", "{", "}", "]", "\n", "is_cuda_available", "=", "ort", ".", "get_device", "(", ")", "==", "'GPU'", "\n", "if", "is_cuda_available", ":", "\n", "            ", "providers", ".", "insert", "(", "0", ",", "'CUDAExecutionProvider'", ")", "\n", "options", ".", "insert", "(", "0", ",", "{", "'device_id'", ":", "device_id", "}", ")", "\n", "\n", "", "sess", ".", "set_providers", "(", "providers", ",", "options", ")", "\n", "\n", "self", ".", "sess", "=", "sess", "\n", "self", ".", "device_id", "=", "device_id", "\n", "self", ".", "io_binding", "=", "sess", ".", "io_binding", "(", ")", "\n", "self", ".", "output_names", "=", "[", "_", ".", "name", "for", "_", "in", "sess", ".", "get_outputs", "(", ")", "]", "\n", "for", "name", "in", "self", ".", "output_names", ":", "\n", "            ", "self", ".", "io_binding", ".", "bind_output", "(", "name", ")", "\n", "", "self", ".", "cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeRecognizer.forward_train": [[157, 159], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeRecognizer.aug_test": [[160, 171], ["isinstance", "deploy_utils.ONNXRuntimeRecognizer.simple_test", "enumerate", "isinstance", "each_img.dim", "each_img.unsqueeze", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "            ", "for", "idx", ",", "each_img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "                ", "if", "each_img", ".", "dim", "(", ")", "==", "3", ":", "\n", "                    ", "imgs", "[", "idx", "]", "=", "each_img", ".", "unsqueeze", "(", "0", ")", "\n", "", "", "imgs", "=", "imgs", "[", "0", "]", "# avoid aug_test", "\n", "img_metas", "=", "img_metas", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "img_metas", ")", "==", "1", "and", "isinstance", "(", "img_metas", "[", "0", "]", ",", "list", ")", ":", "\n", "                ", "img_metas", "=", "img_metas", "[", "0", "]", "\n", "", "", "return", "self", ".", "simple_test", "(", "imgs", ",", "img_metas", "=", "img_metas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeRecognizer.extract_feat": [[172, 174], ["NotImplementedError"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.ONNXRuntimeRecognizer.simple_test": [[175, 202], ["deploy_utils.inference_with_session", "torch.from_numpy", "deploy_utils.ONNXRuntimeRecognizer.label_convertor.tensor2idx", "deploy_utils.ONNXRuntimeRecognizer.label_convertor.idx2str", "zip", "results.append", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.inference_with_session", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str"], ["", "def", "simple_test", "(", "self", ",", "\n", "img", ":", "torch", ".", "Tensor", ",", "\n", "img_metas", ":", "Iterable", ",", "\n", "rescale", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function.\n\n        Args:\n            imgs (torch.Tensor): Image input tensor.\n            img_metas (list[dict]): List of image information.\n\n        Returns:\n            list[str]: Text label result of each image.\n        \"\"\"", "\n", "onnx_pred", "=", "inference_with_session", "(", "self", ".", "sess", ",", "self", ".", "io_binding", ",", "'input'", ",", "\n", "self", ".", "output_names", ",", "img", ")", "\n", "onnx_pred", "=", "torch", ".", "from_numpy", "(", "onnx_pred", "[", "0", "]", ")", "\n", "\n", "label_indexes", ",", "label_scores", "=", "self", ".", "label_convertor", ".", "tensor2idx", "(", "\n", "onnx_pred", ",", "img_metas", ")", "\n", "label_strings", "=", "self", ".", "label_convertor", ".", "idx2str", "(", "label_indexes", ")", "\n", "\n", "# flatten batch results", "\n", "results", "=", "[", "]", "\n", "for", "string", ",", "score", "in", "zip", "(", "label_strings", ",", "label_scores", ")", ":", "\n", "            ", "results", ".", "append", "(", "dict", "(", "text", "=", "string", ",", "score", "=", "score", ")", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTDetector.__init__": [[208, 229], ["mmocr.models.textdet.detectors.single_stage_text_detector.SingleStageTextDetector.__init__", "mmocr.models.textdet.detectors.text_detector_mixin.TextDetectorMixin.__init__", "TRTWrapper", "cfg.model.pop", "load_tensorrt_plugin", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "trt_file", ":", "str", ",", "\n", "cfg", ":", "Any", ",", "\n", "device_id", ":", "int", ",", "\n", "show_score", ":", "bool", "=", "False", ")", ":", "\n", "        ", "if", "'type'", "in", "cfg", ".", "model", ":", "\n", "            ", "cfg", ".", "model", ".", "pop", "(", "'type'", ")", "\n", "", "SingleStageTextDetector", ".", "__init__", "(", "self", ",", "**", "(", "cfg", ".", "model", ")", ")", "\n", "TextDetectorMixin", ".", "__init__", "(", "self", ",", "show_score", ")", "\n", "from", "mmcv", ".", "tensorrt", "import", "TRTWrapper", ",", "load_tensorrt_plugin", "\n", "try", ":", "\n", "            ", "load_tensorrt_plugin", "(", ")", "\n", "", "except", "(", "ImportError", ",", "ModuleNotFoundError", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'If input model has custom op from mmcv, \\\n                you may have to build mmcv with TensorRT from source.'", ")", "\n", "", "model", "=", "TRTWrapper", "(", "\n", "trt_file", ",", "input_names", "=", "[", "'input'", "]", ",", "output_names", "=", "[", "'output'", "]", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "device_id", "=", "device_id", "\n", "self", ".", "cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTDetector.forward_train": [[230, 232], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTDetector.aug_test": [[233, 235], ["NotImplementedError"], "methods", ["None"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTDetector.extract_feat": [[236, 238], ["NotImplementedError"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTDetector.simple_test": [[239, 258], ["torch.cuda.device", "torch.no_grad", "len", "deploy_utils.TensorRTDetector.model", "deploy_utils.TensorRTDetector.bbox_head.get_boundary", "deploy_utils.TensorRTDetector.bbox_head.get_boundary", "range", "trt_pred[].unsqueeze", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "def", "simple_test", "(", "self", ",", "\n", "img", ":", "torch", ".", "Tensor", ",", "\n", "img_metas", ":", "Iterable", ",", "\n", "rescale", ":", "bool", "=", "False", ")", ":", "\n", "        ", "with", "torch", ".", "cuda", ".", "device", "(", "self", ".", "device_id", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "trt_pred", "=", "self", ".", "model", "(", "{", "'input'", ":", "img", "}", ")", "[", "'output'", "]", "\n", "", "if", "len", "(", "img_metas", ")", ">", "1", ":", "\n", "            ", "boundaries", "=", "[", "\n", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "(", "trt_pred", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", ",", "\n", "[", "img_metas", "[", "i", "]", "]", ",", "rescale", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "img_metas", ")", ")", "\n", "]", "\n", "\n", "", "else", ":", "\n", "            ", "boundaries", "=", "[", "\n", "self", ".", "bbox_head", ".", "get_boundary", "(", "*", "trt_pred", ",", "img_metas", ",", "rescale", ")", "\n", "]", "\n", "\n", "", "return", "boundaries", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__": [[264, 284], ["mmocr.models.textrecog.recognizer.encode_decode_recognizer.EncodeDecodeRecognizer.__init__", "TRTWrapper", "cfg.model.pop", "load_tensorrt_plugin", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.__init__"], ["def", "__init__", "(", "self", ",", "\n", "trt_file", ":", "str", ",", "\n", "cfg", ":", "Any", ",", "\n", "device_id", ":", "int", ",", "\n", "show_score", ":", "bool", "=", "False", ")", ":", "\n", "        ", "if", "'type'", "in", "cfg", ".", "model", ":", "\n", "            ", "cfg", ".", "model", ".", "pop", "(", "'type'", ")", "\n", "", "EncodeDecodeRecognizer", ".", "__init__", "(", "self", ",", "**", "(", "cfg", ".", "model", ")", ")", "\n", "from", "mmcv", ".", "tensorrt", "import", "TRTWrapper", ",", "load_tensorrt_plugin", "\n", "try", ":", "\n", "            ", "load_tensorrt_plugin", "(", ")", "\n", "", "except", "(", "ImportError", ",", "ModuleNotFoundError", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'If input model has custom op from mmcv, \\\n                you may have to build mmcv with TensorRT from source.'", ")", "\n", "", "model", "=", "TRTWrapper", "(", "\n", "trt_file", ",", "input_names", "=", "[", "'input'", "]", ",", "output_names", "=", "[", "'output'", "]", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "device_id", "=", "device_id", "\n", "self", ".", "cfg", "=", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train": [[285, 287], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward_train", "(", "self", ",", "img", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.aug_test": [[288, 299], ["isinstance", "deploy_utils.TensorRTRecognizer.simple_test", "enumerate", "isinstance", "each_img.dim", "each_img.unsqueeze", "len"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test"], ["", "def", "aug_test", "(", "self", ",", "imgs", ",", "img_metas", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "            ", "for", "idx", ",", "each_img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "                ", "if", "each_img", ".", "dim", "(", ")", "==", "3", ":", "\n", "                    ", "imgs", "[", "idx", "]", "=", "each_img", ".", "unsqueeze", "(", "0", ")", "\n", "", "", "imgs", "=", "imgs", "[", "0", "]", "# avoid aug_test", "\n", "img_metas", "=", "img_metas", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "if", "len", "(", "img_metas", ")", "==", "1", "and", "isinstance", "(", "img_metas", "[", "0", "]", ",", "list", ")", ":", "\n", "                ", "img_metas", "=", "img_metas", "[", "0", "]", "\n", "", "", "return", "self", ".", "simple_test", "(", "imgs", ",", "img_metas", "=", "img_metas", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat": [[300, 302], ["NotImplementedError"], "methods", ["None"], ["", "def", "extract_feat", "(", "self", ",", "imgs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'This method is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test": [[303, 329], ["deploy_utils.TensorRTRecognizer.label_convertor.tensor2idx", "deploy_utils.TensorRTRecognizer.label_convertor.idx2str", "zip", "torch.cuda.device", "torch.no_grad", "results.append", "deploy_utils.TensorRTRecognizer.model", "dict"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str"], ["", "def", "simple_test", "(", "self", ",", "\n", "img", ":", "torch", ".", "Tensor", ",", "\n", "img_metas", ":", "Iterable", ",", "\n", "rescale", ":", "bool", "=", "False", ")", ":", "\n", "        ", "\"\"\"Test function.\n\n        Args:\n            imgs (torch.Tensor): Image input tensor.\n            img_metas (list[dict]): List of image information.\n\n        Returns:\n            list[str]: Text label result of each image.\n        \"\"\"", "\n", "with", "torch", ".", "cuda", ".", "device", "(", "self", ".", "device_id", ")", ",", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "trt_pred", "=", "self", ".", "model", "(", "{", "'input'", ":", "img", "}", ")", "[", "'output'", "]", "\n", "\n", "", "label_indexes", ",", "label_scores", "=", "self", ".", "label_convertor", ".", "tensor2idx", "(", "\n", "trt_pred", ",", "img_metas", ")", "\n", "label_strings", "=", "self", ".", "label_convertor", ".", "idx2str", "(", "label_indexes", ")", "\n", "\n", "# flatten batch results", "\n", "results", "=", "[", "]", "\n", "for", "string", ",", "score", "in", "zip", "(", "label_strings", ",", "label_scores", ")", ":", "\n", "            ", "results", ".", "append", "(", "dict", "(", "text", "=", "string", ",", "score", "=", "score", ")", ")", "\n", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.inference_with_session": [[18, 35], ["io_binding.bind_input", "sess.run_with_iobinding", "io_binding.copy_outputs_to_cpu", "io_binding.bind_output", "input_tensor.data_ptr"], "function", ["None"], ["def", "inference_with_session", "(", "sess", ",", "io_binding", ",", "input_name", ",", "output_names", ",", "\n", "input_tensor", ")", ":", "\n", "    ", "device_type", "=", "input_tensor", ".", "device", ".", "type", "\n", "device_id", "=", "input_tensor", ".", "device", ".", "index", "\n", "device_id", "=", "0", "if", "device_id", "is", "None", "else", "device_id", "\n", "io_binding", ".", "bind_input", "(", "\n", "name", "=", "input_name", ",", "\n", "device_type", "=", "device_type", ",", "\n", "device_id", "=", "device_id", ",", "\n", "element_type", "=", "np", ".", "float32", ",", "\n", "shape", "=", "input_tensor", ".", "shape", ",", "\n", "buffer_ptr", "=", "input_tensor", ".", "data_ptr", "(", ")", ")", "\n", "for", "name", "in", "output_names", ":", "\n", "        ", "io_binding", ".", "bind_output", "(", "name", ")", "\n", "", "sess", ".", "run_with_iobinding", "(", "io_binding", ")", "\n", "pred", "=", "io_binding", ".", "copy_outputs_to_cpu", "(", ")", "\n", "return", "pred", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx._convert_batchnorm": [[21, 40], ["isinstance", "module.named_children", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d.add_module", "module.weight.data.clone().detach", "module.bias.data.clone().detach", "pytorch2onnx._convert_batchnorm", "module.weight.data.clone", "module.bias.data.clone"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx._convert_batchnorm"], ["def", "_convert_batchnorm", "(", "module", ")", ":", "\n", "    ", "module_output", "=", "module", "\n", "if", "isinstance", "(", "module", ",", "torch", ".", "nn", ".", "SyncBatchNorm", ")", ":", "\n", "        ", "module_output", "=", "torch", ".", "nn", ".", "BatchNorm2d", "(", "module", ".", "num_features", ",", "module", ".", "eps", ",", "\n", "module", ".", "momentum", ",", "module", ".", "affine", ",", "\n", "module", ".", "track_running_stats", ")", "\n", "if", "module", ".", "affine", ":", "\n", "            ", "module_output", ".", "weight", ".", "data", "=", "module", ".", "weight", ".", "data", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "module_output", ".", "bias", ".", "data", "=", "module", ".", "bias", ".", "data", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "# keep requires_grad unchanged", "\n", "module_output", ".", "weight", ".", "requires_grad", "=", "module", ".", "weight", ".", "requires_grad", "\n", "module_output", ".", "bias", ".", "requires_grad", "=", "module", ".", "bias", ".", "requires_grad", "\n", "", "module_output", ".", "running_mean", "=", "module", ".", "running_mean", "\n", "module_output", ".", "running_var", "=", "module", ".", "running_var", "\n", "module_output", ".", "num_batches_tracked", "=", "module", ".", "num_batches_tracked", "\n", "", "for", "name", ",", "child", "in", "module", ".", "named_children", "(", ")", ":", "\n", "        ", "module_output", ".", "add_module", "(", "name", ",", "_convert_batchnorm", "(", "child", ")", ")", "\n", "", "del", "module", "\n", "return", "module_output", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx._prepare_data": [[42, 108], ["isinstance", "isinstance", "mmdet.datasets.replace_ImageToTensor", "mmdet.datasets.pipelines.Compose", "mmcv.parallel.collate", "isinstance", "isinstance", "isinstance", "cfg.copy.copy", "mmdet.datasets.pipelines.Compose.", "mmcv.parallel.collate.append", "isinstance", "Exception", "isinstance", "isinstance", "AssertionError", "AssertionError", "dict", "dict", "len", "len", "dict", "len"], "function", ["None"], ["", "def", "_prepare_data", "(", "cfg", ",", "imgs", ")", ":", "\n", "    ", "\"\"\"Inference image(s) with the detector.\n\n    Args:\n        model (nn.Module): The loaded detector.\n        imgs (str/ndarray or list[str/ndarray] or tuple[str/ndarray]):\n            Either image files or loaded images.\n    Returns:\n        result (dict): Predicted results.\n    \"\"\"", "\n", "if", "isinstance", "(", "imgs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "imgs", "[", "0", "]", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "'imgs must be strings or numpy arrays'", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "imgs", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", ":", "\n", "        ", "imgs", "=", "[", "imgs", "]", "\n", "", "else", ":", "\n", "        ", "raise", "AssertionError", "(", "'imgs must be strings or numpy arrays'", ")", "\n", "\n", "", "is_ndarray", "=", "isinstance", "(", "imgs", "[", "0", "]", ",", "np", ".", "ndarray", ")", "\n", "\n", "if", "is_ndarray", ":", "\n", "        ", "cfg", "=", "cfg", ".", "copy", "(", ")", "\n", "# set loading pipeline type", "\n", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "0", "]", ".", "type", "=", "'LoadImageFromNdarray'", "\n", "\n", "", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "replace_ImageToTensor", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "test_pipeline", "=", "Compose", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "\n", "data", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "# prepare data", "\n", "        ", "if", "is_ndarray", ":", "\n", "# directly add img", "\n", "            ", "datum", "=", "dict", "(", "img", "=", "img", ")", "\n", "", "else", ":", "\n", "# add information into dict", "\n", "            ", "datum", "=", "dict", "(", "img_info", "=", "dict", "(", "filename", "=", "img", ")", ",", "img_prefix", "=", "None", ")", "\n", "\n", "# build the data pipeline", "\n", "", "datum", "=", "test_pipeline", "(", "datum", ")", "\n", "# get tensor from list to stack for batch mode (text detection)", "\n", "data", ".", "append", "(", "datum", ")", "\n", "\n", "", "if", "isinstance", "(", "data", "[", "0", "]", "[", "'img'", "]", ",", "list", ")", "and", "len", "(", "data", ")", ">", "1", ":", "\n", "        ", "raise", "Exception", "(", "'aug test does not support '", "\n", "f'inference with batch size '", "\n", "f'{len(data)}'", ")", "\n", "\n", "", "data", "=", "collate", "(", "data", ",", "samples_per_gpu", "=", "len", "(", "imgs", ")", ")", "\n", "\n", "# process img_metas", "\n", "if", "isinstance", "(", "data", "[", "'img_metas'", "]", ",", "list", ")", ":", "\n", "        ", "data", "[", "'img_metas'", "]", "=", "[", "\n", "img_metas", ".", "data", "[", "0", "]", "for", "img_metas", "in", "data", "[", "'img_metas'", "]", "\n", "]", "\n", "", "else", ":", "\n", "        ", "data", "[", "'img_metas'", "]", "=", "data", "[", "'img_metas'", "]", ".", "data", "\n", "\n", "", "if", "isinstance", "(", "data", "[", "'img'", "]", ",", "list", ")", ":", "\n", "        ", "data", "[", "'img'", "]", "=", "[", "img", ".", "data", "for", "img", "in", "data", "[", "'img'", "]", "]", "\n", "if", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "list", ")", ":", "\n", "            ", "data", "[", "'img'", "]", "=", "[", "img", "[", "0", "]", "for", "img", "in", "data", "[", "'img'", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "data", "[", "'img'", "]", "=", "data", "[", "'img'", "]", ".", "data", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx.pytorch2onnx": [[110, 278], ["torch.device", "model.to().eval", "pytorch2onnx._convert_batchnorm", "pytorch2onnx._prepare_data", "_prepare_data.pop", "_prepare_data.pop", "isinstance", "mmcv.onnx.register_extra_symbolics", "print", "img[].to", "functools.partial", "functools.partial", "torch.no_grad", "torch.onnx.export", "onnx.load", "onnx.checker.check_model", "mmocr.core.deployment.ONNXRuntimeRecognizer.simple_test", "print", "model.to", "torch.no_grad", "model.simple_test", "mmocr.core.deployment.ONNXRuntimeDetector", "mmocr.core.deployment.ONNXRuntimeRecognizer", "zip", "zip", "mmocr.core.deployment.ONNXRuntimeRecognizer.show_result", "model.show_result", "cv2.imshow", "cv2.imshow", "cv2.waitKey", "torch.nn.functional.interpolate", "cv2.imread", "cv2.imread", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx._convert_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx._prepare_data", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "pytorch2onnx", "(", "model", ":", "nn", ".", "Module", ",", "\n", "model_type", ":", "str", ",", "\n", "img_path", ":", "str", ",", "\n", "verbose", ":", "bool", "=", "False", ",", "\n", "show", ":", "bool", "=", "False", ",", "\n", "opset_version", ":", "int", "=", "11", ",", "\n", "output_file", ":", "str", "=", "'tmp.onnx'", ",", "\n", "verify", ":", "bool", "=", "False", ",", "\n", "dynamic_export", ":", "bool", "=", "False", ",", "\n", "device_id", ":", "int", "=", "0", ")", ":", "\n", "    ", "\"\"\"Export PyTorch model to ONNX model and verify the outputs are same\n    between PyTorch and ONNX.\n\n    Args:\n        model (nn.Module): PyTorch model we want to export.\n        model_type (str): Model type, detection or recognition model.\n        img_path (str): We need to use this input to execute the model.\n        opset_version (int): The onnx op version. Default: 11.\n        verbose (bool): Whether print the computation graph. Default: False.\n        show (bool): Whether visialize final results. Default: False.\n        output_file (string): The path to where we store the output ONNX model.\n            Default: `tmp.onnx`.\n        verify (bool): Whether compare the outputs between PyTorch and ONNX.\n            Default: False.\n        dynamic_export (bool): Whether apply dynamic export.\n            Default: False.\n        device_id (id): Device id to place model and data.\n            Default: 0\n    \"\"\"", "\n", "device", "=", "torch", ".", "device", "(", "type", "=", "'cuda'", ",", "index", "=", "device_id", ")", "\n", "model", ".", "to", "(", "device", ")", ".", "eval", "(", ")", "\n", "_convert_batchnorm", "(", "model", ")", "\n", "\n", "# prepare inputs", "\n", "mm_inputs", "=", "_prepare_data", "(", "cfg", "=", "model", ".", "cfg", ",", "imgs", "=", "img_path", ")", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'img'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "\n", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "        ", "imgs", "=", "imgs", "[", "0", "]", "\n", "\n", "", "img_list", "=", "[", "img", "[", "None", ",", ":", "]", ".", "to", "(", "device", ")", "for", "img", "in", "imgs", "]", "\n", "\n", "origin_forward", "=", "model", ".", "forward", "\n", "if", "(", "model_type", "==", "'det'", ")", ":", "\n", "        ", "model", ".", "forward", "=", "partial", "(", "\n", "model", ".", "simple_test", ",", "img_metas", "=", "img_metas", ",", "rescale", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "forward", "=", "partial", "(", "\n", "model", ".", "forward", ",", "\n", "img_metas", "=", "img_metas", ",", "\n", "return_loss", "=", "False", ",", "\n", "rescale", "=", "True", ")", "\n", "\n", "# pytorch has some bug in pytorch1.3, we have to fix it", "\n", "# by replacing these existing op", "\n", "", "register_extra_symbolics", "(", "opset_version", ")", "\n", "dynamic_axes", "=", "None", "\n", "if", "dynamic_export", "and", "model_type", "==", "'det'", ":", "\n", "        ", "dynamic_axes", "=", "{", "\n", "'input'", ":", "{", "\n", "0", ":", "'batch'", ",", "\n", "2", ":", "'height'", ",", "\n", "3", ":", "'width'", "\n", "}", ",", "\n", "'output'", ":", "{", "\n", "0", ":", "'batch'", ",", "\n", "2", ":", "'height'", ",", "\n", "3", ":", "'width'", "\n", "}", "\n", "}", "\n", "", "elif", "dynamic_export", "and", "model_type", "==", "'recog'", ":", "\n", "        ", "dynamic_axes", "=", "{", "\n", "'input'", ":", "{", "\n", "0", ":", "'batch'", ",", "\n", "3", ":", "'width'", "\n", "}", ",", "\n", "'output'", ":", "{", "\n", "0", ":", "'batch'", ",", "\n", "1", ":", "'seq_len'", ",", "\n", "2", ":", "'num_classes'", "\n", "}", "\n", "}", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "torch", ".", "onnx", ".", "export", "(", "\n", "model", ",", "(", "img_list", "[", "0", "]", ",", ")", ",", "\n", "output_file", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "export_params", "=", "True", ",", "\n", "keep_initializers_as_inputs", "=", "False", ",", "\n", "verbose", "=", "verbose", ",", "\n", "opset_version", "=", "opset_version", ",", "\n", "dynamic_axes", "=", "dynamic_axes", ")", "\n", "", "print", "(", "f'Successfully exported ONNX model: {output_file}'", ")", "\n", "if", "verify", ":", "\n", "# check by onnx", "\n", "        ", "import", "onnx", "\n", "onnx_model", "=", "onnx", ".", "load", "(", "output_file", ")", "\n", "onnx", ".", "checker", ".", "check_model", "(", "onnx_model", ")", "\n", "\n", "scale_factor", "=", "(", "0.5", ",", "0.5", ")", "if", "model_type", "==", "'det'", "else", "(", "1", ",", "0.5", ")", "\n", "if", "dynamic_export", ":", "\n", "# scale image for dynamic shape test", "\n", "            ", "img_list", "=", "[", "\n", "nn", ".", "functional", ".", "interpolate", "(", "_", ",", "scale_factor", "=", "scale_factor", ")", "\n", "for", "_", "in", "img_list", "\n", "]", "\n", "if", "model_type", "==", "'det'", ":", "\n", "                ", "img_metas", "[", "0", "]", "[", "0", "]", "[", "\n", "'scale_factor'", "]", "=", "img_metas", "[", "0", "]", "[", "0", "]", "[", "'scale_factor'", "]", "*", "(", "\n", "scale_factor", "*", "2", ")", "\n", "\n", "# check the numerical value", "\n", "# get pytorch output", "\n", "", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "model", ".", "forward", "=", "origin_forward", "\n", "pytorch_out", "=", "model", ".", "simple_test", "(", "\n", "img_list", "[", "0", "]", ",", "img_metas", "[", "0", "]", ",", "rescale", "=", "True", ")", "\n", "\n", "# get onnx output", "\n", "", "if", "model_type", "==", "'det'", ":", "\n", "            ", "onnx_model", "=", "ONNXRuntimeDetector", "(", "output_file", ",", "model", ".", "cfg", ",", "device_id", ")", "\n", "", "else", ":", "\n", "            ", "onnx_model", "=", "ONNXRuntimeRecognizer", "(", "output_file", ",", "model", ".", "cfg", ",", "\n", "device_id", ")", "\n", "", "onnx_out", "=", "onnx_model", ".", "simple_test", "(", "\n", "img_list", "[", "0", "]", ",", "img_metas", "[", "0", "]", ",", "rescale", "=", "True", ")", "\n", "\n", "# compare results", "\n", "same_diff", "=", "'same'", "\n", "if", "model_type", "==", "'recog'", ":", "\n", "            ", "for", "onnx_result", ",", "pytorch_result", "in", "zip", "(", "onnx_out", ",", "pytorch_out", ")", ":", "\n", "                ", "if", "onnx_result", "[", "'text'", "]", "!=", "pytorch_result", "[", "\n", "'text'", "]", "or", "not", "np", ".", "allclose", "(", "\n", "np", ".", "array", "(", "onnx_result", "[", "'score'", "]", ")", ",", "\n", "np", ".", "array", "(", "pytorch_result", "[", "'score'", "]", ")", ",", "\n", "rtol", "=", "1e-4", ",", "\n", "atol", "=", "1e-4", ")", ":", "\n", "                    ", "same_diff", "=", "'different'", "\n", "break", "\n", "", "", "", "else", ":", "\n", "            ", "for", "onnx_result", ",", "pytorch_result", "in", "zip", "(", "\n", "onnx_out", "[", "0", "]", "[", "'boundary_result'", "]", ",", "\n", "pytorch_out", "[", "0", "]", "[", "'boundary_result'", "]", ")", ":", "\n", "                ", "if", "not", "np", ".", "allclose", "(", "\n", "np", ".", "array", "(", "onnx_result", ")", ",", "\n", "np", ".", "array", "(", "pytorch_result", ")", ",", "\n", "rtol", "=", "1e-4", ",", "\n", "atol", "=", "1e-4", ")", ":", "\n", "                    ", "same_diff", "=", "'different'", "\n", "break", "\n", "", "", "", "print", "(", "'The outputs are {} between PyTorch and ONNX'", ".", "format", "(", "same_diff", ")", ")", "\n", "\n", "if", "show", ":", "\n", "            ", "onnx_img", "=", "onnx_model", ".", "show_result", "(", "\n", "img_path", ",", "onnx_out", "[", "0", "]", ",", "out_file", "=", "'onnx.jpg'", ",", "show", "=", "False", ")", "\n", "pytorch_img", "=", "model", ".", "show_result", "(", "\n", "img_path", ",", "pytorch_out", "[", "0", "]", ",", "out_file", "=", "'pytorch.jpg'", ",", "show", "=", "False", ")", "\n", "if", "onnx_img", "is", "None", ":", "\n", "                ", "onnx_img", "=", "cv2", ".", "imread", "(", "img_path", ")", "\n", "", "if", "pytorch_img", "is", "None", ":", "\n", "                ", "pytorch_img", "=", "cv2", ".", "imread", "(", "img_path", ")", "\n", "\n", "", "cv2", ".", "imshow", "(", "'PyTorch'", ",", "pytorch_img", ")", "\n", "cv2", ".", "imshow", "(", "'ONNXRuntime'", ",", "onnx_img", ")", "\n", "cv2", ".", "waitKey", "(", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx.main": [[280, 365], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "warnings.warn", "torch.device", "mmocr.apis.init_detector", "hasattr", "mmocr.utils.is_2dlist", "pytorch2onnx.pytorch2onnx", "mmocr.apis.init_detector.cfg.data.test.get", "mmocr.utils.is_2dlist"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.pytorch2onnx.pytorch2onnx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", "\n", "description", "=", "'Convert MMOCR models from pytorch to ONNX'", ")", "\n", "parser", ".", "add_argument", "(", "'model_config'", ",", "type", "=", "str", ",", "help", "=", "'Config file.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'model_ckpt'", ",", "type", "=", "str", ",", "help", "=", "'Checkpint file (local or url).'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'model_type'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'Detection or recognition model to deploy.'", ",", "\n", "choices", "=", "[", "'recog'", ",", "'det'", "]", ")", "\n", "parser", ".", "add_argument", "(", "'image_path'", ",", "type", "=", "str", ",", "help", "=", "'Input Image file.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output-file'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'Output file name of the onnx model.'", ",", "\n", "default", "=", "'tmp.onnx'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device-id'", ",", "default", "=", "0", ",", "help", "=", "'Device used for inference.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--opset-version'", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'ONNX opset version, default to 11.'", ",", "\n", "default", "=", "11", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--verify'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether verify the outputs of onnx and pytorch are same.'", ",", "\n", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--verbose'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether print the computation graph.'", ",", "\n", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--show'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether visualize final output.'", ",", "\n", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--dynamic-export'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether dynamically export onnx model.'", ",", "\n", "default", "=", "False", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Following strings of text style are from colorama package", "\n", "bright_style", ",", "reset_style", "=", "'\\x1b[1m'", ",", "'\\x1b[0m'", "\n", "red_text", ",", "blue_text", "=", "'\\x1b[31m'", ",", "'\\x1b[34m'", "\n", "white_background", "=", "'\\x1b[107m'", "\n", "\n", "msg", "=", "white_background", "+", "bright_style", "+", "red_text", "\n", "msg", "+=", "'DeprecationWarning: This tool will be deprecated in future. '", "\n", "msg", "+=", "blue_text", "+", "'Welcome to use the unified model deployment toolbox '", "\n", "msg", "+=", "'MMDeploy: https://github.com/open-mmlab/mmdeploy'", "\n", "msg", "+=", "reset_style", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "\n", "device", "=", "torch", ".", "device", "(", "type", "=", "'cuda'", ",", "index", "=", "args", ".", "device_id", ")", "\n", "\n", "# build model", "\n", "model", "=", "init_detector", "(", "args", ".", "model_config", ",", "args", ".", "model_ckpt", ",", "device", "=", "device", ")", "\n", "if", "hasattr", "(", "model", ",", "'module'", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "", "if", "model", ".", "cfg", ".", "data", ".", "test", ".", "get", "(", "'pipeline'", ",", "None", ")", "is", "None", ":", "\n", "        ", "if", "is_2dlist", "(", "model", ".", "cfg", ".", "data", ".", "test", ".", "datasets", ")", ":", "\n", "            ", "model", ".", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "model", ".", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "[", "0", "]", ".", "pipeline", "\n", "", "else", ":", "\n", "            ", "model", ".", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "model", ".", "cfg", ".", "data", ".", "test", "[", "'datasets'", "]", "[", "0", "]", ".", "pipeline", "\n", "", "", "if", "is_2dlist", "(", "model", ".", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", ":", "\n", "        ", "model", ".", "cfg", ".", "data", ".", "test", ".", "pipeline", "=", "model", ".", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "0", "]", "\n", "\n", "", "pytorch2onnx", "(", "\n", "model", ",", "\n", "model_type", "=", "args", ".", "model_type", ",", "\n", "output_file", "=", "args", ".", "output_file", ",", "\n", "img_path", "=", "args", ".", "image_path", ",", "\n", "opset_version", "=", "args", ".", "opset_version", ",", "\n", "verify", "=", "args", ".", "verify", ",", "\n", "verbose", "=", "args", ".", "verbose", ",", "\n", "show", "=", "args", ".", "show", ",", "\n", "device_id", "=", "args", ".", "device_id", ",", "\n", "dynamic_export", "=", "args", ".", "dynamic_export", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt.get_GiB": [[23, 26], ["None"], "function", ["None"], ["def", "get_GiB", "(", "x", ":", "int", ")", ":", "\n", "    ", "\"\"\"return x GiB.\"\"\"", "\n", "return", "x", "*", "(", "1", "<<", "30", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt._prepare_input_img": [[28, 83], ["isinstance", "mmdet.datasets.replace_ImageToTensor", "mmdet.datasets.pipelines.Compose", "mmcv.parallel.collate", "isinstance", "isinstance", "isinstance", "dict", "mmdet.datasets.pipelines.Compose.", "mmcv.parallel.collate.append", "isinstance", "Exception", "isinstance", "isinstance", "AssertionError", "AssertionError", "len", "len", "dict", "len"], "function", ["None"], ["", "def", "_prepare_input_img", "(", "imgs", ",", "test_pipeline", ":", "Iterable", "[", "dict", "]", ")", ":", "\n", "    ", "\"\"\"Inference image(s) with the detector.\n\n    Args:\n        imgs (str/ndarray or list[str/ndarray] or tuple[str/ndarray]):\n            Either image files or loaded images.\n        test_pipeline (Iterable[dict]): Test pipline of configuration.\n    Returns:\n        result (dict): Predicted results.\n    \"\"\"", "\n", "if", "isinstance", "(", "imgs", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "imgs", "[", "0", "]", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", ":", "\n", "            ", "raise", "AssertionError", "(", "'imgs must be strings or numpy arrays'", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "imgs", ",", "(", "np", ".", "ndarray", ",", "str", ")", ")", ":", "\n", "        ", "imgs", "=", "[", "imgs", "]", "\n", "", "else", ":", "\n", "        ", "raise", "AssertionError", "(", "'imgs must be strings or numpy arrays'", ")", "\n", "\n", "", "test_pipeline", "=", "replace_ImageToTensor", "(", "test_pipeline", ")", "\n", "test_pipeline", "=", "Compose", "(", "test_pipeline", ")", "\n", "\n", "data", "=", "[", "]", "\n", "for", "img", "in", "imgs", ":", "\n", "# prepare data", "\n", "# add information into dict", "\n", "        ", "datum", "=", "dict", "(", "img_info", "=", "dict", "(", "filename", "=", "img", ")", ",", "img_prefix", "=", "None", ")", "\n", "\n", "# build the data pipeline", "\n", "datum", "=", "test_pipeline", "(", "datum", ")", "\n", "# get tensor from list to stack for batch mode (text detection)", "\n", "data", ".", "append", "(", "datum", ")", "\n", "\n", "", "if", "isinstance", "(", "data", "[", "0", "]", "[", "'img'", "]", ",", "list", ")", "and", "len", "(", "data", ")", ">", "1", ":", "\n", "        ", "raise", "Exception", "(", "'aug test does not support '", "\n", "f'inference with batch size '", "\n", "f'{len(data)}'", ")", "\n", "\n", "", "data", "=", "collate", "(", "data", ",", "samples_per_gpu", "=", "len", "(", "imgs", ")", ")", "\n", "\n", "# process img_metas", "\n", "if", "isinstance", "(", "data", "[", "'img_metas'", "]", ",", "list", ")", ":", "\n", "        ", "data", "[", "'img_metas'", "]", "=", "[", "\n", "img_metas", ".", "data", "[", "0", "]", "for", "img_metas", "in", "data", "[", "'img_metas'", "]", "\n", "]", "\n", "", "else", ":", "\n", "        ", "data", "[", "'img_metas'", "]", "=", "data", "[", "'img_metas'", "]", ".", "data", "\n", "\n", "", "if", "isinstance", "(", "data", "[", "'img'", "]", ",", "list", ")", ":", "\n", "        ", "data", "[", "'img'", "]", "=", "[", "img", ".", "data", "for", "img", "in", "data", "[", "'img'", "]", "]", "\n", "if", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "list", ")", ":", "\n", "            ", "data", "[", "'img'", "]", "=", "[", "img", "[", "0", "]", "for", "img", "in", "data", "[", "'img'", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "data", "[", "'img'", "]", "=", "data", "[", "'img'", "]", ".", "data", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt.onnx2tensorrt": [[85, 186], ["onnx2tensorrt.get_GiB", "mmcv.tensorrt.onnx2trt", "os.split", "mmcv.tensorrt.save_trt_engine", "print", "os.makedirs", "os.makedirs", "onnx2tensorrt._prepare_input_img", "_prepare_input_img.pop", "_prepare_input_img.pop", "isinstance", "mmocr.core.deployment.ONNXRuntimeRecognizer.simple_test", "img_list[].to", "mmocr.core.deployment.TensorRTRecognizer.simple_test", "print", "mmocr.core.deployment.ONNXRuntimeDetector", "mmocr.core.deployment.ONNXRuntimeRecognizer", "mmocr.core.deployment.TensorRTDetector", "mmocr.core.deployment.TensorRTRecognizer", "torch.device", "zip", "zip", "mmocr.core.deployment.ONNXRuntimeRecognizer.show_result", "mmocr.core.deployment.TensorRTRecognizer.show_result", "cv2.imshow", "cv2.imshow", "cv2.waitKey", "cv2.imread", "cv2.imread", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt.get_GiB", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt._prepare_input_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "onnx2tensorrt", "(", "onnx_file", ":", "str", ",", "\n", "model_type", ":", "str", ",", "\n", "trt_file", ":", "str", ",", "\n", "config", ":", "dict", ",", "\n", "input_config", ":", "dict", ",", "\n", "fp16", ":", "bool", "=", "False", ",", "\n", "verify", ":", "bool", "=", "False", ",", "\n", "show", ":", "bool", "=", "False", ",", "\n", "workspace_size", ":", "int", "=", "1", ",", "\n", "verbose", ":", "bool", "=", "False", ")", ":", "\n", "    ", "import", "tensorrt", "as", "trt", "\n", "min_shape", "=", "input_config", "[", "'min_shape'", "]", "\n", "max_shape", "=", "input_config", "[", "'max_shape'", "]", "\n", "# create trt engine and wrapper", "\n", "opt_shape_dict", "=", "{", "'input'", ":", "[", "min_shape", ",", "min_shape", ",", "max_shape", "]", "}", "\n", "max_workspace_size", "=", "get_GiB", "(", "workspace_size", ")", "\n", "trt_engine", "=", "onnx2trt", "(", "\n", "onnx_file", ",", "\n", "opt_shape_dict", ",", "\n", "log_level", "=", "trt", ".", "Logger", ".", "VERBOSE", "if", "verbose", "else", "trt", ".", "Logger", ".", "ERROR", ",", "\n", "fp16_mode", "=", "fp16", ",", "\n", "max_workspace_size", "=", "max_workspace_size", ")", "\n", "save_dir", ",", "_", "=", "osp", ".", "split", "(", "trt_file", ")", "\n", "if", "save_dir", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_dir", ",", "exist_ok", "=", "True", ")", "\n", "", "save_trt_engine", "(", "trt_engine", ",", "trt_file", ")", "\n", "print", "(", "f'Successfully created TensorRT engine: {trt_file}'", ")", "\n", "\n", "if", "verify", ":", "\n", "        ", "mm_inputs", "=", "_prepare_input_img", "(", "input_config", "[", "'input_path'", "]", ",", "\n", "config", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'img'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "\n", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "            ", "imgs", "=", "imgs", "[", "0", "]", "\n", "\n", "", "img_list", "=", "[", "img", "[", "None", ",", ":", "]", "for", "img", "in", "imgs", "]", "\n", "\n", "# Get results from ONNXRuntime", "\n", "if", "model_type", "==", "'det'", ":", "\n", "            ", "onnx_model", "=", "ONNXRuntimeDetector", "(", "onnx_file", ",", "config", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "onnx_model", "=", "ONNXRuntimeRecognizer", "(", "onnx_file", ",", "config", ",", "0", ")", "\n", "", "onnx_out", "=", "onnx_model", ".", "simple_test", "(", "\n", "img_list", "[", "0", "]", ",", "img_metas", "[", "0", "]", ",", "rescale", "=", "True", ")", "\n", "\n", "# Get results from TensorRT", "\n", "if", "model_type", "==", "'det'", ":", "\n", "            ", "trt_model", "=", "TensorRTDetector", "(", "trt_file", ",", "config", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "trt_model", "=", "TensorRTRecognizer", "(", "trt_file", ",", "config", ",", "0", ")", "\n", "", "img_list", "[", "0", "]", "=", "img_list", "[", "0", "]", ".", "to", "(", "torch", ".", "device", "(", "'cuda:0'", ")", ")", "\n", "trt_out", "=", "trt_model", ".", "simple_test", "(", "\n", "img_list", "[", "0", "]", ",", "img_metas", "[", "0", "]", ",", "rescale", "=", "True", ")", "\n", "\n", "# compare results", "\n", "same_diff", "=", "'same'", "\n", "if", "model_type", "==", "'recog'", ":", "\n", "            ", "for", "onnx_result", ",", "trt_result", "in", "zip", "(", "onnx_out", ",", "trt_out", ")", ":", "\n", "                ", "if", "onnx_result", "[", "'text'", "]", "!=", "trt_result", "[", "'text'", "]", "or", "not", "np", ".", "allclose", "(", "\n", "np", ".", "array", "(", "onnx_result", "[", "'score'", "]", ")", ",", "\n", "np", ".", "array", "(", "trt_result", "[", "'score'", "]", ")", ",", "\n", "rtol", "=", "1e-4", ",", "\n", "atol", "=", "1e-4", ")", ":", "\n", "                    ", "same_diff", "=", "'different'", "\n", "break", "\n", "", "", "", "else", ":", "\n", "            ", "for", "onnx_result", ",", "trt_result", "in", "zip", "(", "onnx_out", "[", "0", "]", "[", "'boundary_result'", "]", ",", "\n", "trt_out", "[", "0", "]", "[", "'boundary_result'", "]", ")", ":", "\n", "                ", "if", "not", "np", ".", "allclose", "(", "\n", "np", ".", "array", "(", "onnx_result", ")", ",", "\n", "np", ".", "array", "(", "trt_result", ")", ",", "\n", "rtol", "=", "1e-4", ",", "\n", "atol", "=", "1e-4", ")", ":", "\n", "                    ", "same_diff", "=", "'different'", "\n", "break", "\n", "", "", "", "print", "(", "'The outputs are {} between TensorRT and ONNX'", ".", "format", "(", "same_diff", ")", ")", "\n", "\n", "if", "show", ":", "\n", "            ", "onnx_img", "=", "onnx_model", ".", "show_result", "(", "\n", "input_config", "[", "'input_path'", "]", ",", "\n", "onnx_out", "[", "0", "]", ",", "\n", "out_file", "=", "'onnx.jpg'", ",", "\n", "show", "=", "False", ")", "\n", "trt_img", "=", "trt_model", ".", "show_result", "(", "\n", "input_config", "[", "'input_path'", "]", ",", "\n", "trt_out", "[", "0", "]", ",", "\n", "out_file", "=", "'tensorrt.jpg'", ",", "\n", "show", "=", "False", ")", "\n", "if", "onnx_img", "is", "None", ":", "\n", "                ", "onnx_img", "=", "cv2", ".", "imread", "(", "input_config", "[", "'input_path'", "]", ")", "\n", "", "if", "trt_img", "is", "None", ":", "\n", "                ", "trt_img", "=", "cv2", ".", "imread", "(", "input_config", "[", "'input_path'", "]", ")", "\n", "\n", "", "cv2", ".", "imshow", "(", "'TensorRT'", ",", "trt_img", ")", "\n", "cv2", ".", "imshow", "(", "'ONNXRuntime'", ",", "onnx_img", ")", "\n", "cv2", ".", "waitKey", "(", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt.parse_args": [[188, 239], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Convert MMOCR models from ONNX to TensorRT'", ")", "\n", "parser", ".", "add_argument", "(", "'model_config'", ",", "help", "=", "'Config file of the model'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'model_type'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'Detection or recognition model to deploy.'", ",", "\n", "choices", "=", "[", "'recog'", ",", "'det'", "]", ")", "\n", "parser", ".", "add_argument", "(", "'image_path'", ",", "type", "=", "str", ",", "help", "=", "'Image for test'", ")", "\n", "parser", ".", "add_argument", "(", "'onnx_file'", ",", "help", "=", "'Path to the input ONNX model'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--trt-file'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'Path to the output TensorRT engine'", ",", "\n", "default", "=", "'tmp.trt'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--max-shape'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "4", ",", "\n", "default", "=", "[", "1", ",", "3", ",", "400", ",", "600", "]", ",", "\n", "help", "=", "'Maximum shape of model input.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--min-shape'", ",", "\n", "type", "=", "int", ",", "\n", "nargs", "=", "4", ",", "\n", "default", "=", "[", "1", ",", "3", ",", "400", ",", "600", "]", ",", "\n", "help", "=", "'Minimum shape of model input.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--workspace-size'", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "1", ",", "\n", "help", "=", "'Max workspace size in GiB.'", ")", "\n", "parser", ".", "add_argument", "(", "'--fp16'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Enable fp16 mode'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--verify'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether Verify the outputs of ONNXRuntime and TensorRT.'", ",", "\n", "default", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--show'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether visiualize outputs of ONNXRuntime and TensorRT.'", ",", "\n", "default", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--verbose'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Whether to verbose logging messages while creating \\\n                TensorRT engine.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr_handler.MMOCRHandler.initialize": [[16, 31], ["torch.device", "properties.get", "os.path.join", "os.path.join", "mmocr.apis.init_detector", "torch.cuda.is_available", "torch.cuda.is_available", "str", "properties.get"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector"], ["def", "initialize", "(", "self", ",", "context", ")", ":", "\n", "        ", "properties", "=", "context", ".", "system_properties", "\n", "self", ".", "map_location", "=", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "self", ".", "map_location", "+", "':'", "+", "\n", "str", "(", "properties", ".", "get", "(", "'gpu_id'", ")", ")", "if", "torch", ".", "cuda", ".", "\n", "is_available", "(", ")", "else", "self", ".", "map_location", ")", "\n", "self", ".", "manifest", "=", "context", ".", "manifest", "\n", "\n", "model_dir", "=", "properties", ".", "get", "(", "'model_dir'", ")", "\n", "serialized_file", "=", "self", ".", "manifest", "[", "'model'", "]", "[", "'serializedFile'", "]", "\n", "checkpoint", "=", "os", ".", "path", ".", "join", "(", "model_dir", ",", "serialized_file", ")", "\n", "self", ".", "config_file", "=", "os", ".", "path", ".", "join", "(", "model_dir", ",", "'config.py'", ")", "\n", "\n", "self", ".", "model", "=", "init_detector", "(", "self", ".", "config_file", ",", "checkpoint", ",", "self", ".", "device", ")", "\n", "self", ".", "initialized", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr_handler.MMOCRHandler.preprocess": [[32, 43], ["isinstance", "mmcv.imfrombytes", "images.append", "row.get", "row.get", "base64.b64decode"], "methods", ["None"], ["", "def", "preprocess", "(", "self", ",", "data", ")", ":", "\n", "        ", "images", "=", "[", "]", "\n", "\n", "for", "row", "in", "data", ":", "\n", "            ", "image", "=", "row", ".", "get", "(", "'data'", ")", "or", "row", ".", "get", "(", "'body'", ")", "\n", "if", "isinstance", "(", "image", ",", "str", ")", ":", "\n", "                ", "image", "=", "base64", ".", "b64decode", "(", "image", ")", "\n", "", "image", "=", "mmcv", ".", "imfrombytes", "(", "image", ")", "\n", "images", ".", "append", "(", "image", ")", "\n", "\n", "", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr_handler.MMOCRHandler.inference": [[44, 48], ["mmocr.apis.model_inference"], "methods", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "def", "inference", "(", "self", ",", "data", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "results", "=", "model_inference", "(", "self", ".", "model", ",", "data", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr_handler.MMOCRHandler.postprocess": [[49, 52], ["None"], "methods", ["None"], ["", "def", "postprocess", "(", "self", ",", "data", ")", ":", "\n", "# Format output following the example OCRHandler format", "\n", "        ", "return", "data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_test.parse_args": [[16, 45], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'MMOCR test (and eval) a onnx or tensorrt model.'", ")", "\n", "parser", ".", "add_argument", "(", "'model_config'", ",", "type", "=", "str", ",", "help", "=", "'Config file.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'model_file'", ",", "type", "=", "str", ",", "help", "=", "'Input file name for evaluation.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'model_type'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'Detection or recognition model to deploy.'", ",", "\n", "choices", "=", "[", "'recog'", ",", "'det'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'backend'", ",", "\n", "type", "=", "str", ",", "\n", "help", "=", "'Which backend to test, TensorRT or ONNXRuntime.'", ",", "\n", "choices", "=", "[", "'TensorRT'", ",", "'ONNXRuntime'", "]", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--eval'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'The evaluation metrics, which depends on the dataset, e.g.,'", "\n", "'\"bbox\", \"seg\", \"proposal\" for COCO, and \"mAP\", \"recall\" for'", "\n", "'PASCAL VOC.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'Device used for inference.'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_test.main": [[47, 106], ["deploy_test.parse_args", "warnings.warn", "mmcv.Config.fromfile", "mmocr.apis.inference.disable_text_recog_aug_test", "mmocr.datasets.build_dataset", "mmocr.datasets.build_dataloader", "mmcv.parallel.MMDataParallel", "mmdet.apis.single_gpu_test", "mmcv.runner.get_dist_info", "mmocr.core.deployment.TensorRTDetector", "mmocr.core.deployment.ONNXRuntimeDetector", "mmocr.core.deployment.TensorRTRecognizer", "mmocr.core.deployment.ONNXRuntimeRecognizer", "mmocr.apis.inference.disable_text_recog_aug_test.get().copy", "cfg.get().copy.update", "print", "cfg.get().copy.pop", "dict", "mmocr.datasets.build_dataset.evaluate", "mmocr.apis.inference.disable_text_recog_aug_test.get"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "# Following strings of text style are from colorama package", "\n", "bright_style", ",", "reset_style", "=", "'\\x1b[1m'", ",", "'\\x1b[0m'", "\n", "red_text", ",", "blue_text", "=", "'\\x1b[31m'", ",", "'\\x1b[34m'", "\n", "white_background", "=", "'\\x1b[107m'", "\n", "\n", "msg", "=", "white_background", "+", "bright_style", "+", "red_text", "\n", "msg", "+=", "'DeprecationWarning: This tool will be deprecated in future. '", "\n", "msg", "+=", "blue_text", "+", "'Welcome to use the unified model deployment toolbox '", "\n", "msg", "+=", "'MMDeploy: https://github.com/open-mmlab/mmdeploy'", "\n", "msg", "+=", "reset_style", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "\n", "if", "args", ".", "device", "==", "'cpu'", ":", "\n", "        ", "args", ".", "device", "=", "None", "\n", "\n", "", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "model_config", ")", "\n", "\n", "# build the model", "\n", "if", "args", ".", "model_type", "==", "'det'", ":", "\n", "        ", "if", "args", ".", "backend", "==", "'TensorRT'", ":", "\n", "            ", "model", "=", "TensorRTDetector", "(", "args", ".", "model_file", ",", "cfg", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "model", "=", "ONNXRuntimeDetector", "(", "args", ".", "model_file", ",", "cfg", ",", "0", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "args", ".", "backend", "==", "'TensorRT'", ":", "\n", "            ", "model", "=", "TensorRTRecognizer", "(", "args", ".", "model_file", ",", "cfg", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "model", "=", "ONNXRuntimeRecognizer", "(", "args", ".", "model_file", ",", "cfg", ",", "0", ")", "\n", "\n", "# build the dataloader", "\n", "", "", "samples_per_gpu", "=", "1", "\n", "cfg", "=", "disable_text_recog_aug_test", "(", "cfg", ")", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "test", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "samples_per_gpu", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "False", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "[", "0", "]", ")", "\n", "outputs", "=", "single_gpu_test", "(", "model", ",", "data_loader", ")", "\n", "\n", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "kwargs", "=", "{", "}", "\n", "if", "args", ".", "eval", ":", "\n", "            ", "eval_kwargs", "=", "cfg", ".", "get", "(", "'evaluation'", ",", "{", "}", ")", ".", "copy", "(", ")", "\n", "# hard-code way to remove EvalHook args", "\n", "for", "key", "in", "[", "\n", "'interval'", ",", "'tmpdir'", ",", "'start'", ",", "'gpu_collect'", ",", "'save_best'", ",", "\n", "'rule'", "\n", "]", ":", "\n", "                ", "eval_kwargs", ".", "pop", "(", "key", ",", "None", ")", "\n", "", "eval_kwargs", ".", "update", "(", "dict", "(", "metric", "=", "args", ".", "eval", ",", "**", "kwargs", ")", ")", "\n", "print", "(", "dataset", ".", "evaluate", "(", "outputs", ",", "**", "eval_kwargs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.test_torchserve.parse_args": [[10, 26], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'img'", ",", "help", "=", "'Image file'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'Config file'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'Checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "'model_name'", ",", "help", "=", "'The model name in the server'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--inference-addr'", ",", "\n", "default", "=", "'127.0.0.1:8080'", ",", "\n", "help", "=", "'Address and port of the inference server'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'Device used for inference'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--score-thr'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'bbox score threshold'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.test_torchserve.main": [[28, 59], ["mmocr.apis.init_detector", "mmocr.apis.model_inference", "mmocr.apis.init_detector.show_result", "requests.post.json", "mmocr.apis.init_detector.show_result", "response.json.keys", "open", "requests.post", "response.json.keys", "mmocr.apis.model_inference.keys", "zip", "isinstance", "numpy.allclose", "isinstance"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "main", "(", "args", ")", ":", "\n", "# build the model from a config file and a checkpoint file", "\n", "    ", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "args", ".", "device", ")", "\n", "# test a single image", "\n", "model_results", "=", "model_inference", "(", "model", ",", "args", ".", "img", ")", "\n", "model", ".", "show_result", "(", "\n", "args", ".", "img", ",", "\n", "model_results", ",", "\n", "win_name", "=", "'model_results'", ",", "\n", "show", "=", "True", ",", "\n", "score_thr", "=", "args", ".", "score_thr", ")", "\n", "url", "=", "'http://'", "+", "args", ".", "inference_addr", "+", "'/predictions/'", "+", "args", ".", "model_name", "\n", "with", "open", "(", "args", ".", "img", ",", "'rb'", ")", "as", "image", ":", "\n", "        ", "response", "=", "requests", ".", "post", "(", "url", ",", "image", ")", "\n", "", "serve_results", "=", "response", ".", "json", "(", ")", "\n", "model", ".", "show_result", "(", "\n", "args", ".", "img", ",", "\n", "serve_results", ",", "\n", "show", "=", "True", ",", "\n", "win_name", "=", "'serve_results'", ",", "\n", "score_thr", "=", "args", ".", "score_thr", ")", "\n", "assert", "serve_results", ".", "keys", "(", ")", "==", "model_results", ".", "keys", "(", ")", "\n", "for", "key", "in", "serve_results", ".", "keys", "(", ")", ":", "\n", "        ", "for", "model_result", ",", "serve_result", "in", "zip", "(", "model_results", "[", "key", "]", ",", "\n", "serve_results", "[", "key", "]", ")", ":", "\n", "            ", "if", "isinstance", "(", "model_result", "[", "0", "]", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "                ", "assert", "np", ".", "allclose", "(", "model_result", ",", "serve_result", ")", "\n", "", "elif", "isinstance", "(", "model_result", "[", "0", "]", ",", "str", ")", ":", "\n", "                ", "assert", "model_result", "==", "serve_result", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr2torchserve.mmocr2torchserve": [[15, 68], ["mmcv.mkdir_or_exist", "mmcv.Config.fromfile", "tempfile.TemporaryDirectory", "mmcv.Config.fromfile.dump", "argparse.Namespace", "ModelExportUtils.generate_manifest_json", "package_model", "pathlib.Path", "pathlib.Path"], "function", ["None"], ["", "def", "mmocr2torchserve", "(", "\n", "config_file", ":", "str", ",", "\n", "checkpoint_file", ":", "str", ",", "\n", "output_folder", ":", "str", ",", "\n", "model_name", ":", "str", ",", "\n", "model_version", ":", "str", "=", "'1.0'", ",", "\n", "force", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Converts MMOCR model (config + checkpoint) to TorchServe `.mar`.\n\n    Args:\n        config_file:\n            In MMOCR config format.\n            The contents vary for each task repository.\n        checkpoint_file:\n            In MMOCR checkpoint format.\n            The contents vary for each task repository.\n        output_folder:\n            Folder where `{model_name}.mar` will be created.\n            The file created will be in TorchServe archive format.\n        model_name:\n            If not None, used for naming the `{model_name}.mar` file\n            that will be created under `output_folder`.\n            If None, `{Path(checkpoint_file).stem}` will be used.\n        model_version:\n            Model's version.\n        force:\n            If True, if there is an existing `{model_name}.mar`\n            file under `output_folder` it will be overwritten.\n    \"\"\"", "\n", "mmcv", ".", "mkdir_or_exist", "(", "output_folder", ")", "\n", "\n", "config", "=", "mmcv", ".", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "\n", "with", "TemporaryDirectory", "(", ")", "as", "tmpdir", ":", "\n", "        ", "config", ".", "dump", "(", "f'{tmpdir}/config.py'", ")", "\n", "\n", "args", "=", "Namespace", "(", "\n", "**", "{", "\n", "'model_file'", ":", "f'{tmpdir}/config.py'", ",", "\n", "'serialized_file'", ":", "checkpoint_file", ",", "\n", "'handler'", ":", "f'{Path(__file__).parent}/mmocr_handler.py'", ",", "\n", "'model_name'", ":", "model_name", "or", "Path", "(", "checkpoint_file", ")", ".", "stem", ",", "\n", "'version'", ":", "model_version", ",", "\n", "'export_path'", ":", "output_folder", ",", "\n", "'force'", ":", "force", ",", "\n", "'requirements_file'", ":", "None", ",", "\n", "'extra_files'", ":", "None", ",", "\n", "'runtime'", ":", "'python'", ",", "\n", "'archive_format'", ":", "'default'", "\n", "}", ")", "\n", "manifest", "=", "ModelExportUtils", ".", "generate_manifest_json", "(", "args", ")", "\n", "package_model", "(", "args", ",", "manifest", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.mmocr2torchserve.parse_args": [[70, 100], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", "\n", "description", "=", "'Convert MMOCR models to TorchServe `.mar` format.'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "type", "=", "str", ",", "help", "=", "'config file path'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "type", "=", "str", ",", "help", "=", "'checkpoint file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--output-folder'", ",", "\n", "type", "=", "str", ",", "\n", "required", "=", "True", ",", "\n", "help", "=", "'Folder where `{model_name}.mar` will be created.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--model-name'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'If not None, used for naming the `{model_name}.mar`'", "\n", "'file that will be created under `output_folder`.'", "\n", "'If None, `{Path(checkpoint_file).stem}` will be used.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--model-version'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "'1.0'", ",", "\n", "help", "=", "'Number used for versioning.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'-f'", ",", "\n", "'--force'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'overwrite the existing `{model_name}.mar`'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.demo.webcam_demo.parse_args": [[12, 24], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'MMDetection webcam demo.'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'Test config file path.'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'Checkpoint file.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "type", "=", "str", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'CPU/CUDA device option.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--camera-id'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'Camera device id.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--score-thr'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'Bbox score threshold.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.demo.webcam_demo.main": [[26, 46], ["webcam_demo.parse_args", "torch.device", "mmocr.apis.init_detector", "cv2.VideoCapture", "print", "cv2.VideoCapture.read", "mmocr.apis.model_inference", "cv2.waitKey", "mmocr.apis.init_detector.show_result", "ord", "ord"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "device", "=", "torch", ".", "device", "(", "args", ".", "device", ")", "\n", "\n", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "device", ")", "\n", "\n", "camera", "=", "cv2", ".", "VideoCapture", "(", "args", ".", "camera_id", ")", "\n", "\n", "print", "(", "'Press \"Esc\", \"q\" or \"Q\" to exit.'", ")", "\n", "while", "True", ":", "\n", "        ", "ret_val", ",", "img", "=", "camera", ".", "read", "(", ")", "\n", "result", "=", "model_inference", "(", "model", ",", "img", ")", "\n", "\n", "ch", "=", "cv2", ".", "waitKey", "(", "1", ")", "\n", "if", "ch", "==", "27", "or", "ch", "==", "ord", "(", "'q'", ")", "or", "ch", "==", "ord", "(", "'Q'", ")", ":", "\n", "            ", "break", "\n", "\n", "", "model", ".", "show_result", "(", "\n", "img", ",", "result", ",", "score_thr", "=", "args", ".", "score_thr", ",", "wait_time", "=", "1", ",", "show", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.demo.ner_demo.main": [[10, 29], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "mmocr.apis.init_detector", "input", "mmocr.apis.inference.text_model_inference", "print"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.text_model_inference"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'Config file.'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'Checkpoint file.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'Device used for inference.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# build the model from a config file and a checkpoint file", "\n", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "args", ".", "device", ")", "\n", "\n", "# test a single text", "\n", "input_sentence", "=", "input", "(", "'Please enter a sentence you want to test: '", ")", "\n", "result", "=", "text_model_inference", "(", "model", ",", "input_sentence", ")", "\n", "\n", "# show the results", "\n", "for", "pred_entities", "in", "result", ":", "\n", "        ", "for", "entity", "in", "pred_entities", ":", "\n", "            ", "print", "(", "f'{entity[0]}: {input_sentence[entity[1]:entity[2] + 1]}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.publish_model.parse_args": [[9, 16], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Process a checkpoint to be published'", ")", "\n", "parser", ".", "add_argument", "(", "'in_file'", ",", "help", "=", "'input checkpoint filename'", ")", "\n", "parser", ".", "add_argument", "(", "'out_file'", ",", "help", "=", "'output checkpoint filename'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.publish_model.process_checkpoint": [[18, 31], ["torch.load", "torch.save", "subprocess.check_output().decode", "subprocess.Popen", "out_file.rstrip", "subprocess.check_output"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.master_decoder.MasterDecoder.decode"], ["", "def", "process_checkpoint", "(", "in_file", ",", "out_file", ")", ":", "\n", "    ", "checkpoint", "=", "torch", ".", "load", "(", "in_file", ",", "map_location", "=", "'cpu'", ")", "\n", "# remove optimizer for smaller file size", "\n", "if", "'optimizer'", "in", "checkpoint", ":", "\n", "        ", "del", "checkpoint", "[", "'optimizer'", "]", "\n", "# if it is necessary to remove some sensitive data in checkpoint['meta'],", "\n", "# add the code here.", "\n", "", "if", "'meta'", "in", "checkpoint", ":", "\n", "        ", "checkpoint", "[", "'meta'", "]", "=", "{", "'CLASSES'", ":", "0", "}", "\n", "", "torch", ".", "save", "(", "checkpoint", ",", "out_file", ",", "_use_new_zipfile_serialization", "=", "False", ")", "\n", "sha", "=", "subprocess", ".", "check_output", "(", "[", "'sha256sum'", ",", "out_file", "]", ")", ".", "decode", "(", ")", "\n", "final_file", "=", "out_file", ".", "rstrip", "(", "'.pth'", ")", "+", "'-{}.pth'", ".", "format", "(", "sha", "[", ":", "8", "]", ")", "\n", "subprocess", ".", "Popen", "(", "[", "'mv'", ",", "out_file", ",", "final_file", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.publish_model.main": [[33, 36], ["publish_model.parse_args", "publish_model.process_checkpoint"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.publish_model.process_checkpoint"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "process_checkpoint", "(", "args", ".", "in_file", ",", "args", ".", "out_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.recog_test_imgs.save_results": [[19, 38], ["mmocr.utils.list_to_file", "mmocr.utils.list_to_file", "mmocr.utils.list_to_file", "len", "len", "len", "os.join", "os.join", "itertools.compress", "os.join", "itertools.compress", "zip", "zip"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "save_results", "(", "img_paths", ",", "pred_labels", ",", "gt_labels", ",", "res_dir", ")", ":", "\n", "    ", "\"\"\"Save predicted results to txt file.\n\n    Args:\n        img_paths (list[str])\n        pred_labels (list[str])\n        gt_labels (list[str])\n        res_dir (str)\n    \"\"\"", "\n", "assert", "len", "(", "img_paths", ")", "==", "len", "(", "pred_labels", ")", "==", "len", "(", "gt_labels", ")", "\n", "corrects", "=", "[", "pred", "==", "gt", "for", "pred", ",", "gt", "in", "zip", "(", "pred_labels", ",", "gt_labels", ")", "]", "\n", "wrongs", "=", "[", "not", "c", "for", "c", "in", "corrects", "]", "\n", "lines", "=", "[", "\n", "f'{img} {pred} {gt}'", "\n", "for", "img", ",", "pred", ",", "gt", "in", "zip", "(", "img_paths", ",", "pred_labels", ",", "gt_labels", ")", "\n", "]", "\n", "list_to_file", "(", "osp", ".", "join", "(", "res_dir", ",", "'results.txt'", ")", ",", "lines", ")", "\n", "list_to_file", "(", "osp", ".", "join", "(", "res_dir", ",", "'correct.txt'", ")", ",", "compress", "(", "lines", ",", "corrects", ")", ")", "\n", "list_to_file", "(", "osp", ".", "join", "(", "res_dir", ",", "'wrong.txt'", ")", ",", "compress", "(", "lines", ",", "wrongs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.recog_test_imgs.main": [[40, 122], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "time.strftime", "os.join", "mmocr.utils.get_root_logger", "mmocr.apis.init_detector", "hasattr", "os.join", "mmcv.mkdir_or_exist", "os.join", "mmcv.mkdir_or_exist", "os.join", "mmcv.mkdir_or_exist", "mmocr.utils.list_from_file", "mmcv.utils.ProgressBar", "recog_test_imgs.save_results", "print", "time.localtime", "mmcv.utils.ProgressBar.update", "line.strip().split", "os.join", "mmocr.apis.model_inference", "os.join", "mmocr.apis.init_detector.show_result", "img_paths.append", "gt_labels.append", "pred_labels.append", "len", "mmocr.core.evaluation.ocr_metric.eval_ocr_metric", "mmocr.utils.get_root_logger.info", "mmocr.utils.get_root_logger.info", "mmocr.utils.get_root_logger.info", "len", "len", "os.exists", "FileNotFoundError", "img_file.split", "shutil.copy", "line.strip", "os.join", "os.join"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.save_results", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.ocr_metric.eval_ocr_metric"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'img_root_path'", ",", "type", "=", "str", ",", "help", "=", "'Image root path'", ")", "\n", "parser", ".", "add_argument", "(", "'img_list'", ",", "type", "=", "str", ",", "help", "=", "'Image path list file'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "type", "=", "str", ",", "help", "=", "'Config file'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "type", "=", "str", ",", "help", "=", "'Checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "type", "=", "str", ",", "default", "=", "'./results'", ",", "help", "=", "'Dir to save results'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--show'", ",", "action", "=", "'store_true'", ",", "help", "=", "'show image or save'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'Device used for inference.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# init the logger before other steps", "\n", "timestamp", "=", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "args", ".", "out_dir", ",", "f'{timestamp}.log'", ")", "\n", "logger", "=", "get_root_logger", "(", "log_file", "=", "log_file", ",", "log_level", "=", "'INFO'", ")", "\n", "\n", "# build the model from a config file and a checkpoint file", "\n", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "args", ".", "device", ")", "\n", "if", "hasattr", "(", "model", ",", "'module'", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "\n", "# Start Inference", "\n", "", "out_vis_dir", "=", "osp", ".", "join", "(", "args", ".", "out_dir", ",", "'out_vis_dir'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_vis_dir", ")", "\n", "correct_vis_dir", "=", "osp", ".", "join", "(", "args", ".", "out_dir", ",", "'correct'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "correct_vis_dir", ")", "\n", "wrong_vis_dir", "=", "osp", ".", "join", "(", "args", ".", "out_dir", ",", "'wrong'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "wrong_vis_dir", ")", "\n", "img_paths", ",", "pred_labels", ",", "gt_labels", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "lines", "=", "list_from_file", "(", "args", ".", "img_list", ")", "\n", "progressbar", "=", "ProgressBar", "(", "task_num", "=", "len", "(", "lines", ")", ")", "\n", "num_gt_label", "=", "0", "\n", "for", "line", "in", "lines", ":", "\n", "        ", "progressbar", ".", "update", "(", ")", "\n", "item_list", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "img_file", "=", "item_list", "[", "0", "]", "\n", "gt_label", "=", "''", "\n", "if", "len", "(", "item_list", ")", ">=", "2", ":", "\n", "            ", "gt_label", "=", "item_list", "[", "1", "]", "\n", "num_gt_label", "+=", "1", "\n", "", "img_path", "=", "osp", ".", "join", "(", "args", ".", "img_root_path", ",", "img_file", ")", "\n", "if", "not", "osp", ".", "exists", "(", "img_path", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "img_path", ")", "\n", "# Test a single image", "\n", "", "result", "=", "model_inference", "(", "model", ",", "img_path", ")", "\n", "pred_label", "=", "result", "[", "'text'", "]", "\n", "\n", "out_img_name", "=", "'_'", ".", "join", "(", "img_file", ".", "split", "(", "'/'", ")", ")", "\n", "out_file", "=", "osp", ".", "join", "(", "out_vis_dir", ",", "out_img_name", ")", "\n", "kwargs_dict", "=", "{", "\n", "'gt_label'", ":", "gt_label", ",", "\n", "'show'", ":", "args", ".", "show", ",", "\n", "'out_file'", ":", "''", "if", "args", ".", "show", "else", "out_file", "\n", "}", "\n", "model", ".", "show_result", "(", "img_path", ",", "result", ",", "**", "kwargs_dict", ")", "\n", "if", "gt_label", "!=", "''", ":", "\n", "            ", "if", "gt_label", "==", "pred_label", ":", "\n", "                ", "dst_file", "=", "osp", ".", "join", "(", "correct_vis_dir", ",", "out_img_name", ")", "\n", "", "else", ":", "\n", "                ", "dst_file", "=", "osp", ".", "join", "(", "wrong_vis_dir", ",", "out_img_name", ")", "\n", "", "shutil", ".", "copy", "(", "out_file", ",", "dst_file", ")", "\n", "", "img_paths", ".", "append", "(", "img_path", ")", "\n", "gt_labels", ".", "append", "(", "gt_label", ")", "\n", "pred_labels", ".", "append", "(", "pred_label", ")", "\n", "\n", "# Save results", "\n", "", "save_results", "(", "img_paths", ",", "pred_labels", ",", "gt_labels", ",", "args", ".", "out_dir", ")", "\n", "\n", "if", "num_gt_label", "==", "len", "(", "pred_labels", ")", ":", "\n", "# eval", "\n", "        ", "eval_results", "=", "eval_ocr_metric", "(", "pred_labels", ",", "gt_labels", ")", "\n", "logger", ".", "info", "(", "'\\n'", "+", "'-'", "*", "100", ")", "\n", "info", "=", "(", "'eval on testset with img_root_path '", "\n", "f'{args.img_root_path} and img_list {args.img_list}\\n'", ")", "\n", "logger", ".", "info", "(", "info", ")", "\n", "logger", ".", "info", "(", "eval_results", ")", "\n", "\n", "", "print", "(", "f'\\nInference done, and results saved in {args.out_dir}\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.kie_test_imgs.save_results": [[20, 50], ["os.join", "mmcv.dump", "mmcv.list_from_file", "os.basename", "line.strip().split", "idx_to_cls.get", "[].cpu().item", "zip", "pred.argmax().cpu().item", "pred.argmax().cpu().item", "line.strip", "int", "[].cpu", "pred.argmax().cpu", "pred.argmax().cpu", "pred.argmax", "pred.argmax", "pred.max"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["def", "save_results", "(", "model", ",", "img_meta", ",", "gt_bboxes", ",", "result", ",", "out_dir", ")", ":", "\n", "    ", "assert", "'filename'", "in", "img_meta", ",", "(", "'Please add \"filename\" '", "\n", "'to \"meta_keys\" in config.'", ")", "\n", "assert", "'ori_texts'", "in", "img_meta", ",", "(", "'Please add \"ori_texts\" '", "\n", "'to \"meta_keys\" in config.'", ")", "\n", "\n", "out_json_file", "=", "osp", ".", "join", "(", "out_dir", ",", "\n", "osp", ".", "basename", "(", "img_meta", "[", "'filename'", "]", ")", "+", "'.json'", ")", "\n", "\n", "idx_to_cls", "=", "{", "}", "\n", "if", "model", ".", "module", ".", "class_list", "is", "not", "None", ":", "\n", "        ", "for", "line", "in", "mmcv", ".", "list_from_file", "(", "model", ".", "module", ".", "class_list", ")", ":", "\n", "            ", "class_idx", ",", "class_label", "=", "line", ".", "strip", "(", ")", ".", "split", "(", ")", "\n", "idx_to_cls", "[", "int", "(", "class_idx", ")", "]", "=", "class_label", "\n", "\n", "", "", "json_result", "=", "[", "{", "\n", "'text'", ":", "\n", "text", ",", "\n", "'box'", ":", "\n", "box", ",", "\n", "'pred'", ":", "\n", "idx_to_cls", ".", "get", "(", "\n", "pred", ".", "argmax", "(", "-", "1", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ",", "\n", "pred", ".", "argmax", "(", "-", "1", ")", ".", "cpu", "(", ")", ".", "item", "(", ")", ")", ",", "\n", "'conf'", ":", "\n", "pred", ".", "max", "(", "-", "1", ")", "[", "0", "]", ".", "cpu", "(", ")", ".", "item", "(", ")", "\n", "}", "for", "text", ",", "box", ",", "pred", "in", "zip", "(", "img_meta", "[", "'ori_texts'", "]", ",", "gt_bboxes", ",", "\n", "result", "[", "'nodes'", "]", ")", "]", "\n", "\n", "mmcv", ".", "dump", "(", "json_result", ",", "out_json_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.kie_test_imgs.test": [[52, 99], ["model.eval", "mmcv.ProgressBar", "enumerate", "len", "len", "range", "torch.no_grad", "model", "enumerate", "mmcv.ProgressBar.update", "numpy.prod", "mmcv.image.tensor2imgs", "len", "len", "[].numpy().tolist", "zip", "model.module.show_result", "mmcv.imread", "os.join", "kie_test_imgs.save_results", "[].numpy", "os.basename"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.save_results"], ["", "def", "test", "(", "model", ",", "data_loader", ",", "show", "=", "False", ",", "out_dir", "=", "None", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "batch_size", "=", "len", "(", "result", ")", "\n", "if", "show", "or", "out_dir", ":", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", ".", "data", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "if", "np", ".", "prod", "(", "img_tensor", ".", "shape", ")", "==", "0", ":", "\n", "                ", "imgs", "=", "[", "mmcv", ".", "imread", "(", "m", "[", "'filename'", "]", ")", "for", "m", "in", "img_metas", "]", "\n", "", "else", ":", "\n", "                ", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "**", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", ")", "\n", "", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "gt_bboxes", "=", "[", "data", "[", "'gt_bboxes'", "]", ".", "data", "[", "0", "]", "[", "0", "]", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "]", "\n", "\n", "for", "i", ",", "(", "img", ",", "img_meta", ")", "in", "enumerate", "(", "zip", "(", "imgs", ",", "img_metas", ")", ")", ":", "\n", "                ", "if", "'img_shape'", "in", "img_meta", ":", "\n", "                    ", "h", ",", "w", ",", "_", "=", "img_meta", "[", "'img_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "", "else", ":", "\n", "                    ", "img_show", "=", "img", "\n", "\n", "", "if", "out_dir", ":", "\n", "                    ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "\n", "osp", ".", "basename", "(", "img_meta", "[", "'filename'", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "out_file", "=", "None", "\n", "\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ")", "\n", "\n", "if", "out_dir", ":", "\n", "                    ", "save_results", "(", "model", ",", "img_meta", ",", "gt_bboxes", "[", "i", "]", ",", "result", "[", "i", "]", ",", "\n", "out_dir", ")", "\n", "\n", "", "", "", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.kie_test_imgs.parse_args": [[101, 120], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'MMOCR visualize for kie model.'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'Test config file path.'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "help", "=", "'Checkpoint file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--show'", ",", "action", "=", "'store_true'", ",", "help", "=", "'Show results.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "help", "=", "'Directory where the output images and results will be saved.'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "\n", "help", "=", "'Use int or int list for gpu. Default is cpu'", ",", "\n", "default", "=", "None", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "if", "'LOCAL_RANK'", "not", "in", "os", ".", "environ", ":", "\n", "        ", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "args", ".", "local_rank", ")", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.kie_test_imgs.main": [[122, 158], ["kie_test_imgs.parse_args", "mmcv.Config.fromfile", "Config.fromfile.get", "Config.fromfile.get", "mmocr.datasets.build_dataset", "mmocr.datasets.build_dataloader", "mmocr.models.build_detector", "mmcv.runner.load_checkpoint", "mmcv.parallel.MMDataParallel", "kie_test_imgs.test", "ast.literal_eval", "import_modules_from_strings", "Config.fromfile.get"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.kie_test_imgs.test"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "assert", "args", ".", "show", "or", "args", ".", "out_dir", ",", "(", "'Please specify at least one '", "\n", "'operation (show the results / save )'", "\n", "'the results with the argument '", "\n", "'\"--show\" or \"--out-dir\".'", ")", "\n", "device", "=", "args", ".", "device", "\n", "if", "device", "is", "not", "None", ":", "\n", "        ", "device", "=", "ast", ".", "literal_eval", "(", "f'[{device}]'", ")", "\n", "", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "# import modules from string list.", "\n", "if", "cfg", ".", "get", "(", "'custom_imports'", ",", "None", ")", ":", "\n", "        ", "from", "mmcv", ".", "utils", "import", "import_modules_from_strings", "\n", "import_modules_from_strings", "(", "**", "cfg", "[", "'custom_imports'", "]", ")", "\n", "# set cudnn_benchmark", "\n", "", "if", "cfg", ".", "get", "(", "'cudnn_benchmark'", ",", "False", ")", ":", "\n", "        ", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "\n", "", "distributed", "=", "False", "\n", "\n", "# build the dataloader", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "test", ")", "\n", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "samples_per_gpu", "=", "1", ",", "\n", "workers_per_gpu", "=", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "dist", "=", "distributed", ",", "\n", "shuffle", "=", "False", ")", "\n", "\n", "# build the model and load checkpoint", "\n", "cfg", ".", "model", ".", "train_cfg", "=", "None", "\n", "model", "=", "build_detector", "(", "cfg", ".", "model", ",", "test_cfg", "=", "cfg", ".", "get", "(", "'test_cfg'", ")", ")", "\n", "load_checkpoint", "(", "model", ",", "args", ".", "checkpoint", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "device", ")", "\n", "test", "(", "model", ",", "data_loader", ",", "args", ".", "show", ",", "args", ".", "out_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.benchmark_processing.main": [[27, 57], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "mmcv.Config.fromfile", "mmocr.datasets.build_dataset", "mmdet.datasets.build_dataloader", "mmcv.ProgressBar", "enumerate", "range", "len", "mmcv.ProgressBar.start", "len", "mmcv.ProgressBar.update"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Benchmark data loading'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'Train config file path.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "train", ")", "\n", "\n", "# prepare data loaders", "\n", "if", "'imgs_per_gpu'", "in", "cfg", ".", "data", ":", "\n", "        ", "cfg", ".", "data", ".", "samples_per_gpu", "=", "cfg", ".", "data", ".", "imgs_per_gpu", "\n", "\n", "", "data_loader", "=", "build_dataloader", "(", "\n", "dataset", ",", "\n", "cfg", ".", "data", ".", "samples_per_gpu", ",", "\n", "cfg", ".", "data", ".", "workers_per_gpu", ",", "\n", "1", ",", "\n", "dist", "=", "False", ",", "\n", "seed", "=", "None", ")", "\n", "\n", "# Start progress bar after first 5 batches", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "\n", "len", "(", "dataset", ")", "-", "5", "*", "cfg", ".", "data", ".", "samples_per_gpu", ",", "start", "=", "False", ")", "\n", "for", "i", ",", "data", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "        ", "if", "i", "==", "5", ":", "\n", "            ", "prog_bar", ".", "start", "(", ")", "\n", "", "for", "_", "in", "range", "(", "len", "(", "data", "[", "'img'", "]", ")", ")", ":", "\n", "            ", "if", "i", "<", "5", ":", "\n", "                ", "continue", "\n", "", "prog_bar", ".", "update", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.cal_train_time": [[13, 34], ["enumerate", "print", "log_dict.keys", "numpy.array", "np.array.mean", "all_times.mean.argmax", "all_times.mean.argmin", "all_times.mean.std", "print", "print", "print", "print", "print", "np.array.append", "np.array.append", "numpy.mean"], "function", ["None"], ["def", "cal_train_time", "(", "log_dicts", ",", "args", ")", ":", "\n", "    ", "for", "i", ",", "log_dict", "in", "enumerate", "(", "log_dicts", ")", ":", "\n", "        ", "print", "(", "f'{\"-\" * 5}Analyze train time of {args.json_logs[i]}{\"-\" * 5}'", ")", "\n", "all_times", "=", "[", "]", "\n", "for", "epoch", "in", "log_dict", ".", "keys", "(", ")", ":", "\n", "            ", "if", "args", ".", "include_outliers", ":", "\n", "                ", "all_times", ".", "append", "(", "log_dict", "[", "epoch", "]", "[", "'time'", "]", ")", "\n", "", "else", ":", "\n", "                ", "all_times", ".", "append", "(", "log_dict", "[", "epoch", "]", "[", "'time'", "]", "[", "1", ":", "]", ")", "\n", "", "", "all_times", "=", "np", ".", "array", "(", "all_times", ")", "\n", "epoch_ave_time", "=", "all_times", ".", "mean", "(", "-", "1", ")", "\n", "slowest_epoch", "=", "epoch_ave_time", ".", "argmax", "(", ")", "\n", "fastest_epoch", "=", "epoch_ave_time", ".", "argmin", "(", ")", "\n", "std_over_epoch", "=", "epoch_ave_time", ".", "std", "(", ")", "\n", "print", "(", "f'slowest epoch {slowest_epoch + 1}, '", "\n", "f'average time is {epoch_ave_time[slowest_epoch]:.4f}'", ")", "\n", "print", "(", "f'fastest epoch {fastest_epoch + 1}, '", "\n", "f'average time is {epoch_ave_time[fastest_epoch]:.4f}'", ")", "\n", "print", "(", "f'time std over epochs is {std_over_epoch:.4f}'", ")", "\n", "print", "(", "f'average iter time: {np.mean(all_times):.4f} s/iter'", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.plot_curve": [[36, 101], ["seaborn.set_style", "len", "enumerate", "matplotlib.switch_backend", "len", "list", "enumerate", "matplotlib.show", "print", "matplotlib.savefig", "matplotlib.cla", "len", "len", "log_dict.keys", "print", "any", "matplotlib.grid", "matplotlib.legend", "matplotlib.title", "legend.append", "matplotlib.xlabel", "matplotlib.plot", "numpy.concatenate", "numpy.concatenate", "matplotlib.xlabel", "matplotlib.plot", "np.concatenate.append", "np.concatenate.append", "np.concatenate.append", "numpy.array", "numpy.array", "len"], "function", ["None"], ["", "", "def", "plot_curve", "(", "log_dicts", ",", "args", ")", ":", "\n", "    ", "if", "args", ".", "backend", "is", "not", "None", ":", "\n", "        ", "plt", ".", "switch_backend", "(", "args", ".", "backend", ")", "\n", "", "sns", ".", "set_style", "(", "args", ".", "style", ")", "\n", "# if legend is None, use {filename}_{key} as legend", "\n", "legend", "=", "args", ".", "legend", "\n", "if", "legend", "is", "None", ":", "\n", "        ", "legend", "=", "[", "]", "\n", "for", "json_log", "in", "args", ".", "json_logs", ":", "\n", "            ", "for", "metric", "in", "args", ".", "keys", ":", "\n", "                ", "legend", ".", "append", "(", "f'{json_log}_{metric}'", ")", "\n", "", "", "", "assert", "len", "(", "legend", ")", "==", "(", "len", "(", "args", ".", "json_logs", ")", "*", "len", "(", "args", ".", "keys", ")", ")", "\n", "metrics", "=", "args", ".", "keys", "\n", "\n", "num_metrics", "=", "len", "(", "metrics", ")", "\n", "for", "i", ",", "log_dict", "in", "enumerate", "(", "log_dicts", ")", ":", "\n", "        ", "epochs", "=", "list", "(", "log_dict", ".", "keys", "(", ")", ")", "\n", "for", "j", ",", "metric", "in", "enumerate", "(", "metrics", ")", ":", "\n", "            ", "print", "(", "f'Plot curve of {args.json_logs[i]}, metric is {metric}'", ")", "\n", "\n", "epoch_based_metrics", "=", "[", "\n", "'hmean'", ",", "'word_acc'", ",", "'word_acc_ignore_case'", ",", "\n", "'word_acc_ignore_case_symbol'", ",", "'char_recall'", ",", "'char_precision'", ",", "\n", "'1-N.E.D'", ",", "'macro_f1'", "\n", "]", "\n", "if", "any", "(", "metric", "in", "m", "for", "m", "in", "epoch_based_metrics", ")", ":", "\n", "# determine whether it is a epoch-plotted metric", "\n", "# e.g. hmean-iou:hmean, 0_word_acc", "\n", "                ", "xs", "=", "[", "]", "\n", "ys", "=", "[", "]", "\n", "for", "epoch", "in", "epochs", ":", "\n", "                    ", "ys", "+=", "log_dict", "[", "epoch", "]", "[", "metric", "]", "\n", "if", "'val'", "in", "log_dict", "[", "epoch", "]", "[", "'mode'", "]", ":", "\n", "                        ", "xs", ".", "append", "(", "epoch", ")", "\n", "", "", "plt", ".", "xlabel", "(", "'epoch'", ")", "\n", "plt", ".", "plot", "(", "xs", ",", "ys", ",", "label", "=", "legend", "[", "i", "*", "num_metrics", "+", "j", "]", ",", "marker", "=", "'o'", ")", "\n", "", "else", ":", "\n", "                ", "xs", "=", "[", "]", "\n", "ys", "=", "[", "]", "\n", "if", "log_dict", "[", "epochs", "[", "0", "]", "]", "[", "'mode'", "]", "[", "-", "1", "]", "==", "'val'", ":", "\n", "                    ", "num_iters_per_epoch", "=", "log_dict", "[", "epochs", "[", "0", "]", "]", "[", "'iter'", "]", "[", "-", "2", "]", "\n", "", "else", ":", "\n", "                    ", "num_iters_per_epoch", "=", "log_dict", "[", "epochs", "[", "0", "]", "]", "[", "'iter'", "]", "[", "-", "1", "]", "\n", "", "for", "epoch", "in", "epochs", ":", "\n", "                    ", "iters", "=", "log_dict", "[", "epoch", "]", "[", "'iter'", "]", "\n", "if", "log_dict", "[", "epoch", "]", "[", "'mode'", "]", "[", "-", "1", "]", "==", "'val'", ":", "\n", "                        ", "iters", "=", "iters", "[", ":", "-", "1", "]", "\n", "", "xs", ".", "append", "(", "\n", "np", ".", "array", "(", "iters", ")", "+", "(", "epoch", "-", "1", ")", "*", "num_iters_per_epoch", ")", "\n", "ys", ".", "append", "(", "np", ".", "array", "(", "log_dict", "[", "epoch", "]", "[", "metric", "]", "[", ":", "len", "(", "iters", ")", "]", ")", ")", "\n", "", "xs", "=", "np", ".", "concatenate", "(", "xs", ")", "\n", "ys", "=", "np", ".", "concatenate", "(", "ys", ")", "\n", "plt", ".", "xlabel", "(", "'iter'", ")", "\n", "plt", ".", "plot", "(", "\n", "xs", ",", "ys", ",", "label", "=", "legend", "[", "i", "*", "num_metrics", "+", "j", "]", ",", "linewidth", "=", "0.5", ")", "\n", "", "plt", ".", "grid", "(", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "", "if", "args", ".", "title", "is", "not", "None", ":", "\n", "            ", "plt", ".", "title", "(", "args", ".", "title", ")", "\n", "", "", "if", "args", ".", "out", "is", "None", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "f'Save curve to: {args.out}'", ")", "\n", "plt", ".", "savefig", "(", "args", ".", "out", ")", "\n", "plt", ".", "cla", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.add_plot_parser": [[103, 129], ["subparsers.add_parser", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument"], "function", ["None"], ["", "", "def", "add_plot_parser", "(", "subparsers", ")", ":", "\n", "    ", "parser_plt", "=", "subparsers", ".", "add_parser", "(", "\n", "'plot_curve'", ",", "help", "=", "'Parser for plotting curves'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'json_logs'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Path of train log in json format'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--keys'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "[", "'loss'", "]", ",", "\n", "help", "=", "'The metric that you want to plot'", ")", "\n", "parser_plt", ".", "add_argument", "(", "'--title'", ",", "type", "=", "str", ",", "help", "=", "'Title of figure'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--legend'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "default", "=", "None", ",", "\n", "help", "=", "'Legend of each plot'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--backend'", ",", "type", "=", "str", ",", "default", "=", "None", ",", "help", "=", "'Backend of plt'", ")", "\n", "parser_plt", ".", "add_argument", "(", "\n", "'--style'", ",", "type", "=", "str", ",", "default", "=", "'dark'", ",", "help", "=", "'Style of plt'", ")", "\n", "parser_plt", ".", "add_argument", "(", "'--out'", ",", "type", "=", "str", ",", "default", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.add_time_parser": [[131, 144], ["subparsers.add_parser", "subparsers.add_parser.add_argument", "subparsers.add_parser.add_argument"], "function", ["None"], ["", "def", "add_time_parser", "(", "subparsers", ")", ":", "\n", "    ", "parser_time", "=", "subparsers", ".", "add_parser", "(", "\n", "'cal_train_time'", ",", "\n", "help", "=", "'Parser for computing the average time per training iteration'", ")", "\n", "parser_time", ".", "add_argument", "(", "\n", "'json_logs'", ",", "\n", "type", "=", "str", ",", "\n", "nargs", "=", "'+'", ",", "\n", "help", "=", "'Path of train log in json format'", ")", "\n", "parser_time", ".", "add_argument", "(", "\n", "'--include-outliers'", ",", "\n", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Include the first value of every epoch when computing '", "\n", "'the average time'", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.parse_args": [[147, 155], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_subparsers", "analyze_logs.add_plot_parser", "analyze_logs.add_time_parser", "argparse.ArgumentParser.parse_args"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.add_plot_parser", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.add_time_parser", "home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Analyze Json Log'", ")", "\n", "# currently only support plot curve and calculate average train time", "\n", "subparsers", "=", "parser", ".", "add_subparsers", "(", "dest", "=", "'task'", ",", "help", "=", "'task parser'", ")", "\n", "add_plot_parser", "(", "subparsers", ")", "\n", "add_time_parser", "(", "subparsers", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.load_json_logs": [[157, 175], ["zip", "dict", "open", "json.loads", "json.loads.pop", "json.loads.items", "line.strip", "collections.defaultdict", "[].append"], "function", ["None"], ["", "def", "load_json_logs", "(", "json_logs", ")", ":", "\n", "# load and convert json_logs to log_dict, key is epoch, value is a sub dict", "\n", "# keys of sub dict is different metrics, e.g. memory, loss", "\n", "# value of sub dict is a list of corresponding values of all iterations", "\n", "    ", "log_dicts", "=", "[", "dict", "(", ")", "for", "_", "in", "json_logs", "]", "\n", "for", "json_log", ",", "log_dict", "in", "zip", "(", "json_logs", ",", "log_dicts", ")", ":", "\n", "        ", "with", "open", "(", "json_log", ",", "'r'", ")", "as", "log_file", ":", "\n", "            ", "for", "line", "in", "log_file", ":", "\n", "                ", "log", "=", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "\n", "# skip lines without `epoch` field", "\n", "if", "'epoch'", "not", "in", "log", ":", "\n", "                    ", "continue", "\n", "", "epoch", "=", "log", ".", "pop", "(", "'epoch'", ")", "\n", "if", "epoch", "not", "in", "log_dict", ":", "\n", "                    ", "log_dict", "[", "epoch", "]", "=", "defaultdict", "(", "list", ")", "\n", "", "for", "k", ",", "v", "in", "log", ".", "items", "(", ")", ":", "\n", "                    ", "log_dict", "[", "epoch", "]", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "", "", "", "", "return", "log_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.main": [[177, 187], ["analyze_logs.parse_args", "analyze_logs.load_json_logs", "json_log.endswith", "eval"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.analyze_logs.load_json_logs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "json_logs", "=", "args", ".", "json_logs", "\n", "for", "json_log", "in", "json_logs", ":", "\n", "        ", "assert", "json_log", ".", "endswith", "(", "'.json'", ")", "\n", "\n", "", "log_dicts", "=", "load_json_logs", "(", "json_logs", ")", "\n", "\n", "eval", "(", "args", ".", "task", ")", "(", "log_dicts", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.train.parse_args": [[25, 101], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_mutually_exclusive_group", "parser.add_mutually_exclusive_group.add_argument", "parser.add_mutually_exclusive_group.add_argument", "parser.add_mutually_exclusive_group.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str", "ValueError", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["validate", "=", "False", ",", "\n", "timestamp", "=", "None", ",", "\n", "meta", "=", "None", ")", ":", "\n", "    ", "logger", "=", "get_root_logger", "(", "cfg", ".", "log_level", ")", "\n", "\n", "# prepare data loaders", "\n", "dataset", "=", "dataset", "if", "isinstance", "(", "dataset", ",", "(", "list", ",", "tuple", ")", ")", "else", "[", "dataset", "]", "\n", "# step 1: give default values and override (if exist) from cfg.data", "\n", "default_loader_cfg", "=", "{", "\n", "**", "dict", "(", "\n", "num_gpus", "=", "len", "(", "cfg", ".", "gpu_ids", ")", ",", "\n", "dist", "=", "distributed", ",", "\n", "seed", "=", "cfg", ".", "get", "(", "'seed'", ")", ",", "\n", "drop_last", "=", "False", ",", "\n", "persistent_workers", "=", "False", ")", ",", "\n", "**", "(", "{", "}", "if", "torch", ".", "__version__", "!=", "'parrots'", "else", "dict", "(", "\n", "prefetch_num", "=", "2", ",", "\n", "pin_memory", "=", "False", ",", "\n", ")", ")", ",", "\n", "}", "\n", "# update overall dataloader(for train, val and test) setting", "\n", "default_loader_cfg", ".", "update", "(", "{", "\n", "k", ":", "v", "\n", "for", "k", ",", "v", "in", "cfg", ".", "data", ".", "items", "(", ")", "if", "k", "not", "in", "[", "\n", "'train'", ",", "'val'", ",", "'test'", ",", "'train_dataloader'", ",", "'val_dataloader'", ",", "\n", "'test_dataloader'", "\n", "]", "\n", "}", ")", "\n", "\n", "# step 2: cfg.data.train_dataloader has highest priority", "\n", "train_loader_cfg", "=", "dict", "(", "default_loader_cfg", ",", "\n", "**", "cfg", ".", "data", ".", "get", "(", "'train_dataloader'", ",", "{", "}", ")", ")", "\n", "\n", "data_loaders", "=", "[", "build_dataloader", "(", "ds", ",", "**", "train_loader_cfg", ")", "for", "ds", "in", "dataset", "]", "\n", "\n", "# put model on gpus", "\n", "if", "distributed", ":", "\n", "        ", "find_unused_parameters", "=", "cfg", ".", "get", "(", "'find_unused_parameters'", ",", "False", ")", "\n", "# Sets the `find_unused_parameters` parameter in", "\n", "# torch.nn.parallel.DistributedDataParallel", "\n", "model", "=", "MMDistributedDataParallel", "(", "\n", "model", ".", "cuda", "(", ")", ",", "\n", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "\n", "broadcast_buffers", "=", "False", ",", "\n", "find_unused_parameters", "=", "find_unused_parameters", ")", "\n", "", "else", ":", "\n", "        ", "if", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "assert", "digit_version", "(", "mmcv", ".", "__version__", ")", ">=", "digit_version", "(", "'1.4.4'", ")", ",", "'Please use MMCV >= 1.4.4 for CPU training!'", "\n", "", "model", "=", "MMDataParallel", "(", "model", ",", "device_ids", "=", "cfg", ".", "gpu_ids", ")", "\n", "\n", "# build runner", "\n", "", "optimizer", "=", "build_optimizer", "(", "model", ",", "cfg", ".", "optimizer", ")", "\n", "\n", "if", "'runner'", "not", "in", "cfg", ":", "\n", "        ", "cfg", ".", "runner", "=", "{", "\n", "'type'", ":", "'EpochBasedRunner'", ",", "\n", "'max_epochs'", ":", "cfg", ".", "total_epochs", "\n", "}", "\n", "warnings", ".", "warn", "(", "\n", "'config is now expected to have a `runner` section, '", "\n", "'please set `runner` in your config.'", ",", "UserWarning", ")", "\n", "", "else", ":", "\n", "        ", "if", "'total_epochs'", "in", "cfg", ":", "\n", "            ", "assert", "cfg", ".", "total_epochs", "==", "cfg", ".", "runner", ".", "max_epochs", "\n", "\n", "", "", "runner", "=", "build_runner", "(", "\n", "cfg", ".", "runner", ",", "\n", "default_args", "=", "dict", "(", "\n", "model", "=", "model", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "work_dir", "=", "cfg", ".", "work_dir", ",", "\n", "logger", "=", "logger", ",", "\n", "meta", "=", "meta", ")", ")", "\n", "\n", "# an ugly workaround to make .log and .log.json filenames the same", "\n", "runner", ".", "timestamp", "=", "timestamp", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.train.main": [[103, 227], ["train.parse_args", "mmcv.Config.fromfile", "mmocr.utils.setup_multi_processes", "Config.fromfile.get", "mmcv.mkdir_or_exist", "Config.fromfile.dump", "time.strftime", "os.join", "mmocr.utils.get_root_logger", "dict", "mmocr.utils.collect_env", "mmocr.utils.get_root_logger.info", "mmocr.utils.get_root_logger.info", "mmocr.utils.get_root_logger.info", "mmocr.apis.init_random_seed", "mmocr.utils.get_root_logger.info", "mmcv.runner.set_random_seed", "os.basename", "mmocr.models.build_detector", "mmocr.models.build_detector.init_weights", "mmocr.apis.train_detector", "Config.fromfile.merge_from_dict", "range", "warnings.warn", "warnings.warn", "mmcv.runner.init_dist", "mmcv.runner.get_dist_info", "range", "os.abspath", "os.join", "time.localtime", "mmocr.datasets.build_dataset", "len", "copy.deepcopy", "datasets.append", "dict", "Config.fromfile.get", "os.join", "os.basename", "torch.get_rank", "Config.fromfile.get", "Config.fromfile.get", "Config.fromfile.data.train.get", "mmocr.utils.is_2dlist", "mmocr.utils.is_2dlist", "mmocr.datasets.build_dataset", "mmocr.utils.collect_env.items", "os.splitext", "os.basename", "mmcv.utils.get_git_hash"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.collect_env.collect_env", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.train.init_random_seed", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.train.train_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["# fp16 setting", "\n", "fp16_cfg", "=", "cfg", ".", "get", "(", "'fp16'", ",", "None", ")", "\n", "if", "fp16_cfg", "is", "not", "None", ":", "\n", "        ", "optimizer_config", "=", "Fp16OptimizerHook", "(", "\n", "**", "cfg", ".", "optimizer_config", ",", "**", "fp16_cfg", ",", "distributed", "=", "distributed", ")", "\n", "", "elif", "distributed", "and", "'type'", "not", "in", "cfg", ".", "optimizer_config", ":", "\n", "        ", "optimizer_config", "=", "OptimizerHook", "(", "**", "cfg", ".", "optimizer_config", ")", "\n", "", "else", ":", "\n", "        ", "optimizer_config", "=", "cfg", ".", "optimizer_config", "\n", "\n", "# register hooks", "\n", "", "runner", ".", "register_training_hooks", "(", "\n", "cfg", ".", "lr_config", ",", "\n", "optimizer_config", ",", "\n", "cfg", ".", "checkpoint_config", ",", "\n", "cfg", ".", "log_config", ",", "\n", "cfg", ".", "get", "(", "'momentum_config'", ",", "None", ")", ",", "\n", "custom_hooks_config", "=", "cfg", ".", "get", "(", "'custom_hooks'", ",", "None", ")", ")", "\n", "if", "distributed", ":", "\n", "        ", "if", "isinstance", "(", "runner", ",", "EpochBasedRunner", ")", ":", "\n", "            ", "runner", ".", "register_hook", "(", "DistSamplerSeedHook", "(", ")", ")", "\n", "\n", "# register eval hooks", "\n", "", "", "if", "validate", ":", "\n", "        ", "val_samples_per_gpu", "=", "(", "cfg", ".", "data", ".", "get", "(", "'val_dataloader'", ",", "{", "}", ")", ")", ".", "get", "(", "\n", "'samples_per_gpu'", ",", "cfg", ".", "data", ".", "get", "(", "'samples_per_gpu'", ",", "1", ")", ")", "\n", "if", "val_samples_per_gpu", ">", "1", ":", "\n", "# Support batch_size > 1 in test for text recognition", "\n", "# by disable MultiRotateAugOCR since it is useless for most case", "\n", "            ", "cfg", "=", "disable_text_recog_aug_test", "(", "cfg", ")", "\n", "cfg", "=", "replace_image_to_tensor", "(", "cfg", ")", "\n", "\n", "", "val_dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "val", ",", "dict", "(", "test_mode", "=", "True", ")", ")", "\n", "\n", "val_loader_cfg", "=", "{", "\n", "**", "default_loader_cfg", ",", "\n", "**", "dict", "(", "shuffle", "=", "False", ",", "drop_last", "=", "False", ")", ",", "\n", "**", "cfg", ".", "data", ".", "get", "(", "'val_dataloader'", ",", "{", "}", ")", ",", "\n", "**", "dict", "(", "samples_per_gpu", "=", "val_samples_per_gpu", ")", "\n", "}", "\n", "\n", "val_dataloader", "=", "build_dataloader", "(", "val_dataset", ",", "**", "val_loader_cfg", ")", "\n", "\n", "eval_cfg", "=", "cfg", ".", "get", "(", "'evaluation'", ",", "{", "}", ")", "\n", "eval_cfg", "[", "'by_epoch'", "]", "=", "cfg", ".", "runner", "[", "'type'", "]", "!=", "'IterBasedRunner'", "\n", "eval_hook", "=", "DistEvalHook", "if", "distributed", "else", "EvalHook", "\n", "runner", ".", "register_hook", "(", "eval_hook", "(", "val_dataloader", ",", "**", "eval_cfg", ")", ")", "\n", "\n", "", "if", "cfg", ".", "resume_from", ":", "\n", "        ", "runner", ".", "resume", "(", "cfg", ".", "resume_from", ")", "\n", "", "elif", "cfg", ".", "load_from", ":", "\n", "        ", "runner", ".", "load_checkpoint", "(", "cfg", ".", "load_from", ")", "\n", "", "runner", ".", "run", "(", "data_loaders", ",", "cfg", ".", "workflow", ")", "\n", "\n", "\n", "", "def", "init_random_seed", "(", "seed", "=", "None", ",", "device", "=", "'cuda'", ")", ":", "\n", "    ", "\"\"\"Initialize random seed. If the seed is None, it will be replaced by a\n    random number, and then broadcasted to all processes.\n\n    Args:\n        seed (int, Optional): The seed.\n        device (str): The device where the seed will be put on.\n\n    Returns:\n        int: Seed to be used.\n    \"\"\"", "\n", "if", "seed", "is", "not", "None", ":", "\n", "        ", "return", "seed", "\n", "\n", "# Make sure all ranks share the same random seed to prevent", "\n", "# some potential bugs. Please refer to", "\n", "# https://github.com/open-mmlab/mmdetection/issues/6339", "\n", "", "rank", ",", "world_size", "=", "get_dist_info", "(", ")", "\n", "seed", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "if", "world_size", "==", "1", ":", "\n", "        ", "return", "seed", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "random_num", "=", "torch", ".", "tensor", "(", "seed", ",", "dtype", "=", "torch", ".", "int32", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "        ", "random_num", "=", "torch", ".", "tensor", "(", "0", ",", "dtype", "=", "torch", ".", "int32", ",", "device", "=", "device", ")", "\n", "", "dist", ".", "broadcast", "(", "random_num", ",", "src", "=", "0", ")", "\n", "return", "random_num", ".", "item", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.test.parse_args": [[24, 111], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "str", "ValueError", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["\n", "\n", "if", "isinstance", "(", "data", "[", "'img'", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "# for textrecog with batch_size > 1", "\n", "# and not use 'DefaultFormatBundle' in pipeline", "\n", "        ", "img_tensor", "=", "data", "[", "'img'", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "data", "[", "'img'", "]", ",", "list", ")", ":", "\n", "        ", "if", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "# for textrecog with aug_test and batch_size = 1", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "data", "[", "'img'", "]", "[", "0", "]", ",", "DataContainer", ")", ":", "\n", "# for textdet with 'MultiScaleFlipAug'", "\n", "# and 'DefaultFormatBundle' in pipeline", "\n", "            ", "img_tensor", "=", "data", "[", "'img'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "", "img_metas", "=", "data", "[", "'img_metas'", "]", "[", "0", "]", ".", "data", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "data", "[", "'img'", "]", ",", "DataContainer", ")", ":", "\n", "# for textrecog with 'DefaultFormatBundle' in pipeline", "\n", "        ", "img_tensor", "=", "data", "[", "'img'", "]", ".", "data", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "\n", "", "must_keys", "=", "[", "'img_norm_cfg'", ",", "'ori_filename'", ",", "'img_shape'", ",", "'ori_shape'", "]", "\n", "for", "key", "in", "must_keys", ":", "\n", "        ", "if", "key", "not", "in", "img_metas", "[", "0", "]", ":", "\n", "            ", "raise", "KeyError", "(", "\n", "f'Please add {key} to the \"meta_keys\" in the pipeline'", ")", "\n", "\n", "", "", "img_norm_cfg", "=", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", "\n", "if", "max", "(", "img_norm_cfg", "[", "'mean'", "]", ")", "<=", "1", ":", "\n", "        ", "img_norm_cfg", "[", "'mean'", "]", "=", "[", "255", "*", "x", "for", "x", "in", "img_norm_cfg", "[", "'mean'", "]", "]", "\n", "img_norm_cfg", "[", "'std'", "]", "=", "[", "255", "*", "x", "for", "x", "in", "img_norm_cfg", "[", "'std'", "]", "]", "\n", "\n", "", "return", "img_tensor", ",", "img_metas", ",", "img_norm_cfg", "\n", "\n", "\n", "", "def", "single_gpu_test", "(", "model", ",", "\n", "data_loader", ",", "\n", "show", "=", "False", ",", "\n", "out_dir", "=", "None", ",", "\n", "is_kie", "=", "False", ",", "\n", "show_score_thr", "=", "0.3", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "results", "=", "[", "]", "\n", "dataset", "=", "data_loader", ".", "dataset", "\n", "prog_bar", "=", "mmcv", ".", "ProgressBar", "(", "len", "(", "dataset", ")", ")", "\n", "for", "data", "in", "data_loader", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "result", "=", "model", "(", "return_loss", "=", "False", ",", "rescale", "=", "True", ",", "**", "data", ")", "\n", "\n", "", "batch_size", "=", "len", "(", "result", ")", "\n", "if", "show", "or", "out_dir", ":", "\n", "            ", "if", "is_kie", ":", "\n", "                ", "img_tensor", "=", "data", "[", "'img'", "]", ".", "data", "[", "0", "]", "\n", "if", "img_tensor", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "                    ", "raise", "KeyError", "(", "'Visualizing KIE outputs in batches is'", "\n", "'currently not supported.'", ")", "\n", "", "gt_bboxes", "=", "data", "[", "'gt_bboxes'", "]", ".", "data", "[", "0", "]", "\n", "img_metas", "=", "data", "[", "'img_metas'", "]", ".", "data", "[", "0", "]", "\n", "must_keys", "=", "[", "'img_norm_cfg'", ",", "'ori_filename'", ",", "'img_shape'", "]", "\n", "for", "key", "in", "must_keys", ":", "\n", "                    ", "if", "key", "not", "in", "img_metas", "[", "0", "]", ":", "\n", "                        ", "raise", "KeyError", "(", "\n", "f'Please add {key} to the \"meta_keys\" in config.'", ")", "\n", "# for no visual model", "\n", "", "", "if", "np", ".", "prod", "(", "img_tensor", ".", "shape", ")", "==", "0", ":", "\n", "                    ", "imgs", "=", "[", "]", "\n", "for", "img_meta", "in", "img_metas", ":", "\n", "                        ", "try", ":", "\n", "                            ", "img", "=", "mmcv", ".", "imread", "(", "img_meta", "[", "'filename'", "]", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                            ", "print", "(", "f'Load image with error: {e}, '", "\n", "'use empty image instead.'", ")", "\n", "img", "=", "np", ".", "ones", "(", "\n", "img_meta", "[", "'img_shape'", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "", "imgs", ".", "append", "(", "img", ")", "\n", "", "", "else", ":", "\n", "                    ", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "\n", "**", "img_metas", "[", "0", "]", "[", "'img_norm_cfg'", "]", ")", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "                    ", "h", ",", "w", ",", "_", "=", "img_metas", "[", "i", "]", "[", "'img_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "h", ",", ":", "w", ",", ":", "]", "\n", "if", "out_dir", ":", "\n", "                        ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "\n", "img_metas", "[", "i", "]", "[", "'ori_filename'", "]", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.test.main": [[113, 232], ["test.parse_args", "mmcv.Config.fromfile", "mmocr.utils.setup_multi_processes", "mmocr.apis.utils.replace_image_to_tensor.get", "mmocr.apis.utils.replace_image_to_tensor.model.get", "mmocr.apis.utils.replace_image_to_tensor.model.get", "mmocr.apis.utils.replace_image_to_tensor.data.get().get", "mmocr.datasets.build_dataset", "default_loader_cfg.update", "mmocr.datasets.build_dataloader", "mmocr.models.build_detector", "mmocr.utils.revert_sync_batchnorm", "mmocr.apis.utils.replace_image_to_tensor.get", "mmcv.runner.load_checkpoint", "mmcv.runner.get_dist_info", "ValueError", "ValueError", "mmocr.apis.utils.replace_image_to_tensor.merge_from_dict", "isinstance", "mmocr.apis.utils.replace_image_to_tensor.data.get", "mmocr.apis.utils.disable_text_recog_aug_test", "mmocr.apis.utils.replace_image_to_tensor", "mmcv.runner.init_dist", "dict", "dict", "dict", "mmocr.apis.utils.replace_image_to_tensor.data.get", "dict", "mmcv.runner.wrap_fp16_model", "mmcv.cnn.fuse_conv_bn", "mmcv.parallel.MMDataParallel", "mmocr.apis.test.single_gpu_test", "mmcv.parallel.MMDistributedDataParallel", "mmdet.apis.multi_gpu_test", "parse_args.out.endswith", "mmocr.apis.utils.replace_image_to_tensor.model.neck.get", "mmocr.apis.utils.replace_image_to_tensor.data.get", "dict", "mmocr.apis.utils.replace_image_to_tensor.get", "mmcv.parallel.MMDistributedDataParallel.cuda", "print", "mmcv.dump", "mmocr.datasets.build_dataset.format_results", "mmocr.apis.utils.replace_image_to_tensor.get().copy", "cfg.get().copy.update", "print", "neck_cfg.get", "mmocr.apis.utils.replace_image_to_tensor.model.neck.rfp_backbone.get", "mmocr.apis.utils.replace_image_to_tensor.get", "mmocr.apis.utils.replace_image_to_tensor.data.items", "cfg.get().copy.pop", "dict", "mmocr.datasets.build_dataset.evaluate", "neck_cfg.rfp_backbone.get", "torch.cuda.current_device", "mmocr.apis.utils.replace_image_to_tensor.get"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.replace_image_to_tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.format_results", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", "[", "i", "]", ",", "\n", "gt_bboxes", "[", "i", "]", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ")", "\n", "", "", "else", ":", "\n", "                ", "img_tensor", ",", "img_metas", ",", "img_norm_cfg", "=", "retrieve_img_tensor_and_meta", "(", "data", ")", "\n", "\n", "if", "img_tensor", ".", "size", "(", "1", ")", "==", "1", ":", "\n", "                    ", "imgs", "=", "tensor2grayimgs", "(", "img_tensor", ",", "**", "img_norm_cfg", ")", "\n", "", "else", ":", "\n", "                    ", "imgs", "=", "tensor2imgs", "(", "img_tensor", ",", "**", "img_norm_cfg", ")", "\n", "", "assert", "len", "(", "imgs", ")", "==", "len", "(", "img_metas", ")", "\n", "\n", "for", "j", ",", "(", "img", ",", "img_meta", ")", "in", "enumerate", "(", "zip", "(", "imgs", ",", "img_metas", ")", ")", ":", "\n", "                    ", "img_shape", ",", "ori_shape", "=", "img_meta", "[", "'img_shape'", "]", ",", "img_meta", "[", "\n", "'ori_shape'", "]", "\n", "img_show", "=", "img", "[", ":", "img_shape", "[", "0", "]", ",", ":", "img_shape", "[", "1", "]", "]", "\n", "img_show", "=", "mmcv", ".", "imresize", "(", "img_show", ",", "\n", "(", "ori_shape", "[", "1", "]", ",", "ori_shape", "[", "0", "]", ")", ")", "\n", "\n", "if", "out_dir", ":", "\n", "                        ", "out_file", "=", "osp", ".", "join", "(", "out_dir", ",", "img_meta", "[", "'ori_filename'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "out_file", "=", "None", "\n", "\n", "", "model", ".", "module", ".", "show_result", "(", "\n", "img_show", ",", "\n", "result", "[", "j", "]", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ",", "\n", "score_thr", "=", "show_score_thr", ")", "\n", "\n", "# encode mask results", "\n", "", "", "", "if", "isinstance", "(", "result", "[", "0", "]", ",", "tuple", ")", ":", "\n", "            ", "result", "=", "[", "(", "bbox_results", ",", "encode_mask_results", "(", "mask_results", ")", ")", "\n", "for", "bbox_results", ",", "mask_results", "in", "result", "]", "\n", "", "results", ".", "extend", "(", "result", ")", "\n", "\n", "for", "_", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "prog_bar", ".", "update", "(", ")", "\n", "", "", "return", "results", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.gen_target_path": [[14, 29], ["isinstance", "isinstance", "isinstance", "os.join", "os.split", "os.splitext"], "function", ["None"], ["def", "gen_target_path", "(", "target_root_path", ",", "src_name", ",", "suffix", ")", ":", "\n", "    ", "\"\"\"Gen target file path.\n\n    Args:\n        target_root_path (str): The target root path.\n        src_name (str): The source file name.\n        suffix (str): The suffix of target file.\n    \"\"\"", "\n", "assert", "isinstance", "(", "target_root_path", ",", "str", ")", "\n", "assert", "isinstance", "(", "src_name", ",", "str", ")", "\n", "assert", "isinstance", "(", "suffix", ",", "str", ")", "\n", "\n", "file_name", "=", "osp", ".", "split", "(", "src_name", ")", "[", "-", "1", "]", "\n", "name", "=", "osp", ".", "splitext", "(", "file_name", ")", "[", "0", "]", "\n", "return", "osp", ".", "join", "(", "target_root_path", ",", "name", "+", "suffix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.save_results": [[31, 52], ["det_test_imgs.gen_target_path", "mmocr.utils.list_to_file", "str", "round"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.gen_target_path", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "save_results", "(", "result", ",", "out_dir", ",", "img_name", ",", "score_thr", "=", "0.3", ")", ":", "\n", "    ", "\"\"\"Save result of detected bounding boxes (quadrangle or polygon) to txt\n    file.\n\n    Args:\n        result (dict): Text Detection result for one image.\n        img_name (str): Image file name.\n        out_dir (str): Dir of txt files to save detected results.\n        score_thr (float, optional): Score threshold to filter bboxes.\n    \"\"\"", "\n", "assert", "'boundary_result'", "in", "result", "\n", "assert", "score_thr", ">", "0", "and", "score_thr", "<", "1", "\n", "\n", "txt_file", "=", "gen_target_path", "(", "out_dir", ",", "img_name", ",", "'.txt'", ")", "\n", "valid_boundary_res", "=", "[", "\n", "res", "for", "res", "in", "result", "[", "'boundary_result'", "]", "if", "res", "[", "-", "1", "]", ">", "score_thr", "\n", "]", "\n", "lines", "=", "[", "\n", "','", ".", "join", "(", "[", "str", "(", "round", "(", "x", ")", ")", "for", "x", "in", "row", "]", ")", "for", "row", "in", "valid_boundary_res", "\n", "]", "\n", "list_to_file", "(", "txt_file", ",", "lines", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.main": [[54, 108], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "mmocr.apis.init_detector", "hasattr", "os.join", "mmcv.mkdir_or_exist", "os.join", "mmcv.mkdir_or_exist", "mmocr.utils.list_from_file", "mmcv.utils.ProgressBar", "print", "mmcv.utils.ProgressBar.update", "os.join", "mmocr.apis.model_inference", "os.basename", "det_test_imgs.save_results", "os.join", "mmocr.apis.init_detector.show_result", "len", "line.strip", "os.exists", "FileNotFoundError"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.tools.det_test_imgs.save_results", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'img_root'", ",", "type", "=", "str", ",", "help", "=", "'Image root path'", ")", "\n", "parser", ".", "add_argument", "(", "'img_list'", ",", "type", "=", "str", ",", "help", "=", "'Image path list file'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "type", "=", "str", ",", "help", "=", "'Config file'", ")", "\n", "parser", ".", "add_argument", "(", "'checkpoint'", ",", "type", "=", "str", ",", "help", "=", "'Checkpoint file'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--score-thr'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "'Bbox score threshold'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--out-dir'", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "'./results'", ",", "\n", "help", "=", "'Dir to save '", "\n", "'visualize images '", "\n", "'and bbox'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--device'", ",", "default", "=", "'cuda:0'", ",", "help", "=", "'Device used for inference.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "assert", "0", "<", "args", ".", "score_thr", "<", "1", "\n", "\n", "# build the model from a config file and a checkpoint file", "\n", "model", "=", "init_detector", "(", "args", ".", "config", ",", "args", ".", "checkpoint", ",", "device", "=", "args", ".", "device", ")", "\n", "if", "hasattr", "(", "model", ",", "'module'", ")", ":", "\n", "        ", "model", "=", "model", ".", "module", "\n", "\n", "# Start Inference", "\n", "", "out_vis_dir", "=", "osp", ".", "join", "(", "args", ".", "out_dir", ",", "'out_vis_dir'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_vis_dir", ")", "\n", "out_txt_dir", "=", "osp", ".", "join", "(", "args", ".", "out_dir", ",", "'out_txt_dir'", ")", "\n", "mmcv", ".", "mkdir_or_exist", "(", "out_txt_dir", ")", "\n", "\n", "lines", "=", "list_from_file", "(", "args", ".", "img_list", ")", "\n", "progressbar", "=", "ProgressBar", "(", "task_num", "=", "len", "(", "lines", ")", ")", "\n", "for", "line", "in", "lines", ":", "\n", "        ", "progressbar", ".", "update", "(", ")", "\n", "img_path", "=", "osp", ".", "join", "(", "args", ".", "img_root", ",", "line", ".", "strip", "(", ")", ")", "\n", "if", "not", "osp", ".", "exists", "(", "img_path", ")", ":", "\n", "            ", "raise", "FileNotFoundError", "(", "img_path", ")", "\n", "# Test a single image", "\n", "", "result", "=", "model_inference", "(", "model", ",", "img_path", ")", "\n", "img_name", "=", "osp", ".", "basename", "(", "img_path", ")", "\n", "# save result", "\n", "save_results", "(", "result", ",", "out_txt_dir", ",", "img_name", ",", "score_thr", "=", "args", ".", "score_thr", ")", "\n", "# show result", "\n", "out_file", "=", "osp", ".", "join", "(", "out_vis_dir", ",", "img_name", ")", "\n", "kwargs_dict", "=", "{", "\n", "'score_thr'", ":", "args", ".", "score_thr", ",", "\n", "'show'", ":", "False", ",", "\n", "'out_file'", ":", "out_file", "\n", "}", "\n", "model", ".", "show_result", "(", "img_path", ",", "result", ",", "**", "kwargs_dict", ")", "\n", "\n", "", "print", "(", "f'\\nInference done, and results saved in {args.out_dir}\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args": [[8, 39], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "ValueError", "warnings.warn"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["def", "parse_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Print the whole config'", ")", "\n", "parser", ".", "add_argument", "(", "'config'", ",", "help", "=", "'config file path'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--options'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "action", "=", "DictAction", ",", "\n", "help", "=", "'override some settings in the used config, the key-value pair '", "\n", "'in xxx=yyy format will be merged into config file (deprecate), '", "\n", "'change to --cfg-options instead.'", ")", "\n", "parser", ".", "add_argument", "(", "\n", "'--cfg-options'", ",", "\n", "nargs", "=", "'+'", ",", "\n", "action", "=", "DictAction", ",", "\n", "help", "=", "'override some settings in the used config, the key-value pair '", "\n", "'in xxx=yyy format will be merged into config file. If the value to '", "\n", "'be overwritten is a list, it should be like key=\"[a,b]\" or key=a,b '", "\n", "'It also allows nested list/tuple values, e.g. key=\"[(a,b),(c,d)]\" '", "\n", "'Note that the quotation marks are necessary and that no white space '", "\n", "'is allowed.'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "args", ".", "options", "and", "args", ".", "cfg_options", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'--options and --cfg-options cannot be both '", "\n", "'specified, --options is deprecated in favor of --cfg-options'", ")", "\n", "", "if", "args", ".", "options", ":", "\n", "        ", "warnings", ".", "warn", "(", "'--options is deprecated in favor of --cfg-options'", ")", "\n", "args", ".", "cfg_options", "=", "args", ".", "options", "\n", "\n", "", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.main": [[41, 52], ["print_config.parse_args", "mmcv.Config.fromfile", "Config.fromfile.get", "print", "Config.fromfile.merge_from_dict", "import_modules_from_strings"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.misc.print_config.parse_args"], ["", "def", "main", "(", ")", ":", "\n", "    ", "args", "=", "parse_args", "(", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "args", ".", "config", ")", "\n", "if", "args", ".", "cfg_options", "is", "not", "None", ":", "\n", "        ", "cfg", ".", "merge_from_dict", "(", "args", ".", "cfg_options", ")", "\n", "# import modules from string list.", "\n", "", "if", "cfg", ".", "get", "(", "'custom_imports'", ",", "None", ")", ":", "\n", "        ", "from", "mmcv", ".", "utils", "import", "import_modules_from_strings", "\n", "import_modules_from_strings", "(", "**", "cfg", "[", "'custom_imports'", "]", ")", "\n", "", "print", "(", "f'Config:\\n{cfg.pretty_text}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.zh_cn.conf.builder_inited_handler": [[128, 132], ["subprocess.run", "subprocess.run", "subprocess.run"], "function", ["None"], ["def", "builder_inited_handler", "(", "app", ")", ":", "\n", "    ", "subprocess", ".", "run", "(", "[", "'./cp_origin_docs.sh'", "]", ")", "\n", "subprocess", ".", "run", "(", "[", "'./merge_docs.sh'", "]", ")", "\n", "subprocess", ".", "run", "(", "[", "'./stats.py'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.zh_cn.conf.setup": [[134, 136], ["app.connect"], "function", ["None"], ["", "def", "setup", "(", "app", ")", ":", "\n", "    ", "app", ".", "connect", "(", "'builder-inited'", ",", "builder_inited_handler", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.zh_cn.stats.title2anchor": [[12, 15], ["re.sub().strip", "re.sub", "re.sub", "name.strip().lower", "name.strip"], "function", ["None"], ["def", "title2anchor", "(", "name", ")", ":", "\n", "    ", "return", "re", ".", "sub", "(", "r'-+'", ",", "'-'", ",", "re", ".", "sub", "(", "r'[^a-zA-Z0-9]'", ",", "'-'", ",", "\n", "name", ".", "strip", "(", ")", ".", "lower", "(", ")", ")", ")", ".", "strip", "(", "'-'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.en.conf.builder_inited_handler": [[128, 131], ["subprocess.run", "subprocess.run"], "function", ["None"], ["def", "builder_inited_handler", "(", "app", ")", ":", "\n", "    ", "subprocess", ".", "run", "(", "[", "'./cp_origin_docs.sh'", "]", ")", "\n", "subprocess", ".", "run", "(", "[", "'./merge_docs.sh'", "]", ")", "\n", "subprocess", ".", "run", "(", "[", "'./stats.py'", "]", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.en.conf.setup": [[133, 135], ["app.connect"], "function", ["None"], ["\n", "", "def", "setup", "(", "app", ")", ":", "\n", "    ", "app", ".", "connect", "(", "'builder-inited'", ",", "builder_inited_handler", ")", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.en.stats.title2anchor": [[12, 15], ["re.sub().strip", "re.sub", "re.sub", "name.strip().lower", "name.strip"], "function", ["None"], ["def", "title2anchor", "(", "name", ")", ":", "\n", "    ", "return", "re", ".", "sub", "(", "r'-+'", ",", "'-'", ",", "re", ".", "sub", "(", "r'[^a-zA-Z0-9]'", ",", "'-'", ",", "\n", "name", ".", "strip", "(", ")", ".", "lower", "(", ")", ")", ")", ".", "strip", "(", "'-'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.build_model": [[21, 27], ["mmocr.models.build_detector", "mmocr.utils.revert_sync_batchnorm", "mmcv.parallel.MMDataParallel", "cfg.get"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm"], ["def", "build_model", "(", "cfg", ")", ":", "\n", "    ", "model", "=", "build_detector", "(", "cfg", ".", "model", ",", "test_cfg", "=", "cfg", ".", "get", "(", "'test_cfg'", ")", ")", "\n", "model", "=", "revert_sync_batchnorm", "(", "model", ")", "\n", "model", "=", "MMDataParallel", "(", "model", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.generate_sample_dataloader": [[29, 64], ["os.join", "os.join", "copy.deepcopy", "mmocr.datasets.build_dataset", "mmocr.datasets.build_dataloader", "collect_pipeline[].append", "dict", "dict", "cfg.data.get"], "function", ["None"], ["", "def", "generate_sample_dataloader", "(", "cfg", ",", "curr_dir", ",", "img_prefix", "=", "''", ",", "ann_file", "=", "''", ")", ":", "\n", "    ", "must_keys", "=", "[", "'img_norm_cfg'", ",", "'ori_filename'", ",", "'img_shape'", ",", "'ori_shape'", "]", "\n", "test_pipeline", "=", "cfg", ".", "data", ".", "test", ".", "pipeline", "\n", "for", "key", "in", "must_keys", ":", "\n", "        ", "if", "test_pipeline", "[", "1", "]", ".", "type", "==", "'MultiRotateAugOCR'", ":", "\n", "            ", "collect_pipeline", "=", "test_pipeline", "[", "1", "]", "[", "'transforms'", "]", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "            ", "collect_pipeline", "=", "test_pipeline", "[", "-", "1", "]", "\n", "", "if", "'meta_keys'", "not", "in", "collect_pipeline", ":", "\n", "            ", "continue", "\n", "", "collect_pipeline", "[", "'meta_keys'", "]", ".", "append", "(", "key", ")", "\n", "\n", "", "img_prefix", "=", "osp", ".", "join", "(", "curr_dir", ",", "img_prefix", ")", "\n", "ann_file", "=", "osp", ".", "join", "(", "curr_dir", ",", "ann_file", ")", "\n", "test", "=", "copy", ".", "deepcopy", "(", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ")", "\n", "test", ".", "img_prefix", "=", "img_prefix", "\n", "test", ".", "ann_file", "=", "ann_file", "\n", "cfg", ".", "data", ".", "workers_per_gpu", "=", "0", "\n", "cfg", ".", "data", ".", "test", ".", "datasets", "=", "[", "test", "]", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "test", ")", "\n", "\n", "loader_cfg", "=", "{", "\n", "**", "dict", "(", "(", "k", ",", "cfg", ".", "data", "[", "k", "]", ")", "for", "k", "in", "[", "\n", "'workers_per_gpu'", ",", "'samples_per_gpu'", "\n", "]", "if", "k", "in", "cfg", ".", "data", ")", "\n", "}", "\n", "test_loader_cfg", "=", "{", "\n", "**", "loader_cfg", ",", "\n", "**", "dict", "(", "shuffle", "=", "False", ",", "drop_last", "=", "False", ")", ",", "\n", "**", "cfg", ".", "data", ".", "get", "(", "'test_dataloader'", ",", "{", "}", ")", "\n", "}", "\n", "\n", "data_loader", "=", "build_dataloader", "(", "dataset", ",", "**", "test_loader_cfg", ")", "\n", "\n", "return", "data_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.test_single_gpu_test_recog": [[66, 87], ["pytest.mark.skipif", "pytest.mark.parametrize", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "mmcv.Config.fromfile", "test_single_gpu_test.build_model", "test_single_gpu_test.generate_sample_dataloader", "os.path.dirname", "os.path.dirname", "tempfile.TemporaryDirectory", "os.join", "mmocr.apis.test.single_gpu_test", "mmocr.utils.check_argument.is_type_list", "torch.cuda.is_available", "os.path.dirname", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.generate_sample_dataloader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'../configs/textrecog/sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "'../configs/textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "'../configs/textrecog/seg/seg_r31_1by16_fpnocr_academic.py'", "\n", "]", ")", "\n", "def", "test_single_gpu_test_recog", "(", "cfg_file", ")", ":", "\n", "    ", "curr_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "curr_dir", ",", "cfg_file", ")", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "img_prefix", "=", "'data/ocr_toy_dataset/imgs'", "\n", "ann_file", "=", "'data/ocr_toy_dataset/label.txt'", "\n", "data_loader", "=", "generate_sample_dataloader", "(", "cfg", ",", "curr_dir", ",", "img_prefix", ",", "\n", "ann_file", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "out_dir", "=", "osp", ".", "join", "(", "tmpdirname", ",", "'tmp'", ")", "\n", "results", "=", "single_gpu_test", "(", "model", ",", "data_loader", ",", "out_dir", "=", "out_dir", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.test_single_gpu_test_det": [[89, 108], ["pytest.mark.skipif", "pytest.mark.parametrize", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "mmcv.Config.fromfile", "test_single_gpu_test.build_model", "test_single_gpu_test.generate_sample_dataloader", "os.path.dirname", "os.path.dirname", "tempfile.TemporaryDirectory", "os.join", "mmocr.apis.test.single_gpu_test", "mmocr.utils.check_argument.is_type_list", "torch.cuda.is_available", "os.path.dirname", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.generate_sample_dataloader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "\n", "[", "'../configs/textdet/psenet/psenet_r50_fpnf_600e_icdar2017.py'", "]", ")", "\n", "def", "test_single_gpu_test_det", "(", "cfg_file", ")", ":", "\n", "    ", "curr_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "curr_dir", ",", "cfg_file", ")", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "img_prefix", "=", "'data/toy_dataset/imgs'", "\n", "ann_file", "=", "'data/toy_dataset/instances_test.json'", "\n", "data_loader", "=", "generate_sample_dataloader", "(", "cfg", ",", "curr_dir", ",", "img_prefix", ",", "\n", "ann_file", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "out_dir", "=", "osp", ".", "join", "(", "tmpdirname", ",", "'tmp'", ")", "\n", "results", "=", "single_gpu_test", "(", "model", ",", "data_loader", ",", "out_dir", "=", "out_dir", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.gene_sdmgr_model_dataloader": [[110, 160], ["os.join", "mmocr.utils.list_to_file", "copy.deepcopy", "os.join", "os.join", "mmocr.datasets.build_dataset", "mmocr.datasets.build_dataloader", "test_single_gpu_test.build_model", "numpy.ones", "os.join", "mmcv.imwrite", "dict", "dict", "cfg.data.get", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model"], ["", "", "def", "gene_sdmgr_model_dataloader", "(", "cfg", ",", "dirname", ",", "curr_dir", ",", "empty_img", "=", "False", ")", ":", "\n", "    ", "json_obj", "=", "{", "\n", "'file_name'", ":", "\n", "'1.jpg'", ",", "\n", "'height'", ":", "\n", "348", ",", "\n", "'width'", ":", "\n", "348", ",", "\n", "'annotations'", ":", "[", "{", "\n", "'box'", ":", "[", "114.0", ",", "19.0", ",", "230.0", ",", "19.0", ",", "230.0", ",", "1.0", ",", "114.0", ",", "1.0", "]", ",", "\n", "'text'", ":", "\n", "'CHOEUN'", ",", "\n", "'label'", ":", "\n", "1", "\n", "}", "]", "\n", "}", "\n", "ann_file", "=", "osp", ".", "join", "(", "dirname", ",", "'test.txt'", ")", "\n", "list_to_file", "(", "ann_file", ",", "[", "json", ".", "dumps", "(", "json_obj", ",", "ensure_ascii", "=", "False", ")", "]", ")", "\n", "\n", "if", "not", "empty_img", ":", "\n", "        ", "img", "=", "np", ".", "ones", "(", "(", "348", ",", "348", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "img_file", "=", "osp", ".", "join", "(", "dirname", ",", "'1.jpg'", ")", "\n", "mmcv", ".", "imwrite", "(", "img", ",", "img_file", ")", "\n", "\n", "", "test", "=", "copy", ".", "deepcopy", "(", "cfg", ".", "data", ".", "test", ")", "\n", "test", ".", "ann_file", "=", "ann_file", "\n", "test", ".", "img_prefix", "=", "dirname", "\n", "test", ".", "dict_file", "=", "osp", ".", "join", "(", "curr_dir", ",", "'data/kie_toy_dataset/dict.txt'", ")", "\n", "cfg", ".", "data", ".", "workers_per_gpu", "=", "1", "\n", "cfg", ".", "data", ".", "test", "=", "test", "\n", "cfg", ".", "model", ".", "class_list", "=", "osp", ".", "join", "(", "curr_dir", ",", "\n", "'data/kie_toy_dataset/class_list.txt'", ")", "\n", "\n", "dataset", "=", "build_dataset", "(", "cfg", ".", "data", ".", "test", ")", "\n", "\n", "loader_cfg", "=", "{", "\n", "**", "dict", "(", "(", "k", ",", "cfg", ".", "data", "[", "k", "]", ")", "for", "k", "in", "[", "\n", "'workers_per_gpu'", ",", "'samples_per_gpu'", "\n", "]", "if", "k", "in", "cfg", ".", "data", ")", "\n", "}", "\n", "test_loader_cfg", "=", "{", "\n", "**", "loader_cfg", ",", "\n", "**", "dict", "(", "shuffle", "=", "False", ",", "drop_last", "=", "False", ")", ",", "\n", "**", "cfg", ".", "data", ".", "get", "(", "'test_dataloader'", ",", "{", "}", ")", "\n", "}", "\n", "\n", "data_loader", "=", "build_dataloader", "(", "dataset", ",", "**", "test_loader_cfg", ")", "\n", "model", "=", "build_model", "(", "cfg", ")", "\n", "\n", "return", "model", ",", "data_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.test_single_gpu_test_kie": [[162, 177], ["pytest.mark.skipif", "pytest.mark.parametrize", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "mmcv.Config.fromfile", "os.path.dirname", "os.path.dirname", "tempfile.TemporaryDirectory", "os.join", "test_single_gpu_test.gene_sdmgr_model_dataloader", "mmocr.apis.test.single_gpu_test", "mmocr.utils.check_argument.is_type_list", "torch.cuda.is_available", "os.path.dirname", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.gene_sdmgr_model_dataloader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "[", "'../configs/kie/sdmgr/sdmgr_unet16_60e_wildreceipt.py'", "]", ")", "\n", "def", "test_single_gpu_test_kie", "(", "cfg_file", ")", ":", "\n", "    ", "curr_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "curr_dir", ",", "cfg_file", ")", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "out_dir", "=", "osp", ".", "join", "(", "tmpdirname", ",", "'tmp'", ")", "\n", "model", ",", "data_loader", "=", "gene_sdmgr_model_dataloader", "(", "\n", "cfg", ",", "out_dir", ",", "curr_dir", ")", "\n", "results", "=", "single_gpu_test", "(", "\n", "model", ",", "data_loader", ",", "out_dir", "=", "out_dir", ",", "is_kie", "=", "True", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.test_single_gpu_test_kie_novisual": [[179, 206], ["pytest.mark.skipif", "pytest.mark.parametrize", "os.path.abspath", "os.path.abspath", "os.path.join", "os.path.join", "mmcv.Config.fromfile", "list", "tuple", "os.path.dirname", "os.path.dirname", "list.append", "tempfile.TemporaryDirectory", "os.join", "test_single_gpu_test.gene_sdmgr_model_dataloader", "mmocr.apis.test.single_gpu_test", "mmocr.utils.check_argument.is_type_list", "test_single_gpu_test.gene_sdmgr_model_dataloader", "mmocr.apis.test.single_gpu_test", "mmocr.utils.check_argument.is_type_list", "torch.cuda.is_available", "os.path.dirname", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.gene_sdmgr_model_dataloader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_single_gpu_test.gene_sdmgr_model_dataloader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.test.single_gpu_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "[", "'../configs/kie/sdmgr/sdmgr_novisual_60e_wildreceipt.py'", "]", ")", "\n", "def", "test_single_gpu_test_kie_novisual", "(", "cfg_file", ")", ":", "\n", "    ", "curr_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "curr_dir", ",", "cfg_file", ")", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "meta_keys", "=", "list", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "-", "1", "]", "[", "'meta_keys'", "]", ")", "\n", "must_keys", "=", "[", "'img_norm_cfg'", ",", "'ori_filename'", ",", "'img_shape'", "]", "\n", "for", "key", "in", "must_keys", ":", "\n", "        ", "meta_keys", ".", "append", "(", "key", ")", "\n", "\n", "", "cfg", ".", "data", ".", "test", ".", "pipeline", "[", "-", "1", "]", "[", "'meta_keys'", "]", "=", "tuple", "(", "meta_keys", ")", "\n", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "out_dir", "=", "osp", ".", "join", "(", "tmpdirname", ",", "'tmp'", ")", "\n", "model", ",", "data_loader", "=", "gene_sdmgr_model_dataloader", "(", "\n", "cfg", ",", "out_dir", ",", "curr_dir", ",", "empty_img", "=", "True", ")", "\n", "results", "=", "single_gpu_test", "(", "\n", "model", ",", "data_loader", ",", "out_dir", "=", "out_dir", ",", "is_kie", "=", "True", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "\n", "model", ",", "data_loader", "=", "gene_sdmgr_model_dataloader", "(", "\n", "cfg", ",", "out_dir", ",", "curr_dir", ")", "\n", "results", "=", "single_gpu_test", "(", "\n", "model", ",", "data_loader", ",", "out_dir", "=", "out_dir", ",", "is_kie", "=", "True", ")", "\n", "assert", "check_argument", ".", "is_type_list", "(", "results", ",", "dict", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_image_misc.test_tensor2grayimgs": [[10, 43], ["pytest.mark.skipif", "torch.randn", "mmocr.apis.utils.tensor2grayimgs", "zip", "pytest.raises", "numpy.random.rand", "mmocr.apis.utils.tensor2grayimgs", "pytest.raises", "torch.randn", "mmocr.apis.utils.tensor2grayimgs", "pytest.raises", "torch.randn", "mmocr.apis.utils.tensor2grayimgs", "pytest.raises", "torch.randn", "mmocr.apis.utils.tensor2grayimgs", "pytest.raises", "torch.randn", "mmocr.apis.utils.tensor2grayimgs", "t.squeeze().cpu().numpy().astype", "numpy.testing.assert_array_equal", "torch.cuda.is_available", "t.squeeze().cpu().numpy", "t.squeeze().cpu", "t.squeeze"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.tensor2grayimgs"], ["@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "def", "test_tensor2grayimgs", "(", ")", ":", "\n", "\n", "# test tensor obj", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "tensor", "=", "np", ".", "random", ".", "rand", "(", "2", ",", "3", ",", "3", ")", "\n", "tensor2grayimgs", "(", "tensor", ")", "\n", "\n", "# test tensor ndim", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "tensor", "=", "torch", ".", "randn", "(", "2", ",", "3", ",", "3", ")", "\n", "tensor2grayimgs", "(", "tensor", ")", "\n", "\n", "# test tensor dim-1", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "tensor", "=", "torch", ".", "randn", "(", "2", ",", "3", ",", "5", ",", "5", ")", "\n", "tensor2grayimgs", "(", "tensor", ")", "\n", "\n", "# test mean length", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "tensor", "=", "torch", ".", "randn", "(", "2", ",", "1", ",", "5", ",", "5", ")", "\n", "tensor2grayimgs", "(", "tensor", ",", "mean", "=", "(", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "# test std length", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "tensor", "=", "torch", ".", "randn", "(", "2", ",", "1", ",", "5", ",", "5", ")", "\n", "tensor2grayimgs", "(", "tensor", ",", "std", "=", "(", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "", "tensor", "=", "torch", ".", "randn", "(", "2", ",", "1", ",", "5", ",", "5", ")", "\n", "gts", "=", "[", "t", ".", "squeeze", "(", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "for", "t", "in", "tensor", "]", "\n", "outputs", "=", "tensor2grayimgs", "(", "tensor", ",", "mean", "=", "(", "0", ",", ")", ",", "std", "=", "(", "1", ",", ")", ")", "\n", "for", "gt", ",", "output", "in", "zip", "(", "gts", ",", "outputs", ")", ":", "\n", "        ", "assert_array_equal", "(", "gt", ",", "output", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_utils.test_disable_text_recog_aug_test": [[12, 70], ["pytest.mark.parametrize", "os.path.abspath", "os.path.join", "mmcv.Config.fromfile", "copy.deepcopy", "copy.deepcopy", "mmocr.apis.utils.disable_text_recog_aug_test", "copy.deepcopy", "copy.deepcopy", "mmocr.apis.utils.disable_text_recog_aug_test", "copy.deepcopy", "copy.deepcopy", "mmcv.Config", "mmocr.apis.utils.disable_text_recog_aug_test", "copy.deepcopy", "copy.deepcopy", "mmocr.apis.utils.disable_text_recog_aug_test", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "mmocr.apis.utils.disable_text_recog_aug_test", "os.path.dirname", "dict", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.disable_text_recog_aug_test"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'../configs/textrecog/sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "]", ")", "\n", "def", "test_disable_text_recog_aug_test", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "test", "=", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "\n", "\n", "# cfg.data.test.type is 'OCRDataset'", "\n", "cfg1", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test1", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test1", ".", "pipeline", "=", "cfg1", ".", "data", ".", "test", ".", "pipeline", "\n", "cfg1", ".", "data", ".", "test", "=", "test1", "\n", "cfg1", "=", "disable_text_recog_aug_test", "(", "cfg1", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg1", ".", "data", ".", "test", ".", "pipeline", "[", "1", "]", ".", "type", "!=", "'MultiRotateAugOCR'", "\n", "\n", "# cfg.data.test.type is 'UniformConcatDataset'", "\n", "# and cfg.data.test.pipeline is list[dict]", "\n", "cfg2", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test2", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test2", ".", "pipeline", "=", "cfg2", ".", "data", ".", "test", ".", "pipeline", "\n", "cfg2", ".", "data", ".", "test", ".", "datasets", "=", "[", "test2", "]", "\n", "cfg2", "=", "disable_text_recog_aug_test", "(", "cfg2", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg2", ".", "data", ".", "test", ".", "pipeline", "[", "1", "]", ".", "type", "!=", "'MultiRotateAugOCR'", "\n", "assert", "cfg2", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ".", "pipeline", "[", "1", "]", ".", "type", "!=", "'MultiRotateAugOCR'", "\n", "\n", "# cfg.data.test.type is 'ConcatDataset'", "\n", "cfg3", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test3", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test3", ".", "pipeline", "=", "cfg3", ".", "data", ".", "test", ".", "pipeline", "\n", "cfg3", ".", "data", ".", "test", "=", "Config", "(", "dict", "(", "type", "=", "'ConcatDataset'", ",", "datasets", "=", "[", "test3", "]", ")", ")", "\n", "cfg3", "=", "disable_text_recog_aug_test", "(", "cfg3", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg3", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ".", "pipeline", "[", "1", "]", ".", "type", "!=", "'MultiRotateAugOCR'", "\n", "\n", "# cfg.data.test.type is 'UniformConcatDataset'", "\n", "# and cfg.data.test.pipeline is list[list[dict]]", "\n", "cfg4", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test4", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test4", ".", "pipeline", "=", "cfg4", ".", "data", ".", "test", ".", "pipeline", "\n", "cfg4", ".", "data", ".", "test", ".", "datasets", "=", "[", "[", "test4", "]", ",", "[", "test", "]", "]", "\n", "cfg4", ".", "data", ".", "test", ".", "pipeline", "=", "[", "\n", "cfg4", ".", "data", ".", "test", ".", "pipeline", ",", "cfg4", ".", "data", ".", "test", ".", "pipeline", "\n", "]", "\n", "cfg4", "=", "disable_text_recog_aug_test", "(", "cfg4", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg4", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "[", "0", "]", ".", "pipeline", "[", "1", "]", ".", "type", "!=", "'MultiRotateAugOCR'", "\n", "\n", "# cfg.data.test.type is 'UniformConcatDataset'", "\n", "# and cfg.data.test.pipeline is None", "\n", "cfg5", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test5", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test5", ".", "pipeline", "=", "copy", ".", "deepcopy", "(", "cfg5", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "cfg5", ".", "data", ".", "test", ".", "datasets", "=", "[", "test5", "]", "\n", "cfg5", ".", "data", ".", "test", ".", "pipeline", "=", "None", "\n", "cfg5", "=", "disable_text_recog_aug_test", "(", "cfg5", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg5", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ".", "pipeline", "[", "1", "]", ".", "type", "!=", "'MultiRotateAugOCR'", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_utils.test_replace_image_to_tensor": [[72, 108], ["pytest.mark.parametrize", "os.path.abspath", "os.path.join", "mmcv.Config.fromfile", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "mmocr.apis.utils.replace_image_to_tensor", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "mmocr.apis.utils.replace_image_to_tensor", "os.path.dirname", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.replace_image_to_tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.utils.replace_image_to_tensor"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'../configs/textdet/psenet/psenet_r50_fpnf_600e_ctw1500.py'", ",", "\n", "]", ")", "\n", "def", "test_replace_image_to_tensor", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "\n", "cfg", "=", "Config", ".", "fromfile", "(", "config_file", ")", "\n", "test", "=", "cfg", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "\n", "\n", "# cfg.data.test.pipeline is list[dict]", "\n", "# and cfg.data.test.datasets is list[dict]", "\n", "cfg1", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test1", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test1", ".", "pipeline", "=", "copy", ".", "deepcopy", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "cfg1", ".", "data", ".", "test", ".", "datasets", "=", "[", "test1", "]", "\n", "cfg1", "=", "replace_image_to_tensor", "(", "cfg1", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg1", ".", "data", ".", "test", ".", "pipeline", "[", "1", "]", "[", "'transforms'", "]", "[", "3", "]", "[", "\n", "'type'", "]", "==", "'DefaultFormatBundle'", "\n", "assert", "cfg1", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", ".", "pipeline", "[", "1", "]", "[", "'transforms'", "]", "[", "3", "]", "[", "\n", "'type'", "]", "==", "'DefaultFormatBundle'", "\n", "\n", "# cfg.data.test.pipeline is list[list[dict]]", "\n", "# and cfg.data.test.datasets is list[list[dict]]", "\n", "cfg2", "=", "copy", ".", "deepcopy", "(", "cfg", ")", "\n", "test2", "=", "copy", ".", "deepcopy", "(", "test", ")", "\n", "test2", ".", "pipeline", "=", "copy", ".", "deepcopy", "(", "cfg", ".", "data", ".", "test", ".", "pipeline", ")", "\n", "cfg2", ".", "data", ".", "test", ".", "datasets", "=", "[", "[", "test2", "]", ",", "[", "test2", "]", "]", "\n", "cfg2", ".", "data", ".", "test", ".", "pipeline", "=", "[", "\n", "cfg2", ".", "data", ".", "test", ".", "pipeline", ",", "cfg2", ".", "data", ".", "test", ".", "pipeline", "\n", "]", "\n", "cfg2", "=", "replace_image_to_tensor", "(", "cfg2", ",", "set_types", "=", "[", "'test'", "]", ")", "\n", "assert", "cfg2", ".", "data", ".", "test", ".", "pipeline", "[", "0", "]", "[", "1", "]", "[", "'transforms'", "]", "[", "3", "]", "[", "\n", "'type'", "]", "==", "'DefaultFormatBundle'", "\n", "assert", "cfg2", ".", "data", ".", "test", ".", "datasets", "[", "0", "]", "[", "0", "]", ".", "pipeline", "[", "1", "]", "[", "'transforms'", "]", "[", "3", "]", "[", "\n", "'type'", "]", "==", "'DefaultFormatBundle'", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model": [[14, 20], ["mmocr.apis.inference.init_detector", "mmocr.utils.revert_sync_batchnorm"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm"], ["def", "build_model", "(", "config_file", ")", ":", "\n", "    ", "device", "=", "'cpu'", "\n", "model", "=", "init_detector", "(", "config_file", ",", "checkpoint", "=", "None", ",", "device", "=", "device", ")", "\n", "model", "=", "revert_sync_batchnorm", "(", "model", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.test_model_inference": [[22, 46], ["pytest.mark.skipif", "pytest.mark.parametrize", "os.path.abspath", "os.path.join", "test_model_inference.build_model", "os.path.join", "mmocr.apis.inference.model_inference", "mmcv.image.imread", "mmocr.apis.inference.model_inference", "os.path.dirname", "pytest.raises", "mmocr.apis.inference.model_inference", "platform.system", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "platform", ".", "system", "(", ")", "==", "'Windows'", ",", "\n", "reason", "=", "'Win container on Github Action does not have enough RAM to run'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'../configs/textrecog/sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "'../configs/textrecog/abinet/abinet_academic.py'", ",", "\n", "'../configs/textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "'../configs/textrecog/seg/seg_r31_1by16_fpnocr_academic.py'", ",", "\n", "'../configs/textdet/psenet/psenet_r50_fpnf_600e_icdar2017.py'", "\n", "]", ")", "\n", "def", "test_model_inference", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "model", "=", "build_model", "(", "config_file", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "model_inference", "(", "model", ",", "1", ")", "\n", "\n", "", "sample_img_path", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'../demo/demo_text_det.jpg'", ")", "\n", "model_inference", "(", "model", ",", "sample_img_path", ")", "\n", "\n", "# numpy inference", "\n", "img", "=", "imread", "(", "sample_img_path", ")", "\n", "\n", "model_inference", "(", "model", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.test_model_batch_inference_det": [[48, 69], ["pytest.mark.skipif", "pytest.mark.parametrize", "os.path.abspath", "os.path.join", "test_model_inference.build_model", "os.path.join", "mmocr.apis.inference.model_inference", "mmcv.image.imread", "mmocr.apis.inference.model_inference", "os.path.dirname", "len", "len", "platform.system", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "platform", ".", "system", "(", ")", "==", "'Windows'", ",", "\n", "reason", "=", "'Win container on Github Action does not have enough RAM to run'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "\n", "[", "'../configs/textdet/psenet/psenet_r50_fpnf_600e_icdar2017.py'", "]", ")", "\n", "def", "test_model_batch_inference_det", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "model", "=", "build_model", "(", "config_file", ")", "\n", "\n", "sample_img_path", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'../demo/demo_text_det.jpg'", ")", "\n", "results", "=", "model_inference", "(", "model", ",", "[", "sample_img_path", "]", ",", "batch_mode", "=", "True", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "1", "\n", "\n", "# numpy inference", "\n", "img", "=", "imread", "(", "sample_img_path", ")", "\n", "results", "=", "model_inference", "(", "model", ",", "[", "img", "]", ",", "batch_mode", "=", "True", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.test_model_batch_inference_raises_exception_error_aug_test_recog": [[71, 90], ["pytest.mark.parametrize", "os.path.abspath", "os.path.join", "test_model_inference.build_model", "os.path.dirname", "pytest.raises", "os.path.join", "mmocr.apis.inference.model_inference", "pytest.raises", "mmcv.image.imread", "mmocr.apis.inference.model_inference", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'../configs/textrecog/sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "]", ")", "\n", "def", "test_model_batch_inference_raises_exception_error_aug_test_recog", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "model", "=", "build_model", "(", "config_file", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "\n", "Exception", ",", "\n", "match", "=", "'aug test does not support inference with batch size'", ")", ":", "\n", "        ", "sample_img_path", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'../demo/demo_text_det.jpg'", ")", "\n", "model_inference", "(", "model", ",", "[", "sample_img_path", ",", "sample_img_path", "]", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "\n", "Exception", ",", "\n", "match", "=", "'aug test does not support inference with batch size'", ")", ":", "\n", "        ", "img", "=", "imread", "(", "sample_img_path", ")", "\n", "model_inference", "(", "model", ",", "[", "img", ",", "img", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.test_model_batch_inference_recog": [[92, 111], ["pytest.mark.parametrize", "os.path.abspath", "os.path.join", "test_model_inference.build_model", "os.path.join", "mmocr.apis.inference.model_inference", "mmcv.image.imread", "mmocr.apis.inference.model_inference", "os.path.dirname", "len", "len", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'../configs/textrecog/sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "]", ")", "\n", "def", "test_model_batch_inference_recog", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "model", "=", "build_model", "(", "config_file", ")", "\n", "\n", "sample_img_path", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "'../demo/demo_text_recog.jpg'", ")", "\n", "results", "=", "model_inference", "(", "\n", "model", ",", "[", "sample_img_path", ",", "sample_img_path", "]", ",", "batch_mode", "=", "True", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "2", "\n", "\n", "# numpy inference", "\n", "img", "=", "imread", "(", "sample_img_path", ")", "\n", "results", "=", "model_inference", "(", "model", ",", "[", "img", ",", "img", "]", ",", "batch_mode", "=", "True", ")", "\n", "\n", "assert", "len", "(", "results", ")", "==", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.test_model_batch_inference_empty_detection": [[113, 128], ["pytest.mark.parametrize", "os.path.abspath", "os.path.join", "test_model_inference.build_model", "os.path.dirname", "pytest.raises", "mmocr.apis.inference.model_inference", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_apis.test_model_inference.build_model", "home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.model_inference"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "\n", "[", "'../configs/textdet/psenet/psenet_r50_fpnf_600e_icdar2017.py'", "]", ")", "\n", "def", "test_model_batch_inference_empty_detection", "(", "cfg_file", ")", ":", "\n", "    ", "tmp_dir", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ")", ")", "\n", "config_file", "=", "os", ".", "path", ".", "join", "(", "tmp_dir", ",", "cfg_file", ")", "\n", "model", "=", "build_model", "(", "config_file", ")", "\n", "\n", "empty_detection", "=", "[", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "\n", "Exception", ",", "\n", "match", "=", "'empty imgs provided, please check and try again'", ")", ":", "\n", "\n", "        ", "model_inference", "(", "model", ",", "empty_detection", ",", "batch_mode", "=", "True", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_icdar_dataset._create_dummy_icdar_json": [[11, 89], ["mmcv.dump"], "function", ["None"], ["def", "_create_dummy_icdar_json", "(", "json_name", ")", ":", "\n", "    ", "image_1", "=", "{", "\n", "'id'", ":", "0", ",", "\n", "'width'", ":", "640", ",", "\n", "'height'", ":", "640", ",", "\n", "'file_name'", ":", "'fake_name.jpg'", ",", "\n", "}", "\n", "image_2", "=", "{", "\n", "'id'", ":", "1", ",", "\n", "'width'", ":", "640", ",", "\n", "'height'", ":", "640", ",", "\n", "'file_name'", ":", "'fake_name1.jpg'", ",", "\n", "}", "\n", "\n", "annotation_1", "=", "{", "\n", "'id'", ":", "1", ",", "\n", "'image_id'", ":", "0", ",", "\n", "'category_id'", ":", "0", ",", "\n", "'area'", ":", "400", ",", "\n", "'bbox'", ":", "[", "50", ",", "60", ",", "20", ",", "20", "]", ",", "\n", "'iscrowd'", ":", "0", ",", "\n", "'segmentation'", ":", "[", "[", "50", ",", "60", ",", "70", ",", "60", ",", "70", ",", "80", ",", "50", ",", "80", "]", "]", "\n", "}", "\n", "\n", "annotation_2", "=", "{", "\n", "'id'", ":", "2", ",", "\n", "'image_id'", ":", "0", ",", "\n", "'category_id'", ":", "0", ",", "\n", "'area'", ":", "900", ",", "\n", "'bbox'", ":", "[", "100", ",", "120", ",", "30", ",", "30", "]", ",", "\n", "'iscrowd'", ":", "0", ",", "\n", "'segmentation'", ":", "[", "[", "100", ",", "120", ",", "130", ",", "120", ",", "120", ",", "150", ",", "100", ",", "150", "]", "]", "\n", "}", "\n", "\n", "annotation_3", "=", "{", "\n", "'id'", ":", "3", ",", "\n", "'image_id'", ":", "0", ",", "\n", "'category_id'", ":", "0", ",", "\n", "'area'", ":", "1600", ",", "\n", "'bbox'", ":", "[", "150", ",", "160", ",", "40", ",", "40", "]", ",", "\n", "'iscrowd'", ":", "1", ",", "\n", "'segmentation'", ":", "[", "[", "150", ",", "160", ",", "190", ",", "160", ",", "190", ",", "200", ",", "150", ",", "200", "]", "]", "\n", "}", "\n", "\n", "annotation_4", "=", "{", "\n", "'id'", ":", "4", ",", "\n", "'image_id'", ":", "0", ",", "\n", "'category_id'", ":", "0", ",", "\n", "'area'", ":", "10000", ",", "\n", "'bbox'", ":", "[", "250", ",", "260", ",", "100", ",", "100", "]", ",", "\n", "'iscrowd'", ":", "1", ",", "\n", "'segmentation'", ":", "[", "[", "250", ",", "260", ",", "350", ",", "260", ",", "350", ",", "360", ",", "250", ",", "360", "]", "]", "\n", "}", "\n", "annotation_5", "=", "{", "\n", "'id'", ":", "5", ",", "\n", "'image_id'", ":", "1", ",", "\n", "'category_id'", ":", "0", ",", "\n", "'area'", ":", "10000", ",", "\n", "'bbox'", ":", "[", "250", ",", "260", ",", "100", ",", "100", "]", ",", "\n", "'iscrowd'", ":", "1", ",", "\n", "'segmentation'", ":", "[", "[", "250", ",", "260", ",", "350", ",", "260", ",", "350", ",", "360", ",", "250", ",", "360", "]", "]", "\n", "}", "\n", "\n", "categories", "=", "[", "{", "\n", "'id'", ":", "0", ",", "\n", "'name'", ":", "'text'", ",", "\n", "'supercategory'", ":", "'text'", ",", "\n", "}", "]", "\n", "\n", "fake_json", "=", "{", "\n", "'images'", ":", "[", "image_1", ",", "image_2", "]", ",", "\n", "'annotations'", ":", "\n", "[", "annotation_1", ",", "annotation_2", ",", "annotation_3", ",", "annotation_4", ",", "annotation_5", "]", ",", "\n", "'categories'", ":", "\n", "categories", "\n", "}", "\n", "\n", "mmcv", ".", "dump", "(", "fake_json", ",", "json_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_icdar_dataset.test_icdar_dataset": [[91, 172], ["tempfile.TemporaryDirectory", "os.join", "test_icdar_dataset._create_dummy_icdar_json", "mmocr.datasets.icdar_dataset.IcdarDataset", "mmocr.datasets.icdar_dataset.IcdarDataset.get_ann_info", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "tempfile.TemporaryDirectory.cleanup", "mmocr.datasets.icdar_dataset.IcdarDataset.evaluate", "mmocr.datasets.icdar_dataset.IcdarDataset.evaluate", "mmocr.datasets.icdar_dataset.IcdarDataset.evaluate"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_icdar_dataset._create_dummy_icdar_json", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "test_icdar_dataset", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "fake_json_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.json'", ")", "\n", "_create_dummy_icdar_json", "(", "fake_json_file", ")", "\n", "\n", "# test initialization", "\n", "dataset", "=", "IcdarDataset", "(", "ann_file", "=", "fake_json_file", ",", "pipeline", "=", "[", "]", ")", "\n", "assert", "dataset", ".", "CLASSES", "==", "(", "'text'", ")", "\n", "assert", "dataset", ".", "img_ids", "==", "[", "0", ",", "1", "]", "\n", "assert", "dataset", ".", "select_first_k", "==", "-", "1", "\n", "\n", "# test _parse_ann_info", "\n", "ann", "=", "dataset", ".", "get_ann_info", "(", "0", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'bboxes'", "]", ",", "\n", "[", "[", "50.", ",", "60.", ",", "70.", ",", "80.", "]", ",", "[", "100.", ",", "120.", ",", "130.", ",", "150.", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'labels'", "]", ",", "[", "0", ",", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'bboxes_ignore'", "]", ",", "\n", "[", "[", "150.", ",", "160.", ",", "190.", ",", "200.", "]", ",", "[", "250.", ",", "260.", ",", "350.", ",", "360.", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'masks'", "]", ",", "\n", "[", "[", "[", "50", ",", "60", ",", "70", ",", "60", ",", "70", ",", "80", ",", "50", ",", "80", "]", "]", ",", "\n", "[", "[", "100", ",", "120", ",", "130", ",", "120", ",", "120", ",", "150", ",", "100", ",", "150", "]", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'masks_ignore'", "]", ",", "\n", "[", "[", "[", "150", ",", "160", ",", "190", ",", "160", ",", "190", ",", "200", ",", "150", ",", "200", "]", "]", ",", "\n", "[", "[", "250", ",", "260", ",", "350", ",", "260", ",", "350", ",", "360", ",", "250", ",", "360", "]", "]", "]", ")", "\n", "assert", "dataset", ".", "cat_ids", "==", "[", "0", "]", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n", "# test rank output", "\n", "# result = [[]]", "\n", "# out_file = tempfile.NamedTemporaryFile().name", "\n", "\n", "# with pytest.raises(AssertionError):", "\n", "#     dataset.output_ranklist(result, out_file)", "\n", "\n", "# result = [{'hmean': 1}, {'hmean': 0.5}]", "\n", "\n", "# output = dataset.output_ranklist(result, out_file)", "\n", "\n", "# assert output[0]['hmean'] == 0.5", "\n", "\n", "# test get_gt_mask", "\n", "# output = dataset.get_gt_mask()", "\n", "# assert np.allclose(output[0][0],", "\n", "#                    [[50, 60, 70, 60, 70, 80, 50, 80],", "\n", "#                     [100, 120, 130, 120, 120, 150, 100, 150]])", "\n", "# assert output[0][1] == []", "\n", "# assert np.allclose(output[1][0],", "\n", "#                    [[150, 160, 190, 160, 190, 200, 150, 200],", "\n", "#                     [250, 260, 350, 260, 350, 360, 250, 360]])", "\n", "# assert np.allclose(output[1][1],", "\n", "#                    [[250, 260, 350, 260, 350, 360, 250, 360]])", "\n", "\n", "# test evluation", "\n", "metrics", "=", "[", "'hmean-iou'", ",", "'hmean-ic13'", "]", "\n", "results", "=", "[", "{", "\n", "'boundary_result'", ":", "[", "[", "50", ",", "60", ",", "70", ",", "60", ",", "70", ",", "80", ",", "50", ",", "80", ",", "1", "]", ",", "\n", "[", "100", ",", "120", ",", "130", ",", "120", ",", "120", ",", "150", ",", "100", ",", "150", ",", "1", "]", "]", "\n", "}", ",", "{", "\n", "'boundary_result'", ":", "[", "]", "\n", "}", "]", "\n", "output", "=", "dataset", ".", "evaluate", "(", "results", ",", "metrics", ")", "\n", "assert", "output", "[", "'hmean-iou:hmean'", "]", "==", "1", "\n", "assert", "output", "[", "'hmean-ic13:hmean'", "]", "==", "1", "\n", "\n", "results", "=", "[", "{", "\n", "'boundary_result'", ":", "[", "[", "50", ",", "60", ",", "70", ",", "60", ",", "70", ",", "80", ",", "50", ",", "80", ",", "0.5", "]", ",", "\n", "[", "100", ",", "120", ",", "130", ",", "120", ",", "120", ",", "150", ",", "100", ",", "150", ",", "1", "]", "]", "\n", "}", ",", "{", "\n", "'boundary_result'", ":", "[", "]", "\n", "}", "]", "\n", "output", "=", "dataset", ".", "evaluate", "(", "\n", "results", ",", "metrics", ",", "min_score_thr", "=", "0", ",", "max_score_thr", "=", "1", ",", "step", "=", "0.5", ")", "\n", "assert", "output", "[", "'hmean-iou:hmean'", "]", "==", "1", "\n", "assert", "output", "[", "'hmean-ic13:hmean'", "]", "==", "1", "\n", "\n", "output", "=", "dataset", ".", "evaluate", "(", "\n", "results", ",", "metrics", ",", "min_score_thr", "=", "0.6", ",", "max_score_thr", "=", "1", ",", "step", "=", "0.5", ")", "\n", "assert", "output", "[", "'hmean-iou:hmean'", "]", "==", "1", "/", "1.5", "\n", "assert", "output", "[", "'hmean-ic13:hmean'", "]", "==", "1", "/", "1.5", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_dbnet_transforms.test_imgaug": [[9, 45], ["mmocr.ImgAug", "numpy.random.rand", "numpy.array", "numpy.array", "dict", "transforms.ImgAug.", "range", "mmocr.ImgAug", "numpy.random.rand", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "dict", "transforms.ImgAug.", "numpy.allclose", "range", "dict", "imgaug.augmentables.polys.Polygon", "imgaug.augmentables.polys.Polygon.to_bounding_box().clip_out_of_image", "poly.to_bounding_box().clip_out_of_image.coords_almost_equals", "dict", "shapely.geometry.Polygon", "shapely.geometry.Polygon", "shapely.geometry.Polygon.equals", "numpy.allclose", "mask.reshape", "[].reshape", "[].reshape", "poly_target[].reshape", "dict", "imgaug.augmentables.polys.Polygon.to_bounding_box", "dict"], "function", ["None"], ["def", "test_imgaug", "(", ")", ":", "\n", "    ", "args", "=", "[", "dict", "(", "cls", "=", "'Affine'", ",", "translate_px", "=", "dict", "(", "x", "=", "-", "10", ",", "y", "=", "-", "10", ")", ")", "]", "\n", "imgaug_transform", "=", "transforms", ".", "ImgAug", "(", "args", ",", "clip_invalid_ploys", "=", "False", ")", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "100", ",", "200", ",", "3", ")", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", ",", "50", ",", "0", ",", "50", ",", "50", ",", "0", ",", "50", "]", "]", ",", "\n", "[", "[", "20", ",", "20", ",", "50", ",", "20", ",", "50", ",", "50", ",", "20", ",", "50", "]", "]", "]", ")", "\n", "box", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "50", ",", "50", "]", ",", "[", "20", ",", "20", ",", "50", ",", "50", "]", "]", ")", "\n", "results", "=", "dict", "(", "img", "=", "img", ",", "masks", "=", "poly", ",", "bboxes", "=", "box", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'masks'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'bboxes'", "]", "\n", "results", "=", "imgaug_transform", "(", "results", ")", "\n", "for", "i", "in", "range", "(", "2", ")", ":", "\n", "        ", "mask", "=", "results", "[", "'masks'", "]", ".", "masks", "[", "i", "]", "[", "0", "]", "\n", "poly", "=", "imgaug", ".", "augmentables", ".", "polys", ".", "Polygon", "(", "mask", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "box", "=", "poly", ".", "to_bounding_box", "(", ")", ".", "clip_out_of_image", "(", "results", "[", "'img_shape'", "]", ")", "\n", "assert", "box", ".", "coords_almost_equals", "(", "results", "[", "'bboxes'", "]", "[", "i", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "\n", "", "args", "=", "[", "dict", "(", "cls", "=", "'Affine'", ",", "translate_px", "=", "dict", "(", "x", "=", "-", "10", ",", "y", "=", "-", "10", ")", ")", "]", "\n", "imgaug_transform", "=", "transforms", ".", "ImgAug", "(", "args", ",", "clip_invalid_ploys", "=", "True", ")", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "100", ",", "200", ",", "3", ")", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", ",", "50", ",", "0", ",", "50", ",", "50", ",", "0", ",", "50", "]", "]", ",", "\n", "[", "[", "20", ",", "20", ",", "50", ",", "20", ",", "50", ",", "50", ",", "20", ",", "50", "]", "]", "]", ")", "\n", "box", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "50", ",", "50", "]", ",", "[", "20", ",", "20", ",", "50", ",", "50", "]", "]", ")", "\n", "poly_target", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", ",", "40", ",", "0", ",", "40", ",", "40", ",", "0", ",", "40", "]", "]", ",", "\n", "[", "[", "10", ",", "10", ",", "40", ",", "10", ",", "40", ",", "40", ",", "10", ",", "40", "]", "]", "]", ")", "\n", "box_target", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "40", ",", "40", "]", ",", "[", "10", ",", "10", ",", "40", ",", "40", "]", "]", ")", "\n", "results", "=", "dict", "(", "img", "=", "img", ",", "masks", "=", "poly", ",", "bboxes", "=", "box", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'masks'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'bboxes'", "]", "\n", "results", "=", "imgaug_transform", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'bboxes'", "]", ",", "box_target", ")", "\n", "for", "i", "in", "range", "(", "2", ")", ":", "\n", "        ", "poly1", "=", "Polygon", "(", "results", "[", "'masks'", "]", ".", "masks", "[", "i", "]", "[", "0", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "poly2", "=", "Polygon", "(", "poly_target", "[", "i", "]", ".", "reshape", "(", "-", "1", ",", "2", ")", ")", "\n", "assert", "poly1", ".", "equals", "(", "poly2", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'bboxes'", "]", "[", "i", "]", ",", "box_target", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_dbnet_transforms.test_eastrandomcrop": [[47, 59], ["mmocr.EastRandomCrop", "numpy.random.rand", "numpy.array", "numpy.array", "dict", "transforms.EastRandomCrop.", "numpy.allclose", "[].flatten"], "function", ["None"], ["", "", "def", "test_eastrandomcrop", "(", ")", ":", "\n", "    ", "crop", "=", "transforms", ".", "EastRandomCrop", "(", "target_size", "=", "(", "60", ",", "60", ")", ",", "max_tries", "=", "100", ")", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "3", ",", "100", ",", "200", ")", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", ",", "50", ",", "0", ",", "50", ",", "50", ",", "0", ",", "50", "]", "]", ",", "\n", "[", "[", "20", ",", "20", ",", "50", ",", "20", ",", "50", ",", "50", ",", "20", ",", "50", "]", "]", "]", ")", "\n", "box", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "50", ",", "50", "]", ",", "[", "20", ",", "20", ",", "50", ",", "50", "]", "]", ")", "\n", "results", "=", "dict", "(", "img", "=", "img", ",", "gt_masks", "=", "poly", ",", "bboxes", "=", "box", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "results", "[", "'bbox_fields'", "]", "=", "[", "'bboxes'", "]", "\n", "results", "=", "crop", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'bboxes'", "]", "[", "0", "]", ",", "\n", "results", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", "[", "[", "0", ",", "2", "]", "]", ".", "flatten", "(", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_gen_pannet_targets": [[11, 57], ["unittest.mock.patch", "mmocr.PANetTargets", "numpy.array", "textdet_targets.PANetTargets.generate_kernels", "print", "numpy.allclose", "textdet_targets.PANetTargets.generate_effective_mask", "numpy.array", "numpy.allclose", "numpy.zeros", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "textdet_targets.PANetTargets.", "mmocr.CustomFormatBundle", "cf_bundle.CustomFormatBundle.", "mock_show_feature.assert_called_once", "len", "len", "target_generator.keys", "target_generator.keys", "numpy.array", "numpy.array", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask"], ["@", "mock", ".", "patch", "(", "'%s.cf_bundle.show_feature'", "%", "__name__", ")", "\n", "def", "test_gen_pannet_targets", "(", "mock_show_feature", ")", ":", "\n", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "PANetTargets", "(", ")", "\n", "assert", "target_generator", ".", "max_shrink", "==", "20", "\n", "\n", "# test generate_kernels", "\n", "img_size", "=", "(", "3", ",", "10", ")", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "2", ",", "0", ",", "3", ",", "0", ",", "3", ",", "1", ",", "2", ",", "1", "]", ")", "]", "]", "\n", "shrink_ratio", "=", "1.0", "\n", "kernel", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "2", ",", "2", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "2", ",", "2", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "output", ",", "_", "=", "target_generator", ".", "generate_kernels", "(", "img_size", ",", "text_polys", ",", "\n", "shrink_ratio", ")", "\n", "print", "(", "output", ")", "\n", "assert", "np", ".", "allclose", "(", "output", ",", "kernel", ")", "\n", "\n", "# test generate_effective_mask", "\n", "polys_ignore", "=", "text_polys", "\n", "output", "=", "target_generator", ".", "generate_effective_mask", "(", "(", "3", ",", "10", ")", ",", "polys_ignore", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "output", ",", "target", ")", "\n", "\n", "# test generate_targets", "\n", "results", "=", "{", "}", "\n", "results", "[", "'img'", "]", "=", "np", ".", "zeros", "(", "(", "3", ",", "10", ",", "3", ")", ",", "np", ".", "uint8", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "3", ",", "10", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "3", ",", "10", ")", "\n", "results", "[", "'img_shape'", "]", "=", "(", "3", ",", "10", ",", "3", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "len", "(", "output", "[", "'gt_kernels'", "]", ")", "==", "2", "\n", "assert", "len", "(", "output", "[", "'gt_mask'", "]", ")", "==", "1", "\n", "\n", "bundle", "=", "cf_bundle", ".", "CustomFormatBundle", "(", "\n", "keys", "=", "[", "'gt_kernels'", ",", "'gt_mask'", "]", ",", "\n", "visualize", "=", "dict", "(", "flag", "=", "True", ",", "boundary_key", "=", "'gt_kernels'", ")", ")", "\n", "bundle", "(", "output", ")", "\n", "assert", "'gt_kernels'", "in", "output", ".", "keys", "(", ")", "\n", "assert", "'gt_mask'", "in", "output", ".", "keys", "(", ")", "\n", "mock_show_feature", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_gen_psenet_targets": [[59, 63], ["mmocr.PSENetTargets"], "function", ["None"], ["", "def", "test_gen_psenet_targets", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "PSENetTargets", "(", ")", "\n", "assert", "target_generator", ".", "max_shrink", "==", "20", "\n", "assert", "target_generator", ".", "shrink_ratio", "==", "(", "1.0", ",", "0.9", ",", "0.8", ",", "0.7", ",", "0.6", ",", "0.5", ",", "0.4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_dbnet_targets_find_invalid": [[68, 81], ["mmocr.DBNetTargets", "mmdet.core.PolygonMasks", "textdet_targets.DBNetTargets.find_invalid", "numpy.allclose", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.find_invalid"], ["", "def", "test_dbnet_targets_find_invalid", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DBNetTargets", "(", ")", "\n", "assert", "target_generator", ".", "shrink_ratio", "==", "0.4", "\n", "assert", "target_generator", ".", "thr_min", "==", "0.3", "\n", "assert", "target_generator", ".", "thr_max", "==", "0.7", "\n", "\n", "results", "=", "{", "}", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "10", ",", "0", ",", "10", ",", "10", ",", "0", ",", "10", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "20", ",", "0", ",", "30", ",", "0", ",", "30", ",", "10", ",", "20", ",", "10", "]", ")", "]", "]", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "40", ",", "40", ")", "\n", "\n", "ignore_tags", "=", "target_generator", ".", "find_invalid", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "ignore_tags", ",", "[", "False", ",", "False", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_dbnet_targets": [[83, 88], ["mmocr.DBNetTargets"], "function", ["None"], ["", "def", "test_dbnet_targets", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DBNetTargets", "(", ")", "\n", "assert", "target_generator", ".", "shrink_ratio", "==", "0.4", "\n", "assert", "target_generator", ".", "thr_min", "==", "0.3", "\n", "assert", "target_generator", ".", "thr_max", "==", "0.7", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_dbnet_ignore_texts": [[90, 110], ["mmocr.DBNetTargets", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "numpy.array", "numpy.array", "textdet_targets.DBNetTargets.ignore_texts", "numpy.allclose", "numpy.allclose", "numpy.array", "len", "len", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.ignore_texts"], ["", "def", "test_dbnet_ignore_texts", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DBNetTargets", "(", ")", "\n", "ignore_tags", "=", "[", "True", ",", "False", "]", "\n", "results", "=", "{", "}", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "10", ",", "0", ",", "10", ",", "10", ",", "0", ",", "10", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "20", ",", "0", ",", "30", ",", "0", ",", "30", ",", "10", ",", "20", ",", "10", "]", ")", "]", "]", "\n", "text_polys_ignore", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "15", ",", "0", ",", "15", ",", "10", ",", "0", ",", "10", "]", ")", "]", "]", "\n", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "text_polys_ignore", ",", "40", ",", "40", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "40", ",", "40", ")", "\n", "results", "[", "'gt_bboxes'", "]", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "[", "20", ",", "0", ",", "30", ",", "10", "]", "]", ")", "\n", "results", "[", "'gt_labels'", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "\n", "target_generator", ".", "ignore_texts", "(", "results", ",", "ignore_tags", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'gt_labels'", "]", ",", "np", ".", "array", "(", "[", "1", "]", ")", ")", "\n", "assert", "len", "(", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", ")", "==", "2", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'gt_masks_ignore'", "]", ".", "masks", "[", "1", "]", "[", "0", "]", ",", "\n", "text_polys", "[", "0", "]", "[", "0", "]", ")", "\n", "assert", "len", "(", "results", "[", "'gt_masks'", "]", ".", "masks", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_dbnet_generate_thr_map": [[112, 118], ["mmocr.DBNetTargets", "textdet_targets.DBNetTargets.generate_thr_map", "numpy.all", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.generate_thr_map"], ["", "def", "test_dbnet_generate_thr_map", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DBNetTargets", "(", ")", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "10", ",", "0", ",", "10", ",", "10", ",", "0", ",", "10", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "20", ",", "0", ",", "30", ",", "0", ",", "30", ",", "10", ",", "20", ",", "10", "]", ")", "]", "]", "\n", "thr_map", ",", "thr_mask", "=", "target_generator", ".", "generate_thr_map", "(", "(", "40", ",", "40", ")", ",", "text_polys", ")", "\n", "assert", "np", ".", "all", "(", "(", "thr_map", ">=", "0.29", ")", "*", "(", "thr_map", "<=", "0.71", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_dbnet_draw_border_map": [[120, 128], ["mmocr.DBNetTargets", "numpy.array", "numpy.zeros", "numpy.zeros", "textdet_targets.DBNetTargets.draw_border_map"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.draw_border_map"], ["", "def", "test_dbnet_draw_border_map", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DBNetTargets", "(", ")", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "20", ",", "21", "]", ",", "[", "-", "14", ",", "20", "]", ",", "[", "-", "11", ",", "30", "]", ",", "[", "-", "22", ",", "26", "]", "]", ")", "\n", "img_size", "=", "(", "40", ",", "40", ")", "\n", "thr_map", "=", "np", ".", "zeros", "(", "img_size", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "thr_mask", "=", "np", ".", "zeros", "(", "img_size", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "target_generator", ".", "draw_border_map", "(", "poly", ",", "thr_map", ",", "thr_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_dbnet_generate_targets": [[130, 149], ["mmocr.DBNetTargets", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "numpy.array", "numpy.array", "textdet_targets.DBNetTargets.generate_targets", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_targets"], ["", "def", "test_dbnet_generate_targets", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DBNetTargets", "(", ")", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "10", ",", "0", ",", "10", ",", "10", ",", "0", ",", "10", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "20", ",", "0", ",", "30", ",", "0", ",", "30", ",", "10", ",", "20", ",", "10", "]", ")", "]", "]", "\n", "text_polys_ignore", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "15", ",", "0", ",", "15", ",", "10", ",", "0", ",", "10", "]", ")", "]", "]", "\n", "\n", "results", "=", "{", "}", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "results", "[", "'img_shape'", "]", "=", "(", "40", ",", "40", ",", "3", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "text_polys_ignore", ",", "40", ",", "40", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "40", ",", "40", ")", "\n", "results", "[", "'gt_bboxes'", "]", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "[", "20", ",", "0", ",", "30", ",", "10", "]", "]", ")", "\n", "results", "[", "'gt_labels'", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "\n", "target_generator", ".", "generate_targets", "(", "results", ")", "\n", "assert", "'gt_shrink'", "in", "results", "[", "'mask_fields'", "]", "\n", "assert", "'gt_shrink_mask'", "in", "results", "[", "'mask_fields'", "]", "\n", "assert", "'gt_thr'", "in", "results", "[", "'mask_fields'", "]", "\n", "assert", "'gt_thr_mask'", "in", "results", "[", "'mask_fields'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_gen_textsnake_targets": [[151, 253], ["unittest.mock.patch", "mmocr.TextSnakeTargets", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "textdet_targets.TextSnakeTargets.vector_angle", "numpy.allclose", "numpy.array", "textdet_targets.TextSnakeTargets.find_head_tail", "numpy.allclose", "numpy.allclose", "numpy.array", "textdet_targets.TextSnakeTargets.find_head_tail", "numpy.allclose", "numpy.allclose", "numpy.array", "textdet_targets.TextSnakeTargets.find_head_tail", "numpy.allclose", "numpy.allclose", "numpy.array", "textdet_targets.TextSnakeTargets.resample_line", "numpy.allclose", "numpy.array", "textdet_targets.TextSnakeTargets.resample_line", "numpy.allclose", "textdet_targets.TextSnakeTargets.generate_text_region_mask", "numpy.array", "numpy.allclose", "textdet_targets.TextSnakeTargets.generate_center_mask_attrib_maps", "numpy.array", "numpy.allclose", "numpy.allclose", "numpy.allclose", "textdet_targets.TextSnakeTargets.generate_effective_mask", "numpy.array", "numpy.allclose", "numpy.zeros", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "textdet_targets.TextSnakeTargets.", "mmocr.CustomFormatBundle", "cf_bundle.CustomFormatBundle.", "mock_show_feature.assert_called_once", "numpy.array", "len", "numpy.array", "len", "numpy.array", "numpy.zeros", "len", "len", "len", "len", "len", "len", "target_generator.keys", "target_generator.keys", "target_generator.keys", "target_generator.keys", "target_generator.keys", "target_generator.keys", "numpy.array", "numpy.array", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.vector_angle", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.find_head_tail", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.find_head_tail", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.find_head_tail", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.resample_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.textsnake_targets.TextSnakeTargets.generate_text_region_mask", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.drrg_targets.DRRGTargets.generate_center_mask_attrib_maps", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_effective_mask"], ["", "@", "mock", ".", "patch", "(", "'%s.cf_bundle.show_feature'", "%", "__name__", ")", "\n", "def", "test_gen_textsnake_targets", "(", "mock_show_feature", ")", ":", "\n", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "TextSnakeTargets", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "orientation_thr", ",", "2.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "resample_step", ",", "4.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "center_region_shrink_ratio", ",", "0.3", ")", "\n", "\n", "# test vector_angle", "\n", "vec1", "=", "np", ".", "array", "(", "[", "[", "-", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", ")", "\n", "vec2", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", ")", "\n", "angles", "=", "target_generator", ".", "vector_angle", "(", "vec1", ",", "vec2", ")", "\n", "assert", "np", ".", "allclose", "(", "angles", ",", "np", ".", "array", "(", "[", "np", ".", "pi", ",", "0", "]", ")", ",", "atol", "=", "1e-3", ")", "\n", "\n", "# test find_head_tail for quadrangle", "\n", "polygon", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "5.0", ",", "1.0", "]", ",", "[", "5.0", ",", "3.0", "]", ",", "[", "1.0", ",", "3.0", "]", "]", ")", "\n", "head_inds", ",", "tail_inds", "=", "target_generator", ".", "find_head_tail", "(", "polygon", ",", "2.0", ")", "\n", "assert", "np", ".", "allclose", "(", "head_inds", ",", "[", "3", ",", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "tail_inds", ",", "[", "1", ",", "2", "]", ")", "\n", "polygon", "=", "np", ".", "array", "(", "[", "[", "1.0", ",", "1.0", "]", ",", "[", "1.0", ",", "3.0", "]", ",", "[", "5.0", ",", "3.0", "]", ",", "[", "5.0", ",", "1.0", "]", "]", ")", "\n", "head_inds", ",", "tail_inds", "=", "target_generator", ".", "find_head_tail", "(", "polygon", ",", "2.0", ")", "\n", "assert", "np", ".", "allclose", "(", "head_inds", ",", "[", "0", ",", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "tail_inds", ",", "[", "2", ",", "3", "]", ")", "\n", "\n", "# test find_head_tail for polygon", "\n", "polygon", "=", "np", ".", "array", "(", "[", "[", "0.", ",", "10.", "]", ",", "[", "3.", ",", "3.", "]", ",", "[", "10.", ",", "0.", "]", ",", "[", "17.", ",", "3.", "]", ",", "[", "20.", ",", "10.", "]", ",", "\n", "[", "15.", ",", "10.", "]", ",", "[", "13.5", ",", "6.5", "]", ",", "[", "10.", ",", "5.", "]", ",", "[", "6.5", ",", "6.5", "]", ",", "\n", "[", "5.", ",", "10.", "]", "]", ")", "\n", "head_inds", ",", "tail_inds", "=", "target_generator", ".", "find_head_tail", "(", "polygon", ",", "2.0", ")", "\n", "assert", "np", ".", "allclose", "(", "head_inds", ",", "[", "9", ",", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "tail_inds", ",", "[", "4", ",", "5", "]", ")", "\n", "\n", "# test resample_line", "\n", "line", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "3", "]", ",", "[", "0", ",", "4", "]", ",", "[", "0", ",", "7", "]", ",", "[", "0", ",", "8", "]", "]", ")", "\n", "resampled_line", "=", "target_generator", ".", "resample_line", "(", "line", ",", "3", ")", "\n", "assert", "len", "(", "resampled_line", ")", "==", "3", "\n", "assert", "np", ".", "allclose", "(", "resampled_line", ",", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "4", "]", ",", "[", "0", ",", "8", "]", "]", ")", ")", "\n", "line", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "resampled_line", "=", "target_generator", ".", "resample_line", "(", "line", ",", "4", ")", "\n", "assert", "len", "(", "resampled_line", ")", "==", "4", "\n", "assert", "np", ".", "allclose", "(", "resampled_line", ",", "\n", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", ")", "\n", "\n", "# test generate_text_region_mask", "\n", "img_size", "=", "(", "3", ",", "10", ")", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "2", ",", "0", ",", "3", ",", "0", ",", "3", ",", "1", ",", "2", ",", "1", "]", ")", "]", "]", "\n", "output", "=", "target_generator", ".", "generate_text_region_mask", "(", "img_size", ",", "text_polys", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "output", ",", "target", ")", "\n", "\n", "# test generate_center_region_mask", "\n", "target_generator", ".", "center_region_shrink_ratio", "=", "1.0", "\n", "(", "center_region_mask", ",", "radius_map", ",", "sin_map", ",", "\n", "cos_map", ")", "=", "target_generator", ".", "generate_center_mask_attrib_maps", "(", "\n", "img_size", ",", "text_polys", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "center_region_mask", ",", "target", ")", "\n", "assert", "np", ".", "allclose", "(", "sin_map", ",", "np", ".", "zeros", "(", "img_size", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "cos_map", ",", "target", ")", "\n", "\n", "# test generate_effective_mask", "\n", "polys_ignore", "=", "text_polys", "\n", "output", "=", "target_generator", ".", "generate_effective_mask", "(", "img_size", ",", "polys_ignore", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "output", ",", "target", ")", "\n", "\n", "# test generate_targets", "\n", "results", "=", "{", "}", "\n", "results", "[", "'img'", "]", "=", "np", ".", "zeros", "(", "(", "3", ",", "10", ",", "3", ")", ",", "np", ".", "uint8", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "3", ",", "10", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "3", ",", "10", ")", "\n", "results", "[", "'img_shape'", "]", "=", "(", "3", ",", "10", ",", "3", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "len", "(", "output", "[", "'gt_text_mask'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_center_region_mask'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_mask'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_radius_map'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_sin_map'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_cos_map'", "]", ")", "==", "1", "\n", "\n", "bundle", "=", "cf_bundle", ".", "CustomFormatBundle", "(", "\n", "keys", "=", "[", "\n", "'gt_text_mask'", ",", "'gt_center_region_mask'", ",", "'gt_mask'", ",", "\n", "'gt_radius_map'", ",", "'gt_sin_map'", ",", "'gt_cos_map'", "\n", "]", ",", "\n", "visualize", "=", "dict", "(", "flag", "=", "True", ",", "boundary_key", "=", "'gt_text_mask'", ")", ")", "\n", "bundle", "(", "output", ")", "\n", "assert", "'gt_text_mask'", "in", "output", ".", "keys", "(", ")", "\n", "assert", "'gt_center_region_mask'", "in", "output", ".", "keys", "(", ")", "\n", "assert", "'gt_mask'", "in", "output", ".", "keys", "(", ")", "\n", "assert", "'gt_radius_map'", "in", "output", ".", "keys", "(", ")", "\n", "assert", "'gt_sin_map'", "in", "output", ".", "keys", "(", ")", "\n", "assert", "'gt_cos_map'", "in", "output", ".", "keys", "(", ")", "\n", "mock_show_feature", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_fcenet_generate_targets": [[255, 277], ["mmocr.FCENetTargets", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "numpy.array", "numpy.array", "textdet_targets.FCENetTargets.generate_targets", "results.keys", "results.keys", "results.keys", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.fcenet_targets.FCENetTargets.generate_targets"], ["", "def", "test_fcenet_generate_targets", "(", ")", ":", "\n", "    ", "fourier_degree", "=", "5", "\n", "target_generator", "=", "textdet_targets", ".", "FCENetTargets", "(", "\n", "fourier_degree", "=", "fourier_degree", ")", "\n", "\n", "h", ",", "w", ",", "c", "=", "(", "64", ",", "64", ",", "3", ")", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "10", ",", "0", ",", "10", ",", "10", ",", "0", ",", "10", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "20", ",", "0", ",", "30", ",", "0", ",", "30", ",", "10", ",", "20", ",", "10", "]", ")", "]", "]", "\n", "text_polys_ignore", "=", "[", "[", "np", ".", "array", "(", "[", "0", ",", "0", ",", "15", ",", "0", ",", "15", ",", "10", ",", "0", ",", "10", "]", ")", "]", "]", "\n", "\n", "results", "=", "{", "}", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "results", "[", "'img_shape'", "]", "=", "(", "h", ",", "w", ",", "c", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "text_polys_ignore", ",", "h", ",", "w", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "h", ",", "w", ")", "\n", "results", "[", "'gt_bboxes'", "]", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "10", ",", "10", "]", ",", "[", "20", ",", "0", ",", "30", ",", "10", "]", "]", ")", "\n", "results", "[", "'gt_labels'", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "\n", "target_generator", ".", "generate_targets", "(", "results", ")", "\n", "assert", "'p3_maps'", "in", "results", ".", "keys", "(", ")", "\n", "assert", "'p4_maps'", "in", "results", ".", "keys", "(", ")", "\n", "assert", "'p5_maps'", "in", "results", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_textdet_targets.test_gen_drrg_targets": [[279, 368], ["mmocr.DRRGTargets", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "mmocr.DRRGTargets", "numpy.zeros", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "textdet_targets.DRRGTargets.", "mmocr.DRRGTargets", "textdet_targets.DRRGTargets.", "mmocr.DRRGTargets", "numpy.zeros", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "textdet_targets.DRRGTargets.", "mmocr.DRRGTargets", "mmdet.core.PolygonMasks", "textdet_targets.DRRGTargets.", "mmocr.DRRGTargets", "textdet_targets.DRRGTargets.", "len", "len", "len", "len", "len", "len", "len", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "test_gen_drrg_targets", "(", ")", ":", "\n", "    ", "target_generator", "=", "textdet_targets", ".", "DRRGTargets", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "orientation_thr", ",", "2.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "resample_step", ",", "8.0", ")", "\n", "assert", "target_generator", ".", "num_min_comps", "==", "9", "\n", "assert", "target_generator", ".", "num_max_comps", "==", "600", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "min_width", ",", "8.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "max_width", ",", "24.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "center_region_shrink_ratio", ",", "0.3", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "comp_shrink_ratio", ",", "1.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "comp_w_h_ratio", ",", "0.3", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "text_comp_nms_thr", ",", "0.25", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "min_rand_half_height", ",", "8.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "max_rand_half_height", ",", "24.0", ")", "\n", "assert", "np", ".", "allclose", "(", "target_generator", ".", "jitter_level", ",", "0.2", ")", "\n", "\n", "# test generate_targets", "\n", "target_generator", "=", "textdet_targets", ".", "DRRGTargets", "(", "\n", "min_width", "=", "2.", ",", "\n", "max_width", "=", "4.", ",", "\n", "min_rand_half_height", "=", "3.", ",", "\n", "max_rand_half_height", "=", "5.", ")", "\n", "\n", "results", "=", "{", "}", "\n", "results", "[", "'img'", "]", "=", "np", ".", "zeros", "(", "(", "64", ",", "64", ",", "3", ")", ",", "np", ".", "uint8", ")", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "4", ",", "2", ",", "30", ",", "2", ",", "30", ",", "10", ",", "4", ",", "10", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "36", ",", "12", ",", "8", ",", "12", ",", "8", ",", "22", ",", "36", ",", "22", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "48", ",", "20", ",", "52", ",", "20", ",", "52", ",", "50", ",", "48", ",", "50", "]", ")", "]", ",", "\n", "[", "np", ".", "array", "(", "[", "44", ",", "50", ",", "38", ",", "50", ",", "38", ",", "20", ",", "44", ",", "20", "]", ")", "]", "]", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "20", ",", "30", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "64", ",", "64", ")", "\n", "results", "[", "'img_shape'", "]", "=", "(", "64", ",", "64", ",", "3", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "len", "(", "output", "[", "'gt_text_mask'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_center_region_mask'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_mask'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_top_height_map'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_bot_height_map'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_sin_map'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_cos_map'", "]", ")", "==", "1", "\n", "assert", "output", "[", "'gt_comp_attribs'", "]", ".", "shape", "[", "-", "1", "]", "==", "8", "\n", "\n", "# test generate_targets with the number of proposed text components exceeds", "\n", "# num_max_comps", "\n", "target_generator", "=", "textdet_targets", ".", "DRRGTargets", "(", "\n", "min_width", "=", "2.", ",", "\n", "max_width", "=", "4.", ",", "\n", "min_rand_half_height", "=", "3.", ",", "\n", "max_rand_half_height", "=", "5.", ",", "\n", "num_max_comps", "=", "6", ")", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "output", "[", "'gt_comp_attribs'", "]", ".", "ndim", "==", "2", "\n", "assert", "output", "[", "'gt_comp_attribs'", "]", ".", "shape", "[", "0", "]", "==", "6", "\n", "\n", "# test generate_targets with blank polygon masks", "\n", "target_generator", "=", "textdet_targets", ".", "DRRGTargets", "(", "\n", "min_width", "=", "2.", ",", "\n", "max_width", "=", "4.", ",", "\n", "min_rand_half_height", "=", "3.", ",", "\n", "max_rand_half_height", "=", "5.", ")", "\n", "results", "=", "{", "}", "\n", "results", "[", "'img'", "]", "=", "np", ".", "zeros", "(", "(", "20", ",", "30", ",", "3", ")", ",", "np", ".", "uint8", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "20", ",", "30", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "20", ",", "30", ")", "\n", "results", "[", "'img_shape'", "]", "=", "(", "20", ",", "30", ",", "3", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "output", "[", "'gt_comp_attribs'", "]", "[", "0", ",", "0", "]", ">", "8", "\n", "\n", "# test generate_targets with one proposed text component", "\n", "text_polys", "=", "[", "[", "np", ".", "array", "(", "[", "13", ",", "6", ",", "17", ",", "6", ",", "17", ",", "14", ",", "13", ",", "14", "]", ")", "]", "]", "\n", "target_generator", "=", "textdet_targets", ".", "DRRGTargets", "(", "\n", "min_width", "=", "4.", ",", "\n", "max_width", "=", "8.", ",", "\n", "min_rand_half_height", "=", "3.", ",", "\n", "max_rand_half_height", "=", "5.", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "text_polys", ",", "20", ",", "30", ")", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "output", "[", "'gt_comp_attribs'", "]", "[", "0", ",", "0", "]", ">", "8", "\n", "\n", "# test generate_targets with shrunk margin in generate_rand_comp_attribs", "\n", "target_generator", "=", "textdet_targets", ".", "DRRGTargets", "(", "\n", "min_width", "=", "2.", ",", "\n", "max_width", "=", "30.", ",", "\n", "min_rand_half_height", "=", "3.", ",", "\n", "max_rand_half_height", "=", "30.", ")", "\n", "output", "=", "target_generator", "(", "results", ")", "\n", "assert", "output", "[", "'gt_comp_attribs'", "]", "[", "0", ",", "0", "]", ">", "8", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_random_crop_instances": [[14, 98], ["unittest.patch", "unittest.patch", "numpy.array", "mmocr.RandomCropInstances", "transforms.RandomCropInstances.sample_offset", "mmocr.RandomCropInstances", "transforms.RandomCropInstances.sample_offset", "mmocr.RandomCropInstances", "transforms.RandomCropInstances.sample_offset", "mmocr.RandomCropInstances", "transforms.RandomCropInstances.sample_offset", "transforms.RandomCropInstances.crop_img", "numpy.allclose", "numpy.allclose", "transforms.RandomCropInstances.crop_img", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "transforms.RandomCropInstances.crop_bboxes", "numpy.allclose", "numpy.array", "transforms.RandomCropInstances.crop_bboxes", "mmocr.RandomCropInstances", "mmdet.core.BitmapMasks", "np.array.copy", "transforms.RandomCropInstances.", "numpy.array", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "len", "np.array.copy"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.sample_offset", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.sample_offset", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.sample_offset", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.sample_offset", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.crop_bboxes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropInstances.crop_bboxes"], ["@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random_sample'", "%", "__name__", ")", "\n", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.randint'", "%", "__name__", ")", "\n", "def", "test_random_crop_instances", "(", "mock_randint", ",", "mock_sample", ")", ":", "\n", "\n", "    ", "img_gt", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "# test target is bigger than img size in sample_offset", "\n", "mock_sample", ".", "side_effect", "=", "[", "1", "]", "\n", "rci", "=", "transforms", ".", "RandomCropInstances", "(", "6", ",", "instance_key", "=", "'gt_kernels'", ")", "\n", "(", "i", ",", "j", ")", "=", "rci", ".", "sample_offset", "(", "img_gt", ",", "(", "5", ",", "5", ")", ")", "\n", "assert", "i", "==", "0", "\n", "assert", "j", "==", "0", "\n", "\n", "# test the second branch in sample_offset", "\n", "\n", "rci", "=", "transforms", ".", "RandomCropInstances", "(", "3", ",", "instance_key", "=", "'gt_kernels'", ")", "\n", "mock_sample", ".", "side_effect", "=", "[", "1", "]", "\n", "mock_randint", ".", "side_effect", "=", "[", "1", ",", "2", "]", "\n", "(", "i", ",", "j", ")", "=", "rci", ".", "sample_offset", "(", "img_gt", ",", "(", "5", ",", "5", ")", ")", "\n", "assert", "i", "==", "1", "\n", "assert", "j", "==", "2", "\n", "\n", "mock_sample", ".", "side_effect", "=", "[", "1", "]", "\n", "mock_randint", ".", "side_effect", "=", "[", "1", ",", "2", "]", "\n", "rci", "=", "transforms", ".", "RandomCropInstances", "(", "5", ",", "instance_key", "=", "'gt_kernels'", ")", "\n", "(", "i", ",", "j", ")", "=", "rci", ".", "sample_offset", "(", "img_gt", ",", "(", "5", ",", "5", ")", ")", "\n", "assert", "i", "==", "0", "\n", "assert", "j", "==", "0", "\n", "\n", "# test the first bracnh is sample_offset", "\n", "\n", "rci", "=", "transforms", ".", "RandomCropInstances", "(", "3", ",", "instance_key", "=", "'gt_kernels'", ")", "\n", "mock_sample", ".", "side_effect", "=", "[", "0.1", "]", "\n", "mock_randint", ".", "side_effect", "=", "[", "1", ",", "1", "]", "\n", "(", "i", ",", "j", ")", "=", "rci", ".", "sample_offset", "(", "img_gt", ",", "(", "5", ",", "5", ")", ")", "\n", "assert", "i", "==", "1", "\n", "assert", "j", "==", "1", "\n", "\n", "# test crop_img(img, offset, target_size)", "\n", "\n", "img", "=", "img_gt", "\n", "offset", "=", "[", "0", ",", "0", "]", "\n", "target", "=", "[", "6", ",", "6", "]", "\n", "crop", "=", "rci", ".", "crop_img", "(", "img", ",", "offset", ",", "target", ")", "\n", "assert", "np", ".", "allclose", "(", "img", ",", "crop", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "crop", "[", "1", "]", ",", "[", "0", ",", "0", ",", "5", ",", "5", "]", ")", "\n", "\n", "target", "=", "[", "3", ",", "2", "]", "\n", "crop", "=", "rci", ".", "crop_img", "(", "img", ",", "offset", ",", "target", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", ",", "crop", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "crop", "[", "1", "]", ",", "[", "0", ",", "0", ",", "2", ",", "3", "]", ")", "\n", "\n", "# test crop_bboxes", "\n", "canvas_box", "=", "np", ".", "array", "(", "[", "2", ",", "3", ",", "5", ",", "5", "]", ")", "\n", "bboxes", "=", "np", ".", "array", "(", "[", "[", "2", ",", "3", ",", "4", ",", "4", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", "]", ",", "[", "1", ",", "2", ",", "4", ",", "4", "]", ",", "\n", "[", "0", ",", "0", ",", "10", ",", "10", "]", "]", ")", "\n", "kept_bboxes", ",", "kept_idx", "=", "rci", ".", "crop_bboxes", "(", "bboxes", ",", "canvas_box", ")", "\n", "assert", "np", ".", "allclose", "(", "kept_bboxes", ",", "\n", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "2", ",", "1", "]", ",", "[", "0", ",", "0", ",", "3", ",", "2", "]", "]", ")", ")", "\n", "assert", "kept_idx", "==", "[", "0", ",", "2", ",", "3", "]", "\n", "\n", "bboxes", "=", "np", ".", "array", "(", "[", "[", "10", ",", "10", ",", "11", ",", "11", "]", ",", "[", "0", ",", "0", ",", "1", ",", "1", "]", "]", ")", "\n", "kept_bboxes", ",", "kept_idx", "=", "rci", ".", "crop_bboxes", "(", "bboxes", ",", "canvas_box", ")", "\n", "assert", "kept_bboxes", ".", "size", "==", "0", "\n", "assert", "kept_bboxes", ".", "shape", "==", "(", "0", ",", "4", ")", "\n", "assert", "len", "(", "kept_idx", ")", "==", "0", "\n", "\n", "# test __call__", "\n", "rci", "=", "transforms", ".", "RandomCropInstances", "(", "3", ",", "instance_key", "=", "'gt_kernels'", ")", "\n", "results", "=", "{", "}", "\n", "gt_kernels", "=", "[", "img_gt", ",", "img_gt", ".", "copy", "(", ")", "]", "\n", "results", "[", "'gt_kernels'", "]", "=", "BitmapMasks", "(", "gt_kernels", ",", "5", ",", "5", ")", "\n", "results", "[", "'img'", "]", "=", "img_gt", ".", "copy", "(", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_kernels'", "]", "\n", "mock_sample", ".", "side_effect", "=", "[", "0.1", "]", "\n", "mock_randint", ".", "side_effect", "=", "[", "1", ",", "1", "]", "\n", "output", "=", "rci", "(", "results", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "1", "]", "]", ")", "\n", "assert", "output", "[", "'img_shape'", "]", "==", "(", "3", ",", "3", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'img'", "]", ",", "target", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_kernels'", "]", ".", "masks", "[", "0", "]", ",", "target", ")", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_kernels'", "]", ".", "masks", "[", "1", "]", ",", "target", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_scale_aspect_jitter": [[100, 134], ["unittest.patch", "mmocr.ScaleAspectJitter", "transforms.ScaleAspectJitter.sample_from_range", "numpy.zeros", "transforms.ScaleAspectJitter._random_scale"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter.sample_from_range", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.ScaleAspectJitter._random_scale"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random_sample'", "%", "__name__", ")", "\n", "def", "test_scale_aspect_jitter", "(", "mock_random", ")", ":", "\n", "    ", "img_scale", "=", "[", "(", "3000", ",", "1000", ")", "]", "# unused", "\n", "ratio_range", "=", "(", "0.5", ",", "1.5", ")", "\n", "aspect_ratio_range", "=", "(", "1", ",", "1", ")", "\n", "multiscale_mode", "=", "'value'", "\n", "long_size_bound", "=", "2000", "\n", "short_size_bound", "=", "640", "\n", "resize_type", "=", "'long_short_bound'", "\n", "keep_ratio", "=", "False", "\n", "jitter", "=", "transforms", ".", "ScaleAspectJitter", "(", "\n", "img_scale", "=", "img_scale", ",", "\n", "ratio_range", "=", "ratio_range", ",", "\n", "aspect_ratio_range", "=", "aspect_ratio_range", ",", "\n", "multiscale_mode", "=", "multiscale_mode", ",", "\n", "long_size_bound", "=", "long_size_bound", ",", "\n", "short_size_bound", "=", "short_size_bound", ",", "\n", "resize_type", "=", "resize_type", ",", "\n", "keep_ratio", "=", "keep_ratio", ")", "\n", "mock_random", ".", "side_effect", "=", "[", "0.5", "]", "\n", "\n", "# test sample_from_range", "\n", "\n", "result", "=", "jitter", ".", "sample_from_range", "(", "[", "100", ",", "200", "]", ")", "\n", "assert", "result", "==", "150", "\n", "\n", "# test _random_scale", "\n", "results", "=", "{", "}", "\n", "results", "[", "'img'", "]", "=", "np", ".", "zeros", "(", "(", "4000", ",", "1000", ")", ")", "\n", "mock_random", ".", "side_effect", "=", "[", "0.5", ",", "1", "]", "\n", "jitter", ".", "_random_scale", "(", "results", ")", "\n", "# scale1 0.5\uff0c scale2=1 scale =0.5  650/1000, w, h", "\n", "# print(results['scale'])", "\n", "assert", "results", "[", "'scale'", "]", "==", "(", "650", ",", "2600", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_random_rotate": [[136, 152], ["unittest.patch", "numpy.random.rand", "np.random.rand.copy", "mmdet.core.BitmapMasks", "mmocr.RandomRotateTextDet", "transforms.RandomRotateTextDet.", "numpy.allclose", "numpy.allclose", "results[].copy"], "function", ["None"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random_sample'", "%", "__name__", ")", "\n", "def", "test_random_rotate", "(", "mock_random", ")", ":", "\n", "\n", "    ", "mock_random", ".", "side_effect", "=", "[", "0.5", ",", "0", "]", "\n", "results", "=", "{", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "results", "[", "'img'", "]", "=", "img", ".", "copy", "(", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'masks'", "]", "\n", "gt_kernels", "=", "[", "results", "[", "'img'", "]", ".", "copy", "(", ")", "]", "\n", "results", "[", "'masks'", "]", "=", "BitmapMasks", "(", "gt_kernels", ",", "5", ",", "5", ")", "\n", "\n", "rotater", "=", "transforms", ".", "RandomRotateTextDet", "(", ")", "\n", "\n", "results", "=", "rotater", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ",", "img", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'masks'", "]", ".", "masks", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_color_jitter": [[154, 165], ["numpy.ones", "torchvision.ColorJitter", "TF.ColorJitter.", "mmocr.ColorJitter", "transforms.ColorJitter.", "numpy.allclose"], "function", ["None"], ["", "def", "test_color_jitter", "(", ")", ":", "\n", "    ", "img", "=", "np", ".", "ones", "(", "(", "64", ",", "256", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "{", "'img'", ":", "img", "}", "\n", "\n", "pt_official_color_jitter", "=", "TF", ".", "ColorJitter", "(", ")", "\n", "output1", "=", "pt_official_color_jitter", "(", "img", ")", "\n", "\n", "color_jitter", "=", "transforms", ".", "ColorJitter", "(", ")", "\n", "output2", "=", "color_jitter", "(", "results", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "output1", ",", "output2", "[", "'img'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_affine_jitter": [[167, 184], ["numpy.ones", "torchvision.RandomAffine", "TF.RandomAffine.", "mmocr.AffineJitter", "transforms.AffineJitter.", "numpy.allclose", "PIL.Image.fromarray", "numpy.array"], "function", ["None"], ["", "def", "test_affine_jitter", "(", ")", ":", "\n", "    ", "img", "=", "np", ".", "ones", "(", "(", "64", ",", "256", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "{", "'img'", ":", "img", "}", "\n", "\n", "pt_official_affine_jitter", "=", "TF", ".", "RandomAffine", "(", "degrees", "=", "0", ")", "\n", "output1", "=", "pt_official_affine_jitter", "(", "Image", ".", "fromarray", "(", "img", ")", ")", "\n", "\n", "affine_jitter", "=", "transforms", ".", "AffineJitter", "(", "\n", "degrees", "=", "0", ",", "\n", "translate", "=", "None", ",", "\n", "scale", "=", "None", ",", "\n", "shear", "=", "None", ",", "\n", "resample", "=", "False", ",", "\n", "fillcolor", "=", "0", ")", "\n", "output2", "=", "affine_jitter", "(", "results", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "array", "(", "output1", ")", ",", "output2", "[", "'img'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_random_scale": [[186, 208], ["numpy.ones", "numpy.array", "mmdet.core.PolygonMasks", "mmocr.RandomScaling", "transforms.RandomScaling.", "numpy.allclose", "numpy.allclose"], "function", ["None"], ["", "def", "test_random_scale", "(", ")", ":", "\n", "    ", "h", ",", "w", ",", "c", "=", "100", ",", "100", ",", "3", "\n", "img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "c", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "{", "'img'", ":", "img", ",", "'img_shape'", ":", "(", "h", ",", "w", ",", "c", ")", "}", "\n", "\n", "polygon", "=", "np", ".", "array", "(", "[", "0.", ",", "0.", ",", "0.", ",", "10.", ",", "10.", ",", "10.", ",", "10.", ",", "0.", "]", ")", "\n", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "[", "[", "polygon", "]", "]", ",", "*", "(", "img", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "\n", "size", "=", "100", "\n", "scale", "=", "(", "2.", ",", "2.", ")", "\n", "random_scaler", "=", "transforms", ".", "RandomScaling", "(", "size", "=", "size", ",", "scale", "=", "scale", ")", "\n", "\n", "results", "=", "random_scaler", "(", "results", ")", "\n", "\n", "out_img", "=", "results", "[", "'img'", "]", "\n", "out_poly", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", "\n", "gt_poly", "=", "polygon", "*", "2", "\n", "\n", "assert", "np", ".", "allclose", "(", "out_img", ".", "shape", ",", "(", "2", "*", "h", ",", "2", "*", "w", ",", "c", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "out_poly", ",", "gt_poly", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_random_crop_flip": [[210, 254], ["unittest.patch", "numpy.ones", "numpy.array", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "mmocr.RandomCropFlip", "int", "int", "transforms.RandomCropFlip.generate_crop_target", "numpy.allclose", "numpy.allclose", "numpy.array", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "transforms.RandomCropFlip.", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropFlip.generate_crop_target"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.randint'", "%", "__name__", ")", "\n", "def", "test_random_crop_flip", "(", "mock_randint", ")", ":", "\n", "    ", "img", "=", "np", ".", "ones", "(", "(", "10", ",", "10", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "img", "[", "0", ",", "0", ",", ":", "]", "=", "0", "\n", "results", "=", "{", "'img'", ":", "img", ",", "'img_shape'", ":", "img", ".", "shape", "}", "\n", "\n", "polygon", "=", "np", ".", "array", "(", "[", "0.", ",", "0.", ",", "0.", ",", "10.", ",", "10.", ",", "10.", ",", "10.", ",", "0.", "]", ")", "\n", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "[", "[", "polygon", "]", "]", ",", "*", "(", "img", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "*", "(", "img", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", ",", "'gt_masks_ignore'", "]", "\n", "\n", "crop_ratio", "=", "1.1", "\n", "iter_num", "=", "3", "\n", "random_crop_fliper", "=", "transforms", ".", "RandomCropFlip", "(", "\n", "crop_ratio", "=", "crop_ratio", ",", "iter_num", "=", "iter_num", ")", "\n", "\n", "# test crop_target", "\n", "pad_ratio", "=", "0.1", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "pad_h", "=", "int", "(", "h", "*", "pad_ratio", ")", "\n", "pad_w", "=", "int", "(", "w", "*", "pad_ratio", ")", "\n", "all_polys", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "\n", "h_axis", ",", "w_axis", "=", "random_crop_fliper", ".", "generate_crop_target", "(", "\n", "img", ",", "all_polys", ",", "pad_h", ",", "pad_w", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "h_axis", ",", "(", "0", ",", "11", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "w_axis", ",", "(", "0", ",", "11", ")", ")", "\n", "\n", "# test __call__", "\n", "polygon", "=", "np", ".", "array", "(", "[", "1.", ",", "1.", ",", "1.", ",", "9.", ",", "9.", ",", "9.", ",", "9.", ",", "1.", "]", ")", "\n", "results", "[", "'gt_masks'", "]", "=", "PolygonMasks", "(", "[", "[", "polygon", "]", "]", ",", "*", "(", "img", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "[", "polygon", "]", "]", ",", "*", "(", "img", ".", "shape", "[", ":", "2", "]", ")", ")", "\n", "\n", "mock_randint", ".", "side_effect", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "results", "=", "random_crop_fliper", "(", "results", ")", "\n", "\n", "out_img", "=", "results", "[", "'img'", "]", "\n", "out_poly", "=", "results", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", "\n", "gt_img", "=", "img", "\n", "gt_poly", "=", "polygon", "\n", "\n", "assert", "np", ".", "allclose", "(", "out_img", ",", "gt_img", ")", "\n", "assert", "np", ".", "allclose", "(", "out_poly", ",", "gt_poly", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_random_crop_poly_instances": [[256, 299], ["unittest.patch", "unittest.patch", "numpy.zeros", "mmdet.core.PolygonMasks", "mmdet.core.PolygonMasks", "mmocr.RandomCropPolyInstances", "transforms.RandomCropPolyInstances.sample_crop_box", "numpy.allclose", "transforms.RandomCropPolyInstances.", "numpy.array", "numpy.allclose", "mmocr.RandomCropPolyInstances", "transforms.RandomCropPolyInstances.", "numpy.allclose", "numpy.allclose", "numpy.array", "numpy.array", "len", "len", "len", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.transforms.RandomCropPolyInstances.sample_crop_box"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random_sample'", "%", "__name__", ")", "\n", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.randint'", "%", "__name__", ")", "\n", "def", "test_random_crop_poly_instances", "(", "mock_randint", ",", "mock_sample", ")", ":", "\n", "    ", "results", "=", "{", "}", "\n", "img", "=", "np", ".", "zeros", "(", "(", "30", ",", "30", ",", "3", ")", ")", "\n", "poly_masks", "=", "PolygonMasks", "(", "[", "[", "\n", "np", ".", "array", "(", "[", "5.", ",", "5.", ",", "25.", ",", "5.", ",", "25.", ",", "10.", ",", "5.", ",", "10.", "]", ")", "\n", "]", ",", "[", "np", ".", "array", "(", "[", "5.", ",", "20.", ",", "25.", ",", "20.", ",", "25.", ",", "25.", ",", "5.", ",", "25.", "]", ")", "]", "]", ",", "30", ",", "30", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'gt_masks'", "]", "=", "poly_masks", "\n", "results", "[", "'gt_masks_ignore'", "]", "=", "PolygonMasks", "(", "[", "]", ",", "30", ",", "30", ")", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", ",", "'gt_masks_ignore'", "]", "\n", "results", "[", "'gt_labels'", "]", "=", "[", "1", ",", "1", "]", "\n", "rcpi", "=", "transforms", ".", "RandomCropPolyInstances", "(", "\n", "instance_key", "=", "'gt_masks'", ",", "crop_ratio", "=", "1.0", ",", "min_side_ratio", "=", "0.3", ")", "\n", "\n", "# test sample_crop_box(img_size, results)", "\n", "mock_randint", ".", "side_effect", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "30", ",", "0", ",", "0", ",", "0", ",", "15", "]", "\n", "crop_box", "=", "rcpi", ".", "sample_crop_box", "(", "(", "30", ",", "30", ")", ",", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "array", "(", "crop_box", ")", ",", "np", ".", "array", "(", "[", "0", ",", "0", ",", "30", ",", "15", "]", ")", ")", "\n", "\n", "# test __call__", "\n", "mock_randint", ".", "side_effect", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "30", ",", "0", ",", "15", ",", "0", ",", "30", "]", "\n", "mock_sample", ".", "side_effect", "=", "[", "0.1", "]", "\n", "output", "=", "rcpi", "(", "results", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "5.", ",", "5.", ",", "25.", ",", "5.", ",", "25.", ",", "10.", ",", "5.", ",", "10.", "]", ")", "\n", "assert", "len", "(", "output", "[", "'gt_masks'", "]", ")", "==", "1", "\n", "assert", "len", "(", "output", "[", "'gt_masks_ignore'", "]", ")", "==", "0", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", ",", "target", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "==", "(", "15", ",", "30", ",", "3", ")", "\n", "\n", "# test __call__ with blank instace_key masks", "\n", "mock_randint", ".", "side_effect", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "30", ",", "0", ",", "15", ",", "0", ",", "30", "]", "\n", "mock_sample", ".", "side_effect", "=", "[", "0.1", "]", "\n", "rcpi", "=", "transforms", ".", "RandomCropPolyInstances", "(", "\n", "instance_key", "=", "'gt_masks_ignore'", ",", "crop_ratio", "=", "1.0", ",", "min_side_ratio", "=", "0.3", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'gt_masks'", "]", "=", "poly_masks", "\n", "output", "=", "rcpi", "(", "results", ")", "\n", "assert", "len", "(", "output", "[", "'gt_masks'", "]", ")", "==", "2", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", ",", "poly_masks", ".", "masks", "[", "0", "]", "[", "0", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks'", "]", ".", "masks", "[", "1", "]", "[", "0", "]", ",", "poly_masks", ".", "masks", "[", "1", "]", "[", "0", "]", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "==", "(", "30", ",", "30", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_random_rotate_poly_instances": [[301, 317], ["unittest.patch", "numpy.zeros", "mmdet.core.PolygonMasks", "mmocr.RandomRotatePolyInstances", "transforms.RandomRotatePolyInstances.", "numpy.allclose", "numpy.array", "numpy.array"], "function", ["None"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random_sample'", "%", "__name__", ")", "\n", "def", "test_random_rotate_poly_instances", "(", "mock_sample", ")", ":", "\n", "    ", "results", "=", "{", "}", "\n", "img", "=", "np", ".", "zeros", "(", "(", "30", ",", "30", ",", "3", ")", ")", "\n", "poly_masks", "=", "PolygonMasks", "(", "\n", "[", "[", "np", ".", "array", "(", "[", "10.", ",", "10.", ",", "20.", ",", "10.", ",", "20.", ",", "20.", ",", "10.", ",", "20.", "]", ")", "]", "]", ",", "30", ",", "30", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'gt_masks'", "]", "=", "poly_masks", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "rrpi", "=", "transforms", ".", "RandomRotatePolyInstances", "(", "rotate_ratio", "=", "1.0", ",", "max_angle", "=", "90", ")", "\n", "\n", "mock_sample", ".", "side_effect", "=", "[", "0.", ",", "1.", "]", "\n", "output", "=", "rrpi", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", ",", "\n", "np", ".", "array", "(", "[", "10.", ",", "20.", ",", "10.", ",", "10.", ",", "20.", ",", "10.", ",", "20.", ",", "20.", "]", ")", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "==", "(", "30", ",", "30", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_square_resize_pad": [[319, 348], ["unittest.patch", "numpy.zeros", "numpy.array", "mmdet.core.PolygonMasks", "mmocr.SquareResizePad", "transforms.SquareResizePad.", "numpy.allclose", "transforms.SquareResizePad.", "np.array.copy", "numpy.allclose"], "function", ["None"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random_sample'", "%", "__name__", ")", "\n", "def", "test_square_resize_pad", "(", "mock_sample", ")", ":", "\n", "    ", "results", "=", "{", "}", "\n", "img", "=", "np", ".", "zeros", "(", "(", "15", ",", "30", ",", "3", ")", ")", "\n", "polygon", "=", "np", ".", "array", "(", "[", "10.", ",", "5.", ",", "20.", ",", "5.", ",", "20.", ",", "10.", ",", "10.", ",", "10.", "]", ")", "\n", "poly_masks", "=", "PolygonMasks", "(", "[", "[", "polygon", "]", "]", ",", "15", ",", "30", ")", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'gt_masks'", "]", "=", "poly_masks", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "'gt_masks'", "]", "\n", "srp", "=", "transforms", ".", "SquareResizePad", "(", "target_size", "=", "40", ",", "pad_ratio", "=", "0.5", ")", "\n", "\n", "# test resize with padding", "\n", "mock_sample", ".", "side_effect", "=", "[", "0.", "]", "\n", "output", "=", "srp", "(", "results", ")", "\n", "target", "=", "4.", "/", "3", "*", "polygon", "\n", "target", "[", "1", ":", ":", "2", "]", "+=", "10.", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", ",", "target", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "==", "(", "40", ",", "40", ",", "3", ")", "\n", "\n", "# test resize to square without padding", "\n", "results", "[", "'img'", "]", "=", "img", "\n", "results", "[", "'gt_masks'", "]", "=", "poly_masks", "\n", "mock_sample", ".", "side_effect", "=", "[", "1.", "]", "\n", "output", "=", "srp", "(", "results", ")", "\n", "target", "=", "polygon", ".", "copy", "(", ")", "\n", "target", "[", ":", ":", "2", "]", "*=", "4.", "/", "3", "\n", "target", "[", "1", ":", ":", "2", "]", "*=", "8.", "/", "3", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks'", "]", ".", "masks", "[", "0", "]", "[", "0", "]", ",", "target", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "==", "(", "40", ",", "40", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transforms.test_pyramid_rescale": [[350, 374], ["numpy.random.randint", "mmocr.PyramidRescale", "transforms.PyramidRescale.", "mmocr.PyramidRescale", "transforms.PyramidRescale.", "numpy.all", "copy.deepcopy", "pytest.raises", "mmocr.PyramidRescale", "pytest.raises", "mmocr.PyramidRescale", "pytest.raises", "mmocr.PyramidRescale", "pytest.raises", "mmocr.PyramidRescale", "pytest.raises", "transforms.PyramidRescale.", "copy.deepcopy"], "function", ["None"], ["", "def", "test_pyramid_rescale", "(", ")", ":", "\n", "    ", "img", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ",", "size", "=", "(", "128", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "x", "=", "{", "'img'", ":", "copy", ".", "deepcopy", "(", "img", ")", "}", "\n", "f", "=", "transforms", ".", "PyramidRescale", "(", ")", "\n", "results", "=", "f", "(", "x", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ",", "3", ")", "\n", "\n", "# Test invalid inputs", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transforms", ".", "PyramidRescale", "(", "base_shape", "=", "(", "128", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transforms", ".", "PyramidRescale", "(", "base_shape", "=", "128", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transforms", ".", "PyramidRescale", "(", "factor", "=", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "transforms", ".", "PyramidRescale", "(", "randomize_factor", "=", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "f", "(", "{", "}", ")", "\n", "\n", "# Test factor = 0", "\n", "", "f_derandomized", "=", "transforms", ".", "PyramidRescale", "(", "\n", "factor", "=", "0", ",", "randomize_factor", "=", "False", ")", "\n", "results", "=", "f_derandomized", "(", "{", "'img'", ":", "copy", ".", "deepcopy", "(", "img", ")", "}", ")", "\n", "assert", "np", ".", "all", "(", "results", "[", "'img'", "]", "==", "img", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_base_dataset._create_dummy_ann_file": [[11, 18], ["open", "fw.write"], "function", ["None"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "'sample1.jpg hello'", "\n", "ann_info2", "=", "'sample2.jpg world'", "\n", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "ann_info", "in", "[", "ann_info1", ",", "ann_info2", "]", ":", "\n", "            ", "fw", ".", "write", "(", "ann_info", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_base_dataset._create_dummy_loader": [[20, 26], ["dict", "dict"], "function", ["None"], ["", "", "", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "type", "=", "'LineStrParser'", ",", "keys", "=", "[", "'file_name'", ",", "'text'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_base_dataset.test_custom_dataset": [[28, 76], ["tempfile.TemporaryDirectory", "os.join", "test_base_dataset._create_dummy_ann_file", "test_base_dataset._create_dummy_loader", "tempfile.TemporaryDirectory.cleanup", "mmocr.datasets.base_dataset.BaseDataset", "numpy.allclose", "mmocr.datasets.base_dataset.BaseDataset.format_results", "len", "len", "mmocr.datasets.base_dataset.BaseDataset.prepare_train_img", "mmocr.datasets.base_dataset.BaseDataset.prepare_test_img", "mmocr.datasets.base_dataset.BaseDataset._get_next_index", "pytest.raises", "mmocr.datasets.base_dataset.BaseDataset.evaluate", "expect_results.items"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.format_results", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset.prepare_test_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.base_dataset.BaseDataset._get_next_index", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "test_custom_dataset", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "\n", "for", "mode", "in", "[", "True", ",", "False", "]", ":", "\n", "        ", "dataset", "=", "BaseDataset", "(", "ann_file", ",", "loader", ",", "pipeline", "=", "[", "]", ",", "test_mode", "=", "mode", ")", "\n", "\n", "# test len", "\n", "assert", "len", "(", "dataset", ")", "==", "len", "(", "dataset", ".", "data_infos", ")", "\n", "\n", "# test set group flag", "\n", "assert", "np", ".", "allclose", "(", "dataset", ".", "flag", ",", "[", "0", ",", "0", "]", ")", "\n", "\n", "# test prepare_train_img", "\n", "expect_results", "=", "{", "\n", "'img_info'", ":", "{", "\n", "'file_name'", ":", "'sample1.jpg'", ",", "\n", "'text'", ":", "'hello'", "\n", "}", ",", "\n", "'img_prefix'", ":", "''", "\n", "}", "\n", "assert", "dataset", ".", "prepare_train_img", "(", "0", ")", "==", "expect_results", "\n", "\n", "# test prepare_test_img", "\n", "assert", "dataset", ".", "prepare_test_img", "(", "0", ")", "==", "expect_results", "\n", "\n", "# test __getitem__", "\n", "assert", "dataset", "[", "0", "]", "==", "expect_results", "\n", "\n", "# test get_next_index", "\n", "assert", "dataset", ".", "_get_next_index", "(", "0", ")", "==", "1", "\n", "\n", "# test format_resuls", "\n", "expect_results_copy", "=", "{", "\n", "key", ":", "value", "\n", "for", "key", ",", "value", "in", "expect_results", ".", "items", "(", ")", "\n", "}", "\n", "dataset", ".", "format_results", "(", "expect_results", ")", "\n", "assert", "expect_results_copy", "==", "expect_results", "\n", "\n", "# test evaluate", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "            ", "dataset", ".", "evaluate", "(", "expect_results", ")", "\n", "\n", "", "", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_kie_dataset._create_dummy_ann_file": [[13, 48], ["open", "fw.write", "json.dumps"], "function", ["None"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "{", "\n", "'file_name'", ":", "\n", "'sample1.png'", ",", "\n", "'height'", ":", "\n", "200", ",", "\n", "'width'", ":", "\n", "200", ",", "\n", "'annotations'", ":", "[", "{", "\n", "'text'", ":", "'store'", ",", "\n", "'box'", ":", "[", "11.0", ",", "0.0", ",", "22.0", ",", "0.0", ",", "12.0", ",", "12.0", ",", "0.0", ",", "12.0", "]", ",", "\n", "'label'", ":", "1", "\n", "}", ",", "{", "\n", "'text'", ":", "'address'", ",", "\n", "'box'", ":", "[", "23.0", ",", "2.0", ",", "31.0", ",", "1.0", ",", "24.0", ",", "11.0", ",", "16.0", ",", "11.0", "]", ",", "\n", "'label'", ":", "1", "\n", "}", ",", "{", "\n", "'text'", ":", "'price'", ",", "\n", "'box'", ":", "[", "33.0", ",", "2.0", ",", "43.0", ",", "2.0", ",", "36.0", ",", "12.0", ",", "25.0", ",", "12.0", "]", ",", "\n", "'label'", ":", "1", "\n", "}", ",", "{", "\n", "'text'", ":", "'1.0'", ",", "\n", "'box'", ":", "[", "46.0", ",", "2.0", ",", "61.0", ",", "2.0", ",", "53.0", ",", "12.0", ",", "39.0", ",", "12.0", "]", ",", "\n", "'label'", ":", "1", "\n", "}", ",", "{", "\n", "'text'", ":", "'google'", ",", "\n", "'box'", ":", "[", "61.0", ",", "2.0", ",", "69.0", ",", "2.0", ",", "63.0", ",", "12.0", ",", "55.0", ",", "12.0", "]", ",", "\n", "'label'", ":", "1", "\n", "}", "]", "\n", "}", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "ann_info", "in", "[", "ann_info1", "]", ":", "\n", "            ", "fw", ".", "write", "(", "json", ".", "dumps", "(", "ann_info", ")", "+", "'\\n'", ")", "\n", "\n", "", "", "return", "ann_info1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_kie_dataset._create_dummy_dict_file": [[50, 57], ["open", "list", "fw.write"], "function", ["None"], ["", "def", "_create_dummy_dict_file", "(", "dict_file", ")", ":", "\n", "    ", "dict_str", "=", "'0123'", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "char", "in", "list", "(", "dict_str", ")", ":", "\n", "            ", "fw", ".", "write", "(", "char", "+", "'\\n'", ")", "\n", "\n", "", "", "return", "dict_str", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_kie_dataset._create_dummy_loader": [[59, 67], ["dict", "dict"], "function", ["None"], ["", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "\n", "type", "=", "'LineJsonParser'", ",", "\n", "keys", "=", "[", "'file_name'", ",", "'height'", ",", "'width'", ",", "'annotations'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_kie_dataset.test_kie_dataset": [[69, 126], ["tempfile.TemporaryDirectory", "os.join", "test_kie_dataset._create_dummy_ann_file", "os.join", "test_kie_dataset._create_dummy_dict_file", "test_kie_dataset._create_dummy_loader", "mmocr.datasets.kie_dataset.KIEDataset", "tempfile.TemporaryDirectory.cleanup", "mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "dict", "mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "torch.full", "print", "mmocr.datasets.kie_dataset.KIEDataset.evaluate", "math.isclose", "pytest.raises", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "pytest.raises", "mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "result[].size", "range"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info"], ["", "def", "test_kie_dataset", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "ann_info1", "=", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_dict.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "# test initialization", "\n", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "dataset", "=", "KIEDataset", "(", "ann_file", ",", "loader", ",", "dict_file", ",", "pipeline", "=", "[", "]", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n", "dataset", ".", "prepare_train_img", "(", "0", ")", "\n", "\n", "# test pre_pipeline", "\n", "img_ann_info", "=", "dataset", ".", "data_infos", "[", "0", "]", "\n", "img_info", "=", "{", "\n", "'filename'", ":", "img_ann_info", "[", "'file_name'", "]", ",", "\n", "'height'", ":", "img_ann_info", "[", "'height'", "]", ",", "\n", "'width'", ":", "img_ann_info", "[", "'width'", "]", "\n", "}", "\n", "ann_info", "=", "dataset", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ",", "ann_info", "=", "ann_info", ")", "\n", "dataset", ".", "pre_pipeline", "(", "results", ")", "\n", "assert", "results", "[", "'img_prefix'", "]", "==", "dataset", ".", "img_prefix", "\n", "\n", "# test _parse_anno_info", "\n", "annos", "=", "ann_info1", "[", "'annotations'", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dataset", ".", "_parse_anno_info", "(", "annos", "[", "0", "]", ")", "\n", "", "tmp_annos", "=", "[", "{", "\n", "'text'", ":", "'store'", ",", "\n", "'box'", ":", "[", "11.0", ",", "0.0", ",", "22.0", ",", "0.0", ",", "12.0", ",", "12.0", ",", "0.0", ",", "12.0", "]", "\n", "}", "]", "\n", "dataset", ".", "_parse_anno_info", "(", "tmp_annos", ")", "\n", "tmp_annos", "=", "[", "{", "'text'", ":", "'store'", "}", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dataset", ".", "_parse_anno_info", "(", "tmp_annos", ")", "\n", "\n", "", "return_anno", "=", "dataset", ".", "_parse_anno_info", "(", "annos", ")", "\n", "assert", "'bboxes'", "in", "return_anno", "\n", "assert", "'relations'", "in", "return_anno", "\n", "assert", "'texts'", "in", "return_anno", "\n", "assert", "'labels'", "in", "return_anno", "\n", "\n", "# test evaluation", "\n", "result", "=", "{", "}", "\n", "result", "[", "'nodes'", "]", "=", "torch", ".", "full", "(", "(", "5", ",", "5", ")", ",", "1", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "result", "[", "'nodes'", "]", "[", ":", ",", "1", "]", "=", "100.", "\n", "print", "(", "'hello'", ",", "result", "[", "'nodes'", "]", ".", "size", "(", ")", ")", "\n", "results", "=", "[", "result", "for", "_", "in", "range", "(", "5", ")", "]", "\n", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "results", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'macro_f1'", "]", ",", "0.2", ",", "abs_tol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_resize_ocr": [[13, 33], ["numpy.ones", "mmocr.ResizeOCR", "transforms.ResizeOCR.", "numpy.allclose", "numpy.allclose", "math.isclose", "math.isclose", "mmocr.ResizeOCR", "transforms.ResizeOCR.", "math.isclose", "numpy.sum"], "function", ["None"], ["def", "test_resize_ocr", "(", ")", ":", "\n", "    ", "input_img", "=", "np", ".", "ones", "(", "(", "64", ",", "256", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "rci", "=", "transforms", ".", "ResizeOCR", "(", "\n", "32", ",", "min_width", "=", "32", ",", "max_width", "=", "160", ",", "keep_aspect_ratio", "=", "True", ")", "\n", "results", "=", "{", "'img_shape'", ":", "input_img", ".", "shape", ",", "'img'", ":", "input_img", "}", "\n", "\n", "# test call", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "[", "32", ",", "160", ",", "3", "]", ",", "results", "[", "'pad_shape'", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "[", "32", ",", "160", ",", "3", "]", ",", "results", "[", "'img'", "]", ".", "shape", ")", "\n", "assert", "'valid_ratio'", "in", "results", "\n", "assert", "math", ".", "isclose", "(", "results", "[", "'valid_ratio'", "]", ",", "0.8", ")", "\n", "assert", "math", ".", "isclose", "(", "np", ".", "sum", "(", "results", "[", "'img'", "]", "[", ":", ",", "129", ":", ",", ":", "]", ")", ",", "0", ")", "\n", "\n", "rci", "=", "transforms", ".", "ResizeOCR", "(", "\n", "32", ",", "min_width", "=", "32", ",", "max_width", "=", "160", ",", "keep_aspect_ratio", "=", "False", ")", "\n", "results", "=", "{", "'img_shape'", ":", "input_img", ".", "shape", ",", "'img'", ":", "input_img", "}", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "math", ".", "isclose", "(", "results", "[", "'valid_ratio'", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_to_tensor": [[35, 45], ["numpy.ones", "torchvision.to_tensor", "mmocr.ToTensorOCR", "transforms.ToTensorOCR.", "numpy.allclose", "results[].numpy", "TF.to_tensor.numpy"], "function", ["None"], ["", "def", "test_to_tensor", "(", ")", ":", "\n", "    ", "input_img", "=", "np", ".", "ones", "(", "(", "64", ",", "256", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "expect_output", "=", "TF", ".", "to_tensor", "(", "input_img", ")", "\n", "rci", "=", "transforms", ".", "ToTensorOCR", "(", ")", "\n", "\n", "results", "=", "{", "'img'", ":", "input_img", "}", "\n", "results", "=", "rci", "(", "results", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ".", "numpy", "(", ")", ",", "expect_output", ".", "numpy", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_normalize": [[47, 57], ["torch.zeros", "mmocr.NormalizeOCR", "transforms.NormalizeOCR.", "numpy.allclose", "torch.ones_like", "results[].numpy", "expect_output.numpy"], "function", ["None"], ["", "def", "test_normalize", "(", ")", ":", "\n", "    ", "inputs", "=", "torch", ".", "zeros", "(", "3", ",", "10", ",", "10", ")", "\n", "\n", "expect_output", "=", "torch", ".", "ones_like", "(", "inputs", ")", "*", "(", "-", "1", ")", "\n", "rci", "=", "transforms", ".", "NormalizeOCR", "(", "mean", "=", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "std", "=", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", "\n", "\n", "results", "=", "{", "'img'", ":", "inputs", "}", "\n", "results", "=", "rci", "(", "results", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ".", "numpy", "(", ")", ",", "expect_output", ".", "numpy", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_online_crop": [[59, 97], ["unittest.patch", "dict", "numpy.ones", "mmocr.OnlineCropOCR", "transforms.OnlineCropOCR.", "numpy.allclose", "transforms.OnlineCropOCR.", "numpy.allclose"], "function", ["None"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.random'", "%", "__name__", ")", "\n", "def", "test_online_crop", "(", "mock_random", ")", ":", "\n", "    ", "kwargs", "=", "dict", "(", "\n", "box_keys", "=", "[", "'x1'", ",", "'y1'", ",", "'x2'", ",", "'y2'", ",", "'x3'", ",", "'y3'", ",", "'x4'", ",", "'y4'", "]", ",", "\n", "jitter_prob", "=", "0.5", ",", "\n", "max_jitter_ratio_x", "=", "0.05", ",", "\n", "max_jitter_ratio_y", "=", "0.02", ")", "\n", "\n", "mock_random", ".", "side_effect", "=", "[", "0.1", ",", "1", ",", "1", ",", "1", "]", "\n", "\n", "src_img", "=", "np", ".", "ones", "(", "(", "100", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "{", "\n", "'img'", ":", "src_img", ",", "\n", "'img_info'", ":", "{", "\n", "'x1'", ":", "'20'", ",", "\n", "'y1'", ":", "'20'", ",", "\n", "'x2'", ":", "'40'", ",", "\n", "'y2'", ":", "'20'", ",", "\n", "'x3'", ":", "'40'", ",", "\n", "'y3'", ":", "'40'", ",", "\n", "'x4'", ":", "'20'", ",", "\n", "'y4'", ":", "'40'", "\n", "}", "\n", "}", "\n", "\n", "rci", "=", "transforms", ".", "OnlineCropOCR", "(", "**", "kwargs", ")", "\n", "\n", "results", "=", "rci", "(", "results", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img_shape'", "]", ",", "[", "20", ",", "20", ",", "3", "]", ")", "\n", "\n", "# test not crop", "\n", "mock_random", ".", "side_effect", "=", "[", "0.1", ",", "1", ",", "1", ",", "1", "]", "\n", "results", "[", "'img_info'", "]", "=", "{", "}", "\n", "results", "[", "'img'", "]", "=", "src_img", "\n", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ".", "shape", ",", "[", "100", ",", "100", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_fancy_pca": [[99, 108], ["torch.rand", "mmocr.FancyPCA", "transforms.FancyPCA.", "torch.Size"], "function", ["None"], ["", "def", "test_fancy_pca", "(", ")", ":", "\n", "    ", "input_tensor", "=", "torch", ".", "rand", "(", "3", ",", "32", ",", "100", ")", "\n", "\n", "rci", "=", "transforms", ".", "FancyPCA", "(", ")", "\n", "\n", "results", "=", "{", "'img'", ":", "input_tensor", "}", "\n", "results", "=", "rci", "(", "results", ")", "\n", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "3", ",", "32", ",", "100", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_random_padding": [[110, 124], ["unittest.patch", "dict", "numpy.ones", "mmocr.RandomPaddingOCR", "transforms.RandomPaddingOCR.", "print", "numpy.allclose"], "function", ["None"], ["", "@", "mock", ".", "patch", "(", "'%s.transforms.np.random.uniform'", "%", "__name__", ")", "\n", "def", "test_random_padding", "(", "mock_random", ")", ":", "\n", "    ", "kwargs", "=", "dict", "(", "max_ratio", "=", "[", "0.0", ",", "0.0", ",", "0.0", ",", "0.0", "]", ",", "box_type", "=", "None", ")", "\n", "\n", "mock_random", ".", "side_effect", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", "\n", "\n", "src_img", "=", "np", ".", "ones", "(", "(", "32", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "{", "'img'", ":", "src_img", ",", "'img_shape'", ":", "(", "32", ",", "100", ",", "3", ")", "}", "\n", "\n", "rci", "=", "transforms", ".", "RandomPaddingOCR", "(", "**", "kwargs", ")", "\n", "\n", "results", "=", "rci", "(", "results", ")", "\n", "print", "(", "results", "[", "'img'", "]", ".", "shape", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img_shape'", "]", ",", "[", "96", ",", "300", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_opencv2pil": [[126, 133], ["numpy.ones", "mmocr.OpencvToPil", "transforms.OpencvToPil.", "numpy.allclose"], "function", ["None"], ["", "def", "test_opencv2pil", "(", ")", ":", "\n", "    ", "src_img", "=", "np", ".", "ones", "(", "(", "32", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "{", "'img'", ":", "src_img", "}", "\n", "rci", "=", "transforms", ".", "OpencvToPil", "(", ")", "\n", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ".", "size", ",", "(", "100", ",", "32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_transforms.test_pil2opencv": [[135, 142], ["PIL.Image.new", "mmocr.PilToOpencv", "transforms.PilToOpencv.", "numpy.allclose"], "function", ["None"], ["", "def", "test_pil2opencv", "(", ")", ":", "\n", "    ", "src_img", "=", "Image", ".", "new", "(", "'RGB'", ",", "(", "100", ",", "32", ")", ",", "color", "=", "(", "255", ",", "255", ",", "255", ")", ")", "\n", "results", "=", "{", "'img'", ":", "src_img", "}", "\n", "rci", "=", "transforms", ".", "PilToOpencv", "(", ")", "\n", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'img'", "]", ".", "shape", ",", "(", "32", ",", "100", ",", "3", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_seg_dataset._create_dummy_ann_file": [[12, 64], ["open", "fw.write", "json.dumps"], "function", ["None"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "{", "\n", "'file_name'", ":", "\n", "'sample1.png'", ",", "\n", "'annotations'", ":", "[", "{", "\n", "'char_text'", ":", "\n", "'F'", ",", "\n", "'char_box'", ":", "[", "11.0", ",", "0.0", ",", "22.0", ",", "0.0", ",", "12.0", ",", "12.0", ",", "0.0", ",", "12.0", "]", "\n", "}", ",", "{", "\n", "'char_text'", ":", "\n", "'r'", ",", "\n", "'char_box'", ":", "[", "23.0", ",", "2.0", ",", "31.0", ",", "1.0", ",", "24.0", ",", "11.0", ",", "16.0", ",", "11.0", "]", "\n", "}", ",", "{", "\n", "'char_text'", ":", "\n", "'o'", ",", "\n", "'char_box'", ":", "[", "33.0", ",", "2.0", ",", "43.0", ",", "2.0", ",", "36.0", ",", "12.0", ",", "25.0", ",", "12.0", "]", "\n", "}", ",", "{", "\n", "'char_text'", ":", "\n", "'m'", ",", "\n", "'char_box'", ":", "[", "46.0", ",", "2.0", ",", "61.0", ",", "2.0", ",", "53.0", ",", "12.0", ",", "39.0", ",", "12.0", "]", "\n", "}", ",", "{", "\n", "'char_text'", ":", "\n", "':'", ",", "\n", "'char_box'", ":", "[", "61.0", ",", "2.0", ",", "69.0", ",", "2.0", ",", "63.0", ",", "12.0", ",", "55.0", ",", "12.0", "]", "\n", "}", "]", ",", "\n", "'text'", ":", "\n", "'From:'", "\n", "}", "\n", "ann_info2", "=", "{", "\n", "'file_name'", ":", "\n", "'sample2.png'", ",", "\n", "'annotations'", ":", "[", "{", "\n", "'char_text'", ":", "'o'", ",", "\n", "'char_box'", ":", "[", "0.0", ",", "5.0", ",", "7.0", ",", "5.0", ",", "9.0", ",", "15.0", ",", "2.0", ",", "15.0", "]", "\n", "}", ",", "{", "\n", "'char_text'", ":", "\n", "'u'", ",", "\n", "'char_box'", ":", "[", "7.0", ",", "4.0", ",", "14.0", ",", "4.0", ",", "18.0", ",", "18.0", ",", "11.0", ",", "18.0", "]", "\n", "}", ",", "{", "\n", "'char_text'", ":", "\n", "'t'", ",", "\n", "'char_box'", ":", "[", "13.0", ",", "1.0", ",", "19.0", ",", "2.0", ",", "24.0", ",", "18.0", ",", "17.0", ",", "18.0", "]", "\n", "}", "]", ",", "\n", "'text'", ":", "\n", "'out'", "\n", "}", "\n", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "ann_info", "in", "[", "ann_info1", ",", "ann_info2", "]", ":", "\n", "            ", "fw", ".", "write", "(", "json", ".", "dumps", "(", "ann_info", ")", "+", "'\\n'", ")", "\n", "\n", "", "", "return", "ann_info1", ",", "ann_info2", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_seg_dataset._create_dummy_loader": [[66, 73], ["dict", "dict"], "function", ["None"], ["", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "\n", "type", "=", "'LineJsonParser'", ",", "keys", "=", "[", "'file_name'", ",", "'text'", ",", "'annotations'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_seg_dataset.test_ocr_seg_dataset": [[75, 129], ["tempfile.TemporaryDirectory", "os.join", "test_ocr_seg_dataset._create_dummy_ann_file", "test_ocr_seg_dataset._create_dummy_loader", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset", "tempfile.TemporaryDirectory.cleanup", "dict", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset.pre_pipeline", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset._parse_anno_info", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset.prepare_train_img", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset.evaluate", "math.isclose", "math.isclose", "math.isclose", "pytest.raises", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset._parse_anno_info", "pytest.raises", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset._parse_anno_info", "pytest.raises", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset._parse_anno_info", "pytest.raises", "mmocr.datasets.ocr_seg_dataset.OCRSegDataset._parse_anno_info", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info"], ["", "def", "test_ocr_seg_dataset", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "ann_info1", ",", "ann_info2", "=", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "\n", "# test initialization", "\n", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "dataset", "=", "OCRSegDataset", "(", "ann_file", ",", "loader", ",", "pipeline", "=", "[", "]", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n", "# test pre_pipeline", "\n", "img_info", "=", "dataset", ".", "data_infos", "[", "0", "]", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ")", "\n", "dataset", ".", "pre_pipeline", "(", "results", ")", "\n", "assert", "results", "[", "'img_prefix'", "]", "==", "dataset", ".", "img_prefix", "\n", "\n", "# test _parse_anno_info", "\n", "annos", "=", "ann_info1", "[", "'annotations'", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dataset", ".", "_parse_anno_info", "(", "annos", "[", "0", "]", ")", "\n", "", "annos2", "=", "ann_info2", "[", "'annotations'", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dataset", ".", "_parse_anno_info", "(", "[", "{", "'char_text'", ":", "'i'", "}", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dataset", ".", "_parse_anno_info", "(", "[", "{", "'char_box'", ":", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", "}", "]", ")", "\n", "", "annos2", "[", "0", "]", "[", "'char_box'", "]", "=", "[", "1", ",", "2", ",", "3", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "dataset", ".", "_parse_anno_info", "(", "annos2", ")", "\n", "\n", "", "return_anno", "=", "dataset", ".", "_parse_anno_info", "(", "annos", ")", "\n", "assert", "return_anno", "[", "'chars'", "]", "==", "[", "'F'", ",", "'r'", ",", "'o'", ",", "'m'", ",", "':'", "]", "\n", "assert", "len", "(", "return_anno", "[", "'char_rects'", "]", ")", "==", "5", "\n", "\n", "# test prepare_train_img", "\n", "expect_results", "=", "{", "\n", "'img_info'", ":", "{", "\n", "'filename'", ":", "'sample1.png'", "\n", "}", ",", "\n", "'img_prefix'", ":", "''", ",", "\n", "'ann_info'", ":", "return_anno", "\n", "}", "\n", "data", "=", "dataset", ".", "prepare_train_img", "(", "0", ")", "\n", "assert", "data", "==", "expect_results", "\n", "\n", "# test evluation", "\n", "metric", "=", "'acc'", "\n", "results", "=", "[", "{", "'text'", ":", "'From:'", "}", ",", "{", "'text'", ":", "'ou'", "}", "]", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "results", ",", "metric", ")", "\n", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'word_acc'", "]", ",", "0.5", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'char_precision'", "]", ",", "1.0", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'char_recall'", "]", ",", "0.857", ",", "abs_tol", "=", "1e-4", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_detect_dataset._create_dummy_ann_file": [[11, 36], ["open", "fw.write", "json.dumps"], "function", ["None"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "{", "\n", "'file_name'", ":", "\n", "'sample1.jpg'", ",", "\n", "'height'", ":", "\n", "640", ",", "\n", "'width'", ":", "\n", "640", ",", "\n", "'annotations'", ":", "[", "{", "\n", "'iscrowd'", ":", "0", ",", "\n", "'category_id'", ":", "1", ",", "\n", "'bbox'", ":", "[", "50", ",", "70", ",", "80", ",", "100", "]", ",", "\n", "'segmentation'", ":", "[", "[", "50", ",", "70", ",", "80", ",", "70", ",", "80", ",", "100", ",", "50", ",", "100", "]", "]", "\n", "}", ",", "{", "\n", "'iscrowd'", ":", "\n", "1", ",", "\n", "'category_id'", ":", "\n", "1", ",", "\n", "'bbox'", ":", "[", "120", ",", "140", ",", "200", ",", "200", "]", ",", "\n", "'segmentation'", ":", "[", "[", "120", ",", "140", ",", "200", ",", "140", ",", "200", ",", "200", ",", "120", ",", "200", "]", "]", "\n", "}", "]", "\n", "}", "\n", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "json", ".", "dumps", "(", "ann_info1", ")", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_detect_dataset._create_dummy_loader": [[38, 46], ["dict", "dict"], "function", ["None"], ["", "", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "\n", "type", "=", "'LineJsonParser'", ",", "\n", "keys", "=", "[", "'file_name'", ",", "'height'", ",", "'width'", ",", "'annotations'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_detect_dataset.test_detect_dataset": [[48, 85], ["tempfile.TemporaryDirectory", "os.join", "test_detect_dataset._create_dummy_ann_file", "test_detect_dataset._create_dummy_loader", "mmocr.datasets.text_det_dataset.TextDetDataset", "mmocr.datasets.text_det_dataset.TextDetDataset._parse_anno_info", "print", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "tempfile.TemporaryDirectory.cleanup", "mmocr.datasets.text_det_dataset.TextDetDataset.prepare_train_img", "numpy.allclose", "numpy.allclose", "numpy.allclose", "mmocr.datasets.text_det_dataset.TextDetDataset.evaluate"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "test_detect_dataset", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "\n", "# test initialization", "\n", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "dataset", "=", "TextDetDataset", "(", "ann_file", ",", "loader", ",", "pipeline", "=", "[", "]", ")", "\n", "\n", "# test _parse_ann_info", "\n", "img_ann_info", "=", "dataset", ".", "data_infos", "[", "0", "]", "\n", "ann", "=", "dataset", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "print", "(", "ann", "[", "'bboxes'", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'bboxes'", "]", ",", "[", "[", "50.", ",", "70.", ",", "80.", ",", "100.", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'labels'", "]", ",", "[", "1", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'bboxes_ignore'", "]", ",", "[", "[", "120", ",", "140", ",", "200", ",", "200", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'masks'", "]", ",", "[", "[", "[", "50", ",", "70", ",", "80", ",", "70", ",", "80", ",", "100", ",", "50", ",", "100", "]", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "ann", "[", "'masks_ignore'", "]", ",", "\n", "[", "[", "[", "120", ",", "140", ",", "200", ",", "140", ",", "200", ",", "200", ",", "120", ",", "200", "]", "]", "]", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n", "# test prepare_train_img", "\n", "pipeline_results", "=", "dataset", ".", "prepare_train_img", "(", "0", ")", "\n", "assert", "np", ".", "allclose", "(", "pipeline_results", "[", "'bbox_fields'", "]", ",", "[", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "pipeline_results", "[", "'mask_fields'", "]", ",", "[", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "pipeline_results", "[", "'seg_fields'", "]", ",", "[", "]", ")", "\n", "expect_img_info", "=", "{", "'filename'", ":", "'sample1.jpg'", ",", "'height'", ":", "640", ",", "'width'", ":", "640", "}", "\n", "assert", "pipeline_results", "[", "'img_info'", "]", "==", "expect_img_info", "\n", "\n", "# test evluation", "\n", "metrics", "=", "'hmean-iou'", "\n", "results", "=", "[", "{", "'boundary_result'", ":", "[", "[", "50", ",", "70", ",", "80", ",", "70", ",", "80", ",", "100", ",", "50", ",", "100", ",", "1", "]", "]", "}", "]", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "results", ",", "metrics", ")", "\n", "\n", "assert", "eval_res", "[", "'hmean-iou:hmean'", "]", "==", "1", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loading._create_dummy_ann": [[9, 25], ["None"], "function", ["None"], ["def", "_create_dummy_ann", "(", ")", ":", "\n", "    ", "results", "=", "{", "}", "\n", "results", "[", "'img_info'", "]", "=", "{", "}", "\n", "results", "[", "'img_info'", "]", "[", "'height'", "]", "=", "1000", "\n", "results", "[", "'img_info'", "]", "[", "'width'", "]", "=", "1000", "\n", "results", "[", "'ann_info'", "]", "=", "{", "}", "\n", "results", "[", "'ann_info'", "]", "[", "'masks'", "]", "=", "[", "]", "\n", "results", "[", "'mask_fields'", "]", "=", "[", "]", "\n", "results", "[", "'ann_info'", "]", "[", "'masks_ignore'", "]", "=", "[", "\n", "[", "[", "499", ",", "94", ",", "531", ",", "94", ",", "531", ",", "124", ",", "499", ",", "124", "]", "]", ",", "\n", "[", "[", "3", ",", "156", ",", "81", ",", "155", ",", "78", ",", "181", ",", "0", ",", "182", "]", "]", ",", "\n", "[", "[", "11", ",", "223", ",", "59", ",", "221", ",", "59", ",", "234", ",", "11", ",", "236", "]", "]", ",", "\n", "[", "[", "500", ",", "156", ",", "551", ",", "156", ",", "550", ",", "165", ",", "499", ",", "165", "]", "]", "\n", "]", "\n", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loading.test_loadtextannotation": [[27, 67], ["test_loading._create_dummy_ann", "mmocr.datasets.pipelines.LoadTextAnnotations", "copy.deepcopy", "mmocr.datasets.pipelines.LoadTextAnnotations._load_masks", "numpy.allclose", "mmocr.datasets.pipelines.LoadTextAnnotations", "copy.deepcopy", "mmocr.datasets.pipelines.LoadTextAnnotations._load_masks", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loading._create_dummy_ann", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations._load_masks", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.loading.LoadTextAnnotations._load_masks"], ["", "def", "test_loadtextannotation", "(", ")", ":", "\n", "\n", "    ", "results", "=", "_create_dummy_ann", "(", ")", "\n", "with_bbox", "=", "True", "\n", "with_label", "=", "True", "\n", "with_mask", "=", "True", "\n", "with_seg", "=", "False", "\n", "poly2mask", "=", "False", "\n", "\n", "# If no 'ori_shape' in result but use_img_shape=True,", "\n", "# result['img_info']['height'] and result['img_info']['width']", "\n", "# will be used to generate mask.", "\n", "loader", "=", "LoadTextAnnotations", "(", "\n", "with_bbox", ",", "\n", "with_label", ",", "\n", "with_mask", ",", "\n", "with_seg", ",", "\n", "poly2mask", ",", "\n", "use_img_shape", "=", "True", ")", "\n", "tmp_results", "=", "copy", ".", "deepcopy", "(", "results", ")", "\n", "output", "=", "loader", ".", "_load_masks", "(", "tmp_results", ")", "\n", "assert", "len", "(", "output", "[", "'gt_masks_ignore'", "]", ")", "==", "4", "\n", "assert", "np", ".", "allclose", "(", "output", "[", "'gt_masks_ignore'", "]", ".", "masks", "[", "0", "]", ",", "\n", "[", "[", "499", ",", "94", ",", "531", ",", "94", ",", "531", ",", "124", ",", "499", ",", "124", "]", "]", ")", "\n", "assert", "output", "[", "'gt_masks_ignore'", "]", ".", "height", "==", "results", "[", "'img_info'", "]", "[", "'height'", "]", "\n", "\n", "# If 'ori_shape' in result and use_img_shape=True,", "\n", "# result['ori_shape'] will be used to generate mask.", "\n", "loader", "=", "LoadTextAnnotations", "(", "\n", "with_bbox", ",", "\n", "with_label", ",", "\n", "with_mask", ",", "\n", "with_seg", ",", "\n", "poly2mask", "=", "True", ",", "\n", "use_img_shape", "=", "True", ")", "\n", "tmp_results", "=", "copy", ".", "deepcopy", "(", "results", ")", "\n", "tmp_results", "[", "'ori_shape'", "]", "=", "(", "640", ",", "640", ",", "3", ")", "\n", "output", "=", "loader", ".", "_load_masks", "(", "tmp_results", ")", "\n", "assert", "output", "[", "'img_info'", "]", "[", "'height'", "]", "==", "640", "\n", "assert", "output", "[", "'gt_masks_ignore'", "]", ".", "height", "==", "640", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loading.test_load_img_from_numpy": [[69, 87], ["mmocr.datasets.pipelines.LoadImageFromNdarray", "mmocr.datasets.pipelines.LoadImageFromNdarray.", "mmocr.datasets.pipelines.LoadImageFromNdarray", "mmocr.datasets.pipelines.LoadImageFromNdarray.", "mmocr.datasets.pipelines.LoadImageFromNdarray", "mmocr.datasets.pipelines.LoadImageFromNdarray.", "numpy.ones", "len", "numpy.ones", "numpy.ones"], "function", ["None"], ["", "def", "test_load_img_from_numpy", "(", ")", ":", "\n", "    ", "result", "=", "{", "'img'", ":", "np", ".", "ones", "(", "(", "32", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "}", "\n", "\n", "load", "=", "LoadImageFromNdarray", "(", "color_type", "=", "'color'", ")", "\n", "output", "=", "load", "(", "result", ")", "\n", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "[", "2", "]", "==", "3", "\n", "assert", "len", "(", "output", "[", "'img'", "]", ".", "shape", ")", "==", "3", "\n", "\n", "result", "=", "{", "'img'", ":", "np", ".", "ones", "(", "(", "32", ",", "100", ",", "1", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "}", "\n", "load", "=", "LoadImageFromNdarray", "(", "color_type", "=", "'color'", ")", "\n", "output", "=", "load", "(", "result", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "[", "2", "]", "==", "3", "\n", "\n", "result", "=", "{", "'img'", ":", "np", ".", "ones", "(", "(", "32", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "}", "\n", "load", "=", "LoadImageFromNdarray", "(", "color_type", "=", "'grayscale'", ",", "to_float32", "=", "True", ")", "\n", "output", "=", "load", "(", "result", ")", "\n", "assert", "output", "[", "'img'", "]", ".", "shape", "[", "2", "]", "==", "1", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_parser.test_line_str_parser": [[9, 34], ["mmocr.datasets.utils.parser.LineStrParser", "pytest.raises", "mmocr.datasets.utils.parser.LineStrParser", "pytest.raises", "mmocr.datasets.utils.parser.LineStrParser", "pytest.raises", "mmocr.datasets.utils.parser.LineStrParser", "mmocr.datasets.utils.parser.LineStrParser.get_item", "pytest.raises", "mmocr.datasets.utils.parser.LineStrParser", "mmocr.datasets.utils.parser.LineStrParser.get_item"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.get_item", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.get_item"], ["def", "test_line_str_parser", "(", ")", ":", "\n", "    ", "data_ret", "=", "[", "'sample1.jpg hello\\n'", ",", "'sample2.jpg world'", "]", "\n", "keys", "=", "[", "'filename'", ",", "'text'", "]", "\n", "keys_idx", "=", "[", "0", ",", "1", "]", "\n", "separator", "=", "' '", "\n", "\n", "# test init", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "parser", "=", "LineStrParser", "(", "'filename'", ",", "keys_idx", ",", "separator", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "parser", "=", "LineStrParser", "(", "keys", ",", "keys_idx", ",", "[", "' '", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "parser", "=", "LineStrParser", "(", "keys", ",", "[", "0", "]", ",", "separator", ")", "\n", "\n", "# test get_item", "\n", "", "parser", "=", "LineStrParser", "(", "keys", ",", "keys_idx", ",", "separator", ")", "\n", "assert", "parser", ".", "get_item", "(", "data_ret", ",", "0", ")", "==", "{", "\n", "'filename'", ":", "'sample1.jpg'", ",", "\n", "'text'", ":", "'hello'", "\n", "}", "\n", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "        ", "parser", "=", "LineStrParser", "(", "[", "'filename'", ",", "'text'", ",", "'ignore'", "]", ",", "[", "0", ",", "1", ",", "2", "]", ",", "\n", "separator", ")", "\n", "parser", ".", "get_item", "(", "data_ret", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_parser.test_line_dict_parser": [[36, 65], ["mmocr.datasets.utils.parser.LineJsonParser", "json.dumps", "json.dumps", "pytest.raises", "mmocr.datasets.utils.parser.LineJsonParser", "pytest.raises", "mmocr.datasets.utils.parser.LineJsonParser", "mmocr.datasets.utils.parser.LineJsonParser.get_item", "pytest.raises", "mmocr.datasets.utils.parser.LineJsonParser", "mmocr.datasets.utils.parser.LineJsonParser.get_item"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.get_item", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.parser.LineJsonParser.get_item"], ["", "", "def", "test_line_dict_parser", "(", ")", ":", "\n", "    ", "data_ret", "=", "[", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "'sample1.jpg'", ",", "\n", "'text'", ":", "'hello'", "\n", "}", ")", ",", "\n", "json", ".", "dumps", "(", "{", "\n", "'filename'", ":", "'sample2.jpg'", ",", "\n", "'text'", ":", "'world'", "\n", "}", ")", "\n", "]", "\n", "keys", "=", "[", "'filename'", ",", "'text'", "]", "\n", "\n", "# test init", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "parser", "=", "LineJsonParser", "(", "'filename'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "parser", "=", "LineJsonParser", "(", "[", "]", ")", "\n", "\n", "# test get_item", "\n", "", "parser", "=", "LineJsonParser", "(", "keys", ")", "\n", "assert", "parser", ".", "get_item", "(", "data_ret", ",", "0", ")", "==", "{", "\n", "'filename'", ":", "'sample1.jpg'", ",", "\n", "'text'", ":", "'hello'", "\n", "}", "\n", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "        ", "parser", "=", "LineJsonParser", "(", "[", "'img_name'", ",", "'text'", "]", ")", "\n", "parser", ".", "get_item", "(", "data_ret", ",", "0", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transform_wrappers.test_torchvision_wrapper": [[13, 26], ["mmocr.datasets.pipelines.TorchVisionWrapper", "mmocr.datasets.pipelines.TorchVisionWrapper.", "numpy.ones", "pytest.raises", "mmocr.datasets.pipelines.TorchVisionWrapper", "pytest.raises", "mmocr.datasets.pipelines.TorchVisionWrapper", "pytest.raises", "mmocr.datasets.pipelines.TorchVisionWrapper."], "function", ["None"], ["def", "test_torchvision_wrapper", "(", ")", ":", "\n", "    ", "x", "=", "{", "'img'", ":", "np", ".", "ones", "(", "(", "128", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "}", "\n", "# object not found error", "\n", "with", "pytest", ".", "raises", "(", "Exception", ")", ":", "\n", "        ", "TorchVisionWrapper", "(", "op", "=", "'NonExist'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "TypeError", ")", ":", "\n", "        ", "TorchVisionWrapper", "(", ")", "\n", "", "f", "=", "TorchVisionWrapper", "(", "'Grayscale'", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "f", "(", "{", "}", ")", "\n", "", "results", "=", "f", "(", "x", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ")", "\n", "assert", "results", "[", "'img_shape'", "]", "==", "(", "128", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transform_wrappers.test_oneof": [[28, 56], ["unittest.patch", "dict", "dict", "mmocr.datasets.pipelines.OneOfWrapper", "mmocr.datasets.pipelines.OneOfWrapper.", "mmocr.datasets.pipelines.OneOfWrapper.", "mmocr.datasets.pipelines.OneOfWrapper", "mmocr.datasets.pipelines.OneOfWrapper.", "numpy.random.randint", "pytest.raises", "mmocr.datasets.pipelines.OneOfWrapper", "pytest.raises", "mmocr.datasets.pipelines.OneOfWrapper", "pytest.raises", "mmocr.datasets.pipelines.OneOfWrapper", "mmocr.datasets.pipelines.transforms.ColorJitter"], "function", ["None"], ["", "@", "mock", ".", "patch", "(", "'random.choice'", ")", "\n", "def", "test_oneof", "(", "rand_choice", ")", ":", "\n", "    ", "color_jitter", "=", "dict", "(", "type", "=", "'TorchVisionWrapper'", ",", "op", "=", "'ColorJitter'", ")", "\n", "gray_scale", "=", "dict", "(", "type", "=", "'TorchVisionWrapper'", ",", "op", "=", "'Grayscale'", ")", "\n", "x", "=", "{", "'img'", ":", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ",", "size", "=", "(", "128", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "}", "\n", "f", "=", "OneOfWrapper", "(", "[", "color_jitter", ",", "gray_scale", "]", ")", "\n", "# Use color_jitter at the first call", "\n", "rand_choice", ".", "side_effect", "=", "lambda", "x", ":", "x", "[", "0", "]", "\n", "results", "=", "f", "(", "x", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ",", "3", ")", "\n", "# Use gray_scale at the second call", "\n", "rand_choice", ".", "side_effect", "=", "lambda", "x", ":", "x", "[", "1", "]", "\n", "results", "=", "f", "(", "x", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ")", "\n", "\n", "# Passing object", "\n", "f", "=", "OneOfWrapper", "(", "[", "ColorJitter", "(", ")", ",", "gray_scale", "]", ")", "\n", "# Use color_jitter at the first call", "\n", "results", "=", "f", "(", "x", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ")", "\n", "\n", "# Test invalid inputs", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "f", "=", "OneOfWrapper", "(", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "f", "=", "OneOfWrapper", "(", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "f", "=", "OneOfWrapper", "(", "{", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_transform_wrappers.test_runwithprob": [[58, 67], ["unittest.patch", "mmocr.datasets.pipelines.RandomWrapper", "numpy.random.randint", "mmocr.datasets.pipelines.RandomWrapper.", "mmocr.datasets.pipelines.RandomWrapper.", "dict", "copy.deepcopy", "copy.deepcopy"], "function", ["None"], ["", "", "@", "mock", ".", "patch", "(", "'numpy.random.uniform'", ")", "\n", "def", "test_runwithprob", "(", "np_random_uniform", ")", ":", "\n", "    ", "np_random_uniform", ".", "side_effect", "=", "[", "0.1", ",", "0.9", "]", "\n", "f", "=", "RandomWrapper", "(", "[", "dict", "(", "type", "=", "'TorchVisionWrapper'", ",", "op", "=", "'Grayscale'", ")", "]", ",", "0.5", ")", "\n", "img", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "256", ",", "size", "=", "(", "128", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "results", "=", "f", "(", "{", "'img'", ":", "copy", ".", "deepcopy", "(", "img", ")", "}", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ")", "\n", "results", "=", "f", "(", "{", "'img'", ":", "copy", ".", "deepcopy", "(", "img", ")", "}", ")", "\n", "assert", "results", "[", "'img'", "]", ".", "shape", "==", "(", "128", ",", "100", ",", "3", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_uniform_concat_dataset.test_uniform_concat_dataset_pipeline": [[11, 64], ["dict", "copy.deepcopy", "copy.deepcopy", "mmocr.datasets.UniformConcatDataset", "copy.deepcopy", "mmocr.datasets.UniformConcatDataset", "copy.deepcopy", "mmocr.datasets.UniformConcatDataset", "copy.deepcopy", "copy.deepcopy", "mmocr.datasets.UniformConcatDataset", "dict", "dict", "dict", "len", "len", "len", "len", "len", "len", "len", "len", "len", "dict", "dict.items", "len", "mmocr.utils.list_from_file", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["def", "test_uniform_concat_dataset_pipeline", "(", ")", ":", "\n", "    ", "pipeline1", "=", "[", "dict", "(", "type", "=", "'LoadImageFromFile'", ")", "]", "\n", "pipeline2", "=", "[", "dict", "(", "type", "=", "'LoadImageFromFile'", ")", ",", "dict", "(", "type", "=", "'ColorJitter'", ")", "]", "\n", "\n", "img_prefix", "=", "'tests/data/ocr_toy_dataset/imgs'", "\n", "ann_file", "=", "'tests/data/ocr_toy_dataset/label.txt'", "\n", "train1", "=", "dict", "(", "\n", "type", "=", "'OCRDataset'", ",", "\n", "img_prefix", "=", "img_prefix", ",", "\n", "ann_file", "=", "ann_file", ",", "\n", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "\n", "type", "=", "'LineStrParser'", ",", "\n", "keys", "=", "[", "'filename'", ",", "'text'", "]", ",", "\n", "keys_idx", "=", "[", "0", ",", "1", "]", ",", "\n", "separator", "=", "' '", ")", ")", ",", "\n", "pipeline", "=", "None", ",", "\n", "test_mode", "=", "False", ")", "\n", "\n", "train2", "=", "{", "key", ":", "value", "for", "key", ",", "value", "in", "train1", ".", "items", "(", ")", "}", "\n", "train2", "[", "'pipeline'", "]", "=", "pipeline2", "\n", "\n", "# pipeline is 1d list", "\n", "copy_train1", "=", "copy", ".", "deepcopy", "(", "train1", ")", "\n", "copy_train2", "=", "copy", ".", "deepcopy", "(", "train2", ")", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "\n", "datasets", "=", "[", "copy_train1", ",", "copy_train2", "]", ",", "\n", "pipeline", "=", "pipeline1", ",", "\n", "force_apply", "=", "True", ")", "\n", "\n", "assert", "len", "(", "tmp_dataset", ")", "==", "2", "*", "len", "(", "list_from_file", "(", "ann_file", ")", ")", "\n", "assert", "len", "(", "tmp_dataset", ".", "datasets", "[", "0", "]", ".", "pipeline", ".", "transforms", ")", "==", "len", "(", "\n", "tmp_dataset", ".", "datasets", "[", "1", "]", ".", "pipeline", ".", "transforms", ")", "\n", "\n", "# pipeline is None", "\n", "copy_train2", "=", "copy", ".", "deepcopy", "(", "train2", ")", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "datasets", "=", "[", "copy_train2", "]", ",", "pipeline", "=", "None", ")", "\n", "assert", "len", "(", "tmp_dataset", ".", "datasets", "[", "0", "]", ".", "pipeline", ".", "transforms", ")", "==", "len", "(", "pipeline2", ")", "\n", "\n", "copy_train2", "=", "copy", ".", "deepcopy", "(", "train2", ")", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "\n", "datasets", "=", "[", "[", "copy_train2", "]", ",", "[", "copy_train2", "]", "]", ",", "pipeline", "=", "None", ")", "\n", "assert", "len", "(", "tmp_dataset", ".", "datasets", "[", "0", "]", ".", "pipeline", ".", "transforms", ")", "==", "len", "(", "pipeline2", ")", "\n", "\n", "# pipeline is 2d list", "\n", "copy_train1", "=", "copy", ".", "deepcopy", "(", "train1", ")", "\n", "copy_train2", "=", "copy", ".", "deepcopy", "(", "train2", ")", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "\n", "datasets", "=", "[", "[", "copy_train1", "]", ",", "[", "copy_train2", "]", "]", ",", "\n", "pipeline", "=", "[", "pipeline1", ",", "pipeline2", "]", ")", "\n", "assert", "len", "(", "tmp_dataset", ".", "datasets", "[", "0", "]", ".", "pipeline", ".", "transforms", ")", "==", "len", "(", "pipeline1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_uniform_concat_dataset.test_uniform_concat_dataset_eval": [[66, 131], ["mmdet.datasets.DATASETS.register_module", "mmocr.datasets.UniformConcatDataset", "mmocr.datasets.UniformConcatDataset.evaluate", "mmocr.datasets.UniformConcatDataset", "mmocr.datasets.UniformConcatDataset.evaluate", "mmocr.datasets.UniformConcatDataset", "mmocr.datasets.UniformConcatDataset", "mmocr.datasets.UniformConcatDataset.evaluate", "mmocr.datasets.UniformConcatDataset", "mmocr.datasets.UniformConcatDataset.evaluate", "dict", "dict", "dict", "pytest.raises", "mmocr.datasets.UniformConcatDataset", "mmocr.datasets.UniformConcatDataset.evaluate", "pytest.raises", "mmdet.datasets.DATASETS.register_module", "mmocr.datasets.UniformConcatDataset", "dict", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "test_uniform_concat_dataset_eval", "(", ")", ":", "\n", "\n", "    ", "@", "DATASETS", ".", "register_module", "(", ")", "\n", "class", "DummyDataset", ":", "\n", "\n", "        ", "def", "__init__", "(", "self", ")", ":", "\n", "            ", "self", ".", "CLASSES", "=", "0", "\n", "self", ".", "ann_file", "=", "'empty'", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "            ", "return", "1", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "res", ",", "logger", ",", "**", "kwargs", ")", ":", "\n", "            ", "return", "dict", "(", "n", "=", "res", "[", "0", "]", ")", "\n", "\n", "# Test 'auto'", "\n", "", "", "fake_inputs", "=", "[", "10", "]", "\n", "datasets", "=", "[", "dict", "(", "type", "=", "'DummyDataset'", ")", "]", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "datasets", ")", "\n", "results", "=", "tmp_dataset", ".", "evaluate", "(", "fake_inputs", ")", "\n", "assert", "results", "[", "'0_n'", "]", "==", "10", "\n", "assert", "'mean_n'", "not", "in", "results", "\n", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "datasets", ",", "show_mean_scores", "=", "True", ")", "\n", "results", "=", "tmp_dataset", ".", "evaluate", "(", "fake_inputs", ")", "\n", "assert", "results", "[", "'mean_n'", "]", "==", "10", "\n", "\n", "fake_inputs", "=", "[", "10", ",", "20", "]", "\n", "datasets", "=", "[", "dict", "(", "type", "=", "'DummyDataset'", ")", ",", "dict", "(", "type", "=", "'DummyDataset'", ")", "]", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "datasets", ")", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "datasets", ")", "\n", "results", "=", "tmp_dataset", ".", "evaluate", "(", "fake_inputs", ")", "\n", "assert", "results", "[", "'0_n'", "]", "==", "10", "\n", "assert", "results", "[", "'1_n'", "]", "==", "20", "\n", "assert", "results", "[", "'mean_n'", "]", "==", "15", "\n", "\n", "tmp_dataset", "=", "UniformConcatDataset", "(", "datasets", ",", "show_mean_scores", "=", "False", ")", "\n", "results", "=", "tmp_dataset", ".", "evaluate", "(", "fake_inputs", ")", "\n", "assert", "results", "[", "'0_n'", "]", "==", "10", "\n", "assert", "results", "[", "'1_n'", "]", "==", "20", "\n", "assert", "'mean_n'", "not", "in", "results", "\n", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "ds", "=", "UniformConcatDataset", "(", "datasets", ",", "separate_eval", "=", "False", ")", "\n", "ds", ".", "evaluate", "(", "fake_inputs", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "\n", "        ", "@", "DATASETS", ".", "register_module", "(", ")", "\n", "class", "DummyDataset2", ":", "\n", "\n", "            ", "def", "__init__", "(", "self", ")", ":", "\n", "                ", "self", ".", "CLASSES", "=", "0", "\n", "self", ".", "ann_file", "=", "'empty'", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "                ", "return", "1", "\n", "\n", "", "def", "evaluate", "(", "self", ",", "res", ",", "logger", ",", "**", "kwargs", ")", ":", "\n", "                ", "return", "dict", "(", "n", "=", "res", "[", "0", "]", ")", "\n", "\n", "", "", "UniformConcatDataset", "(", "\n", "[", "dict", "(", "type", "=", "'DummyDataset'", ")", ",", "\n", "dict", "(", "type", "=", "'DummyDataset2'", ")", "]", ",", "\n", "show_mean_scores", "=", "True", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader._create_dummy_line_str_file": [[15, 22], ["open", "fw.write"], "function", ["None"], ["def", "_create_dummy_line_str_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "'sample1.jpg hello'", "\n", "ann_info2", "=", "'sample2.jpg world'", "\n", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "ann_info", "in", "[", "ann_info1", ",", "ann_info2", "]", ":", "\n", "            ", "fw", ".", "write", "(", "ann_info", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader._create_dummy_line_json_file": [[24, 31], ["open", "fw.write", "json.dumps"], "function", ["None"], ["", "", "", "def", "_create_dummy_line_json_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "{", "'filename'", ":", "'sample1.jpg'", ",", "'text'", ":", "'hello'", "}", "\n", "ann_info2", "=", "{", "'filename'", ":", "'sample2.jpg'", ",", "'text'", ":", "'world'", "}", "\n", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "ann_info", "in", "[", "ann_info1", ",", "ann_info2", "]", ":", "\n", "            ", "fw", ".", "write", "(", "json", ".", "dumps", "(", "ann_info", ")", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader.test_loader": [[33, 97], ["tempfile.TemporaryDirectory", "os.join", "test_loader._create_dummy_line_str_file", "dict", "mmocr.datasets.utils.loader.AnnFileLoader", "test_loader._create_dummy_line_json_file", "dict", "mmocr.datasets.utils.loader.AnnFileLoader", "test_loader._create_dummy_line_json_file", "dict", "mmocr.datasets.utils.loader.AnnFileLoader", "iter", "test_loader._create_dummy_line_str_file", "os.join", "mmocr.utils.recog2lmdb", "dict", "mmocr.datasets.utils.loader.AnnFileLoader", "mmocr.datasets.utils.loader.AnnFileLoader.close", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.datasets.utils.loader.AnnFileLoader", "pytest.raises", "mmocr.datasets.utils.loader.AnnFileLoader", "len", "pytest.raises", "range", "pytest.raises", "mmocr.datasets.utils.backend.HardDiskAnnFileBackend", "pytest.raises", "mmocr.datasets.utils.backend.PetrelAnnFileBackend", "pytest.raises", "mmocr.datasets.utils.backend.HTTPAnnFileBackend", "next", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader._create_dummy_line_str_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader._create_dummy_line_json_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader._create_dummy_line_json_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_loader._create_dummy_line_str_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.lmdb_util.recog2lmdb", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.loader.AnnFileLoader.close"], ["", "", "", "def", "test_loader", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "_create_dummy_line_str_file", "(", "ann_file", ")", "\n", "\n", "parser", "=", "dict", "(", "\n", "type", "=", "'LineStrParser'", ",", "\n", "keys", "=", "[", "'filename'", ",", "'text'", "]", ",", "\n", "keys_idx", "=", "[", "0", ",", "1", "]", ",", "\n", "separator", "=", "' '", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "AnnFileLoader", "(", "ann_file", ",", "parser", ",", "repeat", "=", "0", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "AnnFileLoader", "(", "ann_file", ",", "[", "]", ",", "repeat", "=", "1", ")", "\n", "\n", "# test text loader and line str parser", "\n", "", "text_loader", "=", "AnnFileLoader", "(", "ann_file", ",", "parser", ",", "repeat", "=", "1", ",", "file_format", "=", "'txt'", ")", "\n", "assert", "len", "(", "text_loader", ")", "==", "2", "\n", "assert", "text_loader", ".", "ori_data_infos", "[", "0", "]", "==", "'sample1.jpg hello'", "\n", "assert", "text_loader", "[", "0", "]", "==", "{", "'filename'", ":", "'sample1.jpg'", ",", "'text'", ":", "'hello'", "}", "\n", "\n", "# test text loader and linedict parser", "\n", "_create_dummy_line_json_file", "(", "ann_file", ")", "\n", "json_parser", "=", "dict", "(", "type", "=", "'LineJsonParser'", ",", "keys", "=", "[", "'filename'", ",", "'text'", "]", ")", "\n", "text_loader", "=", "AnnFileLoader", "(", "\n", "ann_file", ",", "json_parser", ",", "repeat", "=", "1", ",", "file_format", "=", "'txt'", ")", "\n", "assert", "text_loader", "[", "0", "]", "==", "{", "'filename'", ":", "'sample1.jpg'", ",", "'text'", ":", "'hello'", "}", "\n", "\n", "# test text loader and linedict parser", "\n", "_create_dummy_line_json_file", "(", "ann_file", ")", "\n", "json_parser", "=", "dict", "(", "type", "=", "'LineJsonParser'", ",", "keys", "=", "[", "'filename'", ",", "'text'", "]", ")", "\n", "text_loader", "=", "AnnFileLoader", "(", "\n", "ann_file", ",", "json_parser", ",", "repeat", "=", "1", ",", "file_format", "=", "'txt'", ")", "\n", "it", "=", "iter", "(", "text_loader", ")", "\n", "with", "pytest", ".", "raises", "(", "StopIteration", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "len", "(", "text_loader", ")", "+", "1", ")", ":", "\n", "            ", "next", "(", "it", ")", "\n", "\n", "# test lmdb loader and line json parser", "\n", "", "", "_create_dummy_line_str_file", "(", "ann_file", ")", "\n", "lmdb_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.lmdb'", ")", "\n", "recog2lmdb", "(", "\n", "img_root", "=", "None", ",", "\n", "label_path", "=", "ann_file", ",", "\n", "label_only", "=", "True", ",", "\n", "output", "=", "lmdb_file", ",", "\n", "lmdb_map_size", "=", "102400", ")", "\n", "\n", "parser", "=", "dict", "(", "type", "=", "'LineJsonParser'", ",", "keys", "=", "[", "'filename'", ",", "'text'", "]", ")", "\n", "lmdb_loader", "=", "AnnFileLoader", "(", "\n", "lmdb_file", ",", "parser", ",", "repeat", "=", "1", ",", "file_format", "=", "'lmdb'", ")", "\n", "assert", "lmdb_loader", "[", "0", "]", "==", "{", "'filename'", ":", "'sample1.jpg'", ",", "'text'", ":", "'hello'", "}", "\n", "lmdb_loader", ".", "close", "(", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "HardDiskAnnFileBackend", "(", "file_format", "=", "'json'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "PetrelAnnFileBackend", "(", "file_format", "=", "'json'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "HTTPAnnFileBackend", "(", "file_format", "=", "'json'", ")", "\n", "\n", "", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ner_dataset._create_dummy_ann_file": [[13, 27], ["mmocr.utils.list_to_file", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "data", "=", "{", "\n", "'text'", ":", "'\u5f6d\u5c0f\u519b\u8ba4\u4e3a\uff0c\u56fd\u5185\u94f6\u884c\u73b0\u5728\u8d70\u7684\u662f\u53f0\u6e7e\u7684\u53d1\u5361\u6a21\u5f0f'", ",", "\n", "'label'", ":", "{", "\n", "'address'", ":", "{", "\n", "'\u53f0\u6e7e'", ":", "[", "[", "15", ",", "16", "]", "]", "\n", "}", ",", "\n", "'name'", ":", "{", "\n", "'\u5f6d\u5c0f\u519b'", ":", "[", "[", "0", ",", "2", "]", "]", "\n", "}", "\n", "}", "\n", "}", "\n", "\n", "list_to_file", "(", "ann_file", ",", "[", "json", ".", "dumps", "(", "data", ",", "ensure_ascii", "=", "False", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ner_dataset._create_dummy_vocab_file": [[29, 32], ["list", "map", "mmocr.utils.list_to_file", "range", "ord", "json.dumps", "ord"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "_create_dummy_vocab_file", "(", "vocab_file", ")", ":", "\n", "    ", "for", "char", "in", "list", "(", "map", "(", "chr", ",", "range", "(", "ord", "(", "'a'", ")", ",", "ord", "(", "'z'", ")", "+", "1", ")", ")", ")", ":", "\n", "        ", "list_to_file", "(", "vocab_file", ",", "[", "json", ".", "dumps", "(", "char", "+", "'\\n'", ",", "ensure_ascii", "=", "False", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ner_dataset._create_dummy_loader": [[34, 40], ["dict", "dict"], "function", ["None"], ["", "", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "type", "=", "'LineJsonParser'", ",", "keys", "=", "[", "'text'", ",", "'label'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ner_dataset.test_ner_dataset": [[42, 115], ["test_ner_dataset._create_dummy_loader", "tempfile.TemporaryDirectory", "os.join", "os.join", "test_ner_dataset._create_dummy_ann_file", "test_ner_dataset._create_dummy_vocab_file", "dict", "mmocr.datasets.ner_dataset.NerDataset", "dict", "mmocr.datasets.ner_dataset.NerDataset.pre_pipeline", "mmocr.datasets.ner_dataset.NerDataset.prepare_train_img", "mmocr.datasets.ner_dataset.NerDataset.evaluate", "range", "torch.tensor", "mmocr.models.ner.convertors.ner_convertor.NerConvertor", "mmocr.models.ner.convertors.ner_convertor.NerConvertor.convert_pred2entities", "tempfile.TemporaryDirectory.cleanup", "dict", "dict", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ner_model._create_dummy_vocab_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ner_convertor.NerConvertor.convert_pred2entities"], ["", "def", "test_ner_dataset", "(", ")", ":", "\n", "# test initialization", "\n", "    ", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "categories", "=", "[", "\n", "'address'", ",", "'book'", ",", "'company'", ",", "'game'", ",", "'government'", ",", "'movie'", ",", "'name'", ",", "\n", "'organization'", ",", "'position'", ",", "'scene'", "\n", "]", "\n", "\n", "# create dummy data", "\n", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "vocab_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_vocab.txt'", ")", "\n", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "_create_dummy_vocab_file", "(", "vocab_file", ")", "\n", "\n", "max_len", "=", "128", "\n", "ner_convertor", "=", "dict", "(", "\n", "type", "=", "'NerConvertor'", ",", "\n", "annotation_type", "=", "'bio'", ",", "\n", "vocab_file", "=", "vocab_file", ",", "\n", "categories", "=", "categories", ",", "\n", "max_len", "=", "max_len", ")", "\n", "\n", "test_pipeline", "=", "[", "\n", "dict", "(", "\n", "type", "=", "'NerTransform'", ",", "\n", "label_convertor", "=", "ner_convertor", ",", "\n", "max_len", "=", "max_len", ")", ",", "\n", "dict", "(", "type", "=", "'ToTensorNER'", ")", "\n", "]", "\n", "dataset", "=", "NerDataset", "(", "ann_file", ",", "loader", ",", "pipeline", "=", "test_pipeline", ")", "\n", "\n", "# test pre_pipeline", "\n", "img_info", "=", "dataset", ".", "data_infos", "[", "0", "]", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ")", "\n", "dataset", ".", "pre_pipeline", "(", "results", ")", "\n", "\n", "# test prepare_train_img", "\n", "dataset", ".", "prepare_train_img", "(", "0", ")", "\n", "\n", "# test evaluation", "\n", "result", "=", "[", "[", "[", "'address'", ",", "15", ",", "16", "]", ",", "[", "'name'", ",", "0", ",", "2", "]", "]", "]", "\n", "\n", "dataset", ".", "evaluate", "(", "result", ")", "\n", "\n", "# test pred convert2entity function", "\n", "pred", "=", "[", "\n", "21", ",", "7", ",", "17", ",", "17", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "13", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "1", ",", "11", ",", "\n", "21", ",", "21", ",", "7", ",", "17", ",", "17", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "13", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "1", ",", "\n", "11", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "1", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "21", ",", "1", ",", "21", ",", "21", ",", "21", ",", "21", ",", "\n", "21", ",", "21", "\n", "]", "\n", "preds", "=", "[", "pred", "[", ":", "128", "]", "]", "\n", "mask", "=", "[", "0", "]", "*", "128", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "        ", "mask", "[", "i", "]", "=", "1", "\n", "", "assert", "len", "(", "preds", "[", "0", "]", ")", "==", "len", "(", "mask", ")", "\n", "masks", "=", "torch", ".", "tensor", "(", "[", "mask", "]", ")", "\n", "convertor", "=", "NerConvertor", "(", "\n", "annotation_type", "=", "'bio'", ",", "\n", "vocab_file", "=", "vocab_file", ",", "\n", "categories", "=", "categories", ",", "\n", "max_len", "=", "128", ")", "\n", "all_entities", "=", "convertor", ".", "convert_pred2entities", "(", "preds", "=", "preds", ",", "masks", "=", "masks", ")", "\n", "assert", "len", "(", "all_entities", "[", "0", "]", "[", "0", "]", ")", "==", "3", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_seg_target._create_dummy_dict_file": [[11, 16], ["list", "open", "fw.write"], "function", ["None"], ["def", "_create_dummy_dict_file", "(", "dict_file", ")", ":", "\n", "    ", "chars", "=", "list", "(", "'0123456789'", ")", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "char", "in", "chars", ":", "\n", "            ", "fw", ".", "write", "(", "char", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_seg_target.test_ocr_segm_targets": [[18, 95], ["tempfile.TemporaryDirectory", "os.join", "test_ocr_seg_target._create_dummy_dict_file", "dict", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets.generate_kernels", "numpy.allclose", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets.generate_kernels", "numpy.allclose", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets.", "numpy.allclose", "numpy.allclose", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets", "pytest.raises", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets", "pytest.raises", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets", "pytest.raises", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets.generate_kernels", "pytest.raises", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets.generate_kernels", "pytest.raises", "mmocr.datasets.pipelines.ocr_seg_targets.OCRSegTargets.generate_kernels", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.base_textdet_targets.BaseTextDetTargets.generate_kernels"], ["", "", "", "def", "test_ocr_segm_targets", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy dict file", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_chars.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "# dummy label convertor", "\n", "label_convertor", "=", "dict", "(", "\n", "type", "=", "'SegConvertor'", ",", "\n", "dict_file", "=", "dict_file", ",", "\n", "with_unknown", "=", "True", ",", "\n", "lower", "=", "True", ")", "\n", "# test init", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "OCRSegTargets", "(", "None", ",", "0.5", ",", "0.5", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "OCRSegTargets", "(", "label_convertor", ",", "'1by2'", ",", "0.5", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "OCRSegTargets", "(", "label_convertor", ",", "0.5", ",", "2", ")", "\n", "\n", "", "ocr_seg_tgt", "=", "OCRSegTargets", "(", "label_convertor", ",", "0.5", ",", "0.5", ")", "\n", "# test generate kernels", "\n", "img_size", "=", "(", "8", ",", "8", ")", "\n", "pad_size", "=", "(", "8", ",", "10", ")", "\n", "char_boxes", "=", "[", "[", "2", ",", "2", ",", "6", ",", "6", "]", "]", "\n", "char_idxs", "=", "[", "2", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ocr_seg_tgt", ".", "generate_kernels", "(", "8", ",", "pad_size", ",", "char_boxes", ",", "char_idxs", ",", "0.5", ",", "\n", "True", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ocr_seg_tgt", ".", "generate_kernels", "(", "img_size", ",", "pad_size", ",", "[", "2", ",", "2", ",", "6", ",", "6", "]", ",", "\n", "char_idxs", ",", "0.5", ",", "True", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ocr_seg_tgt", ".", "generate_kernels", "(", "img_size", ",", "pad_size", ",", "char_boxes", ",", "2", ",", "0.5", ",", "\n", "True", ")", "\n", "\n", "", "attn_tgt", "=", "ocr_seg_tgt", ".", "generate_kernels", "(", "\n", "img_size", ",", "pad_size", ",", "char_boxes", ",", "char_idxs", ",", "0.5", ",", "binary", "=", "True", ")", "\n", "expect_attn_tgt", "=", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", "]", "\n", "assert", "np", ".", "allclose", "(", "attn_tgt", ",", "np", ".", "array", "(", "expect_attn_tgt", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "\n", "segm_tgt", "=", "ocr_seg_tgt", ".", "generate_kernels", "(", "\n", "img_size", ",", "pad_size", ",", "char_boxes", ",", "char_idxs", ",", "0.5", ",", "binary", "=", "False", ")", "\n", "expect_segm_tgt", "=", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "2", ",", "2", ",", "2", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "255", ",", "255", "]", "]", "\n", "assert", "np", ".", "allclose", "(", "segm_tgt", ",", "np", ".", "array", "(", "expect_segm_tgt", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "\n", "# test __call__", "\n", "results", "=", "{", "}", "\n", "results", "[", "'img_shape'", "]", "=", "(", "4", ",", "4", ",", "3", ")", "\n", "results", "[", "'resize_shape'", "]", "=", "(", "8", ",", "8", ",", "3", ")", "\n", "results", "[", "'pad_shape'", "]", "=", "(", "8", ",", "10", ")", "\n", "results", "[", "'ann_info'", "]", "=", "{", "}", "\n", "results", "[", "'ann_info'", "]", "[", "'char_rects'", "]", "=", "[", "[", "1", ",", "1", ",", "3", ",", "3", "]", "]", "\n", "results", "[", "'ann_info'", "]", "[", "'chars'", "]", "=", "[", "'1'", "]", "\n", "\n", "results", "=", "ocr_seg_tgt", "(", "results", ")", "\n", "assert", "results", "[", "'mask_fields'", "]", "==", "[", "'gt_kernels'", "]", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'gt_kernels'", "]", ".", "masks", "[", "0", "]", ",", "\n", "np", ".", "array", "(", "expect_attn_tgt", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "assert", "np", ".", "allclose", "(", "results", "[", "'gt_kernels'", "]", ".", "masks", "[", "1", "]", ",", "\n", "np", ".", "array", "(", "expect_segm_tgt", ",", "dtype", "=", "np", ".", "int32", ")", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_crop.test_order_vertex": [[12, 31], ["set", "pytest.raises", "mmocr.datasets.pipelines.box_utils.sort_vertex", "pytest.raises", "mmocr.datasets.pipelines.box_utils.sort_vertex", "itertools.permutations", "mmocr.datasets.pipelines.box_utils.sort_vertex", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex"], ["def", "test_order_vertex", "(", ")", ":", "\n", "    ", "dummy_points_x", "=", "[", "20", ",", "20", ",", "120", ",", "120", "]", "\n", "dummy_points_y", "=", "[", "20", ",", "40", ",", "40", ",", "20", "]", "\n", "\n", "expect_points_x", "=", "[", "20", ",", "120", ",", "120", ",", "20", "]", "\n", "expect_points_y", "=", "[", "20", ",", "20", ",", "40", ",", "40", "]", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "sort_vertex", "(", "[", "]", ",", "dummy_points_y", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "sort_vertex", "(", "dummy_points_x", ",", "[", "]", ")", "\n", "\n", "", "for", "perm", "in", "set", "(", "permutations", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", ")", ":", "\n", "        ", "points_x", "=", "[", "dummy_points_x", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "points_y", "=", "[", "dummy_points_y", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "ordered_points_x", ",", "ordered_points_y", "=", "sort_vertex", "(", "points_x", ",", "points_y", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "ordered_points_x", ",", "expect_points_x", ")", "\n", "assert", "np", ".", "allclose", "(", "ordered_points_y", ",", "expect_points_y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_crop.test_sort_vertex8": [[33, 46], ["set", "itertools.permutations", "list", "mmocr.datasets.pipelines.box_utils.sort_vertex8", "numpy.allclose", "itertools.chain.from_iterable", "zip"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.box_utils.sort_vertex8"], ["", "", "def", "test_sort_vertex8", "(", ")", ":", "\n", "    ", "dummy_points_x", "=", "[", "21", ",", "21", ",", "122", ",", "122", "]", "\n", "dummy_points_y", "=", "[", "21", ",", "39", ",", "39", ",", "21", "]", "\n", "\n", "expect_points", "=", "[", "21", ",", "21", ",", "122", ",", "21", ",", "122", ",", "39", ",", "21", ",", "39", "]", "\n", "\n", "for", "perm", "in", "set", "(", "permutations", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", ")", ":", "\n", "        ", "points_x", "=", "[", "dummy_points_x", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "points_y", "=", "[", "dummy_points_y", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "points", "=", "list", "(", "chain", ".", "from_iterable", "(", "zip", "(", "points_x", ",", "points_y", ")", ")", ")", "\n", "ordered_points", "=", "sort_vertex8", "(", "points", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "ordered_points", ",", "expect_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_crop.test_box_jitter": [[48, 67], ["dict", "mmocr.datasets.pipelines.crop.box_jitter", "numpy.allclose", "numpy.allclose", "pytest.raises", "mmocr.datasets.pipelines.crop.box_jitter", "pytest.raises", "mmocr.datasets.pipelines.crop.box_jitter", "pytest.raises", "mmocr.datasets.pipelines.crop.box_jitter", "pytest.raises", "mmocr.datasets.pipelines.crop.box_jitter"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.box_jitter"], ["", "", "def", "test_box_jitter", "(", ")", ":", "\n", "    ", "dummy_points_x", "=", "[", "20", ",", "120", ",", "120", ",", "20", "]", "\n", "dummy_points_y", "=", "[", "20", ",", "20", ",", "40", ",", "40", "]", "\n", "\n", "kwargs", "=", "dict", "(", "jitter_ratio_x", "=", "0.0", ",", "jitter_ratio_y", "=", "0.0", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "box_jitter", "(", "[", "]", ",", "dummy_points_y", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "box_jitter", "(", "dummy_points_x", ",", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "box_jitter", "(", "dummy_points_x", ",", "dummy_points_y", ",", "jitter_ratio_x", "=", "1.", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "box_jitter", "(", "dummy_points_x", ",", "dummy_points_y", ",", "jitter_ratio_y", "=", "1.", ")", "\n", "\n", "", "box_jitter", "(", "dummy_points_x", ",", "dummy_points_y", ",", "**", "kwargs", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "dummy_points_x", ",", "[", "20", ",", "120", ",", "120", ",", "20", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "dummy_points_y", ",", "[", "20", ",", "20", ",", "40", ",", "40", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_crop.test_opencv_crop": [[69, 82], ["numpy.ones", "mmocr.datasets.pipelines.crop.warp_img", "math.isclose", "math.isclose", "pytest.raises", "mmocr.datasets.pipelines.crop.warp_img", "pytest.raises", "mmocr.datasets.pipelines.crop.warp_img"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.warp_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.warp_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.warp_img"], ["", "def", "test_opencv_crop", "(", ")", ":", "\n", "    ", "dummy_img", "=", "np", ".", "ones", "(", "(", "600", ",", "600", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "dummy_box", "=", "[", "20", ",", "20", ",", "120", ",", "20", ",", "120", ",", "40", ",", "20", ",", "40", "]", "\n", "\n", "cropped_img", "=", "warp_img", "(", "dummy_img", ",", "dummy_box", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "warp_img", "(", "dummy_img", ",", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "warp_img", "(", "dummy_img", ",", "[", "20", ",", "40", ",", "40", ",", "20", "]", ")", "\n", "\n", "", "assert", "math", ".", "isclose", "(", "cropped_img", ".", "shape", "[", "0", "]", ",", "20", ")", "\n", "assert", "math", ".", "isclose", "(", "cropped_img", ".", "shape", "[", "1", "]", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_crop.test_min_rect_crop": [[84, 106], ["numpy.ones", "mmocr.datasets.pipelines.crop.crop_img", "math.isclose", "math.isclose", "pytest.raises", "mmocr.datasets.pipelines.crop.crop_img", "pytest.raises", "mmocr.datasets.pipelines.crop.crop_img", "pytest.raises", "mmocr.datasets.pipelines.crop.crop_img", "pytest.raises", "mmocr.datasets.pipelines.crop.crop_img"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.pipelines.crop.crop_img"], ["", "def", "test_min_rect_crop", "(", ")", ":", "\n", "    ", "dummy_img", "=", "np", ".", "ones", "(", "(", "600", ",", "600", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "dummy_box", "=", "[", "20", ",", "20", ",", "120", ",", "20", ",", "120", ",", "40", ",", "20", ",", "40", "]", "\n", "\n", "cropped_img", "=", "crop_img", "(", "\n", "dummy_img", ",", "\n", "dummy_box", ",", "\n", "0.", ",", "\n", "0.", ",", "\n", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "crop_img", "(", "dummy_img", ",", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "crop_img", "(", "dummy_img", ",", "[", "20", ",", "40", ",", "40", ",", "20", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "crop_img", "(", "dummy_img", ",", "dummy_box", ",", "4", ",", "0.2", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "crop_img", "(", "dummy_img", ",", "dummy_box", ",", "0.4", ",", "1.2", ")", "\n", "\n", "", "assert", "math", ".", "isclose", "(", "cropped_img", ".", "shape", "[", "0", "]", ",", "20", ")", "\n", "assert", "math", ".", "isclose", "(", "cropped_img", ".", "shape", "[", "1", "]", ",", "100", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_dataset._create_dummy_ann_file": [[9, 16], ["open", "fw.write"], "function", ["None"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "'sample1.jpg hello'", "\n", "ann_info2", "=", "'sample2.jpg world'", "\n", "\n", "with", "open", "(", "ann_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "ann_info", "in", "[", "ann_info1", ",", "ann_info2", "]", ":", "\n", "            ", "fw", ".", "write", "(", "ann_info", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_dataset._create_dummy_loader": [[18, 24], ["dict", "dict"], "function", ["None"], ["", "", "", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "type", "=", "'LineStrParser'", ",", "keys", "=", "[", "'file_name'", ",", "'text'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_ocr_dataset.test_detect_dataset": [[26, 76], ["tempfile.TemporaryDirectory", "os.join", "test_ocr_dataset._create_dummy_ann_file", "test_ocr_dataset._create_dummy_loader", "mmocr.datasets.ocr_dataset.OCRDataset", "tempfile.TemporaryDirectory.cleanup", "dict", "mmocr.datasets.ocr_dataset.OCRDataset.pre_pipeline", "mmocr.datasets.ocr_dataset.OCRDataset.evaluate", "math.isclose", "math.isclose", "math.isclose", "mmocr.datasets.ocr_dataset.OCRDataset.evaluate", "math.isclose", "mmocr.datasets.ocr_dataset.OCRDataset.evaluate", "math.isclose", "math.isclose", "mmocr.datasets.ocr_dataset.OCRDataset.evaluate", "math.isclose", "math.isclose", "math.isclose", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "test_detect_dataset", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_data.txt'", ")", "\n", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "\n", "# test initialization", "\n", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "dataset", "=", "OCRDataset", "(", "ann_file", ",", "loader", ",", "pipeline", "=", "[", "]", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n", "# test pre_pipeline", "\n", "img_info", "=", "dataset", ".", "data_infos", "[", "0", "]", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ")", "\n", "dataset", ".", "pre_pipeline", "(", "results", ")", "\n", "assert", "results", "[", "'img_prefix'", "]", "==", "dataset", ".", "img_prefix", "\n", "assert", "results", "[", "'text'", "]", "==", "img_info", "[", "'text'", "]", "\n", "\n", "# test evluation", "\n", "metric", "=", "'acc'", "\n", "results", "=", "[", "{", "'text'", ":", "'hello'", "}", ",", "{", "'text'", ":", "'worl'", "}", "]", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "results", ",", "metric", ")", "\n", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'word_acc'", "]", ",", "0.5", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'char_precision'", "]", ",", "1.0", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'char_recall'", "]", ",", "0.9", ",", "abs_tol", "=", "1e-4", ")", "\n", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "results", ",", "metric", "=", "'word_acc'", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'word_acc'", "]", ",", "0.5", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "len", "(", "eval_res", ")", "==", "1", "\n", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "\n", "results", ",", "metric", "=", "[", "'char_precision'", ",", "'char_recall'", "]", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'char_precision'", "]", ",", "1.0", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'char_recall'", "]", ",", "0.9", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "len", "(", "eval_res", ")", "==", "2", "\n", "\n", "results", "=", "[", "{", "'text'", ":", "'HELLO*'", "}", ",", "{", "'text'", ":", "'worl'", "}", "]", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "\n", "results", ",", "\n", "metric", "=", "[", "\n", "'word_acc_ignore_case_symbol'", ",", "'word_acc_ignore_case'", ",", "\n", "'one_minus_ned'", "\n", "]", ")", "\n", "assert", "math", ".", "isclose", "(", "\n", "eval_res", "[", "'word_acc_ignore_case_symbol'", "]", ",", "0.5", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'word_acc_ignore_case'", "]", ",", "0", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'1-N.E.D'", "]", ",", "0.9", ",", "abs_tol", "=", "1e-4", ")", "\n", "assert", "len", "(", "eval_res", ")", "==", "3", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file": [[13, 36], ["mmocr.utils.list_to_file", "json.dumps"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "_create_dummy_ann_file", "(", "ann_file", ")", ":", "\n", "    ", "ann_info1", "=", "{", "\n", "'file_name'", ":", "\n", "'1.png'", ",", "\n", "'height'", ":", "\n", "200", ",", "\n", "'width'", ":", "\n", "200", ",", "\n", "'annotations'", ":", "[", "{", "\n", "'text'", ":", "'store'", ",", "\n", "'box'", ":", "[", "11.0", ",", "0.0", ",", "22.0", ",", "0.0", ",", "12.0", ",", "12.0", ",", "0.0", ",", "12.0", "]", ",", "\n", "'label'", ":", "1", ",", "\n", "'edge'", ":", "1", "\n", "}", ",", "{", "\n", "'text'", ":", "'MyFamily'", ",", "\n", "'box'", ":", "[", "23.0", ",", "2.0", ",", "31.0", ",", "1.0", ",", "24.0", ",", "11.0", ",", "16.0", ",", "11.0", "]", ",", "\n", "'label'", ":", "2", ",", "\n", "'edge'", ":", "1", "\n", "}", "]", "\n", "}", "\n", "list_to_file", "(", "ann_file", ",", "[", "json", ".", "dumps", "(", "ann_info1", ")", "]", ")", "\n", "\n", "return", "ann_info1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_dict_file": [[38, 41], ["mmocr.utils.list_to_file", "list"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["", "def", "_create_dummy_dict_file", "(", "dict_file", ")", ":", "\n", "    ", "dict_str", "=", "'0123'", "\n", "list_to_file", "(", "dict_file", ",", "list", "(", "dict_str", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader": [[43, 51], ["dict", "dict"], "function", ["None"], ["", "def", "_create_dummy_loader", "(", ")", ":", "\n", "    ", "loader", "=", "dict", "(", "\n", "type", "=", "'HardDiskLoader'", ",", "\n", "repeat", "=", "1", ",", "\n", "parser", "=", "dict", "(", "\n", "type", "=", "'LineJsonParser'", ",", "\n", "keys", "=", "[", "'file_name'", ",", "'height'", ",", "'width'", ",", "'annotations'", "]", ")", ")", "\n", "return", "loader", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset.test_openset_kie_dataset": [[53, 99], ["tempfile.TemporaryDirectory", "os.join", "test_openset_kie_dataset._create_dummy_ann_file", "os.join", "test_openset_kie_dataset._create_dummy_dict_file", "test_openset_kie_dataset._create_dummy_loader", "mmocr.datasets.openset_kie_dataset.OpensetKIEDataset", "mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.prepare_train_img", "mmocr.datasets.openset_kie_dataset.OpensetKIEDataset._parse_anno_info", "dict", "mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.pre_pipeline", "torch.tensor", "torch.Tensor", "mmocr.datasets.openset_kie_dataset.OpensetKIEDataset.evaluate", "math.isclose", "[].append", "[].append", "range"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_ann_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_openset_kie_dataset._create_dummy_loader", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.prepare_train_img", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset._parse_anno_info", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.kie_dataset.KIEDataset.pre_pipeline", "home.repos.pwc.inspect_result.open-mmlab_mmocr.datasets.uniform_concat_dataset.UniformConcatDataset.evaluate"], ["", "def", "test_openset_kie_dataset", "(", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmp_dir_name", ":", "\n", "# create dummy data", "\n", "        ", "ann_file", "=", "osp", ".", "join", "(", "tmp_dir_name", ",", "'fake_data.txt'", ")", "\n", "ann_info1", "=", "_create_dummy_ann_file", "(", "ann_file", ")", "\n", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir_name", ",", "'fake_dict.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "# test initialization", "\n", "loader", "=", "_create_dummy_loader", "(", ")", "\n", "dataset", "=", "OpensetKIEDataset", "(", "ann_file", ",", "loader", ",", "dict_file", ",", "pipeline", "=", "[", "]", ")", "\n", "\n", "dataset", ".", "prepare_train_img", "(", "0", ")", "\n", "\n", "# test pre_pipeline", "\n", "img_ann_info", "=", "dataset", ".", "data_infos", "[", "0", "]", "\n", "img_info", "=", "{", "\n", "'filename'", ":", "img_ann_info", "[", "'file_name'", "]", ",", "\n", "'height'", ":", "img_ann_info", "[", "'height'", "]", ",", "\n", "'width'", ":", "img_ann_info", "[", "'width'", "]", "\n", "}", "\n", "ann_info", "=", "dataset", ".", "_parse_anno_info", "(", "img_ann_info", "[", "'annotations'", "]", ")", "\n", "results", "=", "dict", "(", "img_info", "=", "img_info", ",", "ann_info", "=", "ann_info", ")", "\n", "dataset", ".", "pre_pipeline", "(", "results", ")", "\n", "assert", "results", "[", "'img_prefix'", "]", "==", "dataset", ".", "img_prefix", "\n", "assert", "'ori_texts'", "in", "results", "\n", "\n", "# test evaluation", "\n", "result", "=", "{", "\n", "'img_metas'", ":", "[", "{", "\n", "'filename'", ":", "ann_info1", "[", "'file_name'", "]", ",", "\n", "'ori_filename'", ":", "ann_info1", "[", "'file_name'", "]", ",", "\n", "'ori_texts'", ":", "[", "]", ",", "\n", "'ori_bboxes'", ":", "[", "]", "\n", "}", "]", "\n", "}", "\n", "for", "anno", "in", "ann_info1", "[", "'annotations'", "]", ":", "\n", "            ", "result", "[", "'img_metas'", "]", "[", "0", "]", "[", "'ori_texts'", "]", ".", "append", "(", "anno", "[", "'text'", "]", ")", "\n", "result", "[", "'img_metas'", "]", "[", "0", "]", "[", "'ori_bboxes'", "]", ".", "append", "(", "anno", "[", "'box'", "]", ")", "\n", "", "result", "[", "'nodes'", "]", "=", "torch", ".", "tensor", "(", "[", "[", "0.01", ",", "0.8", ",", "0.01", ",", "0.18", "]", ",", "\n", "[", "0.01", ",", "0.01", ",", "0.9", ",", "0.08", "]", "]", ")", "\n", "result", "[", "'edges'", "]", "=", "torch", ".", "Tensor", "(", "[", "[", "0.01", ",", "0.99", "]", "for", "_", "in", "range", "(", "4", ")", "]", ")", "\n", "\n", "eval_res", "=", "dataset", ".", "evaluate", "(", "[", "result", "]", ")", "\n", "assert", "math", ".", "isclose", "(", "eval_res", "[", "'edge_openset_f1'", "]", ",", "1.0", ",", "abs_tol", "=", "1e-4", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_dataset.test_test_time_aug.test_resize_ocr": [[8, 35], ["numpy.ones", "numpy.ones", "mmocr.datasets.pipelines.test_time_aug.MultiRotateAugOCR", "mmocr.datasets.pipelines.test_time_aug.MultiRotateAugOCR.", "numpy.allclose", "numpy.allclose", "mmocr.datasets.pipelines.test_time_aug.MultiRotateAugOCR.", "numpy.allclose", "numpy.allclose", "pytest.raises", "mmocr.datasets.pipelines.test_time_aug.MultiRotateAugOCR", "pytest.raises", "mmocr.datasets.pipelines.test_time_aug.MultiRotateAugOCR", "len", "len", "len", "len"], "function", ["None"], ["def", "test_resize_ocr", "(", ")", ":", "\n", "    ", "input_img1", "=", "np", ".", "ones", "(", "(", "64", ",", "256", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "input_img2", "=", "np", ".", "ones", "(", "(", "64", ",", "32", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "rci", "=", "MultiRotateAugOCR", "(", "transforms", "=", "[", "]", ",", "rotate_degrees", "=", "[", "0", ",", "90", ",", "270", "]", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "MultiRotateAugOCR", "(", "transforms", "=", "[", "]", ",", "rotate_degrees", "=", "[", "45", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "MultiRotateAugOCR", "(", "transforms", "=", "[", "]", ",", "rotate_degrees", "=", "[", "20.5", "]", ")", "\n", "\n", "# test call with input_img1", "\n", "", "results", "=", "{", "'img_shape'", ":", "input_img1", ".", "shape", ",", "'img'", ":", "input_img1", "}", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "[", "64", ",", "256", ",", "3", "]", ",", "results", "[", "'img_shape'", "]", ")", "\n", "assert", "len", "(", "results", "[", "'img'", "]", ")", "==", "1", "\n", "assert", "len", "(", "results", "[", "'img_shape'", "]", ")", "==", "1", "\n", "assert", "np", ".", "allclose", "(", "[", "64", ",", "256", ",", "3", "]", ",", "results", "[", "'img_shape'", "]", "[", "0", "]", ")", "\n", "\n", "# test call with input_img2", "\n", "results", "=", "{", "'img_shape'", ":", "input_img2", ".", "shape", ",", "'img'", ":", "input_img2", "}", "\n", "results", "=", "rci", "(", "results", ")", "\n", "assert", "np", ".", "allclose", "(", "[", "64", ",", "32", ",", "3", "]", ",", "results", "[", "'img_shape'", "]", ")", "\n", "assert", "len", "(", "results", "[", "'img'", "]", ")", "==", "3", "\n", "assert", "len", "(", "results", "[", "'img_shape'", "]", ")", "==", "3", "\n", "assert", "np", ".", "allclose", "(", "[", "64", ",", "32", ",", "3", "]", ",", "results", "[", "'img_shape'", "]", "[", "0", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_preprocessor.test_tps_preprocessor": [[9, 30], ["mmocr.models.textrecog.preprocessor.TPSPreprocessor", "mmocr.models.textrecog.preprocessor.TPSPreprocessor.init_weights", "mmocr.models.textrecog.preprocessor.TPSPreprocessor.train", "torch.randn", "mmocr.models.textrecog.preprocessor.TPSPreprocessor.", "pytest.raises", "mmocr.models.textrecog.preprocessor.TPSPreprocessor", "pytest.raises", "mmocr.models.textrecog.preprocessor.TPSPreprocessor", "pytest.raises", "mmocr.models.textrecog.preprocessor.TPSPreprocessor", "pytest.raises", "mmocr.models.textrecog.preprocessor.TPSPreprocessor", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["def", "test_tps_preprocessor", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "TPSPreprocessor", "(", "num_fiducial", "=", "-", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "TPSPreprocessor", "(", "img_size", "=", "32", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "TPSPreprocessor", "(", "rectified_img_size", "=", "100", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "TPSPreprocessor", "(", "num_img_channel", "=", "'bgr'", ")", "\n", "\n", "", "tps_preprocessor", "=", "TPSPreprocessor", "(", "\n", "num_fiducial", "=", "20", ",", "\n", "img_size", "=", "(", "32", ",", "100", ")", ",", "\n", "rectified_img_size", "=", "(", "32", ",", "100", ")", ",", "\n", "num_img_channel", "=", "1", ")", "\n", "tps_preprocessor", ".", "init_weights", "(", ")", "\n", "tps_preprocessor", ".", "train", "(", ")", "\n", "\n", "batch_img", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "32", ",", "100", ")", "\n", "processed", "=", "tps_preprocessor", "(", "batch_img", ")", "\n", "assert", "processed", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1", ",", "32", ",", "100", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_preprocessor.test_base_preprocessor": [[32, 40], ["mmocr.models.textrecog.preprocessor.BasePreprocessor", "mmocr.models.textrecog.preprocessor.BasePreprocessor.init_weights", "mmocr.models.textrecog.preprocessor.BasePreprocessor.train", "torch.randn", "mmocr.models.textrecog.preprocessor.BasePreprocessor.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_base_preprocessor", "(", ")", ":", "\n", "    ", "preprocessor", "=", "BasePreprocessor", "(", ")", "\n", "preprocessor", ".", "init_weights", "(", ")", "\n", "preprocessor", ".", "train", "(", ")", "\n", "\n", "batch_img", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "32", ",", "100", ")", "\n", "processed", "=", "preprocessor", "(", "batch_img", ")", "\n", "assert", "processed", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "1", ",", "32", ",", "100", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recognizer._create_dummy_dict_file": [[15, 20], ["list", "open", "fw.write"], "function", ["None"], ["def", "_create_dummy_dict_file", "(", "dict_file", ")", ":", "\n", "    ", "chars", "=", "list", "(", "'helowrd'", ")", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "char", "in", "chars", ":", "\n", "            ", "fw", ".", "write", "(", "char", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recognizer.test_base_recognizer": [[22, 104], ["tempfile.TemporaryDirectory", "os.join", "test_recognizer._create_dummy_dict_file", "dict", "dict", "dict", "dict", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer.init_weights", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer.train", "torch.rand", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer.extract_feat", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer.forward_train", "isinstance", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer.simple_test", "isinstance", "isinstance", "functools.partial", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer.aug_test", "isinstance", "isinstance", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.EncodeDecodeRecognizer", "torch.Size", "tempfile.TemporaryDirectory", "torch.onnx.export"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.aug_test"], ["", "", "", "def", "test_base_recognizer", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_chars.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "label_convertor", "=", "dict", "(", "\n", "type", "=", "'CTCConvertor'", ",", "dict_file", "=", "dict_file", ",", "with_unknown", "=", "False", ")", "\n", "\n", "preprocessor", "=", "None", "\n", "backbone", "=", "dict", "(", "type", "=", "'VeryDeepVgg'", ",", "leaky_relu", "=", "False", ")", "\n", "encoder", "=", "None", "\n", "decoder", "=", "dict", "(", "type", "=", "'CRNNDecoder'", ",", "in_channels", "=", "512", ",", "rnn_flag", "=", "True", ")", "\n", "loss", "=", "dict", "(", "type", "=", "'CTCLoss'", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "EncodeDecodeRecognizer", "(", "backbone", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "EncodeDecodeRecognizer", "(", "decoder", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "EncodeDecodeRecognizer", "(", "loss", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "EncodeDecodeRecognizer", "(", "label_convertor", "=", "None", ")", "\n", "\n", "", "recognizer", "=", "EncodeDecodeRecognizer", "(", "\n", "preprocessor", "=", "preprocessor", ",", "\n", "backbone", "=", "backbone", ",", "\n", "encoder", "=", "encoder", ",", "\n", "decoder", "=", "decoder", ",", "\n", "loss", "=", "loss", ",", "\n", "label_convertor", "=", "label_convertor", ")", "\n", "\n", "recognizer", ".", "init_weights", "(", ")", "\n", "recognizer", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "rand", "(", "1", ",", "3", ",", "32", ",", "160", ")", "\n", "\n", "# test extract feat", "\n", "feat", "=", "recognizer", ".", "extract_feat", "(", "imgs", ")", "\n", "assert", "feat", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "1", ",", "41", "]", ")", "\n", "\n", "# test forward train", "\n", "img_metas", "=", "[", "{", "\n", "'text'", ":", "'hello'", ",", "\n", "'resize_shape'", ":", "(", "32", ",", "120", ",", "3", ")", ",", "\n", "'valid_ratio'", ":", "1.0", "\n", "}", "]", "\n", "losses", "=", "recognizer", ".", "forward_train", "(", "imgs", ",", "img_metas", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "assert", "'loss_ctc'", "in", "losses", "\n", "\n", "# test simple test", "\n", "results", "=", "recognizer", ".", "simple_test", "(", "imgs", ",", "img_metas", ")", "\n", "assert", "isinstance", "(", "results", ",", "list", ")", "\n", "assert", "isinstance", "(", "results", "[", "0", "]", ",", "dict", ")", "\n", "assert", "'text'", "in", "results", "[", "0", "]", "\n", "assert", "'score'", "in", "results", "[", "0", "]", "\n", "\n", "# test onnx export", "\n", "recognizer", ".", "forward", "=", "partial", "(", "\n", "recognizer", ".", "simple_test", ",", "\n", "img_metas", "=", "img_metas", ",", "\n", "return_loss", "=", "False", ",", "\n", "rescale", "=", "True", ")", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "onnx_path", "=", "f'{tmpdirname}/tmp.onnx'", "\n", "torch", ".", "onnx", ".", "export", "(", "\n", "recognizer", ",", "(", "imgs", ",", ")", ",", "\n", "onnx_path", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "export_params", "=", "True", ",", "\n", "keep_initializers_as_inputs", "=", "False", ")", "\n", "\n", "# test aug_test", "\n", "", "aug_results", "=", "recognizer", ".", "aug_test", "(", "[", "imgs", ",", "imgs", "]", ",", "[", "img_metas", ",", "img_metas", "]", ")", "\n", "assert", "isinstance", "(", "aug_results", ",", "list", ")", "\n", "assert", "isinstance", "(", "aug_results", "[", "0", "]", ",", "dict", ")", "\n", "assert", "'text'", "in", "aug_results", "[", "0", "]", "\n", "assert", "'score'", "in", "aug_results", "[", "0", "]", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recognizer.test_seg_recognizer": [[106, 193], ["tempfile.TemporaryDirectory", "os.join", "test_recognizer._create_dummy_dict_file", "dict", "dict", "dict", "dict", "dict", "mmocr.models.textrecog.recognizer.SegRecognizer", "mmocr.models.textrecog.recognizer.SegRecognizer.init_weights", "mmocr.models.textrecog.recognizer.SegRecognizer.train", "torch.rand", "mmocr.models.textrecog.recognizer.SegRecognizer.extract_feat", "numpy.zeros", "numpy.zeros", "numpy.zeros", "mmdet.core.BitmapMasks", "mmocr.models.textrecog.recognizer.SegRecognizer.forward_train", "isinstance", "mmocr.models.textrecog.recognizer.SegRecognizer.simple_test", "isinstance", "isinstance", "mmocr.models.textrecog.recognizer.SegRecognizer.aug_test", "isinstance", "isinstance", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.models.textrecog.recognizer.SegRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.SegRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.SegRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.SegRecognizer", "pytest.raises", "mmocr.models.textrecog.recognizer.SegRecognizer", "len", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.extract_feat", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.simple_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.aug_test"], ["", "def", "test_seg_recognizer", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_chars.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "label_convertor", "=", "dict", "(", "\n", "type", "=", "'SegConvertor'", ",", "dict_file", "=", "dict_file", ",", "with_unknown", "=", "False", ")", "\n", "\n", "preprocessor", "=", "None", "\n", "backbone", "=", "dict", "(", "\n", "type", "=", "'ResNet31OCR'", ",", "\n", "layers", "=", "[", "1", ",", "2", ",", "5", ",", "3", "]", ",", "\n", "channels", "=", "[", "32", ",", "64", ",", "128", ",", "256", ",", "512", ",", "512", "]", ",", "\n", "out_indices", "=", "[", "0", ",", "1", ",", "2", ",", "3", "]", ",", "\n", "stage4_pool_cfg", "=", "dict", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", ",", "\n", "last_stage_pool", "=", "True", ")", "\n", "neck", "=", "dict", "(", "\n", "type", "=", "'FPNOCR'", ",", "in_channels", "=", "[", "128", ",", "256", ",", "512", ",", "512", "]", ",", "out_channels", "=", "256", ")", "\n", "head", "=", "dict", "(", "\n", "type", "=", "'SegHead'", ",", "\n", "in_channels", "=", "256", ",", "\n", "upsample_param", "=", "dict", "(", "scale_factor", "=", "2.0", ",", "mode", "=", "'nearest'", ")", ")", "\n", "loss", "=", "dict", "(", "type", "=", "'SegLoss'", ",", "seg_downsample_ratio", "=", "1.0", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegRecognizer", "(", "backbone", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegRecognizer", "(", "neck", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegRecognizer", "(", "head", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegRecognizer", "(", "loss", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegRecognizer", "(", "label_convertor", "=", "None", ")", "\n", "\n", "", "recognizer", "=", "SegRecognizer", "(", "\n", "preprocessor", "=", "preprocessor", ",", "\n", "backbone", "=", "backbone", ",", "\n", "neck", "=", "neck", ",", "\n", "head", "=", "head", ",", "\n", "loss", "=", "loss", ",", "\n", "label_convertor", "=", "label_convertor", ")", "\n", "\n", "recognizer", ".", "init_weights", "(", ")", "\n", "recognizer", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "rand", "(", "1", ",", "3", ",", "64", ",", "256", ")", "\n", "\n", "# test extract feat", "\n", "feats", "=", "recognizer", ".", "extract_feat", "(", "imgs", ")", "\n", "assert", "len", "(", "feats", ")", "==", "4", "\n", "\n", "assert", "feats", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "128", ",", "32", ",", "128", "]", ")", "\n", "assert", "feats", "[", "1", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "16", ",", "64", "]", ")", "\n", "assert", "feats", "[", "2", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "8", ",", "32", "]", ")", "\n", "assert", "feats", "[", "3", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "4", ",", "16", "]", ")", "\n", "\n", "attn_tgt", "=", "np", ".", "zeros", "(", "(", "64", ",", "256", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "segm_tgt", "=", "np", ".", "zeros", "(", "(", "64", ",", "256", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "64", ",", "256", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "gt_kernels", "=", "BitmapMasks", "(", "[", "attn_tgt", ",", "segm_tgt", ",", "mask", "]", ",", "64", ",", "256", ")", "\n", "\n", "# test forward train", "\n", "img_metas", "=", "[", "{", "\n", "'text'", ":", "'hello'", ",", "\n", "'resize_shape'", ":", "(", "64", ",", "256", ",", "3", ")", ",", "\n", "'valid_ratio'", ":", "1.0", "\n", "}", "]", "\n", "losses", "=", "recognizer", ".", "forward_train", "(", "imgs", ",", "img_metas", ",", "gt_kernels", "=", "[", "gt_kernels", "]", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# test simple test", "\n", "results", "=", "recognizer", ".", "simple_test", "(", "imgs", ",", "img_metas", ")", "\n", "assert", "isinstance", "(", "results", ",", "list", ")", "\n", "assert", "isinstance", "(", "results", "[", "0", "]", ",", "dict", ")", "\n", "assert", "'text'", "in", "results", "[", "0", "]", "\n", "assert", "'score'", "in", "results", "[", "0", "]", "\n", "\n", "# test aug_test", "\n", "aug_results", "=", "recognizer", ".", "aug_test", "(", "[", "imgs", ",", "imgs", "]", ",", "[", "img_metas", ",", "img_metas", "]", ")", "\n", "assert", "isinstance", "(", "aug_results", ",", "list", ")", "\n", "assert", "isinstance", "(", "aug_results", "[", "0", "]", ",", "dict", ")", "\n", "assert", "'text'", "in", "aug_results", "[", "0", "]", "\n", "assert", "'score'", "in", "aug_results", "[", "0", "]", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_panhead.test_panhead": [[8, 36], ["dict", "mmocr.PANHead", "numpy.array", "pan_head.PANHead.resize_boundary", "numpy.allclose", "pytest.raises", "mmocr.PANHead", "pytest.raises", "mmocr.PANHead", "pytest.raises", "mmocr.PANHead"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.head_mixin.HeadMixin.resize_boundary"], ["def", "test_panhead", "(", ")", ":", "\n", "    ", "in_channels", "=", "[", "128", "]", "\n", "out_channels", "=", "128", "\n", "text_repr_type", "=", "'poly'", "# 'poly' or 'quad'", "\n", "downsample_ratio", "=", "0.25", "\n", "loss", "=", "dict", "(", "type", "=", "'PANLoss'", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "panheader", "=", "pan_head", ".", "PANHead", "(", "128", ",", "out_channels", ",", "downsample_ratio", ",", "loss", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "panheader", "=", "pan_head", ".", "PANHead", "(", "in_channels", ",", "[", "out_channels", "]", ",", "\n", "downsample_ratio", ",", "loss", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "panheader", "=", "pan_head", ".", "PANHead", "(", "in_channels", ",", "out_channels", ",", "text_repr_type", ",", "\n", "1.1", ",", "loss", ")", "\n", "\n", "", "panheader", "=", "pan_head", ".", "PANHead", "(", "in_channels", ",", "out_channels", ",", "downsample_ratio", ",", "\n", "loss", ")", "\n", "\n", "# test resize_boundary", "\n", "boundaries", "=", "[", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0.1", ",", "0.1", ",", "0.1", ",", "0", ",", "0.1", ",", "0.9", "]", "]", "\n", "target_boundary", "=", "[", "[", "0", ",", "0", ",", "0", ",", "0.5", ",", "1", ",", "0.5", ",", "0", ",", "0.5", ",", "0.9", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0.05", ",", "0.1", ",", "0.05", ",", "0", ",", "0.05", ",", "0.9", "]", "]", "\n", "scale_factor", "=", "np", ".", "array", "(", "[", "1", ",", "0.5", ",", "1", ",", "0.5", "]", ")", "\n", "resized_boundary", "=", "panheader", ".", "resize_boundary", "(", "boundaries", ",", "scale_factor", ")", "\n", "assert", "np", ".", "allclose", "(", "resized_boundary", ",", "target_boundary", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_textdet_neck.test_fpnc": [[8, 32], ["dict", "mmocr.models.textdet.necks.FPNC.init_weights", "range", "mmocr.models.textdet.necks.FPNC.forward", "mmocr.models.textdet.necks.FPNC", "inputs.append", "list", "torch.rand", "fpnc.forward.size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["def", "test_fpnc", "(", ")", ":", "\n", "\n", "    ", "in_channels", "=", "[", "64", ",", "128", ",", "256", ",", "512", "]", "\n", "size", "=", "[", "112", ",", "56", ",", "28", ",", "14", "]", "\n", "asf_cfgs", "=", "[", "\n", "None", ",", "\n", "dict", "(", "attention_type", "=", "'ScaleChannelSpatial'", ")", ",", "\n", "]", "\n", "for", "flag", "in", "[", "False", ",", "True", "]", ":", "\n", "        ", "for", "asf_cfg", "in", "asf_cfgs", ":", "\n", "            ", "fpnc", "=", "FPNC", "(", "\n", "in_channels", "=", "in_channels", ",", "\n", "bias_on_lateral", "=", "flag", ",", "\n", "bn_re_on_lateral", "=", "flag", ",", "\n", "bias_on_smooth", "=", "flag", ",", "\n", "bn_re_on_smooth", "=", "flag", ",", "\n", "asf_cfg", "=", "asf_cfg", ",", "\n", "conv_after_concat", "=", "flag", ")", "\n", "", "fpnc", ".", "init_weights", "(", ")", "\n", "inputs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "            ", "inputs", ".", "append", "(", "torch", ".", "rand", "(", "1", ",", "in_channels", "[", "i", "]", ",", "size", "[", "i", "]", ",", "size", "[", "i", "]", ")", ")", "\n", "", "outputs", "=", "fpnc", ".", "forward", "(", "inputs", ")", "\n", "assert", "list", "(", "outputs", ".", "size", "(", ")", ")", "==", "[", "1", ",", "256", ",", "112", ",", "112", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_textdet_neck.test_fpn_unet_neck": [[34, 58], ["mmocr.models.textdet.necks.FPN_UNet", "mmocr.models.textdet.necks.FPN_UNet.init_weights", "mmocr.models.textdet.necks.FPN_UNet.", "pytest.raises", "mmocr.models.textdet.necks.FPN_UNet", "pytest.raises", "mmocr.models.textdet.necks.FPN_UNet", "torch.rand", "torch.Size", "range", "range", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights"], ["", "", "def", "test_fpn_unet_neck", "(", ")", ":", "\n", "    ", "s", "=", "64", "\n", "feat_sizes", "=", "[", "s", "//", "2", "**", "i", "for", "i", "in", "range", "(", "4", ")", "]", "# [64, 32, 16, 8]", "\n", "in_channels", "=", "[", "8", ",", "16", ",", "32", ",", "64", "]", "\n", "out_channels", "=", "4", "\n", "\n", "# len(in_channcels) is not equal to 4", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "FPN_UNet", "(", "in_channels", "+", "[", "128", "]", ",", "out_channels", ")", "\n", "\n", "# `out_channels` is not int type", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "FPN_UNet", "(", "in_channels", ",", "[", "2", ",", "4", "]", ")", "\n", "\n", "", "feats", "=", "[", "\n", "torch", ".", "rand", "(", "1", ",", "in_channels", "[", "i", "]", ",", "feat_sizes", "[", "i", "]", ",", "feat_sizes", "[", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "in_channels", ")", ")", "\n", "]", "\n", "\n", "fpn_unet_neck", "=", "FPN_UNet", "(", "in_channels", ",", "out_channels", ")", "\n", "fpn_unet_neck", ".", "init_weights", "(", ")", "\n", "\n", "out_neck", "=", "fpn_unet_neck", "(", "feats", ")", "\n", "assert", "out_neck", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "out_channels", ",", "s", "*", "4", ",", "s", "*", "4", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_kie_config._demo_mm_inputs": [[10, 45], ["numpy.random.RandomState", "np.random.RandomState.rand", "torch.randn", "torch.ones", "torch.Tensor().expand", "torch.ones().long", "torch.FloatTensor().requires_grad_", "range", "range", "range", "range", "range", "torch.Tensor", "torch.ones", "torch.FloatTensor"], "function", ["None"], ["def", "_demo_mm_inputs", "(", "num_kernels", "=", "0", ",", "input_shape", "=", "(", "1", ",", "3", ",", "300", ",", "300", ")", ",", "\n", "num_items", "=", "None", ")", ":", "# yapf: disable", "\n", "    ", "\"\"\"Create a superset of inputs needed to run test or train batches.\n\n    Args:\n        input_shape (tuple): Input batch dimensions.\n\n        num_items (None | list[int]): Specifies the number of boxes\n            for each batch item.\n    \"\"\"", "\n", "\n", "(", "N", ",", "C", ",", "H", ",", "W", ")", "=", "input_shape", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "0", ")", "\n", "imgs", "=", "rng", ".", "rand", "(", "*", "input_shape", ")", "\n", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'ori_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'pad_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "}", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "relations", "=", "[", "torch", ".", "randn", "(", "10", ",", "10", ",", "5", ")", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "texts", "=", "[", "torch", ".", "ones", "(", "10", ",", "16", ")", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "gt_bboxes", "=", "[", "torch", ".", "Tensor", "(", "[", "[", "2", ",", "2", ",", "4", ",", "4", "]", "]", ")", ".", "expand", "(", "10", ",", "4", ")", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "gt_labels", "=", "[", "torch", ".", "ones", "(", "10", ",", "11", ")", ".", "long", "(", ")", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "\n", "mm_inputs", "=", "{", "\n", "'imgs'", ":", "torch", ".", "FloatTensor", "(", "imgs", ")", ".", "requires_grad_", "(", "True", ")", ",", "\n", "'img_metas'", ":", "img_metas", ",", "\n", "'relations'", ":", "relations", ",", "\n", "'texts'", ":", "texts", ",", "\n", "'gt_bboxes'", ":", "gt_bboxes", ",", "\n", "'gt_labels'", ":", "gt_labels", "\n", "}", "\n", "return", "mm_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_kie_config._get_config_directory": [[47, 60], ["os.path.join", "os.path.dirname", "os.path.exists", "Exception", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "function", ["None"], ["", "def", "_get_config_directory", "(", ")", ":", "\n", "    ", "\"\"\"Find the predefined detector config directory.\"\"\"", "\n", "try", ":", "\n", "# Assume we are running in the source mmocr repo", "\n", "        ", "repo_dpath", "=", "dirname", "(", "dirname", "(", "dirname", "(", "__file__", ")", ")", ")", "\n", "", "except", "NameError", ":", "\n", "# For IPython development when this __file__ is not defined", "\n", "        ", "import", "mmocr", "\n", "repo_dpath", "=", "dirname", "(", "dirname", "(", "mmocr", ".", "__file__", ")", ")", "\n", "", "config_dpath", "=", "join", "(", "repo_dpath", ",", "'configs'", ")", "\n", "if", "not", "exists", "(", "config_dpath", ")", ":", "\n", "        ", "raise", "Exception", "(", "'Cannot find config path'", ")", "\n", "", "return", "config_dpath", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_kie_config._get_config_module": [[62, 69], ["test_kie_config._get_config_directory", "os.path.join", "Config.fromfile"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_directory"], ["", "def", "_get_config_module", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Load a configuration as a python module.\"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "config_dpath", "=", "_get_config_directory", "(", ")", "\n", "config_fpath", "=", "join", "(", "config_dpath", ",", "fname", ")", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "config_fpath", ")", "\n", "return", "config_mod", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_kie_config._get_detector_cfg": [[71, 81], ["test_kie_config._get_config_module", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_module"], ["", "def", "_get_detector_cfg", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Grab configs necessary to create a detector.\n\n    These are deep copied to allow for safe modification of parameters without\n    influencing other tests.\n    \"\"\"", "\n", "config", "=", "_get_config_module", "(", "fname", ")", "\n", "config", ".", "model", ".", "class_list", "=", "None", "\n", "model", "=", "copy", ".", "deepcopy", "(", "config", ".", "model", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_kie_config.test_sdmgr_pipeline": [[83, 132], ["pytest.mark.parametrize", "test_kie_config._get_detector_cfg", "build_detector", "test_kie_config._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "numpy.random.rand", "build_detector.show_result", "torch.no_grad", "range", "torch.randn", "len", "build_detector.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'kie/sdmgr/sdmgr_novisual_60e_wildreceipt.py'", ",", "\n", "'kie/sdmgr/sdmgr_unet16_60e_wildreceipt.py'", "\n", "]", ")", "\n", "def", "test_sdmgr_pipeline", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "128", ",", "128", ")", "\n", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "0", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "relations", "=", "mm_inputs", ".", "pop", "(", "'relations'", ")", "\n", "texts", "=", "mm_inputs", ".", "pop", "(", "'texts'", ")", "\n", "gt_bboxes", "=", "mm_inputs", ".", "pop", "(", "'gt_bboxes'", ")", "\n", "gt_labels", "=", "mm_inputs", ".", "pop", "(", "'gt_labels'", ")", "\n", "\n", "# Test forward train", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "relations", "=", "relations", ",", "\n", "texts", "=", "texts", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "batch_results", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "img_metas", ")", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "\n", "imgs", "[", "idx", ":", "idx", "+", "1", "]", ",", "\n", "None", ",", "\n", "return_loss", "=", "False", ",", "\n", "relations", "=", "[", "relations", "[", "idx", "]", "]", ",", "\n", "texts", "=", "[", "texts", "[", "idx", "]", "]", ",", "\n", "gt_bboxes", "=", "[", "gt_bboxes", "[", "idx", "]", "]", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test show_result", "\n", "", "", "results", "=", "{", "'nodes'", ":", "torch", ".", "randn", "(", "1", ",", "3", ")", "}", "\n", "boxes", "=", "[", "[", "1", ",", "1", ",", "2", ",", "1", ",", "2", ",", "2", ",", "1", ",", "2", "]", "]", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ",", "3", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ",", "boxes", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_targets.test_invalid_polys": [[7, 34], ["mmocr.datasets.pipelines.textdet_targets.dbnet_targets.DBNetTargets", "numpy.array", "mmocr.datasets.pipelines.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "numpy.array", "mmocr.datasets.pipelines.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "numpy.array", "mmocr.datasets.pipelines.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "numpy.array", "mmocr.datasets.pipelines.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "numpy.array", "mmocr.datasets.pipelines.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.textdet_targets.dbnet_targets.DBNetTargets.invalid_polygon"], ["def", "test_invalid_polys", "(", ")", ":", "\n", "\n", "    ", "dbtarget", "=", "DBNetTargets", "(", ")", "\n", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "256.1229216", ",", "347.17471155", "]", ",", "[", "257.63126133", ",", "347.0069367", "]", ",", "\n", "[", "257.70317729", ",", "347.65337423", "]", ",", "\n", "[", "256.19488113", ",", "347.82114909", "]", "]", ")", "\n", "\n", "assert", "dbtarget", ".", "invalid_polygon", "(", "poly", ")", "\n", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "570.34735492", ",", "\n", "335.00214526", "]", ",", "[", "570.99778839", ",", "335.00327318", "]", ",", "\n", "[", "569.69077318", ",", "338.47009908", "]", ",", "\n", "[", "569.04038393", ",", "338.46894904", "]", "]", ")", "\n", "assert", "dbtarget", ".", "invalid_polygon", "(", "poly", ")", "\n", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "481.18343777", ",", "\n", "305.03190065", "]", ",", "[", "479.88478587", ",", "305.10684512", "]", ",", "\n", "[", "479.90976971", ",", "305.53968843", "]", ",", "[", "480.99197962", ",", "\n", "305.4772347", "]", "]", ")", "\n", "assert", "dbtarget", ".", "invalid_polygon", "(", "poly", ")", "\n", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "2", ",", "0", "]", ",", "[", "2", ",", "2", "]", ",", "[", "0", ",", "2", "]", "]", ")", "\n", "assert", "dbtarget", ".", "invalid_polygon", "(", "poly", ")", "\n", "\n", "poly", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "10", ",", "0", "]", ",", "[", "10", ",", "10", "]", ",", "[", "0", ",", "10", "]", "]", ")", "\n", "assert", "not", "dbtarget", ".", "invalid_polygon", "(", "poly", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ner_model._create_dummy_vocab_file": [[12, 16], ["open", "list", "map", "fw.write", "range", "ord", "ord"], "function", ["None"], ["def", "_create_dummy_vocab_file", "(", "vocab_file", ")", ":", "\n", "    ", "with", "open", "(", "vocab_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "char", "in", "list", "(", "map", "(", "chr", ",", "range", "(", "ord", "(", "'a'", ")", ",", "ord", "(", "'z'", ")", "+", "1", ")", ")", ")", ":", "\n", "            ", "fw", ".", "write", "(", "char", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ner_model._get_config_module": [[18, 23], ["Config.fromfile"], "function", ["None"], ["", "", "", "def", "_get_config_module", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Load a configuration as a python module.\"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "fname", ")", "\n", "return", "config_mod", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ner_model._get_detector_cfg": [[25, 34], ["test_ner_model._get_config_module", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_module"], ["", "def", "_get_detector_cfg", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Grab configs necessary to create a detector.\n\n    These are deep copied to allow for safe modification of parameters without\n    influencing other tests.\n    \"\"\"", "\n", "config", "=", "_get_config_module", "(", "fname", ")", "\n", "model", "=", "copy", ".", "deepcopy", "(", "config", ".", "model", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ner_model.test_bert_softmax": [[36, 79], ["pytest.mark.parametrize", "tempfile.TemporaryDirectory", "os.join", "test_ner_model._create_dummy_vocab_file", "test_ner_model._get_detector_cfg", "mmocr.models.build_detector", "mmocr.models.build_detector.forward", "isinstance", "mmocr.models.build_detector", "mmocr.models.build_detector.forward", "isinstance", "tempfile.TemporaryDirectory.cleanup", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.no_grad", "mmocr.models.build_detector.forward", "batch_results.append", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ner_model._create_dummy_vocab_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "[", "'configs/ner/bert_softmax/bert_softmax_cluener_18e.py'", "]", ")", "\n", "def", "test_bert_softmax", "(", "cfg_file", ")", ":", "\n", "# prepare data", "\n", "    ", "texts", "=", "[", "'\u4e2d'", "]", "*", "47", "\n", "img", "=", "[", "31", "]", "*", "47", "\n", "labels", "=", "[", "31", "]", "*", "128", "\n", "input_ids", "=", "[", "0", "]", "*", "128", "\n", "attention_mask", "=", "[", "0", "]", "*", "128", "\n", "token_type_ids", "=", "[", "0", "]", "*", "128", "\n", "img_metas", "=", "{", "\n", "'texts'", ":", "texts", ",", "\n", "'labels'", ":", "torch", ".", "tensor", "(", "labels", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'img'", ":", "img", ",", "\n", "'input_ids'", ":", "torch", ".", "tensor", "(", "input_ids", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'attention_masks'", ":", "torch", ".", "tensor", "(", "attention_mask", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "'token_type_ids'", ":", "torch", ".", "tensor", "(", "token_type_ids", ")", ".", "unsqueeze", "(", "0", ")", "\n", "}", "\n", "\n", "# create dummy data", "\n", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "vocab_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_vocab.txt'", ")", "\n", "_create_dummy_vocab_file", "(", "vocab_file", ")", "\n", "\n", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'label_convertor'", "]", "[", "'vocab_file'", "]", "=", "vocab_file", "\n", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "losses", "=", "detector", ".", "forward", "(", "img", ",", "img_metas", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "model", "[", "'loss'", "]", "[", "'type'", "]", "=", "'MaskedFocalLoss'", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "losses", "=", "detector", ".", "forward", "(", "img", ",", "img_metas", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "batch_results", "=", "[", "]", "\n", "result", "=", "detector", ".", "forward", "(", "None", ",", "img_metas", ",", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config._demo_mm_inputs": [[10, 41], ["numpy.random.RandomState", "np.random.RandomState.rand", "torch.FloatTensor().requires_grad_", "range", "torch.FloatTensor"], "function", ["None"], ["def", "_demo_mm_inputs", "(", "num_kernels", "=", "0", ",", "input_shape", "=", "(", "1", ",", "3", ",", "300", ",", "300", ")", ",", "\n", "num_items", "=", "None", ")", ":", "# yapf: disable", "\n", "    ", "\"\"\"Create a superset of inputs needed to run test or train batches.\n\n    Args:\n        input_shape (tuple): Input batch dimensions.\n\n        num_items (None | list[int]): Specifies the number of boxes\n            for each batch item.\n    \"\"\"", "\n", "\n", "(", "N", ",", "C", ",", "H", ",", "W", ")", "=", "input_shape", "\n", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "0", ")", "\n", "\n", "imgs", "=", "rng", ".", "rand", "(", "*", "input_shape", ")", "\n", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'ori_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'resize_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "'text'", ":", "'hello'", ",", "\n", "'valid_ratio'", ":", "1.0", ",", "\n", "}", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "\n", "mm_inputs", "=", "{", "\n", "'imgs'", ":", "torch", ".", "FloatTensor", "(", "imgs", ")", ".", "requires_grad_", "(", "True", ")", ",", "\n", "'img_metas'", ":", "img_metas", "\n", "}", "\n", "return", "mm_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config._demo_gt_kernel_inputs": [[43, 66], ["range", "range", "gt_kernels.append", "numpy.random.rand", "kernels.append", "BitmapMasks"], "function", ["None"], ["", "def", "_demo_gt_kernel_inputs", "(", "num_kernels", "=", "3", ",", "input_shape", "=", "(", "1", ",", "3", ",", "300", ",", "300", ")", ",", "\n", "num_items", "=", "None", ")", ":", "# yapf: disable", "\n", "    ", "\"\"\"Create a superset of inputs needed to run test or train batches.\n\n    Args:\n        input_shape (tuple): Input batch dimensions.\n\n        num_items (None | list[int]): Specifies the number of boxes\n            for each batch item.\n    \"\"\"", "\n", "from", "mmdet", ".", "core", "import", "BitmapMasks", "\n", "\n", "(", "N", ",", "C", ",", "H", ",", "W", ")", "=", "input_shape", "\n", "gt_kernels", "=", "[", "]", "\n", "\n", "for", "batch_idx", "in", "range", "(", "N", ")", ":", "\n", "        ", "kernels", "=", "[", "]", "\n", "for", "kernel_inx", "in", "range", "(", "num_kernels", ")", ":", "\n", "            ", "kernel", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ")", "\n", "kernels", ".", "append", "(", "kernel", ")", "\n", "", "gt_kernels", ".", "append", "(", "BitmapMasks", "(", "kernels", ",", "H", ",", "W", ")", ")", "\n", "\n", "", "return", "gt_kernels", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config._get_config_directory": [[68, 81], ["os.path.join", "os.path.dirname", "os.path.exists", "Exception", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "function", ["None"], ["", "def", "_get_config_directory", "(", ")", ":", "\n", "    ", "\"\"\"Find the predefined detector config directory.\"\"\"", "\n", "try", ":", "\n", "# Assume we are running in the source mmocr repo", "\n", "        ", "repo_dpath", "=", "dirname", "(", "dirname", "(", "dirname", "(", "__file__", ")", ")", ")", "\n", "", "except", "NameError", ":", "\n", "# For IPython development when this __file__ is not defined", "\n", "        ", "import", "mmocr", "\n", "repo_dpath", "=", "dirname", "(", "dirname", "(", "mmocr", ".", "__file__", ")", ")", "\n", "", "config_dpath", "=", "join", "(", "repo_dpath", ",", "'configs'", ")", "\n", "if", "not", "exists", "(", "config_dpath", ")", ":", "\n", "        ", "raise", "Exception", "(", "'Cannot find config path'", ")", "\n", "", "return", "config_dpath", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config._get_config_module": [[83, 90], ["test_recog_config._get_config_directory", "os.path.join", "Config.fromfile"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_directory"], ["", "def", "_get_config_module", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Load a configuration as a python module.\"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "config_dpath", "=", "_get_config_directory", "(", ")", "\n", "config_fpath", "=", "join", "(", "config_dpath", ",", "fname", ")", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "config_fpath", ")", "\n", "return", "config_mod", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config._get_detector_cfg": [[92, 101], ["test_recog_config._get_config_module", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_module"], ["", "def", "_get_detector_cfg", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Grab configs necessary to create a detector.\n\n    These are deep copied to allow for safe modification of parameters without\n    influencing other tests.\n    \"\"\"", "\n", "config", "=", "_get_config_module", "(", "fname", ")", "\n", "model", "=", "copy", ".", "deepcopy", "(", "config", ".", "model", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config.test_recognizer_pipeline": [[103, 158], ["pytest.mark.parametrize", "test_recog_config._get_detector_cfg", "build_detector", "test_recog_config._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "isinstance", "numpy.random.rand", "build_detector.show_result", "test_recog_config._demo_gt_kernel_inputs", "build_detector.forward", "build_detector.forward", "torch.no_grad", "zip", "build_detector.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_recog_config._demo_gt_kernel_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'textrecog/sar/sar_r31_parallel_decoder_academic.py'", ",", "\n", "'textrecog/sar/sar_r31_parallel_decoder_toy_dataset.py'", ",", "\n", "'textrecog/sar/sar_r31_sequential_decoder_academic.py'", ",", "\n", "'textrecog/crnn/crnn_toy_dataset.py'", ",", "\n", "'textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "'textrecog/nrtr/nrtr_r31_1by16_1by8_academic.py'", ",", "\n", "'textrecog/nrtr/nrtr_modality_transform_academic.py'", ",", "\n", "'textrecog/nrtr/nrtr_modality_transform_toy_dataset.py'", ",", "\n", "'textrecog/nrtr/nrtr_r31_1by8_1by4_academic.py'", ",", "\n", "'textrecog/robust_scanner/robustscanner_r31_academic.py'", ",", "\n", "'textrecog/seg/seg_r31_1by16_fpnocr_academic.py'", ",", "\n", "'textrecog/seg/seg_r31_1by16_fpnocr_toy_dataset.py'", ",", "\n", "'textrecog/satrn/satrn_academic.py'", ",", "'textrecog/satrn/satrn_small.py'", ",", "\n", "'textrecog/tps/crnn_tps_academic_dataset.py'", "\n", "]", ")", "\n", "def", "test_recognizer_pipeline", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "32", ",", "160", ")", "\n", "if", "'crnn'", "in", "cfg_file", ":", "\n", "        ", "input_shape", "=", "(", "1", ",", "1", ",", "32", ",", "160", ")", "\n", "", "mm_inputs", "=", "_demo_mm_inputs", "(", "0", ",", "input_shape", ")", "\n", "gt_kernels", "=", "None", "\n", "if", "'seg'", "in", "cfg_file", ":", "\n", "        ", "gt_kernels", "=", "_demo_gt_kernel_inputs", "(", "3", ",", "input_shape", ")", "\n", "\n", "", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "\n", "# Test forward train", "\n", "if", "'seg'", "in", "cfg_file", ":", "\n", "        ", "losses", "=", "detector", ".", "forward", "(", "imgs", ",", "img_metas", ",", "gt_kernels", "=", "gt_kernels", ")", "\n", "", "else", ":", "\n", "        ", "losses", "=", "detector", ".", "forward", "(", "imgs", ",", "img_metas", ")", "\n", "", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test show_result", "\n", "\n", "", "", "results", "=", "{", "'text'", ":", "'hello'", ",", "'score'", ":", "1.0", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ",", "3", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_head.test_seg_head": [[8, 18], ["mmocr.models.textrecog.SegHead", "mmocr.models.textrecog.SegHead.", "pytest.raises", "mmocr.models.textrecog.SegHead", "pytest.raises", "mmocr.models.textrecog.SegHead", "torch.rand", "torch.Size"], "function", ["None"], ["def", "test_seg_head", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegHead", "(", "num_classes", "=", "'100'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SegHead", "(", "num_classes", "=", "-", "1", ")", "\n", "\n", "", "seg_head", "=", "SegHead", "(", "num_classes", "=", "37", ")", "\n", "out_neck", "=", "(", "torch", ".", "rand", "(", "1", ",", "128", ",", "32", ",", "32", ")", ",", ")", "\n", "out_head", "=", "seg_head", "(", "out_neck", ")", "\n", "assert", "out_head", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "37", ",", "32", ",", "32", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_fuser.test_base_alignment": [[7, 13], ["mmocr.models.textrecog.fusers.ABIFuser", "torch.randn", "torch.randn", "mmocr.models.textrecog.fusers.ABIFuser.", "torch.Size"], "function", ["None"], ["def", "test_base_alignment", "(", ")", ":", "\n", "    ", "model", "=", "ABIFuser", "(", "d_model", "=", "512", ",", "num_chars", "=", "90", ",", "max_seq_len", "=", "40", ")", "\n", "l_feat", "=", "torch", ".", "randn", "(", "1", ",", "40", ",", "512", ")", "\n", "v_feat", "=", "torch", ".", "randn", "(", "1", ",", "40", ",", "512", ")", "\n", "result", "=", "model", "(", "l_feat", ",", "v_feat", ")", "\n", "assert", "result", "[", "'logits'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "40", ",", "90", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_encoder.test_sar_encoder": [[10, 35], ["mmocr.models.textrecog.encoders.SAREncoder", "mmocr.models.textrecog.encoders.SAREncoder.init_weights", "mmocr.models.textrecog.encoders.SAREncoder.train", "torch.randn", "mmocr.models.textrecog.encoders.SAREncoder.", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder", "pytest.raises", "mmocr.models.textrecog.encoders.SAREncoder.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["def", "test_sar_encoder", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SAREncoder", "(", "enc_bi_rnn", "=", "'bi'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SAREncoder", "(", "enc_do_rnn", "=", "2", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SAREncoder", "(", "enc_gru", "=", "'gru'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SAREncoder", "(", "d_model", "=", "512.5", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SAREncoder", "(", "d_enc", "=", "200.5", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "SAREncoder", "(", "mask", "=", "'mask'", ")", "\n", "\n", "", "encoder", "=", "SAREncoder", "(", ")", "\n", "encoder", ".", "init_weights", "(", ")", "\n", "encoder", ".", "train", "(", ")", "\n", "\n", "feat", "=", "torch", ".", "randn", "(", "1", ",", "512", ",", "4", ",", "40", ")", "\n", "img_metas", "=", "[", "{", "'valid_ratio'", ":", "1.0", "}", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "encoder", "(", "feat", ",", "img_metas", "*", "2", ")", "\n", "", "out_enc", "=", "encoder", "(", "feat", ",", "img_metas", ")", "\n", "\n", "assert", "out_enc", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_encoder.test_nrtr_encoder": [[37, 46], ["mmocr.models.textrecog.encoders.NRTREncoder", "mmocr.models.textrecog.encoders.NRTREncoder.init_weights", "mmocr.models.textrecog.encoders.NRTREncoder.train", "torch.randn", "mmocr.models.textrecog.encoders.NRTREncoder.", "print", "tf_encoder.size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_nrtr_encoder", "(", ")", ":", "\n", "    ", "tf_encoder", "=", "NRTREncoder", "(", ")", "\n", "tf_encoder", ".", "init_weights", "(", ")", "\n", "tf_encoder", ".", "train", "(", ")", "\n", "\n", "feat", "=", "torch", ".", "randn", "(", "1", ",", "512", ",", "1", ",", "25", ")", "\n", "out_enc", "=", "tf_encoder", "(", "feat", ")", "\n", "print", "(", "'hello'", ",", "out_enc", ".", "size", "(", ")", ")", "\n", "assert", "out_enc", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "25", ",", "512", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_encoder.test_satrn_encoder": [[48, 56], ["mmocr.models.textrecog.encoders.SatrnEncoder", "mmocr.models.textrecog.encoders.SatrnEncoder.init_weights", "mmocr.models.textrecog.encoders.SatrnEncoder.train", "torch.randn", "mmocr.models.textrecog.encoders.SatrnEncoder.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_satrn_encoder", "(", ")", ":", "\n", "    ", "satrn_encoder", "=", "SatrnEncoder", "(", ")", "\n", "satrn_encoder", ".", "init_weights", "(", ")", "\n", "satrn_encoder", ".", "train", "(", ")", "\n", "\n", "feat", "=", "torch", ".", "randn", "(", "1", ",", "512", ",", "8", ",", "25", ")", "\n", "out_enc", "=", "satrn_encoder", "(", "feat", ")", "\n", "assert", "out_enc", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "200", ",", "512", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_encoder.test_base_encoder": [[58, 66], ["mmocr.models.textrecog.encoders.BaseEncoder", "mmocr.models.textrecog.encoders.BaseEncoder.init_weights", "mmocr.models.textrecog.encoders.BaseEncoder.train", "torch.randn", "mmocr.models.textrecog.encoders.BaseEncoder.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_base_encoder", "(", ")", ":", "\n", "    ", "encoder", "=", "BaseEncoder", "(", ")", "\n", "encoder", ".", "init_weights", "(", ")", "\n", "encoder", ".", "train", "(", ")", "\n", "\n", "feat", "=", "torch", ".", "randn", "(", "1", ",", "256", ",", "4", ",", "40", ")", "\n", "out_enc", "=", "encoder", "(", "feat", ")", "\n", "assert", "out_enc", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "4", ",", "40", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_encoder.test_transformer_encoder": [[68, 72], ["mmocr.models.textrecog.encoders.TransformerEncoder", "torch.randn", "torch.Size", "mmocr.models.textrecog.encoders.TransformerEncoder."], "function", ["None"], ["", "def", "test_transformer_encoder", "(", ")", ":", "\n", "    ", "model", "=", "TransformerEncoder", "(", ")", "\n", "x", "=", "torch", ".", "randn", "(", "10", ",", "512", ",", "8", ",", "32", ")", "\n", "assert", "model", "(", "x", ")", ".", "shape", "==", "torch", ".", "Size", "(", "[", "10", ",", "512", ",", "8", ",", "32", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_encoder.test_abi_vision_model": [[74, 82], ["mmocr.models.textrecog.encoders.ABIVisionModel", "torch.randn", "mmocr.models.textrecog.encoders.ABIVisionModel.", "torch.Size", "torch.Size", "torch.Size", "dict"], "function", ["None"], ["", "def", "test_abi_vision_model", "(", ")", ":", "\n", "    ", "model", "=", "ABIVisionModel", "(", "\n", "decoder", "=", "dict", "(", "type", "=", "'ABIVisionDecoder'", ",", "max_seq_len", "=", "10", ",", "use_result", "=", "None", ")", ")", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "512", ",", "8", ",", "32", ")", "\n", "result", "=", "model", "(", "x", ")", "\n", "assert", "result", "[", "'feature'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "10", ",", "512", "]", ")", "\n", "assert", "result", "[", "'logits'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "10", ",", "90", "]", ")", "\n", "assert", "result", "[", "'attn_scores'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "10", ",", "8", ",", "32", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_neck.test_fpn_ocr": [[7, 19], ["torch.rand", "torch.rand", "torch.rand", "torch.rand", "mmocr.models.textrecog.necks.FPNOCR", "mmocr.models.textrecog.necks.FPNOCR.init_weights", "mmocr.models.textrecog.necks.FPNOCR.train", "mmocr.models.textrecog.necks.FPNOCR.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["def", "test_fpn_ocr", "(", ")", ":", "\n", "    ", "in_s1", "=", "torch", ".", "rand", "(", "1", ",", "128", ",", "32", ",", "256", ")", "\n", "in_s2", "=", "torch", ".", "rand", "(", "1", ",", "256", ",", "16", ",", "128", ")", "\n", "in_s3", "=", "torch", ".", "rand", "(", "1", ",", "512", ",", "8", ",", "64", ")", "\n", "in_s4", "=", "torch", ".", "rand", "(", "1", ",", "512", ",", "4", ",", "32", ")", "\n", "\n", "fpn_ocr", "=", "FPNOCR", "(", "in_channels", "=", "[", "128", ",", "256", ",", "512", ",", "512", "]", ",", "out_channels", "=", "256", ")", "\n", "fpn_ocr", ".", "init_weights", "(", ")", "\n", "fpn_ocr", ".", "train", "(", ")", "\n", "\n", "out_neck", "=", "fpn_ocr", "(", "(", "in_s1", ",", "in_s2", ",", "in_s3", ",", "in_s4", ")", ")", "\n", "assert", "out_neck", "[", "0", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "32", ",", "256", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_loss.test_panloss": [[9, 23], ["mmocr.PANLoss", "mmdet.core.BitmapMasks", "losses.PANLoss.bitmasks2tensor", "numpy.array", "len", "torch.sum().item", "torch.sum", "torch.abs", "results[].float", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor"], ["def", "test_panloss", "(", ")", ":", "\n", "    ", "panloss", "=", "losses", ".", "PANLoss", "(", ")", "\n", "\n", "# test bitmasks2tensor", "\n", "mask", "=", "[", "[", "1", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "1", "]", "]", "\n", "target", "=", "[", "[", "1", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "[", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", "\n", "masks", "=", "[", "np", ".", "array", "(", "mask", ")", "]", "\n", "bitmasks", "=", "BitmapMasks", "(", "masks", ",", "3", ",", "3", ")", "\n", "target_sz", "=", "(", "6", ",", "5", ")", "\n", "results", "=", "panloss", ".", "bitmasks2tensor", "(", "[", "bitmasks", "]", ",", "target_sz", ")", "\n", "assert", "len", "(", "results", ")", "==", "1", "\n", "assert", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "results", "[", "0", "]", ".", "float", "(", ")", "-", "\n", "torch", ".", "Tensor", "(", "target", ")", ")", ")", ".", "item", "(", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_loss.test_textsnakeloss": [[25, 35], ["mmocr.TextSnakeLoss", "torch.tensor", "torch.tensor", "torch.tensor", "losses.TextSnakeLoss.balanced_bce_loss().item", "numpy.allclose", "losses.TextSnakeLoss.balanced_bce_loss"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.textsnake_loss.TextSnakeLoss.balanced_bce_loss"], ["", "def", "test_textsnakeloss", "(", ")", ":", "\n", "    ", "textsnakeloss", "=", "losses", ".", "TextSnakeLoss", "(", ")", "\n", "\n", "# test balanced_bce_loss", "\n", "pred", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "bce_loss", "=", "textsnakeloss", ".", "balanced_bce_loss", "(", "pred", ",", "target", ",", "mask", ")", ".", "item", "(", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "bce_loss", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_loss.test_fcenetloss": [[37, 74], ["mmocr.FCELoss", "torch.ones", "torch.ones", "torch.ones", "losses.FCELoss.ohem", "losses.FCELoss.ohem", "isinstance", "isinstance", "range", "range", "losses.FCELoss.", "isinstance", "torch.ones.append", "torch.ones.append", "preds.append", "p3_maps.append", "p4_maps.append", "p5_maps.append", "torch.rand", "torch.rand", "numpy.random.random", "numpy.random.random", "numpy.random.random"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.ohem", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.fce_loss.FCELoss.ohem"], ["", "def", "test_fcenetloss", "(", ")", ":", "\n", "    ", "k", "=", "5", "\n", "fcenetloss", "=", "losses", ".", "FCELoss", "(", "fourier_degree", "=", "k", ",", "num_sample", "=", "10", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "64", ",", "64", ")", "\n", "(", "n", ",", "c", ",", "h", ",", "w", ")", "=", "input_shape", "\n", "\n", "# test ohem", "\n", "pred", "=", "torch", ".", "ones", "(", "(", "200", ",", "2", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "target", "=", "torch", ".", "ones", "(", "200", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "target", "[", "20", ":", "]", "=", "0", "\n", "mask", "=", "torch", ".", "ones", "(", "200", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "\n", "ohem_loss1", "=", "fcenetloss", ".", "ohem", "(", "pred", ",", "target", ",", "mask", ")", "\n", "ohem_loss2", "=", "fcenetloss", ".", "ohem", "(", "pred", ",", "target", ",", "1", "-", "mask", ")", "\n", "assert", "isinstance", "(", "ohem_loss1", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "ohem_loss2", ",", "torch", ".", "Tensor", ")", "\n", "\n", "# test forward", "\n", "preds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "scale", "=", "8", "*", "2", "**", "i", "\n", "pred", "=", "[", "]", "\n", "pred", ".", "append", "(", "torch", ".", "rand", "(", "n", ",", "4", ",", "h", "//", "scale", ",", "w", "//", "scale", ")", ")", "\n", "pred", ".", "append", "(", "torch", ".", "rand", "(", "n", ",", "4", "*", "k", "+", "2", ",", "h", "//", "scale", ",", "w", "//", "scale", ")", ")", "\n", "preds", ".", "append", "(", "pred", ")", "\n", "\n", "", "p3_maps", "=", "[", "]", "\n", "p4_maps", "=", "[", "]", "\n", "p5_maps", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "        ", "p3_maps", ".", "append", "(", "np", ".", "random", ".", "random", "(", "(", "5", "+", "4", "*", "k", ",", "h", "//", "8", ",", "w", "//", "8", ")", ")", ")", "\n", "p4_maps", ".", "append", "(", "np", ".", "random", ".", "random", "(", "(", "5", "+", "4", "*", "k", ",", "h", "//", "16", ",", "w", "//", "16", ")", ")", ")", "\n", "p5_maps", ".", "append", "(", "np", ".", "random", ".", "random", "(", "(", "5", "+", "4", "*", "k", ",", "h", "//", "32", ",", "w", "//", "32", ")", ")", ")", "\n", "\n", "", "loss", "=", "fcenetloss", "(", "preds", ",", "0", ",", "p3_maps", ",", "p4_maps", ",", "p5_maps", ")", "\n", "assert", "isinstance", "(", "loss", ",", "dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_loss.test_drrgloss": [[76, 147], ["mmocr.DRRGLoss", "numpy.allclose", "torch.tensor", "torch.tensor", "torch.tensor", "losses.DRRGLoss.balance_bce_loss().item", "numpy.allclose", "torch.ones", "torch.ones", "torch.zeros", "losses.DRRGLoss.balance_bce_loss().item", "numpy.allclose", "torch.tensor", "torch.tensor", "losses.DRRGLoss.gcn_loss", "drrgloss.gcn_loss.item", "mmdet.core.BitmapMasks", "losses.DRRGLoss.bitmasks2tensor", "losses.DRRGLoss.", "isinstance", "losses.DRRGLoss.", "isinstance", "losses.DRRGLoss.", "isinstance", "numpy.array", "len", "torch.sum().item", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "torch.randn", "drrgloss.keys", "drrgloss.keys", "drrgloss.keys", "drrgloss.keys", "drrgloss.keys", "drrgloss.keys", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "torch.randn", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "mmdet.core.BitmapMasks", "torch.randn", "losses.DRRGLoss.balance_bce_loss", "losses.DRRGLoss.balance_bce_loss", "torch.sum", "numpy.random.randn", "numpy.ones", "numpy.ones", "numpy.random.randn", "numpy.ones", "numpy.ones", "numpy.random.randn", "numpy.ones", "numpy.zeros", "torch.abs", "results[].float", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.gcn_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.bitmasks2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.balance_bce_loss", "home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.drrg_loss.DRRGLoss.balance_bce_loss"], ["", "def", "test_drrgloss", "(", ")", ":", "\n", "    ", "drrgloss", "=", "losses", ".", "DRRGLoss", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "drrgloss", ".", "ohem_ratio", ",", "3.0", ")", "\n", "\n", "# test balance_bce_loss", "\n", "pred", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "target", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "mask", "=", "torch", ".", "tensor", "(", "[", "[", "0", ",", "1", ",", "0", "]", ",", "[", "1", ",", "0", ",", "1", "]", ",", "[", "0", ",", "1", ",", "0", "]", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "bce_loss", "=", "drrgloss", ".", "balance_bce_loss", "(", "pred", ",", "target", ",", "mask", ")", ".", "item", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "bce_loss", ",", "0", ")", "\n", "\n", "# test balance_bce_loss with positive_count equal to zero", "\n", "pred", "=", "torch", ".", "ones", "(", "(", "16", ",", "16", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "target", "=", "torch", ".", "ones", "(", "(", "16", ",", "16", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "mask", "=", "torch", ".", "zeros", "(", "(", "16", ",", "16", ")", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "bce_loss", "=", "drrgloss", ".", "balance_bce_loss", "(", "pred", ",", "target", ",", "mask", ")", ".", "item", "(", ")", "\n", "assert", "np", ".", "allclose", "(", "bce_loss", ",", "0", ")", "\n", "\n", "# test gcn_loss", "\n", "gcn_preds", "=", "torch", ".", "tensor", "(", "[", "[", "0.", ",", "1.", "]", ",", "[", "1.", ",", "0.", "]", "]", ")", "\n", "labels", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "gcn_loss", "=", "drrgloss", ".", "gcn_loss", "(", "(", "gcn_preds", ",", "labels", ")", ")", "\n", "assert", "gcn_loss", ".", "item", "(", ")", "\n", "\n", "# test bitmasks2tensor", "\n", "mask", "=", "[", "[", "1", ",", "0", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "0", ",", "0", ",", "1", "]", "]", "\n", "target", "=", "[", "[", "1", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "[", "1", ",", "1", ",", "1", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", "\n", "masks", "=", "[", "np", ".", "array", "(", "mask", ")", "]", "\n", "bitmasks", "=", "BitmapMasks", "(", "masks", ",", "3", ",", "3", ")", "\n", "target_sz", "=", "(", "6", ",", "5", ")", "\n", "results", "=", "drrgloss", ".", "bitmasks2tensor", "(", "[", "bitmasks", "]", ",", "target_sz", ")", "\n", "assert", "len", "(", "results", ")", "==", "1", "\n", "assert", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "results", "[", "0", "]", ".", "float", "(", ")", "-", "\n", "torch", ".", "Tensor", "(", "target", ")", ")", ")", ".", "item", "(", ")", "==", "0", "\n", "\n", "# test forward", "\n", "target_maps", "=", "[", "BitmapMasks", "(", "[", "np", ".", "random", ".", "randn", "(", "20", ",", "20", ")", "]", ",", "20", ",", "20", ")", "]", "\n", "target_masks", "=", "[", "BitmapMasks", "(", "[", "np", ".", "ones", "(", "(", "20", ",", "20", ")", ")", "]", ",", "20", ",", "20", ")", "]", "\n", "gt_masks", "=", "[", "BitmapMasks", "(", "[", "np", ".", "ones", "(", "(", "20", ",", "20", ")", ")", "]", ",", "20", ",", "20", ")", "]", "\n", "preds", "=", "(", "torch", ".", "randn", "(", "(", "1", ",", "6", ",", "20", ",", "20", ")", ")", ",", "(", "gcn_preds", ",", "labels", ")", ")", "\n", "loss_dict", "=", "drrgloss", "(", "preds", ",", "1.", ",", "target_masks", ",", "target_masks", ",", "gt_masks", ",", "\n", "target_maps", ",", "target_maps", ",", "target_maps", ",", "target_maps", ")", "\n", "\n", "assert", "isinstance", "(", "loss_dict", ",", "dict", ")", "\n", "assert", "'loss_text'", "in", "loss_dict", ".", "keys", "(", ")", "\n", "assert", "'loss_center'", "in", "loss_dict", ".", "keys", "(", ")", "\n", "assert", "'loss_height'", "in", "loss_dict", ".", "keys", "(", ")", "\n", "assert", "'loss_sin'", "in", "loss_dict", ".", "keys", "(", ")", "\n", "assert", "'loss_cos'", "in", "loss_dict", ".", "keys", "(", ")", "\n", "assert", "'loss_gcn'", "in", "loss_dict", ".", "keys", "(", ")", "\n", "\n", "# test forward with downsample_ratio less than 1.", "\n", "target_maps", "=", "[", "BitmapMasks", "(", "[", "np", ".", "random", ".", "randn", "(", "40", ",", "40", ")", "]", ",", "40", ",", "40", ")", "]", "\n", "target_masks", "=", "[", "BitmapMasks", "(", "[", "np", ".", "ones", "(", "(", "40", ",", "40", ")", ")", "]", ",", "40", ",", "40", ")", "]", "\n", "gt_masks", "=", "[", "BitmapMasks", "(", "[", "np", ".", "ones", "(", "(", "40", ",", "40", ")", ")", "]", ",", "40", ",", "40", ")", "]", "\n", "preds", "=", "(", "torch", ".", "randn", "(", "(", "1", ",", "6", ",", "20", ",", "20", ")", ")", ",", "(", "gcn_preds", ",", "labels", ")", ")", "\n", "loss_dict", "=", "drrgloss", "(", "preds", ",", "0.5", ",", "target_masks", ",", "target_masks", ",", "gt_masks", ",", "\n", "target_maps", ",", "target_maps", ",", "target_maps", ",", "target_maps", ")", "\n", "\n", "assert", "isinstance", "(", "loss_dict", ",", "dict", ")", "\n", "\n", "# test forward with blank gt_mask.", "\n", "target_maps", "=", "[", "BitmapMasks", "(", "[", "np", ".", "random", ".", "randn", "(", "20", ",", "20", ")", "]", ",", "20", ",", "20", ")", "]", "\n", "target_masks", "=", "[", "BitmapMasks", "(", "[", "np", ".", "ones", "(", "(", "20", ",", "20", ")", ")", "]", ",", "20", ",", "20", ")", "]", "\n", "gt_masks", "=", "[", "BitmapMasks", "(", "[", "np", ".", "zeros", "(", "(", "20", ",", "20", ")", ")", "]", ",", "20", ",", "20", ")", "]", "\n", "preds", "=", "(", "torch", ".", "randn", "(", "(", "1", ",", "6", ",", "20", ",", "20", ")", ")", ",", "(", "gcn_preds", ",", "labels", ")", ")", "\n", "loss_dict", "=", "drrgloss", "(", "preds", ",", "1.", ",", "target_masks", ",", "target_masks", ",", "gt_masks", ",", "\n", "target_maps", ",", "target_maps", ",", "target_maps", ",", "target_maps", ")", "\n", "\n", "assert", "isinstance", "(", "loss_dict", ",", "dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_loss.test_dice_loss": [[149, 160], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "mmocr.PANLoss", "losses.PANLoss.dice_loss_with_logits", "numpy.allclose", "pan_loss.dice_loss_with_logits.item"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.pan_loss.PANLoss.dice_loss_with_logits"], ["", "def", "test_dice_loss", "(", ")", ":", "\n", "    ", "pred", "=", "torch", ".", "Tensor", "(", "[", "[", "[", "-", "1000", ",", "-", "1000", ",", "-", "1000", "]", ",", "[", "-", "1000", ",", "-", "1000", ",", "-", "1000", "]", ",", "\n", "[", "-", "1000", ",", "-", "1000", ",", "-", "1000", "]", "]", "]", ")", "\n", "target", "=", "torch", ".", "Tensor", "(", "[", "[", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", "]", ",", "[", "0", ",", "0", ",", "0", "]", "]", "]", ")", "\n", "mask", "=", "torch", ".", "Tensor", "(", "[", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", "]", "]", "]", ")", "\n", "\n", "pan_loss", "=", "losses", ".", "PANLoss", "(", ")", "\n", "\n", "dice_loss", "=", "pan_loss", ".", "dice_loss_with_logits", "(", "pred", ",", "target", ",", "mask", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "dice_loss", ".", "item", "(", ")", ",", "0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_backbone.test_resnet31_ocr_backbone": [[9, 28], ["mmocr.models.textrecog.backbones.ResNet31OCR", "mmocr.models.textrecog.backbones.ResNet31OCR.init_weights", "mmocr.models.textrecog.backbones.ResNet31OCR.train", "torch.randn", "mmocr.models.textrecog.backbones.ResNet31OCR.", "pytest.raises", "mmocr.models.textrecog.backbones.ResNet31OCR", "pytest.raises", "mmocr.models.textrecog.backbones.ResNet31OCR", "pytest.raises", "mmocr.models.textrecog.backbones.ResNet31OCR", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["def", "test_resnet31_ocr_backbone", "(", ")", ":", "\n", "    ", "\"\"\"Test resnet backbone.\"\"\"", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNet31OCR", "(", "2.5", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNet31OCR", "(", "3", ",", "layers", "=", "5", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNet31OCR", "(", "3", ",", "channels", "=", "5", ")", "\n", "\n", "# Test ResNet18 forward", "\n", "", "model", "=", "ResNet31OCR", "(", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "32", ",", "160", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "feat", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "4", ",", "40", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_backbone.test_vgg_deep_vgg_ocr_backbone": [[30, 39], ["mmocr.models.textrecog.backbones.VeryDeepVgg", "mmocr.models.textrecog.backbones.VeryDeepVgg.init_weights", "mmocr.models.textrecog.backbones.VeryDeepVgg.train", "torch.randn", "mmocr.models.textrecog.backbones.VeryDeepVgg.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_vgg_deep_vgg_ocr_backbone", "(", ")", ":", "\n", "\n", "    ", "model", "=", "VeryDeepVgg", "(", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "32", ",", "160", ")", "\n", "feats", "=", "model", "(", "imgs", ")", "\n", "assert", "feats", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "1", ",", "41", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_backbone.test_shallow_cnn_ocr_backbone": [[41, 50], ["mmocr.models.textrecog.backbones.ShallowCNN", "mmocr.models.textrecog.backbones.ShallowCNN.init_weights", "mmocr.models.textrecog.backbones.ShallowCNN.train", "torch.randn", "mmocr.models.textrecog.backbones.ShallowCNN.", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_shallow_cnn_ocr_backbone", "(", ")", ":", "\n", "\n", "    ", "model", "=", "ShallowCNN", "(", ")", "\n", "model", ".", "init_weights", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "1", ",", "32", ",", "100", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "feat", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "8", ",", "25", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_backbone.test_resnet_abi": [[52, 73], ["mmocr.models.textrecog.backbones.ResNetABI", "mmocr.models.textrecog.backbones.ResNetABI.train", "torch.randn", "mmocr.models.textrecog.backbones.ResNetABI.", "pytest.raises", "mmocr.models.textrecog.backbones.ResNetABI", "pytest.raises", "mmocr.models.textrecog.backbones.ResNetABI", "pytest.raises", "mmocr.models.textrecog.backbones.ResNetABI", "pytest.raises", "mmocr.models.textrecog.backbones.ResNetABI", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_resnet_abi", "(", ")", ":", "\n", "    ", "\"\"\"Test resnet backbone.\"\"\"", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNetABI", "(", "2.5", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNetABI", "(", "3", ",", "arch_settings", "=", "5", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNetABI", "(", "3", ",", "stem_channels", "=", "None", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ResNetABI", "(", "arch_settings", "=", "[", "3", ",", "4", ",", "6", ",", "6", "]", ",", "strides", "=", "[", "1", ",", "2", ",", "1", ",", "2", ",", "1", "]", ")", "\n", "\n", "# Test forwarding", "\n", "", "model", "=", "ResNetABI", "(", ")", "\n", "model", ".", "train", "(", ")", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "32", ",", "160", ")", "\n", "feat", "=", "model", "(", "imgs", ")", "\n", "assert", "feat", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "8", ",", "40", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_backbone.test_resnet": [[75, 159], ["mmocr.models.textrecog.backbones.ResNet", "mmocr.models.textrecog.backbones.ResNet", "mmocr.models.textrecog.backbones.ResNet", "mmocr.models.textrecog.backbones.ResNet", "torch.rand", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "dict", "dict", "dict", "dict", "mmocr.models.textrecog.backbones.ResNet.", "mmocr.models.textrecog.backbones.ResNet.", "mmocr.models.textrecog.backbones.ResNet.", "mmocr.models.textrecog.backbones.ResNet.", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict", "dict"], "function", ["None"], ["", "def", "test_resnet", "(", ")", ":", "\n", "    ", "\"\"\"Test all ResNet backbones.\"\"\"", "\n", "\n", "resnet45_aster", "=", "ResNet", "(", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "[", "64", ",", "128", "]", ",", "\n", "block_cfgs", "=", "dict", "(", "type", "=", "'BasicBlock'", ",", "use_conv1x1", "=", "'True'", ")", ",", "\n", "arch_layers", "=", "[", "3", ",", "4", ",", "6", ",", "6", ",", "3", "]", ",", "\n", "arch_channels", "=", "[", "32", ",", "64", ",", "128", ",", "256", ",", "512", "]", ",", "\n", "strides", "=", "[", "(", "2", ",", "2", ")", ",", "(", "2", ",", "2", ")", ",", "(", "2", ",", "1", ")", ",", "(", "2", ",", "1", ")", ",", "(", "2", ",", "1", ")", "]", ")", "\n", "\n", "resnet45_abi", "=", "ResNet", "(", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "32", ",", "\n", "block_cfgs", "=", "dict", "(", "type", "=", "'BasicBlock'", ",", "use_conv1x1", "=", "'True'", ")", ",", "\n", "arch_layers", "=", "[", "3", ",", "4", ",", "6", ",", "6", ",", "3", "]", ",", "\n", "arch_channels", "=", "[", "32", ",", "64", ",", "128", ",", "256", ",", "512", "]", ",", "\n", "strides", "=", "[", "2", ",", "1", ",", "2", ",", "1", ",", "1", "]", ")", "\n", "\n", "resnet_31", "=", "ResNet", "(", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "[", "64", ",", "128", "]", ",", "\n", "block_cfgs", "=", "dict", "(", "type", "=", "'BasicBlock'", ")", ",", "\n", "arch_layers", "=", "[", "1", ",", "2", ",", "5", ",", "3", "]", ",", "\n", "arch_channels", "=", "[", "256", ",", "256", ",", "512", ",", "512", "]", ",", "\n", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'Maxpool2d'", ",", "kernel_size", "=", "2", ",", "stride", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "stages", "=", "(", "True", ",", "True", ",", "False", ",", "False", ")", ",", "\n", "position", "=", "'before_stage'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'Maxpool2d'", ",", "kernel_size", "=", "(", "2", ",", "1", ")", ",", "stride", "=", "(", "2", ",", "1", ")", ")", ",", "\n", "stages", "=", "(", "False", ",", "False", ",", "True", ",", "False", ")", ",", "\n", "position", "=", "'before_stage'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "\n", "type", "=", "'ConvModule'", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", ",", "\n", "stages", "=", "(", "True", ",", "True", ",", "True", ",", "True", ")", ",", "\n", "position", "=", "'after_stage'", ")", "\n", "]", ")", "\n", "\n", "resnet31_master", "=", "ResNet", "(", "\n", "in_channels", "=", "3", ",", "\n", "stem_channels", "=", "[", "64", ",", "128", "]", ",", "\n", "block_cfgs", "=", "dict", "(", "type", "=", "'BasicBlock'", ")", ",", "\n", "arch_layers", "=", "[", "1", ",", "2", ",", "5", ",", "3", "]", ",", "\n", "arch_channels", "=", "[", "256", ",", "256", ",", "512", ",", "512", "]", ",", "\n", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "plugins", "=", "[", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'Maxpool2d'", ",", "kernel_size", "=", "2", ",", "stride", "=", "(", "2", ",", "2", ")", ")", ",", "\n", "stages", "=", "(", "True", ",", "True", ",", "False", ",", "False", ")", ",", "\n", "position", "=", "'before_stage'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'Maxpool2d'", ",", "kernel_size", "=", "(", "2", ",", "1", ")", ",", "stride", "=", "(", "2", ",", "1", ")", ")", ",", "\n", "stages", "=", "(", "False", ",", "False", ",", "True", ",", "False", ")", ",", "\n", "position", "=", "'before_stage'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "type", "=", "'GCAModule'", ",", "ratio", "=", "0.0625", ",", "n_head", "=", "1", ")", ",", "\n", "stages", "=", "[", "True", ",", "True", ",", "True", ",", "True", "]", ",", "\n", "position", "=", "'after_stage'", ")", ",", "\n", "dict", "(", "\n", "cfg", "=", "dict", "(", "\n", "type", "=", "'ConvModule'", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ")", ",", "\n", "act_cfg", "=", "dict", "(", "type", "=", "'ReLU'", ")", ")", ",", "\n", "stages", "=", "(", "True", ",", "True", ",", "True", ",", "True", ")", ",", "\n", "position", "=", "'after_stage'", ")", "\n", "]", ")", "\n", "img", "=", "torch", ".", "rand", "(", "1", ",", "3", ",", "32", ",", "100", ")", "\n", "\n", "assert", "resnet45_aster", "(", "img", ")", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "1", ",", "25", "]", ")", "\n", "assert", "resnet45_abi", "(", "img", ")", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "8", ",", "25", "]", ")", "\n", "assert", "resnet_31", "(", "img", ")", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "4", ",", "25", "]", ")", "\n", "assert", "resnet31_master", "(", "img", ")", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "512", ",", "4", ",", "25", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_textdet_head.test_drrg_head": [[8, 83], ["mmocr.models.textdet.dense_heads.DRRGHead", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "torch.randn", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.hstack", "np.stack.astype", "np.stack.copy", "numpy.stack", "mmocr.models.textdet.dense_heads.DRRGHead.", "numpy.stack().transpose", "numpy.vstack", "numpy.arange", "numpy.stack().transpose", "numpy.array", "numpy.vstack", "mmocr.models.textdet.dense_heads.DRRGHead.get_boundary", "numpy.ones", "numpy.ones", "numpy.cos", "numpy.sin", "numpy.ones", "pred_maps.size", "torch.no_grad", "torch.zeros", "mmocr.models.textdet.dense_heads.DRRGHead.out_conv.bias.data.fill_", "mmocr.models.textdet.dense_heads.DRRGHead.single_test", "all", "numpy.ones", "numpy.ones", "numpy.ones", "drrg_head.get_boundary.keys", "pred_labels.size", "pred_labels.size", "numpy.stack", "numpy.array", "numpy.stack", "numpy.array", "gt_labels.size", "gt_labels.size", "numpy.random.random_sample", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.single_test"], ["def", "test_drrg_head", "(", ")", ":", "\n", "    ", "in_channels", "=", "10", "\n", "drrg_head", "=", "DRRGHead", "(", "in_channels", ")", "\n", "assert", "drrg_head", ".", "in_channels", "==", "in_channels", "\n", "assert", "drrg_head", ".", "k_at_hops", "==", "(", "8", ",", "4", ")", "\n", "assert", "drrg_head", ".", "num_adjacent_linkages", "==", "3", "\n", "assert", "drrg_head", ".", "node_geo_feat_len", "==", "120", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "pooling_scale", ",", "1.0", ")", "\n", "assert", "drrg_head", ".", "pooling_output_size", "==", "(", "4", ",", "3", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "nms_thr", ",", "0.3", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "min_width", ",", "8.0", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "max_width", ",", "24.0", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "comp_shrink_ratio", ",", "1.03", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "comp_ratio", ",", "0.4", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "comp_score_thr", ",", "0.3", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "text_region_thr", ",", "0.2", ")", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "center_region_thr", ",", "0.2", ")", "\n", "assert", "drrg_head", ".", "center_region_area_thr", "==", "50", "\n", "assert", "np", ".", "allclose", "(", "drrg_head", ".", "local_graph_thr", ",", "0.7", ")", "\n", "\n", "# test forward train", "\n", "num_rois", "=", "16", "\n", "feature_maps", "=", "torch", ".", "randn", "(", "(", "2", ",", "10", ",", "128", ",", "128", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "x", "=", "np", ".", "random", ".", "randint", "(", "4", ",", "124", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randint", "(", "4", ",", "124", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "h", "=", "4", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "w", "=", "4", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "angle", "=", "(", "np", ".", "random", ".", "random_sample", "(", "(", "num_rois", ",", "1", ")", ")", "*", "2", "-", "1", ")", "*", "np", ".", "pi", "/", "2", "\n", "cos", ",", "sin", "=", "np", ".", "cos", "(", "angle", ")", ",", "np", ".", "sin", "(", "angle", ")", "\n", "comp_labels", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "3", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "num_rois", "=", "num_rois", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "comp_attribs", "=", "np", ".", "hstack", "(", "[", "num_rois", ",", "x", ",", "y", ",", "h", ",", "w", ",", "cos", ",", "sin", ",", "comp_labels", "]", ")", "\n", "comp_attribs", "=", "comp_attribs", ".", "astype", "(", "np", ".", "float32", ")", "\n", "comp_attribs_", "=", "comp_attribs", ".", "copy", "(", ")", "\n", "comp_attribs", "=", "np", ".", "stack", "(", "[", "comp_attribs", ",", "comp_attribs_", "]", ")", "\n", "pred_maps", ",", "gcn_data", "=", "drrg_head", "(", "feature_maps", ",", "comp_attribs", ")", "\n", "pred_labels", ",", "gt_labels", "=", "gcn_data", "\n", "assert", "pred_maps", ".", "size", "(", ")", "==", "(", "2", ",", "6", ",", "128", ",", "128", ")", "\n", "assert", "pred_labels", ".", "ndim", "==", "gt_labels", ".", "ndim", "==", "2", "\n", "assert", "gt_labels", ".", "size", "(", ")", "[", "0", "]", "*", "gt_labels", ".", "size", "(", ")", "[", "1", "]", "==", "pred_labels", ".", "size", "(", ")", "[", "0", "]", "\n", "assert", "pred_labels", ".", "size", "(", ")", "[", "1", "]", "==", "2", "\n", "\n", "# test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "feat_maps", "=", "torch", ".", "zeros", "(", "(", "1", ",", "10", ",", "128", ",", "128", ")", ")", "\n", "drrg_head", ".", "out_conv", ".", "bias", ".", "data", ".", "fill_", "(", "-", "10", ")", "\n", "preds", "=", "drrg_head", ".", "single_test", "(", "feat_maps", ")", "\n", "assert", "all", "(", "[", "pred", "is", "None", "for", "pred", "in", "preds", "]", ")", "\n", "\n", "# test get_boundary", "\n", "", "edges", "=", "np", ".", "stack", "(", "[", "np", ".", "arange", "(", "0", ",", "10", ")", ",", "np", ".", "arange", "(", "1", ",", "11", ")", "]", ")", ".", "transpose", "(", ")", "\n", "edges", "=", "np", ".", "vstack", "(", "[", "edges", ",", "np", ".", "array", "(", "[", "1", ",", "0", "]", ")", "]", ")", "\n", "scores", "=", "np", ".", "ones", "(", "11", ",", "dtype", "=", "np", ".", "float32", ")", "*", "0.9", "\n", "x1", "=", "np", ".", "arange", "(", "2", ",", "22", ",", "2", ")", "\n", "x2", "=", "x1", "+", "2", "\n", "y1", "=", "np", ".", "ones", "(", "10", ")", "*", "2", "\n", "y2", "=", "y1", "+", "2", "\n", "comp_scores", "=", "np", ".", "ones", "(", "10", ",", "dtype", "=", "np", ".", "float32", ")", "*", "0.9", "\n", "text_comps", "=", "np", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y1", ",", "x2", ",", "y2", ",", "x1", ",", "y2", ",", "\n", "comp_scores", "]", ")", ".", "transpose", "(", ")", "\n", "outlier", "=", "np", ".", "array", "(", "[", "50", ",", "50", ",", "52", ",", "50", ",", "52", ",", "52", ",", "50", ",", "52", ",", "0.9", "]", ")", "\n", "text_comps", "=", "np", ".", "vstack", "(", "[", "text_comps", ",", "outlier", "]", ")", "\n", "\n", "(", "C", ",", "H", ",", "W", ")", "=", "(", "10", ",", "128", ",", "128", ")", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'ori_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'pad_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "'scale_factor'", ":", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", ",", "\n", "'flip'", ":", "False", ",", "\n", "}", "]", "\n", "results", "=", "drrg_head", ".", "get_boundary", "(", "\n", "edges", ",", "scores", ",", "text_comps", ",", "img_metas", ",", "rescale", "=", "True", ")", "\n", "assert", "'boundary_result'", "in", "results", ".", "keys", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder._create_dummy_input": [[16, 23], ["torch.rand", "torch.rand", "torch.LongTensor"], "function", ["None"], ["def", "_create_dummy_input", "(", ")", ":", "\n", "    ", "feat", "=", "torch", ".", "rand", "(", "1", ",", "512", ",", "4", ",", "40", ")", "\n", "out_enc", "=", "torch", ".", "rand", "(", "1", ",", "512", ")", "\n", "tgt_dict", "=", "{", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", ",", "36", "]", "]", ")", "}", "\n", "img_metas", "=", "[", "{", "'valid_ratio'", ":", "1.0", "}", "]", "\n", "\n", "return", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_base_decoder": [[25, 31], ["mmocr.models.textrecog.decoders.BaseDecoder", "pytest.raises", "mmocr.models.textrecog.decoders.BaseDecoder.forward_train", "pytest.raises", "mmocr.models.textrecog.decoders.BaseDecoder.forward_test"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.deploy_utils.TensorRTRecognizer.forward_train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_test"], ["", "def", "test_base_decoder", "(", ")", ":", "\n", "    ", "decoder", "=", "BaseDecoder", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "decoder", ".", "forward_train", "(", "None", ",", "None", ",", "None", ",", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "decoder", ".", "forward_test", "(", "None", ",", "None", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_parallel_sar_decoder": [[33, 50], ["mmocr.models.textrecog.decoders.ParallelSARDecoder", "mmocr.models.textrecog.decoders.ParallelSARDecoder.init_weights", "mmocr.models.textrecog.decoders.ParallelSARDecoder.train", "test_ocr_decoder._create_dummy_input", "mmocr.models.textrecog.decoders.ParallelSARDecoder.", "mmocr.models.textrecog.decoders.ParallelSARDecoder.", "pytest.raises", "mmocr.models.textrecog.decoders.ParallelSARDecoder.", "pytest.raises", "mmocr.models.textrecog.decoders.ParallelSARDecoder.", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder._create_dummy_input"], ["", "", "def", "test_parallel_sar_decoder", "(", ")", ":", "\n", "# test parallel sar decoder", "\n", "    ", "decoder", "=", "ParallelSARDecoder", "(", "num_classes", "=", "37", ",", "padding_idx", "=", "36", ",", "max_seq_len", "=", "5", ")", "\n", "decoder", ".", "init_weights", "(", ")", "\n", "decoder", ".", "train", "(", ")", "\n", "\n", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "=", "_create_dummy_input", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "[", "]", ",", "True", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "*", "2", ",", "True", ")", "\n", "\n", "", "out_train", "=", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "True", ")", "\n", "assert", "out_train", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n", "out_test", "=", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "False", ")", "\n", "assert", "out_test", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_sequential_sar_decoder": [[52, 70], ["mmocr.models.textrecog.decoders.SequentialSARDecoder", "mmocr.models.textrecog.decoders.SequentialSARDecoder.init_weights", "mmocr.models.textrecog.decoders.SequentialSARDecoder.train", "test_ocr_decoder._create_dummy_input", "mmocr.models.textrecog.decoders.SequentialSARDecoder.", "mmocr.models.textrecog.decoders.SequentialSARDecoder.", "pytest.raises", "mmocr.models.textrecog.decoders.SequentialSARDecoder.", "pytest.raises", "mmocr.models.textrecog.decoders.SequentialSARDecoder.", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder._create_dummy_input"], ["", "def", "test_sequential_sar_decoder", "(", ")", ":", "\n", "# test parallel sar decoder", "\n", "    ", "decoder", "=", "SequentialSARDecoder", "(", "\n", "num_classes", "=", "37", ",", "padding_idx", "=", "36", ",", "max_seq_len", "=", "5", ")", "\n", "decoder", ".", "init_weights", "(", ")", "\n", "decoder", ".", "train", "(", ")", "\n", "\n", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "=", "_create_dummy_input", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "*", "2", ")", "\n", "\n", "", "out_train", "=", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "True", ")", "\n", "assert", "out_train", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n", "out_test", "=", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "False", ")", "\n", "assert", "out_test", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_parallel_sar_decoder_with_beam_search": [[72, 100], ["test_ocr_decoder._create_dummy_input", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS.init_weights", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS.train", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS.", "mmocr.models.textrecog.decoders.sar_decoder_with_bs.DecodeNode", "math.isclose", "pytest.raises", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS", "pytest.raises", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS", "pytest.raises", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS.", "pytest.raises", "mmocr.models.textrecog.decoders.ParallelSARDecoderWithBS.", "torch.Size", "pytest.raises", "mmocr.models.textrecog.decoders.sar_decoder_with_bs.DecodeNode", "pytest.raises", "mmocr.models.textrecog.decoders.sar_decoder_with_bs.DecodeNode", "pytest.raises", "mmocr.models.textrecog.decoders.sar_decoder_with_bs.DecodeNode", "mmocr.models.textrecog.decoders.sar_decoder_with_bs.DecodeNode.eval"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder._create_dummy_input", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval"], ["", "def", "test_parallel_sar_decoder_with_beam_search", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ParallelSARDecoderWithBS", "(", "beam_width", "=", "'beam'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "ParallelSARDecoderWithBS", "(", "beam_width", "=", "0", ")", "\n", "\n", "", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "=", "_create_dummy_input", "(", ")", "\n", "decoder", "=", "ParallelSARDecoderWithBS", "(", "\n", "beam_width", "=", "1", ",", "num_classes", "=", "37", ",", "padding_idx", "=", "36", ",", "max_seq_len", "=", "5", ")", "\n", "decoder", ".", "init_weights", "(", ")", "\n", "decoder", ".", "train", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "[", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", "*", "2", ")", "\n", "\n", "", "out_test", "=", "decoder", "(", "feat", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "train_mode", "=", "False", ")", "\n", "assert", "out_test", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n", "# test decodenode", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "DecodeNode", "(", "1", ",", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "DecodeNode", "(", "[", "1", ",", "2", "]", ",", "[", "'4'", ",", "'3'", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "DecodeNode", "(", "[", "1", ",", "2", "]", ",", "[", "0.5", "]", ")", "\n", "", "decode_node", "=", "DecodeNode", "(", "[", "1", ",", "2", "]", ",", "[", "0.7", ",", "0.8", "]", ")", "\n", "assert", "math", ".", "isclose", "(", "decode_node", ".", "eval", "(", ")", ",", "1.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_transformer_decoder": [[102, 117], ["mmocr.models.textrecog.decoders.NRTRDecoder", "mmocr.models.textrecog.decoders.NRTRDecoder.init_weights", "mmocr.models.textrecog.decoders.NRTRDecoder.train", "torch.rand", "mmocr.models.textrecog.decoders.NRTRDecoder.", "mmocr.models.textrecog.decoders.NRTRDecoder.", "torch.LongTensor", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.bert.BertModel.init_weights", "home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train"], ["", "def", "test_transformer_decoder", "(", ")", ":", "\n", "    ", "decoder", "=", "NRTRDecoder", "(", "num_classes", "=", "37", ",", "padding_idx", "=", "36", ",", "max_seq_len", "=", "5", ")", "\n", "decoder", ".", "init_weights", "(", ")", "\n", "decoder", ".", "train", "(", ")", "\n", "\n", "out_enc", "=", "torch", ".", "rand", "(", "1", ",", "25", ",", "512", ")", "\n", "tgt_dict", "=", "{", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "1", ",", "1", ",", "1", ",", "36", "]", "]", ")", "}", "\n", "img_metas", "=", "[", "{", "'valid_ratio'", ":", "1.0", "}", "]", "\n", "tgt_dict", "[", "'padded_targets'", "]", "=", "tgt_dict", "[", "'padded_targets'", "]", "\n", "\n", "out_train", "=", "decoder", "(", "None", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "True", ")", "\n", "assert", "out_train", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n", "out_test", "=", "decoder", "(", "None", ",", "out_enc", ",", "tgt_dict", ",", "img_metas", ",", "False", ")", "\n", "assert", "out_test", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "36", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_abi_language_decoder": [[119, 126], ["mmocr.models.textrecog.decoders.ABILanguageDecoder", "torch.randn", "mmocr.models.textrecog.decoders.ABILanguageDecoder.", "torch.Size", "torch.Size"], "function", ["None"], ["", "def", "test_abi_language_decoder", "(", ")", ":", "\n", "    ", "decoder", "=", "ABILanguageDecoder", "(", "max_seq_len", "=", "25", ")", "\n", "logits", "=", "torch", ".", "randn", "(", "2", ",", "25", ",", "90", ")", "\n", "result", "=", "decoder", "(", "\n", "feat", "=", "None", ",", "out_enc", "=", "logits", ",", "targets_dict", "=", "None", ",", "img_metas", "=", "None", ")", "\n", "assert", "result", "[", "'feature'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "2", ",", "25", ",", "512", "]", ")", "\n", "assert", "result", "[", "'logits'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "2", ",", "25", ",", "90", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_abi_vision_decoder": [[128, 136], ["mmocr.models.textrecog.decoders.ABIVisionDecoder", "torch.randn", "mmocr.models.textrecog.decoders.ABIVisionDecoder.", "torch.Size", "torch.Size", "torch.Size"], "function", ["None"], ["", "def", "test_abi_vision_decoder", "(", ")", ":", "\n", "    ", "model", "=", "ABIVisionDecoder", "(", "\n", "in_channels", "=", "128", ",", "num_channels", "=", "16", ",", "max_seq_len", "=", "10", ",", "use_result", "=", "None", ")", "\n", "x", "=", "torch", ".", "randn", "(", "2", ",", "128", ",", "8", ",", "32", ")", "\n", "result", "=", "model", "(", "x", ",", "None", ")", "\n", "assert", "result", "[", "'feature'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "2", ",", "10", ",", "128", "]", ")", "\n", "assert", "result", "[", "'logits'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "2", ",", "10", ",", "90", "]", ")", "\n", "assert", "result", "[", "'attn_scores'", "]", ".", "shape", "==", "torch", ".", "Size", "(", "[", "2", ",", "10", ",", "8", ",", "32", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_decoder.test_master_decoder": [[138, 152], ["mmocr.models.textrecog.decoders.MasterDecoder", "torch.randn", "mmocr.models.textrecog.decoders.MasterDecoder.", "mmocr.models.textrecog.decoders.MasterDecoder.forward_test", "torch.LongTensor", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.classifiers.ner_classifier.NerClassifier.forward_test"], ["", "def", "test_master_decoder", "(", ")", ":", "\n", "    ", "model", "=", "MasterDecoder", "(", "\n", "start_idx", "=", "0", ",", "\n", "padding_idx", "=", "36", ",", "\n", "num_classes", "=", "37", ",", "\n", "d_model", "=", "64", ",", "\n", "n_head", "=", "2", ",", "\n", "max_seq_len", "=", "5", ")", "\n", "feat", "=", "torch", ".", "randn", "(", "1", ",", "64", ",", "6", ",", "40", ")", "\n", "tgt_dict", "=", "{", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "0", ",", "1", ",", "1", ",", "1", ",", "36", "]", "]", ")", "}", "\n", "result", "=", "model", "(", "feat", ",", "None", ",", "tgt_dict", ")", "\n", "assert", "result", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "37", "]", ")", "\n", "result", "=", "model", ".", "forward_test", "(", "feat", ",", "None", ",", "None", ")", "\n", "assert", "result", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "5", ",", "37", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_layer.test_conv_layer": [[10, 32], ["mmocr.models.textrecog.layers.conv_layer.conv3x3", "torch.rand", "mmocr.models.textrecog.layers.BasicBlock", "mmocr.models.textrecog.layers.BasicBlock.", "mmocr.models.textrecog.layers.Bottleneck", "mmocr.models.textrecog.layers.Bottleneck.", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.layers.conv_layer.conv3x3"], ["def", "test_conv_layer", "(", ")", ":", "\n", "    ", "conv3by3", "=", "conv3x3", "(", "3", ",", "6", ")", "\n", "assert", "conv3by3", ".", "in_channels", "==", "3", "\n", "assert", "conv3by3", ".", "out_channels", "==", "6", "\n", "assert", "conv3by3", ".", "kernel_size", "==", "(", "3", ",", "3", ")", "\n", "\n", "x", "=", "torch", ".", "rand", "(", "1", ",", "64", ",", "224", ",", "224", ")", "\n", "# test basic block", "\n", "basic_block", "=", "BasicBlock", "(", "64", ",", "64", ")", "\n", "assert", "basic_block", ".", "expansion", "==", "1", "\n", "\n", "out", "=", "basic_block", "(", "x", ")", "\n", "\n", "assert", "out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "64", ",", "224", ",", "224", "]", ")", "\n", "\n", "# test bottle neck", "\n", "bottle_neck", "=", "Bottleneck", "(", "64", ",", "64", ",", "downsample", "=", "True", ")", "\n", "assert", "bottle_neck", ".", "expansion", "==", "4", "\n", "\n", "out", "=", "bottle_neck", "(", "x", ")", "\n", "\n", "assert", "out", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "256", ",", "224", ",", "224", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_layer.test_transformer_layer": [[34, 64], ["mmocr.models.common.TFDecoderLayer", "torch.rand", "torch.rand", "mmocr.models.common.TFDecoderLayer.", "mmocr.models.common.TFDecoderLayer", "mmocr.models.common.TFDecoderLayer.", "mmocr.models.common.PositionalEncoding", "torch.rand", "mmocr.models.common.PositionalEncoding.", "mmocr.models.common.TFEncoderLayer", "torch.rand", "mmocr.models.common.TFEncoderLayer.", "mmocr.models.common.TFEncoderLayer", "mmocr.models.common.TFEncoderLayer.", "torch.Size", "torch.Size", "pos_encoder.size", "torch.rand.size", "torch.Size", "torch.Size"], "function", ["None"], ["", "def", "test_transformer_layer", "(", ")", ":", "\n", "# test decoder_layer", "\n", "    ", "decoder_layer", "=", "TFDecoderLayer", "(", ")", "\n", "in_dec", "=", "torch", ".", "rand", "(", "1", ",", "30", ",", "512", ")", "\n", "out_enc", "=", "torch", ".", "rand", "(", "1", ",", "128", ",", "512", ")", "\n", "out_dec", "=", "decoder_layer", "(", "in_dec", ",", "out_enc", ")", "\n", "assert", "out_dec", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "30", ",", "512", "]", ")", "\n", "\n", "decoder_layer", "=", "TFDecoderLayer", "(", "\n", "operation_order", "=", "(", "'self_attn'", ",", "'norm'", ",", "'enc_dec_attn'", ",", "'norm'", ",", "'ffn'", ",", "\n", "'norm'", ")", ")", "\n", "out_dec", "=", "decoder_layer", "(", "in_dec", ",", "out_enc", ")", "\n", "assert", "out_dec", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "30", ",", "512", "]", ")", "\n", "\n", "# test positional_encoding", "\n", "pos_encoder", "=", "PositionalEncoding", "(", ")", "\n", "x", "=", "torch", ".", "rand", "(", "1", ",", "30", ",", "512", ")", "\n", "out", "=", "pos_encoder", "(", "x", ")", "\n", "assert", "out", ".", "size", "(", ")", "==", "x", ".", "size", "(", ")", "\n", "\n", "# test encoder_layer", "\n", "encoder_layer", "=", "TFEncoderLayer", "(", ")", "\n", "in_enc", "=", "torch", ".", "rand", "(", "1", ",", "20", ",", "512", ")", "\n", "out_enc", "=", "encoder_layer", "(", "in_enc", ")", "\n", "assert", "out_dec", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "30", ",", "512", "]", ")", "\n", "\n", "encoder_layer", "=", "TFEncoderLayer", "(", "\n", "operation_order", "=", "(", "'self_attn'", ",", "'norm'", ",", "'ffn'", ",", "'norm'", ")", ")", "\n", "out_enc", "=", "encoder_layer", "(", "in_enc", ")", "\n", "assert", "out_dec", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "30", ",", "512", "]", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_modules.test_local_graph_forward_train": [[10, 44], ["mmocr.models.textdet.modules.LocalGraphs", "torch.randn", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.hstack", "np.stack.astype", "np.stack.copy", "numpy.stack", "mmocr.models.textdet.modules.LocalGraphs.", "numpy.ones", "numpy.ones", "numpy.cos", "numpy.sin", "numpy.ones", "node_feats.dim", "adjacent_matrix.dim", "node_feats.size", "knn_inds.size", "linkage_labels.size", "node_feats.size", "adjacent_matrix.size", "knn_inds.size", "linkage_labels.size", "node_feats.size", "adjacent_matrix.size", "adjacent_matrix.size", "numpy.random.random_sample", "torch.randn.size"], "function", ["None"], ["def", "test_local_graph_forward_train", "(", ")", ":", "\n", "    ", "geo_feat_len", "=", "24", "\n", "pooling_h", ",", "pooling_w", "=", "pooling_out_size", "=", "(", "2", ",", "2", ")", "\n", "num_rois", "=", "32", "\n", "\n", "local_graph_generator", "=", "LocalGraphs", "(", "(", "4", ",", "4", ")", ",", "3", ",", "geo_feat_len", ",", "1.0", ",", "\n", "pooling_out_size", ",", "0.5", ")", "\n", "\n", "feature_maps", "=", "torch", ".", "randn", "(", "(", "2", ",", "3", ",", "128", ",", "128", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "x", "=", "np", ".", "random", ".", "randint", "(", "4", ",", "124", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randint", "(", "4", ",", "124", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "h", "=", "4", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "w", "=", "4", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "angle", "=", "(", "np", ".", "random", ".", "random_sample", "(", "(", "num_rois", ",", "1", ")", ")", "*", "2", "-", "1", ")", "*", "np", ".", "pi", "/", "2", "\n", "cos", ",", "sin", "=", "np", ".", "cos", "(", "angle", ")", ",", "np", ".", "sin", "(", "angle", ")", "\n", "comp_labels", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "3", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "num_rois", "=", "num_rois", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "comp_attribs", "=", "np", ".", "hstack", "(", "[", "num_rois", ",", "x", ",", "y", ",", "h", ",", "w", ",", "cos", ",", "sin", ",", "comp_labels", "]", ")", "\n", "comp_attribs", "=", "comp_attribs", ".", "astype", "(", "np", ".", "float32", ")", "\n", "comp_attribs_", "=", "comp_attribs", ".", "copy", "(", ")", "\n", "comp_attribs", "=", "np", ".", "stack", "(", "[", "comp_attribs", ",", "comp_attribs_", "]", ")", "\n", "\n", "(", "node_feats", ",", "adjacent_matrix", ",", "knn_inds", ",", "\n", "linkage_labels", ")", "=", "local_graph_generator", "(", "feature_maps", ",", "comp_attribs", ")", "\n", "feat_len", "=", "geo_feat_len", "+", "feature_maps", ".", "size", "(", ")", "[", "1", "]", "*", "pooling_h", "*", "pooling_w", "\n", "\n", "assert", "node_feats", ".", "dim", "(", ")", "==", "adjacent_matrix", ".", "dim", "(", ")", "==", "3", "\n", "assert", "node_feats", ".", "size", "(", ")", "[", "-", "1", "]", "==", "feat_len", "\n", "assert", "knn_inds", ".", "size", "(", ")", "[", "-", "1", "]", "==", "4", "\n", "assert", "linkage_labels", ".", "size", "(", ")", "[", "-", "1", "]", "==", "4", "\n", "assert", "(", "node_feats", ".", "size", "(", ")", "[", "0", "]", "==", "adjacent_matrix", ".", "size", "(", ")", "[", "0", "]", "==", "\n", "knn_inds", ".", "size", "(", ")", "[", "0", "]", "==", "linkage_labels", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "assert", "(", "node_feats", ".", "size", "(", ")", "[", "1", "]", "==", "adjacent_matrix", ".", "size", "(", ")", "[", "1", "]", "==", "\n", "adjacent_matrix", ".", "size", "(", ")", "[", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_modules.test_local_graph_forward_test": [[46, 99], ["mmocr.models.textdet.modules.ProposalLocalGraphs", "torch.zeros", "torch.randn", "mmocr.models.textdet.modules.ProposalLocalGraphs.", "mmocr.models.textdet.modules.ProposalLocalGraphs.", "mmocr.models.textdet.modules.ProposalLocalGraphs", "mmocr.models.textdet.modules.ProposalLocalGraphs.", "mmocr.models.textdet.modules.ProposalLocalGraphs.", "node_feats.size", "adjacent_matrices.size", "knn_inds.size", "local_graphs.size", "node_feats.size", "adjacent_matrices.size", "adjacent_matrices.size", "local_graphs.size", "node_feats.size", "torch.randn.size"], "function", ["None"], ["", "def", "test_local_graph_forward_test", "(", ")", ":", "\n", "    ", "geo_feat_len", "=", "24", "\n", "pooling_h", ",", "pooling_w", "=", "pooling_out_size", "=", "(", "2", ",", "2", ")", "\n", "\n", "local_graph_generator", "=", "ProposalLocalGraphs", "(", "\n", "(", "4", ",", "4", ")", ",", "2", ",", "geo_feat_len", ",", "1.", ",", "pooling_out_size", ",", "0.1", ",", "3.", ",", "6.", ",", "1.", ",", "0.5", ",", "\n", "0.3", ",", "0.5", ",", "0.5", ",", "2", ")", "\n", "\n", "maps", "=", "torch", ".", "zeros", "(", "(", "1", ",", "6", ",", "224", ",", "224", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "maps", "[", ":", ",", "0", ":", "2", ",", ":", ",", ":", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "0", ",", "60", ":", "100", ",", "50", ":", "170", "]", "=", "10.", "\n", "maps", "[", ":", ",", "1", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "maps", "[", ":", ",", "2", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "0.", "\n", "maps", "[", ":", ",", "3", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "1.", "\n", "maps", "[", ":", ",", "4", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "maps", "[", ":", ",", "5", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "feature_maps", "=", "torch", ".", "randn", "(", "(", "2", ",", "6", ",", "224", ",", "224", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "feat_len", "=", "geo_feat_len", "+", "feature_maps", ".", "size", "(", ")", "[", "1", "]", "*", "pooling_h", "*", "pooling_w", "\n", "\n", "none_flag", ",", "graph_data", "=", "local_graph_generator", "(", "maps", ",", "feature_maps", ")", "\n", "(", "node_feats", ",", "adjacent_matrices", ",", "knn_inds", ",", "local_graphs", ",", "\n", "text_comps", ")", "=", "graph_data", "\n", "\n", "assert", "none_flag", "is", "False", "\n", "assert", "text_comps", ".", "ndim", "==", "2", "\n", "assert", "text_comps", ".", "shape", "[", "0", "]", ">", "0", "\n", "assert", "text_comps", ".", "shape", "[", "1", "]", "==", "9", "\n", "assert", "(", "node_feats", ".", "size", "(", ")", "[", "0", "]", "==", "adjacent_matrices", ".", "size", "(", ")", "[", "0", "]", "==", "\n", "knn_inds", ".", "size", "(", ")", "[", "0", "]", "==", "local_graphs", ".", "size", "(", ")", "[", "0", "]", "==", "\n", "text_comps", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "node_feats", ".", "size", "(", ")", "[", "1", "]", "==", "adjacent_matrices", ".", "size", "(", ")", "[", "1", "]", "==", "\n", "adjacent_matrices", ".", "size", "(", ")", "[", "2", "]", "==", "local_graphs", ".", "size", "(", ")", "[", "1", "]", ")", "\n", "assert", "node_feats", ".", "size", "(", ")", "[", "-", "1", "]", "==", "feat_len", "\n", "\n", "# test proposal local graphs with area of center region less than threshold", "\n", "maps", "[", ":", ",", "1", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "1", ",", "80", ",", "80", "]", "=", "10.", "\n", "none_flag", ",", "_", "=", "local_graph_generator", "(", "maps", ",", "feature_maps", ")", "\n", "assert", "none_flag", "\n", "\n", "# test proposal local graphs with one text component", "\n", "local_graph_generator", "=", "ProposalLocalGraphs", "(", "\n", "(", "4", ",", "4", ")", ",", "2", ",", "geo_feat_len", ",", "1.", ",", "pooling_out_size", ",", "0.1", ",", "8.", ",", "20.", ",", "1.", ",", "0.5", ",", "\n", "0.3", ",", "0.5", ",", "0.5", ",", "2", ")", "\n", "maps", "[", ":", ",", "1", ",", "78", ":", "82", ",", "78", ":", "82", "]", "=", "10.", "\n", "none_flag", ",", "_", "=", "local_graph_generator", "(", "maps", ",", "feature_maps", ")", "\n", "assert", "none_flag", "\n", "\n", "# test proposal local graphs with text components out of text region", "\n", "maps", "[", ":", ",", "0", ",", "60", ":", "100", ",", "50", ":", "170", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "0", ",", "78", ":", "82", ",", "78", ":", "82", "]", "=", "10.", "\n", "none_flag", ",", "_", "=", "local_graph_generator", "(", "maps", ",", "feature_maps", ")", "\n", "assert", "none_flag", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_modules.test_gcn": [[101, 114], ["mmocr.models.textdet.modules.GCN", "torch.randn", "torch.rand", "torch.randint", "mmocr.models.textdet.modules.GCN.", "gcn.size"], "function", ["None"], ["", "def", "test_gcn", "(", ")", ":", "\n", "    ", "num_local_graphs", "=", "32", "\n", "num_max_graph_nodes", "=", "16", "\n", "input_feat_len", "=", "512", "\n", "k", "=", "8", "\n", "gcn", "=", "GCN", "(", "input_feat_len", ")", "\n", "node_feat", "=", "torch", ".", "randn", "(", "\n", "(", "num_local_graphs", ",", "num_max_graph_nodes", ",", "input_feat_len", ")", ")", "\n", "adjacent_matrix", "=", "torch", ".", "rand", "(", "\n", "(", "num_local_graphs", ",", "num_max_graph_nodes", ",", "num_max_graph_nodes", ")", ")", "\n", "knn_inds", "=", "torch", ".", "randint", "(", "1", ",", "num_max_graph_nodes", ",", "(", "num_local_graphs", ",", "k", ")", ")", "\n", "output", "=", "gcn", "(", "node_feat", ",", "adjacent_matrix", ",", "knn_inds", ")", "\n", "assert", "output", ".", "size", "(", ")", "==", "(", "num_local_graphs", "*", "k", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_modules.test_normalize_adjacent_matrix": [[116, 120], ["numpy.random.randint", "mmocr.models.textdet.modules.utils.normalize_adjacent_matrix"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.normalize_adjacent_matrix"], ["", "def", "test_normalize_adjacent_matrix", "(", ")", ":", "\n", "    ", "adjacent_matrix", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "(", "16", ",", "16", ")", ")", "\n", "normalized_matrix", "=", "normalize_adjacent_matrix", "(", "adjacent_matrix", ")", "\n", "assert", "normalized_matrix", ".", "shape", "==", "adjacent_matrix", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_modules.test_feature_embedding": [[122, 134], ["numpy.random.randn", "mmocr.models.textdet.modules.utils.feature_embedding", "numpy.random.randn", "mmocr.models.textdet.modules.utils.feature_embedding"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.feature_embedding", "home.repos.pwc.inspect_result.open-mmlab_mmocr.modules.utils.feature_embedding"], ["", "def", "test_feature_embedding", "(", ")", ":", "\n", "    ", "out_feat_len", "=", "48", "\n", "\n", "# test without residue dimensions", "\n", "feats", "=", "np", ".", "random", ".", "randn", "(", "10", ",", "8", ")", "\n", "embed_feats", "=", "feature_embedding", "(", "feats", ",", "out_feat_len", ")", "\n", "assert", "embed_feats", ".", "shape", "==", "(", "10", ",", "out_feat_len", ")", "\n", "\n", "# test with residue dimensions", "\n", "feats", "=", "np", ".", "random", ".", "randn", "(", "10", ",", "9", ")", "\n", "embed_feats", "=", "feature_embedding", "(", "feats", ",", "out_feat_len", ")", "\n", "assert", "embed_feats", ".", "shape", "==", "(", "10", ",", "out_feat_len", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs": [[15, 95], ["numpy.random.RandomState", "np.random.RandomState.rand", "range", "numpy.random.randint", "gt_masks.append", "gt_bboxes.append", "gt_labels.append", "range", "gt_kernels.append", "gt_effective_mask.append", "BitmapMasks", "torch.FloatTensor().requires_grad_", "numpy.array", "range", "np.random.RandomState.randint", "np.random.RandomState.rand", "numpy.vstack", "torch.FloatTensor", "torch.LongTensor", "numpy.random.rand", "kernels.append", "BitmapMasks", "BitmapMasks", "len", "torch.FloatTensor", "numpy.ones"], "function", ["None"], ["def", "_demo_mm_inputs", "(", "num_kernels", "=", "0", ",", "input_shape", "=", "(", "1", ",", "3", ",", "300", ",", "300", ")", ",", "\n", "num_items", "=", "None", ",", "num_classes", "=", "1", ")", ":", "# yapf: disable", "\n", "    ", "\"\"\"Create a superset of inputs needed to run test or train batches.\n\n    Args:\n        input_shape (tuple): Input batch dimensions.\n\n        num_items (None | list[int]): Specifies the number of boxes\n            for each batch item.\n\n        num_classes (int): Number of distinct labels a box might have.\n    \"\"\"", "\n", "from", "mmdet", ".", "core", "import", "BitmapMasks", "\n", "\n", "(", "N", ",", "C", ",", "H", ",", "W", ")", "=", "input_shape", "\n", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "0", ")", "\n", "\n", "imgs", "=", "rng", ".", "rand", "(", "*", "input_shape", ")", "\n", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'ori_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'pad_shape'", ":", "(", "H", ",", "W", ",", "C", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "'scale_factor'", ":", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", ",", "\n", "'flip'", ":", "False", ",", "\n", "}", "for", "_", "in", "range", "(", "N", ")", "]", "\n", "\n", "gt_bboxes", "=", "[", "]", "\n", "gt_labels", "=", "[", "]", "\n", "gt_masks", "=", "[", "]", "\n", "gt_kernels", "=", "[", "]", "\n", "gt_effective_mask", "=", "[", "]", "\n", "\n", "for", "batch_idx", "in", "range", "(", "N", ")", ":", "\n", "        ", "if", "num_items", "is", "None", ":", "\n", "            ", "num_boxes", "=", "rng", ".", "randint", "(", "1", ",", "10", ")", "\n", "", "else", ":", "\n", "            ", "num_boxes", "=", "num_items", "[", "batch_idx", "]", "\n", "\n", "", "cx", ",", "cy", ",", "bw", ",", "bh", "=", "rng", ".", "rand", "(", "num_boxes", ",", "4", ")", ".", "T", "\n", "\n", "tl_x", "=", "(", "(", "cx", "*", "W", ")", "-", "(", "W", "*", "bw", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "W", ")", "\n", "tl_y", "=", "(", "(", "cy", "*", "H", ")", "-", "(", "H", "*", "bh", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "H", ")", "\n", "br_x", "=", "(", "(", "cx", "*", "W", ")", "+", "(", "W", "*", "bw", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "W", ")", "\n", "br_y", "=", "(", "(", "cy", "*", "H", ")", "+", "(", "H", "*", "bh", "/", "2", ")", ")", ".", "clip", "(", "0", ",", "H", ")", "\n", "\n", "boxes", "=", "np", ".", "vstack", "(", "[", "tl_x", ",", "tl_y", ",", "br_x", ",", "br_y", "]", ")", ".", "T", "\n", "class_idxs", "=", "[", "0", "]", "*", "num_boxes", "\n", "\n", "gt_bboxes", ".", "append", "(", "torch", ".", "FloatTensor", "(", "boxes", ")", ")", "\n", "gt_labels", ".", "append", "(", "torch", ".", "LongTensor", "(", "class_idxs", ")", ")", "\n", "kernels", "=", "[", "]", "\n", "for", "kernel_inx", "in", "range", "(", "num_kernels", ")", ":", "\n", "            ", "kernel", "=", "np", ".", "random", ".", "rand", "(", "H", ",", "W", ")", "\n", "kernels", ".", "append", "(", "kernel", ")", "\n", "", "gt_kernels", ".", "append", "(", "BitmapMasks", "(", "kernels", ",", "H", ",", "W", ")", ")", "\n", "gt_effective_mask", ".", "append", "(", "BitmapMasks", "(", "[", "np", ".", "ones", "(", "(", "H", ",", "W", ")", ")", "]", ",", "H", ",", "W", ")", ")", "\n", "\n", "", "mask", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "2", ",", "(", "len", "(", "boxes", ")", ",", "H", ",", "W", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "gt_masks", ".", "append", "(", "BitmapMasks", "(", "mask", ",", "H", ",", "W", ")", ")", "\n", "\n", "mm_inputs", "=", "{", "\n", "'imgs'", ":", "torch", ".", "FloatTensor", "(", "imgs", ")", ".", "requires_grad_", "(", "True", ")", ",", "\n", "'img_metas'", ":", "img_metas", ",", "\n", "'gt_bboxes'", ":", "gt_bboxes", ",", "\n", "'gt_labels'", ":", "gt_labels", ",", "\n", "'gt_bboxes_ignore'", ":", "None", ",", "\n", "'gt_masks'", ":", "gt_masks", ",", "\n", "'gt_kernels'", ":", "gt_kernels", ",", "\n", "'gt_mask'", ":", "gt_effective_mask", ",", "\n", "'gt_thr_mask'", ":", "gt_effective_mask", ",", "\n", "'gt_text_mask'", ":", "gt_effective_mask", ",", "\n", "'gt_center_region_mask'", ":", "gt_effective_mask", ",", "\n", "'gt_radius_map'", ":", "gt_kernels", ",", "\n", "'gt_sin_map'", ":", "gt_kernels", ",", "\n", "'gt_cos_map'", ":", "gt_kernels", ",", "\n", "}", "\n", "return", "mm_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_directory": [[97, 110], ["os.path.join", "os.path.dirname", "os.path.exists", "Exception", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "function", ["None"], ["", "def", "_get_config_directory", "(", ")", ":", "\n", "    ", "\"\"\"Find the predefined detector config directory.\"\"\"", "\n", "try", ":", "\n", "# Assume we are running in the source mmocr repo", "\n", "        ", "repo_dpath", "=", "dirname", "(", "dirname", "(", "dirname", "(", "__file__", ")", ")", ")", "\n", "", "except", "NameError", ":", "\n", "# For IPython development when this __file__ is not defined", "\n", "        ", "import", "mmocr", "\n", "repo_dpath", "=", "dirname", "(", "dirname", "(", "mmocr", ".", "__file__", ")", ")", "\n", "", "config_dpath", "=", "join", "(", "repo_dpath", ",", "'configs'", ")", "\n", "if", "not", "exists", "(", "config_dpath", ")", ":", "\n", "        ", "raise", "Exception", "(", "'Cannot find config path'", ")", "\n", "", "return", "config_dpath", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_module": [[112, 119], ["test_detector._get_config_directory", "os.path.join", "Config.fromfile"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_directory"], ["", "def", "_get_config_module", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Load a configuration as a python module.\"\"\"", "\n", "from", "mmcv", "import", "Config", "\n", "config_dpath", "=", "_get_config_directory", "(", ")", "\n", "config_fpath", "=", "join", "(", "config_dpath", ",", "fname", ")", "\n", "config_mod", "=", "Config", ".", "fromfile", "(", "config_fpath", ")", "\n", "return", "config_mod", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg": [[121, 130], ["test_detector._get_config_module", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_config_module"], ["", "def", "_get_detector_cfg", "(", "fname", ")", ":", "\n", "    ", "\"\"\"Grab configs necessary to create a detector.\n\n    These are deep copied to allow for safe modification of parameters without\n    influencing other tests.\n    \"\"\"", "\n", "config", "=", "_get_config_module", "(", "fname", ")", "\n", "model", "=", "copy", ".", "deepcopy", "(", "config", ".", "model", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_ocr_mask_rcnn": [[132, 176], ["pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "test_detector._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "build_detector.forward", "isinstance", "numpy.random.rand", "build_detector.show_result", "torch.no_grad", "zip", "build_detector.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'textdet/maskrcnn/mask_rcnn_r50_fpn_160e_ctw1500.py'", ",", "\n", "'textdet/maskrcnn/mask_rcnn_r50_fpn_160e_icdar2015.py'", ",", "\n", "'textdet/maskrcnn/mask_rcnn_r50_fpn_160e_icdar2017.py'", "\n", "]", ")", "\n", "def", "test_ocr_mask_rcnn", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "0", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_labels", "=", "mm_inputs", ".", "pop", "(", "'gt_labels'", ")", "\n", "gt_masks", "=", "mm_inputs", ".", "pop", "(", "'gt_masks'", ")", "\n", "\n", "# Test forward train", "\n", "gt_bboxes", "=", "mm_inputs", "[", "'gt_bboxes'", "]", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_bboxes", "=", "gt_bboxes", ",", "\n", "gt_labels", "=", "gt_labels", ",", "\n", "gt_masks", "=", "gt_masks", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test show_result", "\n", "\n", "", "", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_panet": [[178, 231], ["pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "mmocr.utils.revert_sync_batchnorm", "test_detector._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "mmocr.utils.revert_sync_batchnorm.forward", "isinstance", "numpy.random.rand", "mmocr.utils.revert_sync_batchnorm.show_result", "torch.no_grad", "zip", "functools.partial", "mmocr.utils.revert_sync_batchnorm.forward", "batch_results.append", "tempfile.TemporaryDirectory", "torch.onnx.export"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'textdet/panet/panet_r18_fpem_ffm_600e_ctw1500.py'", ",", "\n", "'textdet/panet/panet_r18_fpem_ffm_600e_icdar2015.py'", ",", "\n", "'textdet/panet/panet_r50_fpem_ffm_600e_icdar2017.py'", "\n", "]", ")", "\n", "def", "test_panet", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "detector", "=", "revert_sync_batchnorm", "(", "detector", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "num_kernels", "=", "2", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "num_kernels", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_kernels", "=", "mm_inputs", ".", "pop", "(", "'gt_kernels'", ")", "\n", "gt_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_mask'", ")", "\n", "\n", "# Test forward train", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "img_metas", ",", "gt_kernels", "=", "gt_kernels", ",", "gt_mask", "=", "gt_mask", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test onnx export", "\n", "", "detector", ".", "forward", "=", "partial", "(", "\n", "detector", ".", "simple_test", ",", "img_metas", "=", "img_metas", ",", "rescale", "=", "True", ")", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "            ", "onnx_path", "=", "f'{tmpdirname}/tmp.onnx'", "\n", "torch", ".", "onnx", ".", "export", "(", "\n", "detector", ",", "(", "img_list", "[", "0", "]", ",", ")", ",", "\n", "onnx_path", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "export_params", "=", "True", ",", "\n", "keep_initializers_as_inputs", "=", "False", ")", "\n", "\n", "# Test show result", "\n", "", "", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_psenet": [[233, 273], ["pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "mmocr.utils.revert_sync_batchnorm", "test_detector._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "mmocr.utils.revert_sync_batchnorm.forward", "isinstance", "numpy.random.rand", "mmocr.utils.revert_sync_batchnorm.show_result", "torch.no_grad", "zip", "mmocr.utils.revert_sync_batchnorm.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'textdet/psenet/psenet_r50_fpnf_600e_icdar2015.py'", ",", "\n", "'textdet/psenet/psenet_r50_fpnf_600e_icdar2017.py'", ",", "\n", "'textdet/psenet/psenet_r50_fpnf_600e_ctw1500.py'", "\n", "]", ")", "\n", "def", "test_psenet", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "detector", "=", "revert_sync_batchnorm", "(", "detector", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "num_kernels", "=", "7", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "num_kernels", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_kernels", "=", "mm_inputs", ".", "pop", "(", "'gt_kernels'", ")", "\n", "gt_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_mask'", ")", "\n", "\n", "# Test forward train", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "img_metas", ",", "gt_kernels", "=", "gt_kernels", ",", "gt_mask", "=", "gt_mask", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test show result", "\n", "", "", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_dbnet": [[275, 323], ["pytest.mark.skipif", "pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "mmocr.utils.revert_sync_batchnorm", "detector.cuda.cuda", "test_detector._demo_mm_inputs", "_demo_mm_inputs.pop", "imgs.cuda.cuda", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "detector.cuda.forward", "isinstance", "numpy.random.rand", "detector.cuda.show_result", "torch.no_grad", "zip", "torch.cuda.is_available", "detector.cuda.forward", "batch_results.append"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'textdet/dbnet/dbnet_r18_fpnc_1200e_icdar2015.py'", ",", "\n", "'textdet/dbnet/dbnet_r50dcnv2_fpnc_1200e_icdar2015.py'", "\n", "]", ")", "\n", "def", "test_dbnet", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "detector", "=", "revert_sync_batchnorm", "(", "detector", ")", "\n", "detector", "=", "detector", ".", "cuda", "(", ")", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "num_kernels", "=", "7", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "num_kernels", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "imgs", "=", "imgs", ".", "cuda", "(", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_shrink", "=", "mm_inputs", ".", "pop", "(", "'gt_kernels'", ")", "\n", "gt_shrink_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_mask'", ")", "\n", "gt_thr", "=", "mm_inputs", ".", "pop", "(", "'gt_masks'", ")", "\n", "gt_thr_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_thr_mask'", ")", "\n", "\n", "# Test forward train", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_shrink", "=", "gt_shrink", ",", "\n", "gt_shrink_mask", "=", "gt_shrink_mask", ",", "\n", "gt_thr", "=", "gt_thr", ",", "\n", "gt_thr_mask", "=", "gt_thr_mask", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test show result", "\n", "", "", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_textsnake": [[325, 379], ["pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "mmocr.utils.revert_sync_batchnorm", "test_detector._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "mmocr.utils.revert_sync_batchnorm.forward", "isinstance", "torch.zeros", "mmocr.utils.revert_sync_batchnorm.bbox_head.get_boundary", "numpy.random.rand", "mmocr.utils.revert_sync_batchnorm.show_result"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "\n", "[", "'textdet/textsnake/'", "\n", "'textsnake_r50_fpn_unet_1200e_ctw1500.py'", "]", ")", "\n", "def", "test_textsnake", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "detector", "=", "revert_sync_batchnorm", "(", "detector", ")", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "num_kernels", "=", "1", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "num_kernels", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_text_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_text_mask'", ")", "\n", "gt_center_region_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_center_region_mask'", ")", "\n", "gt_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_mask'", ")", "\n", "gt_radius_map", "=", "mm_inputs", ".", "pop", "(", "'gt_radius_map'", ")", "\n", "gt_sin_map", "=", "mm_inputs", ".", "pop", "(", "'gt_sin_map'", ")", "\n", "gt_cos_map", "=", "mm_inputs", ".", "pop", "(", "'gt_cos_map'", ")", "\n", "\n", "# Test forward train", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_text_mask", "=", "gt_text_mask", ",", "\n", "gt_center_region_mask", "=", "gt_center_region_mask", ",", "\n", "gt_mask", "=", "gt_mask", ",", "\n", "gt_radius_map", "=", "gt_radius_map", ",", "\n", "gt_sin_map", "=", "gt_sin_map", ",", "\n", "gt_cos_map", "=", "gt_cos_map", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test get_boundary", "\n", "maps", "=", "torch", ".", "zeros", "(", "(", "1", ",", "5", ",", "224", ",", "224", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "maps", "[", ":", ",", "0", ":", "2", ",", ":", ",", ":", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "0", ",", "60", ":", "100", ",", "12", ":", "212", "]", "=", "10.", "\n", "maps", "[", ":", ",", "1", ",", "70", ":", "90", ",", "22", ":", "202", "]", "=", "10.", "\n", "maps", "[", ":", ",", "2", ",", "70", ":", "90", ",", "22", ":", "202", "]", "=", "0.", "\n", "maps", "[", ":", ",", "3", ",", "70", ":", "90", ",", "22", ":", "202", "]", "=", "1.", "\n", "maps", "[", ":", ",", "4", ",", "70", ":", "90", ",", "22", ":", "202", "]", "=", "10.", "\n", "\n", "one_meta", "=", "img_metas", "[", "0", "]", "\n", "result", "=", "detector", ".", "bbox_head", ".", "get_boundary", "(", "maps", ",", "[", "one_meta", "]", ",", "False", ")", "\n", "assert", "'boundary_result'", "in", "result", "\n", "assert", "'filename'", "in", "result", "\n", "\n", "# Test show result", "\n", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_fcenet": [[381, 438], ["pytest.mark.skipif", "pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "mmocr.utils.revert_sync_batchnorm", "detector.cuda.cuda", "torch.randn().float().cuda", "range", "detector.cuda.forward", "isinstance", "numpy.random.rand", "detector.cuda.show_result", "p3_maps.append", "p4_maps.append", "p5_maps.append", "torch.no_grad", "zip", "torch.cuda.is_available", "torch.randn().float", "numpy.array", "range", "numpy.random.random", "numpy.random.random", "numpy.random.random", "detector.cuda.forward", "batch_results.append", "torch.randn"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'requires cuda'", ")", "\n", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'cfg_file'", ",", "[", "\n", "'textdet/fcenet/fcenet_r50dcnv2_fpn_1500e_ctw1500.py'", ",", "\n", "'textdet/fcenet/fcenet_r50_fpn_1500e_icdar2015.py'", "\n", "]", ")", "\n", "def", "test_fcenet", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "detector", "=", "revert_sync_batchnorm", "(", "detector", ")", "\n", "detector", "=", "detector", ".", "cuda", "(", ")", "\n", "\n", "fourier_degree", "=", "5", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "256", ",", "256", ")", "\n", "(", "n", ",", "c", ",", "h", ",", "w", ")", "=", "input_shape", "\n", "\n", "imgs", "=", "torch", ".", "randn", "(", "n", ",", "c", ",", "h", ",", "w", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "(", "h", ",", "w", ",", "c", ")", ",", "\n", "'ori_shape'", ":", "(", "h", ",", "w", ",", "c", ")", ",", "\n", "'pad_shape'", ":", "(", "h", ",", "w", ",", "c", ")", ",", "\n", "'filename'", ":", "'<demo>.png'", ",", "\n", "'scale_factor'", ":", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", ",", "\n", "'flip'", ":", "False", ",", "\n", "}", "for", "_", "in", "range", "(", "n", ")", "]", "\n", "\n", "p3_maps", "=", "[", "]", "\n", "p4_maps", "=", "[", "]", "\n", "p5_maps", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n", ")", ":", "\n", "        ", "p3_maps", ".", "append", "(", "\n", "np", ".", "random", ".", "random", "(", "(", "5", "+", "4", "*", "fourier_degree", ",", "h", "//", "8", ",", "w", "//", "8", ")", ")", ")", "\n", "p4_maps", ".", "append", "(", "\n", "np", ".", "random", ".", "random", "(", "(", "5", "+", "4", "*", "fourier_degree", ",", "h", "//", "16", ",", "w", "//", "16", ")", ")", ")", "\n", "p5_maps", ".", "append", "(", "\n", "np", ".", "random", ".", "random", "(", "(", "5", "+", "4", "*", "fourier_degree", ",", "h", "//", "32", ",", "w", "//", "32", ")", ")", ")", "\n", "\n", "# Test forward train", "\n", "", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "img_metas", ",", "p3_maps", "=", "p3_maps", ",", "p4_maps", "=", "p4_maps", ",", "p5_maps", "=", "p5_maps", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "img_list", "=", "[", "g", "[", "None", ",", ":", "]", "for", "g", "in", "imgs", "]", "\n", "batch_results", "=", "[", "]", "\n", "for", "one_img", ",", "one_meta", "in", "zip", "(", "img_list", ",", "img_metas", ")", ":", "\n", "            ", "result", "=", "detector", ".", "forward", "(", "[", "one_img", "]", ",", "[", "[", "one_meta", "]", "]", ",", "\n", "return_loss", "=", "False", ")", "\n", "batch_results", ".", "append", "(", "result", ")", "\n", "\n", "# Test show result", "\n", "", "", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector.test_drrg": [[440, 518], ["pytest.mark.parametrize", "test_detector._get_detector_cfg", "build_detector", "mmocr.utils.revert_sync_batchnorm", "test_detector._demo_mm_inputs", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "mm_inputs.pop.copy", "_demo_mm_inputs.pop", "_demo_mm_inputs.pop", "numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "numpy.hstack", "numpy.expand_dims", "build_detector.forward", "isinstance", "build_detector", "torch.zeros", "numpy.random.rand", "build_detector.show_result", "numpy.ones", "numpy.ones", "numpy.cos", "numpy.sin", "numpy.ones", "np.hstack.astype", "torch.no_grad", "torch.zeros", "range", "build_detector.bbox_head.out_conv.bias.data.fill_", "build_detector.bbox_head.single_test", "build_detector.bbox_head.get_boundary", "len", "numpy.random.random_sample"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._get_detector_cfg", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_detector._demo_mm_inputs", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.db_head.DBHead.forward", "home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.detectors.text_detector_mixin.TextDetectorMixin.show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.drrg_head.DRRGHead.single_test", "home.repos.pwc.inspect_result.open-mmlab_mmocr.dense_heads.fce_head.FCEHead.get_boundary"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'cfg_file'", ",", "[", "'textdet/drrg/'", "\n", "'drrg_r50_fpn_unet_1200e_ctw1500.py'", "]", ")", "\n", "def", "test_drrg", "(", "cfg_file", ")", ":", "\n", "    ", "model", "=", "_get_detector_cfg", "(", "cfg_file", ")", "\n", "model", "[", "'pretrained'", "]", "=", "None", "\n", "\n", "from", "mmocr", ".", "models", "import", "build_detector", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "detector", "=", "revert_sync_batchnorm", "(", "detector", ")", "\n", "\n", "input_shape", "=", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "num_kernels", "=", "1", "\n", "mm_inputs", "=", "_demo_mm_inputs", "(", "num_kernels", ",", "input_shape", ")", "\n", "\n", "imgs", "=", "mm_inputs", ".", "pop", "(", "'imgs'", ")", "\n", "img_metas", "=", "mm_inputs", ".", "pop", "(", "'img_metas'", ")", "\n", "gt_text_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_text_mask'", ")", "\n", "gt_center_region_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_center_region_mask'", ")", "\n", "gt_mask", "=", "mm_inputs", ".", "pop", "(", "'gt_mask'", ")", "\n", "gt_top_height_map", "=", "mm_inputs", ".", "pop", "(", "'gt_radius_map'", ")", "\n", "gt_bot_height_map", "=", "gt_top_height_map", ".", "copy", "(", ")", "\n", "gt_sin_map", "=", "mm_inputs", ".", "pop", "(", "'gt_sin_map'", ")", "\n", "gt_cos_map", "=", "mm_inputs", ".", "pop", "(", "'gt_cos_map'", ")", "\n", "num_rois", "=", "32", "\n", "x", "=", "np", ".", "random", ".", "randint", "(", "4", ",", "224", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "y", "=", "np", ".", "random", ".", "randint", "(", "4", ",", "224", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "h", "=", "4", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "w", "=", "4", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "angle", "=", "(", "np", ".", "random", ".", "random_sample", "(", "(", "num_rois", ",", "1", ")", ")", "*", "2", "-", "1", ")", "*", "np", ".", "pi", "/", "2", "\n", "cos", ",", "sin", "=", "np", ".", "cos", "(", "angle", ")", ",", "np", ".", "sin", "(", "angle", ")", "\n", "comp_labels", "=", "np", ".", "random", ".", "randint", "(", "1", ",", "3", ",", "(", "num_rois", ",", "1", ")", ")", "\n", "num_rois", "=", "num_rois", "*", "np", ".", "ones", "(", "(", "num_rois", ",", "1", ")", ")", "\n", "comp_attribs", "=", "np", ".", "hstack", "(", "[", "num_rois", ",", "x", ",", "y", ",", "h", ",", "w", ",", "cos", ",", "sin", ",", "comp_labels", "]", ")", "\n", "gt_comp_attribs", "=", "np", ".", "expand_dims", "(", "comp_attribs", ".", "astype", "(", "np", ".", "float32", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# Test forward train", "\n", "losses", "=", "detector", ".", "forward", "(", "\n", "imgs", ",", "\n", "img_metas", ",", "\n", "gt_text_mask", "=", "gt_text_mask", ",", "\n", "gt_center_region_mask", "=", "gt_center_region_mask", ",", "\n", "gt_mask", "=", "gt_mask", ",", "\n", "gt_top_height_map", "=", "gt_top_height_map", ",", "\n", "gt_bot_height_map", "=", "gt_bot_height_map", ",", "\n", "gt_sin_map", "=", "gt_sin_map", ",", "\n", "gt_cos_map", "=", "gt_cos_map", ",", "\n", "gt_comp_attribs", "=", "gt_comp_attribs", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "\n", "# Test forward test", "\n", "model", "[", "'bbox_head'", "]", "[", "'in_channels'", "]", "=", "6", "\n", "model", "[", "'bbox_head'", "]", "[", "'text_region_thr'", "]", "=", "0.8", "\n", "model", "[", "'bbox_head'", "]", "[", "'center_region_thr'", "]", "=", "0.8", "\n", "detector", "=", "build_detector", "(", "model", ")", "\n", "maps", "=", "torch", ".", "zeros", "(", "(", "1", ",", "6", ",", "224", ",", "224", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "maps", "[", ":", ",", "0", ":", "2", ",", ":", ",", ":", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "0", ",", "60", ":", "100", ",", "50", ":", "170", "]", "=", "10.", "\n", "maps", "[", ":", ",", "1", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "maps", "[", ":", ",", "2", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "0.", "\n", "maps", "[", ":", ",", "3", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "1.", "\n", "maps", "[", ":", ",", "4", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "maps", "[", ":", ",", "5", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "full_pass_weight", "=", "torch", ".", "zeros", "(", "(", "6", ",", "6", ",", "1", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "6", ")", ":", "\n", "            ", "full_pass_weight", "[", "i", ",", "i", ",", "0", ",", "0", "]", "=", "1", "\n", "", "detector", ".", "bbox_head", ".", "out_conv", ".", "weight", ".", "data", "=", "full_pass_weight", "\n", "detector", ".", "bbox_head", ".", "out_conv", ".", "bias", ".", "data", ".", "fill_", "(", "0.", ")", "\n", "outs", "=", "detector", ".", "bbox_head", ".", "single_test", "(", "maps", ")", "\n", "boundaries", "=", "detector", ".", "bbox_head", ".", "get_boundary", "(", "*", "outs", ",", "img_metas", ",", "True", ")", "\n", "", "assert", "len", "(", "boundaries", ")", "==", "1", "\n", "\n", "# Test show result", "\n", "results", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "0.9", "]", "]", "}", "\n", "img", "=", "np", ".", "random", ".", "rand", "(", "5", ",", "5", ")", "\n", "detector", ".", "show_result", "(", "img", ",", "results", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_loss.test_ctc_loss": [[10, 32], ["mmocr.models.textrecog.losses.CTCLoss", "torch.zeros", "mmocr.models.textrecog.losses.CTCLoss.", "isinstance", "torch.allclose", "pytest.raises", "mmocr.models.textrecog.losses.CTCLoss", "pytest.raises", "mmocr.models.textrecog.losses.CTCLoss", "pytest.raises", "mmocr.models.textrecog.losses.CTCLoss", "pytest.raises", "mmocr.models.textrecog.losses.CTCLoss", "torch.IntTensor", "torch.LongTensor", "torch.tensor().float", "torch.tensor", "losses[].item"], "function", ["None"], ["def", "test_ctc_loss", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CTCLoss", "(", "flatten", "=", "'flatten'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CTCLoss", "(", "blank", "=", "None", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CTCLoss", "(", "reduction", "=", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CTCLoss", "(", "zero_infinity", "=", "'zero'", ")", "\n", "# test CTCLoss", "\n", "", "ctc_loss", "=", "CTCLoss", "(", ")", "\n", "outputs", "=", "torch", ".", "zeros", "(", "2", ",", "40", ",", "37", ")", "\n", "targets_dict", "=", "{", "\n", "'flatten_targets'", ":", "torch", ".", "IntTensor", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", ",", "\n", "'target_lengths'", ":", "torch", ".", "LongTensor", "(", "[", "2", ",", "3", "]", ")", "\n", "}", "\n", "\n", "losses", "=", "ctc_loss", "(", "outputs", ",", "targets_dict", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "assert", "'loss_ctc'", "in", "losses", "\n", "assert", "torch", ".", "allclose", "(", "losses", "[", "'loss_ctc'", "]", ",", "\n", "torch", ".", "tensor", "(", "losses", "[", "'loss_ctc'", "]", ".", "item", "(", ")", ")", ".", "float", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_loss.test_ce_loss": [[34, 60], ["mmocr.models.textrecog.losses.CELoss", "torch.rand", "mmocr.models.textrecog.losses.CELoss.", "isinstance", "mmocr.models.textrecog.losses.CELoss", "torch.rand", "mmocr.models.textrecog.losses.CELoss.format", "pytest.raises", "mmocr.models.textrecog.losses.CELoss", "pytest.raises", "mmocr.models.textrecog.losses.CELoss", "pytest.raises", "mmocr.models.textrecog.losses.CELoss", "torch.LongTensor", "losses[].size", "torch.LongTensor", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.TFLoss.format"], ["", "def", "test_ce_loss", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CELoss", "(", "ignore_index", "=", "'ignore'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CELoss", "(", "reduction", "=", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "CELoss", "(", "reduction", "=", "'avg'", ")", "\n", "\n", "", "ce_loss", "=", "CELoss", "(", "ignore_index", "=", "0", ")", "\n", "outputs", "=", "torch", ".", "rand", "(", "1", ",", "10", ",", "37", ")", "\n", "targets_dict", "=", "{", "\n", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "}", "\n", "losses", "=", "ce_loss", "(", "outputs", ",", "targets_dict", ")", "\n", "assert", "isinstance", "(", "losses", ",", "dict", ")", "\n", "assert", "'loss_ce'", "in", "losses", "\n", "assert", "losses", "[", "'loss_ce'", "]", ".", "size", "(", "1", ")", "==", "10", "\n", "\n", "ce_loss", "=", "CELoss", "(", "ignore_first_char", "=", "True", ")", "\n", "outputs", "=", "torch", ".", "rand", "(", "1", ",", "10", ",", "37", ")", "\n", "targets_dict", "=", "{", "\n", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "}", "\n", "new_output", ",", "new_target", "=", "ce_loss", ".", "format", "(", "outputs", ",", "targets_dict", ")", "\n", "assert", "new_output", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "37", ",", "9", "]", ")", "\n", "assert", "new_target", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "9", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_loss.test_sar_loss": [[62, 71], ["torch.rand", "mmocr.models.textrecog.losses.SARLoss", "mmocr.models.textrecog.losses.SARLoss.format", "torch.LongTensor", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.TFLoss.format"], ["", "def", "test_sar_loss", "(", ")", ":", "\n", "    ", "outputs", "=", "torch", ".", "rand", "(", "1", ",", "10", ",", "37", ")", "\n", "targets_dict", "=", "{", "\n", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "}", "\n", "sar_loss", "=", "SARLoss", "(", ")", "\n", "new_output", ",", "new_target", "=", "sar_loss", ".", "format", "(", "outputs", ",", "targets_dict", ")", "\n", "assert", "new_output", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "37", ",", "9", "]", ")", "\n", "assert", "new_target", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "9", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_loss.test_tf_loss": [[73, 85], ["torch.rand", "mmocr.models.textrecog.losses.TFLoss", "mmocr.models.textrecog.losses.TFLoss.format", "pytest.raises", "mmocr.models.textrecog.losses.TFLoss", "torch.LongTensor", "torch.Size", "torch.Size"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.losses.ce_loss.TFLoss.format"], ["", "def", "test_tf_loss", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "TFLoss", "(", "flatten", "=", "1.0", ")", "\n", "\n", "", "outputs", "=", "torch", ".", "rand", "(", "1", ",", "10", ",", "37", ")", "\n", "targets_dict", "=", "{", "\n", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", "\n", "}", "\n", "tf_loss", "=", "TFLoss", "(", "flatten", "=", "False", ")", "\n", "new_output", ",", "new_target", "=", "tf_loss", ".", "format", "(", "outputs", ",", "targets_dict", ")", "\n", "assert", "new_output", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "37", ",", "9", "]", ")", "\n", "assert", "new_target", ".", "shape", "==", "torch", ".", "Size", "(", "[", "1", ",", "9", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_loss.test_dice_loss": [[87, 101], ["mmocr.models.common.losses.DiceLoss", "torch.rand", "torch.rand", "mmocr.models.common.losses.DiceLoss.", "isinstance", "torch.rand", "mmocr.models.common.losses.DiceLoss.", "isinstance", "pytest.raises", "mmocr.models.common.losses.DiceLoss"], "function", ["None"], ["", "def", "test_dice_loss", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "DiceLoss", "(", "eps", "=", "'1'", ")", "\n", "\n", "", "dice_loss", "=", "DiceLoss", "(", ")", "\n", "pred", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "32", ",", "32", ")", "\n", "gt", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "32", ",", "32", ")", "\n", "\n", "loss", "=", "dice_loss", "(", "pred", ",", "gt", ",", "None", ")", "\n", "assert", "isinstance", "(", "loss", ",", "torch", ".", "Tensor", ")", "\n", "\n", "mask", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "loss", "=", "dice_loss", "(", "pred", ",", "gt", ",", "mask", ")", "\n", "assert", "isinstance", "(", "loss", ",", "torch", ".", "Tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_models.test_ocr_loss.test_abi_loss": [[103, 134], ["mmocr.models.textrecog.losses.ABILoss", "dict", "mmocr.models.textrecog.losses.ABILoss.", "isinstance", "isinstance", "isinstance", "isinstance", "dict.pop", "mmocr.models.textrecog.losses.ABILoss.", "dict.pop", "mmocr.models.textrecog.losses.ABILoss.", "dict.pop", "torch.LongTensor", "pytest.raises", "mmocr.models.textrecog.losses.ABILoss.", "dict", "torch.LongTensor", "torch.LongTensor", "dict", "dict", "dict", "dict", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "function", ["None"], ["", "def", "test_abi_loss", "(", ")", ":", "\n", "    ", "loss", "=", "ABILoss", "(", "num_classes", "=", "90", ")", "\n", "outputs", "=", "dict", "(", "\n", "out_enc", "=", "dict", "(", "logits", "=", "torch", ".", "randn", "(", "2", ",", "10", ",", "90", ")", ")", ",", "\n", "out_decs", "=", "[", "\n", "dict", "(", "logits", "=", "torch", ".", "randn", "(", "2", ",", "10", ",", "90", ")", ")", ",", "\n", "dict", "(", "logits", "=", "torch", ".", "randn", "(", "2", ",", "10", ",", "90", ")", ")", "\n", "]", ",", "\n", "out_fusers", "=", "[", "\n", "dict", "(", "logits", "=", "torch", ".", "randn", "(", "2", ",", "10", ",", "90", ")", ")", ",", "\n", "dict", "(", "logits", "=", "torch", ".", "randn", "(", "2", ",", "10", ",", "90", ")", ")", "\n", "]", ")", "\n", "targets_dict", "=", "{", "\n", "'padded_targets'", ":", "torch", ".", "LongTensor", "(", "[", "[", "1", ",", "2", ",", "3", ",", "4", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", ",", "\n", "'targets'", ":", "\n", "[", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", ",", "\n", "torch", ".", "LongTensor", "(", "[", "1", ",", "2", ",", "3", "]", ")", "]", "\n", "}", "\n", "result", "=", "loss", "(", "outputs", ",", "targets_dict", ")", "\n", "assert", "isinstance", "(", "result", ",", "dict", ")", "\n", "assert", "isinstance", "(", "result", "[", "'loss_visual'", "]", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "result", "[", "'loss_lang'", "]", ",", "torch", ".", "Tensor", ")", "\n", "assert", "isinstance", "(", "result", "[", "'loss_fusion'", "]", ",", "torch", ".", "Tensor", ")", "\n", "\n", "outputs", ".", "pop", "(", "'out_enc'", ")", "\n", "loss", "(", "outputs", ",", "targets_dict", ")", "\n", "outputs", ".", "pop", "(", "'out_decs'", ")", "\n", "loss", "(", "outputs", ",", "targets_dict", ")", "\n", "outputs", ".", "pop", "(", "'out_fusers'", ")", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "loss", "(", "outputs", ",", "targets_dict", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_attn_label_convertor._create_dummy_dict_file": [[12, 17], ["list", "open", "fw.write"], "function", ["None"], ["def", "_create_dummy_dict_file", "(", "dict_file", ")", ":", "\n", "    ", "characters", "=", "list", "(", "'helowrd'", ")", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "char", "in", "characters", ":", "\n", "            ", "fw", ".", "write", "(", "char", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_attn_label_convertor.test_attn_label_convertor": [[19, 79], ["tempfile.TemporaryDirectory", "os.join", "test_attn_label_convertor._create_dummy_dict_file", "mmocr.models.textrecog.convertors.AttnConvertor", "mmocr.models.textrecog.convertors.AttnConvertor.str2tensor", "torch.allclose", "torch.allclose", "torch.Tensor", "mmocr.models.textrecog.convertors.AttnConvertor.tensor2idx", "numpy.allclose", "mmocr.models.textrecog.convertors.AttnConvertor.str2idx", "numpy.allclose", "mmocr.models.textrecog.convertors.AttnConvertor.idx2str", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.models.textrecog.convertors.AttnConvertor", "pytest.raises", "mmocr.models.textrecog.convertors.AttnConvertor", "pytest.raises", "mmocr.models.textrecog.convertors.AttnConvertor", "mmocr.models.textrecog.convertors.AttnConvertor.num_classes", "len", "torch.LongTensor", "torch.LongTensor", "pytest.raises", "mmocr.models.textrecog.convertors.AttnConvertor.str2idx", "pytest.raises", "mmocr.models.textrecog.convertors.AttnConvertor.idx2str"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.num_classes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str"], ["", "", "", "def", "test_attn_label_convertor", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_dict.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "AttnConvertor", "(", "5", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "AttnConvertor", "(", "'DICT90'", ",", "dict_file", ",", "'1'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "AttnConvertor", "(", "'DICT90'", ",", "dict_file", ",", "True", ",", "'1'", ")", "\n", "\n", "", "label_convertor", "=", "AttnConvertor", "(", "dict_file", "=", "dict_file", ",", "max_seq_len", "=", "10", ")", "\n", "# test init and parse_dict", "\n", "assert", "label_convertor", ".", "num_classes", "(", ")", "==", "10", "\n", "assert", "len", "(", "label_convertor", ".", "idx2char", ")", "==", "10", "\n", "assert", "label_convertor", ".", "idx2char", "[", "0", "]", "==", "'h'", "\n", "assert", "label_convertor", ".", "idx2char", "[", "1", "]", "==", "'e'", "\n", "assert", "label_convertor", ".", "idx2char", "[", "-", "3", "]", "==", "'<UKN>'", "\n", "assert", "label_convertor", ".", "char2idx", "[", "'h'", "]", "==", "0", "\n", "assert", "label_convertor", ".", "unknown_idx", "==", "7", "\n", "\n", "# test encode str to tensor", "\n", "strings", "=", "[", "'hell'", "]", "\n", "targets_dict", "=", "label_convertor", ".", "str2tensor", "(", "strings", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'targets'", "]", "[", "0", "]", ",", "\n", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "2", "]", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'padded_targets'", "]", "[", "0", "]", ",", "\n", "torch", ".", "LongTensor", "(", "[", "8", ",", "0", ",", "1", ",", "2", ",", "2", ",", "8", ",", "9", ",", "9", ",", "9", ",", "9", "]", ")", ")", "\n", "\n", "# test decode output to index", "\n", "dummy_output", "=", "torch", ".", "Tensor", "(", "[", "[", "[", "100", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", "]", ",", "\n", "[", "1", ",", "100", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "100", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "100", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "100", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "100", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "100", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "100", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "100", ",", "9", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "100", ",", "9", "]", "]", "]", ")", "\n", "indexes", ",", "scores", "=", "label_convertor", ".", "tensor2idx", "(", "dummy_output", ")", "\n", "assert", "np", ".", "allclose", "(", "indexes", ",", "[", "[", "0", ",", "1", ",", "2", ",", "2", "]", "]", ")", "\n", "\n", "# test encode_str_label_to_index", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "label_convertor", ".", "str2idx", "(", "'hell'", ")", "\n", "", "tmp_indexes", "=", "label_convertor", ".", "str2idx", "(", "strings", ")", "\n", "assert", "np", ".", "allclose", "(", "tmp_indexes", ",", "[", "[", "0", ",", "1", ",", "2", ",", "2", "]", "]", ")", "\n", "\n", "# test decode_index to str_label", "\n", "input_indexes", "=", "[", "[", "0", ",", "1", ",", "2", ",", "2", "]", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "label_convertor", ".", "idx2str", "(", "'hell'", ")", "\n", "", "output_strings", "=", "label_convertor", ".", "idx2str", "(", "input_indexes", ")", "\n", "assert", "output_strings", "[", "0", "]", "==", "'hell'", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_attn_label_convertor.test_abi_label_convertor": [[81, 106], ["tempfile.TemporaryDirectory", "os.join", "test_attn_label_convertor._create_dummy_dict_file", "mmocr.models.textrecog.convertors.ABIConvertor", "mmocr.models.textrecog.convertors.ABIConvertor.str2tensor", "torch.allclose", "torch.allclose", "mmocr.models.textrecog.convertors.ABIConvertor.str2tensor", "torch.allclose", "torch.allclose", "tempfile.TemporaryDirectory.cleanup", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor"], ["", "def", "test_abi_label_convertor", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_dict.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "label_convertor", "=", "ABIConvertor", "(", "dict_file", "=", "dict_file", ",", "max_seq_len", "=", "10", ")", "\n", "\n", "label_convertor", ".", "end_idx", "\n", "# test encode str to tensor", "\n", "strings", "=", "[", "'hell'", "]", "\n", "targets_dict", "=", "label_convertor", ".", "str2tensor", "(", "strings", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'targets'", "]", "[", "0", "]", ",", "\n", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "2", ",", "8", "]", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'padded_targets'", "]", "[", "0", "]", ",", "\n", "torch", ".", "LongTensor", "(", "[", "8", ",", "0", ",", "1", ",", "2", ",", "2", ",", "8", ",", "9", ",", "9", ",", "9", ",", "9", "]", ")", ")", "\n", "\n", "strings", "=", "[", "'hellhellhell'", "]", "\n", "targets_dict", "=", "label_convertor", ".", "str2tensor", "(", "strings", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'targets'", "]", "[", "0", "]", ",", "\n", "torch", ".", "LongTensor", "(", "[", "0", ",", "1", ",", "2", ",", "2", ",", "0", ",", "1", ",", "2", ",", "2", ",", "0", ",", "8", "]", ")", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'padded_targets'", "]", "[", "0", "]", ",", "\n", "torch", ".", "LongTensor", "(", "[", "8", ",", "0", ",", "1", ",", "2", ",", "2", ",", "0", ",", "1", ",", "2", ",", "2", ",", "0", "]", ")", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file": [[12, 17], ["list", "open", "fw.write"], "function", ["None"], ["def", "_create_dummy_dict_file", "(", "dict_file", ")", ":", "\n", "    ", "chars", "=", "list", "(", "'helowrd'", ")", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "for", "char", "in", "chars", ":", "\n", "            ", "fw", ".", "write", "(", "char", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor.test_ctc_label_convertor": [[19, 74], ["tempfile.TemporaryDirectory", "os.join", "test_ctc_label_convertor._create_dummy_dict_file", "mmocr.models.textrecog.convertors.CTCConvertor", "torch.IntTensor", "mmocr.models.textrecog.convertors.CTCConvertor.str2tensor", "torch.allclose", "torch.allclose", "torch.allclose", "torch.Tensor", "mmocr.models.textrecog.convertors.CTCConvertor.tensor2idx", "numpy.allclose", "mmocr.models.textrecog.convertors.CTCConvertor.str2idx", "numpy.allclose", "mmocr.models.textrecog.convertors.CTCConvertor.idx2str", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.models.textrecog.convertors.CTCConvertor", "mmocr.models.textrecog.convertors.CTCConvertor.num_classes", "len", "torch.IntTensor", "pytest.raises", "mmocr.models.textrecog.convertors.CTCConvertor.str2idx", "pytest.raises", "mmocr.models.textrecog.convertors.CTCConvertor.idx2str"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_ctc_label_convertor._create_dummy_dict_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.num_classes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.str2idx", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.base.BaseConvertor.idx2str"], ["", "", "", "def", "test_ctc_label_convertor", "(", ")", ":", "\n", "    ", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "# create dummy data", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_chars.txt'", ")", "\n", "_create_dummy_dict_file", "(", "dict_file", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "CTCConvertor", "(", "5", ")", "\n", "\n", "", "label_convertor", "=", "CTCConvertor", "(", "dict_file", "=", "dict_file", ",", "with_unknown", "=", "False", ")", "\n", "# test init and parse_chars", "\n", "assert", "label_convertor", ".", "num_classes", "(", ")", "==", "8", "\n", "assert", "len", "(", "label_convertor", ".", "idx2char", ")", "==", "8", "\n", "assert", "label_convertor", ".", "idx2char", "[", "0", "]", "==", "'<BLK>'", "\n", "assert", "label_convertor", ".", "char2idx", "[", "'h'", "]", "==", "1", "\n", "assert", "label_convertor", ".", "unknown_idx", "is", "None", "\n", "\n", "# test encode str to tensor", "\n", "strings", "=", "[", "'hell'", "]", "\n", "expect_tensor", "=", "torch", ".", "IntTensor", "(", "[", "1", ",", "2", ",", "3", ",", "3", "]", ")", "\n", "targets_dict", "=", "label_convertor", ".", "str2tensor", "(", "strings", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'targets'", "]", "[", "0", "]", ",", "expect_tensor", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'flatten_targets'", "]", ",", "expect_tensor", ")", "\n", "assert", "torch", ".", "allclose", "(", "targets_dict", "[", "'target_lengths'", "]", ",", "torch", ".", "IntTensor", "(", "[", "4", "]", ")", ")", "\n", "\n", "# test decode output to index", "\n", "dummy_output", "=", "torch", ".", "Tensor", "(", "[", "[", "[", "1", ",", "100", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "100", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "1", ",", "2", ",", "100", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "1", ",", "2", ",", "100", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "100", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "100", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "100", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ",", "\n", "[", "1", ",", "2", ",", "3", ",", "100", ",", "5", ",", "6", ",", "7", ",", "8", "]", "]", "]", ")", "\n", "indexes", ",", "scores", "=", "label_convertor", ".", "tensor2idx", "(", "\n", "dummy_output", ",", "img_metas", "=", "[", "{", "\n", "'valid_ratio'", ":", "1.0", "\n", "}", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "indexes", ",", "[", "[", "1", ",", "2", ",", "3", ",", "3", "]", "]", ")", "\n", "\n", "# test encode_str_label_to_index", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "label_convertor", ".", "str2idx", "(", "'hell'", ")", "\n", "", "tmp_indexes", "=", "label_convertor", ".", "str2idx", "(", "strings", ")", "\n", "assert", "np", ".", "allclose", "(", "tmp_indexes", ",", "[", "[", "1", ",", "2", ",", "3", ",", "3", "]", "]", ")", "\n", "\n", "# test deocde_index_to_str_label", "\n", "input_indexes", "=", "[", "[", "1", ",", "2", ",", "3", ",", "3", "]", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "label_convertor", ".", "idx2str", "(", "'hell'", ")", "\n", "", "output_strings", "=", "label_convertor", ".", "idx2str", "(", "input_indexes", ")", "\n", "assert", "output_strings", "[", "0", "]", "==", "'hell'", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_label_convertor.test_base_label_convertor.test_base_label_convertor": [[10, 75], ["tempfile.TemporaryDirectory", "os.join", "mmocr.models.textrecog.convertors.BaseConvertor", "mmocr.models.textrecog.convertors.BaseConvertor", "mmocr.models.textrecog.convertors.BaseConvertor", "mmocr.models.textrecog.convertors.BaseConvertor", "mmocr.models.textrecog.convertors.BaseConvertor", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.models.textrecog.convertors.BaseConvertor", "mmocr.models.textrecog.convertors.BaseConvertor.str2tensor", "mmocr.models.textrecog.convertors.BaseConvertor.tensor2idx", "open", "fw.write", "open", "fw.write", "open", "fw.write", "open", "fw.write", "pytest.raises", "mmocr.models.textrecog.convertors.BaseConvertor", "open", "fw.write", "pytest.raises", "mmocr.models.textrecog.convertors.BaseConvertor", "open", "fw.write", "pytest.raises", "mmocr.models.textrecog.convertors.BaseConvertor", "len", "pytest.raises", "mmocr.models.textrecog.convertors.BaseConvertor"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.abi.ABIConvertor.str2tensor", "home.repos.pwc.inspect_result.open-mmlab_mmocr.convertors.ctc.CTCConvertor.tensor2idx"], ["def", "test_base_label_convertor", "(", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "label_convertor", "=", "BaseConvertor", "(", ")", "\n", "label_convertor", ".", "str2tensor", "(", "None", ")", "\n", "label_convertor", ".", "tensor2idx", "(", "None", ")", "\n", "\n", "", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "dict_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'fake_chars.txt'", ")", "\n", "\n", "# Test loading a dictionary from file", "\n", "\n", "# Test the capability of handling different line separator style", "\n", "# Set newline='' to preserve the line separators as given in the test file", "\n", "# *nix style line separator", "\n", "with", "open", "(", "dict_file", ",", "'w'", ",", "newline", "=", "''", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "'a\\nb\\n\\n \\n\\n'", ")", "\n", "", "label_convertor", "=", "BaseConvertor", "(", "dict_file", "=", "dict_file", ")", "\n", "assert", "label_convertor", ".", "idx2char", "==", "[", "'a'", ",", "'b'", ",", "' '", "]", "\n", "# Windows style line separator", "\n", "with", "open", "(", "dict_file", ",", "'w'", ",", "newline", "=", "''", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "'a\\r\\nb\\r\\n\\r\\n \\r\\n\\r\\n'", ")", "\n", "", "label_convertor", "=", "BaseConvertor", "(", "dict_file", "=", "dict_file", ")", "\n", "assert", "label_convertor", ".", "idx2char", "==", "[", "'a'", ",", "'b'", ",", "' '", "]", "\n", "\n", "# Ensure it won't parse line separator as a space character", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "'a\\nb\\n\\n\\nc\\n\\n'", ")", "\n", "", "label_convertor", "=", "BaseConvertor", "(", "dict_file", "=", "dict_file", ")", "\n", "assert", "label_convertor", ".", "idx2char", "==", "[", "'a'", ",", "'b'", ",", "'c'", "]", "\n", "\n", "# Test loading an illegal dictionary", "\n", "# Duplciated characters", "\n", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "'a\\nb\\n\\n \\n\\na'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "label_convertor", "=", "BaseConvertor", "(", "dict_file", "=", "dict_file", ")", "\n", "\n", "# Too many characters per line", "\n", "", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "'a\\nb\\nc \\n'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "\n", "ValueError", ",", "\n", "match", "=", "'Expect each line has 0 or 1 character, got 2'", "\n", "' characters at line 3'", ")", ":", "\n", "        ", "label_convertor", "=", "BaseConvertor", "(", "dict_file", "=", "dict_file", ")", "\n", "", "with", "open", "(", "dict_file", ",", "'w'", ")", "as", "fw", ":", "\n", "        ", "fw", ".", "write", "(", "'   \\n'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "\n", "ValueError", ",", "\n", "match", "=", "'Expect each line has 0 or 1 character, got 3'", "\n", "' characters at line 1'", ")", ":", "\n", "        ", "label_convertor", "=", "BaseConvertor", "(", "dict_file", "=", "dict_file", ")", "\n", "\n", "# Test creating a dictionary from dict_type", "\n", "", "label_convertor", "=", "BaseConvertor", "(", "dict_type", "=", "'DICT37'", ")", "\n", "assert", "len", "(", "label_convertor", ".", "idx2char", ")", "==", "37", "\n", "with", "pytest", ".", "raises", "(", "\n", "NotImplementedError", ",", "match", "=", "'Dict type DICT100 is not supported'", ")", ":", "\n", "        ", "label_convertor", "=", "BaseConvertor", "(", "dict_type", "=", "'DICT100'", ")", "\n", "\n", "# Test creating a dictionary from dict_list", "\n", "", "label_convertor", "=", "BaseConvertor", "(", "dict_list", "=", "[", "'a'", ",", "'b'", ",", "'c'", ",", "'d'", ",", "' '", "]", ")", "\n", "assert", "label_convertor", ".", "idx2char", "==", "[", "'a'", ",", "'b'", ",", "'c'", ",", "'d'", ",", "' '", "]", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_tools.test_data_converter.test_drop_orientation": [[10, 20], ["mmocr.utils.drop_orientation", "tempfile.TemporaryDirectory", "shutil.copy", "mmocr.utils.drop_orientation"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.img_util.drop_orientation", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.img_util.drop_orientation"], ["def", "test_drop_orientation", "(", ")", ":", "\n", "    ", "img_file", "=", "'tests/data/test_img2.jpg'", "\n", "output_file", "=", "drop_orientation", "(", "img_file", ")", "\n", "assert", "output_file", "is", "img_file", "\n", "\n", "img_file", "=", "'tests/data/test_img1.jpg'", "\n", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "dst_file", "=", "shutil", ".", "copy", "(", "img_file", ",", "tmp_dir", ".", "name", ")", "\n", "output_file", "=", "drop_orientation", "(", "dst_file", ")", "\n", "assert", "output_file", "[", "-", "3", ":", "]", "==", "'png'", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_textio.test_list_to_file": [[58, 83], ["tempfile.TemporaryDirectory", "enumerate", "enumerate", "mmocr.utils.list_to_file", "list", "all", "mmocr.utils.list_to_file", "list", "all", "line.rstrip", "map", "len", "len", "len", "len", "open().readlines", "json.dumps", "zip", "json.loads", "open().readlines", "zip", "open", "line.rstrip", "open"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_to_file"], ["def", "test_list_to_file", "(", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "# test txt", "\n", "        ", "for", "i", ",", "lines", "in", "enumerate", "(", "lists", ")", ":", "\n", "            ", "filename", "=", "f'{tmpdirname}/{i}.txt'", "\n", "list_to_file", "(", "filename", ",", "lines", ")", "\n", "lines2", "=", "[", "\n", "line", ".", "rstrip", "(", "'\\r\\n'", ")", "\n", "for", "line", "in", "open", "(", "filename", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", ".", "readlines", "(", ")", "\n", "]", "\n", "lines", "=", "list", "(", "map", "(", "str", ",", "lines", ")", ")", "\n", "assert", "len", "(", "lines", ")", "==", "len", "(", "lines2", ")", "\n", "assert", "all", "(", "line1", "==", "line2", "for", "line1", ",", "line2", "in", "zip", "(", "lines", ",", "lines2", ")", ")", "\n", "# test jsonl", "\n", "", "for", "i", ",", "lines", "in", "enumerate", "(", "dicts", ")", ":", "\n", "            ", "filename", "=", "f'{tmpdirname}/{i}.jsonl'", "\n", "list_to_file", "(", "filename", ",", "[", "json", ".", "dumps", "(", "line", ")", "for", "line", "in", "lines", "]", ")", "\n", "lines2", "=", "[", "\n", "json", ".", "loads", "(", "line", ".", "rstrip", "(", "'\\r\\n'", ")", ")", "[", "'text'", "]", "\n", "for", "line", "in", "open", "(", "filename", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", ".", "readlines", "(", ")", "\n", "]", "[", "0", "]", "\n", "\n", "lines", "=", "list", "(", "lines", "[", "0", "]", "[", "'text'", "]", ")", "\n", "assert", "len", "(", "lines", ")", "==", "len", "(", "lines2", ")", "\n", "assert", "all", "(", "line1", "==", "line2", "for", "line1", ",", "line2", "in", "zip", "(", "lines", ",", "lines2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_textio.test_list_from_file": [[85, 105], ["tempfile.TemporaryDirectory", "enumerate", "enumerate", "mmocr.utils.list_from_file", "list", "all", "mmocr.utils.list_from_file", "list", "all", "open", "f.writelines", "map", "len", "len", "open", "f.writelines", "map", "len", "len", "zip", "zip"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.fileio.list_from_file"], ["", "", "", "def", "test_list_from_file", "(", ")", ":", "\n", "    ", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "# test txt file", "\n", "        ", "for", "i", ",", "lines", "in", "enumerate", "(", "lists", ")", ":", "\n", "            ", "filename", "=", "f'{tmpdirname}/{i}.txt'", "\n", "with", "open", "(", "filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "                ", "f", ".", "writelines", "(", "f'{line}\\n'", "for", "line", "in", "lines", ")", "\n", "", "lines2", "=", "list_from_file", "(", "filename", ",", "encoding", "=", "'utf-8'", ")", "\n", "lines", "=", "list", "(", "map", "(", "str", ",", "lines", ")", ")", "\n", "assert", "len", "(", "lines", ")", "==", "len", "(", "lines2", ")", "\n", "assert", "all", "(", "line1", "==", "line2", "for", "line1", ",", "line2", "in", "zip", "(", "lines", ",", "lines2", ")", ")", "\n", "# test jsonl file", "\n", "", "for", "i", ",", "lines", "in", "enumerate", "(", "dicts", ")", ":", "\n", "            ", "filename", "=", "f'{tmpdirname}/{i}.jsonl'", "\n", "with", "open", "(", "filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "                ", "f", ".", "writelines", "(", "f'{line}\\n'", "for", "line", "in", "lines", ")", "\n", "", "lines2", "=", "list_from_file", "(", "filename", ",", "encoding", "=", "'utf-8'", ")", "\n", "lines", "=", "list", "(", "map", "(", "str", ",", "lines", ")", ")", "\n", "assert", "len", "(", "lines", ")", "==", "len", "(", "lines2", ")", "\n", "assert", "all", "(", "line1", "==", "line2", "for", "line1", ",", "line2", "in", "zip", "(", "lines", ",", "lines2", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_model.test_revert_sync_batchnorm": [[9, 23], ["mmcv.cnn.bricks.ConvModule().to", "ConvModule().to.train", "torch.randn", "mmocr.utils.revert_sync_batchnorm", "mmocr.utils.revert_sync_batchnorm.", "ConvModule().to.eval", "mmocr.utils.revert_sync_batchnorm", "pytest.raises", "ConvModule().to.", "mmcv.cnn.bricks.ConvModule", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.backbones.unet.UNet.train", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm", "home.repos.pwc.inspect_result.open-mmlab_mmocr.decoders.sar_decoder_with_bs.DecodeNode.eval", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.model.revert_sync_batchnorm"], ["def", "test_revert_sync_batchnorm", "(", ")", ":", "\n", "    ", "conv_syncbn", "=", "ConvModule", "(", "3", ",", "8", ",", "2", ",", "norm_cfg", "=", "dict", "(", "type", "=", "'SyncBN'", ")", ")", ".", "to", "(", "'cpu'", ")", "\n", "conv_syncbn", ".", "train", "(", ")", "\n", "x", "=", "torch", ".", "randn", "(", "1", ",", "3", ",", "10", ",", "10", ")", "\n", "# Will raise an ValueError saying SyncBN does not run on CPU", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "y", "=", "conv_syncbn", "(", "x", ")", "\n", "", "conv_bn", "=", "revert_sync_batchnorm", "(", "conv_syncbn", ")", "\n", "y", "=", "conv_bn", "(", "x", ")", "\n", "assert", "y", ".", "shape", "==", "(", "1", ",", "8", ",", "9", ",", "9", ")", "\n", "assert", "conv_bn", ".", "training", "==", "conv_syncbn", ".", "training", "\n", "conv_syncbn", ".", "eval", "(", ")", "\n", "conv_bn", "=", "revert_sync_batchnorm", "(", "conv_syncbn", ")", "\n", "assert", "conv_bn", ".", "training", "==", "conv_syncbn", ".", "training", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_box.test_box_on_line": [[9, 23], ["mmocr.utils.is_on_same_line", "mmocr.utils.is_on_same_line", "mmocr.utils.is_on_same_line", "mmocr.utils.is_on_same_line"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.is_on_same_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.is_on_same_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.is_on_same_line", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.is_on_same_line"], ["def", "test_box_on_line", "(", ")", ":", "\n", "# regular boxes", "\n", "    ", "box1", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "\n", "box2", "=", "[", "2", ",", "0.5", ",", "3", ",", "0.5", ",", "3", ",", "1.5", ",", "2", ",", "1.5", "]", "\n", "box3", "=", "[", "4", ",", "0.8", ",", "5", ",", "0.8", ",", "5", ",", "1.8", ",", "4", ",", "1.8", "]", "\n", "assert", "is_on_same_line", "(", "box1", ",", "box2", ",", "0.5", ")", "\n", "assert", "not", "is_on_same_line", "(", "box1", ",", "box3", ",", "0.5", ")", "\n", "\n", "# irregular box4", "\n", "box4", "=", "[", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "2", ",", "0", ",", "1", "]", "\n", "box5", "=", "[", "2", ",", "1.5", ",", "3", ",", "1.5", ",", "3", ",", "2.5", ",", "2", ",", "2.5", "]", "\n", "box6", "=", "[", "2", ",", "1.6", ",", "3", ",", "1.6", ",", "3", ",", "2.6", ",", "2", ",", "2.6", "]", "\n", "assert", "is_on_same_line", "(", "box4", ",", "box5", ",", "0.5", ")", "\n", "assert", "not", "is_on_same_line", "(", "box4", ",", "box6", ",", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_box.test_stitch_boxes_into_lines": [[25, 53], ["mmocr.utils.stitch_boxes_into_lines", "mmocr.utils.stitch_boxes_into_lines.sort", "expected_result.sort", "str", "range", "len"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.stitch_boxes_into_lines"], ["", "def", "test_stitch_boxes_into_lines", "(", ")", ":", "\n", "    ", "boxes", "=", "[", "# regular boxes", "\n", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "2", ",", "0.5", ",", "3", ",", "0.5", ",", "3", ",", "1.5", ",", "2", ",", "1.5", "]", ",", "\n", "[", "3", ",", "1.2", ",", "4", ",", "1.2", ",", "4", ",", "2.2", ",", "3", ",", "2.2", "]", ",", "\n", "[", "5", ",", "0.5", ",", "6", ",", "0.5", ",", "6", ",", "1.5", ",", "5", ",", "1.5", "]", ",", "\n", "# irregular box", "\n", "[", "6", ",", "1.5", ",", "7", ",", "1.25", ",", "7", ",", "1.75", ",", "6", ",", "1.75", "]", "\n", "]", "\n", "raw_input", "=", "[", "{", "'box'", ":", "boxes", "[", "i", "]", ",", "'text'", ":", "str", "(", "i", ")", "}", "for", "i", "in", "range", "(", "len", "(", "boxes", ")", ")", "]", "\n", "result", "=", "stitch_boxes_into_lines", "(", "raw_input", ",", "1", ",", "0.5", ")", "\n", "# Final lines: [0, 1], [2], [3, 4]", "\n", "# box 0, 1, 3, 4 are on the same line but box 3 is 2 pixels away from box 1", "\n", "# box 3 and 4 are on the same line since the length of overlapping part >=", "\n", "# 0.5 * the y-axis length of box 5", "\n", "expected_result", "=", "[", "{", "\n", "'box'", ":", "[", "0", ",", "0", ",", "3", ",", "0", ",", "3", ",", "1.5", ",", "0", ",", "1.5", "]", ",", "\n", "'text'", ":", "'0 1'", "\n", "}", ",", "{", "\n", "'box'", ":", "[", "3", ",", "1.2", ",", "4", ",", "1.2", ",", "4", ",", "2.2", ",", "3", ",", "2.2", "]", ",", "\n", "'text'", ":", "'2'", "\n", "}", ",", "{", "\n", "'box'", ":", "[", "5", ",", "0.5", ",", "7", ",", "0.5", ",", "7", ",", "1.75", ",", "5", ",", "1.75", "]", ",", "\n", "'text'", ":", "'3 4'", "\n", "}", "]", "\n", "result", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "'box'", "]", "[", "0", "]", ")", "\n", "expected_result", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "'box'", "]", "[", "0", "]", ")", "\n", "assert", "result", "==", "expected_result", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_box.test_bezier_to_polygon": [[55, 111], ["mmocr.utils.bezier_to_polygon", "numpy.array", "numpy.allclose", "mmocr.utils.bezier_to_polygon", "numpy.array", "numpy.allclose", "pytest.raises", "mmocr.utils.bezier_to_polygon", "pytest.raises", "mmocr.utils.bezier_to_polygon"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.bezier_to_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.bezier_to_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.bezier_to_polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.bezier_to_polygon"], ["", "def", "test_bezier_to_polygon", "(", ")", ":", "\n", "    ", "bezier_points", "=", "[", "\n", "37.0", ",", "249.0", ",", "72.5", ",", "229.55", ",", "95.34", ",", "220.65", ",", "134.0", ",", "216.0", ",", "132.0", ",", "233.0", ",", "\n", "82.11", ",", "240.2", ",", "72.46", ",", "247.16", ",", "38.0", ",", "263.0", "\n", "]", "\n", "pts", "=", "bezier_to_polygon", "(", "bezier_points", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "37.0", ",", "249.0", "]", ",", "[", "42.50420761043885", ",", "246.01570199737577", "]", ",", "\n", "[", "47.82291296107305", ",", "243.2012392477038", "]", ",", "\n", "[", "52.98102930456334", ",", "240.5511007435486", "]", ",", "\n", "[", "58.00346989357049", ",", "238.05977547747486", "]", ",", "\n", "[", "62.91514798075522", ",", "235.721752442047", "]", ",", "\n", "[", "67.74097681877824", ",", "233.53152062982943", "]", ",", "\n", "[", "72.50586966030032", ",", "231.48356903338674", "]", ",", "\n", "[", "77.23473975798221", ",", "229.57238664528356", "]", ",", "\n", "[", "81.95250036448464", ",", "227.79246245808432", "]", ",", "\n", "[", "86.68406473246829", ",", "226.13828546435346", "]", ",", "\n", "[", "91.45434611459396", ",", "224.60434465665548", "]", ",", "\n", "[", "96.28825776352238", ",", "223.18512902755504", "]", ",", "\n", "[", "101.21071293191426", ",", "221.87512756961655", "]", ",", "\n", "[", "106.24662487243039", ",", "220.6688292754046", "]", ",", "\n", "[", "111.42090683773145", ",", "219.5607231374836", "]", ",", "\n", "[", "116.75847208047819", ",", "218.5452981484181", "]", ",", "\n", "[", "122.28423385333137", ",", "217.6170433007727", "]", ",", "\n", "[", "128.02310540895172", ",", "216.77044758711182", "]", ",", "\n", "[", "134.0", ",", "216.0", "]", ",", "[", "132.0", ",", "233.0", "]", ",", "\n", "[", "124.4475521213005", ",", "234.13617728531858", "]", ",", "\n", "[", "117.50700976818779", ",", "235.2763434903047", "]", ",", "\n", "[", "111.12146960198277", ",", "236.42847645429362", "]", ",", "\n", "[", "105.2340282840064", ",", "237.6005540166205", "]", ",", "\n", "[", "99.78778247557953", ",", "238.80055401662054", "]", ",", "\n", "[", "94.72582883802303", ",", "240.0364542936288", "]", ",", "\n", "[", "89.99126403265781", ",", "241.31623268698053", "]", ",", "\n", "[", "85.52718472080478", ",", "242.64786703601104", "]", ",", "\n", "[", "81.27668756378483", ",", "244.03933518005545", "]", ",", "\n", "[", "77.1828692229188", ",", "245.49861495844874", "]", ",", "\n", "[", "73.18882635952762", ",", "247.0336842105263", "]", ",", "\n", "[", "69.23765563493221", ",", "248.65252077562326", "]", ",", "\n", "[", "65.27245371045342", ",", "250.3631024930748", "]", ",", "\n", "[", "61.23631724741216", ",", "252.17340720221605", "]", ",", "\n", "[", "57.07234290712931", ",", "254.09141274238226", "]", ",", "\n", "[", "52.723627350925796", ",", "256.12509695290856", "]", ",", "\n", "[", "48.13326724012247", ",", "258.2824376731302", "]", ",", "\n", "[", "43.24435923604024", ",", "260.5714127423822", "]", ",", "[", "38.0", ",", "263.0", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "pts", ",", "target", ")", "\n", "\n", "bezier_points", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "2", ",", "0", ",", "3", ",", "1", ",", "0", ",", "1", ",", "1", ",", "1", ",", "2", ",", "1", ",", "3", "]", "\n", "pts", "=", "bezier_to_polygon", "(", "bezier_points", ",", "num_sample", "=", "3", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "0", ",", "1.5", "]", ",", "[", "0", ",", "3", "]", ",", "[", "1", ",", "0", "]", ",", "[", "1", ",", "1.5", "]", ",", "[", "1", ",", "3", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "pts", ",", "target", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "bezier_to_polygon", "(", "bezier_points", ",", "num_sample", "=", "-", "1", ")", "\n", "\n", "", "bezier_points", "=", "[", "0", ",", "1", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "bezier_to_polygon", "(", "bezier_points", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_box.test_sort_points": [[113, 129], ["numpy.array", "numpy.array", "numpy.allclose", "numpy.array", "numpy.array", "numpy.allclose", "numpy.allclose", "mmocr.utils.sort_points", "mmocr.utils.sort_points", "mmocr.utils.sort_points", "pytest.raises", "mmocr.utils.sort_points"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.sort_points", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.sort_points", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.sort_points", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.box_util.sort_points"], ["", "", "def", "test_sort_points", "(", ")", ":", "\n", "    ", "points", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "1", ",", "-", "1", "]", ",", "[", "2", ",", "-", "2", "]", ",", "[", "0", ",", "2", "]", ",", "[", "1", ",", "1", "]", ",", "\n", "[", "0", ",", "1", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", "]", "]", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "-", "1", ",", "-", "1", "]", ",", "[", "0", ",", "0", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "[", "1", ",", "1", "]", ",", "\n", "[", "1", ",", "1", "]", ",", "[", "2", ",", "-", "2", "]", ",", "[", "1", ",", "-", "1", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "target", ",", "sort_points", "(", "points", ")", ")", "\n", "\n", "points", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "-", "1", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", "]", "]", ")", "\n", "target", "=", "np", ".", "array", "(", "[", "[", "-", "1", ",", "-", "1", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "-", "1", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "target", ",", "sort_points", "(", "points", ")", ")", "\n", "\n", "points", "=", "[", "[", "1", ",", "1", "]", ",", "[", "1", ",", "-", "1", "]", ",", "[", "-", "1", ",", "1", "]", ",", "[", "-", "1", ",", "-", "1", "]", "]", "\n", "assert", "np", ".", "allclose", "(", "target", ",", "sort_points", "(", "points", ")", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "sort_points", "(", "[", "1", ",", "2", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_check_argument.test_is_3dlist": [[7, 15], ["mmocr.is_3dlist", "mmocr.is_3dlist", "mmocr.is_3dlist", "mmocr.is_3dlist", "mmocr.is_3dlist", "mmocr.is_3dlist", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_3dlist"], ["def", "test_is_3dlist", "(", ")", ":", "\n", "\n", "    ", "assert", "utils", ".", "is_3dlist", "(", "[", "]", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "[", "[", "]", "]", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "[", "[", "[", "]", "]", "]", ")", "\n", "assert", "utils", ".", "is_3dlist", "(", "[", "[", "[", "1", "]", "]", "]", ")", "\n", "assert", "not", "utils", ".", "is_3dlist", "(", "[", "[", "1", ",", "2", "]", "]", ")", "\n", "assert", "not", "utils", ".", "is_3dlist", "(", "[", "[", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_check_argument.test_is_2dlist": [[17, 22], ["mmocr.is_2dlist", "mmocr.is_2dlist", "mmocr.is_2dlist"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_2dlist"], ["", "def", "test_is_2dlist", "(", ")", ":", "\n", "\n", "    ", "assert", "utils", ".", "is_2dlist", "(", "[", "]", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "[", "[", "]", "]", ")", "\n", "assert", "utils", ".", "is_2dlist", "(", "[", "[", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_check_argument.test_is_type_list": [[24, 30], ["mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_type_list", "mmocr.is_type_list", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_type_list"], ["", "def", "test_is_type_list", "(", ")", ":", "\n", "    ", "assert", "utils", ".", "is_type_list", "(", "[", "]", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "[", "]", ",", "float", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "[", "np", ".", "array", "(", "[", "]", ")", "]", ",", "np", ".", "ndarray", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "[", "1", "]", ",", "int", ")", "\n", "assert", "utils", ".", "is_type_list", "(", "[", "'str'", "]", ",", "str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_check_argument.test_is_none_or_type": [[32, 39], ["mmocr.is_none_or_type", "mmocr.is_none_or_type", "mmocr.is_none_or_type", "mmocr.is_none_or_type", "mmocr.is_none_or_type", "numpy.ndarray"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.is_none_or_type"], ["", "def", "test_is_none_or_type", "(", ")", ":", "\n", "\n", "    ", "assert", "utils", ".", "is_none_or_type", "(", "None", ",", "int", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "1.0", ",", "float", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "np", ".", "ndarray", "(", "[", "]", ")", ",", "np", ".", "ndarray", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "1", ",", "int", ")", "\n", "assert", "utils", ".", "is_none_or_type", "(", "'str'", ",", "str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_check_argument.test_valid_boundary": [[41, 49], ["mmocr.valid_boundary", "mmocr.valid_boundary", "mmocr.valid_boundary", "mmocr.valid_boundary"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.check_argument.valid_boundary"], ["", "def", "test_valid_boundary", "(", ")", ":", "\n", "\n", "    ", "x", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "\n", "assert", "not", "utils", ".", "valid_boundary", "(", "x", ",", "True", ")", "\n", "assert", "not", "utils", ".", "valid_boundary", "(", "[", "0", "]", ")", "\n", "assert", "utils", ".", "valid_boundary", "(", "x", ",", "False", ")", "\n", "x", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "\n", "assert", "utils", ".", "valid_boundary", "(", "x", ",", "True", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_string_util.test_string_strip": [[7, 36], ["enumerate", "enumerate", "pytest.raises", "mmocr.utils.StringStrip", "mmocr.utils.StringStrip", "mmocr.utils.StringStrip", "enumerate", "dict", "mmocr.utils.StringStrip", "mmocr.utils.StringStrip.", "len", "len", "len"], "function", ["None"], ["def", "test_string_strip", "(", ")", ":", "\n", "    ", "strip_list", "=", "[", "True", ",", "False", "]", "\n", "strip_pos_list", "=", "[", "'both'", ",", "'left'", ",", "'right'", "]", "\n", "strip_str_list", "=", "[", "None", ",", "' '", "]", "\n", "\n", "in_str_list", "=", "[", "\n", "' hello '", ",", "'hello '", ",", "' hello'", ",", "' hello'", ",", "'hello '", ",", "'hello '", ",", "'hello'", ",", "\n", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", "\n", "]", "\n", "out_str_list", "=", "[", "\n", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", ",", "\n", "'hello'", ",", "'hello'", ",", "'hello'", ",", "'hello'", "\n", "]", "\n", "\n", "for", "idx1", ",", "strip", "in", "enumerate", "(", "strip_list", ")", ":", "\n", "        ", "for", "idx2", ",", "strip_pos", "in", "enumerate", "(", "strip_pos_list", ")", ":", "\n", "            ", "for", "idx3", ",", "strip_str", "in", "enumerate", "(", "strip_str_list", ")", ":", "\n", "                ", "tmp_args", "=", "dict", "(", "\n", "strip", "=", "strip", ",", "strip_pos", "=", "strip_pos", ",", "strip_str", "=", "strip_str", ")", "\n", "strip_class", "=", "StringStrip", "(", "**", "tmp_args", ")", "\n", "i", "=", "idx1", "*", "len", "(", "strip_pos_list", ")", "*", "len", "(", "\n", "strip_str_list", ")", "+", "idx2", "*", "len", "(", "strip_str_list", ")", "+", "idx3", "\n", "\n", "assert", "strip_class", "(", "in_str_list", "[", "i", "]", ")", "==", "out_str_list", "[", "i", "]", "\n", "\n", "", "", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "StringStrip", "(", "strip", "=", "'strip'", ")", "\n", "StringStrip", "(", "strip_pos", "=", "'head'", ")", "\n", "StringStrip", "(", "strip_str", "=", "[", "'\\n'", ",", "'\\t'", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_version_utils.test_digit_version": [[5, 22], ["mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version", "mmocr.digit_version"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version", "home.repos.pwc.inspect_result.open-mmlab_mmocr.mmocr.__init__.digit_version"], ["def", "test_digit_version", "(", ")", ":", "\n", "    ", "assert", "digit_version", "(", "'0.2.16'", ")", "==", "(", "0", ",", "2", ",", "16", ",", "0", ",", "0", ",", "0", ")", "\n", "assert", "digit_version", "(", "'1.2.3'", ")", "==", "(", "1", ",", "2", ",", "3", ",", "0", ",", "0", ",", "0", ")", "\n", "assert", "digit_version", "(", "'1.2.3rc0'", ")", "==", "(", "1", ",", "2", ",", "3", ",", "0", ",", "-", "1", ",", "0", ")", "\n", "assert", "digit_version", "(", "'1.2.3rc1'", ")", "==", "(", "1", ",", "2", ",", "3", ",", "0", ",", "-", "1", ",", "1", ")", "\n", "assert", "digit_version", "(", "'1.0rc0'", ")", "==", "(", "1", ",", "0", ",", "0", ",", "0", ",", "-", "1", ",", "0", ")", "\n", "assert", "digit_version", "(", "'1.0'", ")", "==", "digit_version", "(", "'1.0.0'", ")", "\n", "assert", "digit_version", "(", "'1.5.0+cuda90_cudnn7.6.3_lms'", ")", "==", "digit_version", "(", "'1.5'", ")", "\n", "assert", "digit_version", "(", "'1.0.0dev'", ")", "<", "digit_version", "(", "'1.0.0a'", ")", "\n", "assert", "digit_version", "(", "'1.0.0a'", ")", "<", "digit_version", "(", "'1.0.0a1'", ")", "\n", "assert", "digit_version", "(", "'1.0.0a'", ")", "<", "digit_version", "(", "'1.0.0b'", ")", "\n", "assert", "digit_version", "(", "'1.0.0b'", ")", "<", "digit_version", "(", "'1.0.0rc'", ")", "\n", "assert", "digit_version", "(", "'1.0.0rc1'", ")", "<", "digit_version", "(", "'1.0.0'", ")", "\n", "assert", "digit_version", "(", "'1.0.0'", ")", "<", "digit_version", "(", "'1.0.0post'", ")", "\n", "assert", "digit_version", "(", "'1.0.0post'", ")", "<", "digit_version", "(", "'1.0.0post1'", ")", "\n", "assert", "digit_version", "(", "'v1'", ")", "==", "(", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ")", "\n", "assert", "digit_version", "(", "'v1.1.5'", ")", "==", "(", "1", ",", "1", ",", "5", ",", "0", ",", "0", ",", "0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_setup_env.test_setup_multi_processes": [[12, 69], ["multiprocessing.get_start_method", "cv2.getNumThreads", "os.environ.pop", "os.environ.pop", "dict", "mmcv.Config", "mmocr.utils.setup_multi_processes", "os.environ.pop", "os.environ.pop", "dict", "mmcv.Config", "mmocr.utils.setup_multi_processes", "dict", "mmcv.Config", "mmocr.utils.setup_multi_processes", "dict", "mmcv.Config", "mmocr.utils.setup_multi_processes", "cv2.setNumThreads", "os.getenv", "os.getenv", "cv2.getNumThreads", "platform.system", "os.getenv", "cv2.getNumThreads", "multiprocessing.get_start_method", "multiprocessing.set_start_method", "os.environ.pop", "os.environ.pop", "dict", "multiprocessing.get_start_method", "dict", "dict", "dict"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.setup_env.setup_multi_processes"], ["def", "test_setup_multi_processes", "(", ")", ":", "\n", "# temp save system setting", "\n", "    ", "sys_start_mehod", "=", "mp", ".", "get_start_method", "(", "allow_none", "=", "True", ")", "\n", "sys_cv_threads", "=", "cv2", ".", "getNumThreads", "(", ")", "\n", "# pop and temp save system env vars", "\n", "sys_omp_threads", "=", "os", ".", "environ", ".", "pop", "(", "'OMP_NUM_THREADS'", ",", "default", "=", "None", ")", "\n", "sys_mkl_threads", "=", "os", ".", "environ", ".", "pop", "(", "'MKL_NUM_THREADS'", ",", "default", "=", "None", ")", "\n", "\n", "# test config without setting env", "\n", "config", "=", "dict", "(", "data", "=", "dict", "(", "workers_per_gpu", "=", "2", ")", ")", "\n", "cfg", "=", "Config", "(", "config", ")", "\n", "setup_multi_processes", "(", "cfg", ")", "\n", "assert", "os", ".", "getenv", "(", "'OMP_NUM_THREADS'", ")", "==", "'1'", "\n", "assert", "os", ".", "getenv", "(", "'MKL_NUM_THREADS'", ")", "==", "'1'", "\n", "# when set to 0, the num threads will be 1", "\n", "assert", "cv2", ".", "getNumThreads", "(", ")", "==", "1", "\n", "if", "platform", ".", "system", "(", ")", "!=", "'Windows'", ":", "\n", "        ", "assert", "mp", ".", "get_start_method", "(", ")", "==", "'fork'", "\n", "\n", "# test num workers <= 1", "\n", "", "os", ".", "environ", ".", "pop", "(", "'OMP_NUM_THREADS'", ")", "\n", "os", ".", "environ", ".", "pop", "(", "'MKL_NUM_THREADS'", ")", "\n", "config", "=", "dict", "(", "data", "=", "dict", "(", "workers_per_gpu", "=", "0", ")", ")", "\n", "cfg", "=", "Config", "(", "config", ")", "\n", "setup_multi_processes", "(", "cfg", ")", "\n", "assert", "'OMP_NUM_THREADS'", "not", "in", "os", ".", "environ", "\n", "assert", "'MKL_NUM_THREADS'", "not", "in", "os", ".", "environ", "\n", "\n", "# test manually set env var", "\n", "os", ".", "environ", "[", "'OMP_NUM_THREADS'", "]", "=", "'4'", "\n", "config", "=", "dict", "(", "data", "=", "dict", "(", "workers_per_gpu", "=", "2", ")", ")", "\n", "cfg", "=", "Config", "(", "config", ")", "\n", "setup_multi_processes", "(", "cfg", ")", "\n", "assert", "os", ".", "getenv", "(", "'OMP_NUM_THREADS'", ")", "==", "'4'", "\n", "\n", "# test manually set opencv threads and mp start method", "\n", "config", "=", "dict", "(", "\n", "data", "=", "dict", "(", "workers_per_gpu", "=", "2", ")", ",", "\n", "opencv_num_threads", "=", "4", ",", "\n", "mp_start_method", "=", "'spawn'", ")", "\n", "cfg", "=", "Config", "(", "config", ")", "\n", "setup_multi_processes", "(", "cfg", ")", "\n", "assert", "cv2", ".", "getNumThreads", "(", ")", "==", "4", "\n", "assert", "mp", ".", "get_start_method", "(", ")", "==", "'spawn'", "\n", "\n", "# revert setting to avoid affecting other programs", "\n", "if", "sys_start_mehod", ":", "\n", "        ", "mp", ".", "set_start_method", "(", "sys_start_mehod", ",", "force", "=", "True", ")", "\n", "", "cv2", ".", "setNumThreads", "(", "sys_cv_threads", ")", "\n", "if", "sys_omp_threads", ":", "\n", "        ", "os", ".", "environ", "[", "'OMP_NUM_THREADS'", "]", "=", "sys_omp_threads", "\n", "", "else", ":", "\n", "        ", "os", ".", "environ", ".", "pop", "(", "'OMP_NUM_THREADS'", ")", "\n", "", "if", "sys_mkl_threads", ":", "\n", "        ", "os", ".", "environ", "[", "'MKL_NUM_THREADS'", "]", "=", "sys_mkl_threads", "\n", "", "else", ":", "\n", "        ", "os", ".", "environ", ".", "pop", "(", "'MKL_NUM_THREADS'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_wrapper.test_db_boxes_from_bitmaps": [[12, 21], ["numpy.array", "torch.FloatTensor().requires_grad_", "mmocr.models.textdet.postprocess.DBPostprocessor", "mmocr.models.textdet.postprocess.DBPostprocessor.", "len", "torch.FloatTensor"], "function", ["None"], ["def", "test_db_boxes_from_bitmaps", "(", ")", ":", "\n", "    ", "\"\"\"Test the boxes_from_bitmaps function in db_decoder.\"\"\"", "\n", "pred", "=", "np", ".", "array", "(", "[", "[", "[", "0.8", ",", "0.8", ",", "0.8", ",", "0.8", ",", "0", "]", ",", "[", "0.8", ",", "0.8", ",", "0.8", ",", "0.8", ",", "0", "]", ",", "\n", "[", "0.8", ",", "0.8", ",", "0.8", ",", "0.8", ",", "0", "]", ",", "[", "0.8", ",", "0.8", ",", "0.8", ",", "0.8", ",", "0", "]", ",", "\n", "[", "0.8", ",", "0.8", ",", "0.8", ",", "0.8", ",", "0", "]", "]", "]", ")", "\n", "preds", "=", "torch", ".", "FloatTensor", "(", "pred", ")", ".", "requires_grad_", "(", "True", ")", "\n", "db_decode", "=", "DBPostprocessor", "(", "text_repr_type", "=", "'quad'", ",", "min_text_width", "=", "0", ")", "\n", "boxes", "=", "db_decode", "(", "preds", ")", "\n", "assert", "len", "(", "boxes", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_wrapper.test_fcenet_decode": [[23, 34], ["preds.append", "preds.append", "mmocr.models.textdet.postprocess.FCEPostprocessor", "mmocr.models.textdet.postprocess.FCEPostprocessor.", "isinstance", "torch.ones", "torch.ones"], "function", ["None"], ["", "def", "test_fcenet_decode", "(", ")", ":", "\n", "\n", "    ", "k", "=", "1", "\n", "preds", "=", "[", "]", "\n", "preds", ".", "append", "(", "torch", ".", "ones", "(", "1", ",", "4", ",", "10", ",", "10", ")", ")", "\n", "preds", ".", "append", "(", "torch", ".", "ones", "(", "1", ",", "4", "*", "k", "+", "2", ",", "10", ",", "10", ")", ")", "\n", "fcenet_decode", "=", "FCEPostprocessor", "(", "\n", "fourier_degree", "=", "k", ",", "num_reconstr_points", "=", "50", ",", "nms_thr", "=", "0.01", ")", "\n", "boundaries", "=", "fcenet_decode", "(", "preds", "=", "preds", ",", "scale", "=", "1", ")", "\n", "\n", "assert", "isinstance", "(", "boundaries", ",", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_wrapper.test_poly_nms": [[36, 46], ["polygons.append", "polygons.append", "polygons.append", "polygons.append", "mmocr.models.textdet.postprocess.utils.poly_nms", "isinstance"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.poly_nms"], ["", "def", "test_poly_nms", "(", ")", ":", "\n", "    ", "threshold", "=", "0", "\n", "polygons", "=", "[", "]", "\n", "polygons", ".", "append", "(", "[", "10", ",", "10", ",", "10", ",", "30", ",", "30", ",", "30", ",", "30", ",", "10", ",", "0.95", "]", ")", "\n", "polygons", ".", "append", "(", "[", "15", ",", "15", ",", "15", ",", "25", ",", "25", ",", "25", ",", "25", ",", "15", ",", "0.9", "]", ")", "\n", "polygons", ".", "append", "(", "[", "40", ",", "40", ",", "40", ",", "50", ",", "50", ",", "50", ",", "50", ",", "40", ",", "0.85", "]", ")", "\n", "polygons", ".", "append", "(", "[", "5", ",", "5", ",", "5", ",", "15", ",", "15", ",", "15", ",", "15", ",", "5", ",", "0.7", "]", ")", "\n", "\n", "keep_poly", "=", "poly_nms", "(", "polygons", ",", "threshold", ")", "\n", "assert", "isinstance", "(", "keep_poly", ",", "list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_wrapper.test_comps2boundaries": [[48, 66], ["numpy.arange", "numpy.stack().transpose", "numpy.array", "mmocr.models.textdet.postprocess.utils.comps2boundaries", "mmocr.models.textdet.postprocess.utils.comps2boundaries", "numpy.ones", "numpy.ones", "len", "len", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.comps2boundaries", "home.repos.pwc.inspect_result.open-mmlab_mmocr.postprocess.utils.comps2boundaries"], ["", "def", "test_comps2boundaries", "(", ")", ":", "\n", "\n", "# test comps2boundaries", "\n", "    ", "x1", "=", "np", ".", "arange", "(", "2", ",", "18", ",", "2", ")", "\n", "x2", "=", "x1", "+", "2", "\n", "y1", "=", "np", ".", "ones", "(", "8", ")", "*", "2", "\n", "y2", "=", "y1", "+", "2", "\n", "comp_scores", "=", "np", ".", "ones", "(", "8", ",", "dtype", "=", "np", ".", "float32", ")", "*", "0.9", "\n", "text_comps", "=", "np", ".", "stack", "(", "[", "x1", ",", "y1", ",", "x2", ",", "y1", ",", "x2", ",", "y2", ",", "x1", ",", "y2", ",", "\n", "comp_scores", "]", ")", ".", "transpose", "(", ")", "\n", "comp_labels", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "3", ",", "5", ",", "5", "]", ")", "\n", "shuffle", "=", "[", "3", ",", "2", ",", "5", ",", "7", ",", "6", ",", "0", ",", "4", ",", "1", "]", "\n", "boundaries", "=", "comps2boundaries", "(", "text_comps", "[", "shuffle", "]", ",", "comp_labels", "[", "shuffle", "]", ")", "\n", "assert", "len", "(", "boundaries", ")", "==", "3", "\n", "\n", "# test comps2boundaries with blank inputs", "\n", "boundaries", "=", "comps2boundaries", "(", "text_comps", "[", "[", "]", "]", ",", "comp_labels", "[", "[", "]", "]", ")", "\n", "assert", "len", "(", "boundaries", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_wrapper.test_textsnake_decode": [[68, 94], ["torch.zeros", "mmocr.models.textdet.postprocess.TextSnakePostprocessor", "mmocr.models.textdet.postprocess.TextSnakePostprocessor.", "torch.zeros.fill_", "mmocr.models.textdet.postprocess.TextSnakePostprocessor.", "torch.squeeze", "len", "torch.squeeze", "len"], "function", ["None"], ["", "def", "test_textsnake_decode", "(", ")", ":", "\n", "\n", "    ", "maps", "=", "torch", ".", "zeros", "(", "(", "1", ",", "6", ",", "224", ",", "224", ")", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "maps", "[", ":", ",", "0", ":", "2", ",", ":", ",", ":", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "0", ",", "60", ":", "100", ",", "50", ":", "170", "]", "=", "10.", "\n", "maps", "[", ":", ",", "1", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "maps", "[", ":", ",", "2", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "0.", "\n", "maps", "[", ":", ",", "3", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "1.", "\n", "maps", "[", ":", ",", "4", ",", "75", ":", "85", ",", "60", ":", "160", "]", "=", "10.", "\n", "# test decoding with text center region of small area", "\n", "maps", "[", ":", ",", "0", ":", "2", ",", "150", ":", "152", ",", "5", ":", "7", "]", "=", "10.", "\n", "textsnake_decode", "=", "TextSnakePostprocessor", "(", ")", "\n", "results", "=", "textsnake_decode", "(", "torch", ".", "squeeze", "(", "maps", ")", ")", "\n", "assert", "len", "(", "results", ")", "==", "1", "\n", "\n", "# test decoding with small radius", "\n", "maps", ".", "fill_", "(", "0.", ")", "\n", "maps", "[", ":", ",", "0", ":", "2", ",", ":", ",", ":", "]", "=", "-", "10.", "\n", "maps", "[", ":", ",", "0", ",", "120", ":", "140", ",", "20", ":", "40", "]", "=", "10.", "\n", "maps", "[", ":", ",", "1", ",", "120", ":", "140", ",", "20", ":", "40", "]", "=", "10.", "\n", "maps", "[", ":", ",", "2", ",", "120", ":", "140", ",", "20", ":", "40", "]", "=", "0.", "\n", "maps", "[", ":", ",", "3", ",", "120", ":", "140", ",", "20", ":", "40", "]", "=", "1.", "\n", "maps", "[", ":", ",", "4", ",", "120", ":", "140", ",", "20", ":", "40", "]", "=", "0.5", "\n", "\n", "results", "=", "textsnake_decode", "(", "torch", ".", "squeeze", "(", "maps", ")", ")", "\n", "assert", "len", "(", "results", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_wrapper.test_db_decode": [[96, 113], ["torch.zeros", "mmocr.models.textdet.postprocess.DBPostprocessor", "mmocr.models.textdet.postprocess.DBPostprocessor.", "mmocr.models.textdet.postprocess.DBPostprocessor", "mmocr.models.textdet.postprocess.DBPostprocessor.", "pytest.raises", "mmocr.models.textdet.postprocess.DBPostprocessor"], "function", ["None"], ["", "def", "test_db_decode", "(", ")", ":", "\n", "    ", "pred", "=", "torch", ".", "zeros", "(", "(", "1", ",", "8", ",", "8", ")", ")", "\n", "pred", "[", "0", ",", "2", ":", "7", ",", "2", ":", "7", "]", "=", "0.8", "\n", "expect_result_quad", "=", "[", "[", "\n", "1.0", ",", "8.0", ",", "1.0", ",", "1.0", ",", "8.0", ",", "1.0", ",", "8.0", ",", "8.0", ",", "0.800000011920929", "\n", "]", "]", "\n", "expect_result_poly", "=", "[", "[", "\n", "8", ",", "2", ",", "8", ",", "6", ",", "6", ",", "8", ",", "2", ",", "8", ",", "1", ",", "6", ",", "1", ",", "2", ",", "2", ",", "1", ",", "6", ",", "1", ",", "0.800000011920929", "\n", "]", "]", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "DBPostprocessor", "(", "text_repr_type", "=", "'dummpy'", ")", "\n", "", "db_decode", "=", "DBPostprocessor", "(", "text_repr_type", "=", "'quad'", ",", "min_text_width", "=", "1", ")", "\n", "result_quad", "=", "db_decode", "(", "preds", "=", "pred", ")", "\n", "db_decode", "=", "DBPostprocessor", "(", "text_repr_type", "=", "'poly'", ",", "min_text_width", "=", "1", ")", "\n", "result_poly", "=", "db_decode", "(", "preds", "=", "pred", ")", "\n", "assert", "result_quad", "==", "expect_result_quad", "\n", "assert", "result_poly", "==", "expect_result_poly", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.test_ocr_init_errors": [[22, 34], ["pytest.raises", "mmocr.utils.ocr.MMOCR", "pytest.raises", "mmocr.utils.ocr.MMOCR", "pytest.raises", "mmocr.utils.ocr.MMOCR", "pytest.raises", "mmocr.utils.ocr.MMOCR", "pytest.raises", "mmocr.utils.ocr.MMOCR"], "function", ["None"], ["def", "test_ocr_init_errors", "(", ")", ":", "\n", "# Test assertions", "\n", "    ", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "_", "=", "MMOCR", "(", "det", "=", "'test'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "_", "=", "MMOCR", "(", "recog", "=", "'test'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "_", "=", "MMOCR", "(", "kie", "=", "'test'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "_", "=", "MMOCR", "(", "det", "=", "None", ",", "recog", "=", "None", ",", "kie", "=", "'SDMGR'", ")", "\n", "", "with", "pytest", ".", "raises", "(", "NotImplementedError", ")", ":", "\n", "        ", "_", "=", "MMOCR", "(", "det", "=", "'DB_r18'", ",", "recog", "=", "None", ",", "kie", "=", "'SDMGR'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.test_ocr_init": [[39, 116], ["pytest.mark.parametrize", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "isinstance", "isinstance", "range", "torch.device", "mock_init_detector.assert_has_calls", "torch.device", "len", "mock_config.assert_called_with", "mock_build_detector.assert_called_once", "mock_loading.assert_called_once", "unittest.mock.call", "mmocr.utils.ocr.MMOCR", "mmocr.utils.ocr.MMOCR", "mmocr.utils.ocr.MMOCR", "mmocr.utils.ocr.MMOCR", "torch.cuda.is_available", "torch.cuda.is_available"], "function", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'det, recog, kie, config_dir, gt_cfg, gt_ckpt'", ",", "\n", "[", "(", "'DB_r18'", ",", "None", ",", "''", ",", "''", ",", "\n", "cfg_default_prefix", "+", "'textdet/dbnet/dbnet_r18_fpnc_1200e_icdar2015.py'", ",", "\n", "'https://download.openmmlab.com/mmocr/textdet/'", "\n", "'dbnet/dbnet_r18_fpnc_sbn_1200e_icdar2015_20210329-ba3ab597.pth'", ")", ",", "\n", "(", "None", ",", "'CRNN'", ",", "''", ",", "''", ",", "\n", "cfg_default_prefix", "+", "'textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "'https://download.openmmlab.com/mmocr/textrecog/'", "\n", "'crnn/crnn_academic-a723a1c5.pth'", ")", ",", "\n", "(", "'DB_r18'", ",", "'CRNN'", ",", "'SDMGR'", ",", "''", ",", "[", "\n", "cfg_default_prefix", "+", "\n", "'textdet/dbnet/dbnet_r18_fpnc_1200e_icdar2015.py'", ",", "\n", "cfg_default_prefix", "+", "'textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "cfg_default_prefix", "+", "'kie/sdmgr/sdmgr_unet16_60e_wildreceipt.py'", "\n", "]", ",", "[", "\n", "'https://download.openmmlab.com/mmocr/textdet/'", "\n", "'dbnet/dbnet_r18_fpnc_sbn_1200e_icdar2015_20210329-ba3ab597.pth'", ",", "\n", "'https://download.openmmlab.com/mmocr/textrecog/'", "\n", "'crnn/crnn_academic-a723a1c5.pth'", ",", "\n", "'https://download.openmmlab.com/mmocr/kie/'", "\n", "'sdmgr/sdmgr_unet16_60e_wildreceipt_20210520-7489e6de.pth'", "\n", "]", ")", ",", "\n", "(", "'DB_r18'", ",", "'CRNN'", ",", "'SDMGR'", ",", "'test/'", ",", "[", "\n", "'test/textdet/dbnet/dbnet_r18_fpnc_1200e_icdar2015.py'", ",", "\n", "'test/textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "'test/kie/sdmgr/sdmgr_unet16_60e_wildreceipt.py'", "\n", "]", ",", "[", "\n", "'https://download.openmmlab.com/mmocr/textdet/'", "\n", "'dbnet/dbnet_r18_fpnc_sbn_1200e_icdar2015_20210329-ba3ab597.pth'", ",", "\n", "'https://download.openmmlab.com/mmocr/textrecog/'", "\n", "'crnn/crnn_academic-a723a1c5.pth'", ",", "\n", "'https://download.openmmlab.com/mmocr/kie/'", "\n", "'sdmgr/sdmgr_unet16_60e_wildreceipt_20210520-7489e6de.pth'", "\n", "]", ")", "]", ",", "\n", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.init_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.build_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.Config.fromfile'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.load_checkpoint'", ")", "\n", "def", "test_ocr_init", "(", "mock_loading", ",", "mock_config", ",", "mock_build_detector", ",", "\n", "mock_init_detector", ",", "det", ",", "recog", ",", "kie", ",", "config_dir", ",", "gt_cfg", ",", "\n", "gt_ckpt", ")", ":", "\n", "\n", "    ", "def", "loadcheckpoint_assert", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "args", "[", "1", "]", "==", "gt_ckpt", "[", "-", "1", "]", "\n", "assert", "kwargs", "[", "'map_location'", "]", "==", "torch", ".", "device", "(", "\n", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "\n", "", "mock_loading", ".", "side_effect", "=", "loadcheckpoint_assert", "\n", "with", "mock", ".", "patch", "(", "'mmocr.utils.ocr.revert_sync_batchnorm'", ")", ":", "\n", "        ", "if", "kie", "==", "''", ":", "\n", "            ", "if", "config_dir", "==", "''", ":", "\n", "                ", "_", "=", "MMOCR", "(", "det", "=", "det", ",", "recog", "=", "recog", ")", "\n", "", "else", ":", "\n", "                ", "_", "=", "MMOCR", "(", "det", "=", "det", ",", "recog", "=", "recog", ",", "config_dir", "=", "config_dir", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "config_dir", "==", "''", ":", "\n", "                ", "_", "=", "MMOCR", "(", "det", "=", "det", ",", "recog", "=", "recog", ",", "kie", "=", "kie", ")", "\n", "", "else", ":", "\n", "                ", "_", "=", "MMOCR", "(", "det", "=", "det", ",", "recog", "=", "recog", ",", "kie", "=", "kie", ",", "config_dir", "=", "config_dir", ")", "\n", "", "", "if", "isinstance", "(", "gt_cfg", ",", "str", ")", ":", "\n", "            ", "gt_cfg", "=", "[", "gt_cfg", "]", "\n", "", "if", "isinstance", "(", "gt_ckpt", ",", "str", ")", ":", "\n", "            ", "gt_ckpt", "=", "[", "gt_ckpt", "]", "\n", "\n", "", "i_range", "=", "range", "(", "len", "(", "gt_cfg", ")", ")", "\n", "if", "kie", ":", "\n", "            ", "i_range", "=", "i_range", "[", ":", "-", "1", "]", "\n", "mock_config", ".", "assert_called_with", "(", "gt_cfg", "[", "-", "1", "]", ")", "\n", "mock_build_detector", ".", "assert_called_once", "(", ")", "\n", "mock_loading", ".", "assert_called_once", "(", ")", "\n", "", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "calls", "=", "[", "\n", "mock", ".", "call", "(", "gt_cfg", "[", "i", "]", ",", "gt_ckpt", "[", "i", "]", ",", "device", "=", "device", ")", "for", "i", "in", "i_range", "\n", "]", "\n", "mock_init_detector", ".", "assert_has_calls", "(", "calls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.test_ocr_init_customize_config": [[118, 177], ["pytest.mark.parametrize", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "mmocr.utils.ocr.MMOCR", "range", "torch.device", "mock_init_detector.assert_has_calls", "len", "mock_config.assert_called_with", "mock_build_detector.assert_called_once", "mock_loading.assert_called_once", "unittest.mock.call", "torch.cuda.is_available"], "function", ["None"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\n", "'det, det_config, det_ckpt, recog, recog_config, recog_ckpt,'", "\n", "'kie, kie_config, kie_ckpt, config_dir, gt_cfg, gt_ckpt'", ",", "\n", "[", "(", "'DB_r18'", ",", "'test.py'", ",", "''", ",", "'CRNN'", ",", "'test.py'", ",", "''", ",", "'SDMGR'", ",", "'test.py'", ",", "''", ",", "\n", "'configs/'", ",", "[", "'test.py'", ",", "'test.py'", ",", "'test.py'", "]", ",", "[", "\n", "'https://download.openmmlab.com/mmocr/textdet/'", "\n", "'dbnet/dbnet_r18_fpnc_sbn_1200e_icdar2015_20210329-ba3ab597.pth'", ",", "\n", "'https://download.openmmlab.com/mmocr/textrecog/'", "\n", "'crnn/crnn_academic-a723a1c5.pth'", ",", "\n", "'https://download.openmmlab.com/mmocr/kie/'", "\n", "'sdmgr/sdmgr_unet16_60e_wildreceipt_20210520-7489e6de.pth'", "\n", "]", ")", ",", "\n", "(", "'DB_r18'", ",", "''", ",", "'test.ckpt'", ",", "'CRNN'", ",", "''", ",", "'test.ckpt'", ",", "'SDMGR'", ",", "''", ",", "\n", "'test.ckpt'", ",", "''", ",", "[", "\n", "'textdet/dbnet/dbnet_r18_fpnc_1200e_icdar2015.py'", ",", "\n", "'textrecog/crnn/crnn_academic_dataset.py'", ",", "\n", "'kie/sdmgr/sdmgr_unet16_60e_wildreceipt.py'", "\n", "]", ",", "[", "'test.ckpt'", ",", "'test.ckpt'", ",", "'test.ckpt'", "]", ")", ",", "\n", "(", "'DB_r18'", ",", "'test.py'", ",", "'test.ckpt'", ",", "'CRNN'", ",", "'test.py'", ",", "'test.ckpt'", ",", "\n", "'SDMGR'", ",", "'test.py'", ",", "'test.ckpt'", ",", "''", ",", "[", "'test.py'", ",", "'test.py'", ",", "'test.py'", "]", ",", "\n", "[", "'test.ckpt'", ",", "'test.ckpt'", ",", "'test.ckpt'", "]", ")", "]", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.init_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.build_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.Config.fromfile'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.load_checkpoint'", ")", "\n", "def", "test_ocr_init_customize_config", "(", "mock_loading", ",", "mock_config", ",", "\n", "mock_build_detector", ",", "mock_init_detector", ",", "\n", "det", ",", "det_config", ",", "det_ckpt", ",", "recog", ",", "\n", "recog_config", ",", "recog_ckpt", ",", "kie", ",", "kie_config", ",", "\n", "kie_ckpt", ",", "config_dir", ",", "gt_cfg", ",", "gt_ckpt", ")", ":", "\n", "\n", "    ", "def", "loadcheckpoint_assert", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "assert", "args", "[", "1", "]", "==", "gt_ckpt", "[", "-", "1", "]", "\n", "\n", "", "mock_loading", ".", "side_effect", "=", "loadcheckpoint_assert", "\n", "with", "mock", ".", "patch", "(", "'mmocr.utils.ocr.revert_sync_batchnorm'", ")", ":", "\n", "        ", "_", "=", "MMOCR", "(", "\n", "det", "=", "det", ",", "\n", "det_config", "=", "det_config", ",", "\n", "det_ckpt", "=", "det_ckpt", ",", "\n", "recog", "=", "recog", ",", "\n", "recog_config", "=", "recog_config", ",", "\n", "recog_ckpt", "=", "recog_ckpt", ",", "\n", "kie", "=", "kie", ",", "\n", "kie_config", "=", "kie_config", ",", "\n", "kie_ckpt", "=", "kie_ckpt", ",", "\n", "config_dir", "=", "config_dir", ")", "\n", "\n", "i_range", "=", "range", "(", "len", "(", "gt_cfg", ")", ")", "\n", "if", "kie", ":", "\n", "            ", "i_range", "=", "i_range", "[", ":", "-", "1", "]", "\n", "mock_config", ".", "assert_called_with", "(", "gt_cfg", "[", "-", "1", "]", ")", "\n", "mock_build_detector", ".", "assert_called_once", "(", ")", "\n", "mock_loading", ".", "assert_called_once", "(", ")", "\n", "", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "calls", "=", "[", "\n", "mock", ".", "call", "(", "gt_cfg", "[", "i", "]", ",", "gt_ckpt", "[", "i", "]", ",", "device", "=", "device", ")", "for", "i", "in", "i_range", "\n", "]", "\n", "mock_init_detector", ".", "assert_has_calls", "(", "calls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.test_single_inference": [[179, 211], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "mmocr.utils.ocr.MMOCR", "list", "mmocr.utils.ocr.MMOCR.single_inference", "mock_model_inference.reset_mock", "mmocr.utils.ocr.MMOCR.single_inference", "mock_model_inference.assert_called_once", "mock_model_inference.reset_mock", "mmocr.utils.ocr.MMOCR.single_inference", "mock_model_inference.assert_called_once", "mock_model_inference.reset_mock", "mmocr.utils.ocr.MMOCR.single_inference", "range"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.single_inference"], ["", "", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.init_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.build_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.Config.fromfile'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.load_checkpoint'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.model_inference'", ")", "\n", "def", "test_single_inference", "(", "mock_model_inference", ",", "mock_loading", ",", "mock_config", ",", "\n", "mock_build_detector", ",", "mock_init_detector", ")", ":", "\n", "\n", "    ", "def", "dummy_inference", "(", "model", ",", "arr", ",", "batch_mode", ")", ":", "\n", "        ", "return", "arr", "\n", "\n", "", "mock_model_inference", ".", "side_effect", "=", "dummy_inference", "\n", "mmocr", "=", "MMOCR", "(", ")", "\n", "\n", "data", "=", "list", "(", "range", "(", "20", ")", ")", "\n", "model", "=", "'dummy'", "\n", "res", "=", "mmocr", ".", "single_inference", "(", "model", ",", "data", ",", "batch_mode", "=", "False", ")", "\n", "assert", "(", "data", "==", "res", ")", "\n", "mock_model_inference", ".", "reset_mock", "(", ")", "\n", "\n", "res", "=", "mmocr", ".", "single_inference", "(", "model", ",", "data", ",", "batch_mode", "=", "True", ")", "\n", "assert", "(", "data", "==", "res", ")", "\n", "mock_model_inference", ".", "assert_called_once", "(", ")", "\n", "mock_model_inference", ".", "reset_mock", "(", ")", "\n", "\n", "res", "=", "mmocr", ".", "single_inference", "(", "model", ",", "data", ",", "batch_mode", "=", "True", ",", "batch_size", "=", "100", ")", "\n", "assert", "(", "data", "==", "res", ")", "\n", "mock_model_inference", ".", "assert_called_once", "(", ")", "\n", "mock_model_inference", ".", "reset_mock", "(", ")", "\n", "\n", "res", "=", "mmocr", ".", "single_inference", "(", "model", ",", "data", ",", "batch_mode", "=", "True", ",", "batch_size", "=", "3", ")", "\n", "assert", "(", "data", "==", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.MMOCR_testobj": [[213, 231], ["unittest.mock.patch", "unittest.mock.patch", "kwargs.get", "kwargs.get", "kwargs.get", "mmocr.utils.ocr.MMOCR", "mmocr.apis.init_detector", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector"], ["", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.init_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.load_checkpoint'", ")", "\n", "def", "MMOCR_testobj", "(", "mock_loading", ",", "mock_init_detector", ",", "**", "kwargs", ")", ":", "\n", "# returns an MMOCR object bypassing the", "\n", "# checkpoint initialization step", "\n", "    ", "def", "init_detector_skip_ckpt", "(", "config", ",", "ckpt", ",", "device", ")", ":", "\n", "        ", "return", "init_detector", "(", "config", ",", "device", "=", "device", ")", "\n", "\n", "", "def", "modify_kie_class", "(", "model", ",", "ckpt", ",", "map_location", ")", ":", "\n", "        ", "model", ".", "class_list", "=", "'tests/data/kie_toy_dataset/class_list.txt'", "\n", "\n", "", "mock_init_detector", ".", "side_effect", "=", "init_detector_skip_ckpt", "\n", "mock_loading", ".", "side_effect", "=", "modify_kie_class", "\n", "kwargs", "[", "'det'", "]", "=", "kwargs", ".", "get", "(", "'det'", ",", "'DB_r18'", ")", "\n", "kwargs", "[", "'recog'", "]", "=", "kwargs", ".", "get", "(", "'recog'", ",", "'CRNN'", ")", "\n", "kwargs", "[", "'kie'", "]", "=", "kwargs", ".", "get", "(", "'kie'", ",", "'SDMGR'", ")", "\n", "device", "=", "'cuda:0'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", "\n", "return", "MMOCR", "(", "**", "kwargs", ",", "device", "=", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.test_readtext": [[233, 372], ["pytest.mark.skipif", "unittest.mock.patch", "torch.manual_seed", "random.seed", "test_ocr.MMOCR_testobj", "test_ocr.MMOCR_testobj", "test_ocr.MMOCR_testobj", "test_ocr.MMOCR_testobj", "test_ocr.test_readtext.readtext"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.MMOCR_testobj", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.MMOCR_testobj", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.MMOCR_testobj", "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.MMOCR_testobj", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.readtext"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "platform", ".", "system", "(", ")", "==", "'Windows'", ",", "\n", "reason", "=", "'Win container on Github Action does not have enough RAM to run'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.KIEDataset'", ")", "\n", "def", "test_readtext", "(", "mock_kiedataset", ")", ":", "\n", "# Fixing the weights of models to prevent them from", "\n", "# generating invalid results and triggering other assertion errors", "\n", "    ", "torch", ".", "manual_seed", "(", "4", ")", "\n", "random", ".", "seed", "(", "4", ")", "\n", "mmocr", "=", "MMOCR_testobj", "(", ")", "\n", "mmocr_det", "=", "MMOCR_testobj", "(", "kie", "=", "''", ",", "recog", "=", "''", ")", "\n", "mmocr_recog", "=", "MMOCR_testobj", "(", "kie", "=", "''", ",", "det", "=", "''", ",", "recog", "=", "'CRNN_TPS'", ")", "\n", "mmocr_det_recog", "=", "MMOCR_testobj", "(", "kie", "=", "''", ")", "\n", "\n", "def", "readtext", "(", "imgs", ",", "ocr_obj", "=", "mmocr", ",", "**", "kwargs", ")", ":", "\n", "# filename can be different depends on how", "\n", "# the the image was loaded", "\n", "        ", "e2e_res", "=", "ocr_obj", ".", "readtext", "(", "imgs", ",", "**", "kwargs", ")", "\n", "for", "res", "in", "e2e_res", ":", "\n", "            ", "res", ".", "pop", "(", "'filename'", ")", "\n", "", "return", "e2e_res", "\n", "\n", "", "def", "kiedataset_with_test_dict", "(", "**", "kwargs", ")", ":", "\n", "        ", "kwargs", "[", "'dict_file'", "]", "=", "'tests/data/kie_toy_dataset/dict.txt'", "\n", "return", "KIEDataset", "(", "**", "kwargs", ")", "\n", "\n", "", "mock_kiedataset", ".", "side_effect", "=", "kiedataset_with_test_dict", "\n", "\n", "# Single image", "\n", "toy_dir", "=", "'tests/data/toy_dataset/imgs/test/'", "\n", "toy_img1_path", "=", "toy_dir", "+", "'img_1.jpg'", "\n", "str_e2e_res", "=", "readtext", "(", "toy_img1_path", ")", "\n", "toy_img1", "=", "mmcv", ".", "imread", "(", "toy_img1_path", ")", "\n", "np_e2e_res", "=", "readtext", "(", "toy_img1", ")", "\n", "assert", "str_e2e_res", "==", "np_e2e_res", "\n", "\n", "# Multiple images", "\n", "toy_img2_path", "=", "toy_dir", "+", "'img_2.jpg'", "\n", "toy_img2", "=", "mmcv", ".", "imread", "(", "toy_img2_path", ")", "\n", "toy_imgs", "=", "[", "toy_img1", ",", "toy_img2", "]", "\n", "toy_img_paths", "=", "[", "toy_img1_path", ",", "toy_img2_path", "]", "\n", "np_e2e_results", "=", "readtext", "(", "toy_imgs", ")", "\n", "str_e2e_results", "=", "readtext", "(", "toy_img_paths", ")", "\n", "str_tuple_e2e_results", "=", "readtext", "(", "tuple", "(", "toy_img_paths", ")", ")", "\n", "assert", "np_e2e_results", "==", "str_e2e_results", "\n", "assert", "str_e2e_results", "==", "str_tuple_e2e_results", "\n", "\n", "# Batch mode test", "\n", "toy_imgs", ".", "append", "(", "toy_dir", "+", "'img_3.jpg'", ")", "\n", "e2e_res", "=", "readtext", "(", "toy_imgs", ")", "\n", "full_batch_e2e_res", "=", "readtext", "(", "toy_imgs", ",", "batch_mode", "=", "True", ")", "\n", "assert", "full_batch_e2e_res", "==", "e2e_res", "\n", "batch_e2e_res", "=", "readtext", "(", "\n", "toy_imgs", ",", "batch_mode", "=", "True", ",", "recog_batch_size", "=", "2", ",", "det_batch_size", "=", "2", ")", "\n", "assert", "batch_e2e_res", "==", "full_batch_e2e_res", "\n", "\n", "# Batch mode test with DBNet only", "\n", "full_batch_det_res", "=", "mmocr_det", ".", "readtext", "(", "toy_imgs", ",", "batch_mode", "=", "True", ")", "\n", "det_res", "=", "mmocr_det", ".", "readtext", "(", "toy_imgs", ")", "\n", "batch_det_res", "=", "mmocr_det", ".", "readtext", "(", "\n", "toy_imgs", ",", "batch_mode", "=", "True", ",", "single_batch_size", "=", "2", ")", "\n", "assert", "len", "(", "full_batch_det_res", ")", "==", "len", "(", "det_res", ")", "\n", "assert", "len", "(", "batch_det_res", ")", "==", "len", "(", "det_res", ")", "\n", "assert", "all", "(", "[", "\n", "np", ".", "allclose", "(", "full_batch_det_res", "[", "i", "]", "[", "'boundary_result'", "]", ",", "\n", "det_res", "[", "i", "]", "[", "'boundary_result'", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "full_batch_det_res", ")", ")", "\n", "]", ")", "\n", "assert", "all", "(", "[", "\n", "np", ".", "allclose", "(", "batch_det_res", "[", "i", "]", "[", "'boundary_result'", "]", ",", "\n", "det_res", "[", "i", "]", "[", "'boundary_result'", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "batch_det_res", ")", ")", "\n", "]", ")", "\n", "\n", "# Batch mode test with CRNN_TPS only (CRNN doesn't support batch inference)", "\n", "full_batch_recog_res", "=", "mmocr_recog", ".", "readtext", "(", "toy_imgs", ",", "batch_mode", "=", "True", ")", "\n", "recog_res", "=", "mmocr_recog", ".", "readtext", "(", "toy_imgs", ")", "\n", "batch_recog_res", "=", "mmocr_recog", ".", "readtext", "(", "\n", "toy_imgs", ",", "batch_mode", "=", "True", ",", "single_batch_size", "=", "2", ")", "\n", "full_batch_recog_res", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "'text'", "]", ")", "\n", "batch_recog_res", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "'text'", "]", ")", "\n", "recog_res", ".", "sort", "(", "key", "=", "lambda", "x", ":", "x", "[", "'text'", "]", ")", "\n", "assert", "np", ".", "all", "(", "[", "\n", "np", ".", "allclose", "(", "full_batch_recog_res", "[", "i", "]", "[", "'score'", "]", ",", "recog_res", "[", "i", "]", "[", "'score'", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "full_batch_recog_res", ")", ")", "\n", "]", ")", "\n", "assert", "np", ".", "all", "(", "[", "\n", "np", ".", "allclose", "(", "batch_recog_res", "[", "i", "]", "[", "'score'", "]", ",", "recog_res", "[", "i", "]", "[", "'score'", "]", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "full_batch_recog_res", ")", ")", "\n", "]", ")", "\n", "\n", "# Test export", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "mmocr", ".", "readtext", "(", "toy_imgs", ",", "export", "=", "tmpdirname", ")", "\n", "assert", "len", "(", "os", ".", "listdir", "(", "tmpdirname", ")", ")", "==", "len", "(", "toy_imgs", ")", "\n", "", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "mmocr_det", ".", "readtext", "(", "toy_imgs", ",", "export", "=", "tmpdirname", ")", "\n", "assert", "len", "(", "os", ".", "listdir", "(", "tmpdirname", ")", ")", "==", "len", "(", "toy_imgs", ")", "\n", "", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "mmocr_recog", ".", "readtext", "(", "toy_imgs", ",", "export", "=", "tmpdirname", ")", "\n", "assert", "len", "(", "os", ".", "listdir", "(", "tmpdirname", ")", ")", "==", "len", "(", "toy_imgs", ")", "\n", "\n", "# Test output", "\n", "# Single image", "\n", "", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "tmp_output", "=", "os", ".", "path", ".", "join", "(", "tmpdirname", ",", "'1.jpg'", ")", "\n", "mmocr", ".", "readtext", "(", "toy_imgs", "[", "0", "]", ",", "output", "=", "tmp_output", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "tmp_output", ")", "\n", "# Multiple images", "\n", "", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "mmocr", ".", "readtext", "(", "toy_imgs", ",", "output", "=", "tmpdirname", ")", "\n", "assert", "len", "(", "os", ".", "listdir", "(", "tmpdirname", ")", ")", "==", "len", "(", "toy_imgs", ")", "\n", "\n", "# Test imshow", "\n", "", "with", "mock", ".", "patch", "(", "'mmocr.utils.ocr.mmcv.imshow'", ")", "as", "mock_imshow", ":", "\n", "        ", "mmocr", ".", "readtext", "(", "toy_img1_path", ",", "imshow", "=", "True", ")", "\n", "mock_imshow", ".", "assert_called_once", "(", ")", "\n", "mock_imshow", ".", "reset_mock", "(", ")", "\n", "mmocr", ".", "readtext", "(", "toy_imgs", ",", "imshow", "=", "True", ")", "\n", "assert", "mock_imshow", ".", "call_count", "==", "len", "(", "toy_imgs", ")", "\n", "\n", "# Test print_result", "\n", "", "with", "io", ".", "StringIO", "(", ")", "as", "capturedOutput", ":", "\n", "        ", "sys", ".", "stdout", "=", "capturedOutput", "\n", "res", "=", "mmocr", ".", "readtext", "(", "toy_imgs", ",", "print_result", "=", "True", ")", "\n", "assert", "json", ".", "loads", "(", "'[%s]'", "%", "capturedOutput", ".", "getvalue", "(", ")", ".", "strip", "(", ")", ".", "replace", "(", "\n", "'\\n\\n'", ",", "','", ")", ".", "replace", "(", "\"'\"", ",", "'\"'", ")", ")", "==", "res", "\n", "sys", ".", "stdout", "=", "sys", ".", "__stdout__", "\n", "", "with", "io", ".", "StringIO", "(", ")", "as", "capturedOutput", ":", "\n", "        ", "sys", ".", "stdout", "=", "capturedOutput", "\n", "res", "=", "mmocr", ".", "readtext", "(", "toy_imgs", ",", "details", "=", "True", ",", "print_result", "=", "True", ")", "\n", "assert", "json", ".", "loads", "(", "'[%s]'", "%", "capturedOutput", ".", "getvalue", "(", ")", ".", "strip", "(", ")", ".", "replace", "(", "\n", "'\\n\\n'", ",", "','", ")", ".", "replace", "(", "\"'\"", ",", "'\"'", ")", ")", "==", "res", "\n", "sys", ".", "stdout", "=", "sys", ".", "__stdout__", "\n", "\n", "# Test merge", "\n", "", "with", "mock", ".", "patch", "(", "'mmocr.utils.ocr.stitch_boxes_into_lines'", ")", "as", "mock_merge", ":", "\n", "        ", "mmocr_det_recog", ".", "readtext", "(", "toy_imgs", ",", "merge", "=", "True", ")", "\n", "assert", "mock_merge", ".", "call_count", "==", "len", "(", "toy_imgs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_utils.test_ocr.test_tesseract_wrapper": [[374, 421], ["pytest.mark.parametrize", "unittest.mock.patch", "unittest.mock.patch", "unittest.mock.Mock", "mmocr.utils.ocr.MMOCR", "mmocr.apis.init_detector", "unittest.mock.patch", "mmocr.utils.ocr.MMOCR.readtext", "target.items", "mock_imshow.assert_called_once", "mock_imshow.reset_mock"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.apis.inference.init_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.utils.ocr.MMOCR.readtext"], ["", "", "@", "pytest", ".", "mark", ".", "parametrize", "(", "'det, recog, target'", ",", "\n", "[", "(", "'Tesseract'", ",", "None", ",", "{", "\n", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1.0", "]", "]", "\n", "}", ")", ",", "\n", "(", "'Tesseract'", ",", "'Tesseract'", ",", "{", "\n", "'result'", ":", "[", "{", "\n", "'box'", ":", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "'box_score'", ":", "1.0", ",", "\n", "'text'", ":", "'text'", ",", "\n", "'text_score'", ":", "0.5", "\n", "}", "]", "\n", "}", ")", ",", "\n", "(", "None", ",", "'Tesseract'", ",", "{", "\n", "'text'", ":", "'text'", ",", "\n", "'score'", ":", "0.5", "\n", "}", ")", "]", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.init_detector'", ")", "\n", "@", "mock", ".", "patch", "(", "'mmocr.utils.ocr.tesserocr'", ")", "\n", "def", "test_tesseract_wrapper", "(", "mock_tesserocr", ",", "mock_init_detector", ",", "det", ",", "recog", ",", "\n", "target", ")", ":", "\n", "\n", "    ", "def", "init_detector_skip_ckpt", "(", "config", ",", "ckpt", ",", "device", ")", ":", "\n", "        ", "return", "init_detector", "(", "config", ",", "device", "=", "device", ")", "\n", "\n", "", "mock_init_detector", ".", "side_effect", "=", "init_detector_skip_ckpt", "\n", "mock_tesseract", "=", "mock", ".", "Mock", "(", ")", "\n", "mock_tesseract", ".", "GetComponentImages", ".", "return_value", "=", "[", "(", "None", ",", "{", "\n", "'x'", ":", "0", ",", "\n", "'y'", ":", "0", ",", "\n", "'w'", ":", "1", ",", "\n", "'h'", ":", "1", "\n", "}", ",", "0", ",", "None", ")", "]", "\n", "mock_tesseract", ".", "GetUTF8Text", ".", "return_value", "=", "'text'", "\n", "mock_tesseract", ".", "MeanTextConf", ".", "return_value", "=", "50", "\n", "mock_tesserocr", ".", "PyTessBaseAPI", ".", "return_value", "=", "mock_tesseract", "\n", "\n", "mmocr", "=", "MMOCR", "(", "det", "=", "det", ",", "recog", "=", "recog", ",", "device", "=", "'cpu'", ")", "\n", "\n", "img_path", "=", "'demo/demo_kie.jpeg'", "\n", "\n", "# Test imshow", "\n", "with", "mock", ".", "patch", "(", "'mmocr.utils.ocr.mmcv.imshow'", ")", "as", "mock_imshow", ":", "\n", "        ", "result", "=", "mmocr", ".", "readtext", "(", "img_path", ",", "imshow", "=", "True", ",", "details", "=", "True", ")", "\n", "for", "k", ",", "v", "in", "target", ".", "items", "(", ")", ":", "\n", "            ", "assert", "result", "[", "0", "]", "[", "k", "]", "==", "v", "\n", "", "mock_imshow", ".", "assert_called_once", "(", ")", "\n", "mock_imshow", ".", "reset_mock", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_points2boundary": [[14, 46], ["numpy.array", "numpy.array", "mmocr.points2boundary", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2boundary", "mmocr.points2polygon", "mmocr.points2polygon", "pytest.raises", "mmocr.points2boundary", "pytest.raises", "mmocr.points2boundary", "pytest.raises", "mmocr.points2boundary", "mmocr.poly_iou", "mmocr.poly_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.points2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou"], ["def", "test_points2boundary", "(", ")", ":", "\n", "\n", "    ", "points", "=", "np", ".", "array", "(", "[", "[", "1", ",", "2", "]", "]", ")", "\n", "text_repr_type", "=", "'quad'", "\n", "text_score", "=", "None", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "points2boundary", "(", "[", "]", ",", "text_repr_type", ",", "text_score", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "points2boundary", "(", "points", ",", "''", ",", "text_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "points2boundary", "(", "points", ",", "''", ",", "1.1", ")", "\n", "\n", "# test quad", "\n", "", "points", "=", "np", ".", "array", "(", "[", "[", "0", ",", "0", "]", ",", "[", "1", ",", "0", "]", ",", "[", "2", ",", "0", "]", ",", "[", "0", ",", "1", "]", ",", "[", "1", ",", "1", "]", ",", "[", "2", ",", "1", "]", ",", "[", "0", ",", "2", "]", ",", "\n", "[", "1", ",", "2", "]", ",", "[", "2", ",", "2", "]", "]", ")", "\n", "text_repr_type", "=", "'quad'", "\n", "text_score", "=", "None", "\n", "\n", "result", "=", "mask_utils", ".", "points2boundary", "(", "points", ",", "text_repr_type", ",", "text_score", ")", "\n", "pred_poly", "=", "eval_utils", ".", "points2polygon", "(", "result", ")", "\n", "target_poly", "=", "eval_utils", ".", "points2polygon", "(", "[", "2", ",", "2", ",", "0", ",", "2", ",", "0", ",", "0", ",", "2", ",", "0", "]", ")", "\n", "assert", "eval_utils", ".", "poly_iou", "(", "pred_poly", ",", "target_poly", ")", "==", "1", "\n", "\n", "# test poly", "\n", "text_repr_type", "=", "'poly'", "\n", "result", "=", "mask_utils", ".", "points2boundary", "(", "points", ",", "text_repr_type", ",", "text_score", ")", "\n", "pred_poly", "=", "eval_utils", ".", "points2polygon", "(", "result", ")", "\n", "target_poly", "=", "eval_utils", ".", "points2polygon", "(", "[", "0", ",", "0", ",", "0", ",", "2", ",", "2", ",", "2", ",", "2", ",", "0", "]", ")", "\n", "assert", "eval_utils", ".", "poly_iou", "(", "pred_poly", ",", "target_poly", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_seg2boundary": [[48, 66], ["numpy.array", "numpy.array", "mmocr.seg2boundary", "mmocr.points2polygon", "mmocr.points2polygon", "pytest.raises", "mmocr.seg2boundary", "pytest.raises", "mmocr.seg2boundary", "pytest.raises", "mmocr.seg2boundary", "mmocr.poly_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.seg2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.seg2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.seg2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.seg2boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou"], ["", "def", "test_seg2boundary", "(", ")", ":", "\n", "\n", "    ", "seg", "=", "np", ".", "array", "(", "[", "[", "]", "]", ")", "\n", "text_repr_type", "=", "'quad'", "\n", "text_score", "=", "None", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "seg2boundary", "(", "[", "[", "]", "]", ",", "text_repr_type", ",", "text_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "seg2boundary", "(", "seg", ",", "1", ",", "text_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "seg2boundary", "(", "seg", ",", "text_repr_type", ",", "1.1", ")", "\n", "\n", "", "seg", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", "]", ",", "[", "1", ",", "1", ",", "1", "]", "]", ")", "\n", "result", "=", "mask_utils", ".", "seg2boundary", "(", "seg", ",", "text_repr_type", ",", "text_score", ")", "\n", "pred_poly", "=", "eval_utils", ".", "points2polygon", "(", "result", ")", "\n", "target_poly", "=", "eval_utils", ".", "points2polygon", "(", "[", "2", ",", "2", ",", "0", ",", "2", ",", "0", ",", "0", ",", "2", ",", "0", "]", ")", "\n", "assert", "eval_utils", ".", "poly_iou", "(", "pred_poly", ",", "target_poly", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_show_feature": [[68, 98], ["unittest.mock.patch", "mmocr.show_feature", "mock_plt.title.assert_called_once_with", "mock_plt.show.assert_called_once", "mmocr.show_feature", "mock_plt.savefig.assert_called_once", "numpy.random.rand", "pytest.raises", "mmocr.show_feature", "pytest.raises", "mmocr.show_feature", "pytest.raises", "mmocr.show_feature", "pytest.raises", "mmocr.show_feature", "pytest.raises", "mmocr.show_feature", "tempfile.NamedTemporaryFile"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_feature"], ["", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.plt'", "%", "__name__", ")", "\n", "def", "test_show_feature", "(", "mock_plt", ")", ":", "\n", "\n", "    ", "features", "=", "[", "np", ".", "random", ".", "rand", "(", "10", ",", "10", ")", "]", "\n", "names", "=", "[", "'test'", "]", "\n", "to_uint8", "=", "[", "0", "]", "\n", "out_file", "=", "None", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_feature", "(", "[", "]", ",", "names", ",", "to_uint8", ",", "out_file", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_feature", "(", "features", ",", "[", "1", "]", ",", "to_uint8", ",", "out_file", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_feature", "(", "features", ",", "names", ",", "[", "'a'", "]", ",", "out_file", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_feature", "(", "features", ",", "names", ",", "to_uint8", ",", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_feature", "(", "features", ",", "names", ",", "to_uint8", ",", "[", "0", ",", "1", "]", ")", "\n", "\n", "", "visualize_utils", ".", "show_feature", "(", "features", ",", "names", ",", "to_uint8", ")", "\n", "\n", "# test showing img", "\n", "mock_plt", ".", "title", ".", "assert_called_once_with", "(", "'test'", ")", "\n", "mock_plt", ".", "show", ".", "assert_called_once", "(", ")", "\n", "\n", "# test saving fig", "\n", "out_file", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", ".", "name", "\n", "visualize_utils", ".", "show_feature", "(", "features", ",", "names", ",", "to_uint8", ",", "out_file", ")", "\n", "mock_plt", ".", "savefig", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_show_img_boundary": [[100, 115], ["unittest.mock.patch", "numpy.random.rand", "mmocr.show_img_boundary", "mock_plt.imshow.assert_called_once", "mock_plt.show.assert_called_once", "pytest.raises", "mmocr.show_img_boundary", "pytest.raises", "mmocr.show_img_boundary", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_img_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_img_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_img_boundary"], ["", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.plt'", "%", "__name__", ")", "\n", "def", "test_show_img_boundary", "(", "mock_plt", ")", ":", "\n", "    ", "img", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "10", ")", "\n", "boundary", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_img_boundary", "(", "[", "]", ",", "boundary", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_img_boundary", "(", "img", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "# test showing img", "\n", "\n", "", "visualize_utils", ".", "show_img_boundary", "(", "img", ",", "boundary", ")", "\n", "mock_plt", ".", "imshow", ".", "assert_called_once", "(", ")", "\n", "mock_plt", ".", "show", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_show_pred_gt": [[117, 137], ["unittest.mock.patch", "mmocr.show_pred_gt", "mock_mmcv.imshow.assert_called_once", "mock_mmcv.imwrite.assert_called_once", "tempfile.NamedTemporaryFile", "pytest.raises", "mmocr.show_pred_gt", "pytest.raises", "mmocr.show_pred_gt", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_pred_gt", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_pred_gt", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.show_pred_gt"], ["", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv'", "%", "__name__", ")", "\n", "def", "test_show_pred_gt", "(", "mock_mmcv", ")", ":", "\n", "    ", "preds", "=", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "]", "\n", "gts", "=", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "]", "\n", "show", "=", "True", "\n", "win_name", "=", "'test'", "\n", "wait_time", "=", "0", "\n", "out_file", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", ".", "name", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_pred_gt", "(", "np", ".", "array", "(", "[", "]", ")", ",", "gts", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "show_pred_gt", "(", "preds", ",", "np", ".", "array", "(", "[", "]", ")", ")", "\n", "\n", "# test showing img", "\n", "\n", "", "visualize_utils", ".", "show_pred_gt", "(", "preds", ",", "gts", ",", "show", ",", "win_name", ",", "wait_time", ",", "\n", "out_file", ")", "\n", "mock_mmcv", ".", "imshow", ".", "assert_called_once", "(", ")", "\n", "mock_mmcv", ".", "imwrite", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_imshow_pred_boundary": [[139, 150], ["unittest.mock.patch", "unittest.mock.patch", "mmocr.imshow_pred_boundary", "mock_imwrite.assert_called_once", "mock_imshow.assert_called_once", "tempfile.NamedTemporaryFile"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_pred_boundary"], ["", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imshow'", "%", "__name__", ")", "\n", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imwrite'", "%", "__name__", ")", "\n", "def", "test_imshow_pred_boundary", "(", "mock_imshow", ",", "mock_imwrite", ")", ":", "\n", "    ", "img", "=", "'./tests/data/test_img1.jpg'", "\n", "boundaries_with_scores", "=", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "]", "\n", "labels", "=", "[", "1", "]", "\n", "file", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", ".", "name", "\n", "visualize_utils", ".", "imshow_pred_boundary", "(", "\n", "img", ",", "boundaries_with_scores", ",", "labels", ",", "show", "=", "True", ",", "out_file", "=", "file", ")", "\n", "mock_imwrite", ".", "assert_called_once", "(", ")", "\n", "mock_imshow", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_imshow_text_char_boundary": [[152, 173], ["unittest.mock.patch", "unittest.mock.patch", "mmocr.imshow_text_char_boundary", "mock_imwrite.assert_called_once", "mock_imshow.assert_called_once", "tempfile.NamedTemporaryFile"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_char_boundary"], ["", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imshow'", "%", "__name__", ")", "\n", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imwrite'", "%", "__name__", ")", "\n", "def", "test_imshow_text_char_boundary", "(", "mock_imshow", ",", "mock_imwrite", ")", ":", "\n", "\n", "    ", "img", "=", "'./tests/data/test_img1.jpg'", "\n", "text_quads", "=", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "]", "\n", "boundaries", "=", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "]", "\n", "char_quads", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "]", "]", "\n", "chars", "=", "[", "[", "'a'", ",", "'b'", "]", "]", "\n", "show", "=", "True", ",", "\n", "out_file", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", ".", "name", "\n", "visualize_utils", ".", "imshow_text_char_boundary", "(", "\n", "img", ",", "\n", "text_quads", ",", "\n", "boundaries", ",", "\n", "char_quads", ",", "\n", "chars", ",", "\n", "show", "=", "show", ",", "\n", "out_file", "=", "out_file", ")", "\n", "mock_imwrite", ".", "assert_called_once", "(", ")", "\n", "mock_imshow", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_overlay_mask_img": [[175, 182], ["unittest.mock.patch", "numpy.random.rand", "numpy.zeros", "mmocr.overlay_mask_img", "mock_drawContours.assert_called_once"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.overlay_mask_img"], ["", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.cv2.drawContours'", "%", "__name__", ")", "\n", "def", "test_overlay_mask_img", "(", "mock_drawContours", ")", ":", "\n", "\n", "    ", "img", "=", "np", ".", "random", ".", "rand", "(", "10", ",", "10", ")", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "10", ",", "10", ")", ")", "\n", "visualize_utils", ".", "overlay_mask_img", "(", "img", ",", "mask", ")", "\n", "mock_drawContours", ".", "assert_called_once", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_mask.test_mask_utils.test_extract_boundary": [[184, 199], ["mmocr.extract_boundary", "pytest.raises", "mmocr.extract_boundary", "pytest.raises", "mmocr.extract_boundary"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.extract_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.extract_boundary", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.mask.extract_boundary"], ["", "def", "test_extract_boundary", "(", ")", ":", "\n", "    ", "result", "=", "{", "}", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "extract_boundary", "(", "result", ")", "\n", "\n", "", "result", "=", "{", "'boundary_result'", ":", "[", "0", ",", "1", "]", "}", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "mask_utils", ".", "extract_boundary", "(", "result", ")", "\n", "\n", "", "result", "=", "{", "'boundary_result'", ":", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "]", "}", "\n", "\n", "output", "=", "mask_utils", ".", "extract_boundary", "(", "result", ")", "\n", "assert", "output", "[", "2", "]", "==", "[", "1", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_text.test_text_utils.test_tile_image": [[14, 33], ["range", "mmocr.tile_image", "random.randint", "random.randint", "heights.append", "widths.append", "numpy.ones", "dummp_imgs.append", "sum", "max", "pytest.raises", "mmocr.tile_image", "pytest.raises", "mmocr.tile_image"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.tile_image", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.tile_image", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.tile_image"], ["def", "test_tile_image", "(", ")", ":", "\n", "    ", "dummp_imgs", ",", "heights", ",", "widths", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "range", "(", "3", ")", ":", "\n", "        ", "h", "=", "random", ".", "randint", "(", "100", ",", "300", ")", "\n", "w", "=", "random", ".", "randint", "(", "100", ",", "300", ")", "\n", "heights", ".", "append", "(", "h", ")", "\n", "widths", ".", "append", "(", "w", ")", "\n", "# dummy_img = Image.new('RGB', (w, h), Image.ANTIALIAS)", "\n", "dummy_img", "=", "np", ".", "ones", "(", "(", "h", ",", "w", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "dummp_imgs", ".", "append", "(", "dummy_img", ")", "\n", "", "joint_img", "=", "visualize_utils", ".", "tile_image", "(", "dummp_imgs", ")", "\n", "assert", "joint_img", ".", "shape", "[", "0", "]", "==", "sum", "(", "heights", ")", "\n", "assert", "joint_img", ".", "shape", "[", "1", "]", "==", "max", "(", "widths", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "tile_image", "(", "dummp_imgs", "[", "0", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "tile_image", "(", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_text.test_text_utils.test_show_text_label": [[35, 68], ["unittest.mock.patch", "unittest.mock.patch", "unittest.mock.patch", "numpy.ones", "tempfile.TemporaryDirectory", "os.join", "mmocr.imshow_text_label", "mmocr.imshow_text_label", "mock_imshow.assert_called_once", "mock_imwrite.assert_called_once", "tempfile.TemporaryDirectory.cleanup", "pytest.raises", "mmocr.imshow_text_label", "pytest.raises", "mmocr.imshow_text_label", "pytest.raises", "mmocr.imshow_text_label", "pytest.raises", "mmocr.imshow_text_label"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.imshow_text_label"], ["", "", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imread'", "%", "__name__", ")", "\n", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imshow'", "%", "__name__", ")", "\n", "@", "mock", ".", "patch", "(", "'%s.visualize_utils.mmcv.imwrite'", "%", "__name__", ")", "\n", "def", "test_show_text_label", "(", "mock_imwrite", ",", "mock_imshow", ",", "mock_imread", ")", ":", "\n", "    ", "img", "=", "np", ".", "ones", "(", "(", "32", ",", "160", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "pred_label", "=", "'hello'", "\n", "gt_label", "=", "'world'", "\n", "\n", "tmp_dir", "=", "tempfile", ".", "TemporaryDirectory", "(", ")", "\n", "out_file", "=", "osp", ".", "join", "(", "tmp_dir", ".", "name", ",", "'tmp.jpg'", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "imshow_text_label", "(", "5", ",", "pred_label", ",", "gt_label", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "imshow_text_label", "(", "img", ",", "pred_label", ",", "4", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "imshow_text_label", "(", "img", ",", "3", ",", "gt_label", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "visualize_utils", ".", "imshow_text_label", "(", "\n", "img", ",", "pred_label", ",", "gt_label", ",", "show", "=", "True", ",", "wait_time", "=", "0.1", ")", "\n", "\n", "", "mock_imread", ".", "side_effect", "=", "[", "img", ",", "img", "]", "\n", "visualize_utils", ".", "imshow_text_label", "(", "\n", "img", ",", "pred_label", ",", "gt_label", ",", "out_file", "=", "out_file", ")", "\n", "visualize_utils", ".", "imshow_text_label", "(", "\n", "img", ",", "'\u4e2d\u6587'", ",", "'\u4e2d\u6587'", ",", "out_file", "=", "None", ",", "show", "=", "True", ")", "\n", "\n", "# test showing img", "\n", "mock_imshow", ".", "assert_called_once", "(", ")", "\n", "mock_imwrite", ".", "assert_called_once", "(", ")", "\n", "\n", "tmp_dir", ".", "cleanup", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_core.test_deploy_utils.test_detector_wrapper": [[16, 120], ["pytest.mark.skipif", "pytest.mark.skipif", "pytest.mark.skipif", "dict", "mmcv.Config", "mmocr.models.build_detector", "torch.rand", "isinstance", "isinstance", "isinstance", "isinstance", "tempfile.TemporaryDirectory", "onnx_path.replace", "test_deploy_utils.test_detector_wrapper.get_GiB"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt.get_GiB"], ["@", "pytest", ".", "mark", ".", "skipif", "(", "torch", ".", "__version__", "==", "'parrots'", ",", "reason", "=", "'skip parrots.'", ")", "\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "version", ".", "parse", "(", "torch", ".", "__version__", ")", "<", "version", ".", "parse", "(", "'1.4.0'", ")", ",", "\n", "reason", "=", "'skip if torch=1.3.x'", ")", "\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'skip if on cpu device'", ")", "\n", "def", "test_detector_wrapper", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "onnxruntime", "as", "ort", "# noqa: F401", "\n", "import", "tensorrt", "as", "trt", "\n", "from", "mmcv", ".", "tensorrt", "import", "onnx2trt", ",", "save_trt_engine", "\n", "", "except", "ImportError", ":", "\n", "        ", "pytest", ".", "skip", "(", "'ONNXRuntime or TensorRT is not available.'", ")", "\n", "\n", "", "cfg", "=", "dict", "(", "\n", "model", "=", "dict", "(", "\n", "type", "=", "'DBNet'", ",", "\n", "backbone", "=", "dict", "(", "\n", "type", "=", "'ResNet'", ",", "\n", "depth", "=", "18", ",", "\n", "num_stages", "=", "4", ",", "\n", "out_indices", "=", "(", "0", ",", "1", ",", "2", ",", "3", ")", ",", "\n", "frozen_stages", "=", "-", "1", ",", "\n", "norm_cfg", "=", "dict", "(", "type", "=", "'BN'", ",", "requires_grad", "=", "True", ")", ",", "\n", "init_cfg", "=", "dict", "(", "\n", "type", "=", "'Pretrained'", ",", "checkpoint", "=", "'torchvision://resnet18'", ")", ",", "\n", "norm_eval", "=", "False", ",", "\n", "style", "=", "'caffe'", ")", ",", "\n", "neck", "=", "dict", "(", "\n", "type", "=", "'FPNC'", ",", "\n", "in_channels", "=", "[", "64", ",", "128", ",", "256", ",", "512", "]", ",", "\n", "lateral_channels", "=", "256", ")", ",", "\n", "bbox_head", "=", "dict", "(", "\n", "type", "=", "'DBHead'", ",", "\n", "text_repr_type", "=", "'quad'", ",", "\n", "in_channels", "=", "256", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'DBLoss'", ",", "alpha", "=", "5.0", ",", "beta", "=", "10.0", ",", "\n", "bbce_loss", "=", "True", ")", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", ")", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", "(", "cfg", ")", "\n", "\n", "pytorch_model", "=", "build_detector", "(", "cfg", ".", "model", ",", "None", ",", "None", ")", "\n", "\n", "# prepare data", "\n", "inputs", "=", "torch", ".", "rand", "(", "1", ",", "3", ",", "224", ",", "224", ")", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "[", "1", ",", "3", ",", "224", ",", "224", "]", ",", "\n", "'ori_shape'", ":", "[", "1", ",", "3", ",", "224", ",", "224", "]", ",", "\n", "'pad_shape'", ":", "[", "1", ",", "3", ",", "224", ",", "224", "]", ",", "\n", "'filename'", ":", "None", ",", "\n", "'scale_factor'", ":", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "}", "]", "\n", "\n", "pytorch_model", ".", "forward", "=", "pytorch_model", ".", "forward_dummy", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "onnx_path", "=", "f'{tmpdirname}/tmp.onnx'", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "torch", ".", "onnx", ".", "export", "(", "\n", "pytorch_model", ",", "\n", "inputs", ",", "\n", "onnx_path", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "export_params", "=", "True", ",", "\n", "keep_initializers_as_inputs", "=", "False", ",", "\n", "verbose", "=", "False", ",", "\n", "opset_version", "=", "11", ")", "\n", "\n", "# TensorRT part", "\n", "", "def", "get_GiB", "(", "x", ":", "int", ")", ":", "\n", "            ", "\"\"\"return x GiB.\"\"\"", "\n", "return", "x", "*", "(", "1", "<<", "30", ")", "\n", "\n", "", "trt_path", "=", "onnx_path", ".", "replace", "(", "'.onnx'", ",", "'.trt'", ")", "\n", "min_shape", "=", "[", "1", ",", "3", ",", "224", ",", "224", "]", "\n", "max_shape", "=", "[", "1", ",", "3", ",", "224", ",", "224", "]", "\n", "# create trt engine and wrapper", "\n", "opt_shape_dict", "=", "{", "'input'", ":", "[", "min_shape", ",", "min_shape", ",", "max_shape", "]", "}", "\n", "max_workspace_size", "=", "get_GiB", "(", "1", ")", "\n", "trt_engine", "=", "onnx2trt", "(", "\n", "onnx_path", ",", "\n", "opt_shape_dict", ",", "\n", "log_level", "=", "trt", ".", "Logger", ".", "ERROR", ",", "\n", "fp16_mode", "=", "False", ",", "\n", "max_workspace_size", "=", "max_workspace_size", ")", "\n", "save_trt_engine", "(", "trt_engine", ",", "trt_path", ")", "\n", "print", "(", "f'Successfully created TensorRT engine: {trt_path}'", ")", "\n", "\n", "wrap_onnx", "=", "ONNXRuntimeDetector", "(", "onnx_path", ",", "cfg", ",", "0", ")", "\n", "wrap_trt", "=", "TensorRTDetector", "(", "trt_path", ",", "cfg", ",", "0", ")", "\n", "\n", "", "assert", "isinstance", "(", "wrap_onnx", ",", "ONNXRuntimeDetector", ")", "\n", "assert", "isinstance", "(", "wrap_trt", ",", "TensorRTDetector", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "onnx_outputs", "=", "wrap_onnx", ".", "simple_test", "(", "inputs", ",", "img_metas", ",", "rescale", "=", "False", ")", "\n", "trt_outputs", "=", "wrap_onnx", ".", "simple_test", "(", "inputs", ",", "img_metas", ",", "rescale", "=", "False", ")", "\n", "\n", "", "assert", "isinstance", "(", "onnx_outputs", "[", "0", "]", ",", "dict", ")", "\n", "assert", "isinstance", "(", "trt_outputs", "[", "0", "]", ",", "dict", ")", "\n", "assert", "'boundary_result'", "in", "onnx_outputs", "[", "0", "]", "\n", "assert", "'boundary_result'", "in", "trt_outputs", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_core.test_deploy_utils.test_recognizer_wrapper": [[122, 226], ["pytest.mark.skipif", "pytest.mark.skipif", "pytest.mark.skipif", "dict", "mmcv.Config", "mmocr.models.build_detector", "torch.rand", "functools.partial", "isinstance", "isinstance", "isinstance", "isinstance", "tempfile.TemporaryDirectory", "onnx_path.replace", "test_deploy_utils.test_detector_wrapper.get_GiB"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.models.builder.build_detector", "home.repos.pwc.inspect_result.open-mmlab_mmocr.deployment.onnx2tensorrt.get_GiB"], ["", "@", "pytest", ".", "mark", ".", "skipif", "(", "torch", ".", "__version__", "==", "'parrots'", ",", "reason", "=", "'skip parrots.'", ")", "\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "version", ".", "parse", "(", "torch", ".", "__version__", ")", "<", "version", ".", "parse", "(", "'1.4.0'", ")", ",", "\n", "reason", "=", "'skip if torch=1.3.x'", ")", "\n", "@", "pytest", ".", "mark", ".", "skipif", "(", "\n", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "reason", "=", "'skip if on cpu device'", ")", "\n", "def", "test_recognizer_wrapper", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "import", "onnxruntime", "as", "ort", "# noqa: F401", "\n", "import", "tensorrt", "as", "trt", "\n", "from", "mmcv", ".", "tensorrt", "import", "onnx2trt", ",", "save_trt_engine", "\n", "", "except", "ImportError", ":", "\n", "        ", "pytest", ".", "skip", "(", "'ONNXRuntime or TensorRT is not available.'", ")", "\n", "\n", "", "cfg", "=", "dict", "(", "\n", "label_convertor", "=", "dict", "(", "\n", "type", "=", "'CTCConvertor'", ",", "\n", "dict_type", "=", "'DICT36'", ",", "\n", "with_unknown", "=", "False", ",", "\n", "lower", "=", "True", ")", ",", "\n", "model", "=", "dict", "(", "\n", "type", "=", "'CRNNNet'", ",", "\n", "preprocessor", "=", "None", ",", "\n", "backbone", "=", "dict", "(", "\n", "type", "=", "'VeryDeepVgg'", ",", "leaky_relu", "=", "False", ",", "input_channels", "=", "1", ")", ",", "\n", "encoder", "=", "None", ",", "\n", "decoder", "=", "dict", "(", "type", "=", "'CRNNDecoder'", ",", "in_channels", "=", "512", ",", "rnn_flag", "=", "True", ")", ",", "\n", "loss", "=", "dict", "(", "type", "=", "'CTCLoss'", ")", ",", "\n", "label_convertor", "=", "dict", "(", "\n", "type", "=", "'CTCConvertor'", ",", "\n", "dict_type", "=", "'DICT36'", ",", "\n", "with_unknown", "=", "False", ",", "\n", "lower", "=", "True", ")", ",", "\n", "pretrained", "=", "None", ")", ",", "\n", "train_cfg", "=", "None", ",", "\n", "test_cfg", "=", "None", ")", "\n", "\n", "cfg", "=", "mmcv", ".", "Config", "(", "cfg", ")", "\n", "\n", "pytorch_model", "=", "build_detector", "(", "cfg", ".", "model", ",", "None", ",", "None", ")", "\n", "\n", "# prepare data", "\n", "inputs", "=", "torch", ".", "rand", "(", "1", ",", "1", ",", "32", ",", "32", ")", "\n", "img_metas", "=", "[", "{", "\n", "'img_shape'", ":", "[", "1", ",", "1", ",", "32", ",", "32", "]", ",", "\n", "'ori_shape'", ":", "[", "1", ",", "1", ",", "32", ",", "32", "]", ",", "\n", "'pad_shape'", ":", "[", "1", ",", "1", ",", "32", ",", "32", "]", ",", "\n", "'filename'", ":", "None", ",", "\n", "'scale_factor'", ":", "np", ".", "array", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "}", "]", "\n", "\n", "pytorch_model", ".", "forward", "=", "partial", "(", "\n", "pytorch_model", ".", "forward", ",", "\n", "img_metas", "=", "img_metas", ",", "\n", "return_loss", "=", "False", ",", "\n", "rescale", "=", "True", ")", "\n", "with", "tempfile", ".", "TemporaryDirectory", "(", ")", "as", "tmpdirname", ":", "\n", "        ", "onnx_path", "=", "f'{tmpdirname}/tmp.onnx'", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "torch", ".", "onnx", ".", "export", "(", "\n", "pytorch_model", ",", "\n", "inputs", ",", "\n", "onnx_path", ",", "\n", "input_names", "=", "[", "'input'", "]", ",", "\n", "output_names", "=", "[", "'output'", "]", ",", "\n", "export_params", "=", "True", ",", "\n", "keep_initializers_as_inputs", "=", "False", ",", "\n", "verbose", "=", "False", ",", "\n", "opset_version", "=", "11", ")", "\n", "\n", "# TensorRT part", "\n", "", "def", "get_GiB", "(", "x", ":", "int", ")", ":", "\n", "            ", "\"\"\"return x GiB.\"\"\"", "\n", "return", "x", "*", "(", "1", "<<", "30", ")", "\n", "\n", "", "trt_path", "=", "onnx_path", ".", "replace", "(", "'.onnx'", ",", "'.trt'", ")", "\n", "min_shape", "=", "[", "1", ",", "1", ",", "32", ",", "32", "]", "\n", "max_shape", "=", "[", "1", ",", "1", ",", "32", ",", "32", "]", "\n", "# create trt engine and wrapper", "\n", "opt_shape_dict", "=", "{", "'input'", ":", "[", "min_shape", ",", "min_shape", ",", "max_shape", "]", "}", "\n", "max_workspace_size", "=", "get_GiB", "(", "1", ")", "\n", "trt_engine", "=", "onnx2trt", "(", "\n", "onnx_path", ",", "\n", "opt_shape_dict", ",", "\n", "log_level", "=", "trt", ".", "Logger", ".", "ERROR", ",", "\n", "fp16_mode", "=", "False", ",", "\n", "max_workspace_size", "=", "max_workspace_size", ")", "\n", "save_trt_engine", "(", "trt_engine", ",", "trt_path", ")", "\n", "print", "(", "f'Successfully created TensorRT engine: {trt_path}'", ")", "\n", "\n", "wrap_onnx", "=", "ONNXRuntimeRecognizer", "(", "onnx_path", ",", "cfg", ",", "0", ")", "\n", "wrap_trt", "=", "TensorRTRecognizer", "(", "trt_path", ",", "cfg", ",", "0", ")", "\n", "\n", "", "assert", "isinstance", "(", "wrap_onnx", ",", "ONNXRuntimeRecognizer", ")", "\n", "assert", "isinstance", "(", "wrap_trt", ",", "TensorRTRecognizer", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "onnx_outputs", "=", "wrap_onnx", ".", "simple_test", "(", "inputs", ",", "img_metas", ",", "rescale", "=", "False", ")", "\n", "trt_outputs", "=", "wrap_onnx", ".", "simple_test", "(", "inputs", ",", "img_metas", ",", "rescale", "=", "False", ")", "\n", "\n", "", "assert", "isinstance", "(", "onnx_outputs", "[", "0", "]", ",", "dict", ")", "\n", "assert", "isinstance", "(", "trt_outputs", "[", "0", "]", ",", "dict", ")", "\n", "assert", "'text'", "in", "onnx_outputs", "[", "0", "]", "\n", "assert", "'text'", "in", "trt_outputs", "[", "0", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_core.test_end2end_vis.test_det_recog_show_result": [[7, 26], ["mmocr.core.det_recog_show_result", "mmocr.core.det_recog_show_result", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.det_recog_show_result", "home.repos.pwc.inspect_result.open-mmlab_mmocr.core.visualize.det_recog_show_result"], ["def", "test_det_recog_show_result", "(", ")", ":", "\n", "    ", "img", "=", "np", ".", "ones", "(", "(", "100", ",", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "*", "255", "\n", "det_recog_res", "=", "{", "\n", "'result'", ":", "[", "{", "\n", "'box'", ":", "[", "51", ",", "88", ",", "51", ",", "62", ",", "85", ",", "62", ",", "85", ",", "88", "]", ",", "\n", "'box_score'", ":", "0.9417", ",", "\n", "'text'", ":", "'hell'", ",", "\n", "'text_score'", ":", "0.8834", "\n", "}", "]", "\n", "}", "\n", "\n", "vis_img", "=", "det_recog_show_result", "(", "img", ",", "det_recog_res", ")", "\n", "\n", "assert", "vis_img", ".", "shape", "[", "0", "]", "==", "100", "\n", "assert", "vis_img", ".", "shape", "[", "1", "]", "==", "200", "\n", "assert", "vis_img", ".", "shape", "[", "2", "]", "==", "3", "\n", "\n", "det_recog_res", "[", "'result'", "]", "[", "0", "]", "[", "'text'", "]", "=", "'\u4e2d\u6587'", "\n", "det_recog_show_result", "(", "img", ",", "det_recog_res", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_ic13.test_compute_recall_precision": [[11, 30], ["mmocr.compute_recall_precision", "pytest.raises", "mmocr.compute_recall_precision", "mmocr.points2polygon", "mmocr.points2polygon"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.compute_recall_precision", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.compute_recall_precision", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon"], ["def", "test_compute_recall_precision", "(", ")", ":", "\n", "\n", "    ", "gt_polys", "=", "[", "]", "\n", "det_polys", "=", "[", "]", "\n", "\n", "# test invalid arguments.", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "compute_recall_precision", "(", "1", ",", "1", ")", "\n", "\n", "", "box1", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "\n", "\n", "box2", "=", "[", "0", ",", "0", ",", "10", ",", "0", ",", "10", ",", "1", ",", "0", ",", "1", "]", "\n", "\n", "gt_polys", "=", "[", "utils", ".", "points2polygon", "(", "box1", ")", "]", "\n", "det_polys", "=", "[", "utils", ".", "points2polygon", "(", "box2", ")", "]", "\n", "recall", ",", "precision", "=", "hmean_ic13", ".", "compute_recall_precision", "(", "\n", "gt_polys", ",", "det_polys", ")", "\n", "assert", "recall", "==", "1", "\n", "assert", "precision", "==", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_ic13.test_eval_hmean_ic13": [[32, 118], ["mmocr.eval_hmean_ic13", "math.isclose", "mmocr.eval_hmean_ic13", "math.isclose", "mmocr.eval_hmean_ic13", "math.isclose", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13", "pytest.raises", "mmocr.eval_hmean_ic13"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_ic13.eval_hmean_ic13"], ["", "def", "test_eval_hmean_ic13", "(", ")", ":", "\n", "    ", "det_boxes", "=", "[", "]", "\n", "gt_boxes", "=", "[", "]", "\n", "gt_ignored_boxes", "=", "[", "]", "\n", "precision_thr", "=", "0.4", "\n", "recall_thr", "=", "0.8", "\n", "center_dist_thr", "=", "1.0", "\n", "one2one_score", "=", "1.", "\n", "one2many_score", "=", "0.8", "\n", "many2one_score", "=", "1", "\n", "# test invalid arguments.", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "[", "1", "]", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "recall_thr", ",", "center_dist_thr", ",", "\n", "one2one_score", ",", "one2many_score", ",", "\n", "many2one_score", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "1", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "recall_thr", ",", "center_dist_thr", ",", "\n", "one2one_score", ",", "one2many_score", ",", "\n", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "1", ",", "precision_thr", ",", "\n", "recall_thr", ",", "center_dist_thr", ",", "one2one_score", ",", "\n", "one2many_score", ",", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "1.1", ",", "\n", "recall_thr", ",", "center_dist_thr", ",", "one2one_score", ",", "\n", "one2many_score", ",", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "1.1", ",", "center_dist_thr", ",", "\n", "one2one_score", ",", "one2many_score", ",", "\n", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "recall_thr", ",", "-", "1", ",", "\n", "one2one_score", ",", "one2many_score", ",", "\n", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "recall_thr", ",", "center_dist_thr", ",", "\n", "-", "1", ",", "one2many_score", ",", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "recall_thr", ",", "center_dist_thr", ",", "\n", "one2one_score", ",", "-", "1", ",", "many2one_score", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_ic13", ".", "eval_hmean_ic13", "(", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "precision_thr", ",", "recall_thr", ",", "center_dist_thr", ",", "\n", "one2one_score", ",", "one2many_score", ",", "-", "1", ")", "\n", "\n", "# test one2one match", "\n", "", "det_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "10", ",", "0", ",", "11", ",", "0", ",", "11", ",", "1", ",", "10", ",", "1", "]", "]", "]", "\n", "gt_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "]", "]", "\n", "gt_ignored_boxes", "=", "[", "[", "]", "]", "\n", "dataset_result", ",", "img_result", "=", "hmean_ic13", ".", "eval_hmean_ic13", "(", "\n", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "precision_thr", ",", "recall_thr", ",", "\n", "center_dist_thr", ",", "one2one_score", ",", "one2many_score", ",", "many2one_score", ")", "\n", "assert", "img_result", "[", "0", "]", "[", "'recall'", "]", "==", "1", "\n", "assert", "img_result", "[", "0", "]", "[", "'precision'", "]", "==", "0.5", "\n", "assert", "math", ".", "isclose", "(", "img_result", "[", "0", "]", "[", "'hmean'", "]", ",", "2", "*", "(", "0.5", ")", "/", "1.5", ")", "\n", "\n", "# test one2many match", "\n", "gt_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "2", ",", "0", ",", "2", ",", "1", ",", "0", ",", "1", "]", "]", "]", "\n", "det_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "1", ",", "0", ",", "2", ",", "0", ",", "2", ",", "1", ",", "1", ",", "1", "]", "]", "]", "\n", "dataset_result", ",", "img_result", "=", "hmean_ic13", ".", "eval_hmean_ic13", "(", "\n", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "precision_thr", ",", "recall_thr", ",", "\n", "center_dist_thr", ",", "one2one_score", ",", "one2many_score", ",", "many2one_score", ")", "\n", "assert", "img_result", "[", "0", "]", "[", "'recall'", "]", "==", "0.8", "\n", "assert", "img_result", "[", "0", "]", "[", "'precision'", "]", "==", "1.6", "/", "2", "\n", "assert", "math", ".", "isclose", "(", "img_result", "[", "0", "]", "[", "'hmean'", "]", ",", "2", "*", "(", "0.64", ")", "/", "1.6", ")", "\n", "\n", "# test many2one match", "\n", "precision_thr", "=", "0.6", "\n", "recall_thr", "=", "0.8", "\n", "det_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "2", ",", "0", ",", "2", ",", "1", ",", "0", ",", "1", "]", "]", "]", "\n", "gt_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "1", ",", "0", ",", "2", ",", "0", ",", "2", ",", "1", ",", "1", ",", "1", "]", "]", "]", "\n", "dataset_result", ",", "img_result", "=", "hmean_ic13", ".", "eval_hmean_ic13", "(", "\n", "det_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "precision_thr", ",", "recall_thr", ",", "\n", "center_dist_thr", ",", "one2one_score", ",", "one2many_score", ",", "many2one_score", ")", "\n", "assert", "img_result", "[", "0", "]", "[", "'recall'", "]", "==", "1", "\n", "assert", "img_result", "[", "0", "]", "[", "'precision'", "]", "==", "1", "\n", "assert", "math", ".", "isclose", "(", "img_result", "[", "0", "]", "[", "'hmean'", "]", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_ignore_pred": [[10, 50], ["mmocr.ignore_pred", "mmocr.ignore_pred", "mmocr.ignore_pred", "mmocr.points2polygon", "pytest.raises", "mmocr.ignore_pred", "pytest.raises", "mmocr.ignore_pred", "pytest.raises", "mmocr.ignore_pred", "pytest.raises", "mmocr.ignore_pred"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.ignore_pred"], ["def", "test_ignore_pred", "(", ")", ":", "\n", "\n", "# test invalid arguments", "\n", "    ", "box", "=", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "\n", "det_boxes", "=", "[", "box", "]", "\n", "gt_dont_care_index", "=", "[", "0", "]", "\n", "gt_polys", "=", "[", "utils", ".", "points2polygon", "(", "box", ")", "]", "\n", "precision_thr", "=", "0.5", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "det_boxes_tmp", "=", "1", "\n", "utils", ".", "ignore_pred", "(", "det_boxes_tmp", ",", "gt_dont_care_index", ",", "gt_polys", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "gt_dont_care_index_tmp", "=", "1", "\n", "utils", ".", "ignore_pred", "(", "det_boxes", ",", "gt_dont_care_index_tmp", ",", "gt_polys", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "gt_polys_tmp", "=", "1", "\n", "utils", ".", "ignore_pred", "(", "det_boxes", ",", "gt_dont_care_index", ",", "gt_polys_tmp", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "precision_thr_tmp", "=", "1.1", "\n", "utils", ".", "ignore_pred", "(", "det_boxes", ",", "gt_dont_care_index", ",", "gt_polys", ",", "\n", "precision_thr_tmp", ")", "\n", "\n", "# test ignored cases", "\n", "", "result", "=", "utils", ".", "ignore_pred", "(", "det_boxes", ",", "gt_dont_care_index", ",", "gt_polys", ",", "\n", "precision_thr", ")", "\n", "assert", "result", "[", "2", "]", "==", "[", "0", "]", "\n", "# test unignored cases", "\n", "gt_dont_care_index_tmp", "=", "[", "]", "\n", "result", "=", "utils", ".", "ignore_pred", "(", "det_boxes", ",", "gt_dont_care_index_tmp", ",", "gt_polys", ",", "\n", "precision_thr", ")", "\n", "assert", "result", "[", "2", "]", "==", "[", "]", "\n", "\n", "det_boxes_tmp", "=", "[", "[", "10", ",", "10", ",", "15", ",", "10", ",", "15", ",", "15", ",", "10", ",", "15", "]", "]", "\n", "result", "=", "utils", ".", "ignore_pred", "(", "det_boxes_tmp", ",", "gt_dont_care_index", ",", "gt_polys", ",", "\n", "precision_thr", ")", "\n", "assert", "result", "[", "2", "]", "==", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_compute_hmean": [[52, 69], ["mmocr.compute_hmean", "mmocr.compute_hmean", "pytest.raises", "mmocr.compute_hmean", "pytest.raises", "mmocr.compute_hmean", "pytest.raises", "mmocr.compute_hmean", "pytest.raises", "mmocr.compute_hmean"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.compute_hmean"], ["", "def", "test_compute_hmean", "(", ")", ":", "\n", "\n", "# test invalid arguments", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "compute_hmean", "(", "0", ",", "0", ",", "0.0", ",", "0", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "compute_hmean", "(", "0", ",", "0", ",", "0", ",", "0.0", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "compute_hmean", "(", "[", "1", "]", ",", "0", ",", "0", ",", "0", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "compute_hmean", "(", "0", ",", "[", "1", "]", ",", "0", ",", "0", ")", "\n", "\n", "", "_", ",", "_", ",", "hmean", "=", "utils", ".", "compute_hmean", "(", "2", ",", "2", ",", "2", ",", "2", ")", "\n", "assert", "hmean", "==", "1", "\n", "\n", "_", ",", "_", ",", "hmean", "=", "utils", ".", "compute_hmean", "(", "0", ",", "0", ",", "2", ",", "2", ")", "\n", "assert", "hmean", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_points2polygon": [[71, 102], ["numpy.array", "mmocr.points2polygon", "mmocr.points2polygon", "pytest.raises", "mmocr.points2polygon", "pytest.raises", "mmocr.points2polygon", "pytest.raises", "mmocr.points2polygon"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon"], ["", "def", "test_points2polygon", "(", ")", ":", "\n", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "points", "=", "2", "\n", "utils", ".", "points2polygon", "(", "points", ")", "\n", "\n", "# test unsupported size", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "points", "=", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", "]", "\n", "utils", ".", "points2polygon", "(", "points", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "points", "=", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", "]", "\n", "utils", ".", "points2polygon", "(", "points", ")", "\n", "\n", "# test np.array", "\n", "", "points", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", ")", "\n", "poly", "=", "utils", ".", "points2polygon", "(", "points", ")", "\n", "i", "=", "0", "\n", "for", "coord", "in", "poly", ".", "exterior", ".", "coords", "[", ":", "-", "1", "]", ":", "\n", "        ", "assert", "coord", "[", "0", "]", "==", "points", "[", "i", "]", "\n", "assert", "coord", "[", "1", "]", "==", "points", "[", "i", "+", "1", "]", "\n", "i", "+=", "2", "\n", "\n", "", "points", "=", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", "]", "\n", "poly", "=", "utils", ".", "points2polygon", "(", "points", ")", "\n", "i", "=", "0", "\n", "for", "coord", "in", "poly", ".", "exterior", ".", "coords", "[", ":", "-", "1", "]", ":", "\n", "        ", "assert", "coord", "[", "0", "]", "==", "points", "[", "i", "]", "\n", "assert", "coord", "[", "1", "]", "==", "points", "[", "i", "+", "1", "]", "\n", "i", "+=", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_poly_intersection": [[104, 148], ["mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.poly_intersection", "mmocr.poly_intersection", "mmocr.poly_intersection", "mmocr.poly_intersection", "isinstance", "mmocr.poly_intersection", "isinstance", "mmocr.poly_intersection", "pytest.raises", "mmocr.poly_intersection", "mmocr.poly_intersection", "mmocr.poly_intersection", "mmocr.poly_intersection"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_intersection"], ["", "", "def", "test_poly_intersection", "(", ")", ":", "\n", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "poly_intersection", "(", "0", ",", "1", ")", "\n", "\n", "# test non-overlapping polygons", "\n", "\n", "", "points", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", "]", "\n", "points1", "=", "[", "10", ",", "20", ",", "30", ",", "40", ",", "50", ",", "60", ",", "70", ",", "80", "]", "\n", "points2", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "# Invalid polygon", "\n", "points3", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "# Self-intersected polygon", "\n", "points4", "=", "[", "0.5", ",", "0", ",", "1.5", ",", "0", ",", "1.5", ",", "1", ",", "0.5", ",", "1", "]", "\n", "poly", "=", "utils", ".", "points2polygon", "(", "points", ")", "\n", "poly1", "=", "utils", ".", "points2polygon", "(", "points1", ")", "\n", "poly2", "=", "utils", ".", "points2polygon", "(", "points2", ")", "\n", "poly3", "=", "utils", ".", "points2polygon", "(", "points3", ")", "\n", "poly4", "=", "utils", ".", "points2polygon", "(", "points4", ")", "\n", "\n", "area_inters", "=", "utils", ".", "poly_intersection", "(", "poly", ",", "poly1", ")", "\n", "\n", "assert", "area_inters", "==", "0", "\n", "\n", "# test overlapping polygons", "\n", "area_inters", "=", "utils", ".", "poly_intersection", "(", "poly", ",", "poly", ")", "\n", "assert", "area_inters", "==", "1", "\n", "area_inters", "=", "utils", ".", "poly_intersection", "(", "poly", ",", "poly4", ")", "\n", "assert", "area_inters", "==", "0.5", "\n", "\n", "# test invalid polygons", "\n", "assert", "utils", ".", "poly_intersection", "(", "poly2", ",", "poly2", ")", "==", "0", "\n", "assert", "utils", ".", "poly_intersection", "(", "poly3", ",", "poly3", ",", "invalid_ret", "=", "1", ")", "==", "1", "\n", "# The return value depends on the implementation of the package", "\n", "assert", "utils", ".", "poly_intersection", "(", "poly3", ",", "poly3", ",", "invalid_ret", "=", "None", ")", "==", "0.25", "\n", "\n", "# test poly return", "\n", "_", ",", "poly", "=", "utils", ".", "poly_intersection", "(", "poly", ",", "poly4", ",", "return_poly", "=", "True", ")", "\n", "assert", "isinstance", "(", "poly", ",", "Polygon", ")", "\n", "_", ",", "poly", "=", "utils", ".", "poly_intersection", "(", "\n", "poly3", ",", "poly3", ",", "invalid_ret", "=", "None", ",", "return_poly", "=", "True", ")", "\n", "assert", "isinstance", "(", "poly", ",", "Polygon", ")", "\n", "_", ",", "poly", "=", "utils", ".", "poly_intersection", "(", "\n", "poly2", ",", "poly3", ",", "invalid_ret", "=", "1", ",", "return_poly", "=", "True", ")", "\n", "assert", "poly", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_poly_union": [[150, 190], ["mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.poly_union", "isinstance", "mmocr.poly_union", "isinstance", "mmocr.poly_union", "pytest.raises", "mmocr.poly_union", "mmocr.poly_union", "mmocr.poly_union", "mmocr.poly_union", "mmocr.poly_union", "mmocr.poly_union", "mmocr.poly_union", "mmocr.poly_union"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_union"], ["", "def", "test_poly_union", "(", ")", ":", "\n", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "poly_union", "(", "0", ",", "1", ")", "\n", "\n", "# test non-overlapping polygons", "\n", "\n", "", "points", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", "]", "\n", "points1", "=", "[", "2", ",", "2", ",", "2", ",", "3", ",", "3", ",", "3", ",", "3", ",", "2", "]", "\n", "points2", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "# Invalid polygon", "\n", "points3", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "# Self-intersected polygon", "\n", "points4", "=", "[", "0.5", ",", "0.5", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0.5", ",", "0.5", "]", "\n", "poly", "=", "utils", ".", "points2polygon", "(", "points", ")", "\n", "poly1", "=", "utils", ".", "points2polygon", "(", "points1", ")", "\n", "poly2", "=", "utils", ".", "points2polygon", "(", "points2", ")", "\n", "poly3", "=", "utils", ".", "points2polygon", "(", "points3", ")", "\n", "poly4", "=", "utils", ".", "points2polygon", "(", "points4", ")", "\n", "\n", "assert", "utils", ".", "poly_union", "(", "poly", ",", "poly1", ")", "==", "2", "\n", "\n", "# test overlapping polygons", "\n", "assert", "utils", ".", "poly_union", "(", "poly", ",", "poly", ")", "==", "1", "\n", "\n", "# test invalid polygons", "\n", "assert", "utils", ".", "poly_union", "(", "poly2", ",", "poly2", ")", "==", "0", "\n", "assert", "utils", ".", "poly_union", "(", "poly3", ",", "poly3", ",", "invalid_ret", "=", "1", ")", "==", "1", "\n", "\n", "# The return value depends on the implementation of the package", "\n", "assert", "utils", ".", "poly_union", "(", "poly3", ",", "poly3", ",", "invalid_ret", "=", "None", ")", "==", "0.25", "\n", "assert", "utils", ".", "poly_union", "(", "poly2", ",", "poly3", ")", "==", "0.25", "\n", "assert", "utils", ".", "poly_union", "(", "poly3", ",", "poly4", ")", "==", "0.5", "\n", "\n", "# test poly return", "\n", "_", ",", "poly", "=", "utils", ".", "poly_union", "(", "poly", ",", "poly1", ",", "return_poly", "=", "True", ")", "\n", "assert", "isinstance", "(", "poly", ",", "MultiPolygon", ")", "\n", "_", ",", "poly", "=", "utils", ".", "poly_union", "(", "poly3", ",", "poly3", ",", "return_poly", "=", "True", ")", "\n", "assert", "isinstance", "(", "poly", ",", "Polygon", ")", "\n", "_", ",", "poly", "=", "utils", ".", "poly_union", "(", "poly2", ",", "poly3", ",", "invalid_ret", "=", "0", ",", "return_poly", "=", "True", ")", "\n", "assert", "poly", "is", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_poly_iou": [[192, 217], ["mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "mmocr.points2polygon", "pytest.raises", "mmocr.poly_iou", "mmocr.poly_iou", "mmocr.poly_iou", "mmocr.poly_iou", "mmocr.poly_iou", "mmocr.poly_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points2polygon", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.poly_iou"], ["", "def", "test_poly_iou", "(", ")", ":", "\n", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "poly_iou", "(", "[", "1", "]", ",", "[", "2", "]", ")", "\n", "\n", "", "points", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", "]", "\n", "points1", "=", "[", "10", ",", "20", ",", "30", ",", "40", ",", "50", ",", "60", ",", "70", ",", "80", "]", "\n", "points2", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "# Invalid polygon", "\n", "points3", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "# Self-intersected polygon", "\n", "\n", "poly", "=", "utils", ".", "points2polygon", "(", "points", ")", "\n", "poly1", "=", "utils", ".", "points2polygon", "(", "points1", ")", "\n", "poly2", "=", "utils", ".", "points2polygon", "(", "points2", ")", "\n", "poly3", "=", "utils", ".", "points2polygon", "(", "points3", ")", "\n", "\n", "assert", "utils", ".", "poly_iou", "(", "poly", ",", "poly1", ")", "==", "0", "\n", "\n", "# test overlapping polygons", "\n", "assert", "utils", ".", "poly_iou", "(", "poly", ",", "poly", ")", "==", "1", "\n", "\n", "# test invalid polygons", "\n", "assert", "utils", ".", "poly_iou", "(", "poly2", ",", "poly2", ")", "==", "0", "\n", "assert", "utils", ".", "poly_iou", "(", "poly3", ",", "poly3", ",", "zero_division", "=", "1", ")", "==", "1", "\n", "assert", "utils", ".", "poly_iou", "(", "poly2", ",", "poly3", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_boundary_iou": [[219, 234], ["mmocr.boundary_iou", "mmocr.boundary_iou", "mmocr.boundary_iou", "mmocr.boundary_iou", "mmocr.boundary_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.boundary_iou"], ["", "def", "test_boundary_iou", "(", ")", ":", "\n", "    ", "points", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "1", ",", "1", ",", "0", "]", "\n", "points1", "=", "[", "10", ",", "20", ",", "30", ",", "40", ",", "50", ",", "60", ",", "70", ",", "80", "]", "\n", "points2", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "# Invalid polygon", "\n", "points3", "=", "[", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", ",", "1", "]", "# Self-intersected polygon", "\n", "\n", "assert", "utils", ".", "boundary_iou", "(", "points", ",", "points1", ")", "==", "0", "\n", "\n", "# test overlapping boundaries", "\n", "assert", "utils", ".", "boundary_iou", "(", "points", ",", "points", ")", "==", "1", "\n", "\n", "# test invalid boundaries", "\n", "assert", "utils", ".", "boundary_iou", "(", "points2", ",", "points2", ")", "==", "0", "\n", "assert", "utils", ".", "boundary_iou", "(", "points3", ",", "points3", ",", "zero_division", "=", "1", ")", "==", "1", "\n", "assert", "utils", ".", "boundary_iou", "(", "points2", ",", "points3", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_points_center": [[236, 247], ["numpy.array", "numpy.array_equal", "pytest.raises", "mmocr.points_center", "pytest.raises", "numpy.array", "mmocr.points_center", "mmocr.points_center", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points_center", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points_center", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.points_center"], ["", "def", "test_points_center", "(", ")", ":", "\n", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "points_center", "(", "[", "1", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "points", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "utils", ".", "points_center", "(", "points", ")", "\n", "\n", "", "points", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "assert", "np", ".", "array_equal", "(", "utils", ".", "points_center", "(", "points", ")", ",", "np", ".", "array", "(", "[", "2", ",", "3", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_point_distance": [[249, 263], ["numpy.array", "numpy.array", "pytest.raises", "mmocr.point_distance", "pytest.raises", "numpy.array", "mmocr.point_distance", "mmocr.point_distance", "mmocr.point_distance"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.point_distance"], ["", "def", "test_point_distance", "(", ")", ":", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "point_distance", "(", "[", "1", ",", "2", "]", ",", "[", "1", ",", "2", "]", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "p", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "utils", ".", "point_distance", "(", "p", ",", "p", ")", "\n", "\n", "", "p", "=", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", "\n", "assert", "utils", ".", "point_distance", "(", "p", ",", "p", ")", "==", "0", "\n", "\n", "p1", "=", "np", ".", "array", "(", "[", "2", ",", "2", "]", ")", "\n", "assert", "utils", ".", "point_distance", "(", "p", ",", "p1", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_box_center_distance": [[265, 270], ["numpy.array", "numpy.array", "mmocr.box_center_distance"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_center_distance"], ["", "def", "test_box_center_distance", "(", ")", ":", "\n", "    ", "p1", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "3", ",", "3", "]", ")", "\n", "p2", "=", "np", ".", "array", "(", "[", "2", ",", "2", ",", "4", ",", "2", "]", ")", "\n", "\n", "assert", "utils", ".", "box_center_distance", "(", "p1", ",", "p2", ")", "==", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_box_diag": [[272, 282], ["numpy.array", "pytest.raises", "mmocr.box_diag", "pytest.raises", "mmocr.box_diag", "mmocr.box_diag", "numpy.array"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_diag", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_diag", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.box_diag"], ["", "def", "test_box_diag", "(", ")", ":", "\n", "# test unsupported type", "\n", "    ", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "box_diag", "(", "[", "1", ",", "2", "]", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "box_diag", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", ")", "\n", "\n", "", "box", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "10", ",", "-", "10", ",", "0", "]", ")", "\n", "\n", "assert", "utils", ".", "box_diag", "(", "box", ")", "==", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_one2one_match_ic13": [[284, 321], ["numpy.array", "numpy.array", "mmocr.one2one_match_ic13", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "pytest.raises", "mmocr.one2one_match_ic13", "pytest.raises", "mmocr.one2one_match_ic13", "pytest.raises", "mmocr.one2one_match_ic13", "pytest.raises", "mmocr.one2one_match_ic13", "pytest.raises", "mmocr.one2one_match_ic13", "pytest.raises", "mmocr.one2one_match_ic13", "mmocr.one2one_match_ic13", "mmocr.one2one_match_ic13"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2one_match_ic13"], ["", "def", "test_one2one_match_ic13", "(", ")", ":", "\n", "    ", "gt_id", "=", "0", "\n", "det_id", "=", "0", "\n", "recall_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "precision_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "recall_thr", "=", "0.5", "\n", "precision_thr", "=", "0.5", "\n", "# test invalid arguments.", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "one2one_match_ic13", "(", "0.0", ",", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "one2one_match_ic13", "(", "gt_id", ",", "0.0", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "one2one_match_ic13", "(", "gt_id", ",", "det_id", ",", "[", "0", ",", "0", "]", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "one2one_match_ic13", "(", "gt_id", ",", "det_id", ",", "recall_mat", ",", "[", "0", ",", "0", "]", ",", "recall_thr", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "one2one_match_ic13", "(", "gt_id", ",", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "1.1", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "utils", ".", "one2one_match_ic13", "(", "gt_id", ",", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "1.1", ")", "\n", "\n", "", "assert", "utils", ".", "one2one_match_ic13", "(", "gt_id", ",", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ")", "\n", "recall_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0.6", ",", "0", "]", "]", ")", "\n", "precision_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0.6", ",", "0", "]", "]", ")", "\n", "assert", "not", "utils", ".", "one2one_match_ic13", "(", "\n", "gt_id", ",", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "precision_thr", ")", "\n", "recall_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0.6", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "precision_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0.6", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "assert", "not", "utils", ".", "one2one_match_ic13", "(", "\n", "gt_id", ",", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "precision_thr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_one2many_match_ic13": [[323, 391], ["numpy.array", "numpy.array", "mmocr.one2many_match_ic13", "mmocr.one2many_match_ic13", "pytest.raises", "mmocr.one2many_match_ic13", "pytest.raises", "mmocr.one2many_match_ic13", "pytest.raises", "mmocr.one2many_match_ic13", "pytest.raises", "mmocr.one2many_match_ic13", "pytest.raises", "mmocr.one2many_match_ic13", "pytest.raises", "numpy.array", "mmocr.one2many_match_ic13", "pytest.raises", "numpy.array", "mmocr.one2many_match_ic13", "pytest.raises", "numpy.array", "mmocr.one2many_match_ic13"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.one2many_match_ic13"], ["", "def", "test_one2many_match_ic13", "(", ")", ":", "\n", "    ", "gt_id", "=", "0", "\n", "recall_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "precision_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "recall_thr", "=", "0.5", "\n", "precision_thr", "=", "0.5", "\n", "gt_match_flag", "=", "[", "0", ",", "0", "]", "\n", "det_match_flag", "=", "[", "0", ",", "0", "]", "\n", "det_dont_care_index", "=", "[", "]", "\n", "# test invalid arguments.", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "gt_id_tmp", "=", "0.0", "\n", "utils", ".", "one2many_match_ic13", "(", "gt_id_tmp", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "recall_mat_tmp", "=", "[", "1", ",", "0", "]", "\n", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat_tmp", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "precision_mat_tmp", "=", "[", "1", ",", "0", "]", "\n", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat_tmp", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "\n", "        ", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "1.1", ",", "\n", "precision_thr", ",", "gt_match_flag", ",", "det_match_flag", ",", "\n", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "\n", "        ", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "1.1", ",", "gt_match_flag", ",", "det_match_flag", ",", "\n", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "gt_match_flag_tmp", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "precision_thr", ",", "gt_match_flag_tmp", ",", "\n", "det_match_flag", ",", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "det_match_flag_tmp", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag_tmp", ",", "det_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "det_dont_care_index_tmp", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "recall_thr", ",", "\n", "precision_thr", ",", "gt_match_flag", ",", "det_match_flag", ",", "\n", "det_dont_care_index_tmp", ")", "\n", "\n", "# test matched case", "\n", "\n", "", "result", "=", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "\n", "gt_match_flag", ",", "det_match_flag", ",", "\n", "det_dont_care_index", ")", "\n", "assert", "result", "[", "0", "]", "\n", "assert", "result", "[", "1", "]", "==", "[", "0", "]", "\n", "\n", "# test unmatched case", "\n", "gt_match_flag_tmp", "=", "[", "1", ",", "0", "]", "\n", "result", "=", "utils", ".", "one2many_match_ic13", "(", "gt_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "\n", "gt_match_flag_tmp", ",", "det_match_flag", ",", "\n", "det_dont_care_index", ")", "\n", "assert", "not", "result", "[", "0", "]", "\n", "assert", "result", "[", "1", "]", "==", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_eval_utils.test_many2one_match_ic13": [[393, 463], ["numpy.array", "numpy.array", "mmocr.many2one_match_ic13", "mmocr.many2one_match_ic13", "pytest.raises", "mmocr.many2one_match_ic13", "pytest.raises", "mmocr.many2one_match_ic13", "pytest.raises", "mmocr.many2one_match_ic13", "pytest.raises", "mmocr.many2one_match_ic13", "pytest.raises", "mmocr.many2one_match_ic13", "pytest.raises", "numpy.array", "mmocr.many2one_match_ic13", "pytest.raises", "numpy.array", "mmocr.many2one_match_ic13", "pytest.raises", "numpy.array", "mmocr.many2one_match_ic13"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.utils.many2one_match_ic13"], ["", "def", "test_many2one_match_ic13", "(", ")", ":", "\n", "    ", "det_id", "=", "0", "\n", "recall_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "precision_mat", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", ")", "\n", "recall_thr", "=", "0.5", "\n", "precision_thr", "=", "0.5", "\n", "gt_match_flag", "=", "[", "0", ",", "0", "]", "\n", "det_match_flag", "=", "[", "0", ",", "0", "]", "\n", "gt_dont_care_index", "=", "[", "]", "\n", "# test invalid arguments.", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "det_id_tmp", "=", "1.0", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id_tmp", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "recall_mat_tmp", "=", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat_tmp", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "precision_mat_tmp", "=", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat_tmp", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "recall_thr_tmp", "=", "1.1", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr_tmp", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "precision_thr_tmp", "=", "1.1", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr_tmp", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "gt_match_flag_tmp", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag_tmp", ",", "\n", "det_match_flag", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "det_match_flag_tmp", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag_tmp", ",", "gt_dont_care_index", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "gt_dont_care_index_tmp", "=", "np", ".", "array", "(", "[", "0", ",", "1", "]", ")", "\n", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "gt_match_flag", ",", "\n", "det_match_flag", ",", "gt_dont_care_index_tmp", ")", "\n", "\n", "# test matched cases", "\n", "\n", "", "result", "=", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "\n", "gt_match_flag", ",", "det_match_flag", ",", "\n", "gt_dont_care_index", ")", "\n", "assert", "result", "[", "0", "]", "\n", "assert", "result", "[", "1", "]", "==", "[", "0", "]", "\n", "\n", "# test unmatched cases", "\n", "\n", "gt_dont_care_index", "=", "[", "0", "]", "\n", "\n", "result", "=", "utils", ".", "many2one_match_ic13", "(", "det_id", ",", "recall_mat", ",", "precision_mat", ",", "\n", "recall_thr", ",", "precision_thr", ",", "\n", "gt_match_flag", ",", "det_match_flag", ",", "\n", "gt_dont_care_index", ")", "\n", "assert", "not", "result", "[", "0", "]", "\n", "assert", "result", "[", "1", "]", "==", "[", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_detect._create_dummy_ann_infos": [[11, 20], ["numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["def", "_create_dummy_ann_infos", "(", ")", ":", "\n", "    ", "ann_infos", "=", "{", "\n", "'bboxes'", ":", "np", ".", "array", "(", "[", "[", "50.", ",", "70.", ",", "80.", ",", "100.", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'labels'", ":", "np", ".", "array", "(", "[", "1", "]", ",", "dtype", "=", "np", ".", "int64", ")", ",", "\n", "'bboxes_ignore'", ":", "np", ".", "array", "(", "[", "[", "120", ",", "140", ",", "200", ",", "200", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'masks'", ":", "[", "[", "[", "50", ",", "70", ",", "80", ",", "70", ",", "80", ",", "100", ",", "50", ",", "100", "]", "]", "]", ",", "\n", "'masks_ignore'", ":", "[", "[", "[", "120", ",", "140", ",", "200", ",", "140", ",", "200", ",", "200", ",", "120", ",", "200", "]", "]", "]", "\n", "}", "\n", "return", "[", "ann_infos", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_detect.test_output_ranklist": [[22, 38], ["mmocr.core.evaluation.hmean.output_ranklist", "tempfile.NamedTemporaryFile", "pytest.raises", "mmocr.core.evaluation.hmean.output_ranklist", "pytest.raises", "mmocr.core.evaluation.hmean.output_ranklist", "pytest.raises", "mmocr.core.evaluation.hmean.output_ranklist"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.output_ranklist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.output_ranklist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.output_ranklist", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.output_ranklist"], ["", "def", "test_output_ranklist", "(", ")", ":", "\n", "    ", "result", "=", "[", "{", "'hmean'", ":", "1", "}", ",", "{", "'hmean'", ":", "0.5", "}", "]", "\n", "file_name", "=", "tempfile", ".", "NamedTemporaryFile", "(", ")", ".", "name", "\n", "img_infos", "=", "[", "{", "'file_name'", ":", "'sample1.jpg'", "}", ",", "{", "'file_name'", ":", "'sample2.jpg'", "}", "]", "\n", "\n", "json_file", "=", "file_name", "+", "'.json'", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "output_ranklist", "(", "[", "[", "]", "]", ",", "img_infos", ",", "json_file", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "output_ranklist", "(", "result", ",", "[", "[", "]", "]", ",", "json_file", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "output_ranklist", "(", "result", ",", "img_infos", ",", "file_name", ")", "\n", "\n", "", "sorted_outputs", "=", "output_ranklist", "(", "result", ",", "img_infos", ",", "json_file", ")", "\n", "\n", "assert", "sorted_outputs", "[", "0", "]", "[", "'hmean'", "]", "==", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_detect.test_get_gt_mask": [[40, 47], ["test_hmean_detect._create_dummy_ann_infos", "mmocr.core.evaluation.hmean.get_gt_masks", "numpy.allclose", "numpy.allclose"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_detect._create_dummy_ann_infos", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.get_gt_masks"], ["", "def", "test_get_gt_mask", "(", ")", ":", "\n", "    ", "ann_infos", "=", "_create_dummy_ann_infos", "(", ")", "\n", "gt_masks", ",", "gt_masks_ignore", "=", "get_gt_masks", "(", "ann_infos", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "gt_masks", "[", "0", "]", ",", "[", "[", "50", ",", "70", ",", "80", ",", "70", ",", "80", ",", "100", ",", "50", ",", "100", "]", "]", ")", "\n", "assert", "np", ".", "allclose", "(", "gt_masks_ignore", "[", "0", "]", ",", "\n", "[", "[", "120", ",", "140", ",", "200", ",", "140", ",", "200", ",", "200", ",", "120", ",", "200", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_detect.test_eval_hmean": [[49, 73], ["set", "test_hmean_detect._create_dummy_ann_infos", "mmocr.core.evaluation.hmean.eval_hmean", "pytest.raises", "mmocr.core.evaluation.hmean.eval_hmean", "pytest.raises", "mmocr.core.evaluation.hmean.eval_hmean", "pytest.raises", "mmocr.core.evaluation.hmean.eval_hmean", "pytest.raises", "mmocr.core.evaluation.hmean.eval_hmean"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_detect._create_dummy_ann_infos", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean.eval_hmean"], ["", "def", "test_eval_hmean", "(", ")", ":", "\n", "    ", "metrics", "=", "set", "(", "[", "'hmean-iou'", ",", "'hmean-ic13'", "]", ")", "\n", "results", "=", "[", "{", "\n", "'boundary_result'", ":", "[", "[", "50", ",", "70", ",", "80", ",", "70", ",", "80", ",", "100", ",", "50", ",", "100", ",", "1", "]", ",", "\n", "[", "120", ",", "140", ",", "200", ",", "140", ",", "200", ",", "200", ",", "120", ",", "200", ",", "1", "]", "]", "\n", "}", "]", "\n", "\n", "img_infos", "=", "[", "{", "'file_name'", ":", "'sample1.jpg'", "}", "]", "\n", "ann_infos", "=", "_create_dummy_ann_infos", "(", ")", "\n", "\n", "# test invalid arguments", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "eval_hmean", "(", "results", ",", "[", "[", "]", "]", ",", "ann_infos", ",", "metrics", "=", "metrics", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "eval_hmean", "(", "results", ",", "img_infos", ",", "[", "[", "]", "]", ",", "metrics", "=", "metrics", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "eval_hmean", "(", "[", "[", "]", "]", ",", "img_infos", ",", "ann_infos", ",", "metrics", "=", "metrics", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "eval_hmean", "(", "results", ",", "img_infos", ",", "ann_infos", ",", "metrics", "=", "'hmean-iou'", ")", "\n", "\n", "", "eval_results", "=", "eval_hmean", "(", "results", ",", "img_infos", ",", "ann_infos", ",", "metrics", "=", "metrics", ")", "\n", "\n", "assert", "eval_results", "[", "'hmean-iou:hmean'", "]", "==", "1", "\n", "assert", "eval_results", "[", "'hmean-ic13:hmean'", "]", "==", "1", "\n", "", ""]], "home.repos.pwc.inspect_result.open-mmlab_mmocr.test_metrics.test_hmean_iou.test_eval_hmean_iou": [[8, 42], ["mmocr.eval_hmean_iou", "pytest.raises", "mmocr.eval_hmean_iou", "pytest.raises", "mmocr.eval_hmean_iou", "pytest.raises", "mmocr.eval_hmean_iou", "pytest.raises", "mmocr.eval_hmean_iou", "pytest.raises", "mmocr.eval_hmean_iou"], "function", ["home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou", "home.repos.pwc.inspect_result.open-mmlab_mmocr.evaluation.hmean_iou.eval_hmean_iou"], ["def", "test_eval_hmean_iou", "(", ")", ":", "\n", "\n", "    ", "pred_boxes", "=", "[", "]", "\n", "gt_boxes", "=", "[", "]", "\n", "gt_ignored_boxes", "=", "[", "]", "\n", "iou_thr", "=", "0.5", "\n", "precision_thr", "=", "0.5", "\n", "\n", "# test invalid arguments.", "\n", "\n", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_iou", ".", "eval_hmean_iou", "(", "[", "1", "]", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "iou_thr", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_iou", ".", "eval_hmean_iou", "(", "pred_boxes", ",", "[", "1", "]", ",", "gt_ignored_boxes", ",", "iou_thr", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_iou", ".", "eval_hmean_iou", "(", "pred_boxes", ",", "gt_boxes", ",", "[", "1", "]", ",", "iou_thr", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_iou", ".", "eval_hmean_iou", "(", "pred_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "1.1", ",", "\n", "precision_thr", ")", "\n", "", "with", "pytest", ".", "raises", "(", "AssertionError", ")", ":", "\n", "        ", "hmean_iou", ".", "eval_hmean_iou", "(", "pred_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "iou_thr", ",", "1.1", ")", "\n", "\n", "", "pred_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "2", ",", "0", ",", "3", ",", "0", ",", "3", ",", "1", ",", "2", ",", "1", "]", "]", "]", "\n", "gt_boxes", "=", "[", "[", "[", "0", ",", "0", ",", "1", ",", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", ",", "[", "2", ",", "0", ",", "3", ",", "0", ",", "3", ",", "1", ",", "2", ",", "1", "]", "]", "]", "\n", "gt_ignored_boxes", "=", "[", "[", "]", "]", "\n", "results", "=", "hmean_iou", ".", "eval_hmean_iou", "(", "pred_boxes", ",", "gt_boxes", ",", "gt_ignored_boxes", ",", "\n", "iou_thr", ",", "precision_thr", ")", "\n", "assert", "results", "[", "1", "]", "[", "0", "]", "[", "'recall'", "]", "==", "1", "\n", "assert", "results", "[", "1", "]", "[", "0", "]", "[", "'precision'", "]", "==", "1", "\n", "assert", "results", "[", "1", "]", "[", "0", "]", "[", "'hmean'", "]", "==", "1", "\n", "", ""]]}