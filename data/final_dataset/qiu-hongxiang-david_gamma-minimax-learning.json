{"home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.__init__": [[35, 73], ["simulation.Gamma_minimax_Problem.eval_parameter_constraint", "torch.sum().mean", "numpy.array", "numpy.concatenate", "numpy.ones", "simulation.Gamma_minimax_Problem.distrs.extend", "simulation.Gamma_minimax_Problem.generate_ps", "torch.zeros", "torch.as_tensor", "simulation.parameter_constraint_fun", "simulation.Gamma_minimax_Problem.generate_ps", "torch.sum", "numpy.array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.eval_parameter_constraint": [[74, 95], ["simulation.Gamma_minimax_Problem.parameter_constraint_fun", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun"], ["\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.enlarge_distr_grid": [[96, 104], ["simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.distrs.extend", "torch.cat", "simulation.Gamma_minimax_Problem.eval_parameter_constraint", "len", "simulation.Gamma_minimax_Problem.generate_ps", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.get_constraint_matrices": [[105, 117], ["simulation.Gamma_minimax_Problem.A_ubT.cpu().numpy().transpose", "simulation.Gamma_minimax_Problem.A_eqT.cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "simulation.Gamma_minimax_Problem.A_ubT.cpu().numpy", "simulation.Gamma_minimax_Problem.A_eqT.cpu().numpy", "numpy.ones", "simulation.Gamma_minimax_Problem.prior_prob.size", "simulation.Gamma_minimax_Problem.A_ubT.cpu", "simulation.Gamma_minimax_Problem.A_eqT.cpu", "simulation.Gamma_minimax_Problem.prior_prob.size"], "methods", ["None"], ["\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.draw_sample": [[118, 130], ["torch.empty", "enumerate", "torch.distributions.Multinomial().sample().type", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample", "torch.distributions.Multinomial", "p.cpu"], "methods", ["None"], ["\n", "", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.calc_Risks_tensor": [[131, 154], ["len", "torch.empty", "torch.empty", "enumerate", "estimator().view", "simulation.Gamma_minimax_Problem.Risk_fun", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample.type", "prob_occur_new_sample.unsqueeze().cpu", "estimator", "torch.distributions.Multinomial", "torch.empty.reshape", "p.cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff": [[155, 179], ["len", "torch.empty", "enumerate", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "estimator().view", "simulation.Gamma_minimax_Problem.Risk_fun", "len", "torch.distributions.Multinomial().sample.type", "true_prediction_mean.cuda.cuda.cuda", "torch.distributions.Multinomial", "torch.as_tensor", "torch.as_tensor", "estimator", "p.cpu", "torch.as_tensor().unsqueeze.reshape", "prob_occur_new_sample.unsqueeze().cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.log_pseudo_prior": [[180, 183], ["torch.tensor", "MCMC_normal_distribution.log_prob().item", "MCMC_negbinomial_distribution.log_prob().item", "MCMC_normal_distribution.log_prob", "MCMC_negbinomial_distribution.log_prob", "simulation.Gamma_minimax_Problem.parameter", "torch.tensor", "p.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.generate_ps": [[184, 259], ["simulation.Gamma_minimax_Problem.log_pseudo_prior", "max", "torch.distributions.dirichlet.Dirichlet().sample", "torch.distributions.dirichlet.Dirichlet().sample.size", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.poisson.Poisson", "torch.distributions.poisson.Poisson.sample", "torch.distributions.poisson.Poisson", "numpy.ceil", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.no_grad", "torch.exp", "torch.distributions.poisson.Poisson.sample", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "torch.cat", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "numpy.random.uniform", "torch.ones", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.cat", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.ones", "torch.distributions.dirichlet.Dirichlet.log_prob", "int", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.ones", "torch.no_grad", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "int", "torch.sum().unsqueeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.sum", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.log", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.log", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.SGDmax": [[260, 316], ["simulation.Gamma_minimax_Problem.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "simulation.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "simulation.Gamma_minimax_Problem.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "simulation.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "simulation.Gamma_minimax_Problem.estimator.parameters", "scipy.optimize.linprog", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "RuntimeError", "simulation.Gamma_minimax_Problem.dot.item", "simulation.Gamma_minimax_Problem.dot", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.dot", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Gamma_minimax_Problem.calc_Gamma_minimax_estimator": [[317, 383], ["simulation.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "range", "torch.optim.SGD", "simulation.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.clone", "simulation.Gamma_minimax_Problem.enlarge_distr_grid", "simulation.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.dot().item", "eval_Risks[].dot().item", "risk_iter.append", "simulation.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.dot", "eval_Risks[].dot", "numpy.array", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu", "str"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff"], ["risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.JVHW_estimator.__init__": [[442, 454], ["float", "min", "numpy.array", "numpy.array", "numpy.arange", "int", "scipy.loadmat", "numpy.ceil", "numpy.log"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n", "if", "poly_entro", "is", "None", ":", "\n", "            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.JVHW_estimator.__call__": [[455, 479], ["samples.t().cpu().numpy", "numpy.zeros", "numpy.sum", "torch.as_tensor().unsqueeze", "numpy.errstate", "simulation.entro_mat", "samples.t().cpu", "f1nonzero.any", "numpy.maximum", "torch.as_tensor", "numpy.polyval", "numpy.polyval", "numpy.polyval", "samples.t", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.nnet_estimator.__init__": [[451, 468], ["super().__init__", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.zeros", "torch.cat().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.cat", "torch.tensor", "torch.tensor", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.nnet_estimator.forward": [[468, 476], ["torch.cat", "torch.relu", "torch.cat", "torch.relu", "torch.cat", "simulation.nnet_estimator.output", "torch.cat", "simulation.nnet_estimator.hidden1", "simulation.nnet_estimator.hidden2", "est"], "methods", ["None"], ["c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.sufficient_statistic": [[27, 30], ["numpy.bincount"], "function", ["None"], ["\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.parameter_constraint_fun": [[394, 402], ["torch.empty", "enumerate", "torch.sum", "torch.cat", "len"], "function", ["None"], ["\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.parameter": [[403, 410], ["torch.empty", "enumerate", "torch.sum", "len"], "function", ["None"], ["    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n", "        ", "summand", "=", "-", "p", "*", "torch", ".", "log", "(", "p", ")", "\n", "output", "[", "i", ",", "0", "]", "=", "torch", ".", "sum", "(", "summand", "[", "p", "!=", "0", "]", ")", "\n", "", "return", "(", "output", ",", "torch", ".", "cat", "(", "(", "-", "(", "(", "output", ">=", "prior_credible_range", "[", "0", "]", ")", "&", "(", "output", "<=", "prior_credible_range", "[", "1", "]", ")", ")", ".", "type", "(", "default_dtype", ")", ",", "output", ",", "-", "output", ")", ",", "1", ")", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.Risk_fun": [[411, 413], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["", "def", "parameter", "(", "ps", ")", ":", "\n", "    ", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.entro_mat": [[422, 437], ["numpy.meshgrid", "numpy.minimum", "numpy.arange().reshape", "g_coeff.reshape", "numpy.maximum", "len", "numpy.maximum", "numpy.sum", "numpy.isnan", "numpy.isinf", "numpy.log", "numpy.arange", "numpy.log", "numpy.log", "numpy.concatenate().cumprod", "numpy.concatenate"], "function", ["None"], ["", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.OrlitskySureshWu_Estimator.__init__": [[416, 422], ["torch.as_tensor", "scipy.stats.binom.sf", "numpy.arange", "numpy.arange", "numpy.floor", "numpy.log", "numpy.log"], "methods", ["None"], ["", "return", "output", "\n", "\n", "", "def", "Risk_fun", "(", "estimates", ",", "true_parameters", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.OrlitskySureshWu_Estimator.__call__": [[422, 424], ["torch.sum().unsqueeze", "torch.sum", "simulation.OrlitskySureshWu_Estimator.weights.expand", "samples.size"], "methods", ["None"], ["", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.ShenChaoLin_Estimator.__init__": [[426, 432], ["ValueError"], "methods", ["None"], ["T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.2.simulation.ShenChaoLin_Estimator.__call__": [[432, 447], ["torch.sum", "torch.where", "torch.where", "torch.max", "torch.where", "torch.where", "torch.where.unsqueeze", "torch.zeros_like", "torch.isnan", "torch.isnan", "torch.ones_like", "torch.ones_like", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n", "\n", "\n", "\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.__init__": [[35, 73], ["simulation.Gamma_minimax_Problem.eval_parameter_constraint", "torch.sum().mean", "numpy.array", "numpy.concatenate", "numpy.ones", "simulation.Gamma_minimax_Problem.distrs.extend", "simulation.Gamma_minimax_Problem.generate_ps", "torch.zeros", "torch.as_tensor", "simulation.parameter_constraint_fun", "simulation.Gamma_minimax_Problem.generate_ps", "torch.sum", "numpy.array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.eval_parameter_constraint": [[74, 95], ["simulation.Gamma_minimax_Problem.parameter_constraint_fun", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun"], ["\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.enlarge_distr_grid": [[96, 104], ["simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.distrs.extend", "torch.cat", "simulation.Gamma_minimax_Problem.eval_parameter_constraint", "len", "simulation.Gamma_minimax_Problem.generate_ps", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.get_constraint_matrices": [[105, 117], ["simulation.Gamma_minimax_Problem.A_ubT.cpu().numpy().transpose", "simulation.Gamma_minimax_Problem.A_eqT.cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "simulation.Gamma_minimax_Problem.A_ubT.cpu().numpy", "simulation.Gamma_minimax_Problem.A_eqT.cpu().numpy", "numpy.ones", "simulation.Gamma_minimax_Problem.prior_prob.size", "simulation.Gamma_minimax_Problem.A_ubT.cpu", "simulation.Gamma_minimax_Problem.A_eqT.cpu", "simulation.Gamma_minimax_Problem.prior_prob.size"], "methods", ["None"], ["\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.draw_sample": [[118, 130], ["torch.empty", "enumerate", "torch.distributions.Multinomial().sample().type", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample", "torch.distributions.Multinomial", "p.cpu"], "methods", ["None"], ["\n", "", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.calc_Risks_tensor": [[131, 154], ["len", "torch.empty", "torch.empty", "enumerate", "estimator().view", "simulation.Gamma_minimax_Problem.Risk_fun", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample.type", "prob_occur_new_sample.unsqueeze().cpu", "estimator", "torch.distributions.Multinomial", "torch.empty.reshape", "p.cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff": [[155, 179], ["len", "torch.empty", "enumerate", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "estimator().view", "simulation.Gamma_minimax_Problem.Risk_fun", "len", "torch.distributions.Multinomial().sample.type", "true_prediction_mean.cuda.cuda.cuda", "torch.distributions.Multinomial", "torch.as_tensor", "torch.as_tensor", "estimator", "p.cpu", "torch.as_tensor().unsqueeze.reshape", "prob_occur_new_sample.unsqueeze().cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.log_pseudo_prior": [[180, 183], ["torch.tensor", "MCMC_normal_distribution.log_prob().item", "MCMC_negbinomial_distribution.log_prob().item", "MCMC_normal_distribution.log_prob", "MCMC_negbinomial_distribution.log_prob", "simulation.Gamma_minimax_Problem.parameter", "torch.tensor", "p.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.generate_ps": [[184, 259], ["simulation.Gamma_minimax_Problem.log_pseudo_prior", "max", "torch.distributions.dirichlet.Dirichlet().sample", "torch.distributions.dirichlet.Dirichlet().sample.size", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.poisson.Poisson", "torch.distributions.poisson.Poisson.sample", "torch.distributions.poisson.Poisson", "numpy.ceil", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.no_grad", "torch.exp", "torch.distributions.poisson.Poisson.sample", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "torch.cat", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "numpy.random.uniform", "torch.ones", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.cat", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.ones", "torch.distributions.dirichlet.Dirichlet.log_prob", "int", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.ones", "torch.no_grad", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "int", "torch.sum().unsqueeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.sum", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.log", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.log", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.SGDmax": [[260, 314], ["simulation.Gamma_minimax_Problem.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "simulation.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "simulation.Gamma_minimax_Problem.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "simulation.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "simulation.Gamma_minimax_Problem.estimator.parameters", "scipy.optimize.linprog", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "RuntimeError", "simulation.Gamma_minimax_Problem.dot.item", "simulation.Gamma_minimax_Problem.dot", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.dot", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Gamma_minimax_Problem.calc_Gamma_minimax_estimator": [[315, 381], ["simulation.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "range", "torch.optim.SGD", "simulation.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.clone", "simulation.Gamma_minimax_Problem.enlarge_distr_grid", "simulation.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.dot().item", "eval_Risks[].dot().item", "risk_iter.append", "simulation.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.dot", "eval_Risks[].dot", "numpy.array", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu", "str"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff"], ["nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.JVHW_estimator.__init__": [[440, 452], ["float", "min", "numpy.array", "numpy.array", "numpy.arange", "int", "scipy.loadmat", "numpy.ceil", "numpy.log"], "methods", ["None"], ["\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n", "if", "poly_entro", "is", "None", ":", "\n", "            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.JVHW_estimator.__call__": [[453, 477], ["samples.t().cpu().numpy", "numpy.zeros", "numpy.sum", "torch.as_tensor().unsqueeze", "numpy.errstate", "simulation.entro_mat", "samples.t().cpu", "f1nonzero.any", "numpy.maximum", "torch.as_tensor", "numpy.polyval", "numpy.polyval", "numpy.polyval", "samples.t", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat"], ["self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.nnet_estimator.__init__": [[449, 466], ["super().__init__", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.zeros", "torch.cat().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.cat", "torch.tensor", "torch.tensor", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.nnet_estimator.forward": [[466, 474], ["torch.cat", "torch.relu", "torch.cat", "torch.relu", "torch.cat", "simulation.nnet_estimator.output", "torch.cat", "simulation.nnet_estimator.hidden1", "simulation.nnet_estimator.hidden2", "est"], "methods", ["None"], ["                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.sufficient_statistic": [[27, 30], ["numpy.bincount"], "function", ["None"], ["\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.parameter_constraint_fun": [[392, 400], ["torch.empty", "enumerate", "torch.sum", "torch.cat", "len"], "function", ["None"], ["\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.parameter": [[401, 408], ["torch.empty", "enumerate", "torch.sum", "len"], "function", ["None"], ["\n", "", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n", "    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n", "        ", "summand", "=", "-", "p", "*", "torch", ".", "log", "(", "p", ")", "\n", "output", "[", "i", ",", "0", "]", "=", "torch", ".", "sum", "(", "summand", "[", "p", "!=", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.Risk_fun": [[409, 411], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["", "return", "(", "output", ",", "torch", ".", "cat", "(", "(", "-", "(", "(", "output", ">=", "prior_credible_range", "[", "0", "]", ")", "&", "(", "output", "<=", "prior_credible_range", "[", "1", "]", ")", ")", ".", "type", "(", "default_dtype", ")", ",", "output", ",", "-", "output", ")", ",", "1", ")", ",", "None", ")", "\n", "\n", "", "def", "parameter", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.entro_mat": [[420, 435], ["numpy.meshgrid", "numpy.minimum", "numpy.arange().reshape", "g_coeff.reshape", "numpy.maximum", "len", "numpy.maximum", "numpy.sum", "numpy.isnan", "numpy.isinf", "numpy.log", "numpy.arange", "numpy.log", "numpy.log", "numpy.concatenate().cumprod", "numpy.concatenate"], "function", ["None"], ["\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.OrlitskySureshWu_Estimator.__init__": [[414, 420], ["torch.as_tensor", "scipy.stats.binom.sf", "numpy.arange", "numpy.arange", "numpy.floor", "numpy.log", "numpy.log"], "methods", ["None"], ["        ", "summand", "=", "-", "p", "*", "torch", ".", "log", "(", "p", ")", "\n", "output", "[", "i", ",", "0", "]", "=", "torch", ".", "sum", "(", "summand", "[", "p", "!=", "0", "]", ")", "\n", "", "return", "output", "\n", "\n", "", "def", "Risk_fun", "(", "estimates", ",", "true_parameters", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.OrlitskySureshWu_Estimator.__call__": [[420, 422], ["torch.sum().unsqueeze", "torch.sum", "simulation.OrlitskySureshWu_Estimator.weights.expand", "samples.size"], "methods", ["None"], ["\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.ShenChaoLin_Estimator.__init__": [[424, 430], ["ValueError"], "methods", ["None"], ["    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.3.simulation.ShenChaoLin_Estimator.__call__": [[430, 445], ["torch.sum", "torch.where", "torch.where", "torch.max", "torch.where", "torch.where", "torch.where.unsqueeze", "torch.zeros_like", "torch.isnan", "torch.isnan", "torch.ones_like", "torch.ones_like", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n", "\n", "\n", "\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.__init__": [[35, 73], ["analysis.Gamma_minimax_Problem.eval_parameter_constraint", "torch.sum().mean", "numpy.array", "numpy.concatenate", "numpy.ones", "analysis.Gamma_minimax_Problem.distrs.extend", "analysis.Gamma_minimax_Problem.generate_ps", "torch.zeros", "torch.as_tensor", "analysis.parameter_constraint_fun", "analysis.Gamma_minimax_Problem.generate_ps", "torch.sum", "numpy.array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.eval_parameter_constraint": [[74, 95], ["analysis.Gamma_minimax_Problem.parameter_constraint_fun", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun"], ["", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.enlarge_distr_grid": [[96, 104], ["analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.distrs.extend", "torch.cat", "analysis.Gamma_minimax_Problem.eval_parameter_constraint", "len", "analysis.Gamma_minimax_Problem.generate_ps", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.get_constraint_matrices": [[105, 117], ["analysis.Gamma_minimax_Problem.A_ubT.cpu().numpy().transpose", "analysis.Gamma_minimax_Problem.A_eqT.cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "analysis.Gamma_minimax_Problem.A_ubT.cpu().numpy", "analysis.Gamma_minimax_Problem.A_eqT.cpu().numpy", "numpy.ones", "analysis.Gamma_minimax_Problem.prior_prob.size", "analysis.Gamma_minimax_Problem.A_ubT.cpu", "analysis.Gamma_minimax_Problem.A_eqT.cpu", "analysis.Gamma_minimax_Problem.prior_prob.size"], "methods", ["None"], ["", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.draw_sample": [[118, 130], ["torch.empty", "enumerate", "torch.distributions.Multinomial().sample().type", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample", "torch.distributions.Multinomial", "p.cpu"], "methods", ["None"], ["", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.calc_Risks_tensor": [[155, 178], ["len", "torch.empty", "torch.empty", "enumerate", "estimator().view", "analysis.Gamma_minimax_Problem.Risk_fun", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample.type", "prob_occur_new_sample.unsqueeze().cpu", "estimator", "torch.distributions.Multinomial", "torch.empty.reshape", "p.cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff": [[179, 203], ["len", "torch.empty", "enumerate", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "estimator().view", "analysis.Gamma_minimax_Problem.Risk_fun", "len", "torch.distributions.Multinomial().sample.type", "true_prediction_mean.cuda.cuda.cuda", "torch.distributions.Multinomial", "torch.as_tensor", "torch.as_tensor", "estimator", "p.cpu", "torch.as_tensor().unsqueeze.reshape", "prob_occur_new_sample.unsqueeze().cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.log_pseudo_prior": [[204, 207], ["torch.tensor", "MCMC_normal_distribution.log_prob().item", "MCMC_negbinomial_distribution.log_prob().item", "MCMC_normal_distribution.log_prob", "MCMC_negbinomial_distribution.log_prob", "analysis.Gamma_minimax_Problem.parameter", "torch.tensor", "p.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.generate_ps": [[208, 283], ["analysis.Gamma_minimax_Problem.log_pseudo_prior", "max", "torch.distributions.dirichlet.Dirichlet().sample", "torch.distributions.dirichlet.Dirichlet().sample.size", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.poisson.Poisson", "torch.distributions.poisson.Poisson.sample", "torch.distributions.poisson.Poisson", "numpy.ceil", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.no_grad", "torch.exp", "torch.distributions.poisson.Poisson.sample", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "torch.cat", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "numpy.random.uniform", "torch.ones", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.cat", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.ones", "torch.distributions.dirichlet.Dirichlet.log_prob", "int", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.ones", "torch.no_grad", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "int", "torch.sum().unsqueeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.sum", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.log", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.log", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "# scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lambda epoch: 1/(epoch+2))", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.SGDmax": [[284, 343], ["analysis.Gamma_minimax_Problem.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "analysis.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "analysis.Gamma_minimax_Problem.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "analysis.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "analysis.Gamma_minimax_Problem.estimator.parameters", "scipy.optimize.linprog", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "RuntimeError", "analysis.Gamma_minimax_Problem.dot.item", "analysis.Gamma_minimax_Problem.dot", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.dot", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "# torch.nn.utils.clip_grad_norm_(self.estimator.parameters(), 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "# scheduler.step()", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "# torch.nn.utils.clip_grad_norm_(self.estimator.parameters(), 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "# scheduler.step()", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Gamma_minimax_Problem.calc_Gamma_minimax_estimator": [[344, 410], ["analysis.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "range", "torch.optim.SGD", "analysis.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.clone", "analysis.Gamma_minimax_Problem.enlarge_distr_grid", "analysis.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.dot().item", "eval_Risks[].dot().item", "risk_iter.append", "analysis.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.dot", "eval_Risks[].dot", "numpy.array", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu", "str"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff"], ["\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "                ", "with", "open", "(", "\"l\"", "+", "str", "(", "l", "+", "1", ")", "+", "\".pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                    ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "", "return", "(", "1", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n", "    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.JVHW_estimator.__init__": [[446, 458], ["float", "min", "numpy.array", "numpy.array", "numpy.arange", "int", "scipy.loadmat", "numpy.ceil", "numpy.log"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n", "if", "poly_entro", "is", "None", ":", "\n", "            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.JVHW_estimator.__call__": [[459, 483], ["samples.t().cpu().numpy", "numpy.zeros", "numpy.sum", "torch.as_tensor().unsqueeze", "numpy.errstate", "analysis.entro_mat", "samples.t().cpu", "f1nonzero.any", "numpy.maximum", "torch.as_tensor", "numpy.polyval", "numpy.polyval", "numpy.polyval", "samples.t", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.nnet_estimator.__init__": [[478, 495], ["super().__init__", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.zeros", "torch.cat().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.cat", "torch.tensor", "torch.tensor", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "\n", "\n", "\n", "", "", "class", "nnet_estimator", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "naive_estimators", ",", "naive_estimators_scale", "=", "1.", ",", "init_output_params", "=", "\"naive mean\"", ")", ":", "\n", "        ", "'''naive_estimators_scale: initial estimates are multiplied by naive_estimators_scale before feeding to the neural net to stabilize gradients\n        init_output_params: initial parameters, vector of length >=2. First component is intercept; second component is slope of previous hidden layers; other components are the slope of naive estimators. default \"naive mean\" takes the mean of naive_estimators. Set to None to randomized initialization.'''", "\n", "global", "sample_size", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "naive_estimators", "=", "naive_estimators", "\n", "self", ".", "n_naive_estimators", "=", "len", "(", "naive_estimators", ")", "\n", "self", ".", "naive_estimators_scale", "=", "naive_estimators_scale", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.nnet_estimator.forward": [[495, 503], ["torch.cat", "torch.relu", "torch.cat", "torch.relu", "torch.cat", "analysis.nnet_estimator.output", "torch.cat", "analysis.nnet_estimator.hidden1", "analysis.nnet_estimator.hidden2", "est"], "methods", ["None"], ["self", ".", "naive_estimators_scale", "=", "naive_estimators_scale", "\n", "self", ".", "hidden1", "=", "torch", ".", "nn", ".", "Linear", "(", "sample_size", "+", "self", ".", "n_naive_estimators", ",", "50", ",", "bias", "=", "True", ")", "\n", "self", ".", "hidden2", "=", "torch", ".", "nn", ".", "Linear", "(", "50", "+", "self", ".", "n_naive_estimators", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "output", "=", "torch", ".", "nn", ".", "Linear", "(", "1", "+", "self", ".", "n_naive_estimators", ",", "1", ",", "bias", "=", "True", ")", "\n", "if", "init_output_params", "==", "\"naive mean\"", ":", "\n", "            ", "self", ".", "output", ".", "bias", ".", "data", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "self", ".", "output", ".", "weight", ".", "data", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros", "(", "1", ")", ",", "torch", ".", "ones", "(", "self", ".", "n_naive_estimators", ")", "/", "self", ".", "n_naive_estimators", "/", "self", ".", "naive_estimators_scale", ")", ")", ".", "unsqueeze", "(", "0", ")", "\n", "", "elif", "init_output_params", "is", "not", "None", ":", "\n", "            ", "self", ".", "output", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "init_output_params", "[", "0", "]", ")", ".", "unsqueeze", "(", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.sufficient_statistic": [[27, 30], ["numpy.bincount"], "function", ["None"], ["def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.parameter_constraint_fun": [[421, 429], ["torch.empty", "enumerate", "torch.sum", "torch.cat", "len"], "function", ["None"], ["\n", "", "def", "Risk_fun", "(", "estimates", ",", "true_parameters", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.parameter": [[430, 437], ["torch.empty", "enumerate", "torch.sum", "len"], "function", ["None"], ["T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.Risk_fun": [[438, 440], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.entro_mat": [[426, 441], ["numpy.meshgrid", "numpy.minimum", "numpy.arange().reshape", "g_coeff.reshape", "numpy.maximum", "len", "numpy.maximum", "numpy.sum", "numpy.isnan", "numpy.isinf", "numpy.log", "numpy.arange", "numpy.log", "numpy.log", "numpy.concatenate().cumprod", "numpy.concatenate"], "function", ["None"], ["", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.OrlitskySureshWu_Estimator.__init__": [[443, 449], ["torch.as_tensor", "scipy.stats.binom.sf", "numpy.arange", "numpy.arange", "numpy.floor", "numpy.log", "numpy.log"], "methods", ["None"], ["\n", "\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.OrlitskySureshWu_Estimator.__call__": [[449, 451], ["torch.sum().unsqueeze", "torch.sum", "analysis.OrlitskySureshWu_Estimator.weights.expand", "samples.size"], "methods", ["None"], ["self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.ShenChaoLin_Estimator.__init__": [[453, 459], ["ValueError"], "methods", ["None"], ["            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis1.analysis.ShenChaoLin_Estimator.__call__": [[459, 474], ["torch.sum", "torch.where", "torch.where", "torch.max", "torch.where", "torch.where", "torch.where.unsqueeze", "torch.zeros_like", "torch.isnan", "torch.isnan", "torch.ones_like", "torch.ones_like", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.__init__": [[35, 73], ["analysis.Gamma_minimax_Problem.eval_parameter_constraint", "torch.sum().mean", "numpy.array", "numpy.concatenate", "numpy.ones", "analysis.Gamma_minimax_Problem.distrs.extend", "analysis.Gamma_minimax_Problem.generate_ps", "torch.zeros", "torch.as_tensor", "analysis.parameter_constraint_fun", "analysis.Gamma_minimax_Problem.generate_ps", "torch.sum", "numpy.array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.eval_parameter_constraint": [[74, 95], ["analysis.Gamma_minimax_Problem.parameter_constraint_fun", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun"], ["", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.enlarge_distr_grid": [[96, 104], ["analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.distrs.extend", "torch.cat", "analysis.Gamma_minimax_Problem.eval_parameter_constraint", "len", "analysis.Gamma_minimax_Problem.generate_ps", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.get_constraint_matrices": [[105, 117], ["analysis.Gamma_minimax_Problem.A_ubT.cpu().numpy().transpose", "analysis.Gamma_minimax_Problem.A_eqT.cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "analysis.Gamma_minimax_Problem.A_ubT.cpu().numpy", "analysis.Gamma_minimax_Problem.A_eqT.cpu().numpy", "numpy.ones", "analysis.Gamma_minimax_Problem.prior_prob.size", "analysis.Gamma_minimax_Problem.A_ubT.cpu", "analysis.Gamma_minimax_Problem.A_eqT.cpu", "analysis.Gamma_minimax_Problem.prior_prob.size"], "methods", ["None"], ["", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.draw_sample": [[118, 130], ["torch.empty", "enumerate", "torch.distributions.Multinomial().sample().type", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample", "torch.distributions.Multinomial", "p.cpu"], "methods", ["None"], ["", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.calc_Risks_tensor": [[155, 178], ["len", "torch.empty", "torch.empty", "enumerate", "estimator().view", "analysis.Gamma_minimax_Problem.Risk_fun", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample.type", "prob_occur_new_sample.unsqueeze().cpu", "estimator", "torch.distributions.Multinomial", "torch.empty.reshape", "p.cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff": [[179, 203], ["len", "torch.empty", "enumerate", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "estimator().view", "analysis.Gamma_minimax_Problem.Risk_fun", "len", "torch.distributions.Multinomial().sample.type", "true_prediction_mean.cuda.cuda.cuda", "torch.distributions.Multinomial", "torch.as_tensor", "torch.as_tensor", "estimator", "p.cpu", "torch.as_tensor().unsqueeze.reshape", "prob_occur_new_sample.unsqueeze().cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.log_pseudo_prior": [[204, 207], ["torch.tensor", "MCMC_normal_distribution.log_prob().item", "MCMC_negbinomial_distribution.log_prob().item", "MCMC_normal_distribution.log_prob", "MCMC_negbinomial_distribution.log_prob", "analysis.Gamma_minimax_Problem.parameter", "torch.tensor", "p.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.generate_ps": [[208, 283], ["analysis.Gamma_minimax_Problem.log_pseudo_prior", "max", "torch.distributions.dirichlet.Dirichlet().sample", "torch.distributions.dirichlet.Dirichlet().sample.size", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.poisson.Poisson", "torch.distributions.poisson.Poisson.sample", "torch.distributions.poisson.Poisson", "numpy.ceil", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.no_grad", "torch.exp", "torch.distributions.poisson.Poisson.sample", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "torch.cat", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "numpy.random.uniform", "torch.ones", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.cat", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.ones", "torch.distributions.dirichlet.Dirichlet.log_prob", "int", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.ones", "torch.no_grad", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "int", "torch.sum().unsqueeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.sum", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.log", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.log", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "# scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lambda epoch: 1/(epoch+2))", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.SGDmax": [[284, 343], ["analysis.Gamma_minimax_Problem.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "analysis.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "analysis.Gamma_minimax_Problem.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "analysis.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "analysis.Gamma_minimax_Problem.estimator.parameters", "scipy.optimize.linprog", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "RuntimeError", "analysis.Gamma_minimax_Problem.dot.item", "analysis.Gamma_minimax_Problem.dot", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.dot", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "# torch.nn.utils.clip_grad_norm_(self.estimator.parameters(), 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "# scheduler.step()", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "# torch.nn.utils.clip_grad_norm_(self.estimator.parameters(), 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "# scheduler.step()", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Gamma_minimax_Problem.calc_Gamma_minimax_estimator": [[344, 410], ["analysis.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "range", "torch.optim.SGD", "analysis.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.clone", "analysis.Gamma_minimax_Problem.enlarge_distr_grid", "analysis.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.dot().item", "eval_Risks[].dot().item", "risk_iter.append", "analysis.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.dot", "eval_Risks[].dot", "numpy.array", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu", "str"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff"], ["\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "                ", "with", "open", "(", "\"l\"", "+", "str", "(", "l", "+", "1", ")", "+", "\".pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                    ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "", "return", "(", "1", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n", "    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.JVHW_estimator.__init__": [[446, 458], ["float", "min", "numpy.array", "numpy.array", "numpy.arange", "int", "scipy.loadmat", "numpy.ceil", "numpy.log"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n", "if", "poly_entro", "is", "None", ":", "\n", "            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.JVHW_estimator.__call__": [[459, 483], ["samples.t().cpu().numpy", "numpy.zeros", "numpy.sum", "torch.as_tensor().unsqueeze", "numpy.errstate", "analysis.entro_mat", "samples.t().cpu", "f1nonzero.any", "numpy.maximum", "torch.as_tensor", "numpy.polyval", "numpy.polyval", "numpy.polyval", "samples.t", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.nnet_estimator.__init__": [[478, 495], ["super().__init__", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.zeros", "torch.cat().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.cat", "torch.tensor", "torch.tensor", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "\n", "\n", "\n", "", "", "class", "nnet_estimator", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "naive_estimators", ",", "naive_estimators_scale", "=", "1.", ",", "init_output_params", "=", "\"naive mean\"", ")", ":", "\n", "        ", "'''naive_estimators_scale: initial estimates are multiplied by naive_estimators_scale before feeding to the neural net to stabilize gradients\n        init_output_params: initial parameters, vector of length >=2. First component is intercept; second component is slope of previous hidden layers; other components are the slope of naive estimators. default \"naive mean\" takes the mean of naive_estimators. Set to None to randomized initialization.'''", "\n", "global", "sample_size", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "naive_estimators", "=", "naive_estimators", "\n", "self", ".", "n_naive_estimators", "=", "len", "(", "naive_estimators", ")", "\n", "self", ".", "naive_estimators_scale", "=", "naive_estimators_scale", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.nnet_estimator.forward": [[495, 503], ["torch.cat", "torch.relu", "torch.cat", "torch.relu", "torch.cat", "analysis.nnet_estimator.output", "torch.cat", "analysis.nnet_estimator.hidden1", "analysis.nnet_estimator.hidden2", "est"], "methods", ["None"], ["self", ".", "naive_estimators_scale", "=", "naive_estimators_scale", "\n", "self", ".", "hidden1", "=", "torch", ".", "nn", ".", "Linear", "(", "sample_size", "+", "self", ".", "n_naive_estimators", ",", "50", ",", "bias", "=", "True", ")", "\n", "self", ".", "hidden2", "=", "torch", ".", "nn", ".", "Linear", "(", "50", "+", "self", ".", "n_naive_estimators", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "output", "=", "torch", ".", "nn", ".", "Linear", "(", "1", "+", "self", ".", "n_naive_estimators", ",", "1", ",", "bias", "=", "True", ")", "\n", "if", "init_output_params", "==", "\"naive mean\"", ":", "\n", "            ", "self", ".", "output", ".", "bias", ".", "data", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "self", ".", "output", ".", "weight", ".", "data", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros", "(", "1", ")", ",", "torch", ".", "ones", "(", "self", ".", "n_naive_estimators", ")", "/", "self", ".", "n_naive_estimators", "/", "self", ".", "naive_estimators_scale", ")", ")", ".", "unsqueeze", "(", "0", ")", "\n", "", "elif", "init_output_params", "is", "not", "None", ":", "\n", "            ", "self", ".", "output", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "init_output_params", "[", "0", "]", ")", ".", "unsqueeze", "(", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.sufficient_statistic": [[27, 30], ["numpy.bincount"], "function", ["None"], ["def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.parameter_constraint_fun": [[421, 429], ["torch.empty", "enumerate", "torch.sum", "torch.cat", "len"], "function", ["None"], ["\n", "", "def", "Risk_fun", "(", "estimates", ",", "true_parameters", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.parameter": [[430, 437], ["torch.empty", "enumerate", "torch.sum", "len"], "function", ["None"], ["T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.Risk_fun": [[438, 440], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.entro_mat": [[426, 441], ["numpy.meshgrid", "numpy.minimum", "numpy.arange().reshape", "g_coeff.reshape", "numpy.maximum", "len", "numpy.maximum", "numpy.sum", "numpy.isnan", "numpy.isinf", "numpy.log", "numpy.arange", "numpy.log", "numpy.log", "numpy.concatenate().cumprod", "numpy.concatenate"], "function", ["None"], ["", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.OrlitskySureshWu_Estimator.__init__": [[443, 449], ["torch.as_tensor", "scipy.stats.binom.sf", "numpy.arange", "numpy.arange", "numpy.floor", "numpy.log", "numpy.log"], "methods", ["None"], ["\n", "\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.OrlitskySureshWu_Estimator.__call__": [[449, 451], ["torch.sum().unsqueeze", "torch.sum", "analysis.OrlitskySureshWu_Estimator.weights.expand", "samples.size"], "methods", ["None"], ["self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.ShenChaoLin_Estimator.__init__": [[453, 459], ["ValueError"], "methods", ["None"], ["            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis2.analysis.ShenChaoLin_Estimator.__call__": [[459, 474], ["torch.sum", "torch.where", "torch.where", "torch.max", "torch.where", "torch.where", "torch.where.unsqueeze", "torch.zeros_like", "torch.isnan", "torch.isnan", "torch.ones_like", "torch.ones_like", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.__init__": [[35, 73], ["analysis.Gamma_minimax_Problem.eval_parameter_constraint", "torch.sum().mean", "numpy.array", "numpy.concatenate", "numpy.ones", "analysis.Gamma_minimax_Problem.distrs.extend", "analysis.Gamma_minimax_Problem.generate_ps", "torch.zeros", "torch.as_tensor", "analysis.parameter_constraint_fun", "analysis.Gamma_minimax_Problem.generate_ps", "torch.sum", "numpy.array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.eval_parameter_constraint": [[74, 95], ["analysis.Gamma_minimax_Problem.parameter_constraint_fun", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun"], ["", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.enlarge_distr_grid": [[96, 104], ["analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.distrs.extend", "torch.cat", "analysis.Gamma_minimax_Problem.eval_parameter_constraint", "len", "analysis.Gamma_minimax_Problem.generate_ps", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.get_constraint_matrices": [[105, 117], ["analysis.Gamma_minimax_Problem.A_ubT.cpu().numpy().transpose", "analysis.Gamma_minimax_Problem.A_eqT.cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "analysis.Gamma_minimax_Problem.A_ubT.cpu().numpy", "analysis.Gamma_minimax_Problem.A_eqT.cpu().numpy", "numpy.ones", "analysis.Gamma_minimax_Problem.prior_prob.size", "analysis.Gamma_minimax_Problem.A_ubT.cpu", "analysis.Gamma_minimax_Problem.A_eqT.cpu", "analysis.Gamma_minimax_Problem.prior_prob.size"], "methods", ["None"], ["", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.draw_sample": [[118, 130], ["torch.empty", "enumerate", "torch.distributions.Multinomial().sample().type", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample", "torch.distributions.Multinomial", "p.cpu"], "methods", ["None"], ["", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.calc_Risks_tensor": [[155, 178], ["len", "torch.empty", "torch.empty", "enumerate", "estimator().view", "analysis.Gamma_minimax_Problem.Risk_fun", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample.type", "prob_occur_new_sample.unsqueeze().cpu", "estimator", "torch.distributions.Multinomial", "torch.empty.reshape", "p.cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff": [[179, 203], ["len", "torch.empty", "enumerate", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "estimator().view", "analysis.Gamma_minimax_Problem.Risk_fun", "len", "torch.distributions.Multinomial().sample.type", "true_prediction_mean.cuda.cuda.cuda", "torch.distributions.Multinomial", "torch.as_tensor", "torch.as_tensor", "estimator", "p.cpu", "torch.as_tensor().unsqueeze.reshape", "prob_occur_new_sample.unsqueeze().cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.log_pseudo_prior": [[204, 207], ["torch.tensor", "MCMC_normal_distribution.log_prob().item", "MCMC_negbinomial_distribution.log_prob().item", "MCMC_normal_distribution.log_prob", "MCMC_negbinomial_distribution.log_prob", "analysis.Gamma_minimax_Problem.parameter", "torch.tensor", "p.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.generate_ps": [[208, 283], ["analysis.Gamma_minimax_Problem.log_pseudo_prior", "max", "torch.distributions.dirichlet.Dirichlet().sample", "torch.distributions.dirichlet.Dirichlet().sample.size", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.poisson.Poisson", "torch.distributions.poisson.Poisson.sample", "torch.distributions.poisson.Poisson", "numpy.ceil", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.no_grad", "torch.exp", "torch.distributions.poisson.Poisson.sample", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "torch.cat", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "numpy.random.uniform", "torch.ones", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.cat", "analysis.Gamma_minimax_Problem.log_pseudo_prior", "torch.ones", "torch.distributions.dirichlet.Dirichlet.log_prob", "int", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.ones", "torch.no_grad", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "int", "torch.sum().unsqueeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.sum", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.log", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.log", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "# scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lambda epoch: 1/(epoch+2))", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.SGDmax": [[284, 343], ["analysis.Gamma_minimax_Problem.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "analysis.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "analysis.Gamma_minimax_Problem.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "analysis.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "analysis.Gamma_minimax_Problem.estimator.parameters", "scipy.optimize.linprog", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor", "analysis.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "RuntimeError", "analysis.Gamma_minimax_Problem.dot.item", "analysis.Gamma_minimax_Problem.dot", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.nonzero", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.dot", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "# torch.nn.utils.clip_grad_norm_(self.estimator.parameters(), 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "# scheduler.step()", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "# torch.nn.utils.clip_grad_norm_(self.estimator.parameters(), 1)", "\n", "optimizer", ".", "step", "(", ")", "\n", "# scheduler.step()", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Gamma_minimax_Problem.calc_Gamma_minimax_estimator": [[344, 410], ["analysis.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "range", "torch.optim.SGD", "analysis.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.prior_prob.clone", "analysis.Gamma_minimax_Problem.enlarge_distr_grid", "analysis.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "analysis.Gamma_minimax_Problem.dot().item", "eval_Risks[].dot().item", "risk_iter.append", "analysis.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "analysis.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.prior_prob.cpu().numpy", "analysis.Gamma_minimax_Problem.dot", "eval_Risks[].dot", "numpy.array", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu().numpy", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.prior_prob.cpu", "analysis.Gamma_minimax_Problem.cpu", "analysis.Gamma_minimax_Problem.cpu", "str"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff"], ["\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "                ", "with", "open", "(", "\"l\"", "+", "str", "(", "l", "+", "1", ")", "+", "\".pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                    ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "", "return", "(", "1", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n", "    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.JVHW_estimator.__init__": [[446, 458], ["float", "min", "numpy.array", "numpy.array", "numpy.arange", "int", "scipy.loadmat", "numpy.ceil", "numpy.log"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n", "if", "poly_entro", "is", "None", ":", "\n", "            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.JVHW_estimator.__call__": [[459, 483], ["samples.t().cpu().numpy", "numpy.zeros", "numpy.sum", "torch.as_tensor().unsqueeze", "numpy.errstate", "analysis.entro_mat", "samples.t().cpu", "f1nonzero.any", "numpy.maximum", "torch.as_tensor", "numpy.polyval", "numpy.polyval", "numpy.polyval", "samples.t", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.nnet_estimator.__init__": [[478, 495], ["super().__init__", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.zeros", "torch.cat().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.cat", "torch.tensor", "torch.tensor", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n", "return", "torch", ".", "as_tensor", "(", "output", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "\n", "\n", "\n", "", "", "class", "nnet_estimator", "(", "torch", ".", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "naive_estimators", ",", "naive_estimators_scale", "=", "1.", ",", "init_output_params", "=", "\"naive mean\"", ")", ":", "\n", "        ", "'''naive_estimators_scale: initial estimates are multiplied by naive_estimators_scale before feeding to the neural net to stabilize gradients\n        init_output_params: initial parameters, vector of length >=2. First component is intercept; second component is slope of previous hidden layers; other components are the slope of naive estimators. default \"naive mean\" takes the mean of naive_estimators. Set to None to randomized initialization.'''", "\n", "global", "sample_size", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "naive_estimators", "=", "naive_estimators", "\n", "self", ".", "n_naive_estimators", "=", "len", "(", "naive_estimators", ")", "\n", "self", ".", "naive_estimators_scale", "=", "naive_estimators_scale", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.nnet_estimator.forward": [[495, 503], ["torch.cat", "torch.relu", "torch.cat", "torch.relu", "torch.cat", "analysis.nnet_estimator.output", "torch.cat", "analysis.nnet_estimator.hidden1", "analysis.nnet_estimator.hidden2", "est"], "methods", ["None"], ["self", ".", "naive_estimators_scale", "=", "naive_estimators_scale", "\n", "self", ".", "hidden1", "=", "torch", ".", "nn", ".", "Linear", "(", "sample_size", "+", "self", ".", "n_naive_estimators", ",", "50", ",", "bias", "=", "True", ")", "\n", "self", ".", "hidden2", "=", "torch", ".", "nn", ".", "Linear", "(", "50", "+", "self", ".", "n_naive_estimators", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "output", "=", "torch", ".", "nn", ".", "Linear", "(", "1", "+", "self", ".", "n_naive_estimators", ",", "1", ",", "bias", "=", "True", ")", "\n", "if", "init_output_params", "==", "\"naive mean\"", ":", "\n", "            ", "self", ".", "output", ".", "bias", ".", "data", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "self", ".", "output", ".", "weight", ".", "data", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros", "(", "1", ")", ",", "torch", ".", "ones", "(", "self", ".", "n_naive_estimators", ")", "/", "self", ".", "n_naive_estimators", "/", "self", ".", "naive_estimators_scale", ")", ")", ".", "unsqueeze", "(", "0", ")", "\n", "", "elif", "init_output_params", "is", "not", "None", ":", "\n", "            ", "self", ".", "output", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "init_output_params", "[", "0", "]", ")", ".", "unsqueeze", "(", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.sufficient_statistic": [[27, 30], ["numpy.bincount"], "function", ["None"], ["def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.parameter_constraint_fun": [[421, 429], ["torch.empty", "enumerate", "torch.sum", "torch.cat", "len"], "function", ["None"], ["\n", "", "def", "Risk_fun", "(", "estimates", ",", "true_parameters", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.parameter": [[430, 437], ["torch.empty", "enumerate", "torch.sum", "len"], "function", ["None"], ["T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.Risk_fun": [[438, 440], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.entro_mat": [[426, 441], ["numpy.meshgrid", "numpy.minimum", "numpy.arange().reshape", "g_coeff.reshape", "numpy.maximum", "len", "numpy.maximum", "numpy.sum", "numpy.isnan", "numpy.isinf", "numpy.log", "numpy.arange", "numpy.log", "numpy.log", "numpy.concatenate().cumprod", "numpy.concatenate"], "function", ["None"], ["", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.OrlitskySureshWu_Estimator.__init__": [[443, 449], ["torch.as_tensor", "scipy.stats.binom.sf", "numpy.arange", "numpy.arange", "numpy.floor", "numpy.log", "numpy.log"], "methods", ["None"], ["\n", "\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.OrlitskySureshWu_Estimator.__call__": [[449, 451], ["torch.sum().unsqueeze", "torch.sum", "analysis.OrlitskySureshWu_Estimator.weights.expand", "samples.size"], "methods", ["None"], ["self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.ShenChaoLin_Estimator.__init__": [[453, 459], ["ValueError"], "methods", ["None"], ["            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.analysis3.analysis.ShenChaoLin_Estimator.__call__": [[459, 474], ["torch.sum", "torch.where", "torch.where", "torch.max", "torch.where", "torch.where", "torch.where.unsqueeze", "torch.zeros_like", "torch.isnan", "torch.isnan", "torch.ones_like", "torch.ones_like", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.__init__": [[35, 73], ["simulation.Gamma_minimax_Problem.eval_parameter_constraint", "torch.sum().mean", "numpy.array", "numpy.concatenate", "numpy.ones", "simulation.Gamma_minimax_Problem.distrs.extend", "simulation.Gamma_minimax_Problem.generate_ps", "torch.zeros", "torch.as_tensor", "simulation.parameter_constraint_fun", "simulation.Gamma_minimax_Problem.generate_ps", "torch.sum", "numpy.array", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.eval_parameter_constraint": [[74, 95], ["simulation.Gamma_minimax_Problem.parameter_constraint_fun", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun"], ["\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.enlarge_distr_grid": [[96, 104], ["simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.distrs.extend", "torch.cat", "simulation.Gamma_minimax_Problem.eval_parameter_constraint", "len", "simulation.Gamma_minimax_Problem.generate_ps", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps"], ["\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.get_constraint_matrices": [[105, 117], ["simulation.Gamma_minimax_Problem.A_ubT.cpu().numpy().transpose", "simulation.Gamma_minimax_Problem.A_eqT.cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "simulation.Gamma_minimax_Problem.A_ubT.cpu().numpy", "simulation.Gamma_minimax_Problem.A_eqT.cpu().numpy", "numpy.ones", "simulation.Gamma_minimax_Problem.prior_prob.size", "simulation.Gamma_minimax_Problem.A_ubT.cpu", "simulation.Gamma_minimax_Problem.A_eqT.cpu", "simulation.Gamma_minimax_Problem.prior_prob.size"], "methods", ["None"], ["\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.draw_sample": [[118, 130], ["torch.empty", "enumerate", "torch.distributions.Multinomial().sample().type", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample", "torch.distributions.Multinomial", "p.cpu"], "methods", ["None"], ["\n", "", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.calc_Risks_tensor": [[131, 154], ["len", "torch.empty", "torch.empty", "enumerate", "estimator().view", "simulation.Gamma_minimax_Problem.Risk_fun", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor", "len", "torch.distributions.Multinomial().sample.type", "prob_occur_new_sample.unsqueeze().cpu", "estimator", "torch.distributions.Multinomial", "torch.empty.reshape", "p.cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff": [[155, 179], ["len", "torch.empty", "enumerate", "range", "torch.distributions.Multinomial().sample", "numpy.apply_along_axis", "torch.as_tensor().unsqueeze", "torch.as_tensor().unsqueeze", "estimator().view", "simulation.Gamma_minimax_Problem.Risk_fun", "len", "torch.distributions.Multinomial().sample.type", "true_prediction_mean.cuda.cuda.cuda", "torch.distributions.Multinomial", "torch.as_tensor", "torch.as_tensor", "estimator", "p.cpu", "torch.as_tensor().unsqueeze.reshape", "prob_occur_new_sample.unsqueeze().cpu", "prob_occur_new_sample.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior": [[180, 183], ["torch.tensor", "MCMC_normal_distribution.log_prob().item", "MCMC_negbinomial_distribution.log_prob().item", "MCMC_normal_distribution.log_prob", "MCMC_negbinomial_distribution.log_prob", "simulation.Gamma_minimax_Problem.parameter", "torch.tensor", "p.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.generate_ps": [[184, 259], ["simulation.Gamma_minimax_Problem.log_pseudo_prior", "max", "torch.distributions.dirichlet.Dirichlet().sample", "torch.distributions.dirichlet.Dirichlet().sample.size", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.poisson.Poisson", "torch.distributions.poisson.Poisson.sample", "torch.distributions.poisson.Poisson", "numpy.ceil", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.no_grad", "torch.exp", "torch.distributions.poisson.Poisson.sample", "torch.distributions.dirichlet.Dirichlet", "torch.distributions.dirichlet.Dirichlet.sample", "torch.cat", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.distributions.dirichlet.Dirichlet", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "numpy.random.uniform", "torch.ones", "torch.no_grad", "torch.distributions.dirichlet.Dirichlet", "torch.cat", "simulation.Gamma_minimax_Problem.log_pseudo_prior", "torch.ones", "torch.distributions.dirichlet.Dirichlet.log_prob", "int", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.ones", "torch.no_grad", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "int", "torch.sum().unsqueeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "torch.exp", "numpy.random.uniform", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "int", "torch.sum", "torch.exp", "torch.distributions.poisson.Poisson.log_prob", "torch.tensor", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.log", "int", "torch.distributions.dirichlet.Dirichlet.log_prob", "torch.log", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.distributions.poisson.Poisson.log_prob", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.log_pseudo_prior", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.SGDmax": [[260, 314], ["simulation.Gamma_minimax_Problem.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "simulation.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "simulation.Gamma_minimax_Problem.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.nonzero().squeeze", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "simulation.Gamma_minimax_Problem.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "simulation.Gamma_minimax_Problem.estimator.parameters", "scipy.optimize.linprog", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor", "simulation.Gamma_minimax_Problem.dot().item", "scipy.optimize.linprog", "RuntimeError", "simulation.Gamma_minimax_Problem.dot.item", "simulation.Gamma_minimax_Problem.dot", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.nonzero", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.dot", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Gamma_minimax_Problem.calc_Gamma_minimax_estimator": [[315, 381], ["simulation.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "range", "torch.optim.SGD", "simulation.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.prior_prob.clone", "simulation.Gamma_minimax_Problem.enlarge_distr_grid", "simulation.Gamma_minimax_Problem.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "simulation.Gamma_minimax_Problem.dot().item", "eval_Risks[].dot().item", "risk_iter.append", "simulation.Gamma_minimax_Problem.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "RuntimeError", "torch.no_grad", "simulation.Gamma_minimax_Problem.calc_Risks_tensor_memeff", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.prior_prob.cpu().numpy", "simulation.Gamma_minimax_Problem.dot", "eval_Risks[].dot", "numpy.array", "open", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu().numpy", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.prior_prob.cpu", "simulation.Gamma_minimax_Problem.cpu", "simulation.Gamma_minimax_Problem.cpu", "str"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff"], ["nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n", "for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.JVHW_estimator.__init__": [[440, 452], ["float", "min", "numpy.array", "numpy.array", "numpy.arange", "int", "scipy.loadmat", "numpy.ceil", "numpy.log"], "methods", ["None"], ["\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n", "self", ".", "n_greater_than_order", "=", "self", ".", "n", ">=", "self", ".", "order", "\n", "\n", "if", "poly_entro", "is", "None", ":", "\n", "            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.JVHW_estimator.__call__": [[453, 477], ["samples.t().cpu().numpy", "numpy.zeros", "numpy.sum", "torch.as_tensor().unsqueeze", "numpy.errstate", "simulation.entro_mat", "samples.t().cpu", "f1nonzero.any", "numpy.maximum", "torch.as_tensor", "numpy.polyval", "numpy.polyval", "numpy.polyval", "samples.t", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat"], ["self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n", "\n", "# output = np.sum(f * prob_mat, axis=0) / np.log(2)", "\n", "", "output", "=", "np", ".", "sum", "(", "f", "*", "prob_mat", ",", "axis", "=", "0", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.nnet_estimator.__init__": [[449, 466], ["super().__init__", "len", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.zeros", "torch.cat().unsqueeze", "torch.tensor().unsqueeze", "torch.tensor().unsqueeze", "torch.cat", "torch.tensor", "torch.tensor", "torch.zeros", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["            ", "poly_entro", "=", "sio", ".", "loadmat", "(", "'poly_coeff_entro.mat'", ")", "[", "'poly_entro'", "]", "\n", "", "self", ".", "coeff", "=", "poly_entro", "[", "self", ".", "order", "-", "1", ",", "0", "]", "[", "0", "]", "\n", "self", ".", "prob", "=", "np", ".", "arange", "(", "1", ",", "sample_size", "+", "1", ")", "/", "sample_size", "\n", "self", ".", "V1", "=", "np", ".", "array", "(", "[", "0.3303", ",", "0.4679", "]", ")", "\n", "self", ".", "V2", "=", "np", ".", "array", "(", "[", "-", "0.530556484842359", ",", "1.09787328176926", ",", "0.184831781602259", "]", ")", "\n", "\n", "", "def", "__call__", "(", "self", ",", "samples", ")", ":", "\n", "        ", "f", "=", "samples", ".", "t", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "wid", "=", "f", ".", "shape", "[", "1", "]", "\n", "f1nonzero", "=", "f", "[", "0", "]", ">", "0", "\n", "c_1", "=", "np", ".", "zeros", "(", "wid", ")", "\n", "\n", "with", "np", ".", "errstate", "(", "divide", "=", "'ignore'", ",", "invalid", "=", "'ignore'", ")", ":", "\n", "            ", "if", "self", ".", "n_greater_than_order", "and", "f1nonzero", ".", "any", "(", ")", ":", "\n", "                ", "if", "self", ".", "n", "<", "200", ":", "\n", "                    ", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "f1nonzero", "]", ")", ")", "\n", "", "else", ":", "\n", "                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.nnet_estimator.forward": [[466, 474], ["torch.cat", "torch.relu", "torch.cat", "torch.relu", "torch.cat", "simulation.nnet_estimator.output", "torch.cat", "simulation.nnet_estimator.hidden1", "simulation.nnet_estimator.hidden2", "est"], "methods", ["None"], ["                    ", "n2f1_small", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", "<=", "1.5", ")", "\n", "n2f1_large", "=", "f1nonzero", "&", "(", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", "]", ")", ">", "1.5", ")", "\n", "c_1", "[", "n2f1_small", "]", "=", "np", ".", "polyval", "(", "self", ".", "V2", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_small", "]", ")", ")", "\n", "c_1", "[", "n2f1_large", "]", "=", "np", ".", "polyval", "(", "self", ".", "V1", ",", "np", ".", "log", "(", "self", ".", "n", "/", "f", "[", "0", ",", "n2f1_large", "]", ")", ")", "\n", "\n", "# make sure nonzero threshold is higher than 1/n", "\n", "", "c_1", "[", "f1nonzero", "]", "=", "np", ".", "maximum", "(", "c_1", "[", "f1nonzero", "]", ",", "1", "/", "(", "1.9", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", "\n", "\n", "", "prob_mat", "=", "entro_mat", "(", "self", ".", "prob", ",", "self", ".", "n", ",", "self", ".", "coeff", ",", "c_1", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.sufficient_statistic": [[27, 30], ["numpy.bincount"], "function", ["None"], ["\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter_constraint_fun": [[392, 400], ["torch.empty", "enumerate", "torch.sum", "torch.cat", "len"], "function", ["None"], ["\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.parameter": [[401, 408], ["torch.empty", "enumerate", "torch.sum", "len"], "function", ["None"], ["\n", "", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n", "    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n", "        ", "summand", "=", "-", "p", "*", "torch", ".", "log", "(", "p", ")", "\n", "output", "[", "i", ",", "0", "]", "=", "torch", ".", "sum", "(", "summand", "[", "p", "!=", "0", "]", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.Risk_fun": [[409, 411], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["", "return", "(", "output", ",", "torch", ".", "cat", "(", "(", "-", "(", "(", "output", ">=", "prior_credible_range", "[", "0", "]", ")", "&", "(", "output", "<=", "prior_credible_range", "[", "1", "]", ")", ")", ".", "type", "(", "default_dtype", ")", ",", "output", ",", "-", "output", ")", ",", "1", ")", ",", "None", ")", "\n", "\n", "", "def", "parameter", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.entro_mat": [[420, 435], ["numpy.meshgrid", "numpy.minimum", "numpy.arange().reshape", "g_coeff.reshape", "numpy.maximum", "len", "numpy.maximum", "numpy.sum", "numpy.isnan", "numpy.isinf", "numpy.log", "numpy.arange", "numpy.log", "numpy.log", "numpy.concatenate().cumprod", "numpy.concatenate"], "function", ["None"], ["\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n", "# g_coeff = {g0, g1, g2, ..., g_K}, K: the order of best polynomial approximation,", "\n", "    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.OrlitskySureshWu_Estimator.__init__": [[414, 420], ["torch.as_tensor", "scipy.stats.binom.sf", "numpy.arange", "numpy.arange", "numpy.floor", "numpy.log", "numpy.log"], "methods", ["None"], ["        ", "summand", "=", "-", "p", "*", "torch", ".", "log", "(", "p", ")", "\n", "output", "[", "i", ",", "0", "]", "=", "torch", ".", "sum", "(", "summand", "[", "p", "!=", "0", "]", ")", "\n", "", "return", "output", "\n", "\n", "", "def", "Risk_fun", "(", "estimates", ",", "true_parameters", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.OrlitskySureshWu_Estimator.__call__": [[420, 422], ["torch.sum().unsqueeze", "torch.sum", "simulation.OrlitskySureshWu_Estimator.weights.expand", "samples.size"], "methods", ["None"], ["\n", "\n", "", "def", "entro_mat", "(", "x", ",", "n", ",", "g_coeff", ",", "c_1", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.ShenChaoLin_Estimator.__init__": [[424, 430], ["ValueError"], "methods", ["None"], ["    ", "K", "=", "len", "(", "g_coeff", ")", "-", "1", "\n", "thres", "=", "4", "*", "c_1", "*", "np", ".", "log", "(", "n", ")", "/", "n", "\n", "T", ",", "X", "=", "np", ".", "meshgrid", "(", "thres", ",", "x", ")", "\n", "ratio", "=", "np", ".", "minimum", "(", "np", ".", "maximum", "(", "2", "*", "X", "/", "T", "-", "1", ",", "0", ")", ",", "1", ")", "\n", "q", "=", "np", ".", "arange", "(", "K", ")", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", ")", ")", "\n", "g", "=", "g_coeff", ".", "reshape", "(", "(", "1", ",", "1", ",", "K", "+", "1", ")", ")", "\n", "MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.1.simulation.ShenChaoLin_Estimator.__call__": [[430, 445], ["torch.sum", "torch.where", "torch.where", "torch.max", "torch.where", "torch.where", "torch.where.unsqueeze", "torch.zeros_like", "torch.isnan", "torch.isnan", "torch.ones_like", "torch.ones_like", "torch.arange().unsqueeze", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["MLE", "=", "-", "X", "*", "np", ".", "log", "(", "X", ")", "+", "1", "/", "(", "2", "*", "n", ")", "\n", "polyApp", "=", "np", ".", "sum", "(", "np", ".", "concatenate", "(", "(", "T", "[", "...", ",", "None", "]", ",", "(", "(", "n", "*", "X", ")", "[", "...", ",", "None", "]", "-", "q", ")", "/", "(", "\n", "T", "[", "...", ",", "None", "]", "*", "(", "n", "-", "q", ")", ")", ")", ",", "axis", "=", "2", ")", ".", "cumprod", "(", "axis", "=", "2", ")", "*", "g", ",", "axis", "=", "2", ")", "-", "X", "*", "np", ".", "log", "(", "T", ")", "\n", "polyfail", "=", "np", ".", "isnan", "(", "polyApp", ")", "|", "np", ".", "isinf", "(", "polyApp", ")", "\n", "polyApp", "[", "polyfail", "]", "=", "MLE", "[", "polyfail", "]", "\n", "output", "=", "ratio", "*", "MLE", "+", "(", "1", "-", "ratio", ")", "*", "polyApp", "\n", "return", "np", ".", "maximum", "(", "output", ",", "0", ")", "\n", "\n", "\n", "\n", "\n", "", "class", "JVHW_estimator", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "poly_entro", "=", "None", ")", ":", "\n", "        ", "global", "sample_size", "\n", "self", ".", "n", "=", "float", "(", "sample_size", ")", "\n", "self", ".", "order", "=", "min", "(", "4", "+", "int", "(", "np", ".", "ceil", "(", "1.2", "*", "np", ".", "log", "(", "self", ".", "n", ")", ")", ")", ",", "22", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.__init__": [[33, 47], ["simulation.init_generate_distr", "torch.arange", "simulation.Distrs.distributions.size", "support.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.init_generate_distr"], ["", "class", "Gamma_minimax_Problem", "(", "object", ")", ":", "\n", "    ", "'''holds the estimator, an array of distributions and their prior probs, their true parameters and the summaries of distributions appearing in the constraints.'''", "\n", "\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.generate_distr": [[48, 55], ["torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.cat", "len", "torch.distributions.dirichlet.Dirichlet"], "methods", ["None"], ["            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.draw_sample": [[56, 61], ["torch.empty", "enumerate", "simulation.Distrs.support[].reshape", "torch.distributions.categorical.Categorical().sample", "torch.distributions.categorical.Categorical"], "methods", ["None"], ["self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.eval_parameter_constraint": [[62, 80], ["simulation.parameter", "simulation.ub_constraint_fun", "eq_constraint_fun"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.add_parameter_constraint": [[81, 99], ["torch.cat", "simulation.parameter", "torch.cat", "torch.cat", "eq_constraint_fun", "simulation.ub_constraint_fun"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.eval_Risks": [[100, 115], ["simulation.Distrs.draw_sample", "simulation.Distrs.true_parameters.unsqueeze().expand", "estimator().view", "simulation.Risk_fun", "torch.sum().mean", "AttributeError", "simulation.Distrs.true_parameters.unsqueeze", "estimator", "torch.sum", "simulation.Distrs.samples.reshape"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.draw_sample", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Distrs.eval_Risks_memeff": [[116, 127], ["torch.empty", "enumerate", "torch.sum().mean", "AttributeError", "simulation.Distrs.support[].reshape", "estimator", "simulation.Risk_fun", "estimator.unsqueeze", "torch.sum", "torch.distributions.categorical.Categorical().sample", "torch.distributions.categorical.Categorical"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n", "\n", "", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Prior_Risk_Constraint.__init__": [[132, 159], ["numpy.array", "torch.tensor", "torch.tensor", "simulation.Prior_Risk_Constraint.distrs[].eval_parameter_constraint", "torch.sum().mean", "simulation.Distrs", "torch.zeros", "torch.as_tensor", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint"], ["sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Prior_Risk_Constraint.enlarge_distr_grid": [[160, 183], ["enumerate", "torch.cat", "torch.arange", "simulation.Distrs", "simulation.Distrs.eval_parameter_constraint", "numpy.concatenate", "torch.cat", "new_prior_list.append", "torch.cat", "torch.cat", "new_prior_list.extend", "distr.generate_distr", "distr.add_parameter_constraint", "len", "len", "torch.zeros", "torch.distributions.uniform.Uniform().sample", "numpy.array", "torch.tensor", "torch.tensor", "torch.cumsum", "torch.zeros", "torch.distributions.uniform.Uniform"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.generate_distr", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.add_parameter_constraint"], ["", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Prior_Risk_Constraint.get_constraint_matrices": [[184, 202], ["np_A_ub.append", "numpy.ones.append", "torch.cat().cpu().numpy().transpose", "torch.cat().cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "numpy.ones", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat().cpu", "torch.cat().cpu", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat", "torch.cat"], "methods", ["None"], ["sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Prior_Risk_Constraint.calc_Risks_tensor": [[203, 210], ["torch.cat", "distr.eval_Risks", "Risks.append"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks"], ["", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff": [[211, 218], ["torch.cat", "distr.eval_Risks_memeff", "Risks.append"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks_memeff"], ["#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.nnet_estimator.__init__": [[357, 376], ["numpy.array", "super().__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.as_tensor", "torch.as_tensor"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.nnet_estimator.forward": [[376, 388], ["simulation.sample_mean", "simulation.nnet_estimator.activation", "simulation.nnet_estimator.activation", "simulation.nnet_estimator.reshape().mean", "torch.cat", "simulation.nnet_estimator.activation", "torch.cat", "simulation.nnet_estimator.activation", "torch.cat", "simulation.nnet_estimator.output", "input.size", "simulation.nnet_estimator.transform_hidden", "simulation.nnet_estimator.transform_output", "simulation.nnet_estimator.aggregate_hidden", "simulation.nnet_estimator.aggregate_output", "input.reshape", "simulation.nnet_estimator.reshape"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.sample_mean"], ["old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n", "if", "new_risk", "-", "old_risk", "<=", "tol", "or", "(", "new_risk", "-", "old_risk", ")", "/", "new_risk", "<=", "relative_tol", ":", "\n", "                ", "return", "(", "0", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "                ", "with", "open", "(", "\"l\"", "+", "str", "(", "l", "+", "1", ")", "+", "\".pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                    ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Linear_mean_estimator.__init__": [[391, 398], ["numpy.array", "super().__init__", "torch.nn.Linear", "simulation.Linear_mean_estimator.output_linear.bias.data.fill_", "simulation.Linear_mean_estimator.output_linear.weight.data.fill_"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Linear_mean_estimator.forward": [[398, 400], ["simulation.Linear_mean_estimator.output_linear", "simulation.sample_mean"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.sample_mean"], ["\n", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.init_generate_distr": [[16, 30], ["torch.empty", "enumerate", "torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.arange", "len", "len", "len", "torch.distributions.dirichlet.Dirichlet", "len", "len", "len"], "function", ["None"], ["default_dtype", "=", "torch", ".", "double", "\n", "use_cuda", "=", "False", "\n", "if", "use_cuda", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "cuda", ".", "DoubleTensor", ")", "\n", "", "else", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "DoubleTensor", ")", "\n", "\n", "\n", "", "sample_size", "=", "100", "\n", "\n", "# functions and classes for estimators and Gamma-minimax estimators", "\n", "\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.SGDmax": [[223, 274], ["Prior_Risk_Constraint_object.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "Risks.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "Risks.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "Risks.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "estimator.parameters", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "Risks.dot.item", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.calc_Gamma_minimax_estimator": [[277, 344], ["simulation.SGDmax", "risk_lower.append", "risk_upper.append", "range", "numpy.concatenate", "numpy.ones", "torch.optim.SGD", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.enlarge_distr_grid", "Prior_Risk_Constraint_object.prior_prob.clone", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_iter.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "simulation.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.ones", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "numpy.array", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "open", "pickle.dump", "pickle.dump", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "str", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax"], ["risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.sample_mean": [[352, 355], ["torch.mean().unsqueeze", "torch.mean"], "function", ["None"], ["linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.parameter": [[403, 406], ["distribution.mm", "support.unsqueeze"], "function", ["None"], ["    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.ub_constraint_fun": [[407, 410], ["simulation.parameter", "torch.cat"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["        ", "summand", "=", "-", "p", "*", "torch", ".", "log", "(", "p", ")", "\n", "output", "[", "i", ",", "0", "]", "=", "torch", ".", "sum", "(", "summand", "[", "p", "!=", "0", "]", ")", "\n", "", "return", "(", "output", ",", "torch", ".", "cat", "(", "(", "-", "(", "(", "output", ">=", "prior_credible_range", "[", "0", "]", ")", "&", "(", "output", "<=", "prior_credible_range", "[", "1", "]", ")", ")", ".", "type", "(", "default_dtype", ")", ",", "output", ",", "-", "output", ")", ",", "1", ")", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_skn.simulation.Risk_fun": [[411, 413], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["", "def", "parameter", "(", "ps", ")", ":", "\n", "    ", "output", "=", "torch", ".", "empty", "(", "(", "len", "(", "ps", ")", ",", "1", ")", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "ps", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Distrs.__init__": [[31, 44], ["simulation.init_generate_distr", "torch.arange", "simulation.Distrs.distributions.size", "support.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.init_generate_distr"], ["\n", "\n", "", "class", "Gamma_minimax_Problem", "(", "object", ")", ":", "\n", "    ", "'''holds the estimator, an array of distributions and their prior probs, their true parameters and the summaries of distributions appearing in the constraints.'''", "\n", "\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Distrs.generate_distr": [[45, 52], ["torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.cat", "len", "torch.distributions.dirichlet.Dirichlet"], "methods", ["None"], ["self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Distrs.eval_parameter_constraint": [[54, 77], ["simulation.parameter", "torch.cat().reshape", "torch.cat().reshape", "simulation.Distrs.distributions.mm", "torch.cat", "torch.cat", "ub_constraint_fun", "eq_constraint_fun", "simulation.Distrs.support.unsqueeze", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Distrs.add_parameter_constraint": [[78, 99], ["torch.cat", "torch.cat", "torch.cat().reshape", "torch.cat().reshape", "simulation.parameter", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "simulation.Distrs.distributions[].mm", "eq_constraint_fun", "torch.ones", "ub_constraint_fun", "simulation.Distrs.support.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Distrs.eval_Risks": [[100, 108], ["AttributeError"], "methods", ["None"], ["p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Prior_Risk_Constraint.__init__": [[113, 140], ["numpy.array", "torch.tensor", "torch.tensor", "simulation.Prior_Risk_Constraint.distrs[].eval_parameter_constraint", "torch.sum().mean", "simulation.Distrs", "torch.zeros", "torch.as_tensor", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint"], ["np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n", "\n", "", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Prior_Risk_Constraint.enlarge_distr_grid": [[141, 164], ["enumerate", "torch.cat", "torch.arange", "simulation.Distrs", "simulation.Distrs.eval_parameter_constraint", "numpy.concatenate", "torch.cat", "new_prior_list.append", "torch.cat", "torch.cat", "new_prior_list.extend", "distr.generate_distr", "distr.add_parameter_constraint", "len", "len", "torch.zeros", "torch.distributions.uniform.Uniform().sample", "numpy.array", "torch.tensor", "torch.tensor", "torch.cumsum", "torch.zeros", "torch.distributions.uniform.Uniform"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.generate_distr", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.add_parameter_constraint"], ["", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Prior_Risk_Constraint.get_constraint_matrices": [[165, 183], ["np_A_ub.append", "numpy.ones.append", "torch.cat().cpu().numpy().transpose", "torch.cat().cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "numpy.ones", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat().cpu", "torch.cat().cpu", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat", "torch.cat"], "methods", ["None"], ["\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Prior_Risk_Constraint.get_XTX_XTY": [[184, 195], ["torch.cat", "torch.cat", "torch.cat.append", "torch.cat.append"], "methods", ["None"], ["sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Prior_Risk_Constraint.calc_Risks_tensor": [[196, 203], ["torch.cat", "distr.eval_Risks", "Risks.append"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks"], ["if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n", "p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.init_generate_distr": [[14, 28], ["torch.empty", "enumerate", "torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.arange", "len", "len", "len", "torch.distributions.dirichlet.Dirichlet", "len", "len", "len"], "function", ["None"], ["# A sample is a vector of length sample_size with the i-th entry being the number of species with i occurrences (i=1 to sample_size)", "\n", "\n", "default_dtype", "=", "torch", ".", "double", "\n", "use_cuda", "=", "False", "\n", "if", "use_cuda", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "cuda", ".", "DoubleTensor", ")", "\n", "", "else", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "DoubleTensor", ")", "\n", "\n", "\n", "", "sample_size", "=", "100", "\n", "\n", "# functions and classes for estimators and Gamma-minimax estimators", "\n", "\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.fictitious_play": [[206, 268], ["Prior_Risk_Constraint_object.get_constraint_matrices", "Prior_Risk_Constraint_object.get_XTX_XTY", "Prior_Risk_Constraint_object.calc_Risks_tensor", "risk_lower.append", "torch.as_tensor", "risk_upper.append", "range", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "RuntimeError", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "Prior_Risk_Constraint_object.prior_prob.reshape", "[].squeeze", "torch.cat", "Prior_Risk_Constraint_object.calc_Risks_tensor", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "risk_upper.append", "Prior_Risk_Constraint_object.prior_prob.reshape", "[].squeeze", "torch.cat", "numpy.array", "numpy.array", "scipy.optimize.linprog", "[].squeeze.unsqueeze", "torch.cat.size", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "RuntimeError", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "[].squeeze.unsqueeze", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "torch.as_tensor.cpu().numpy", "numpy.array", "numpy.array", "[].squeeze.unsqueeze", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "torch.solve", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "torch.solve", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "torch.as_tensor.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Prior_Risk_Constraint.get_XTX_XTY", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.calc_Gamma_minimax_estimator": [[270, 323], ["estimators_coef.mean.unsqueeze", "simulation.fictitious_play", "estimator_coef.unsqueeze.mean", "risk_lower.append", "risk_upper.append", "fictitious_play_success.append", "range", "numpy.concatenate", "numpy.ones", "Prior_Risk_Constraint_object.enlarge_distr_grid", "Prior_Risk_Constraint_object.prior_prob.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_iter.append", "numpy.array", "estimators_coef.mean.unsqueeze", "scipy.optimize.linprog", "RuntimeError", "estimators_coef.mean.unsqueeze", "simulation.fictitious_play", "estimator_coef.unsqueeze.mean", "risk_lower.append", "risk_upper.append", "fictitious_play_success.append", "numpy.ones", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "numpy.array", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.fictitious_play", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.fictitious_play"], ["", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.estimate": [[337, 340], ["samples.mean"], "function", ["None"], ["risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.parameter": [[341, 344], ["distribution.mm", "support.unsqueeze"], "function", ["None"], ["", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_fictitious_play.simulation.Risk_fun": [[345, 347], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Distrs.__init__": [[33, 47], ["simulation.init_generate_distr", "torch.arange", "simulation.Distrs.distributions.size", "support.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.init_generate_distr"], ["", "class", "Gamma_minimax_Problem", "(", "object", ")", ":", "\n", "    ", "'''holds the estimator, an array of distributions and their prior probs, their true parameters and the summaries of distributions appearing in the constraints.'''", "\n", "\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n", "if", "parameter", "is", "None", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Distrs.generate_distr": [[48, 55], ["torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.cat", "len", "torch.distributions.dirichlet.Dirichlet"], "methods", ["None"], ["            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n", "", "self", ".", "Risk_fun", "=", "Risk_fun", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Distrs.draw_sample": [[56, 61], ["torch.empty", "enumerate", "simulation.Distrs.support[].reshape", "torch.distributions.categorical.Categorical().sample", "torch.distributions.categorical.Categorical"], "methods", ["None"], ["self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Distrs.eval_parameter_constraint": [[62, 80], ["simulation.parameter", "simulation.ub_constraint_fun", "eq_constraint_fun"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Distrs.add_parameter_constraint": [[81, 99], ["torch.cat", "simulation.parameter", "torch.cat", "torch.cat", "eq_constraint_fun", "simulation.ub_constraint_fun"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n", "non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Distrs.eval_Risks": [[100, 115], ["simulation.Distrs.draw_sample", "simulation.Distrs.true_parameters.unsqueeze().expand", "estimator().view", "simulation.Risk_fun", "torch.sum().mean", "AttributeError", "simulation.Distrs.true_parameters.unsqueeze", "estimator", "torch.sum", "simulation.Distrs.samples.reshape"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.draw_sample", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Prior_Risk_Constraint.__init__": [[120, 147], ["numpy.array", "torch.tensor", "torch.tensor", "simulation.Prior_Risk_Constraint.distrs[].eval_parameter_constraint", "torch.sum().mean", "simulation.Distrs", "torch.zeros", "torch.as_tensor", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint"], ["        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "samples", "=", "torch", ".", "empty", "(", "(", "n_distr", ",", "n_sample", ",", "sample_size", ")", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Prior_Risk_Constraint.enlarge_distr_grid": [[148, 171], ["enumerate", "torch.cat", "torch.arange", "simulation.Distrs", "simulation.Distrs.eval_parameter_constraint", "numpy.concatenate", "torch.cat", "new_prior_list.append", "torch.cat", "torch.cat", "new_prior_list.extend", "distr.generate_distr", "distr.add_parameter_constraint", "len", "len", "torch.zeros", "torch.distributions.uniform.Uniform().sample", "numpy.array", "torch.tensor", "torch.tensor", "torch.cumsum", "torch.zeros", "torch.distributions.uniform.Uniform"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.generate_distr", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.add_parameter_constraint"], ["true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n", "\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Prior_Risk_Constraint.get_constraint_matrices": [[172, 190], ["np_A_ub.append", "numpy.ones.append", "torch.cat().cpu().numpy().transpose", "torch.cat().cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "numpy.ones", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat().cpu", "torch.cat().cpu", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat", "torch.cat"], "methods", ["None"], ["            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n", "multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Prior_Risk_Constraint.calc_Risks_tensor": [[191, 198], ["torch.cat", "distr.eval_Risks", "Risks.append"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks"], ["        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Linear_mean_estimator.__init__": [[336, 343], ["numpy.array", "super().__init__", "torch.nn.Linear", "simulation.Linear_mean_estimator.output_linear.bias.data.fill_", "simulation.Linear_mean_estimator.output_linear.weight.data.fill_"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Linear_mean_estimator.forward": [[343, 345], ["simulation.Linear_mean_estimator.output_linear", "torch.mean().unsqueeze", "torch.mean"], "methods", ["None"], ["            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.init_generate_distr": [[16, 30], ["torch.empty", "enumerate", "torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.arange", "len", "len", "len", "torch.distributions.dirichlet.Dirichlet", "len", "len", "len"], "function", ["None"], ["default_dtype", "=", "torch", ".", "double", "\n", "use_cuda", "=", "False", "\n", "if", "use_cuda", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "cuda", ".", "DoubleTensor", ")", "\n", "", "else", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "DoubleTensor", ")", "\n", "\n", "\n", "", "sample_size", "=", "100", "\n", "\n", "# functions and classes for estimators and Gamma-minimax estimators", "\n", "\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n", "return", "np", ".", "bincount", "(", "multinomial_sample", ",", "minlength", "=", "sample_size", "+", "1", ")", "[", "1", ":", "]", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.SGDmax": [[203, 252], ["Prior_Risk_Constraint_object.get_constraint_matrices", "Prior_Risk_Constraint_object.calc_Risks_tensor", "risk_lower.append", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "Risks.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "Risks.dot.item", "Prior_Risk_Constraint_object.calc_Risks_tensor", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "Risks.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "estimator.parameters", "scipy.optimize.linprog", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "Risks.dot.item", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n", "while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n", "ratio", "=", "Risk_prop", "/", "Risk_init", "*", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_dirichlet", ".", "log_prob", "(", "p_init", ")", "-", "to_prop_dirichlet", ".", "log_prob", "(", "p_prop", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.calc_Gamma_minimax_estimator": [[255, 322], ["simulation.SGDmax", "risk_lower.append", "risk_upper.append", "range", "numpy.concatenate", "numpy.ones", "torch.optim.SGD", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.enlarge_distr_grid", "Prior_Risk_Constraint_object.prior_prob.clone", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_iter.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "simulation.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.ones", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "numpy.array", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "open", "pickle.dump", "pickle.dump", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "str", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax"], ["log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        ", "'''use SGDmax to find the Gamma_l-minimax estimator; updates estimator and Prior_Risk_Constraint_object in place; returns a tuple of \"lower bounds\" and \"upper bounds\" (not really because only a small Monte Carlo sample size is used and we update the estimator with one SGD step in each iteration) of the Gamma_l-minimax risk\n        n_iter: number of iterations\n        use_init_prior: whether to use the prior in Prior_Risk_Constraint_object as the initial point in linear programming\n        optimizer: optimizer to update estimator\n        n_sample: number of samples drawn for each distribution to estimate Risk.\n        b_ub, b_eq: constraints used in linprog that define the restricted set of priors Gamma. default to None. b_eq should include the constraint that prior probabilities sum to 1'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.parameter": [[348, 351], ["distribution.mm", "support.unsqueeze"], "function", ["None"], ["for", "l", "in", "range", "(", "max_enlarge_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.ub_constraint_fun": [[352, 355], ["simulation.parameter", "torch.cat"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean.simulation.Risk_fun": [[356, 358], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.__init__": [[32, 46], ["simulation.init_generate_distr", "torch.arange", "simulation.Distrs.distributions.size", "support.size"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.init_generate_distr"], ["\n", "", "class", "Gamma_minimax_Problem", "(", "object", ")", ":", "\n", "    ", "'''holds the estimator, an array of distributions and their prior probs, their true parameters and the summaries of distributions appearing in the constraints.'''", "\n", "\n", "def", "__init__", "(", "self", ",", "estimator", ",", "parameter_constraint_fun", ",", "b_ub", "=", "None", ",", "b_eq", "=", "None", ",", "Risk_fun", "=", "lambda", "estimates", ",", "true_parameters", ":", "torch", ".", "sum", "(", "(", "estimates", "-", "true_parameters", ")", "**", "2", ",", "dim", "=", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", ",", "p_init", "=", "None", ",", "n_distr", "=", "2000", ",", "init_prior_prob", "=", "None", ",", "MCMC_MC_size", "=", "100", ",", "parameter", "=", "None", ")", ":", "\n", "        ", "'''n_distr: number of random distributions drawn initially\n        parameter_constraint_fun: function that takes in distributions (array of tensors on simplexes) and returns 3 components: (1) parameter (2) summaries that appear in upper bound constraints (3) summaries that appear in equality constraints. Each component should be None (no constraint) or a 2D-tensor with each entry in the 0th dimension corresponding to each distribution. The parameter component cannot be None.\n        b_ub, b_eq: vector of <= and == constraints in linear programming. can be None or numpy arrays or 1D iterables.\n        estimator: initial estimator parameterized in PyTorch\n        Risk_fun: function that takes in a 3D tensor of estimates (number of distributions X number of samples X dimension of estimate) and a 3D tensor of true parameters (number of distributions X number of samples X dimension of estimate) and outputs the Risk=average loss for each distribution. output should be a 1D tensor. default to squared-error loss\n        init_prior_prob: initial probs for the distributions. if not None, its length should be n_distr. defaults to a point mass at the initial point\n        MCMC_MC_size: Monte Caro size to estimate Risk in MCMC\n        parameter: function that takes in distributions (array of tensors on simplexes) and returns the parameter. defaults to run parameter_constraint_fun and take the first output'''", "\n", "self", ".", "estimator", "=", "estimator", "\n", "self", ".", "parameter_constraint_fun", "=", "parameter_constraint_fun", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.generate_distr": [[47, 54], ["torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.cat", "len", "torch.distributions.dirichlet.Dirichlet"], "methods", ["None"], ["if", "parameter", "is", "None", ":", "\n", "            ", "def", "parameter", "(", "ps", ")", ":", "\n", "                ", "true_parameters", ",", "dummy1", ",", "dummy2", "=", "parameter_constraint_fun", "(", "ps", ")", "\n", "return", "true_parameters", "\n", "", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.draw_sample": [[55, 60], ["torch.empty", "enumerate", "simulation.Distrs.support[].reshape", "torch.distributions.categorical.Categorical().sample", "torch.distributions.categorical.Categorical"], "methods", ["None"], ["", "self", ".", "Risk_fun", "=", "Risk_fun", "\n", "self", ".", "MCMC_MC_size", "=", "MCMC_MC_size", "\n", "self", ".", "b_ub", "=", "np", ".", "array", "(", "b_ub", ")", "if", "b_ub", "is", "not", "None", "else", "None", "\n", "self", ".", "b_eq", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "b_eq", ")", ",", "np", ".", "ones", "(", "1", ")", ")", ")", "if", "b_eq", "is", "not", "None", "else", "np", ".", "ones", "(", "1", ")", "\n", "\n", "if", "p_init", "is", "not", "None", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint": [[61, 79], ["simulation.parameter", "simulation.ub_constraint_fun", "eq_constraint_fun"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["            ", "self", ".", "distrs", "=", "[", "p_init", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", "-", "1", ",", "p_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "distrs", "=", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", "\n", "", "self", ".", "n_distr", "=", "n_distr", "\n", "\n", "if", "init_prior_prob", "is", "None", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "zeros", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "prior_prob", "[", "0", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "init_prior_prob", ")", "\n", "\n", "", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "\n", "", "def", "eval_parameter_constraint", "(", "self", ",", "index_of_first_new_distr", "=", "0", ")", ":", "\n", "        ", "'''index_of_first_new_distr: index of the first new random distribution'''", "\n", "true_parameters", ",", "A_ubT", ",", "A_eqT", "=", "self", ".", "parameter_constraint_fun", "(", "self", ".", "distrs", "[", "index_of_first_new_distr", ":", "]", ")", "\n", "if", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "true_parameters", "=", "true_parameters", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.add_parameter_constraint": [[80, 98], ["torch.cat", "simulation.parameter", "torch.cat", "torch.cat", "eq_constraint_fun", "simulation.ub_constraint_fun"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun"], ["", "else", ":", "\n", "            ", "self", ".", "true_parameters", "=", "torch", ".", "cat", "(", "(", "self", ".", "true_parameters", ",", "true_parameters", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_ubT", "is", "None", ":", "\n", "            ", "self", ".", "A_ubT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_ubT", "=", "A_ubT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_ubT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_ubT", ",", "A_ubT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "A_eqT", "is", "None", ":", "\n", "            ", "self", ".", "A_eqT", "=", "None", "\n", "", "elif", "index_of_first_new_distr", "==", "0", ":", "\n", "            ", "self", ".", "A_eqT", "=", "A_eqT", "\n", "", "else", ":", "\n", "            ", "self", ".", "A_eqT", "=", "torch", ".", "cat", "(", "(", "self", ".", "A_eqT", ",", "A_eqT", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "def", "enlarge_distr_grid", "(", "self", ",", "n_distr", "=", "1000", ")", ":", "\n", "        ", "'''generate n_distr more distributions starting from the last distribution with positive prior prob; appends 0 to prior; calculate parameter and constraints'''", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks": [[99, 114], ["simulation.Distrs.draw_sample", "simulation.Distrs.true_parameters.unsqueeze().expand", "estimator().view", "simulation.Risk_fun", "torch.sum().mean", "AttributeError", "simulation.Distrs.true_parameters.unsqueeze", "estimator", "torch.sum", "simulation.Distrs.samples.reshape"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.draw_sample", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["non_zero_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "p_init", "=", "self", ".", "distrs", "[", "non_zero_indices", "[", "-", "1", "]", "]", "\n", "self", ".", "distrs", ".", "extend", "(", "self", ".", "generate_ps", "(", "n_distr", ",", "p_init", ")", ")", "\n", "self", ".", "prior_prob", "=", "torch", ".", "cat", "(", "(", "self", ".", "prior_prob", ",", "torch", ".", "zeros", "(", "n_distr", ")", ")", ")", "\n", "self", ".", "eval_parameter_constraint", "(", "self", ".", "n_distr", ")", "\n", "self", ".", "n_distr", "=", "len", "(", "self", ".", "distrs", ")", "\n", "\n", "", "def", "get_constraint_matrices", "(", "self", ")", ":", "\n", "        ", "'''return a tuple of (1) 2D numpy array A_ub (2) 2D numpy array A_eq\n        A_eq stacks the constraint that prior probability sums to 1 at the end'''", "\n", "np_A_ub", "=", "self", ".", "A_ubT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "if", "self", ".", "A_ubT", "is", "not", "None", "else", "None", "\n", "\n", "if", "self", ".", "A_eqT", "is", "not", "None", ":", "\n", "            ", "np_A_eq", "=", "self", ".", "A_eqT", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", ")", "\n", "np_A_eq", "=", "np", ".", "vstack", "(", "(", "np_A_eq", ",", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", ")", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks_memeff": [[115, 126], ["torch.empty", "enumerate", "torch.sum().mean", "AttributeError", "simulation.Distrs.support[].reshape", "estimator", "simulation.Risk_fun", "estimator.unsqueeze", "torch.sum", "torch.distributions.categorical.Categorical().sample", "torch.distributions.categorical.Categorical"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun"], ["            ", "np_A_eq", "=", "np", ".", "ones", "(", "(", "1", ",", "self", ".", "prior_prob", ".", "size", "(", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "np_A_ub", ",", "np_A_eq", "\n", "\n", "", "def", "draw_sample", "(", "self", ",", "n_sample", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''returns a 3D tensor (number of distributions X number of samples X sample_size). when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which samples are to be drawn; when distr_indices=None, draw samples for all distributions'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.__init__": [[131, 158], ["numpy.array", "torch.tensor", "torch.tensor", "simulation.Prior_Risk_Constraint.distrs[].eval_parameter_constraint", "torch.sum().mean", "simulation.Distrs", "torch.zeros", "torch.as_tensor", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint"], ["multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "[", "i", ",", ":", ",", ":", "]", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", "\n", "", "return", "samples", "\n", "\n", "", "def", "calc_Risks_tensor", "(", "self", ",", "n_sample", "=", "30", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''calculate Risks of distributions and estimator via Monte Carlo. when estimator = None, use the current estimator in the object. when distributions = None, use the distributions in the object. distr_indices is the indices in distributions for which Risks are to be calculated; when distr_indices=None, calculate Risks for all distributions'''", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "samples", "=", "self", ".", "draw_sample", "(", "n_sample", "=", "n_sample", ",", "distributions", "=", "distributions", ",", "distr_indices", "=", "distr_indices", ")", "\n", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_distr", "*", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "n_distr", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "distr_indices", "]", ")", "\n", "return", "Risks", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid": [[159, 182], ["enumerate", "torch.cat", "torch.arange", "simulation.Distrs", "simulation.Distrs.eval_parameter_constraint", "numpy.concatenate", "torch.cat", "new_prior_list.append", "torch.cat", "torch.cat", "new_prior_list.extend", "distr.generate_distr", "distr.add_parameter_constraint", "len", "len", "torch.zeros", "torch.distributions.uniform.Uniform().sample", "numpy.array", "torch.tensor", "torch.tensor", "torch.cumsum", "torch.zeros", "torch.distributions.uniform.Uniform"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_parameter_constraint", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.generate_distr", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.add_parameter_constraint"], ["\n", "", "def", "calc_Risks_tensor_memeff", "(", "self", ",", "n_sample", "=", "2000", ",", "estimator", "=", "None", ",", "distributions", "=", "None", ",", "distr_indices", "=", "None", ")", ":", "\n", "        ", "'''memory efficient version of Gamma_minimax_Problem.calc_Risks_tensor. may be slower and have trouble when used with autograd. may be preferrable when evaluating Risk or Bayes risk with a large number of distributions and large n_sample'''", "\n", "global", "sample_size", ",", "default_dtype", "\n", "if", "estimator", "is", "None", ":", "\n", "            ", "estimator", "=", "self", ".", "estimator", "\n", "\n", "", "if", "distributions", "is", "None", ":", "\n", "            ", "distributions", "=", "self", ".", "distrs", "\n", "if", "self", ".", "true_parameters", "is", "None", "or", "len", "(", "distributions", ")", "!=", "len", "(", "self", ".", "distrs", ")", ":", "\n", "                ", "self", ".", "eval_parameter_constraint", "(", ")", "\n", "", "true_parameters", "=", "self", ".", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "true_parameters", "=", "self", ".", "parameter", "(", "distributions", ")", "\n", "true_parameters", "=", "true_parameters", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "\n", "", "if", "distr_indices", "is", "None", ":", "\n", "            ", "distr_indices", "=", "range", "(", "len", "(", "distributions", ")", ")", "\n", "", "n_distr", "=", "len", "(", "distr_indices", ")", "\n", "\n", "Risks", "=", "torch", ".", "empty", "(", "n_distr", ")", "\n", "for", "i", ",", "p_index", "in", "enumerate", "(", "distr_indices", ")", ":", "\n", "            ", "p", "=", "distributions", "[", "p_index", "]", "\n", "#work on CPU so that numpy functions can be used", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices": [[183, 201], ["np_A_ub.append", "numpy.ones.append", "torch.cat().cpu().numpy().transpose", "torch.cat().cpu().numpy().transpose", "numpy.vstack", "numpy.ones", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "numpy.ones", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat().cpu", "torch.cat().cpu", "simulation.Prior_Risk_Constraint.prior_prob.size", "torch.cat", "torch.cat"], "methods", ["None"], ["multinomial_samples", "=", "torch", ".", "distributions", ".", "Multinomial", "(", "sample_size", ",", "p", ".", "cpu", "(", ")", ")", ".", "sample", "(", "(", "n_sample", ",", ")", ")", ".", "type", "(", "torch", ".", "int64", ")", "\n", "sufficient_stats", "=", "np", ".", "apply_along_axis", "(", "sufficient_statistic", ",", "1", ",", "multinomial_samples", ")", "\n", "samples", "=", "torch", ".", "as_tensor", "(", "sufficient_stats", ",", "dtype", "=", "default_dtype", ")", ".", "unsqueeze", "(", "0", ")", "\n", "estimates", "=", "estimator", "(", "samples", ".", "reshape", "(", "n_sample", ",", "-", "1", ")", ")", ".", "view", "(", "1", ",", "n_sample", ",", "-", "1", ")", "\n", "Risks", "[", "i", "]", "=", "self", ".", "Risk_fun", "(", "estimates", ",", "true_parameters", "[", "p_index", "]", ")", "\n", "", "return", "Risks", "\n", "\n", "", "def", "log_pseudo_prior", "(", "self", ",", "p", ")", ":", "\n", "        ", "global", "MCMC_normal_distribution", ",", "MCMC_negbinomial_distribution", ",", "default_dtype", "\n", "return", "torch", ".", "tensor", "(", "MCMC_normal_distribution", ".", "log_prob", "(", "self", ".", "parameter", "(", "(", "p", ",", ")", ")", ")", ".", "item", "(", ")", "*", "30.", "+", "MCMC_negbinomial_distribution", ".", "log_prob", "(", "torch", ".", "tensor", "(", "p", ".", "size", "(", ")", ",", "dtype", "=", "default_dtype", ")", ")", ".", "item", "(", ")", "*", "10.", ")", "\n", "\n", "", "def", "generate_ps", "(", "self", ",", "n_distr", ",", "p_init", "=", "None", ")", ":", "\n", "        ", "'''generate a list of n_distr tensors of multinomial probabilities'''", "\n", "if", "n_distr", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "if", "p_init", "is", "None", ":", "\n", "            ", "global", "sample_size", "\n", "k_init", "=", "max", "(", "np", ".", "ceil", "(", ".5", "*", "sample_size", ")", ",", "2", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor": [[202, 209], ["torch.cat", "distr.eval_Risks", "Risks.append"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks"], ["p_init", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", ")", ")", ")", ".", "sample", "(", ")", "\n", "", "k_init", "=", "p_init", ".", "size", "(", ")", "[", "0", "]", "\n", "log_pseudo_prior_init", "=", "self", ".", "log_pseudo_prior", "(", "p_init", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risk_init", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_init", ",", ")", ")", "[", "0", "]", "\n", "\n", "", "ps", "=", "[", "None", "]", "*", "n_distr", "\n", "i", "=", "0", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff": [[210, 217], ["torch.cat", "distr.eval_Risks_memeff", "Risks.append"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Distrs.eval_Risks_memeff"], ["while", "(", "True", ")", ":", "\n", "#within dimension jump", "\n", "            ", "to_prop_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_init", "+", "1.", ")", "\n", "p_prop", "=", "to_prop_dirichlet", ".", "sample", "(", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "to_init_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "1e4", "*", "p_prop", "+", "1.", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.nnet_estimator.__init__": [[356, 371], ["super().__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "\n", "old_n_distr", "=", "self", ".", "n_distr", "\n", "old_prior", "=", "self", ".", "prior_prob", ".", "clone", "(", ")", "\n", "self", ".", "enlarge_distr_grid", "(", "n_distr", "=", "n_new_distr", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.nnet_estimator.forward": [[372, 379], ["simulation.nnet_estimator.activation", "simulation.nnet_estimator.activation", "simulation.nnet_estimator.reshape().mean", "simulation.nnet_estimator.activation", "simulation.nnet_estimator.aggregate_output", "input.size", "simulation.nnet_estimator.transform_hidden", "simulation.nnet_estimator.transform_output", "simulation.nnet_estimator.aggregate_hidden", "input.reshape", "simulation.nnet_estimator.reshape"], "methods", ["None"], ["\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "eval_Risks", "=", "self", ".", "calc_Risks_tensor_memeff", "(", "n_sample", "=", "n_accurate_Risk_sample", ")", "\n", "", "new_risk", "=", "eval_Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", "\n", "old_risk", "=", "eval_Risks", "[", ":", "old_n_distr", "]", ".", "dot", "(", "old_prior", ")", ".", "item", "(", ")", "\n", "\n", "risk_iter", ".", "append", "(", "[", "old_risk", ",", "new_risk", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__": [[382, 389], ["numpy.array", "super().__init__", "torch.nn.Linear", "simulation.Linear_mean_estimator.output_linear.bias.data.fill_", "simulation.Linear_mean_estimator.output_linear.weight.data.fill_"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.__init__"], ["\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "                ", "with", "open", "(", "\"l\"", "+", "str", "(", "l", "+", "1", ")", "+", "\".pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n", "                    ", "pickle", ".", "dump", "(", "{", "\"estimator\"", ":", "estimator", ",", "\"lower\"", ":", "lower", ",", "\"upper\"", ":", "upper", "}", ",", "saved_file", ")", "\n", "", "", "risk_lower", ".", "append", "(", "lower", ")", "\n", "risk_upper", ".", "append", "(", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Linear_mean_estimator.forward": [[389, 391], ["simulation.Linear_mean_estimator.output_linear", "simulation.sample_mean"], "methods", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.sample_mean"], ["\n", "", "return", "(", "1", ",", "risk_lower", ",", "risk_upper", ",", "np", ".", "array", "(", "risk_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.init_generate_distr": [[15, 29], ["torch.empty", "enumerate", "torch.ones", "torch.distributions.dirichlet.Dirichlet().sample", "torch.arange", "len", "len", "len", "torch.distributions.dirichlet.Dirichlet", "len", "len", "len"], "function", ["None"], ["\n", "default_dtype", "=", "torch", ".", "double", "\n", "use_cuda", "=", "False", "\n", "if", "use_cuda", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "cuda", ".", "DoubleTensor", ")", "\n", "", "else", ":", "\n", "    ", "torch", ".", "set_default_tensor_type", "(", "torch", ".", "DoubleTensor", ")", "\n", "\n", "\n", "", "sample_size", "=", "100", "\n", "\n", "# functions and classes for estimators and Gamma-minimax estimators", "\n", "\n", "def", "sufficient_statistic", "(", "multinomial_sample", ")", ":", "\n", "    ", "global", "sample_size", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax": [[222, 273], ["Prior_Risk_Constraint_object.get_constraint_matrices", "risk_lower.append", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "Risks.dot.backward", "torch.optim.SGD.step", "range", "torch.optim.SGD", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "scipy.optimize.linprog", "Risks.dot.item", "risk_lower.append", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "risk_upper.append", "torch.optim.SGD.zero_grad", "Risks.dot.backward", "torch.optim.SGD.step", "numpy.array", "numpy.array", "estimator.parameters", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot().item", "scipy.optimize.linprog", "Risks.dot.item", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor"], ["log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                    ", "break", "\n", "\n", "#across dimension jump", "\n", "", "", "to_prop_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_init", ")", "\n", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "while", "k_prop", "==", "0", ":", "\n", "                ", "k_prop", "=", "to_prop_Poisson", ".", "sample", "(", ")", "\n", "", "to_init_Poisson", "=", "torch", ".", "distributions", ".", "poisson", ".", "Poisson", "(", "k_prop", ")", "\n", "if", "k_prop", ">", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_prop", "-", "k_init", "+", "1", ")", ")", ")", "\n", "u", "=", "flat_dirichlet", ".", "sample", "(", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "-", "1", "]", ",", "p_init", "[", "-", "1", "]", "*", "u", ")", ")", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "(", "k_prop", "-", "k_init", ")", "*", "torch", ".", "log", "(", "p_init", "[", "-", "1", "]", ")", "-", "flat_dirichlet", ".", "log_prob", "(", "u", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "elif", "k_prop", "<", "k_init", ":", "\n", "                ", "flat_dirichlet", "=", "torch", ".", "distributions", ".", "dirichlet", ".", "Dirichlet", "(", "torch", ".", "ones", "(", "int", "(", "k_init", "-", "k_prop", "+", "1", ")", ")", ")", "\n", "p_prop", "=", "torch", ".", "cat", "(", "(", "p_init", "[", ":", "int", "(", "k_prop", "-", "1", ")", "]", ",", "torch", ".", "sum", "(", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", ")", ".", "unsqueeze", "(", "0", ")", ")", ")", "\n", "u", "=", "p_init", "[", "int", "(", "k_prop", "-", "1", ")", ":", "]", "/", "p_prop", "[", "-", "1", "]", "\n", "log_pseudo_prior_prop", "=", "self", ".", "log_pseudo_prior", "(", "p_prop", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "Risk_prop", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "self", ".", "MCMC_MC_size", ",", "distributions", "=", "(", "p_prop", ",", ")", ")", "[", "0", "]", "\n", "", "ratio", "=", "torch", ".", "exp", "(", "log_pseudo_prior_prop", "-", "log_pseudo_prior_init", "+", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_init", ",", "dtype", "=", "default_dtype", ")", ")", "-", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "as_tensor", "(", "k_prop", ",", "dtype", "=", "default_dtype", ")", ")", "+", "flat_dirichlet", ".", "log_prob", "(", "u", ")", "-", "(", "k_init", "-", "k_prop", ")", "*", "torch", ".", "log", "(", "p_prop", "[", "-", "1", "]", ")", ")", "*", "Risk_prop", "/", "Risk_init", "*", "(", "1", "-", "torch", ".", "exp", "(", "to_prop_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "/", "(", "1", "-", "torch", ".", "exp", "(", "to_init_Poisson", ".", "log_prob", "(", "torch", ".", "tensor", "(", "0.", ")", ")", ")", ")", "\n", "if", "ratio", ">=", "1", "or", "uniform", "(", ")", "<=", "ratio", ":", "\n", "                    ", "ps", "[", "i", "]", "=", "p_prop", "\n", "p_init", "=", "p_prop", "\n", "k_init", "=", "k_prop", "\n", "log_pseudo_prior_init", "=", "log_pseudo_prior_prop", "\n", "Risk_init", "=", "Risk_prop", "\n", "i", "+=", "1", "\n", "if", "i", "==", "n_distr", ":", "\n", "                        ", "break", "\n", "", "", "", "", "return", "ps", "\n", "\n", "", "def", "SGDmax", "(", "self", ",", "n_iter", "=", "2000", ",", "use_init_prior", "=", "True", ",", "optimizer", "=", "None", ",", "n_sample", "=", "30", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.calc_Gamma_minimax_estimator": [[276, 343], ["simulation.SGDmax", "risk_lower.append", "risk_upper.append", "range", "numpy.concatenate", "numpy.ones", "torch.optim.SGD", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.enlarge_distr_grid", "Prior_Risk_Constraint_object.prior_prob.clone", "Prior_Risk_Constraint_object.get_constraint_matrices", "scipy.optimize.linprog", "torch.as_tensor", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.dot", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.dot", "risk_iter.append", "numpy.array", "estimator.parameters", "open", "pickle.dump", "pickle.dump", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff", "scipy.optimize.linprog", "torch.no_grad", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff", "simulation.SGDmax", "risk_lower.append", "risk_upper.append", "numpy.ones", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.prior_prob.cpu().numpy", "numpy.array", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu().numpy", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu().numpy", "open", "pickle.dump", "pickle.dump", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu", "Prior_Risk_Constraint_object.prior_prob.cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach().cpu", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach", "str", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone().detach", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone", "Prior_Risk_Constraint_object.calc_Risks_tensor_memeff.clone"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.enlarge_distr_grid", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.get_constraint_matrices", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Prior_Risk_Constraint.calc_Risks_tensor_memeff", "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.SGDmax"], ["\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "if", "use_init_prior", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "", "else", ":", "\n", "            ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "            ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "for", "_", "in", "range", "(", "n_iter", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ")", "\n", "", "risk_lower", ".", "append", "(", "Risks", ".", "dot", "(", "self", ".", "prior_prob", ")", ".", "item", "(", ")", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n", "", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "raise", "RuntimeError", "(", "linear_prog_result", ".", "message", ")", "\n", "", "self", ".", "prior_prob", "=", "torch", ".", "as_tensor", "(", "linear_prog_result", ".", "x", ")", "\n", "nonzero_distr_indices", "=", "self", ".", "prior_prob", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "Risks", "=", "self", ".", "calc_Risks_tensor", "(", "n_sample", "=", "n_sample", ",", "distr_indices", "=", "nonzero_distr_indices", ")", "\n", "risk", "=", "Risks", ".", "dot", "(", "self", ".", "prior_prob", "[", "nonzero_distr_indices", "]", ")", "\n", "risk_upper", ".", "append", "(", "risk", ".", "item", "(", ")", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "risk", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "return", "(", "np", ".", "array", "(", "risk_lower", ")", ",", "np", ".", "array", "(", "risk_upper", ")", ")", "\n", "\n", "", "def", "calc_Gamma_minimax_estimator", "(", "self", ",", "n_SGDmax_iter", "=", "200", ",", "max_enlarge_iter", "=", "10", ",", "optimizer", "=", "None", ",", "n_SGDmax_sample", "=", "30", ",", "n_accurate_Risk_sample", "=", "2000", ",", "tol", "=", "1e-4", ",", "relative_tol", "=", "0.02", ",", "n_new_distr", "=", "1000", ",", "save_SGDmax_result", "=", "True", ")", ":", "\n", "        ", "'''calculate the Gamma-minimax estimator; estimator and prior are updated in place. returns a tuple of (1) status where 0 means success and 1 means divergence (2) list of \"lower bounds\" of Gamma_l-minimax risk from SGDmax (3) list of \"upper bounds\" of Gamma_l-minimax risk from SGDmax (4) 2D array of estimated Gamma_l-minimax risks in each iteration (indexed by l) of the old prior (1st column) and new prior (2nd column)\n        n_SGDmax_iter: number of iterations in SGDmax (use 30 X n_SGDmax_iter for the first training)\n        max_enlarge_iter: max number of iterations to enlarge grid\n        optimizer: optimizer to update estimator\n        n_SGD_max_sample: number of samples drawn for each distribution to estimate Risk in SGDmax\n        n_accurate_Risk_sample: number of samples drawn for each distribution to accurately estimate Risk\n        tol, relative_tol: tolerance in increment of [min max risk] to stop enlarging the grid of distributions\n        max_enlarge_iter: max number of iteration to enlarge the grid of distributions\n        n_new_distr: numbder of new distributions when enlarging the grid'''", "\n", "risk_lower", "=", "[", "]", "\n", "risk_upper", "=", "[", "]", "\n", "risk_iter", "=", "[", "]", "\n", "if", "optimizer", "is", "None", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "estimator", ".", "parameters", "(", ")", ",", "lr", "=", "0.001", ")", "\n", "\n", "", "lower", ",", "upper", "=", "self", ".", "SGDmax", "(", "n_iter", "=", "n_SGDmax_iter", "*", "30", ",", "use_init_prior", "=", "False", ",", "optimizer", "=", "optimizer", ",", "n_sample", "=", "n_SGDmax_sample", ")", "\n", "if", "save_SGDmax_result", ":", "\n", "            ", "with", "open", "(", "\"l0.pkl\"", ",", "\"wb\"", ")", "as", "saved_file", ":", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.sample_mean": [[351, 354], ["torch.mean().unsqueeze", "torch.mean"], "function", ["None"], ["", "np_A_ub", ",", "np_A_eq", "=", "self", ".", "get_constraint_matrices", "(", ")", "\n", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ",", "x0", "=", "self", ".", "prior_prob", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "not", "linear_prog_result", ".", "success", ":", "\n", "                ", "linear_prog_result", "=", "linprog", "(", "-", "Risks", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "A_ub", "=", "np_A_ub", ",", "b_ub", "=", "self", ".", "b_ub", ",", "A_eq", "=", "np_A_eq", ",", "b_eq", "=", "self", ".", "b_eq", ",", "bounds", "=", "(", "0.", ",", "1.", ")", ",", "method", "=", "'revised simplex'", ")", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter": [[394, 397], ["distribution.mm", "support.unsqueeze"], "function", ["None"], ["\n", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.ub_constraint_fun": [[398, 401], ["simulation.parameter", "torch.cat"], "function", ["home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.parameter"], ["\n", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.qiu-hongxiang-david_gamma-minimax-learning.univariate_mean_nn.simulation.Risk_fun": [[402, 404], ["torch.sum().mean", "torch.sum"], "function", ["None"], ["", "", "def", "parameter_constraint_fun", "(", "ps", ")", ":", "\n", "    ", "'''parameters and eq_constraint: expected number of new species in the new sample; no ub_constraint'''", "\n", "global", "prior_credible_range", "\n"]]}