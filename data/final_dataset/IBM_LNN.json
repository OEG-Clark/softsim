{"home.repos.pwc.inspect_result.IBM_LNN.None.setup.parse_requirements": [[11, 13], ["pathlib.Path().read_text().replace().split", "pathlib.Path().read_text().replace", "pathlib.Path().read_text", "pathlib.Path"], "function", ["None"], ["def", "parse_requirements", "(", "filename", ")", ":", "\n", "    ", "return", "pathlib", ".", "Path", "(", "filename", ")", ".", "read_text", "(", ")", ".", "replace", "(", "\"==\"", ",", "\">=\"", ")", ".", "split", "(", "\"\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.constants.AutoName._generate_next_value_": [[31, 33], ["None"], "methods", ["None"], ["def", "_generate_next_value_", "(", "self", ",", "start", ",", "count", ",", "last_values", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.MultiInstance.__init__": [[18, 29], ["isinstance", "isinstance", "_utils.MultiInstance.__class__", "Exception", "type"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "term", ":", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ")", ":", "\n", "        ", "if", "isinstance", "(", "term", ",", "tuple", ")", ":", "\n", "# Decompose Tuple to create an instance for each in the Tuple", "\n", "# This allows _Grounding(('x', 'y')) to create individual", "\n", "# groundings, i.e. _Grounding('x'), _Grounding('y')", "\n", "            ", "[", "self", ".", "__class__", "(", "t", ")", "for", "t", "in", "term", "]", "\n", "", "elif", "isinstance", "(", "term", ",", "str", ")", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "\n", "f\"expected {self.__class__.__name__} inputs from \"", "\n", "f\"[str, list], received {type(term)}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.__getitem__": [[48, 54], ["LookupError", "type", "list", "cls.instances.keys"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys"], ["@", "classmethod", "\n", "def", "__getitem__", "(", "cls", ",", "key", ":", "str", ")", ":", "\n", "        ", "if", "key", "in", "cls", ".", "instances", ":", "\n", "            ", "return", "cls", ".", "instances", "[", "key", "]", "\n", "", "raise", "LookupError", "(", "\n", "f\"should not end up here, {type(key)} key {key} not found in \"", "\n", "f\"Groundings {list(cls.instances.keys())}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.__setitem__": [[57, 60], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "__setitem__", "(", "cls", ",", "key", ":", "str", ",", "val", ":", "any", ")", ":", "\n", "        ", "cls", ".", "instances", "[", "key", "]", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.__new__": [[61, 68], ["str", "cls.instances.get", "super().__new__", "cls.__setitem__"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.__new__", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.__setitem__"], ["", "def", "__new__", "(", "cls", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "unique_name", "=", "str", "(", "*", "args", ",", "**", "kwds", ")", "\n", "instance", "=", "cls", ".", "instances", ".", "get", "(", "unique_name", ")", "\n", "if", "instance", "is", "None", ":", "\n", "            ", "instance", "=", "super", "(", "cls", ".", "__class__", ",", "cls", ")", ".", "__new__", "(", "cls", ")", "\n", "cls", ".", "__setitem__", "(", "unique_name", ",", "instance", ")", "\n", "", "return", "instance", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys": [[69, 72], ["cls.instances.keys"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys"], ["", "@", "classmethod", "\n", "def", "keys", "(", "cls", ")", ":", "\n", "        ", "return", "cls", ".", "instances", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values": [[73, 76], ["cls.instances.values"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values"], ["", "@", "classmethod", "\n", "def", "values", "(", "cls", ")", ":", "\n", "        ", "return", "cls", ".", "instances", ".", "values", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.__len__": [[77, 80], ["len"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "__len__", "(", "cls", ")", ":", "\n", "        ", "return", "len", "(", "cls", ".", "instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items": [[81, 84], ["cls.instances.items"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items"], ["", "@", "classmethod", "\n", "def", "items", "(", "cls", ")", ":", "\n", "        ", "return", "cls", ".", "instances", ".", "items", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.rekey": [[85, 88], ["cls.instances.pop"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.pop"], ["", "@", "classmethod", "\n", "def", "rekey", "(", "cls", ",", "new_key", ":", "str", ",", "old_key", ":", "str", ")", ":", "\n", "        ", "cls", ".", "instances", "[", "new_key", "]", "=", "cls", ".", "instances", ".", "pop", "(", "old_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.pop": [[89, 92], ["cls.instances.pop"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.pop"], ["", "@", "classmethod", "\n", "def", "pop", "(", "cls", ",", "key", ":", "str", ")", ":", "\n", "        ", "return", "cls", ".", "instances", ".", "pop", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.clear": [[93, 96], ["dict"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "clear", "(", "cls", ")", ":", "\n", "        ", "cls", ".", "instances", "=", "dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.__contains__": [[97, 100], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "__contains__", "(", "cls", ",", "key", ":", "str", ")", ":", "\n", "        ", "return", "key", "in", "cls", ".", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds": [[102, 142], ["isinstance", "isinstance", "torch.tensor().repeat().requires_grad_", "_exceptions.AssertBoundsLen", "type", "torch.tensor().repeat", "torch.tensor", "tuple", "map"], "function", ["None"], ["", "", "def", "fact_to_bounds", "(", "\n", "fact", ":", "Union", "[", "Fact", ",", "World", "]", ",", "\n", "propositional", ":", "bool", ",", "\n", "dims", ":", "list", "=", "None", ",", "\n", "requires_grad", ":", "bool", "=", "False", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Create classical bounds tensor\n\n    bounds tensor repeats over dims according to (batch, groundings)\n    None facts assumes `Unknown`\n        tuple facts required in bounds form `(Lower, Upper)`\n        All facts are converted to bounds, see\n            [F2 - table 3](https://arxiv.org/pdf/2006.13155.pdf) for\n            additional description of how truths and bounds are mapped\n\n    **Parameters**\n\n    fact: Fact\n    dims: tuple\n        repeats over optional (batch, groundings)\n    propositional: bool\n\n    **Example**\n\n    fact_to_bounds(UNKNOWN, dims=[5])\n    fact_to_bounds(UNKNOWN, dims=[2, 5])\n\n    \"\"\"", "\n", "if", "isinstance", "(", "fact", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "return", "fact", "\n", "\n", "", "sizes", "=", "dims", "+", "[", "1", "]", "if", "dims", "else", "(", "1", "if", "propositional", "else", "[", "1", ",", "1", "]", ")", "\n", "if", "isinstance", "(", "fact", ",", "tuple", ")", ":", "\n", "        ", "_exceptions", ".", "AssertBoundsLen", "(", "fact", ")", "\n", "", "elif", "type", "(", "fact", ")", "in", "[", "World", ",", "Fact", "]", ":", "\n", "        ", "fact", "=", "fact", ".", "value", "\n", "", "return", "(", "\n", "torch", ".", "tensor", "(", "tuple", "(", "map", "(", "float", ",", "fact", ")", ")", ")", "\n", ".", "repeat", "(", "sizes", ")", "\n", ".", "requires_grad_", "(", "requires_grad", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds": [[145, 148], ["None"], "function", ["None"], ["", "def", "negate_bounds", "(", "bounds", ":", "torch", ".", "Tensor", ",", "dim", "=", "-", "1", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"Negate a bounds tensor: (1 - U, 1 - L)\"\"\"", "\n", "return", "(", "1", "-", "bounds", ")", ".", "flip", "(", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.node_state": [[150, 162], ["state.item"], "function", ["None"], ["", "def", "node_state", "(", "state", ":", "np", ".", "ScalarType", ")", ":", "\n", "    ", "result", "=", "{", "\n", "\"U\"", ":", "Fact", ".", "UNKNOWN", ",", "\n", "\"T\"", ":", "Fact", ".", "TRUE", ",", "\n", "\"F\"", ":", "Fact", ".", "FALSE", ",", "\n", "\"C\"", ":", "Fact", ".", "CONTRADICTION", ",", "\n", "\"~F\"", ":", "_Fact", ".", "APPROX_FALSE", ",", "\n", "\"~U\"", ":", "_Fact", ".", "APPROX_UNKNOWN", ",", "\n", "\"=U\"", ":", "_Fact", ".", "EXACT_UNKNOWN", ",", "\n", "\"~T\"", ":", "_Fact", ".", "APPROX_TRUE", ",", "\n", "}", "\n", "return", "result", "[", "state", ".", "item", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.dict_rekey": [[164, 166], ["d.pop"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.pop"], ["", "def", "dict_rekey", "(", "d", ",", "old_key", ",", "new_key", ")", "->", "None", ":", "\n", "    ", "d", "[", "new_key", "]", "=", "d", ".", "pop", "(", "old_key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.plot_autograd": [[178, 188], ["model.named_parameters", "torchviz.make_dot().render", "torchviz.make_dot", "kwds.get", "kwds.get", "kwds.get"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters"], ["def", "plot_autograd", "(", "model", ":", "Model", ",", "loss", ":", "torch", ".", "Tensor", ",", "**", "kwds", ")", "->", "None", ":", "\n", "    ", "import", "torchviz", "\n", "\n", "params", "=", "model", ".", "named_parameters", "(", ")", "\n", "torchviz", ".", "make_dot", "(", "\n", "loss", ",", "\n", "params", "=", "params", ",", "\n", "show_attrs", "=", "kwds", ".", "get", "(", "\"show_attrs\"", ",", "True", ")", ",", "\n", "show_saved", "=", "kwds", ".", "get", "(", "\"show_saved\"", ",", "True", ")", ",", "\n", ")", ".", "render", "(", "f'graph_{kwds.get(\"epoch\", \"\")}'", ",", "view", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.val_clamp": [[190, 195], ["x.detach", "x.detach"], "function", ["None"], ["", "def", "val_clamp", "(", "x", ",", "_min", ":", "float", "=", "0", ",", "_max", ":", "float", "=", "1", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"gradient-transparent clamping to clamp values between [min, max]\"\"\"", "\n", "clamp_min", "=", "(", "x", ".", "detach", "(", ")", "-", "_min", ")", ".", "clamp", "(", "max", "=", "0", ")", "\n", "clamp_max", "=", "(", "x", ".", "detach", "(", ")", "-", "_max", ")", ".", "clamp", "(", "min", "=", "0", ")", "\n", "return", "x", "-", "clamp_max", "-", "clamp_min", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.unpack_checkpoints": [[200, 203], ["range", "print", "len"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["def", "unpack_checkpoints", "(", ")", ":", "\n", "    ", "for", "t", "in", "range", "(", "len", "(", "checkpoints", ")", "-", "1", ")", ":", "\n", "        ", "print", "(", "f\"{checkpoints[t+1][1]}: \"", "f\"{checkpoints[t+1][0] - checkpoints[t][0]}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.add_checkpoint": [[205, 207], ["checkpoints.append", "time.time"], "function", ["None"], ["", "", "def", "add_checkpoint", "(", "label", ")", ":", "\n", "    ", "checkpoints", ".", "append", "(", "(", "time", ".", "time", "(", ")", ",", "label", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertWorld.__init__": [[21, 25], ["KeyError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "world", ":", "World", ")", ":", "\n", "        ", "if", "world", "not", "in", "World", ":", "\n", "            ", "raise", "KeyError", "(", "\n", "\"truth world assumption expects lnn.World object from \"", "\n", "f\"{[w.name for w in World]}, received \"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertBoundsBroadcasting.__init__": [[36, 40], ["isinstance", "len", "IndexError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bounds", ":", "Set", ")", ":", "\n", "        ", "if", "isinstance", "(", "bounds", ",", "set", ")", ":", "\n", "            ", "if", "len", "(", "bounds", ")", "!=", "1", ":", "\n", "                ", "raise", "IndexError", "(", "\"broadcasting facts expects a set of 1 item\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertBoundsType.__init__": [[47, 52], ["type", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bounds", ":", "Union", "[", "Fact", ",", "tuple", "]", ")", ":", "\n", "        ", "options", "=", "[", "Fact", ",", "tuple", "]", "\n", "if", "type", "(", "bounds", ")", "not", "in", "options", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f\"fact expected from [lnn.Fact, tuple] \"", "\n", "f\"received {bounds.__class__.__name__} {bounds}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertBoundsLen.__init__": [[62, 67], ["isinstance", "len", "IndexError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bounds", ":", "tuple", ")", ":", "\n", "        ", "if", "isinstance", "(", "bounds", ",", "tuple", ")", ":", "\n", "            ", "if", "len", "(", "bounds", ")", "!=", "2", ":", "\n", "                ", "raise", "IndexError", "(", "\n", "\"bounds tuple expected to have 2 bounds (Lower, Upper), \"", "\n", "f\"received {bounds}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertBoundsInputs.__init__": [[77, 82], ["isinstance", "any", "IndexError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bounds", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "...", "]", ")", ":", "\n", "        ", "if", "isinstance", "(", "bounds", ",", "tuple", ")", ":", "\n", "            ", "if", "any", "(", "[", "not", "0", "<=", "b", "<=", "1", "for", "b", "in", "bounds", "]", ")", ":", "\n", "                ", "raise", "IndexError", "(", "\n", "\"bounds expected to be in range [0, 1], \"", "f\"received {bounds}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertBounds.__init__": [[91, 96], ["_exceptions.AssertBoundsType", "_exceptions.AssertBoundsLen", "_exceptions.AssertBoundsInputs", "_exceptions.AssertBoundsBroadcasting"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bounds", ")", ":", "\n", "        ", "AssertBoundsType", "(", "bounds", ")", "\n", "AssertBoundsLen", "(", "bounds", ")", "\n", "AssertBoundsInputs", "(", "bounds", ")", "\n", "AssertBoundsBroadcasting", "(", "bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertPropositionalInheritance.__init__": [[104, 108], ["hasattr", "Exception"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "node", ",", "\"propositional\"", ")", ":", "\n", "            ", "raise", "Exception", "(", "\n", "\"should not end up here, propositional variable \"", "\n", "\"expected to be declared at proposition/predicate\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertFormulaInModel.__init__": [[120, 123], ["Exception"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ":", "\"lnn.Model\"", ",", "formula", ":", "\"lnn.symbolic.logic._Formula\"", ")", ":", "\n", "        ", "if", "formula", "not", "in", "model", ":", "\n", "            ", "raise", "Exception", "(", "f\"{formula} is not a stored formula, can't set facts\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertGroundingKeyType.__init__": [[131, 136], ["isinstance", "all", "TypeError", "type", "facts.keys"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys"], ["def", "__init__", "(", "self", ",", "facts", ":", "Dict", ")", ":", "\n", "        ", "if", "isinstance", "(", "facts", ",", "dict", ")", ":", "\n", "            ", "if", "all", "(", "[", "type", "(", "f", ")", "not", "in", "[", "tuple", ",", "Fact", "]", "for", "f", "in", "facts", ".", "keys", "(", ")", "]", ")", ":", "\n", "                ", "raise", "TypeError", "(", "\n", "\"fact keys expected as str or tuple of str\"", "f\"received {facts}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertFOLFacts.__init__": [[146, 151], ["isinstance", "facts.items", "_exceptions.AssertGroundingKeyType", "_exceptions.AssertBounds"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items"], ["def", "__init__", "(", "self", ",", "facts", ":", "Dict", ")", ":", "\n", "        ", "if", "isinstance", "(", "facts", ",", "dict", ")", ":", "\n", "            ", "for", "grounding", ",", "bounds", "in", "facts", ".", "items", "(", ")", ":", "\n", "                ", "AssertGroundingKeyType", "(", "grounding", ")", "\n", "AssertBounds", "(", "bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertDirection.__init__": [[159, 162], ["_exceptions.AssertDirectionType", "_exceptions.AssertValidDirection"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "AssertDirectionType", "(", "direction", ")", "\n", "AssertValidDirection", "(", "direction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertValidDirection.__init__": [[170, 174], ["KeyError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "options", "=", "[", "Direction", ".", "UPWARD", ",", "Direction", ".", "DOWNWARD", "]", "\n", "if", "direction", "not", "in", "options", ":", "\n", "            ", "raise", "KeyError", "(", "f\"direction expected from {options}, \"", "f\"found {direction}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertDirectionType.__init__": [[182, 186], ["isinstance", "TypeError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "direction", ",", "Direction", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "f\"direction expected as Direction, \"", "f\"received {direction}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertBias.__init__": [[195, 198], ["isinstance", "TypeError", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "bias", ":", "float", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "bias", ",", "float", ")", ":", "\n", "            ", "raise", "TypeError", "(", "f\"bias expected as a float, received {type(bias)}: {bias}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertWeights.__init__": [[206, 215], ["isinstance", "TypeError", "ValueError", "len", "type", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "weights", ":", "Tuple", ",", "arity", ":", "int", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "weights", ",", "tuple", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "\"weights expected as a tuple of floats, received \"", "\n", "f\"{type(weights)}: {weights}\"", "\n", ")", "\n", "", "if", "not", "len", "(", "weights", ")", "==", "arity", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"weights expected as len {arity}, received {len(weights)}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertAlphaNodeValue.__init__": [[224, 227], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "alpha", ":", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "not", "(", "0.5", "<", "alpha", "<=", "1", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"alpha expected between (.5, 1], received {alpha}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertAlphaNeuronArityValue.__init__": [[235, 240], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "alpha", ":", "torch", ".", "Tensor", ",", "arity", ":", "int", ")", ":", "\n", "        ", "constraint", "=", "arity", "/", "(", "arity", "+", "1", ")", "\n", "if", "not", "(", "alpha", ">=", "constraint", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"alpha expected greater than n/(n+1) ({constraint:<.3e}) \"", "\n", "f\"for n={arity}, received {alpha:<3e}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn._exceptions.AssertCalledPredicate.__init__": [[250, 256], ["isinstance", "ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "formula", ":", "Tuple", "[", "\"lnn.symbolic.logic._Formula\"", ",", "...", "]", ")", ":", "\n", "        ", "if", "formula", ":", "\n", "            ", "for", "subformula", "in", "formula", ":", "\n", "                ", "if", "isinstance", "(", "subformula", ",", "lnn", ".", "Predicate", ")", ":", "\n", "                    ", "raise", "ValueError", "(", "\n", "f\"predicate {subformula} inside formula must be called\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.__init__": [[97, 101], ["networkx.DiGraph", "dict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ":", "str", "=", "\"Model\"", ")", ":", "\n", "        ", "self", ".", "graph", "=", "nx", ".", "DiGraph", "(", ")", "\n", "self", ".", "nodes", "=", "dict", "(", ")", "\n", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.__getitem__": [[102, 106], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ":", "str", ")", ":", "\n", "        ", "r\"\"\"model['node_name']\"\"\"", "\n", "if", "key", "in", "self", ".", "nodes", ":", "\n", "            ", "return", "self", ".", "nodes", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.__setitem__": [[107, 125], ["model.Model.add_formulae", "_utils.dict_rekey", "model.Model.nodes[].rename", "warnings.warn", "model.Model.__dict__.update", "repr"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.dict_rekey", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.rename"], ["", "", "def", "__setitem__", "(", "self", ",", "name", ":", "str", ",", "formula", ":", "_Formula", ")", ":", "\n", "        ", "r\"\"\"Alias for `model.add_formulae`\n\n        Automatically renames graph nodes, instantiated nodes need not be named\n        ```python\n        model['P1'] = Predicate()\n        ```\n        \"\"\"", "\n", "self", ".", "add_formulae", "(", "formula", ")", "\n", "_utils", ".", "dict_rekey", "(", "self", ".", "nodes", ",", "formula", ".", "name", ",", "name", ")", "\n", "self", ".", "nodes", "[", "name", "]", ".", "rename", "(", "name", ")", "\n", "if", "name", "in", "self", ".", "__dict__", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "f\"{name} already exists as a model variable the \"", "\n", "f\"existing object {repr(self.__dict__[name])} will \"", "\n", "\"be overtten\"", "\n", ")", "\n", "self", ".", "__dict__", ".", "update", "(", "{", "name", ":", "formula", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.__contains__": [[126, 128], ["None"], "methods", ["None"], ["", "", "def", "__contains__", "(", "self", ",", "key", ":", "str", ")", ":", "\n", "        ", "return", "key", "in", "self", ".", "nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae": [[129, 162], ["model.Model._add_rules"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._add_rules"], ["", "def", "add_formulae", "(", "self", ",", "*", "formulae", ":", "_Formula", ",", "world", ":", "World", "=", "World", ".", "OPEN", ")", ":", "\n", "        ", "r\"\"\"Extend the model to include additional formulae\n\n        Only root level formulae explicitly need to be added to the model.\n        Unless otherwise specified, each root formula follows the open world\n        assumption.\n\n        **Example**\n\n        Any formula given without cloning will be operated on directly\n        To be used when working with only 1 model,\n        i.e., directly referencing the model nodes\n\n        ```python\n        model.add_formulae(Predicate('P1'))\n\n        ```\n\n        or directly modifying the formula in the user space:\n\n        ```python\n        model = Model()\n        P1 = Predicate('P1')\n        model.add_formulae(P1)\n\n        ```\n\n        the former requires modifications to be accessed via `model['P1']`\n        while the latter will store any changes to made by the model,\n        directly in `P1`\n\n        \"\"\"", "\n", "self", ".", "_add_rules", "(", "*", "formulae", ",", "world", "=", "world", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_propositions": [[163, 169], ["symbolic.logic.Proposition", "ret.append", "len"], "methods", ["None"], ["", "def", "add_propositions", "(", "self", ",", "*", "names", ":", "str", ",", "**", "kwds", ")", ":", "\n", "        ", "ret", "=", "[", "]", "\n", "for", "name", "in", "names", ":", "\n", "            ", "self", "[", "name", "]", "=", "Proposition", "(", "**", "kwds", ")", "\n", "ret", ".", "append", "(", "self", "[", "name", "]", ")", "\n", "", "return", "ret", "[", "0", "]", "if", "len", "(", "ret", ")", "==", "1", "else", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates": [[170, 176], ["symbolic.logic.Predicate", "ret.append", "len"], "methods", ["None"], ["", "def", "add_predicates", "(", "self", ",", "arity", ":", "int", ",", "*", "names", ":", "str", ",", "**", "kwds", ")", ":", "\n", "        ", "ret", "=", "[", "]", "\n", "for", "name", "in", "names", ":", "\n", "            ", "self", "[", "name", "]", "=", "Predicate", "(", "arity", "=", "arity", ",", "**", "kwds", ")", "\n", "ret", ".", "append", "(", "self", "[", "name", "]", ")", "\n", "", "return", "ret", "[", "0", "]", "if", "len", "(", "ret", ")", "==", "1", "else", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._add_rules": [[177, 184], ["model.Model.nodes.update", "model.Model.graph.add_node", "model.Model.graph.add_edges_from", "model.Model._set_world"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._set_world"], ["", "def", "_add_rules", "(", "self", ",", "*", "formulae", ":", "_Formula", ",", "world", ":", "World", "=", "World", ".", "OPEN", ")", ":", "\n", "        ", "for", "f", "in", "formulae", ":", "\n", "            ", "self", ".", "graph", ".", "add_node", "(", "f", ")", "\n", "self", ".", "graph", ".", "add_edges_from", "(", "f", ".", "edge_list", ")", "\n", "", "self", ".", "nodes", ".", "update", "(", "{", "node", ".", "name", ":", "node", "for", "node", "in", "self", ".", "graph", ".", "nodes", "}", ")", "\n", "if", "world", "is", "not", "World", ".", "OPEN", ":", "\n", "            ", "[", "self", "[", "f", ".", "name", "]", ".", "_set_world", "(", "world", ")", "for", "f", "in", "formulae", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_facts": [[185, 266], ["facts.items", "_exceptions.AssertFormulaInModel", "model.Model._add_facts", "_exceptions.AssertBounds", "_exceptions.AssertFOLFacts"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._add_facts"], ["", "", "def", "add_facts", "(", "\n", "self", ",", "\n", "facts", ":", "Dict", "[", "\n", "str", ",", "\n", "Union", "[", "\n", "Union", "[", "Fact", ",", "Tuple", "[", "float", ",", "float", "]", "]", ",", "\n", "Dict", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ",", "Union", "[", "Fact", ",", "Tuple", "[", "float", ",", "float", "]", "]", "]", ",", "\n", "]", ",", "\n", "]", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"Append facts to the model\n\n        Assumes that the formulae that require facts have already been inserted\n        into the model, see\n        [add_formulae](https://ibm.github.io/LNN/lnn/LNN.html#lnn.Model.add_formulae)  # noqa: E501\n        for more details\n\n        **Parameters**\n\n            # propositional\n            facts : dict\n                key : str\n                    This is the unique node name stored in the model\n                    can be reference either by the associated string in the\n                    model-scope or extracting the node`.name` stored in the\n                    user-scope\n                value :  Fact or Bounds\n                    Facts may be the flags for classical bounds or bounds can\n                    be directly set as a list of two floats, representing lower\n                    and upper bounds\n\n            # first-order logic\n            facts : dict\n                key : str\n                    This is the unique node name stored in the model\n                    can be reference either by the associated string in the\n                    model-scope or extracting the node`.name` stored in the\n                    user-scope\n                value :  dict\n                    key : str or tuple-of-str\n                        This inner key represents the first-order grounding or\n                        the propositionalised/instantiated binding that applies\n                        the the free variable. It represents a single row\n                        within the bounds table\n                    value :  Fact or Bounds\n                        This inner value represents the facts, given either as\n                        a flag for classical bounds or directly as a list of\n                        two floats, representing the lower and upper bounds.\n                        This fact is set as the associated truth for the\n                        grounding key above.\n\n        **Example**\n\n        ```python\n        # propositional\n        P = Proposition('Person')\n        model.add_facts({'Person': Facts.TRUE})\n        ```\n\n        ```python\n        # first-order logic\n        P = Predicate('Person')\n        B = Predicate('Birthdate', arity=2)\n        model.add_facts(\n            {'Person': {\n                'Barack Obama': TRUE,\n                'Bo': FALSE},\n             B.name: {\n                 ('Barack Obama', '04 August 1961'): TRUE,\n                 ('Bo', '09 October 2008'): TRUE}\n            })\n        ```\n\n        \"\"\"", "\n", "for", "formula", ",", "fact", "in", "facts", ".", "items", "(", ")", ":", "\n", "            ", "_exceptions", ".", "AssertFormulaInModel", "(", "self", ",", "formula", ")", "\n", "if", "self", "[", "formula", "]", ".", "propositional", ":", "\n", "                ", "_exceptions", ".", "AssertBounds", "(", "fact", ")", "\n", "", "else", ":", "\n", "                ", "_exceptions", ".", "AssertFOLFacts", "(", "fact", ")", "\n", "", "self", "[", "formula", "]", ".", "_add_facts", "(", "fact", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels": [[267, 290], ["labels.items", "_exceptions.AssertFormulaInModel", "model.Model._add_labels", "_exceptions.AssertBounds", "_exceptions.AssertFOLFacts"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_labels"], ["", "", "def", "add_labels", "(", "\n", "self", ",", "\n", "labels", ":", "Union", "[", "\n", "Dict", "[", "str", ",", "Union", "[", "Tuple", "[", "float", ",", "float", "]", ",", "Fact", "]", "]", ",", "\n", "Dict", "[", "\n", "str", ",", "Dict", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ",", "Union", "[", "Tuple", "[", "float", ",", "float", "]", ",", "Fact", "]", "]", "\n", "]", ",", "\n", "]", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"Append labels to the model\n\n        Adding labels to formulae in the model follows the same dictionary\n        input API as\n        [adding facts](https://ibm.github.io/LNN/lnn/LNN.html#lnn.Model.add_facts).  # noqa: E501\n\n        \"\"\"", "\n", "for", "formula", ",", "label", "in", "labels", ".", "items", "(", ")", ":", "\n", "            ", "_exceptions", ".", "AssertFormulaInModel", "(", "self", ",", "formula", ")", "\n", "if", "self", "[", "formula", "]", ".", "propositional", ":", "\n", "                ", "_exceptions", ".", "AssertBounds", "(", "label", ")", "\n", "", "else", ":", "\n", "                ", "_exceptions", ".", "AssertFOLFacts", "(", "label", ")", "\n", "", "self", "[", "formula", "]", ".", "_add_labels", "(", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute": [[291, 316], ["_exceptions.AssertValidDirection", "torch.tensor", "list", "networkx.dfs_postorder_nodes", "list", "hasattr", "reversed", "getattr", "list", "networkx.dfs_postorder_nodes"], "methods", ["None"], ["", "", "def", "_traverse_execute", "(", "\n", "self", ",", "\n", "func", ":", "str", ",", "\n", "direction", ":", "Direction", "=", "Direction", ".", "UPWARD", ",", "\n", "source", ":", "_Formula", "=", "None", ",", "\n", "**", "kwds", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"Traverse over the model and execute a node operation\n\n        Traverses through graph from `source` in the given `direction`\n            and execute `func` at each node\n\n        \"\"\"", "\n", "_exceptions", ".", "AssertValidDirection", "(", "direction", ")", "\n", "nodes", "=", "None", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", ":", "\n", "            ", "nodes", "=", "list", "(", "nx", ".", "dfs_postorder_nodes", "(", "self", ".", "graph", ",", "source", ")", ")", "\n", "", "elif", "direction", "is", "Direction", ".", "DOWNWARD", ":", "\n", "            ", "nodes", "=", "list", "(", "reversed", "(", "list", "(", "nx", ".", "dfs_postorder_nodes", "(", "self", ".", "graph", ",", "source", ")", ")", ")", ")", "\n", "\n", "", "coalesce", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "for", "node", "in", "nodes", ":", "\n", "            ", "val", "=", "getattr", "(", "node", ",", "func", ")", "(", "**", "kwds", ")", "if", "hasattr", "(", "node", ",", "func", ")", "else", "None", "\n", "coalesce", "=", "coalesce", "+", "val", "if", "val", "is", "not", "None", "else", "coalesce", "+", "0.0", "\n", "", "return", "coalesce", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.lifted_preprocessing": [[317, 335], ["model.Model.print"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["", "def", "lifted_preprocessing", "(", "self", ",", "n", ":", "Union", "[", "float", ",", "int", "]", ")", ":", "\n", "        ", "print", "(", "f'\\n{\"*\" * 75}\\n{\"\":<20} Lifted Reasoning Preprocessing'", ")", "\n", "axioms", "=", "lifted_axioms", "(", ")", "\n", "subformulae", "=", "list", "(", ")", "\n", "for", "node", "in", "self", ".", "nodes", ":", "\n", "            ", "if", "self", "[", "node", "]", ".", "world", "is", "World", ".", "AXIOM", ":", "\n", "                ", "subformulae", ".", "append", "(", "self", "[", "node", "]", ")", "\n", "", "", "if", "len", "(", "subformulae", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "for", "_", "in", "range", "(", "int", "(", "n", ")", ")", ":", "\n", "            ", "axiom", ",", "k", "=", "random", ".", "choice", "(", "list", "(", "axioms", ".", "items", "(", ")", ")", ")", "\n", "nodes", "=", "random", ".", "choices", "(", "subformulae", ",", "k", "=", "k", ")", "\n", "result", "=", "axiom", "(", "nodes", ")", "\n", "if", "result", "and", "result", ".", "name", "not", "in", "self", ".", "nodes", ":", "\n", "                ", "self", ".", "add_formulae", "(", "result", ")", "\n", "subformulae", ".", "append", "(", "self", "[", "str", "(", "result", ")", "]", ")", "\n", "print", "(", "f\"Added {str(result)}\"", ")", "\n", "", "", "print", "(", "f'{\"*\" * 75}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer": [[336, 400], ["kwds.get", "torch.tensor", "model.Model.lifted_preprocessing", "model.Model._traverse_execute", "d.value.lower"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.lifted_preprocessing", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute"], ["", "def", "infer", "(", "\n", "self", ",", "\n", "direction", ":", "Direction", "=", "None", ",", "\n", "source", ":", "_Formula", "=", "None", ",", "\n", "max_steps", ":", "int", "=", "None", ",", "\n", "**", "kwds", ",", "\n", ")", ":", "\n", "        ", "r\"\"\"Reasons over all possible inferences until convergence\n\n        **Return**\n\n            steps : int\n                The number of steps taken to converge\n            facts_inferred : Tensor\n                Sum of bounds tightening from inference updates\n\n        **Parameters**\n\n            direction : Direction\n                Can be specified as either UPWARD or DOWNWARD inference, a\n                single pass of that direction will be applied\n                If unspecified, None, defaults to the LNN naive inference\n                strategy of doing upward and downward inference until\n                convergence\n            source : node\n                Specifies starting node for\n                [depth-first search traversal](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.traversal.depth_first_search.dfs_postorder_nodes.html#networkx.algorithms.traversal.depth_first_search.dfs_postorder_nodes)  # noqa: E501\n                The node can be extracted using __getitem__ from the node name\n            max_steps: int\n                Limits the inference to a specified number of passes of the\n                naive traversal strategy\n            kwds\n                lifted : bool or float\n                    Computes lifted inference preprocessing to expand the\n                    knowledge by randomly searching for axioms that can be\n                    applied to the network. If True, defaults to 1e3 random\n                    nodes.\n\n        \"\"\"", "\n", "lifted", "=", "kwds", ".", "get", "(", "\"lifted\"", ")", "\n", "if", "lifted", ":", "\n", "            ", "self", ".", "lifted_preprocessing", "(", "1e3", "if", "lifted", "is", "True", "else", "lifted", ")", "\n", "", "direction", "=", "(", "\n", "[", "Direction", ".", "UPWARD", ",", "Direction", ".", "DOWNWARD", "]", "if", "not", "direction", "else", "[", "direction", "]", "\n", ")", "\n", "converged", "=", "False", "\n", "steps", "=", "0", "\n", "facts_inferred", "=", "torch", ".", "tensor", "(", "0", ")", "\n", "while", "not", "converged", ":", "\n", "            ", "bounds_diff", "=", "0.0", "\n", "for", "d", "in", "direction", ":", "\n", "                ", "bounds_diff", "=", "bounds_diff", "+", "self", ".", "_traverse_execute", "(", "\n", "d", ".", "value", ".", "lower", "(", ")", ",", "d", ",", "source", ",", "**", "kwds", "\n", ")", "\n", "", "converged", "=", "(", "\n", "True", "\n", "if", "direction", "in", "(", "[", "[", "Direction", ".", "UPWARD", "]", ",", "[", "Direction", ".", "DOWNWARD", "]", "]", ")", "\n", "else", "(", "bounds_diff", "<=", "1e-7", ")", "\n", ")", "\n", "facts_inferred", "=", "facts_inferred", "+", "bounds_diff", "\n", "steps", "=", "steps", "+", "1", "\n", "if", "max_steps", "is", "not", "None", "and", "steps", ">=", "max_steps", ":", "\n", "                ", "break", "\n", "", "", "return", "steps", ",", "facts_inferred", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.forward": [[401, 403], ["model.Model.infer"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["", "def", "forward", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "return", "self", ".", "infer", "(", "*", "args", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.upward": [[406, 408], ["model.Model.infer"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["def", "upward", "(", "self", ",", "**", "kwds", ")", ":", "\n", "        ", "return", "self", ".", "infer", "(", "Direction", ".", "UPWARD", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.downward": [[409, 411], ["model.Model.infer"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["", "def", "downward", "(", "self", ",", "**", "kwds", ")", ":", "\n", "        ", "return", "self", ".", "infer", "(", "Direction", ".", "DOWNWARD", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train": [[412, 517], ["kwds.get", "tqdm.tqdm.tqdm", "model.Model.increment_param_history", "torch.optim.Adam", "range", "kwds.get.zero_grad", "model.Model.increment_param_history", "model.Model.infer", "model.Model.loss_fn", "sum", "sum.backward", "kwds.get.step", "model.Model._project_params", "running_loss.append", "loss_history.append", "inference_history.append", "kwds.get", "kwds.get", "int", "model.Model.reset_bounds", "kwds.get", "kwds.get", "RuntimeError", "sum.item", "facts_inferred.item", "kwds.get", "model.Model.parameters", "kwds.get", "kwds.get", "kwds.get", "L.clone().detach().tolist", "L.clone().detach", "L.clone"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._trace.increment_param_history", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._trace.increment_param_history", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.loss_fn", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._project_params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.reset_bounds", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.parameters"], ["", "def", "train", "(", "self", ",", "**", "kwds", ")", ":", "\n", "        ", "r\"\"\"Train the model\n\n        Reasons across the model until convergence using the standard inference\n        strategy - equivalent to running a NN in the forward direction.\n        At the end of each reasoning pass losses are calculated according to a\n        predefined or custom loss and model parameters are updated.\n        An epoch constitutes all computation until parameters take a step.\n\n        **Parameters**\n            kwds\n                losses: list or dict\n                    predefined losses include\n                     ['contradiction', 'uncertainty', 'logical', 'supervised']\n                    If given in dict form, coefficients of each loss can be\n                    specified as a float value. The value can alternatively\n                    specify additional parameters for each loss calculation\n                    using a dict\n\n        **Returns**\n\n            epoch + 1: int\n            total_loss: tuple\n                running_loss: list\n                    sum of loss at the end of each epoch\n                loss_history: Tensor\n                    individual loss components as specified by `losses` kwd\n\n        **Example**\n\n        ```python\n        # construct the model from formulae\n        model = Model()\n        p1, p2 = map(Predicate, ['P1', 'P2'])\n        x = Variable('x')\n        model['AB'] = And(p1(x), p2(x))\n\n        # add data to the model\n        model.add_facts({\n            p1.name: {\n                '0': TRUE,\n                '1': TRUE,\n                '2': FALSE,\n                '3': FALSE\n            },\n            p2.name: {\n                '0': TRUE,\n                '1': FALSE,\n                '2': TRUE,\n                '3': FALSE,\n            }\n        })\n\n        # add supervisory targets\n        model.add_labels({\n            'AB': {\n                '0': TRUE,\n                '1': FALSE,\n                '2': TRUE,\n                '3': FALSE,\n            }\n        })\n\n        # train the model and output results\n        model.train(losses=['supervised'])\n        model.print(params=True)\n        ```\n\n        \"\"\"", "\n", "optimizer", "=", "kwds", ".", "get", "(", "\n", "\"optimizer\"", ",", "\n", "torch", ".", "optim", ".", "Adam", "(", "\n", "kwds", ".", "get", "(", "\"parameters\"", ",", "self", ".", "parameters", "(", ")", ")", ",", "\n", "lr", "=", "kwds", ".", "get", "(", "\"learning_rate\"", ",", "5e-2", ")", ",", "\n", ")", ",", "\n", ")", "\n", "running_loss", ",", "loss_history", ",", "inference_history", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "epoch", "in", "tqdm", "(", "\n", "range", "(", "int", "(", "kwds", ".", "get", "(", "\"epochs\"", ",", "3e2", ")", ")", ")", ",", "\n", "desc", "=", "\"training epoch\"", ",", "\n", "disable", "=", "not", "kwds", ".", "get", "(", "\"pbar\"", ",", "False", ")", ",", "\n", ")", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "if", "epoch", ">", "0", ":", "\n", "                ", "self", ".", "reset_bounds", "(", ")", "\n", "", "self", ".", "increment_param_history", "(", "kwds", ".", "get", "(", "\"parameter_history\"", ")", ")", "\n", "_", ",", "facts_inferred", "=", "self", ".", "infer", "(", "**", "kwds", ")", "\n", "loss_fn", "=", "self", ".", "loss_fn", "(", "kwds", ".", "get", "(", "\"losses\"", ")", ")", "\n", "loss", "=", "sum", "(", "loss_fn", ")", "\n", "if", "not", "loss", ".", "grad_fn", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "\"graph loss found no gradient... \"", "\n", "\"check learning flags, loss functions, labels \"", "\n", "\"or switch to reasoning without learning\"", "\n", ")", "\n", "", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "_project_params", "(", ")", "\n", "running_loss", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "loss_history", ".", "append", "(", "[", "L", ".", "clone", "(", ")", ".", "detach", "(", ")", ".", "tolist", "(", ")", "for", "L", "in", "loss_fn", "]", ")", "\n", "inference_history", ".", "append", "(", "facts_inferred", ".", "item", "(", ")", ")", "\n", "if", "loss", "<=", "1e-5", "and", "kwds", ".", "get", "(", "\"stop_at_convergence\"", ",", "True", ")", ":", "\n", "                ", "break", "\n", "", "", "self", ".", "increment_param_history", "(", "kwds", ".", "get", "(", "\"parameter_history\"", ")", ")", "\n", "return", "(", "running_loss", ",", "loss_history", ")", ",", "inference_history", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.parameters": [[518, 521], ["list", "itertools.chain.from_iterable", "model.Model.parameters"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.parameters"], ["", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "result", "=", "list", "(", "chain", ".", "from_iterable", "(", "[", "self", "[", "n", "]", ".", "parameters", "(", ")", "for", "n", "in", "self", ".", "nodes", "]", ")", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.parameters_grouped_by_neuron": [[522, 534], ["list", "dict", "list", "list", "model.Model.named_parameters", "list.append", "param_group[].append", "param_group[].append"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters"], ["", "def", "parameters_grouped_by_neuron", "(", "self", ")", ":", "\n", "        ", "result", "=", "list", "(", ")", "\n", "for", "n", "in", "self", ".", "nodes", ":", "\n", "            ", "param_group", "=", "dict", "(", ")", "\n", "param_group", "[", "\"params\"", "]", "=", "list", "(", ")", "\n", "param_group", "[", "\"param_names\"", "]", "=", "list", "(", ")", "\n", "for", "name", ",", "param", "in", "self", "[", "n", "]", ".", "named_parameters", "(", ")", ":", "\n", "                ", "param_group", "[", "\"params\"", "]", ".", "append", "(", "param", ")", "\n", "param_group", "[", "\"param_names\"", "]", ".", "append", "(", "name", ")", "\n", "", "param_group", "[", "\"neuron_type\"", "]", "=", "self", "[", "n", "]", ".", "__class__", ".", "__name__", "\n", "result", ".", "append", "(", "param_group", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.named_parameters": [[535, 542], ["dict", "dict.update", "model.Model.named_parameters"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters"], ["", "def", "named_parameters", "(", "self", ")", ":", "\n", "        ", "result", "=", "dict", "(", ")", "\n", "for", "n", "in", "self", ".", "nodes", ":", "\n", "            ", "result", ".", "update", "(", "\n", "{", "f\"{n}.{name}\"", ":", "param", "for", "name", ",", "param", "in", "self", "[", "n", "]", ".", "named_parameters", "(", ")", "}", "\n", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.fit": [[543, 546], ["model.Model.train"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train"], ["", "def", "fit", "(", "self", ",", "**", "kwds", ")", ":", "\n", "        ", "\"\"\"Alias for train\"\"\"", "\n", "return", "self", ".", "train", "(", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.loss_fn": [[549, 581], ["list", "Exception", "isinstance", "losses[].values", "list.append", "isinstance", "TypeError", "torch.tensor", "list", "list.append", "isinstance", "model.Model._traverse_execute", "networkx.dfs_postorder_nodes", "model.Model.loss_fn"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.loss_fn"], ["def", "loss_fn", "(", "self", ",", "losses", ")", ":", "\n", "        ", "loss_names", "=", "[", "\"contradiction\"", ",", "\"uncertainty\"", ",", "\"logical\"", ",", "\"supervised\"", ",", "\"custom\"", "]", "\n", "if", "losses", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "\n", "\"no loss function given, \"", "\n", "f\"expected losses from the following {loss_names}\"", "\n", ")", "\n", "", "elif", "isinstance", "(", "losses", ",", "list", ")", ":", "\n", "            ", "losses", "=", "{", "c", ":", "None", "for", "c", "in", "losses", "}", "\n", "", "result", "=", "list", "(", ")", "\n", "for", "loss", "in", "losses", ":", "\n", "            ", "if", "loss", "in", "loss_names", ":", "\n", "                ", "if", "loss", "==", "\"custom\"", ":", "\n", "                    ", "if", "not", "isinstance", "(", "losses", "[", "loss", "]", ",", "dict", ")", ":", "\n", "                        ", "raise", "TypeError", "(", "\n", "\"custom losses expected as a dict with keys as \"", "\n", "\"name of the loss and values as function \"", "\n", "\"definitions\"", "\n", ")", "\n", "", "for", "loss_fn", "in", "losses", "[", "loss", "]", ".", "values", "(", ")", ":", "\n", "                        ", "coalesce", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "for", "node", "in", "list", "(", "nx", ".", "dfs_postorder_nodes", "(", "self", ".", "graph", ")", ")", ":", "\n", "                            ", "coalesce", "=", "coalesce", "+", "loss_fn", "(", "node", ")", "\n", "", "result", ".", "append", "(", "coalesce", ")", "\n", "", "", "else", ":", "\n", "                    ", "kwds", "=", "(", "\n", "losses", "[", "loss", "]", "\n", "if", "(", "isinstance", "(", "losses", "[", "loss", "]", ",", "dict", ")", ")", "\n", "else", "(", "{", "\"coeff\"", ":", "losses", "[", "loss", "]", "}", ")", "\n", ")", "\n", "result", ".", "append", "(", "self", ".", "_traverse_execute", "(", "f\"{loss}_loss\"", ",", "**", "kwds", ")", ")", "\n", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.print": [[582, 600], ["model.Model.print"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["", "def", "print", "(", "\n", "self", ",", "\n", "header_len", ":", "int", "=", "50", ",", "\n", "roundoff", ":", "int", "=", "5", ",", "\n", "params", ":", "bool", "=", "False", ",", "\n", "grads", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "n", "=", "header_len", "+", "25", "\n", "print", "(", "\"\\n\"", "+", "\"*\"", "*", "n", "+", "f'\\n{\"\":<{n/2 - 5}}LNN {self.name}\\n'", ")", "\n", "self", ".", "_traverse_execute", "(", "\n", "\"print\"", ",", "\n", "Direction", ".", "DOWNWARD", ",", "\n", "header_len", "=", "header_len", ",", "\n", "roundoff", "=", "roundoff", ",", "\n", "params", "=", "params", ",", "\n", "grads", "=", "grads", ",", "\n", ")", "\n", "print", "(", "\"*\"", "*", "n", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.flush": [[601, 603], ["model.Model._traverse_execute"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "self", ".", "_traverse_execute", "(", "\"flush\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.reset_bounds": [[604, 606], ["model.Model._traverse_execute"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute"], ["", "def", "reset_bounds", "(", "self", ")", ":", "\n", "        ", "self", ".", "_traverse_execute", "(", "\"reset_bounds\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._project_params": [[607, 609], ["model.Model._traverse_execute"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute"], ["", "def", "_project_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "_traverse_execute", "(", "\"project_params\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.increment_param_history": [[610, 614], ["model.Model._traverse_execute"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model._traverse_execute"], ["", "def", "increment_param_history", "(", "self", ",", "parameter_history", ")", ":", "\n", "        ", "if", "parameter_history", ":", "\n", "            ", "self", ".", "_traverse_execute", "(", "\n", "\"increment_param_history\"", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table": [[22, 26], ["list", "itertools.product"], "function", ["None"], ["def", "truth_table", "(", "n", ":", "int", ",", "states", "=", "None", ")", "->", "List", "[", "Tuple", "[", "Fact", ",", "...", "]", "]", ":", "\n", "    ", "if", "states", "is", "None", ":", "\n", "        ", "states", "=", "[", "FALSE", ",", "TRUE", "]", "\n", "", "return", "list", "(", "itertools", ".", "product", "(", "states", ",", "repeat", "=", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table_dict": [[28, 33], ["itertools.product", "len", "dict", "zip"], "function", ["None"], ["", "def", "truth_table_dict", "(", "*", "args", ":", "str", ",", "states", "=", "None", ")", ":", "\n", "    ", "if", "states", "is", "None", ":", "\n", "        ", "states", "=", "[", "FALSE", ",", "TRUE", "]", "\n", "", "for", "instance", "in", "itertools", ".", "product", "(", "states", ",", "repeat", "=", "len", "(", "args", ")", ")", ":", "\n", "        ", "yield", "dict", "(", "zip", "(", "args", ",", "instance", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.fact_to_bool": [[35, 44], ["len", "tuple", "map"], "function", ["None"], ["", "", "def", "fact_to_bool", "(", "*", "fact", ":", "Fact", ")", "->", "Union", "[", "Fact", ",", "bool", ",", "Tuple", "[", "bool", ",", "...", "]", "]", ":", "\n", "    ", "if", "len", "(", "fact", ")", ">", "1", ":", "\n", "        ", "return", "tuple", "(", "map", "(", "fact_to_bool", ",", "fact", ")", ")", "\n", "", "if", "fact", "[", "0", "]", "is", "TRUE", ":", "\n", "        ", "return", "True", "\n", "", "elif", "fact", "[", "0", "]", "is", "FALSE", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "return", "fact", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact": [[46, 50], ["len", "tuple", "map"], "function", ["None"], ["", "", "def", "bool_to_fact", "(", "*", "truth", ":", "bool", ")", "->", "Union", "[", "Fact", ",", "Tuple", "[", "Fact", ",", "...", "]", "]", ":", "\n", "    ", "if", "len", "(", "truth", ")", ">", "1", ":", "\n", "        ", "return", "tuple", "(", "map", "(", "bool_to_fact", ",", "truth", ")", ")", "\n", "", "return", "TRUE", "if", "truth", "[", "0", "]", "else", "FALSE", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.predicate_truth_table": [[52, 77], ["len", "numpy.array", "list", "enumerate", "utils.truth_table", "range", "Predicate", "random.shuffle", "len", "TT[].item", "model[].add_facts"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts"], ["", "def", "predicate_truth_table", "(", "*", "args", ":", "str", ",", "arity", ":", "int", ",", "model", ",", "states", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    predicate_truth_table('p', 'q', 'r', model=model)\n\n    randomises the truth table into a predicate by str(int) rows\n\n    **Returns**\n\n    model\n    \"\"\"", "\n", "if", "states", "is", "None", ":", "\n", "        ", "states", "=", "[", "FALSE", ",", "TRUE", "]", "\n", "", "from", "lnn", "import", "Predicate", "# noqa: F401", "\n", "\n", "n", "=", "len", "(", "args", ")", "\n", "TT", "=", "np", ".", "array", "(", "truth_table", "(", "n", ",", "states", ")", ")", "\n", "_range", "=", "list", "(", "range", "(", "len", "(", "TT", ")", ")", ")", "\n", "for", "idx", ",", "arg", "in", "enumerate", "(", "args", ")", ":", "\n", "        ", "model", "[", "arg", "]", "=", "Predicate", "(", "arity", "=", "arity", ")", "\n", "random", ".", "shuffle", "(", "_range", ")", "\n", "for", "i", "in", "_range", ":", "\n", "            ", "grounding", "=", "f\"{i}\"", "if", "arity", "==", "1", "else", "(", "f\"{i}\"", ",", ")", "*", "arity", "\n", "truth", "=", "TT", "[", "i", ",", "idx", "]", ".", "item", "(", ")", "\n", "model", "[", "arg", "]", ".", "add_facts", "(", "{", "grounding", ":", "truth", "}", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.plot_graph": [[79, 98], ["options.update", "networkx.drawing.nx_agraph.graphviz_layout", "networkx.draw", "plt.show"], "function", ["None"], ["", "def", "plot_graph", "(", "self", ",", "**", "kwds", ")", "->", "None", ":", "\n", "    ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "labels", "=", "{", "node", ":", "f\"{node.__class__.__name__}\\n{node}\"", "for", "node", "in", "self", ".", "graph", "}", "\n", "\n", "options", "=", "{", "\n", "\"with_labels\"", ":", "True", ",", "\n", "\"arrows\"", ":", "True", ",", "\n", "\"edge_color\"", ":", "\"#d0e2ff\"", ",", "\n", "\"node_size\"", ":", "1", ",", "\n", "\"font_size\"", ":", "9", ",", "\n", "\"labels\"", ":", "labels", ",", "\n", "}", "\n", "\n", "options", ".", "update", "(", "kwds", ")", "\n", "pos", "=", "nx", ".", "drawing", ".", "nx_agraph", ".", "graphviz_layout", "(", "self", ".", "graph", ",", "prog", "=", "\"dot\"", ")", "\n", "nx", ".", "draw", "(", "self", ".", "graph", ",", "pos", ",", "**", "options", ")", "\n", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.plot_loss": [[100, 113], ["plt.subplots", "fig.suptitle", "axs[].plot", "axs[].legend", "axs[].plot", "axs[].legend", "plt.show", "numpy.array", "ax.set", "numpy.array", "str.capitalize"], "function", ["None"], ["", "def", "plot_loss", "(", "total_loss", ",", "losses", ")", "->", "None", ":", "\n", "    ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "loss", ",", "cummulative_loss", "=", "total_loss", "\n", "fig", ",", "axs", "=", "plt", ".", "subplots", "(", "1", ",", "2", ")", "\n", "fig", ".", "suptitle", "(", "\"Model Loss\"", ")", "\n", "axs", "[", "0", "]", ".", "plot", "(", "np", ".", "array", "(", "loss", ")", ")", "\n", "for", "ax", "in", "axs", ".", "flat", ":", "\n", "        ", "ax", ".", "set", "(", "xlabel", "=", "\"Epochs\"", ",", "ylabel", "=", "\"Loss\"", ")", "\n", "", "axs", "[", "0", "]", ".", "legend", "(", "[", "\"Total Loss\"", "]", ")", "\n", "axs", "[", "1", "]", ".", "plot", "(", "np", ".", "array", "(", "cummulative_loss", ")", ")", "\n", "axs", "[", "1", "]", ".", "legend", "(", "[", "str", ".", "capitalize", "(", "i", ")", "for", "i", "in", "losses", "]", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.plot_params": [[118, 139], ["plt.xlabel", "plt.legend", "plt.title", "plt.show", "hasattr", "utils..parameter_history.items", "isinstance", "plt.plot", "list", "legend.append", "list", "range", "len"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items"], ["def", "plot_params", "(", "self", ":", "Model", ")", "->", "None", ":", "\n", "    ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "\n", "legend", "=", "[", "]", "\n", "for", "node", "in", "self", ".", "nodes", ":", "\n", "        ", "if", "hasattr", "(", "self", "[", "node", "]", ",", "\"parameter_history\"", ")", ":", "\n", "            ", "for", "param", ",", "data", "in", "self", "[", "node", "]", ".", "parameter_history", ".", "items", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "data", "[", "0", "]", ",", "list", ")", ":", "\n", "                    ", "operands", "=", "list", "(", "self", "[", "node", "]", ".", "operands", ")", "\n", "legend_idxs", "=", "[", "f\"_{operands[i]}\"", "for", "i", "in", "list", "(", "range", "(", "len", "(", "data", "[", "0", "]", ")", ")", ")", "]", "\n", "", "else", ":", "\n", "                    ", "legend_idxs", "=", "[", "\"\"", "]", "\n", "", "[", "\n", "legend", ".", "append", "(", "f\"{node} {_utils.param_symbols[param]}{i}\"", ")", "\n", "for", "i", "in", "legend_idxs", "\n", "]", "\n", "plt", ".", "plot", "(", "data", ")", "\n", "", "", "", "plt", ".", "xlabel", "(", "\"Epochs\"", ")", "\n", "plt", ".", "legend", "(", "legend", ")", "\n", "plt", ".", "title", "(", "f\"{self.name} Parameters\"", ")", "\n", "plt", ".", "show", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.neuron._NeuronParameters.__init__": [[14, 26], ["node._NodeParameters.__init__", "_exceptions.AssertAlphaNeuronArityValue", "kwds.get", "_exceptions.AssertBias", "neuron._NeuronParameters.add_param", "neuron._NeuronParameters.bias.requires_grad_", "kwds.get", "_exceptions.AssertWeights", "neuron._NeuronParameters.add_param", "neuron._NeuronParameters.weights.requires_grad_", "torch.tensor", "kwds.get", "torch.tensor", "kwds.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_param", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_param"], ["    ", "def", "__init__", "(", "self", ",", "propositional", ",", "arity", ",", "truth", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "propositional", ",", "truth", ",", "**", "kwds", ")", "\n", "self", ".", "arity", "=", "arity", "\n", "_exceptions", ".", "AssertAlphaNeuronArityValue", "(", "self", ".", "alpha", ",", "self", ".", "arity", ")", "\n", "bias", "=", "kwds", ".", "get", "(", "\"bias\"", ",", "1.0", ")", "\n", "_exceptions", ".", "AssertBias", "(", "bias", ")", "\n", "self", ".", "bias", "=", "self", ".", "add_param", "(", "\"bias\"", ",", "torch", ".", "tensor", "(", "bias", ")", ")", "\n", "self", ".", "bias", ".", "requires_grad_", "(", "kwds", ".", "get", "(", "\"bias_learning\"", ",", "True", ")", ")", "\n", "weights", "=", "kwds", ".", "get", "(", "\"weights\"", ",", "(", "1.0", ",", ")", "*", "arity", ")", "\n", "_exceptions", ".", "AssertWeights", "(", "weights", ",", "arity", ")", "\n", "self", ".", "weights", "=", "self", ".", "add_param", "(", "\"weights\"", ",", "torch", ".", "tensor", "(", "weights", ")", ")", "\n", "self", ".", "weights", ".", "requires_grad_", "(", "kwds", ".", "get", "(", "\"weights_learning\"", ",", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.neuron._NeuronParameters.project_params": [[27, 31], ["torch.no_grad", "neuron._NeuronParameters.weights.data.clamp", "neuron._NeuronParameters.bias.data.clamp"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "project_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "weights", ".", "data", "=", "self", ".", "weights", ".", "data", ".", "clamp", "(", "0", ",", "1", ")", "\n", "self", ".", "bias", ".", "data", "=", "self", ".", "bias", ".", "data", ".", "clamp", "(", "0", ",", "self", ".", "arity", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.__init__": [[44, 63], ["node._NodeParameters.add_param", "_exceptions.AssertAlphaNodeValue", "kwds.get", "_utils.fact_to_bounds", "node._NodeParameters.leaves.clone", "torch.tensor", "node._NodeParameters.extend_groundings", "kwds.get", "math.erf", "kwds.get", "kwds.get", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_param", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.extend_groundings"], ["def", "__init__", "(", "self", ",", "propositional", ":", "bool", ",", "world", ":", "World", ",", "**", "kwds", ")", ":", "\n", "        ", "self", ".", "params", "=", "{", "}", "\n", "self", ".", "propositional", "=", "propositional", "\n", "self", ".", "world", "=", "world", "\n", "self", ".", "alpha", "=", "self", ".", "add_param", "(", "\n", "\"alpha\"", ",", "\n", "torch", ".", "tensor", "(", "\n", "kwds", ".", "get", "(", "\"alpha\"", ",", "math", ".", "erf", "(", "kwds", ".", "get", "(", "\"alpha_sigma\"", ",", "10", ")", "/", "math", ".", "sqrt", "(", "2", ")", ")", ")", ",", "\n", "requires_grad", "=", "kwds", ".", "get", "(", "\"alpha_learning\"", ",", "False", ")", ",", "\n", ")", ",", "\n", ")", "\n", "_exceptions", ".", "AssertAlphaNodeValue", "(", "self", ".", "alpha", ")", "\n", "self", ".", "bounds_learning", "=", "kwds", ".", "get", "(", "\"bounds_learning\"", ",", "False", ")", "\n", "self", ".", "leaves", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "self", ".", "world", ",", "self", ".", "propositional", ",", "[", "0", "]", ",", "requires_grad", "=", "self", ".", "bounds_learning", "\n", ")", "\n", "self", ".", "bounds_table", "=", "self", ".", "leaves", ".", "clone", "(", ")", "\n", "if", "propositional", ":", "\n", "            ", "self", ".", "extend_groundings", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.set_world": [[64, 66], ["None"], "methods", ["None"], ["", "", "def", "set_world", "(", "self", ",", "world", ":", "World", ")", ":", "\n", "        ", "self", ".", "world", "=", "world", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_param": [[67, 70], ["None"], "methods", ["None"], ["", "def", "add_param", "(", "self", ",", "name", ",", "param", ")", ":", "\n", "        ", "self", ".", "params", "[", "name", "]", "=", "param", "\n", "return", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.flush": [[71, 73], ["node._NodeParameters.add_facts"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts"], ["", "def", "flush", "(", "self", ",", "bounds_table", "=", "None", ")", ":", "\n", "        ", "self", ".", "add_facts", "(", "{", "Fact", ".", "UNKNOWN", "}", ",", "bounds_table", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.get_facts": [[74, 85], ["isinstance"], "methods", ["None"], ["", "def", "get_facts", "(", "self", ",", "grounding_rows", ":", "List", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"returns tuple of all facts given by `grounding_rows`\n        The `bounds_table` is returned if no `grounding_rows` given\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "return", "self", ".", "bounds_table", "[", "0", "]", "\n", "", "if", "grounding_rows", "is", "None", ":", "\n", "            ", "return", "self", ".", "bounds_table", "\n", "", "if", "isinstance", "(", "grounding_rows", ",", "list", ")", ":", "\n", "            ", "return", "self", ".", "bounds_table", "[", "grounding_rows", "]", "\n", "", "return", "self", ".", "bounds_table", "[", "grounding_rows", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts": [[86, 107], ["isinstance", "isinstance", "node._NodeParameters.update_bounds", "isinstance", "node._NodeParameters.update_bounds", "next", "next.items", "set", "next", "iter", "iter", "node._NodeParameters.update_bounds", "Exception"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.update_bounds", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.update_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.update_bounds"], ["", "def", "add_facts", "(", "self", ",", "facts", ":", "Union", "[", "Fact", ",", "Tuple", ",", "Set", ",", "Dict", "]", ",", "update_leaves", "=", "False", ")", ":", "\n", "        ", "\"\"\"Populate formula with facts\n\n        Facts given in bool, tuple or None, assumes a propositional formula\n        Facts given in dict form assume FOL, keyed by the tensor index, w\n            the value also required in bool, Tuple or None\n\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "# Propositional facts", "\n", "            ", "if", "isinstance", "(", "facts", ",", "set", ")", ":", "\n", "                ", "facts", "=", "next", "(", "iter", "(", "facts", ")", ")", "\n", "", "self", ".", "update_bounds", "(", "0", ",", "facts", ",", "update_leaves", ")", "\n", "", "else", ":", "# FOL facts", "\n", "            ", "if", "isinstance", "(", "facts", ",", "dict", ")", ":", "# facts given per grounding", "\n", "                ", "for", "grounding_row", ",", "fact", "in", "facts", ".", "items", "(", ")", ":", "\n", "                    ", "if", "grounding_row", "<", "self", ".", "leaves", ".", "shape", "[", "self", ".", "_grounding_dims", "]", ":", "\n", "                        ", "self", ".", "update_bounds", "(", "grounding_row", ",", "fact", ",", "update_leaves", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "Exception", "(", "\"groundings not extended correctly\"", ")", "\n", "", "", "", "", "if", "isinstance", "(", "facts", ",", "set", ")", ":", "# broadcast facts across groundings", "\n", "            ", "self", ".", "update_bounds", "(", "set", "(", ")", ",", "next", "(", "iter", "(", "facts", ")", ")", ",", "update_leaves", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.update_bounds": [[108, 141], ["isinstance", "_utils.fact_to_bounds", "_utils.fact_to_bounds", "_utils.fact_to_bounds.clone", "_utils.fact_to_bounds", "isinstance", "isinstance", "node._NodeParameters.update_bounds.func"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds"], ["", "", "def", "update_bounds", "(", "\n", "self", ",", "\n", "grounding_rows", ":", "Optional", "[", "Union", "[", "int", ",", "Set", ",", "Dict", ",", "None", "]", "]", ",", "\n", "facts", ":", "Union", "[", "torch", ".", "Tensor", ",", "Fact", "]", ",", "\n", "update_leaves", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"update bounds with facts for given grounding_rows\n\n        if grounding_rows is None, assumes propositional\n\n        \"\"\"", "\n", "\n", "def", "func", "(", "grounding_row", ",", "fact", ")", ":", "\n", "            ", "if", "update_leaves", ":", "\n", "                ", "fact", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "fact", ",", "self", ".", "propositional", ",", "requires_grad", "=", "self", ".", "bounds_learning", "\n", ")", "\n", "self", ".", "leaves", "[", "grounding_row", "]", "=", "fact", "\n", "self", ".", "bounds_table", "[", "grounding_row", "]", "=", "fact", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                ", "fact", "=", "_utils", ".", "fact_to_bounds", "(", "fact", ",", "self", ".", "propositional", ")", "\n", "self", ".", "bounds_table", "[", "grounding_row", "]", "=", "fact", "\n", "\n", "", "", "if", "isinstance", "(", "grounding_rows", ",", "set", ")", ":", "\n", "            ", "facts", "=", "_utils", ".", "fact_to_bounds", "(", "facts", ",", "self", ".", "propositional", ")", "\n", "if", "not", "self", ".", "propositional", ":", "\n", "                ", "facts", "=", "facts", "[", "0", "]", "\n", "", "self", ".", "bounds_table", "[", "...", ",", "0", "]", "=", "facts", "[", "0", "]", "\n", "self", ".", "bounds_table", "[", "...", ",", "1", "]", "=", "facts", "[", "1", "]", "\n", "", "elif", "isinstance", "(", "grounding_rows", ",", "dict", ")", "or", "isinstance", "(", "grounding_rows", ",", "list", ")", ":", "\n", "            ", "[", "func", "(", "*", "_", ")", "for", "_", "in", "zip", "(", "grounding_rows", ",", "facts", ")", "]", "\n", "", "else", ":", "\n", "            ", "func", "(", "grounding_rows", ",", "facts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.extend_groundings": [[142, 157], ["_utils.fact_to_bounds", "torch.cat", "torch.cat", "list", "Exception", "range", "_utils.fact_to_bounds.clone", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds"], ["", "", "def", "extend_groundings", "(", "self", ",", "n", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"extend the `bounds_table` number of groundings by n\n\n        returns list of new bounds_table row numbers\n\n        \"\"\"", "\n", "if", "n", "<=", "0", ":", "\n", "            ", "raise", "Exception", "(", "f\"n expected as int > 0, received {type(n), n}\"", ")", "\n", "", "n_groundings", "=", "self", ".", "bounds_table", ".", "shape", "[", "self", ".", "_grounding_dims", "]", "\n", "new_leaves", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "self", ".", "world", ",", "self", ".", "propositional", ",", "[", "n", "]", ",", "requires_grad", "=", "self", ".", "bounds_learning", "\n", ")", "\n", "self", ".", "leaves", "=", "torch", ".", "cat", "(", "[", "self", ".", "leaves", ",", "new_leaves", "]", ")", "\n", "self", ".", "bounds_table", "=", "torch", ".", "cat", "(", "[", "self", ".", "bounds_table", ",", "new_leaves", ".", "clone", "(", ")", "]", ")", "\n", "return", "list", "(", "range", "(", "n_groundings", ",", "n_groundings", "+", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters._grounding_dims": [[158, 164], ["node._NodeParameters.bounds_table.dim"], "methods", ["None"], ["", "@", "property", "\n", "def", "_grounding_dims", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns int of grounding dim in bounds table\"\"\"", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "return", "0", "\n", "", "return", "1", "if", "self", ".", "bounds_table", ".", "dim", "(", ")", "==", "3", "else", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.reset_bounds": [[165, 168], ["node._NodeParameters.leaves.clone"], "methods", ["None"], ["", "def", "reset_bounds", "(", "self", ")", ":", "\n", "        ", "\"\"\"restores bounds_table to default state of leaves\"\"\"", "\n", "self", ".", "bounds_table", "=", "self", ".", "leaves", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.project_params": [[169, 172], ["torch.no_grad", "node._NodeParameters.alpha.data.clamp"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "project_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "alpha", ".", "data", "=", "self", ".", "alpha", ".", "data", ".", "clamp", "(", "0.5", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.project_bounds": [[173, 176], ["torch.no_grad", "node._NodeParameters.bounds_table.data.clamp"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "project_bounds", "(", "self", ")", ":", "\n", "        ", "self", ".", "bounds_table", ".", "data", "=", "self", ".", "bounds_table", ".", "data", ".", "clamp", "(", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.named_parameters": [[177, 184], ["node._NodeParameters.params.items", "enumerate"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items"], ["", "def", "named_parameters", "(", "self", ")", "->", "Iterator", "[", "Tuple", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "for", "name", ",", "param", "in", "self", ".", "params", ".", "items", "(", ")", ":", "\n", "            ", "yield", "name", ",", "param", "\n", "", "if", "self", ".", "bounds_learning", ":", "\n", "            ", "for", "idx", ",", "param", "in", "enumerate", "(", "self", ".", "leaves", ")", ":", "\n", "                ", "if", "param", ".", "requires_grad", "and", "param", ".", "is_leaf", ":", "\n", "                    ", "yield", "f\"bounds_{idx}\"", ",", "param", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.parameters.model._ModelParameters.__init__": [[9, 11], ["None"], "methods", ["None"], ["from", "itertools", "import", "chain", "\n", "from", "typing", "import", "Union", ",", "Dict", ",", "Tuple", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.__init__": [[22, 26], ["parameters.node._NodeParameters.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], []], "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds": [[27, 61], ["node._NodeActivation.get_facts().clone", "kwds.get", "node._NodeActivation.update_bounds", "NotImplementedError", "torch.stack", "_utils.val_clamp", "node._NodeActivation.get_facts", "torch.max", "torch.min"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.update_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.val_clamp", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts"], ["\n", "\n", "def", "__init__", "(", "self", ",", "propositional", ":", "bool", ",", "world", ":", "World", ",", "**", "kwds", ")", ":", "\n", "        ", "self", ".", "params", "=", "{", "}", "\n", "self", ".", "propositional", "=", "propositional", "\n", "self", ".", "world", "=", "world", "\n", "self", ".", "alpha", "=", "self", ".", "add_param", "(", "\n", "\"alpha\"", ",", "\n", "torch", ".", "tensor", "(", "\n", "kwds", ".", "get", "(", "\"alpha\"", ",", "math", ".", "erf", "(", "kwds", ".", "get", "(", "\"alpha_sigma\"", ",", "10", ")", "/", "math", ".", "sqrt", "(", "2", ")", ")", ")", ",", "\n", "requires_grad", "=", "kwds", ".", "get", "(", "\"alpha_learning\"", ",", "False", ")", ",", "\n", ")", ",", "\n", ")", "\n", "_exceptions", ".", "AssertAlphaNodeValue", "(", "self", ".", "alpha", ")", "\n", "self", ".", "bounds_learning", "=", "kwds", ".", "get", "(", "\"bounds_learning\"", ",", "False", ")", "\n", "self", ".", "leaves", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "self", ".", "world", ",", "self", ".", "propositional", ",", "[", "0", "]", ",", "requires_grad", "=", "self", ".", "bounds_learning", "\n", ")", "\n", "self", ".", "bounds_table", "=", "self", ".", "leaves", ".", "clone", "(", ")", "\n", "if", "propositional", ":", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.output_regions": [[62, 85], ["torch.zeros_like", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.masked_fill", "node.bool_and", "node.bool_and", "Exception"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and"], ["            ", "self", ".", "extend_groundings", "(", ")", "\n", "\n", "", "", "def", "set_world", "(", "self", ",", "world", ":", "World", ")", ":", "\n", "        ", "self", ".", "world", "=", "world", "\n", "\n", "", "def", "add_param", "(", "self", ",", "name", ",", "param", ")", ":", "\n", "        ", "self", ".", "params", "[", "name", "]", "=", "param", "\n", "return", "param", "\n", "\n", "", "def", "flush", "(", "self", ",", "bounds_table", "=", "None", ")", ":", "\n", "        ", "self", ".", "add_facts", "(", "{", "Fact", ".", "UNKNOWN", "}", ",", "bounds_table", ")", "\n", "\n", "", "def", "get_facts", "(", "self", ",", "grounding_rows", ":", "List", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"returns tuple of all facts given by `grounding_rows`\n        The `bounds_table` is returned if no `grounding_rows` given\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "return", "self", ".", "bounds_table", "[", "0", "]", "\n", "", "if", "grounding_rows", "is", "None", ":", "\n", "            ", "return", "self", ".", "bounds_table", "\n", "", "if", "isinstance", "(", "grounding_rows", ",", "list", ")", ":", "\n", "            ", "return", "self", ".", "bounds_table", "[", "grounding_rows", "]", "\n", "", "return", "self", ".", "bounds_table", "[", "grounding_rows", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation._get_state_vars": [[86, 97], ["node._NodeActivation.output_regions().numpy().astype", "numpy.zeros_like().astype", "node._NodeActivation.get_facts", "node._NodeActivation.output_regions().numpy", "numpy.zeros_like", "node._NodeActivation.output_regions"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.output_regions"], ["", "def", "add_facts", "(", "self", ",", "facts", ":", "Union", "[", "Fact", ",", "Tuple", ",", "Set", ",", "Dict", "]", ",", "update_leaves", "=", "False", ")", ":", "\n", "        ", "\"\"\"Populate formula with facts\n\n        Facts given in bool, tuple or None, assumes a propositional formula\n        Facts given in dict form assume FOL, keyed by the tensor index, w\n            the value also required in bool, Tuple or None\n\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "# Propositional facts", "\n", "            ", "if", "isinstance", "(", "facts", ",", "set", ")", ":", "\n", "                ", "facts", "=", "next", "(", "iter", "(", "facts", ")", ")", "\n", "", "self", ".", "update_bounds", "(", "0", ",", "facts", ",", "update_leaves", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.is_contradiction": [[98, 119], ["node.bool_and", "node._NodeActivation._get_state_vars", "bool_and().logical_not", "bool_and().logical_not", "node.bool_and", "node.bool_and"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation._get_state_vars", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and"], ["", "else", ":", "# FOL facts", "\n", "            ", "if", "isinstance", "(", "facts", ",", "dict", ")", ":", "# facts given per grounding", "\n", "                ", "for", "grounding_row", ",", "fact", "in", "facts", ".", "items", "(", ")", ":", "\n", "                    ", "if", "grounding_row", "<", "self", ".", "leaves", ".", "shape", "[", "self", ".", "_grounding_dims", "]", ":", "\n", "                        ", "self", ".", "update_bounds", "(", "grounding_row", ",", "fact", ",", "update_leaves", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "Exception", "(", "\"groundings not extended correctly\"", ")", "\n", "", "", "", "", "if", "isinstance", "(", "facts", ",", "set", ")", ":", "# broadcast facts across groundings", "\n", "            ", "self", ".", "update_bounds", "(", "set", "(", ")", ",", "next", "(", "iter", "(", "facts", ")", ")", ",", "update_leaves", ")", "\n", "\n", "", "", "def", "update_bounds", "(", "\n", "self", ",", "\n", "grounding_rows", ":", "Optional", "[", "Union", "[", "int", ",", "Set", ",", "Dict", ",", "None", "]", "]", ",", "\n", "facts", ":", "Union", "[", "torch", ".", "Tensor", ",", "Fact", "]", ",", "\n", "update_leaves", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"update bounds with facts for given grounding_rows\n\n        if grounding_rows is None, assumes propositional\n\n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.state": [[120, 167], ["node._NodeActivation._get_state_vars", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "node.bool_and", "node.bool_and", "node.bool_and", "node.bool_and", "node._NodeActivation.is_contradiction", "node.bool_and", "node.bool_and", "node.bool_or", "Exception", "node.bool_and", "node.bool_and", "node.bool_and"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation._get_state_vars", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_or", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and", "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and"], ["def", "func", "(", "grounding_row", ",", "fact", ")", ":", "\n", "            ", "if", "update_leaves", ":", "\n", "                ", "fact", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "fact", ",", "self", ".", "propositional", ",", "requires_grad", "=", "self", ".", "bounds_learning", "\n", ")", "\n", "self", ".", "leaves", "[", "grounding_row", "]", "=", "fact", "\n", "self", ".", "bounds_table", "[", "grounding_row", "]", "=", "fact", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                ", "fact", "=", "_utils", ".", "fact_to_bounds", "(", "fact", ",", "self", ".", "propositional", ")", "\n", "self", ".", "bounds_table", "[", "grounding_row", "]", "=", "fact", "\n", "\n", "", "", "if", "isinstance", "(", "grounding_rows", ",", "set", ")", ":", "\n", "            ", "facts", "=", "_utils", ".", "fact_to_bounds", "(", "facts", ",", "self", ".", "propositional", ")", "\n", "if", "not", "self", ".", "propositional", ":", "\n", "                ", "facts", "=", "facts", "[", "0", "]", "\n", "", "self", ".", "bounds_table", "[", "...", ",", "0", "]", "=", "facts", "[", "0", "]", "\n", "self", ".", "bounds_table", "[", "...", ",", "1", "]", "=", "facts", "[", "1", "]", "\n", "", "elif", "isinstance", "(", "grounding_rows", ",", "dict", ")", "or", "isinstance", "(", "grounding_rows", ",", "list", ")", ":", "\n", "            ", "[", "func", "(", "*", "_", ")", "for", "_", "in", "zip", "(", "grounding_rows", ",", "facts", ")", "]", "\n", "", "else", ":", "\n", "            ", "func", "(", "grounding_rows", ",", "facts", ")", "\n", "\n", "", "", "def", "extend_groundings", "(", "self", ",", "n", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"extend the `bounds_table` number of groundings by n\n\n        returns list of new bounds_table row numbers\n\n        \"\"\"", "\n", "if", "n", "<=", "0", ":", "\n", "            ", "raise", "Exception", "(", "f\"n expected as int > 0, received {type(n), n}\"", ")", "\n", "", "n_groundings", "=", "self", ".", "bounds_table", ".", "shape", "[", "self", ".", "_grounding_dims", "]", "\n", "new_leaves", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "self", ".", "world", ",", "self", ".", "propositional", ",", "[", "n", "]", ",", "requires_grad", "=", "self", ".", "bounds_learning", "\n", ")", "\n", "self", ".", "leaves", "=", "torch", ".", "cat", "(", "[", "self", ".", "leaves", ",", "new_leaves", "]", ")", "\n", "self", ".", "bounds_table", "=", "torch", ".", "cat", "(", "[", "self", ".", "bounds_table", ",", "new_leaves", ".", "clone", "(", ")", "]", ")", "\n", "return", "list", "(", "range", "(", "n_groundings", ",", "n_groundings", "+", "n", ")", ")", "\n", "\n", "", "@", "property", "\n", "def", "_grounding_dims", "(", "self", ")", ":", "\n", "        ", "\"\"\"returns int of grounding dim in bounds table\"\"\"", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "return", "0", "\n", "", "return", "1", "if", "self", ".", "bounds_table", ".", "dim", "(", ")", "==", "3", "else", "0", "\n", "\n", "", "def", "reset_bounds", "(", "self", ")", ":", "\n", "        ", "\"\"\"restores bounds_table to default state of leaves\"\"\"", "\n", "self", ".", "bounds_table", "=", "self", ".", "leaves", ".", "clone", "(", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node.tensorise": [[169, 174], ["isinstance", "t.clone().detach", "torch.tensor().detach", "t.clone", "torch.tensor"], "function", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "project_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "alpha", ".", "data", "=", "self", ".", "alpha", ".", "data", ".", "clamp", "(", "0.5", ",", "1", ")", "\n", "\n", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "project_bounds", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_and": [[177, 179], ["node.bool_tensor"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_tensor"], ["", "def", "named_parameters", "(", "self", ")", "->", "Iterator", "[", "Tuple", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "for", "name", ",", "param", "in", "self", ".", "params", ".", "items", "(", ")", ":", "\n", "            ", "yield", "name", ",", "param", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_or": [[181, 183], ["node.bool_tensor"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_tensor"], ["            ", "for", "idx", ",", "param", "in", "enumerate", "(", "self", ".", "leaves", ")", ":", "\n", "                ", "if", "param", ".", "requires_grad", "and", "param", ".", "is_leaf", ":", "\n", "                    ", "yield", "f\"bounds_{idx}\"", ",", "param", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.activations.node.bool_tensor": [[185, 194], ["tensorise().to", "tensorise().to.type", "node.tensorise"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node.tensorise"], []], "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.__init__": [[21, 26], ["node._NodeActivation.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["self", ".", "bias", ".", "requires_grad_", "(", "kwds", ".", "get", "(", "\"bias_learning\"", ",", "True", ")", ")", "\n", "weights", "=", "kwds", ".", "get", "(", "\"weights\"", ",", "(", "1.0", ",", ")", "*", "arity", ")", "\n", "_exceptions", ".", "AssertWeights", "(", "weights", ",", "arity", ")", "\n", "self", ".", "weights", "=", "self", ".", "add_param", "(", "\"weights\"", ",", "torch", ".", "tensor", "(", "weights", ")", ")", "\n", "self", ".", "weights", ".", "requires_grad_", "(", "kwds", ".", "get", "(", "\"weights_learning\"", ",", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.function": [[27, 29], ["getattr", "func.lower"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "project_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "weights", ".", "data", "=", "self", ".", "weights", ".", "data", ".", "clamp", "(", "0", ",", "1", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.downward_conditional": [[30, 54], ["torch.no_grad", "torch.ones_like", "out_bounds[].repeat_interleave", "result[].where", "result[].where", "neuron._NeuronActivation.weights[].repeat_interleave", "result.where.where.where", "_utils.val_clamp", "input_terms.sum", "neuron._NeuronActivation.weights.clamp"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.val_clamp"], ["self", ".", "bias", ".", "data", "=", "self", ".", "bias", ".", "data", ".", "clamp", "(", "0", ",", "self", ".", "arity", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation._bidirectional": [[55, 61], ["None"], "methods", ["None"], []], "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.__init__": [[17, 24], ["neuron._NeuronActivation.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwds", ")", "\n", "self", ".", "Xmin", "=", "0", "\n", "self", ".", "Xf", "=", "1", "-", "self", ".", "alpha", "\n", "self", ".", "Xt", "=", "self", ".", "alpha", "\n", "self", ".", "Xmid", "=", "0.5", "\n", "self", ".", "Xmax", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.input_regions": [[25, 36], ["torch.zeros_like", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.masked_fill", "any", "ValueError"], "methods", ["None"], ["", "def", "input_regions", "(", "self", ",", "bounds", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "result", "=", "torch", ".", "zeros_like", "(", "bounds", ")", "\n", "result", "=", "result", ".", "masked_fill", "(", "(", "self", ".", "Xmin", "<=", "bounds", ")", "*", "(", "bounds", "<=", "self", ".", "Xf", ")", ",", "1", ")", "\n", "result", "=", "result", ".", "masked_fill", "(", "(", "self", ".", "Xf", "<", "bounds", ")", "*", "(", "bounds", "<", "self", ".", "Xt", ")", ",", "2", ")", "\n", "result", "=", "result", ".", "masked_fill", "(", "(", "self", ".", "Xt", "<=", "bounds", ")", "*", "(", "bounds", "<=", "self", ".", "Xmax", ")", ",", "3", ")", "\n", "if", "any", "(", "result", "==", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Unknown input regions. Expected all values from \"", "\n", "f\"[1, 2, 3], received  {result}\"", "\n", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide": [[51, 65], ["divident.reshape.reshape.masked_scatter", "result.masked_fill.masked_fill.masked_fill", "result.masked_fill.masked_fill.reshape", "divident.reshape.reshape.dim", "divident.reshape.reshape.reshape", "divident.reshape.reshape.masked_select", "divisor.masked_select"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "divide", "(", "divident", ":", "torch", ".", "Tensor", ",", "divisor", ":", "torch", ".", "Tensor", ",", "fill", "=", "1.0", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\n        Divide the bounds tensor (divident) by weights (divisor) while\n            respecting gradient connectivity\n        shortcurcuits a div 0 error with the fill value\n        \"\"\"", "\n", "shape", "=", "divident", ".", "shape", "\n", "if", "divident", ".", "dim", "(", ")", "<", "2", ":", "\n", "            ", "divident", "=", "divident", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "", "div", "=", "divident", ".", "masked_select", "(", "divisor", "!=", "0", ")", "/", "divisor", ".", "masked_select", "(", "divisor", "!=", "0", ")", "\n", "result", "=", "divident", ".", "masked_scatter", "(", "divisor", "!=", "0", ",", "div", ")", "\n", "result", "=", "result", ".", "masked_fill", "(", "divisor", "==", "0", ",", "fill", ")", "\n", "return", "result", ".", "reshape", "(", "shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear.__init__": [[17, 22], ["activations.neuron.dynamic._DynamicActivation.__init__", "kwds.get", "dynamiclinear.DynamicLinear.add_param", "dynamiclinear.DynamicLinear.kappa.requires_grad_", "torch.tensor", "kwds.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_param"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwds", ")", "\n", "self", ".", "w_m_slacks", "=", "kwds", ".", "get", "(", "\"w_m_slacks\"", ",", "\"max\"", ")", "\n", "self", ".", "kappa", "=", "self", ".", "add_param", "(", "\"kappa\"", ",", "torch", ".", "tensor", "(", "1.0", ")", ")", "\n", "self", ".", "kappa", ".", "requires_grad_", "(", "kwds", ".", "get", "(", "\"kappa_learning\"", ",", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._and": [[23, 27], ["torch.tensor", "dynamiclinear.DynamicLinear.update_activation", "dynamiclinear.DynamicLinear._and_or"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear.update_activation", "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._and_or"], ["", "def", "_and", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "self", ".", "kappa", ".", "data", "=", "torch", ".", "tensor", "(", "1.0", ")", "\n", "self", ".", "update_activation", "(", ")", "\n", "return", "self", ".", "_and_or", "(", "direction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._or": [[28, 32], ["torch.tensor", "dynamiclinear.DynamicLinear.update_activation", "dynamiclinear.DynamicLinear._and_or"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear.update_activation", "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._and_or"], ["", "def", "_or", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "self", ".", "kappa", ".", "data", "=", "torch", ".", "tensor", "(", "0.0", ")", "\n", "self", ".", "update_activation", "(", ")", "\n", "return", "self", ".", "_and_or", "(", "direction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._atleast": [[33, 36], ["dynamiclinear.DynamicLinear.update_activation", "dynamiclinear.DynamicLinear._and_or"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear.update_activation", "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._and_or"], ["", "def", "_atleast", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "self", ".", "update_activation", "(", ")", "\n", "return", "self", ".", "_and_or", "(", "direction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._implies": [[37, 57], ["_utils.negate_bounds", "torch.stack", "_utils.negate_bounds", "_utils.negate_bounds", "torch.stack", "torch.stack", "dynamiclinear.DynamicLinear._and", "_utils.negate_bounds", "dynamiclinear.DynamicLinear._and", "_utils.negate_bounds"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds"], ["", "def", "_implies", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "lhs", "=", "in_bounds", "[", "...", ",", "0", "]", "\n", "rhs", "=", "_not", "(", "in_bounds", "[", "...", ",", "1", "]", ")", "\n", "implies_bounds", "=", "torch", ".", "stack", "(", "(", "lhs", ",", "rhs", ")", ",", "dim", "=", "2", ")", "\n", "return", "_not", "(", "self", ".", "_and", "(", "Direction", ".", "UPWARD", ")", "(", "implies_bounds", ")", ")", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "lhs", "=", "in_bounds", "[", "...", ",", "0", "]", "\n", "rhs", "=", "_not", "(", "in_bounds", "[", "...", ",", "1", "]", ")", "\n", "implies_bounds", "=", "torch", ".", "stack", "(", "(", "lhs", ",", "rhs", ")", ",", "dim", "=", "2", ")", "\n", "tmp_bounds", "=", "self", ".", "_and", "(", "Direction", ".", "DOWNWARD", ")", "(", "_not", "(", "out_bounds", ")", ",", "implies_bounds", ")", "\n", "return", "torch", ".", "stack", "(", "\n", "[", "tmp_bounds", "[", "...", ",", "0", "]", ",", "_not", "(", "tmp_bounds", "[", "...", ",", "1", "]", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear._and_or": [[59, 94], ["dynamiclinear.DynamicLinear.input_regions", "torch.where", "torch.where", "torch.where", "out_bounds.clone", "dynamiclinear.DynamicLinear.output_regions", "torch.where", "torch.where", "torch.where", "result.clamp", "torch.zeros_like", "torch.where.clone", "any", "any", "any", "ValueError", "any", "any", "ValueError", "input_terms.sum"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.input_regions", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.output_regions"], ["", "def", "_and_or", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "x", "=", "in_bounds", "@", "self", ".", "weights", "\n", "y", "=", "torch", ".", "zeros_like", "(", "x", ")", "-", "1", "\n", "regions", "=", "self", ".", "input_regions", "(", "x", ".", "clone", "(", ")", ")", "\n", "y", "=", "torch", ".", "where", "(", "regions", "==", "1", ",", "x", "*", "self", ".", "Gf", ",", "y", ")", "\n", "y", "=", "torch", ".", "where", "(", "regions", "==", "2", ",", "self", ".", "Yf", "+", "(", "x", "-", "self", ".", "Xf", ")", "*", "self", ".", "Gz", ",", "y", ")", "\n", "y", "=", "torch", ".", "where", "(", "regions", "==", "3", ",", "self", ".", "Yt", "+", "(", "x", "-", "self", ".", "Xt", ")", "*", "self", ".", "Gt", ",", "y", ")", "\n", "if", "any", "(", "y", "<", "0", ")", "or", "any", "(", "y", ">", "1", ")", "or", "any", "(", "y", "==", "-", "1", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"output of activation expected in [0, 1], \"", "f\"received {y}\"", "\n", ")", "\n", "", "return", "y", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "x", "=", "out_bounds", ".", "clone", "(", ")", "\n", "regions", "=", "self", ".", "output_regions", "(", "x", ")", "\n", "x", "=", "torch", ".", "where", "(", "regions", "==", "1", ",", "x", "*", "self", ".", "Gf_inv", ",", "x", ")", "\n", "x", "=", "torch", ".", "where", "(", "regions", "==", "2", ",", "self", ".", "Xf", "+", "(", "x", "-", "self", ".", "Yf", ")", "*", "self", ".", "Gz_inv", ",", "x", ")", "\n", "x", "=", "torch", ".", "where", "(", "regions", "==", "3", ",", "self", ".", "Xt", "+", "(", "x", "-", "self", ".", "Yt", ")", "*", "self", ".", "Gt_inv", ",", "x", ")", "\n", "if", "any", "(", "x", "<", "0", ")", "or", "any", "(", "x", ">", "self", ".", "bias", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"input to activation expected in [0, 1], \"", "f\"received {x}\"", "\n", ")", "\n", "\n", "", "input_terms", "=", "in_bounds", "*", "self", ".", "weights", "\n", "result", "=", "(", "\n", "x", "[", ":", ",", "None", "]", "-", "(", "input_terms", ".", "sum", "(", "dim", "=", "1", ")", "[", ":", ",", "None", "]", "-", "input_terms", ")", "\n", ")", "/", "self", ".", "weights", "\n", "return", "result", ".", "clamp", "(", "0", ",", "1", ")", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.dynamiclinear.DynamicLinear.update_activation": [[96, 122], ["dynamiclinear.DynamicLinear.weights[].sum", "dynamiclinear.DynamicLinear.TransparentMax.apply", "dynamiclinear.DynamicLinear.divide", "dynamiclinear.DynamicLinear.divide", "dynamiclinear.DynamicLinear.divide", "dynamiclinear.DynamicLinear.divide", "dynamiclinear.DynamicLinear.divide", "dynamiclinear.DynamicLinear.divide", "torch.ones_like", "torch.ones_like", "torch.ones_like", "len", "len", "ValueError", "dynamiclinear.DynamicLinear.weights.max", "float", "float", "float", "set", "dynamiclinear.DynamicLinear.weights.mean", "dynamiclinear.DynamicLinear.weights.min"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide", "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide", "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide", "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide", "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide", "home.repos.pwc.inspect_result.IBM_LNN.neuron.dynamic._DynamicActivation.divide"], ["", "def", "update_activation", "(", "self", ",", "**", "kwds", ")", ":", "\n", "        ", "bias", "=", "self", ".", "weights", "[", "0", "]", "=", "self", ".", "weights", "[", "1", ":", "]", ".", "sum", "(", ")", "\n", "self", ".", "Xmax", "=", "bias", "\n", "w_m", "=", "self", ".", "TransparentMax", ".", "apply", "(", "\n", "self", ".", "weights", ".", "max", "(", ")", "\n", "if", "self", ".", "w_m_slacks", "==", "\"max\"", "\n", "else", "self", ".", "weights", ".", "mean", "(", ")", "\n", "if", "self", ".", "w_m_slacks", "==", "\"mean\"", "\n", "else", "self", ".", "weights", ".", "min", "(", ")", "\n", ")", "\n", "n", "=", "self", ".", "weights", ".", "shape", "[", "-", "1", "]", "\n", "k", "=", "1", "+", "self", ".", "kappa", "*", "(", "n", "-", "1", ")", "\n", "self", ".", "Xf", "=", "bias", "-", "self", ".", "alpha", "*", "(", "\n", "w_m", "+", "(", "(", "n", "-", "k", ")", "/", "(", "n", "-", "1", "+", "self", ".", "eps", ")", ")", "*", "(", "bias", "-", "w_m", ")", "\n", ")", "\n", "self", ".", "Xt", "=", "self", ".", "alpha", "*", "(", "w_m", "+", "(", "(", "k", "-", "1", ")", "/", "(", "n", "-", "1", "+", "self", ".", "eps", ")", ")", "*", "(", "bias", "-", "w_m", ")", ")", "\n", "self", ".", "Gf", "=", "self", ".", "divide", "(", "self", ".", "Yf", ",", "self", ".", "Xf", ",", "fill", "=", "0", ")", "\n", "self", ".", "Gz", "=", "self", ".", "divide", "(", "self", ".", "Yt", "-", "self", ".", "Yf", ",", "self", ".", "Xt", "-", "self", ".", "Xf", ",", "fill", "=", "float", "(", "\"inf\"", ")", ")", "\n", "self", ".", "Gt", "=", "self", ".", "divide", "(", "1", "-", "self", ".", "Yt", ",", "self", ".", "Xmax", "-", "self", ".", "Xt", ",", "fill", "=", "0", ")", "\n", "self", ".", "Gf_inv", "=", "self", ".", "divide", "(", "torch", ".", "ones_like", "(", "self", ".", "Gf", ")", ",", "self", ".", "Gf", ",", "fill", "=", "float", "(", "\"inf\"", ")", ")", "\n", "self", ".", "Gz_inv", "=", "self", ".", "divide", "(", "torch", ".", "ones_like", "(", "self", ".", "Gz", ")", ",", "self", ".", "Gz", ",", "fill", "=", "0", ")", "\n", "self", ".", "Gt_inv", "=", "self", ".", "divide", "(", "torch", ".", "ones_like", "(", "self", ".", "Gt", ")", ",", "self", ".", "Gt", ",", "fill", "=", "float", "(", "\"inf\"", ")", ")", "\n", "uniques", "=", "[", "self", ".", "Xmin", ",", "self", ".", "Xf", ",", "self", ".", "Xt", ",", "self", ".", "Xmax", "]", "\n", "if", "len", "(", "uniques", ")", "<", "len", "(", "set", "(", "uniques", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"expected unique values for input control \"", "\n", "f\"points, received {uniques}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicz.Lukasiewicz._and": [[16, 40], ["lukasiewicz.Lukasiewicz.downward_conditional", "torch.stack", "torch.stack", "torch.tensor", "torch.tensor", "lukasiewicz.Lukasiewicz.weights.sum"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.downward_conditional"], ["def", "_and", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "(", "self", ".", "bias", "-", "(", "(", "1", "-", "in_bounds", ")", "@", "self", ".", "weights", ")", ")", ".", "clamp", "(", "0", ",", "1", ")", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "f_inv", "=", "(", "\n", "out_bounds", "\n", "+", "(", "\n", "(", "out_bounds", "<=", "0", ")", ".", "float", "(", ")", "\n", "*", "torch", ".", "stack", "(", "[", "self", ".", "bias", "-", "self", ".", "weights", ".", "sum", "(", ")", ",", "torch", ".", "tensor", "(", "0.0", ")", "]", ")", "\n", ")", "\n", "+", "(", "\n", "(", "out_bounds", ">=", "1", ")", ".", "float", "(", ")", "\n", "*", "torch", ".", "stack", "(", "[", "torch", ".", "tensor", "(", "0.0", ")", ",", "self", ".", "bias", "-", "1", "]", ")", "\n", ")", "\n", ")", "\n", "input_terms", "=", "(", "1", "-", "in_bounds", ")", "*", "self", ".", "weights", "\n", "result", "=", "self", ".", "downward_conditional", "(", "out_bounds", ",", "f_inv", ",", "input_terms", ")", "\n", "return", "result", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicz.Lukasiewicz._or": [[42, 58], ["_utils.negate_bounds", "lukasiewicz.Lukasiewicz._and", "_utils.negate_bounds", "_utils.negate_bounds"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds"], ["", "def", "_or", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "(", "1", "-", "self", ".", "bias", "+", "(", "in_bounds", "@", "self", ".", "weights", ")", ")", ".", "clamp", "(", "0", ",", "1", ")", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "_not", "(", "\n", "self", ".", "_and", "(", "Direction", ".", "DOWNWARD", ")", "(", "\n", "_not", "(", "out_bounds", ")", ",", "_not", "(", "in_bounds", ",", "dim", "=", "-", "2", ")", "\n", ")", ",", "\n", "dim", "=", "-", "2", ",", "\n", ")", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicz.Lukasiewicz._implies": [[60, 83], ["torch.stack", "_utils.negate_bounds", "lukasiewicz.Lukasiewicz._and", "_utils.negate_bounds", "torch.stack", "_utils.negate_bounds", "in_bounds[].flip"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds"], ["", "def", "_implies", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "result", "=", "(", "\n", "1", "\n", "-", "self", ".", "bias", "\n", "+", "(", "self", ".", "weights", "[", "0", "]", "*", "(", "1", "-", "in_bounds", "[", "...", ",", "0", "]", ".", "flip", "(", "-", "1", ")", ")", ")", "\n", "+", "(", "self", ".", "weights", "[", "1", "]", "*", "in_bounds", "[", "...", ",", "1", "]", ")", "\n", ")", ".", "clamp", "(", "0", ",", "1", ")", "\n", "return", "result", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "lhs", ",", "rhs", "=", "in_bounds", "[", "...", ",", "0", "]", ",", "_not", "(", "in_bounds", "[", "...", ",", "1", "]", ")", "\n", "tmp_bounds", "=", "self", ".", "_and", "(", "Direction", ".", "DOWNWARD", ")", "(", "\n", "_not", "(", "out_bounds", ")", ",", "torch", ".", "stack", "(", "[", "lhs", ",", "rhs", "]", ",", "dim", "=", "-", "1", ")", "\n", ")", "\n", "return", "torch", ".", "stack", "(", "\n", "[", "tmp_bounds", "[", "...", ",", "0", "]", ",", "_not", "(", "tmp_bounds", "[", "...", ",", "1", "]", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and": [[17, 41], ["_utils.val_clamp", "lukasiewicztransparent.LukasiewiczTransparent.downward_conditional", "torch.stack", "torch.stack", "torch.tensor", "torch.tensor", "lukasiewicztransparent.LukasiewiczTransparent.weights.sum"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.val_clamp", "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.downward_conditional"], ["def", "_and", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "val_clamp", "(", "self", ".", "bias", "-", "(", "(", "1", "-", "in_bounds", ")", "@", "self", ".", "weights", ")", ")", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "f_inv", "=", "(", "\n", "out_bounds", "\n", "+", "(", "\n", "(", "out_bounds", "<=", "0", ")", ".", "float", "(", ")", "\n", "*", "torch", ".", "stack", "(", "[", "self", ".", "bias", "-", "self", ".", "weights", ".", "sum", "(", ")", ",", "torch", ".", "tensor", "(", "0.0", ")", "]", ")", "\n", ")", "\n", "+", "(", "\n", "(", "out_bounds", ">=", "1", ")", ".", "float", "(", ")", "\n", "*", "torch", ".", "stack", "(", "[", "torch", ".", "tensor", "(", "0.0", ")", ",", "self", ".", "bias", "-", "1", "]", ")", "\n", ")", "\n", ")", "\n", "input_terms", "=", "(", "1", "-", "in_bounds", ")", "*", "self", ".", "weights", "\n", "result", "=", "self", ".", "downward_conditional", "(", "out_bounds", ",", "f_inv", ",", "input_terms", ")", "\n", "return", "result", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._or": [[43, 59], ["_utils.val_clamp", "_utils.negate_bounds", "lukasiewicztransparent.LukasiewiczTransparent._and", "_utils.negate_bounds", "_utils.negate_bounds"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.val_clamp", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds"], ["", "def", "_or", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "val_clamp", "(", "1", "-", "self", ".", "bias", "+", "(", "in_bounds", "@", "self", ".", "weights", ")", ")", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "return", "_not", "(", "\n", "self", ".", "_and", "(", "Direction", ".", "DOWNWARD", ")", "(", "\n", "_not", "(", "out_bounds", ")", ",", "_not", "(", "in_bounds", ",", "dim", "=", "-", "2", ")", "\n", ")", ",", "\n", "dim", "=", "-", "2", ",", "\n", ")", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._implies": [[61, 84], ["_utils.val_clamp", "torch.stack", "_utils.negate_bounds", "lukasiewicztransparent.LukasiewiczTransparent._and", "_utils.negate_bounds", "torch.stack", "_utils.negate_bounds", "in_bounds[].flip"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.val_clamp", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.methods.lukasiewicztransparent.LukasiewiczTransparent._and", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds"], ["", "def", "_implies", "(", "self", ",", "direction", ":", "Direction", ")", ":", "\n", "        ", "def", "upward", "(", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "result", "=", "val_clamp", "(", "\n", "1", "\n", "-", "self", ".", "bias", "\n", "+", "(", "self", ".", "weights", "[", "0", "]", "*", "(", "1", "-", "in_bounds", "[", "...", ",", "0", "]", ".", "flip", "(", "-", "1", ")", ")", ")", "\n", "+", "(", "self", ".", "weights", "[", "1", "]", "*", "in_bounds", "[", "...", ",", "1", "]", ")", "\n", ")", "\n", "return", "result", "\n", "\n", "", "def", "downward", "(", "out_bounds", ":", "torch", ".", "Tensor", ",", "in_bounds", ":", "torch", ".", "Tensor", ")", ":", "\n", "            ", "lhs", ",", "rhs", "=", "in_bounds", "[", "...", ",", "0", "]", ",", "_not", "(", "in_bounds", "[", "...", ",", "1", "]", ")", "\n", "tmp_bounds", "=", "self", ".", "_and", "(", "Direction", ".", "DOWNWARD", ")", "(", "\n", "_not", "(", "out_bounds", ")", ",", "torch", ".", "stack", "(", "[", "lhs", ",", "rhs", "]", ",", "dim", "=", "-", "1", ")", "\n", ")", "\n", "return", "torch", ".", "stack", "(", "\n", "[", "tmp_bounds", "[", "...", ",", "0", "]", ",", "_not", "(", "tmp_bounds", "[", "...", ",", "1", "]", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "-", "1", "\n", ")", "\n", "\n", "", "return", "(", "\n", "upward", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", "\n", "else", "(", "downward", "if", "direction", "is", "Direction", ".", "DOWNWARD", "else", "None", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._trace.increment_param_history": [[8, 27], ["params.get.get", "hasattr", "param.split", "len", "hasattr", "getattr", "_trace..parameter_history[].append", "val.tolist", "getattr.clone().detach", "getattr.clone"], "function", ["None"], ["def", "increment_param_history", "(", "self", ",", "**", "params", ")", ":", "\n", "    ", "if", "not", "hasattr", "(", "self", ",", "\"parameter_history\"", ")", ":", "\n", "        ", "self", ".", "parameter_history", "=", "{", "}", "\n", "", "params", "=", "params", ".", "get", "(", "\"parameter_history\"", ")", "\n", "for", "param", "in", "params", ":", "\n", "        ", "split", "=", "param", ".", "split", "(", "\".grad\"", ")", "\n", "p", "=", "split", "[", "0", "]", "\n", "grad", "=", "False", "\n", "if", "len", "(", "split", ")", "==", "2", ":", "\n", "            ", "grad", "=", "True", "\n", "", "if", "(", "params", "[", "p", "]", "is", "True", "or", "params", "[", "p", "]", "is", "self", ")", "and", "hasattr", "(", "self", ".", "neuron", ",", "p", ")", ":", "\n", "            ", "if", "param", "not", "in", "self", ".", "parameter_history", ":", "\n", "                ", "self", ".", "parameter_history", "[", "param", "]", "=", "[", "]", "\n", "", "attrib", "=", "getattr", "(", "self", ".", "neuron", ",", "p", ")", "\n", "val", "=", "attrib", ".", "grad", "if", "grad", "else", "attrib", "\n", "self", ".", "parameter_history", "[", "param", "]", ".", "append", "(", "\n", "val", ".", "tolist", "(", ")", "\n", "if", "val", "is", "not", "None", "\n", "else", "(", "attrib", ".", "clone", "(", ")", ".", "detach", "(", ")", "*", "0", ")", ".", "tolist", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.axioms.lifted_axioms": [[13, 28], ["dict", "all", "isinstance", "p.Implies"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies"], ["def", "lifted_axioms", "(", ")", "->", "dict", ":", "\n", "    ", "result", "=", "dict", "(", ")", "\n", "\n", "def", "hypothetical_syllogism", "(", "formulae", ":", "Tuple", "[", "Implies", ",", "Implies", "]", ")", ":", "\n", "        ", "\"\"\"\n        ((p \u279e q) \u2227 (q \u279e r)) \u279e (p \u279e r)\n        \"\"\"", "\n", "if", "all", "(", "isinstance", "(", "f", ",", "Implies", ")", "for", "f", "in", "formulae", ")", ":", "\n", "            ", "p", ",", "q_0", "=", "formulae", "[", "0", "]", ".", "operands", "\n", "q_1", ",", "r", "=", "formulae", "[", "1", "]", ".", "operands", "\n", "if", "q_0", "is", "q_1", ":", "\n", "                ", "return", "p", ".", "Implies", "(", "r", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "", "", "", "result", "[", "hypothetical_syllogism", "]", "=", "2", "\n", "return", "result", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.upward_bounds": [[28, 36], ["_gm._operational_bounds"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._operational_bounds"], ["def", "upward_bounds", "(", "\n", "self", ":", "_Formula", ",", "\n", "operands", ":", "Tuple", "[", "_Formula", ",", "...", "]", ",", "\n", "groundings", ":", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "None", ",", "Tuple", "[", "torch", ".", "Tensor", ",", "None", "]", ",", "Tuple", "[", "torch", ".", "Tensor", ",", "Set", "[", "_Grounding", "]", "]", "]", ":", "\n", "    ", "\"\"\"returns (input_bounds, groundings)\"\"\"", "\n", "result", "=", "_operational_bounds", "(", "self", ",", "Direction", ".", "UPWARD", ",", "operands", ",", "groundings", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.downward_bounds": [[38, 50], ["_gm._operational_bounds"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._operational_bounds"], ["", "def", "downward_bounds", "(", "\n", "self", ":", "_Formula", ",", "\n", "operands", ":", "Tuple", "[", "_Formula", ",", "...", "]", ",", "\n", "groundings", ":", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "None", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "None", "]", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "Set", "[", "_Grounding", "]", "]", ",", "\n", "]", ":", "\n", "    ", "\"\"\"returns (output_bounds, input_bounds, groundings)\"\"\"", "\n", "result", "=", "_operational_bounds", "(", "self", ",", "Direction", ".", "DOWNWARD", ",", "operands", ",", "groundings", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.disjoint": [[52, 54], ["any", "all"], "function", ["None"], ["", "def", "disjoint", "(", "pred_vars", ")", ":", "\n", "    ", "return", "not", "any", "(", "[", "all", "(", "[", "v", "in", "_vars", "for", "_vars", "in", "pred_vars", "]", ")", "for", "v", "in", "pred_vars", "[", "0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.unique_variables": [[59, 69], ["list", "tuple", "list.append"], "function", ["None"], ["def", "unique_variables", "(", "*", "variables", ":", "Tuple", "[", "_Variable", ",", "...", "]", ")", "->", "Tuple", ":", "\n", "    ", "\"\"\"combines all predicate variables into a unique tuple\n    the tuple is sorted by the order of appearance of variables in the operands\n    \"\"\"", "\n", "result", "=", "list", "(", ")", "\n", "for", "op_vars", "in", "variables", ":", "\n", "        ", "for", "v", "in", "op_vars", ":", "\n", "            ", "if", "v", "not", "in", "result", ":", "\n", "                ", "result", ".", "append", "(", "v", ")", "\n", "", "", "", "return", "tuple", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._operational_bounds": [[71, 192], ["tuple", "_gm._masked_negate", "_gm.._add_groundings", "_gm..get_facts", "all", "_gm._masked_negate", "_gm._hash_join", "_gm._masked_negate", "_gm.._add_groundings", "_gm..get_facts", "TypeError", "dict", "grounding_tables.append", "tuple", "_gm._nested_loop_join_inner", "all", "torch.stack", "len", "_gm.._has_bindings", "torch.stack", "_gm..get_facts", "set", "set", "torch.stack", "len", "_gm._nested_loop_join_outer", "len", "_gm.._ground", "itertools.chain.from_iterable", "set.update", "map", "op._add_groundings", "_gm._nested_loop_join_outer_pruned", "op.get_facts", "op.is_contradiction", "_gm..is_contradiction", "op.get_facts", "_gm..grounding_table.keys", "op.get_facts", "isinstance", "len", "enumerate", "eval", "eval", "str", "str", "constants.Direction.UPWARD", "constants.Direction.DOWNWARD"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._masked_negate", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._masked_negate", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._hash_join", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._masked_negate", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._nested_loop_join_inner", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._has_bindings", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._nested_loop_join_outer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._nested_loop_join_outer_pruned", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.eval", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.eval"], ["", "def", "_operational_bounds", "(", "\n", "self", ":", "_Formula", ",", "\n", "direction", ":", "Direction", ",", "\n", "operands", ":", "Tuple", "[", "_Formula", ",", "...", "]", ",", "\n", "groundings", ":", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", "=", "None", ",", "\n", ")", "->", "Union", "[", "\n", "None", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "None", "]", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "None", "]", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "Set", "[", "_Grounding", "]", "]", ",", "\n", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", ",", "Set", "[", "_Grounding", "]", "]", ",", "\n", "]", ":", "\n", "\n", "# propositional / hash join for homogeneous operand variables", "\n", "    ", "if", "self", ".", "propositional", "or", "(", "# propositional", "\n", "all", "(", "[", "v", "==", "self", ".", "var_remap", "[", "0", "]", "for", "v", "in", "self", ".", "var_remap", "]", ")", "# homogenous variables", "\n", "and", "not", "self", ".", "_has_bindings", "(", ")", "\n", ")", ":", "# bindings", "\n", "        ", "if", "self", ".", "propositional", ":", "# propositional bounds", "\n", "            ", "if", "True", "in", "(", "\n", "[", "op", ".", "is_contradiction", "(", ")", "for", "op", "in", "operands", "]", "+", "[", "self", ".", "is_contradiction", "(", ")", "]", "\n", ")", ":", "\n", "                ", "return", "\n", "", "input_bounds", "=", "_masked_negate", "(", "\n", "self", ",", "torch", ".", "stack", "(", "[", "op", ".", "get_facts", "(", ")", "for", "op", "in", "operands", "]", ",", "dim", "=", "-", "1", ")", "\n", ")", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", ":", "\n", "                ", "return", "input_bounds", ",", "None", "\n", "", "return", "self", ".", "get_facts", "(", ")", ",", "input_bounds", ",", "None", "\n", "\n", "", "else", ":", "# FOL bounds", "\n", "            ", "if", "groundings", "is", "None", ":", "\n", "                ", "groundings", "=", "set", "(", "\n", "chain", ".", "from_iterable", "(", "[", "op", ".", "grounding_table", "for", "op", "in", "operands", "]", ")", "\n", ")", "\n", "if", "direction", "is", "Direction", ".", "DOWNWARD", ":", "\n", "                    ", "groundings", ".", "update", "(", "self", ".", "grounding_table", ".", "keys", "(", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "groundings", "=", "set", "(", "map", "(", "self", ".", "_ground", ",", "groundings", ")", ")", "\n", "\n", "", "for", "g", "in", "groundings", ":", "\n", "                ", "for", "op", "in", "operands", ":", "\n", "                    ", "op", ".", "_add_groundings", "(", "g", ")", "\n", "\n", "", "", "groundings", "=", "_hash_join", "(", "operands", ",", "groundings", ")", "\n", "input_bounds", "=", "_masked_negate", "(", "\n", "self", ",", "\n", "torch", ".", "stack", "(", "[", "op", ".", "get_facts", "(", "*", "groundings", ")", "for", "op", "in", "operands", "]", ",", "dim", "=", "-", "1", ")", ",", "\n", ")", "\n", "self", ".", "_add_groundings", "(", "*", "groundings", ")", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", ":", "\n", "                ", "return", "input_bounds", ",", "groundings", "\n", "", "output_bounds", "=", "self", ".", "get_facts", "(", "*", "groundings", ")", "\n", "if", "len", "(", "output_bounds", ")", "==", "0", ":", "\n", "                ", "return", "\n", "", "return", "output_bounds", ",", "input_bounds", ",", "groundings", "\n", "\n", "# nested loop join for bindings / heterogenous operand variables", "\n", "", "", "else", ":", "\n", "        ", "if", "self", ".", "propositional", ":", "\n", "            ", "raise", "TypeError", "(", "\"proposition should not reach here\"", ")", "\n", "", "grounding_tables", "=", "[", "]", "\n", "for", "op", "in", "operands", ":", "\n", "            ", "g_t", "=", "dict", "(", ")", "\n", "for", "g", "in", "op", ".", "grounding_table", ":", "\n", "                ", "if", "g", ".", "name", "[", "0", "]", "!=", "\"(\"", ":", "\n", "                    ", "g_t", "[", "eval", "(", "\"('\"", "+", "g", ".", "name", "+", "\"',)\"", ")", "]", "=", "g", "\n", "", "else", ":", "\n", "                    ", "g_t", "[", "eval", "(", "g", ".", "name", ")", "]", "=", "g", "# op.grounding_table[g]", "\n", "", "", "grounding_tables", ".", "append", "(", "g_t", ")", "\n", "\n", "", "tmp_bindings", "=", "[", "\n", "tuple", "(", "\n", "[", "str", "(", "b", ")", "if", "b", "is", "not", "None", "else", "b", "for", "b", "in", "g", "]", "\n", "if", "isinstance", "(", "g", ",", "List", ")", "\n", "else", "str", "(", "g", ")", "\n", "if", "g", "is", "not", "None", "\n", "else", "g", "\n", "for", "g", "in", "op", "\n", ")", "\n", "for", "op", "in", "self", ".", "bindings", "\n", "]", "\n", "tmp_binding_str", "=", "[", "\", \"", ".", "join", "(", "[", "f\"{v}\"", "for", "v", "in", "op", "]", ")", "for", "op", "in", "self", ".", "var_remap", "]", "\n", "if", "self", ".", "join_method", "is", "Join", ".", "INNER", ":", "\n", "            ", "ground_tuples", ",", "ground_objects", "=", "_nested_loop_join_inner", "(", "\n", "grounding_tables", ",", "tmp_binding_str", ",", "tmp_bindings", ",", "operands", "\n", ")", "\n", "", "elif", "self", ".", "join_method", "is", "Join", ".", "OUTER", ":", "\n", "            ", "ground_tuples", ",", "ground_objects", "=", "_nested_loop_join_outer", "(", "\n", "grounding_tables", ",", "tmp_binding_str", ",", "tmp_bindings", ",", "operands", "\n", ")", "\n", "", "elif", "self", ".", "join_method", "is", "Join", ".", "OUTER_PRUNED", ":", "\n", "            ", "ground_tuples", ",", "ground_objects", "=", "_nested_loop_join_outer_pruned", "(", "\n", "grounding_tables", ",", "tmp_binding_str", ",", "tmp_bindings", ",", "operands", "\n", ")", "\n", "\n", "", "if", "ground_objects", "is", "None", "or", "all", "(", "[", "len", "(", "o", ")", "==", "0", "for", "o", "in", "ground_objects", "]", ")", ":", "\n", "            ", "return", "\n", "\n", "", "tmp_ground_tuples", "=", "(", "\n", "[", "g", "[", "0", "]", "for", "g", "in", "ground_tuples", "]", "\n", "if", "(", "len", "(", "self", ".", "unique_vars", ")", "==", "1", ")", "\n", "else", "ground_tuples", "\n", ")", "\n", "groundings", "=", "tuple", "(", ")", "\n", "for", "t", "in", "tmp_ground_tuples", ":", "\n", "            ", "groundings", "+=", "(", "self", ".", "_ground", "(", "t", ")", ",", ")", "\n", "", "input_bounds", "=", "_masked_negate", "(", "\n", "self", ",", "\n", "torch", ".", "stack", "(", "\n", "[", "op", ".", "get_facts", "(", "*", "ground_objects", "[", "i", "]", ")", "for", "i", ",", "op", "in", "enumerate", "(", "operands", ")", "]", ",", "\n", "dim", "=", "-", "1", ",", "\n", ")", ",", "\n", ")", "\n", "self", ".", "_add_groundings", "(", "*", "groundings", ")", "\n", "if", "direction", "is", "Direction", ".", "UPWARD", ":", "\n", "            ", "return", "input_bounds", ",", "groundings", "\n", "", "output_bounds", "=", "self", ".", "get_facts", "(", "*", "groundings", ")", "\n", "if", "len", "(", "output_bounds", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "return", "output_bounds", ",", "input_bounds", ",", "groundings", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._nested_loop_join_outer": [[194, 350], ["torch.no_grad", "len", "set", "enumerate", "range", "range", "g.split", "var_remap.append", "enumerate", "set", "set", "len", "len", "all_vars.index", "set", "_gm._nested_loop_join_outer.find_joined_vars"], "function", ["None"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_nested_loop_join_outer", "(", "g_list", ",", "arg_str", ",", "bindings", ",", "operands", ")", ":", "\n", "    ", "\"\"\"\n    E.g  Join two Predicates P1(x,y) and P2(x,z,y) with groundings\n    (x1,y1) : g11 (ground object)  and (x1,z1,y1) : g12\n    (x2,y2) : g21 (ground object)  and (x2,z2,y2) : g22\n    (x1,y3) : g31 (ground object)  and (x2,z3,y2) : g32\n\n    Inputs\n\n    arg_str : is the list of strings : ['x,y','x,z,y']\n    bindings : list of bindings for each variable\n    g_list : is the list [ g_list[0], g_list[1]]\n    where g_list[0] is the dictionary g_list[0]\n       [(x1,y1)] = g11 ; [(x2,y2)] = g21 ; [(x1,y3)] = g31\n    and g_list[1] is the dictionary g_list[1]\n       [(x1,z1,y1)] = g12;[(x2,z2,y2)] = g2;[(x2,z3,y3)] = g32\n\n    **Returns**\n\n    list_tuples:\n        List of joined ground tuples: [(x1,y1,z1), (x2,y2,z2), ...]\n    object: List of list of  ground objects for each operand\n       [[g11,g21], [g12,g22], ...]\n\n    \"\"\"", "\n", "n_ops", "=", "len", "(", "g_list", ")", "\n", "var_list", "=", "[", "g", ".", "split", "(", "\", \"", ")", "for", "g", "in", "arg_str", "]", "\n", "_vars", "=", "set", "(", ")", "\n", "var_map", "=", "{", "}", "\n", "var_count", "=", "0", "\n", "var_remap", "=", "[", "]", "\n", "for", "v", "in", "var_list", ":", "\n", "        ", "var_remap_t", "=", "[", "]", "\n", "for", "v2", "in", "v", ":", "\n", "            ", "if", "v2", "not", "in", "_vars", ":", "\n", "                ", "var_map", "[", "v2", "]", "=", "var_count", "\n", "var_remap_t", ".", "append", "(", "var_count", ")", "\n", "var_count", "=", "var_count", "+", "1", "\n", "_vars", ".", "add", "(", "v2", ")", "\n", "", "else", ":", "\n", "                ", "var_remap_t", ".", "append", "(", "var_map", "[", "v2", "]", ")", "\n", "", "", "var_remap", ".", "append", "(", "var_remap_t", ")", "\n", "\n", "", "def", "find_rev_joined_pos", "(", "full_map", ",", "op_map", ")", ":", "\n", "        ", "rev_index", "=", "[", "]", "\n", "rev_pos", "=", "[", "]", "\n", "for", "i_", ",", "o_", "in", "enumerate", "(", "full_map", ")", ":", "\n", "            ", "if", "o_", "in", "op_map", ":", "\n", "                ", "rev_index", ".", "append", "(", "i_", ")", "\n", "rev_pos", ".", "append", "(", "op_map", ".", "index", "(", "o_", ")", ")", "\n", "", "", "return", "rev_index", ",", "rev_pos", "\n", "\n", "", "def", "find_joined_vars", "(", "var_map1", ",", "var_map2", ")", ":", "\n", "        ", "match_pos1", "=", "[", "]", "\n", "match_pos2", "=", "[", "]", "\n", "for", "v", "in", "var_map1", ":", "\n", "            ", "if", "v", "in", "var_map2", ":", "\n", "                ", "match_pos1", ".", "append", "(", "var_map1", ".", "index", "(", "v", ")", ")", "\n", "match_pos2", ".", "append", "(", "var_map2", ".", "index", "(", "v", ")", ")", "\n", "", "", "umatch_pos2", "=", "[", "var_map2", ".", "index", "(", "v", ")", "for", "v", "in", "var_map2", "if", "v", "not", "in", "var_map1", "]", "\n", "\n", "joined_vars", "=", "[", "v", "for", "v", "in", "var_map1", "]", "\n", "for", "v", "in", "var_map2", ":", "\n", "            ", "if", "v", "not", "in", "joined_vars", ":", "\n", "                ", "joined_vars", ".", "append", "(", "v", ")", "\n", "\n", "", "", "scatter_pos2", "=", "[", "]", "\n", "for", "v", "in", "var_map2", ":", "\n", "            ", "scatter_pos2", ".", "append", "(", "joined_vars", ".", "index", "(", "v", ")", ")", "\n", "\n", "", "return", "match_pos1", ",", "match_pos2", ",", "umatch_pos2", ",", "joined_vars", ",", "scatter_pos2", "\n", "\n", "", "curr_merged", "=", "g_list", "[", "0", "]", "\n", "curr_map", "=", "var_remap", "[", "0", "]", "\n", "all_vars", "=", "[", "]", "\n", "n_z_index", "=", "[", "]", "\n", "for", "i", ",", "a_", "in", "enumerate", "(", "var_remap", ")", ":", "\n", "        ", "for", "aa_", "in", "a_", ":", "\n", "            ", "if", "aa_", "not", "in", "all_vars", ":", "\n", "                ", "all_vars", ".", "append", "(", "aa_", ")", "\n", "", "", "if", "len", "(", "g_list", "[", "i", "]", ")", "!=", "0", ":", "\n", "            ", "n_z_index", ".", "append", "(", "i", ")", "\n", "\n", "", "", "n_z_vars", "=", "[", "]", "\n", "for", "i", "in", "n_z_index", ":", "\n", "        ", "for", "a_", "in", "var_remap", "[", "i", "]", ":", "\n", "            ", "if", "a_", "not", "in", "n_z_vars", ":", "\n", "                ", "n_z_vars", ".", "append", "(", "a_", ")", "\n", "\n", "", "", "", "if", "set", "(", "all_vars", ")", "!=", "set", "(", "n_z_vars", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "", "reorder_pos", "=", "[", "None", "]", "*", "len", "(", "all_vars", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "n_z_vars", ")", ")", ":", "\n", "        ", "reorder_pos", "[", "i", "]", "=", "all_vars", ".", "index", "(", "n_z_vars", "[", "i", "]", ")", "\n", "\n", "", "curr_merged", "=", "g_list", "[", "n_z_index", "[", "0", "]", "]", "\n", "curr_map", "=", "var_remap", "[", "n_z_index", "[", "0", "]", "]", "\n", "for", "i", "in", "n_z_index", "[", "1", ":", "]", ":", "\n", "        ", "colllected_g_list_full", "=", "set", "(", ")", "\n", "curr_to_merge", "=", "g_list", "[", "i", "]", "\n", "(", "\n", "match_pos1", ",", "\n", "match_pos2", ",", "\n", "umatch_pos2", ",", "\n", "joined_vars", ",", "\n", "scatter_pos2", ",", "\n", ")", "=", "find_joined_vars", "(", "curr_map", ",", "var_remap", "[", "i", "]", ")", "\n", "for", "a1", "in", "curr_merged", ":", "\n", "            ", "for", "a2", "in", "curr_to_merge", ":", "\n", "                ", "m1", "=", "[", "a1", "[", "i", "]", "for", "i", "in", "match_pos1", "]", "\n", "m2", "=", "[", "a2", "[", "i", "]", "for", "i", "in", "match_pos2", "]", "\n", "if", "m1", "==", "m2", ":", "\n", "                    ", "j1", "=", "tuple", "(", "list", "(", "a1", ")", "+", "[", "a2", "[", "k", "]", "for", "k", "in", "umatch_pos2", "]", ")", "\n", "colllected_g_list_full", ".", "add", "(", "j1", ")", "\n", "", "else", ":", "\n", "                    ", "j1", "=", "tuple", "(", "list", "(", "a1", ")", "+", "[", "a2", "[", "k", "]", "for", "k", "in", "umatch_pos2", "]", ")", "\n", "j2", "=", "[", "None", "]", "*", "len", "(", "joined_vars", ")", "\n", "j2", "[", "0", ":", "len", "(", "a1", ")", "]", "=", "a1", "\n", "for", "i", ",", "j", "in", "enumerate", "(", "scatter_pos2", ")", ":", "\n", "                        ", "j2", "[", "j", "]", "=", "a2", "[", "i", "]", "\n", "", "j2", "=", "tuple", "(", "j2", ")", "\n", "colllected_g_list_full", ".", "add", "(", "j1", ")", "\n", "colllected_g_list_full", ".", "add", "(", "j2", ")", "\n", "", "", "", "curr_map", "=", "joined_vars", "\n", "curr_merged", "=", "list", "(", "colllected_g_list_full", ")", "\n", "\n", "", "ground_objects", "=", "[", "[", "]", "for", "i", "in", "range", "(", "len", "(", "operands", ")", ")", "]", "\n", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "        ", "rev_index", ",", "rev_pos", "=", "find_rev_joined_pos", "(", "curr_map", ",", "var_remap", "[", "i", "]", ")", "\n", "curr_op", "=", "copy", ".", "copy", "(", "g_list", "[", "i", "]", ")", "\n", "for", "curr_tup", "in", "curr_merged", ":", "\n", "            ", "found", "=", "False", "\n", "m1", "=", "[", "None", "]", "*", "len", "(", "var_remap", "[", "i", "]", ")", "\n", "for", "i_", ",", "r_", "in", "enumerate", "(", "rev_index", ")", ":", "\n", "                ", "m1", "[", "rev_pos", "[", "i_", "]", "]", "=", "curr_tup", "[", "r_", "]", "\n", "", "m1", "=", "tuple", "(", "m1", ")", "\n", "for", "op_tup", "in", "curr_op", ":", "\n", "                ", "if", "m1", "==", "op_tup", ":", "\n", "                    ", "if", "operands", "[", "i", "]", ".", "arity", "==", "1", ":", "\n", "                        ", "g_obj", "=", "operands", "[", "i", "]", ".", "_ground", "(", "op_tup", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                        ", "g_obj", "=", "operands", "[", "i", "]", ".", "_ground", "(", "op_tup", ")", "\n", "", "ground_objects", "[", "i", "]", ".", "append", "(", "g_obj", ")", "\n", "found", "=", "True", "\n", "", "", "if", "not", "found", ":", "\n", "                ", "if", "operands", "[", "i", "]", ".", "arity", "==", "1", ":", "\n", "                    ", "g_obj", "=", "operands", "[", "i", "]", ".", "_ground", "(", "m1", "[", "0", "]", ")", "\n", "operands", "[", "i", "]", ".", "_add_groundings", "(", "g_obj", ")", "\n", "", "else", ":", "\n", "                    ", "g_obj", "=", "operands", "[", "i", "]", ".", "_ground", "(", "m1", ")", "\n", "operands", "[", "i", "]", ".", "_add_groundings", "(", "g_obj", ")", "\n", "", "ground_objects", "[", "i", "]", ".", "append", "(", "g_obj", ")", "\n", "curr_op", "[", "m1", "]", "=", "g_obj", "\n", "\n", "", "", "", "return", "curr_merged", ",", "ground_objects", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._nested_loop_join_outer_pruned": [[352, 543], ["torch.no_grad", "len", "set", "enumerate", "range", "range", "curr_merged.values", "g.split", "var_remap.append", "enumerate", "set", "set", "len", "len", "all_vars.index", "_gm._nested_loop_join_outer.find_joined_vars"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_nested_loop_join_outer_pruned", "(", "g_list", ",", "arg_str", ",", "bindings", ",", "operands", ")", ":", "\n", "    ", "\"\"\"\n    E.g  Join two Predicates P1(x,y) and P2(x,z,y) with groundings\n    (x1,y1) : g11 (ground object)  and (x1,z1,y1) : g12\n    (x2,y2) : g21 (ground object)  and (x2,z2,y2) : g22\n    (x1,y3) : g31 (ground object)  and (x2,z3,y2) : g32\n\n    Inputs\n\n    arg_str : is the list of strings : ['x,y','x,z,y']\n    bindings : list of bindings for each variable\n    g_list : is the list [ g_list[0], g_list[1]]\n    where g_list[0] is the dictionary g_list[0]\n       [(x1,y1)] = g11 ; [(x2,y2)] = g21 ; [(x1,y3)] = g31\n    and g_list[1] is the dictionary g_list[1]\n       [(x1,z1,y1)] = g12;[(x2,z2,y2)] = g2;[(x2,z3,y3)] = g32\n\n    **Returns**\n\n    list_tuples:\n        List of joined ground tuples: [(x1,y1,z1), (x2,y2,z2), ...]\n    object: List of list of  ground objects for each operand\n       [[g11,g21], [g12,g22], ...]\n\n    \"\"\"", "\n", "n_ops", "=", "len", "(", "g_list", ")", "\n", "var_list", "=", "[", "g", ".", "split", "(", "\", \"", ")", "for", "g", "in", "arg_str", "]", "\n", "_vars", "=", "set", "(", ")", "\n", "var_map", "=", "{", "}", "\n", "var_count", "=", "0", "\n", "var_remap", "=", "[", "]", "\n", "for", "v", "in", "var_list", ":", "\n", "        ", "var_remap_t", "=", "[", "]", "\n", "for", "v2", "in", "v", ":", "\n", "            ", "if", "v2", "not", "in", "_vars", ":", "\n", "                ", "var_map", "[", "v2", "]", "=", "var_count", "\n", "var_remap_t", ".", "append", "(", "var_count", ")", "\n", "var_count", "=", "var_count", "+", "1", "\n", "_vars", ".", "add", "(", "v2", ")", "\n", "", "else", ":", "\n", "                ", "var_remap_t", ".", "append", "(", "var_map", "[", "v2", "]", ")", "\n", "", "", "var_remap", ".", "append", "(", "var_remap_t", ")", "\n", "\n", "", "def", "find_rev_joined_pos", "(", "full_map", ",", "op_map", ")", ":", "\n", "        ", "rev_index", "=", "[", "]", "\n", "rev_pos", "=", "[", "]", "\n", "for", "i_", ",", "o_", "in", "enumerate", "(", "full_map", ")", ":", "\n", "            ", "if", "o_", "in", "op_map", ":", "\n", "                ", "rev_index", ".", "append", "(", "i_", ")", "\n", "rev_pos", ".", "append", "(", "op_map", ".", "index", "(", "o_", ")", ")", "\n", "", "", "return", "rev_index", ",", "rev_pos", "\n", "\n", "", "def", "find_joined_vars", "(", "var_map1", ",", "var_map2", ")", ":", "\n", "        ", "match_pos1", "=", "[", "]", "\n", "match_pos2", "=", "[", "]", "\n", "for", "v", "in", "var_map1", ":", "\n", "            ", "if", "v", "in", "var_map2", ":", "\n", "                ", "match_pos1", ".", "append", "(", "var_map1", ".", "index", "(", "v", ")", ")", "\n", "match_pos2", ".", "append", "(", "var_map2", ".", "index", "(", "v", ")", ")", "\n", "", "", "umatch_pos2", "=", "[", "var_map2", ".", "index", "(", "v", ")", "for", "v", "in", "var_map2", "if", "v", "not", "in", "var_map1", "]", "\n", "\n", "joined_vars", "=", "[", "v", "for", "v", "in", "var_map1", "]", "\n", "for", "v", "in", "var_map2", ":", "\n", "            ", "if", "v", "not", "in", "joined_vars", ":", "\n", "                ", "joined_vars", ".", "append", "(", "v", ")", "\n", "\n", "", "", "scatter_pos2", "=", "[", "]", "\n", "for", "v", "in", "var_map2", ":", "\n", "            ", "scatter_pos2", ".", "append", "(", "joined_vars", ".", "index", "(", "v", ")", ")", "\n", "\n", "", "return", "match_pos1", ",", "match_pos2", ",", "umatch_pos2", ",", "joined_vars", ",", "scatter_pos2", "\n", "\n", "", "curr_merged", "=", "g_list", "[", "0", "]", "\n", "curr_map", "=", "var_remap", "[", "0", "]", "\n", "all_vars", "=", "[", "]", "\n", "n_z_index", "=", "[", "]", "\n", "n_z_groundings", "=", "False", "\n", "for", "i", ",", "a_", "in", "enumerate", "(", "var_remap", ")", ":", "\n", "        ", "for", "aa_", "in", "a_", ":", "\n", "            ", "if", "aa_", "not", "in", "all_vars", ":", "\n", "                ", "all_vars", ".", "append", "(", "aa_", ")", "\n", "", "", "if", "len", "(", "g_list", "[", "i", "]", ")", "!=", "0", ":", "\n", "            ", "n_z_index", ".", "append", "(", "i", ")", "\n", "", "else", ":", "\n", "            ", "n_z_groundings", "=", "True", "\n", "\n", "", "", "n_z_vars", "=", "[", "]", "\n", "for", "i", "in", "n_z_index", ":", "\n", "        ", "for", "a_", "in", "var_remap", "[", "i", "]", ":", "\n", "            ", "if", "a_", "not", "in", "n_z_vars", ":", "\n", "                ", "n_z_vars", ".", "append", "(", "a_", ")", "\n", "\n", "", "", "", "if", "set", "(", "all_vars", ")", "!=", "set", "(", "n_z_vars", ")", ":", "\n", "        ", "return", "None", ",", "None", "\n", "", "reorder_pos", "=", "[", "None", "]", "*", "len", "(", "all_vars", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "n_z_vars", ")", ")", ":", "\n", "        ", "reorder_pos", "[", "i", "]", "=", "all_vars", ".", "index", "(", "n_z_vars", "[", "i", "]", ")", "\n", "\n", "", "curr_merged", "=", "g_list", "[", "n_z_index", "[", "0", "]", "]", "\n", "curr_map", "=", "var_remap", "[", "n_z_index", "[", "0", "]", "]", "\n", "first_op", "=", "True", "\n", "for", "i", "in", "n_z_index", "[", "1", ":", "]", ":", "\n", "        ", "colllected_g_list_obj", "=", "{", "}", "\n", "curr_to_merge", "=", "g_list", "[", "i", "]", "\n", "(", "\n", "match_pos1", ",", "\n", "match_pos2", ",", "\n", "umatch_pos2", ",", "\n", "joined_vars", ",", "\n", "scatter_pos2", ",", "\n", ")", "=", "find_joined_vars", "(", "curr_map", ",", "var_remap", "[", "i", "]", ")", "\n", "for", "a1", "in", "curr_merged", ":", "\n", "            ", "for", "a2", "in", "curr_to_merge", ":", "\n", "                ", "m1", "=", "[", "a1", "[", "i_", "]", "for", "i_", "in", "match_pos1", "]", "\n", "m2", "=", "[", "a2", "[", "i_", "]", "for", "i_", "in", "match_pos2", "]", "\n", "if", "m1", "==", "m2", ":", "\n", "                    ", "j1", "=", "tuple", "(", "list", "(", "a1", ")", "+", "[", "a2", "[", "k", "]", "for", "k", "in", "umatch_pos2", "]", ")", "\n", "if", "first_op", ":", "\n", "                        ", "colllected_g_list_obj", "[", "j1", "]", "=", "[", "curr_merged", "[", "a1", "]", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "", "else", ":", "\n", "                        ", "colllected_g_list_obj", "[", "j1", "]", "=", "curr_merged", "[", "a1", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "", "", "else", ":", "\n", "                    ", "j1", "=", "tuple", "(", "list", "(", "a1", ")", "+", "[", "a2", "[", "k", "]", "for", "k", "in", "umatch_pos2", "]", ")", "\n", "j2", "=", "[", "None", "]", "*", "len", "(", "joined_vars", ")", "\n", "j2", "[", "0", ":", "len", "(", "a1", ")", "]", "=", "a1", "\n", "for", "i_", ",", "j_", "in", "enumerate", "(", "scatter_pos2", ")", ":", "\n", "                        ", "j2", "[", "j_", "]", "=", "a2", "[", "i_", "]", "\n", "", "j2", "=", "tuple", "(", "j2", ")", "\n", "colllected_g_list_obj", "[", "j1", "]", "=", "[", "curr_merged", "[", "a1", "]", "]", "+", "[", "curr_to_merge", "[", "a2", "]", "]", "\n", "colllected_g_list_obj", "[", "j2", "]", "=", "[", "curr_merged", "[", "a1", "]", "]", "+", "[", "curr_to_merge", "[", "a2", "]", "]", "\n", "if", "first_op", ":", "\n", "                        ", "colllected_g_list_obj", "[", "j1", "]", "=", "[", "curr_merged", "[", "a1", "]", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "colllected_g_list_obj", "[", "j2", "]", "=", "[", "curr_merged", "[", "a1", "]", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "", "else", ":", "\n", "                        ", "colllected_g_list_obj", "[", "j1", "]", "=", "curr_merged", "[", "a1", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "colllected_g_list_obj", "[", "j2", "]", "=", "curr_merged", "[", "a1", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "", "", "", "", "curr_map", "=", "joined_vars", "\n", "curr_merged", "=", "colllected_g_list_obj", "\n", "first_op", "=", "False", "\n", "\n", "", "if", "n_z_groundings", ":", "\n", "        ", "g_obj2", "=", "{", "}", "\n", "for", "g", "in", "curr_merged", ":", "\n", "            ", "g_", "=", "[", "None", "]", "*", "len", "(", "g", ")", "\n", "for", "i", ",", "a_", "in", "enumerate", "(", "g", ")", ":", "\n", "                ", "g_", "[", "reorder_pos", "[", "i", "]", "]", "=", "a_", "\n", "", "g_", "=", "tuple", "(", "g_", ")", "\n", "g_obj", "=", "[", "curr_merged", "[", "g", "]", "]", "\n", "g_new", "=", "[", "]", "\n", "g_obj_indx", "=", "0", "\n", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "                ", "if", "i", "not", "in", "n_z_index", ":", "\n", "                    ", "rev_index", ",", "rev_pos", "=", "find_rev_joined_pos", "(", "all_vars", ",", "var_remap", "[", "i", "]", ")", "\n", "m1", "=", "[", "None", "]", "*", "len", "(", "var_remap", "[", "i", "]", ")", "\n", "for", "i_", ",", "r_", "in", "enumerate", "(", "rev_index", ")", ":", "\n", "                        ", "m1", "[", "rev_pos", "[", "i_", "]", "]", "=", "g_", "[", "r_", "]", "\n", "", "m1", "=", "tuple", "(", "m1", ")", "\n", "if", "operands", "[", "i", "]", ".", "arity", "==", "1", ":", "\n", "                        ", "g_obj_n", "=", "operands", "[", "i", "]", ".", "_ground", "(", "m1", "[", "0", "]", ")", "\n", "operands", "[", "i", "]", ".", "_add_groundings", "(", "g_obj_n", ")", "\n", "", "else", ":", "\n", "                        ", "g_obj_n", "=", "operands", "[", "i", "]", ".", "_ground", "(", "m1", ")", "\n", "operands", "[", "i", "]", ".", "_add_groundings", "(", "g_obj_n", ")", "\n", "", "g_new", ".", "append", "(", "g_obj_n", ")", "\n", "", "else", ":", "\n", "                    ", "g_new", ".", "append", "(", "g_obj", "[", "g_obj_indx", "]", ")", "\n", "g_obj_indx", "=", "g_obj_indx", "+", "1", "\n", "", "", "g_obj2", "[", "g_", "]", "=", "g_new", "\n", "", "curr_merged", "=", "g_obj2", "\n", "\n", "", "g_obj", "=", "[", "None", "]", "*", "n_ops", "\n", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "        ", "g_obj", "[", "i", "]", "=", "[", "]", "\n", "", "for", "gg", "in", "curr_merged", ".", "values", "(", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "            ", "g_obj", "[", "i", "]", ".", "append", "(", "gg", "[", "i", "]", ")", "\n", "\n", "", "", "return", "list", "(", "curr_merged", ".", "keys", "(", ")", ")", ",", "g_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._nested_loop_join_inner": [[545, 713], ["torch.no_grad", "len", "set", "enumerate", "range", "range", "curr_merged.values", "g.split", "var_remap.append", "enumerate", "set", "set", "range", "len", "len", "all_vars.index", "_gm._nested_loop_join_outer.find_joined_vars"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_nested_loop_join_inner", "(", "g_list", ",", "arg_str", ",", "bindings", ",", "operands", ")", ":", "\n", "\n", "    ", "\"\"\"\n    E.g  Join two Predicates P1(x,y) and P2(x,z,y) with groundings\n    (x1,y1) : g11 (ground object)  and (x1,z1,y1) : g12\n    (x2,y2) : g21 (ground object)  and (x2,z2,y2) : g22\n    (x1,y3) : g31 (ground object)  and (x2,z3,y2) : g32\n\n    Inputs\n\n    arg_str : is the list of strings : ['x,y','x,z,y']\n    bindings : list of bindings for each variable\n    g_list : is the list [ g_list[0], g_list[1]]\n    where g_list[0] is the dictionary g_list[0]\n       [(x1,y1)] = g11 ; [(x2,y2)] = g21 ; [(x1,y3)] = g31\n    and g_list[1] is the dictionary g_list[1]\n       [(x1,z1,y1)] = g12;[(x2,z2,y2)] = g2;[(x2,z3,y3)] = g32\n\n    **Returns**\n\n    list_tuples:\n        List of joined ground tuples: [(x1,y1,z1), (x2,y2,z2), ...]\n    object: List of list of  ground objects for each operand\n       [[g11,g21], [g12,g22], ...]\n\n    \"\"\"", "\n", "n_ops", "=", "len", "(", "g_list", ")", "\n", "var_list", "=", "[", "g", ".", "split", "(", "\", \"", ")", "for", "g", "in", "arg_str", "]", "\n", "_vars", "=", "set", "(", ")", "\n", "var_map", "=", "{", "}", "\n", "var_count", "=", "0", "\n", "var_remap", "=", "[", "]", "\n", "for", "v", "in", "var_list", ":", "\n", "        ", "var_remap_t", "=", "[", "]", "\n", "for", "v2", "in", "v", ":", "\n", "            ", "if", "v2", "not", "in", "_vars", ":", "\n", "                ", "var_map", "[", "v2", "]", "=", "var_count", "\n", "var_remap_t", ".", "append", "(", "var_count", ")", "\n", "var_count", "=", "var_count", "+", "1", "\n", "_vars", ".", "add", "(", "v2", ")", "\n", "", "else", ":", "\n", "                ", "var_remap_t", ".", "append", "(", "var_map", "[", "v2", "]", ")", "\n", "", "", "var_remap", ".", "append", "(", "var_remap_t", ")", "\n", "\n", "", "def", "find_rev_joined_pos", "(", "full_map", ",", "op_map", ")", ":", "\n", "        ", "rev_index", "=", "[", "]", "\n", "rev_pos", "=", "[", "]", "\n", "for", "i_", ",", "o_", "in", "enumerate", "(", "full_map", ")", ":", "\n", "            ", "if", "o_", "in", "op_map", ":", "\n", "                ", "rev_index", ".", "append", "(", "i_", ")", "\n", "rev_pos", ".", "append", "(", "op_map", ".", "index", "(", "o_", ")", ")", "\n", "", "", "return", "rev_index", ",", "rev_pos", "\n", "\n", "", "def", "find_joined_vars", "(", "var_map1", ",", "var_map2", ")", ":", "\n", "        ", "match_pos1", "=", "[", "]", "\n", "match_pos2", "=", "[", "]", "\n", "for", "v", "in", "var_map1", ":", "\n", "            ", "if", "v", "in", "var_map2", ":", "\n", "                ", "match_pos1", ".", "append", "(", "var_map1", ".", "index", "(", "v", ")", ")", "\n", "match_pos2", ".", "append", "(", "var_map2", ".", "index", "(", "v", ")", ")", "\n", "", "", "umatch_pos2", "=", "[", "var_map2", ".", "index", "(", "v", ")", "for", "v", "in", "var_map2", "if", "v", "not", "in", "var_map1", "]", "\n", "\n", "joined_vars", "=", "[", "v", "for", "v", "in", "var_map1", "]", "\n", "for", "v", "in", "var_map2", ":", "\n", "            ", "if", "v", "not", "in", "joined_vars", ":", "\n", "                ", "joined_vars", ".", "append", "(", "v", ")", "\n", "\n", "", "", "scatter_pos2", "=", "[", "]", "\n", "for", "v", "in", "var_map2", ":", "\n", "            ", "scatter_pos2", ".", "append", "(", "joined_vars", ".", "index", "(", "v", ")", ")", "\n", "\n", "", "return", "match_pos1", ",", "match_pos2", ",", "umatch_pos2", ",", "joined_vars", ",", "scatter_pos2", "\n", "\n", "", "all_vars", "=", "[", "]", "\n", "n_z_index", "=", "[", "]", "\n", "n_z_groundings", "=", "False", "\n", "for", "i", ",", "a_", "in", "enumerate", "(", "var_remap", ")", ":", "\n", "        ", "for", "aa_", "in", "a_", ":", "\n", "            ", "if", "aa_", "not", "in", "all_vars", ":", "\n", "                ", "all_vars", ".", "append", "(", "aa_", ")", "\n", "", "", "if", "len", "(", "g_list", "[", "i", "]", ")", "!=", "0", ":", "\n", "            ", "n_z_index", ".", "append", "(", "i", ")", "\n", "", "else", ":", "\n", "            ", "n_z_groundings", "=", "True", "\n", "\n", "", "", "n_z_vars", "=", "[", "]", "\n", "for", "i", "in", "n_z_index", ":", "\n", "        ", "for", "a_", "in", "var_remap", "[", "i", "]", ":", "\n", "            ", "if", "a_", "not", "in", "n_z_vars", ":", "\n", "                ", "n_z_vars", ".", "append", "(", "a_", ")", "\n", "\n", "", "", "", "if", "set", "(", "all_vars", ")", "!=", "set", "(", "n_z_vars", ")", ":", "\n", "        ", "curr_merged", "=", "g_list", "[", "0", "]", "\n", "g_obj", "=", "[", "None", "]", "*", "n_ops", "\n", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "            ", "g_obj", "[", "i", "]", "=", "[", "]", "\n", "", "return", "list", "(", "curr_merged", ".", "keys", "(", ")", ")", ",", "g_obj", "\n", "\n", "", "reorder_pos", "=", "[", "None", "]", "*", "len", "(", "all_vars", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "n_z_vars", ")", ")", ":", "\n", "        ", "reorder_pos", "[", "i", "]", "=", "all_vars", ".", "index", "(", "n_z_vars", "[", "i", "]", ")", "\n", "\n", "", "curr_merged", "=", "g_list", "[", "n_z_index", "[", "0", "]", "]", "\n", "curr_map", "=", "var_remap", "[", "n_z_index", "[", "0", "]", "]", "\n", "first_op", "=", "True", "\n", "for", "i", "in", "n_z_index", "[", "1", ":", "]", ":", "\n", "        ", "colllected_g_list_obj", "=", "{", "}", "\n", "curr_to_merge", "=", "g_list", "[", "i", "]", "\n", "match_pos1", ",", "match_pos2", ",", "umatch_pos2", ",", "joined_vars", ",", "_", "=", "find_joined_vars", "(", "\n", "curr_map", ",", "var_remap", "[", "i", "]", "\n", ")", "\n", "for", "a1", "in", "curr_merged", ":", "\n", "            ", "for", "a2", "in", "curr_to_merge", ":", "\n", "                ", "m1", "=", "[", "a1", "[", "i_", "]", "for", "i_", "in", "match_pos1", "]", "\n", "m2", "=", "[", "a2", "[", "i_", "]", "for", "i_", "in", "match_pos2", "]", "\n", "if", "m1", "==", "m2", ":", "\n", "                    ", "j1", "=", "tuple", "(", "list", "(", "a1", ")", "+", "[", "a2", "[", "k", "]", "for", "k", "in", "umatch_pos2", "]", ")", "\n", "if", "first_op", ":", "\n", "                        ", "colllected_g_list_obj", "[", "j1", "]", "=", "[", "curr_merged", "[", "a1", "]", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "", "else", ":", "\n", "                        ", "colllected_g_list_obj", "[", "j1", "]", "=", "curr_merged", "[", "a1", "]", "+", "[", "\n", "curr_to_merge", "[", "a2", "]", "\n", "]", "\n", "", "", "", "", "curr_map", "=", "joined_vars", "\n", "curr_merged", "=", "colllected_g_list_obj", "\n", "first_op", "=", "False", "\n", "\n", "", "if", "n_z_groundings", ":", "\n", "        ", "g_obj2", "=", "{", "}", "\n", "for", "g", "in", "curr_merged", ":", "\n", "            ", "g_", "=", "[", "None", "]", "*", "len", "(", "g", ")", "\n", "for", "i", ",", "a_", "in", "enumerate", "(", "g", ")", ":", "\n", "                ", "g_", "[", "reorder_pos", "[", "i", "]", "]", "=", "a_", "\n", "", "g_", "=", "tuple", "(", "g_", ")", "\n", "g_obj", "=", "[", "curr_merged", "[", "g", "]", "]", "\n", "g_new", "=", "[", "]", "\n", "g_obj_indx", "=", "0", "\n", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "                ", "if", "i", "not", "in", "n_z_index", ":", "\n", "                    ", "rev_index", ",", "rev_pos", "=", "find_rev_joined_pos", "(", "all_vars", ",", "var_remap", "[", "i", "]", ")", "\n", "m1", "=", "[", "None", "]", "*", "len", "(", "var_remap", "[", "i", "]", ")", "\n", "for", "i_", ",", "r_", "in", "enumerate", "(", "rev_index", ")", ":", "\n", "                        ", "m1", "[", "rev_pos", "[", "i_", "]", "]", "=", "g_", "[", "r_", "]", "\n", "", "m1", "=", "tuple", "(", "m1", ")", "\n", "if", "operands", "[", "i", "]", ".", "arity", "==", "1", ":", "\n", "                        ", "g_obj_n", "=", "operands", "[", "i", "]", ".", "_ground", "(", "m1", "[", "0", "]", ")", "\n", "operands", "[", "i", "]", ".", "_add_groundings", "(", "g_obj_n", ")", "\n", "", "else", ":", "\n", "                        ", "g_obj_n", "=", "operands", "[", "i", "]", ".", "_ground", "(", "m1", ")", "\n", "operands", "[", "i", "]", ".", "_add_groundings", "(", "g_obj_n", ")", "\n", "", "g_new", ".", "append", "(", "g_obj_n", ")", "\n", "", "else", ":", "\n", "                    ", "g_new", ".", "append", "(", "g_obj", "[", "g_obj_indx", "]", ")", "\n", "g_obj_indx", "=", "g_obj_indx", "+", "1", "\n", "", "", "g_obj2", "[", "g_", "]", "=", "g_new", "\n", "", "curr_merged", "=", "g_obj2", "\n", "\n", "", "g_obj", "=", "[", "None", "]", "*", "n_ops", "\n", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "        ", "g_obj", "[", "i", "]", "=", "[", "]", "\n", "", "for", "gg", "in", "curr_merged", ".", "values", "(", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_ops", ")", ":", "\n", "            ", "g_obj", "[", "i", "]", ".", "append", "(", "gg", "[", "i", "]", ")", "\n", "\n", "", "", "return", "list", "(", "curr_merged", ".", "keys", "(", ")", ")", ",", "g_obj", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.is_grounding_in_bindings": [[715, 728], ["all", "range", "len"], "function", ["None"], ["", "def", "is_grounding_in_bindings", "(", "\n", "self", ":", "_Formula", ",", "\n", "operand_idx", ":", "int", ",", "\n", "operand_grounding", ":", "_Grounding", ",", "\n", ")", "->", "bool", ":", "\n", "    ", "return", "all", "(", "\n", "True", "\n", "if", "self", ".", "bindings", "[", "operand_idx", "]", "[", "slot", "]", "==", "[", "None", "]", "\n", "else", "(", "\n", "operand_grounding", ".", "partial_grounding", "[", "slot", "]", "\n", "in", "self", ".", "bindings", "[", "operand_idx", "]", "[", "slot", "]", "\n", ")", "\n", "for", "slot", "in", "range", "(", "len", "(", "self", ".", "bindings", "[", "operand_idx", "]", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._hash_join": [[731, 745], ["torch.no_grad", "list", "list", "set", "all", "list.append", "range", "len"], "function", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_hash_join", "(", "operands", ":", "_Formula", ",", "groundings", ":", "Set", ")", "->", "Set", ":", "\n", "    ", "\"\"\"get groundings that appear in all children\"\"\"", "\n", "\n", "# limit grounding_table join to given groundings", "\n", "grounding_tables", "=", "list", "(", "\n", "{", "g", ":", "op", ".", "grounding_table", "[", "g", "]", "for", "g", "in", "groundings", "if", "g", "in", "op", ".", "grounding_table", "}", "\n", "for", "op", "in", "operands", "\n", ")", "\n", "result", "=", "list", "(", ")", "\n", "for", "g", "in", "groundings", ":", "\n", "        ", "if", "all", "(", "g", "in", "grounding_tables", "[", "slot", "]", "for", "slot", "in", "range", "(", "len", "(", "operands", ")", ")", ")", ":", "\n", "            ", "result", ".", "append", "(", "g", ")", "\n", "", "", "return", "set", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm._masked_negate": [[747, 753], ["hasattr", "bounds.where", "_utils.negate_bounds"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds"], ["", "def", "_masked_negate", "(", "self", ":", "_Formula", ",", "bounds", ":", "torch", ".", "Tensor", ",", "dim", ":", "int", "=", "-", "2", ")", ":", "\n", "    ", "\"\"\"negate bounds where weights are negative\"\"\"", "\n", "if", "hasattr", "(", "self", ".", "neuron", ",", "\"weights\"", ")", ":", "\n", "        ", "result", "=", "bounds", ".", "where", "(", "self", ".", "neuron", ".", "weights", ".", "data", ">=", "0", ",", "negate_bounds", "(", "bounds", ",", "dim", ")", ")", "\n", "return", "result", "\n", "", "return", "bounds", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Variable.__init__": [[38, 41], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ":", "str", ",", "ctype", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "ctype", "=", "ctype", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Variable.__str__": [[42, 45], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "r\"\"\"Returns the name of the free variable\"\"\"", "\n", "return", "self", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.__init__": [[84, 95], ["_utils.MultiInstance.__init__", "str", "isinstance", "len", "tuple", "map"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "constants", ":", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "constants", ")", "\n", "self", ".", "name", "=", "str", "(", "constants", ")", "\n", "if", "isinstance", "(", "constants", ",", "tuple", ")", ":", "\n", "            ", "self", ".", "grounding_arity", "=", "len", "(", "constants", ")", "\n", "self", ".", "partial_grounding", "=", "tuple", "(", "\n", "map", "(", "self", ".", "_partial_grounding_from_str", ",", "constants", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "grounding_arity", "=", "1", "\n", "self", ".", "partial_grounding", "=", "(", "self", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding._partial_grounding_from_str": [[96, 100], ["None"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "_partial_grounding_from_str", "(", "cls", ",", "constant", ":", "str", ")", "->", "_Grounding", ":", "\n", "        ", "r\"\"\"Returns partial Grounding given grounding str\"\"\"", "\n", "return", "_Grounding", ".", "instances", "[", "constant", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.ground_by_groundings": [[101, 108], ["cls.__class__", "len", "tuple", "str"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "ground_by_groundings", "(", "cls", ",", "*", "grounding", ":", "_Grounding", ")", ":", "\n", "        ", "r\"\"\"Reduce a tuple of groundings to a single grounding\"\"\"", "\n", "return", "(", "\n", "grounding", "[", "0", "]", "\n", "if", "len", "(", "grounding", ")", "==", "1", "\n", "else", "cls", ".", "__class__", "(", "tuple", "(", "str", "(", "g", ")", "for", "g", "in", "grounding", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.__len__": [[110, 113], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "r\"\"\"Returns the length of the grounding arity\"\"\"", "\n", "return", "self", ".", "grounding_arity", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.__str__": [[114, 117], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "r\"\"\"Returns the name of the grounding\"\"\"", "\n", "return", "self", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.eval": [[118, 122], ["logic._Grounding.eval"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Grounding.eval"], ["", "@", "staticmethod", "\n", "def", "eval", "(", "grounding", ":", "_Grounding", ")", "->", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ":", "\n", "        ", "r\"\"\"Returns the original constant(s) in str or tuple-of-str form\"\"\"", "\n", "return", "eval", "(", "grounding", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.class_name": [[139, 143], ["_Formula.unique_num.setdefault"], "methods", ["None"], ["@", "property", "\n", "def", "class_name", "(", "self", ")", "->", "str", ":", "\n", "        ", "_Formula", ".", "unique_num", ".", "setdefault", "(", "self", ".", "__class__", ".", "__name__", ",", "0", ")", "\n", "return", "self", ".", "__class__", ".", "__name__", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.__init__": [[144, 187], ["_exceptions.AssertCalledPredicate", "kwds.get", "list", "list", "kwds.get", "logic._Formula._inherit_from_subformulae", "_exceptions.AssertWorld", "list", "dict"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._inherit_from_subformulae"], ["", "def", "__init__", "(", "\n", "self", ",", "\n", "*", "formula", ":", "_Formula", ",", "\n", "name", ":", "Optional", "[", "str", "]", "=", "\"\"", ",", "\n", "arity", ":", "int", "=", "None", ",", "\n", "world", ":", "World", "=", "World", ".", "OPEN", ",", "\n", "**", "kwds", ",", "\n", ")", ":", "\n", "# check if all subformula has called predicates", "\n", "        ", "_exceptions", ".", "AssertCalledPredicate", "(", "formula", ")", "\n", "\n", "# formula naming", "\n", "self", ".", "name", "=", "(", "\n", "name", "\n", "if", "name", "\n", "else", "(", "f\"{self.class_name}_{_Formula.unique_num[self.class_name]}\"", ")", "\n", ")", "\n", "_Formula", ".", "unique_num", "[", "self", ".", "class_name", "]", "+=", "1", "\n", "self", ".", "join_method", "=", "kwds", ".", "get", "(", "\"join\"", ",", "Join", ".", "INNER", ")", "\n", "\n", "# construct edge and operand list for each formula", "\n", "self", ".", "edge_list", "=", "list", "(", ")", "\n", "self", ".", "operands", "=", "list", "(", ")", "\n", "\n", "# formula arity", "\n", "self", ".", "arity", "=", "arity", "\n", "\n", "# inherit propositional, variables, and graphs", "\n", "self", ".", "propositional", "=", "kwds", ".", "get", "(", "\"propositional\"", ")", "\n", "self", ".", "_inherit_from_subformulae", "(", "*", "formula", ")", "\n", "\n", "# formula truth world assumption", "\n", "_exceptions", ".", "AssertWorld", "(", "world", ")", "\n", "self", ".", "world", "=", "world", "\n", "\n", "# formula grounding table maps grounded objects to table rows", "\n", "self", ".", "grounding_table", "=", "None", "if", "self", ".", "propositional", "else", "dict", "(", ")", "\n", "\n", "# placeholder for neural variables and functions", "\n", "self", ".", "variables", "=", "list", "(", "[", "None", "]", "*", "arity", ")", "\n", "self", ".", "neuron", "=", "None", "\n", "self", ".", "func", "=", "None", "\n", "self", ".", "func_inv", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.set_propositional": [[188, 190], ["None"], "methods", ["None"], ["", "def", "set_propositional", "(", "self", ",", "propositional", ":", "bool", ")", "->", "None", ":", "\n", "        ", "self", ".", "propositional", "=", "propositional", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._inherit_from_subformulae": [[191, 248], ["list", "enumerate", "isinstance", "logic._Formula.set_propositional", "logic._Formula._update_variables", "logic._Formula._update_map", "logic._Formula.edge_list.extend", "list.append", "logic._Formula.edge_list.append", "logic._Formula.operands.append", "list.append", "logic._Formula.edge_list.append", "logic._Formula.operands.append", "isinstance", "tuple", "any"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.set_propositional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._update_variables", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._update_map"], ["", "def", "_inherit_from_subformulae", "(", "self", ",", "*", "subformula", ":", "Union", "[", "_Formula", ",", "Tuple", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        _inherit_from_subformula(*Union[_Formulae, _Formula(*Variable)])\n\n        provides manual manual variable remapping if given with variables:\n            i.e. _Formula used as a function via `__call__`\n        alternatively inherits remapping from operands if formula is not called\n\n        \"\"\"", "\n", "\n", "# inheritance variables", "\n", "self", ".", "operand_vars", "=", "[", "None", "]", "*", "self", ".", "arity", "\n", "self", ".", "var_remap", "=", "[", "None", "]", "*", "self", ".", "arity", "\n", "self", ".", "bindings", "=", "[", "None", "]", "*", "self", ".", "arity", "\n", "self", ".", "binding_str", "=", "[", "None", "]", "*", "self", ".", "arity", "\n", "self", ".", "has_remapping_vars", "=", "True", "\n", "\n", "subformulae", "=", "list", "(", ")", "\n", "for", "slot", ",", "f", "in", "enumerate", "(", "subformula", ")", ":", "\n", "# manual variable remapping from`__called__` operands", "\n", "# And(Predicate(x, y)) ... Or(Predicate(x, y)) ...", "\n", "            ", "if", "isinstance", "(", "f", ",", "tuple", ")", ":", "\n", "                ", "self", ".", "operand_vars", "[", "slot", "]", "=", "f", "[", "1", "]", "\n", "self", ".", "var_remap", "[", "slot", "]", "=", "f", "[", "2", "]", "\n", "self", ".", "bindings", "[", "slot", "]", "=", "f", "[", "3", "]", "\n", "self", ".", "binding_str", "[", "slot", "]", "=", "f", "[", "4", "]", "\n", "subformulae", ".", "append", "(", "f", "[", "0", "]", ")", "\n", "\n", "self", ".", "edge_list", ".", "append", "(", "(", "self", ",", "f", "[", "0", "]", ")", ")", "\n", "self", ".", "operands", ".", "append", "(", "f", "[", "0", "]", ")", "\n", "\n", "# inherit variable remapping from 'uncalled' operands", "\n", "# for higher level connective formulae", "\n", "", "else", ":", "\n", "                ", "if", "not", "f", ".", "propositional", ":", "\n", "                    ", "self", ".", "var_remap", "[", "slot", "]", "=", "f", ".", "unique_vars", "\n", "self", ".", "operand_vars", "[", "slot", "]", "=", "f", ".", "unique_vars", "\n", "self", ".", "bindings", "[", "slot", "]", "=", "tuple", "(", "[", "[", "None", "]", "]", ")", "\n", "", "subformulae", ".", "append", "(", "f", ")", "\n", "\n", "self", ".", "edge_list", ".", "append", "(", "(", "self", ",", "f", ")", ")", "\n", "self", ".", "operands", ".", "append", "(", "f", ")", "\n", "\n", "# inherit propositional flag from children", "\n", "", "", "if", "self", ".", "propositional", "is", "None", ":", "\n", "            ", "self", ".", "set_propositional", "(", "\n", "False", "if", "any", "(", "[", "not", "f", ".", "propositional", "for", "f", "in", "subformulae", "]", ")", "else", "True", "\n", ")", "\n", "\n", "# inherit variables from children", "\n", "", "if", "not", "self", ".", "propositional", "and", "not", "isinstance", "(", "self", ",", "_LeafFormula", ")", ":", "\n", "            ", "self", ".", "_update_variables", "(", "*", "self", ".", "var_remap", ")", "\n", "self", ".", "_update_map", "(", ")", "\n", "\n", "# expand formula graph to include all subformulae", "\n", "", "if", "subformulae", ":", "\n", "            ", "self", ".", "edge_list", ".", "extend", "(", "[", "edge", "for", "f", "in", "subformulae", "for", "edge", "in", "f", ".", "edge_list", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._update_variables": [[249, 260], ["_gm.unique_variables", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.unique_variables"], ["", "", "def", "_update_variables", "(", "self", ",", "*", "variables", ":", "Tuple", "[", "Variable", ",", "...", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        **Notes**\n\n        If the formula grounding_arity is not specified, it will be inherited\n            from the variables. If variables are not specified, both the\n            `grounding_arity` and variables are inherited from groundings\n\n        \"\"\"", "\n", "self", ".", "variables", "=", "self", ".", "unique_vars", "=", "_gm", ".", "unique_variables", "(", "*", "variables", ")", "\n", "self", ".", "num_unique_vars", "=", "len", "(", "self", ".", "unique_vars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._update_map": [[261, 274], ["enumerate", "len", "tuple", "enumerate"], "methods", ["None"], ["", "def", "_update_map", "(", "self", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        Update the 'operand_map' to map parent groundings to operand groundings\n        \"\"\"", "\n", "self", ".", "operand_map", "=", "[", "None", "]", "*", "len", "(", "self", ".", "operand_vars", ")", "\n", "for", "op_index", ",", "op_vars", "in", "enumerate", "(", "self", ".", "var_remap", ")", ":", "\n", "            ", "op_map", "=", "[", "\n", "var_index", "\n", "for", "var_op", "in", "self", ".", "var_remap", "[", "op_index", "]", "\n", "for", "var_index", ",", "var", "in", "enumerate", "(", "self", ".", "unique_vars", ")", "\n", "if", "var", "==", "var_op", "\n", "]", "\n", "self", ".", "operand_map", "[", "op_index", "]", "=", "tuple", "(", "op_map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._set_world": [[275, 279], ["_exceptions.AssertWorld", "logic._Formula.neuron.set_world"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.set_world"], ["", "", "def", "_set_world", "(", "self", ",", "world", ":", "World", ")", "->", "None", ":", "\n", "        ", "_exceptions", ".", "AssertWorld", "(", "world", ")", "\n", "self", ".", "world", "=", "world", "\n", "self", ".", "neuron", ".", "set_world", "(", "world", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._is_grounded": [[280, 283], ["isinstance"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_is_grounded", "(", "groundings", ":", "Union", "[", "_Grounding", ",", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ")", "->", "bool", ":", "\n", "        ", "return", "isinstance", "(", "groundings", ",", "_Grounding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground": [[284, 329], ["logic._Formula._is_grounded", "isinstance", "logic._Grounding", "all", "Exception", "Exception", "Exception", "len", "type", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._is_grounded"], ["", "def", "_ground", "(", "\n", "self", ",", "\n", "grounding", ":", "Union", "[", "_Grounding", ",", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ",", "\n", "arity_match", ":", "bool", "=", "True", ",", "\n", ")", "->", "_Grounding", ":", "\n", "        ", "r\"\"\"returns a single grounded object\n\n        **Example**\n\n        ```python\n        # for arity == 1\n        self._ground('str_1')\n        ```\n        ```python\n        # for arity > 1\n        grounding = ('str_1', 'str_2', ...)\n        self._ground(grounding)\n        ```\n\n        **Warning**\n\n        only grounds one object at a time due to tuple confusion\n        for multiple objects\n\n        \"\"\"", "\n", "if", "_Formula", ".", "_is_grounded", "(", "grounding", ")", ":", "\n", "            ", "return", "grounding", "\n", "", "if", "isinstance", "(", "grounding", ",", "tuple", ")", ":", "\n", "            ", "if", "not", "all", "(", "[", "type", "(", "g", ")", "in", "[", "str", ",", "None", "]", "for", "g", "in", "grounding", "]", ")", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"expected groundings as tuple of str for num_unique_vars \"", "\n", "f\" > 1, received {type(grounding)} {grounding}\"", "\n", ")", "\n", "", "if", "len", "(", "grounding", ")", "!=", "self", ".", "num_unique_vars", "and", "arity_match", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"expected grounding length to be of \"", "\n", "f\"arity {self.num_unique_vars}, received {grounding}\"", "\n", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "self", ".", "num_unique_vars", "!=", "1", "and", "arity_match", ":", "\n", "                ", "raise", "Exception", "(", "\n", "f\"{self} received str as grounding, expected grounding \"", "\n", "f\"({grounding}) as a tuple of len {self.num_unique_vars}\"", "\n", ")", "\n", "", "", "return", "_Grounding", "(", "grounding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings": [[330, 363], ["logic._Formula.neuron.extend_groundings", "logic._Formula.grounding_table.update", "len", "len", "enumerate"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.extend_groundings"], ["", "def", "_add_groundings", "(", "self", ",", "*", "groundings", ":", "_Grounding", ")", "->", "None", ":", "\n", "        ", "r\"\"\"add missing groundings to `grounding_table`\n\n        **Returns**\n\n        tuple:  groundings in grounded form\n\n        **Example**\n\n        ```python\n        # for formulae with arity == 1:\n        model['formula']._add_groundings(_Grounding_1, _Grounding_2)\n        ```\n        ```python\n        # for formulae with arity > 1:\n        groundings = ((_Grounding_1, _Grounding_7),\n                      (_Grounding_2, _Grounding_8))\n        model['formula']._add_groundings(*groundings)\n        ```\n\n        **Warning**\n\n        groundings must be given in grounded form: `self._ground('grounding')`\n        _add_groundings should not be directly called\n        - instead use `model.add_facts('node': Fact)`\n\n        \"\"\"", "\n", "missing_groundings", "=", "{", "g", "for", "g", "in", "groundings", "if", "g", "not", "in", "self", ".", "grounding_table", "}", "\n", "if", "len", "(", "missing_groundings", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "table_rows", "=", "self", ".", "neuron", ".", "extend_groundings", "(", "len", "(", "missing_groundings", ")", ")", "\n", "self", ".", "grounding_table", ".", "update", "(", "\n", "{", "g", ":", "table_rows", "[", "i", "]", "for", "i", ",", "g", "in", "enumerate", "(", "missing_groundings", ")", "}", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_facts": [[365, 417], ["_exceptions.AssertBounds", "logic._Formula.neuron.add_facts", "isinstance", "logic._Formula.neuron.add_facts", "tuple", "tuple", "logic._Formula._add_groundings", "isinstance", "facts.keys", "facts.pop", "facts.keys", "Exception", "logic._Formula._ground", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.pop", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground"], ["", "def", "_add_facts", "(", "self", ",", "facts", ":", "Union", "[", "Fact", ",", "Tuple", ",", "Set", ",", "Dict", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"Populate formula with fact\n\n        Facts given in bool, tuple or None, assumes a propositional formula.\n        Facts given in dict form assume FOL, keyed by the grounding, where the\n            value also required in bool, tuple or None\n\n        **Warning**\n\n        Formulae facts should not be modified directly, rather provide facts\n        on a per model basis\n        All subsequent models that are instantiated with formulae that have\n            existing facts will clone facts into the models\n\n        **Example**\n\n        usage from within a model\n        ```python\n        # Propositional:\n        model['proposition']._add_facts(TRUE)\n        ```\n        ```python\n        # First-order logic\n        model['predicate']._add_facts({'grounding': TRUE})\n        ```\n\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "# Propositional facts", "\n", "            ", "_exceptions", ".", "AssertBounds", "(", "facts", ")", "\n", "self", ".", "neuron", ".", "add_facts", "(", "facts", ",", "update_leaves", "=", "True", ")", "\n", "\n", "", "else", ":", "# FOL facts", "\n", "            ", "if", "isinstance", "(", "facts", ",", "dict", ")", ":", "# facts given per grounding", "\n", "# replace fact keys (str -> _Groundings)", "\n", "                ", "groundings", "=", "tuple", "(", "facts", ".", "keys", "(", ")", ")", "\n", "for", "g", "in", "groundings", ":", "\n", "                    ", "facts", "[", "self", ".", "_ground", "(", "g", ")", "]", "=", "facts", ".", "pop", "(", "g", ")", "\n", "\n", "# add missing groundings to `grounding_table`", "\n", "", "groundings", "=", "tuple", "(", "facts", ".", "keys", "(", ")", ")", "\n", "self", ".", "_add_groundings", "(", "*", "groundings", ")", "\n", "\n", "# set facts for all groundings", "\n", "table_facts", "=", "{", "self", ".", "grounding_table", "[", "g", "]", ":", "facts", "[", "g", "]", "for", "g", "in", "groundings", "}", "\n", "", "elif", "isinstance", "(", "facts", ",", "set", ")", ":", "# broadcast facts across groundings", "\n", "                ", "table_facts", "=", "facts", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"FOL facts should be from [dict, set], \"", "\n", "f'\"{self}\" received {type(facts)}'", "\n", ")", "\n", "", "self", ".", "neuron", ".", "add_facts", "(", "table_facts", ",", "update_leaves", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts": [[418, 431], ["list", "logic._Formula.neuron.get_facts", "logic._Formula.neuron.get_facts", "len", "logic._Formula.grounding_table.get", "logic._Formula._ground"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground"], ["", "", "def", "get_facts", "(", "\n", "self", ",", "*", "groundings", ":", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", ",", "_Grounding", "]", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"returns bounds_table slices\n\n        if groundings is None, the whole table will return\n        elif a tuple of groundings returns appropriate slices\n        \"\"\"", "\n", "if", "self", ".", "propositional", "or", "len", "(", "groundings", ")", "==", "0", ":", "\n", "            ", "return", "self", ".", "neuron", ".", "get_facts", "(", ")", "\n", "", "table_rows", "=", "list", "(", "self", ".", "grounding_table", ".", "get", "(", "self", ".", "_ground", "(", "g", ")", ")", "for", "g", "in", "groundings", ")", "\n", "result", "=", "self", ".", "neuron", ".", "get_facts", "(", "table_rows", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_labels": [[432, 438], ["torch.stack", "len", "logic._Formula.labels.get", "len", "logic._Formula._ground"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground"], ["", "def", "get_labels", "(", "self", ",", "*", "groundings", ":", "str", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"returns labels if no groundings else tuple of given bounds\"\"\"", "\n", "if", "self", ".", "propositional", "or", "len", "(", "groundings", ")", "==", "0", ":", "\n", "            ", "return", "self", ".", "labels", "\n", "", "result", "=", "torch", ".", "stack", "(", "[", "self", ".", "labels", ".", "get", "(", "self", ".", "_ground", "(", "g", ")", ")", "for", "g", "in", "groundings", "]", ")", "\n", "return", "result", "[", "0", "]", "if", "len", "(", "groundings", ")", "==", "1", "else", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_labels": [[439, 474], ["_exceptions.AssertBounds", "_utils.fact_to_bounds", "isinstance", "hasattr", "dict", "tuple", "Exception", "labels.keys", "_utils.fact_to_bounds", "labels.pop", "logic._Formula._ground", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.fact_to_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.pop", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground"], ["", "def", "_add_labels", "(", "self", ",", "labels", ":", "Union", "[", "Fact", ",", "Tuple", "[", "str", ",", "...", "]", ",", "Set", ",", "Dict", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"Populate labels with fact\n\n        Facts given in bool, tuple or None, assumes a propositional formula.\n        Facts given in dict form assume FOL, keyed by the grounding, where the\n            value also required in bool, tuple or None\n\n        **Example**\n\n        ```python\n        # Propositional\n        model.add_labels({'proposition': TRUE})\n        ```\n        ```python\n        # First-order logic\n        model.add_labels({'predicate': {'grounding': TRUE}})\n        ```\n\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "# Propositional labels", "\n", "            ", "_exceptions", ".", "AssertBounds", "(", "labels", ")", "\n", "self", ".", "labels", "=", "_utils", ".", "fact_to_bounds", "(", "labels", ",", "True", ")", "\n", "\n", "", "else", ":", "# FOL labels", "\n", "            ", "if", "not", "hasattr", "(", "self", ",", "\"labels\"", ")", ":", "\n", "                ", "self", ".", "labels", "=", "dict", "(", ")", "\n", "", "if", "isinstance", "(", "labels", ",", "dict", ")", ":", "# labels given per grounding", "\n", "                ", "for", "g", "in", "tuple", "(", "labels", ".", "keys", "(", ")", ")", ":", "\n", "# set labels for groundings, replace str keys -> Groundings", "\n", "                    ", "self", ".", "labels", "[", "self", ".", "_ground", "(", "g", ")", "]", "=", "_utils", ".", "fact_to_bounds", "(", "\n", "labels", ".", "pop", "(", "g", ")", ",", "True", "\n", ")", "\n", "", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "\n", "\"FOL facts should be from [dict, set], \"", "\n", "f'\"{self}\" received {type(labels)}'", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.groundings": [[477, 480], ["None"], "methods", ["None"], ["", "", "", "@", "property", "\n", "def", "groundings", "(", "self", ")", "->", "Set", ":", "\n", "        ", "return", "{", "g", "for", "g", "in", "self", ".", "grounding_table", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state": [[481, 520], ["_utils.node_state", "logic._Formula.neuron.state", "utils.fact_to_bool", "logic._Formula._ground", "logic._Formula.get_facts", "len", "LookupError", "logic._Formula.neuron.state", "isinstance", "str", "logic._Formula.state", "str"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.node_state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.fact_to_bool", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "state", "(", "\n", "self", ",", "\n", "groundings", ":", "Union", "[", "\n", "str", ",", "Tuple", "[", "str", ",", "...", "]", ",", "List", "[", "str", "]", ",", "List", "[", "Tuple", "[", "str", ",", "...", "]", "]", "\n", "]", "=", "None", ",", "\n", "to_bool", ":", "bool", "=", "False", ",", "\n", "bounds", ":", "torch", ".", "Tensor", "=", "None", ",", "\n", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "Dict", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "r\"\"\"returns the state of a single grounded fact\n\n        if to_bool flag is True, will map classical Facts to bool:\n            i.e. {Fact.True: True, FALSE': False}\n        The rest of the node states will return as str\n\n        **Notes**\n\n        see section (F.2)[https://arxiv.org/abs/2006.13155] for more\n            information on node states\n\n        \"\"\"", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "result", "=", "self", ".", "neuron", ".", "state", "(", ")", "\n", "", "else", ":", "\n", "            ", "if", "bounds", "is", "None", ":", "\n", "                ", "if", "groundings", "is", "None", "or", "isinstance", "(", "groundings", ",", "list", ")", ":", "\n", "                    ", "result", "=", "{", "\n", "str", "(", "g", ")", ":", "self", ".", "state", "(", "g", ")", "\n", "for", "g", "in", "(", "\n", "self", ".", "grounding_table", "if", "groundings", "is", "None", "else", "groundings", "\n", ")", "\n", "}", "\n", "return", "result", "\n", "", "groundings", "=", "self", ".", "_ground", "(", "groundings", ")", "\n", "bounds", "=", "self", ".", "get_facts", "(", "groundings", ")", "\n", "", "if", "len", "(", "bounds", ")", "==", "0", ":", "\n", "                ", "raise", "LookupError", "(", "f\"grounding {groundings} not found in {str(self)}\"", ")", "\n", "", "result", "=", "self", ".", "neuron", ".", "state", "(", "bounds", "[", "None", ",", ":", "]", ")", "[", "0", "]", "\n", "", "result", "=", "_utils", ".", "node_state", "(", "result", ")", "\n", "return", "utils", ".", "fact_to_bool", "(", "result", ")", "if", "to_bool", "else", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print": [[521, 645], ["tuple", "dict", "_utils.param_symbols.items", "logic._Formula.print"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.items", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["", "def", "print", "(", "\n", "self", ",", "\n", "header_len", ":", "int", "=", "50", ",", "\n", "roundoff", ":", "int", "=", "5", ",", "\n", "params", ":", "bool", "=", "False", ",", "\n", "grads", ":", "bool", "=", "False", ",", "\n", ")", "->", "None", ":", "\n", "        ", "r\"\"\"\n        print the state of the formula\n\n        ```\n        OPEN   Proposition: A                 UNKNOWN (L, U)\n\n        CLOSED Proposition: B                   FALSE (L, U)\n\n        OPEN   Predicate: P1 (x)\n        'const_1'                                TRUE (L, U)\n        'const_2'                       CONTRADICTION (L, U)\n        'const_3'                               FALSE (L, U)\n\n        OPEN   Predicate: P2 (x, y)\n        ('const_1', 'const_5')                   TRUE (L, U)\n        ('const_2', 'const_6')          CONTRADICTION (L, U)\n        ('const_3', 'const_7')                  FALSE (L, U)\n\n        OPEN   And: And_0 (x, y)\n        Bindings: P1 (x: 'const_1'), P2 (x: 'const_2', y: ['const_3', ...])\n        ('const_1', 'const_3')                   TRUE (L, U)\n        ('const_2', 'const_3')          CONTRADICTION (L, U)\n        ('const_1', 'const_7')                  FALSE (L, U)\n\n        TRUE   ForAll: ForAll_0 (y)           UNKNOWN (L, U)\n        ```\n\n        \"\"\"", "\n", "\n", "def", "state_wrapper", "(", "grounding", ":", "_Grounding", ")", ":", "\n", "            ", "return", "(", "\n", "f\"'{grounding}'\"", "if", "grounding", ".", "grounding_arity", "==", "1", "else", "f\"{grounding}\"", "\n", ")", "\n", "\n", "", "def", "round_bounds", "(", "grounding", "=", "None", ")", ":", "\n", "            ", "return", "tuple", "(", "\n", "[", "\n", "round", "(", "r", ",", "roundoff", ")", "\n", "for", "r", "in", "(", "\n", "self", ".", "get_facts", "(", "grounding", ")", "\n", "if", "self", ".", "propositional", "\n", "else", "self", ".", "get_facts", "(", "grounding", ")", "[", "0", "]", "\n", ")", ".", "tolist", "(", ")", "\n", "]", "\n", ")", "\n", "\n", "", "header", "=", "f\"{self.world.name:<6} \"", "f\"{self.__class__.__name__}: \"", "f\"{str(self)}\"", "\n", "if", "params", ":", "\n", "            ", "params", "=", "dict", "(", ")", "\n", "for", "name", ",", "symbol", "in", "_utils", ".", "param_symbols", ".", "items", "(", ")", ":", "\n", "                ", "if", "hasattr", "(", "self", ".", "neuron", ",", "name", ")", ":", "\n", "                    ", "val", "=", "getattr", "(", "self", ".", "neuron", ",", "name", ")", "\n", "params", "[", "symbol", "]", "=", "f\"{np.around(val.tolist(), roundoff)}\"", "+", "(", "\n", "f\" grads {np.around(val.grad.tolist(), roundoff)}\"", "\n", "if", "grads", "and", "val", ".", "grad", "is", "not", "None", "\n", "else", "\"\"", "\n", ")", "\n", "", "", "params", "=", "\"params  \"", "+", "\",  \"", ".", "join", "(", "[", "f\"{k}: {v}\"", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "params", "=", "\"\"", "\n", "\n", "# extract variables", "\n", "", "var_str", "=", "(", "\n", "\"\"", "\n", "if", "not", "(", "hasattr", "(", "self", ",", "\"unique_vars\"", ")", "and", "self", ".", "unique_vars", ")", "\n", "else", "(", "\n", "str", "(", "tuple", "(", "[", "str", "(", "v", ")", "for", "v", "in", "self", ".", "unique_vars", "]", ")", ")", "\n", "if", "(", "len", "(", "self", ".", "unique_vars", ")", ">", "1", ")", "\n", "else", "(", "str", "(", "f\"({self.unique_vars[0]})\"", ")", ")", "\n", ")", "\n", ")", "\n", "\n", "# print propositional node - single bounds", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "states", "=", "(", "\n", "f'{\" \".join([header, var_str]):<{header_len}} '", "\n", "f\"{self.state().name:>13} \"", "\n", "f\"{round_bounds()}\\n\"", "\n", "f\"{params}\"", "\n", ")", "\n", "print", "(", "states", ")", "\n", "\n", "# print FOL node - table of bounds", "\n", "", "else", ":", "\n", "            ", "facts", "=", "(", "\n", "[", "\"\"", "]", "\n", "if", "self", ".", "grounding_table", "is", "None", "\n", "else", "(", "\n", "[", "\n", "(", "\n", "f\"{state_wrapper(g):{header_len}} \"", "\n", "f\"{self.state(g).name:>13} \"", "\n", "f\"{round_bounds(g)}\\n\"", "\n", ")", "\n", "for", "g", "in", "self", ".", "grounding_table", "\n", "]", "\n", ")", "\n", ")", "\n", "var_str", "=", "(", "\n", "\"\"", "\n", "if", "not", "(", "hasattr", "(", "self", ",", "\"unique_vars\"", ")", "and", "self", ".", "unique_vars", ")", "\n", "else", "(", "\n", "str", "(", "tuple", "(", "[", "str", "(", "v", ")", "for", "v", "in", "self", ".", "unique_vars", "]", ")", ")", "\n", "if", "(", "len", "(", "self", ".", "unique_vars", ")", ">", "1", ")", "\n", "else", "(", "str", "(", "f\"({self.unique_vars[0]})\"", ")", ")", "\n", ")", "\n", ")", "\n", "\n", "binder", "=", "list", "(", ")", "\n", "for", "i", ",", "op", "in", "enumerate", "(", "self", ".", "operands", ")", ":", "\n", "                ", "if", "var_str", "and", "not", "self", ".", "propositional", "and", "self", ".", "_has_bindings", "(", "i", ")", ":", "\n", "                    ", "binder", ".", "append", "(", "f\"{op} ({self.binding_str[i]})\"", ")", "\n", "", "", "bind_str", "=", "(", "\"\\nBindings: \"", "+", "\", \"", ".", "join", "(", "binder", ")", ")", "if", "binder", "else", "\"\"", "\n", "header", "=", "f\"{header}{var_str} {bind_str}\"", "\n", "params", "=", "f\"\\n{params}\"", "if", "params", "else", "\"\"", "\n", "header", "=", "f\"{header}{params}\"", "\n", "print", "(", "f\"{header}\\n\"", "+", "\"\"", ".", "join", "(", "facts", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush": [[646, 649], ["logic._Formula.neuron.flush"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "flush", "(", "self", ")", "->", "None", ":", "\n", "        ", "r\"\"\"set all facts in formula to 'Unknown'\"\"\"", "\n", "self", ".", "neuron", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction": [[650, 653], ["logic._Formula.neuron.is_contradiction"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction"], ["", "def", "is_contradiction", "(", "self", ",", "bounds", ":", "torch", ".", "Tensor", "=", "None", ")", "->", "torch", ".", "BoolTensor", ":", "\n", "        ", "r\"\"\"check if bounds are in contradiction\"\"\"", "\n", "return", "self", ".", "neuron", ".", "is_contradiction", "(", "bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._has_bindings": [[654, 669], ["isinstance", "any", "any", "logic._Formula._has_bindings", "range", "len", "range", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._has_bindings"], ["", "def", "_has_bindings", "(", "self", ",", "slot", ":", "int", "=", "None", ")", "->", "bool", ":", "\n", "        ", "r\"\"\"Returns True if Formula has any bindings\"\"\"", "\n", "if", "isinstance", "(", "slot", ",", "int", ")", ":", "\n", "            ", "return", "(", "\n", "True", "\n", "if", "any", "(", "\n", "[", "\n", "self", ".", "bindings", "[", "slot", "]", "[", "i", "]", "[", "j", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "bindings", "[", "slot", "]", ")", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "self", ".", "bindings", "[", "slot", "]", "[", "i", "]", ")", ")", "\n", "]", "\n", ")", "\n", "else", "False", "\n", ")", "\n", "", "return", "any", "(", "[", "self", ".", "_has_bindings", "(", "i", ")", "for", "i", "in", "range", "(", "len", "(", "self", ".", "bindings", ")", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.__call__": [[670, 736], ["list", "list", "list", "len", "Exception", "isinstance", "tuple", "tuple", "list.append", "list.append", "isinstance", "list.append", "list.append", "list.append", "isinstance", "Exception", "list.append", "isinstance", "len", "list.append", "Exception", "logic._Formula._ground", "logic._Formula._ground", "type", "type"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._ground"], ["", "def", "__call__", "(", "\n", "self", ",", "*", "variables", ":", "Union", "[", "Variable", ",", "Tuple", "[", "Variable", ",", "Union", "[", "str", ",", "List", "[", "str", "]", "]", "]", "]", "\n", ")", "->", "Tuple", "[", "\n", "_Formula", ",", "\n", "List", "[", "Union", "[", "Variable", ",", "None", "]", "]", ",", "\n", "Tuple", "[", "List", "[", "Union", "[", "Variable", ",", "None", "]", "]", ",", "...", "]", ",", "\n", "Tuple", "[", "Union", "[", "_Grounding", ",", "None", "]", ",", "...", "]", ",", "\n", "str", ",", "\n", "]", ":", "\n", "        ", "r\"\"\"variable remapping between operator and operand variables\n\n        **Example**\n\n        FOL formulae that appear in connectives are callable:\n            Note `A`, `B` in the `And`\n        ```python\n        x = Variable('x')\n        model['A'] = Predicate()\n        model['B'] = Predicate()\n        model['AB'] = And(A(x), B(x))\n        ```\n\n        **Returns**\n\n        _Formula: reference to the child object\n        variables: tuple of child's Variables\n        var_remap: tuple of parent-to-child remapping Variables\n        bindings: tuple of parent-to-child groundings to bind inference to\n            single groundings are _Grounding\n            multiple groundings are list(_Grounding)\n        binding_string: complete bindings given in string form\n\n        \"\"\"", "\n", "if", "len", "(", "variables", ")", "!=", "self", ".", "num_unique_vars", ":", "\n", "            ", "raise", "Exception", "(", "\n", "f\"{self} variables length ({len(variables)}) must be the same \"", "\n", "f\"length as `num_unique_vars` ({self.num_unique_vars})\"", "\n", ")", "\n", "", "bindings", "=", "list", "(", ")", "\n", "_variables", "=", "list", "(", ")", "# variables to return", "\n", "binding_str", "=", "list", "(", ")", "\n", "for", "v", "in", "variables", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "tuple", ")", ":", "\n", "                ", "if", "not", "isinstance", "(", "v", "[", "0", "]", ",", "Variable", ")", ":", "\n", "                    ", "raise", "Exception", "(", "\n", "\"expected a Variable for first tuple input, received \"", "\n", "f\"{[type(v[0]), v[0]]}\"", "\n", ")", "\n", "", "_variables", ".", "append", "(", "v", "[", "0", "]", ")", "\n", "binding_str", ".", "append", "(", "f\"{v[0]}: {v[1]}\"", ")", "\n", "if", "isinstance", "(", "v", "[", "1", "]", ",", "list", ")", ":", "# Pred(x, ['str_1', ...]))", "\n", "                    ", "bindings", ".", "append", "(", "[", "self", ".", "_ground", "(", "g", ",", "arity_match", "=", "False", ")", "for", "g", "in", "v", "[", "1", "]", "]", ")", "\n", "", "elif", "isinstance", "(", "v", "[", "1", "]", ",", "str", ")", ":", "# Pred(x, 'str_1')", "\n", "                    ", "bindings", ".", "append", "(", "[", "self", ".", "_ground", "(", "v", "[", "1", "]", ",", "arity_match", "=", "False", ")", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "Exception", "(", "\n", "\"bindings expected from [str, List(str)],\"", "\n", "f\" received {type(v[1]), v[1]}\"", "\n", ")", "\n", "", "", "else", ":", "\n", "                ", "bindings", ".", "append", "(", "[", "None", "]", ")", "\n", "_variables", ".", "append", "(", "v", ")", "\n", "binding_str", ".", "append", "(", "f\"{v}\"", ")", "\n", "", "binding_str", "=", "[", "\", \"", ".", "join", "(", "binding_str", ")", "]", "\n", "", "binding_str", "=", "\", \"", ".", "join", "(", "binding_str", ")", "\n", "return", "(", "self", ",", "self", ".", "variables", ",", "tuple", "(", "_variables", ")", ",", "tuple", "(", "bindings", ")", ",", "binding_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.__str__": [[737, 739], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "self", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.rename": [[740, 742], ["None"], "methods", ["None"], ["", "def", "rename", "(", "self", ",", "name", ":", "str", ")", "->", "None", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.parameters": [[743, 746], ["logic._Formula.neuron.named_parameters"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters"], ["", "def", "parameters", "(", "self", ")", "->", "Iterator", "[", "torch", ".", "Tensor", "]", ":", "\n", "        ", "for", "name", ",", "param", "in", "self", ".", "neuron", ".", "named_parameters", "(", ")", ":", "\n", "            ", "yield", "param", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters": [[747, 749], ["logic._Formula.neuron.named_parameters"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters"], ["", "", "def", "named_parameters", "(", "self", ")", "->", "Iterator", "[", "Tuple", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "yield", "from", "self", ".", "neuron", ".", "named_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params": [[750, 764], ["list", "dict", "list.append", "ValueError", "len", "logic._Formula.neuron.named_parameters", "getattr().clone().detach", "getattr", "getattr().clone", "getattr"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.named_parameters"], ["", "def", "params", "(", "\n", "self", ",", "*", "params", ":", "str", ",", "detach", ":", "bool", "=", "False", "\n", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "result", "=", "list", "(", ")", "\n", "for", "param", "in", "params", ":", "\n", "            ", "if", "param", "in", "dict", "(", "self", ".", "neuron", ".", "named_parameters", "(", ")", ")", ":", "\n", "                ", "result", ".", "append", "(", "\n", "getattr", "(", "self", ".", "neuron", ",", "param", ")", ".", "clone", "(", ")", ".", "detach", "(", ")", "\n", "if", "detach", "\n", "else", "getattr", "(", "self", ".", "neuron", ",", "param", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"{self} has no attribute: {param}\"", ")", "\n", "", "", "return", "result", "[", "0", "]", "if", "len", "(", "params", ")", "==", "1", "else", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.contradiction_loss": [[765, 772], ["logic._Formula.get_facts", "logic._Formula.is_contradiction"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction"], ["", "def", "contradiction_loss", "(", "self", ",", "coeff", ":", "float", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"Contradiction loss\"\"\"", "\n", "if", "coeff", "is", "None", ":", "\n", "            ", "coeff", "=", "1", "\n", "", "bounds", "=", "self", ".", "get_facts", "(", ")", "\n", "x", "=", "bounds", "[", "...", ",", "0", "]", "-", "bounds", "[", "...", ",", "1", "]", "\n", "return", "(", "self", ".", "is_contradiction", "(", ")", "*", "coeff", "*", "x", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.uncertainty_loss": [[773, 780], ["logic._Formula.get_facts", "logic._Formula.is_contradiction().logical_not", "logic._Formula.is_contradiction"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_contradiction"], ["", "def", "uncertainty_loss", "(", "self", ",", "coeff", ":", "float", "=", "None", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"Uncertainty loss\"\"\"", "\n", "if", "coeff", "is", "None", ":", "\n", "            ", "coeff", "=", "0", "\n", "", "bounds", "=", "self", ".", "get_facts", "(", ")", "\n", "x", "=", "bounds", "[", "...", ",", "1", "]", "-", "bounds", "[", "...", ",", "0", "]", "\n", "return", "(", "self", ".", "is_contradiction", "(", ")", ".", "logical_not", "(", ")", "*", "coeff", "*", "x", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.supervised_loss": [[781, 799], ["torch.nn.MSELoss", "logic._Formula.get_labels", "len", "torch.nn.MSELoss.", "hasattr", "torch.nn.MSELoss.", "logic._Formula.get_facts", "logic._Formula.get_labels", "logic._Formula.labels.numel", "logic._Formula.get_facts"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_labels", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_labels", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts"], ["", "def", "supervised_loss", "(", "self", ",", "coeff", ":", "float", "=", "None", ")", "->", "Union", "[", "None", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "r\"\"\"supervised loss\"\"\"", "\n", "if", "coeff", "is", "None", ":", "\n", "            ", "coeff", "=", "1", "\n", "", "loss", "=", "torch", ".", "nn", ".", "MSELoss", "(", ")", "\n", "if", "(", "\n", "not", "hasattr", "(", "self", ",", "\"labels\"", ")", "\n", "or", "(", "self", ".", "propositional", "and", "not", "self", ".", "labels", ".", "numel", "(", ")", ")", "\n", "or", "(", "not", "self", ".", "propositional", "and", "not", "self", ".", "labels", ")", "\n", ")", ":", "\n", "            ", "return", "\n", "", "labels", "=", "self", ".", "get_labels", "(", ")", "\n", "if", "self", ".", "propositional", ":", "\n", "            ", "return", "coeff", "*", "loss", "(", "self", ".", "get_facts", "(", ")", ",", "labels", ")", "\n", "", "groundings", "=", "[", "g", "for", "g", "in", "labels", "if", "g", "in", "self", ".", "grounding_table", "]", "\n", "if", "len", "(", "groundings", ")", "==", "0", ":", "\n", "            ", "return", "\n", "", "return", "coeff", "*", "loss", "(", "self", ".", "get_facts", "(", "*", "groundings", ")", ",", "self", ".", "get_labels", "(", "*", "groundings", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.reset_bounds": [[800, 802], ["logic._Formula.neuron.reset_bounds"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.reset_bounds"], ["", "def", "reset_bounds", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "neuron", ".", "reset_bounds", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.project_params": [[803, 805], ["logic._Formula.neuron.project_params"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.project_params"], ["", "def", "project_params", "(", "self", ")", "->", "None", ":", "\n", "        ", "self", ".", "neuron", ".", "project_params", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_unweighted": [[808, 811], ["logic._Formula.params", "all"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params"], ["def", "is_unweighted", "(", "self", ")", "->", "bool", ":", "\n", "        ", "bias", ",", "weights", "=", "self", ".", "params", "(", "\"bias\"", ",", "\"weights\"", ")", "\n", "return", "all", "(", "[", "bias", "==", "w", "for", "w", "in", "weights", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.shape": [[812, 815], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", "->", "torch", ".", "Size", ":", "\n", "        ", "return", "self", ".", "neuron", ".", "bounds_table", ".", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_name": [[816, 820], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_formula_name", "(", "*", "formulae", ":", "_Formula", ",", "connective", ":", "str", ")", "->", "str", ":", "\n", "        ", "r\"\"\"Come up with a name for input formula(e)\"\"\"", "\n", "return", "\"(\"", "+", "f\" {connective} \"", ".", "join", "(", "[", "f", ".", "name", "for", "f", "in", "formulae", "]", ")", "+", "\")\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_vars": [[821, 832], ["list", "logic.Variable", "f", "range", "max"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_formula_vars", "(", "*", "formulae", ":", "_Formula", ")", "->", "List", "[", "Union", "[", "_Formula", ",", "Tuple", "]", "]", ":", "\n", "        ", "r\"\"\"\n        Returns a list of formulae as wither called (when predicates)\n        or uncalled as connectives\n        \"\"\"", "\n", "variables", "=", "list", "(", "\n", "Variable", "(", "f\"x{i}\"", ")", "for", "i", "in", "range", "(", "max", "(", "[", "f", ".", "arity", "for", "f", "in", "formulae", "]", ")", ")", "\n", ")", "\n", "return", "[", "\n", "f", "(", "*", "variables", "[", ":", "f", ".", "arity", "]", ")", "if", "not", "f", ".", "propositional", "else", "f", "for", "f", "in", "formulae", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not": [[837, 841], ["logic.Not", "logic._Formula._formula_vars"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_vars"], ["def", "Not", "(", "self", ",", "**", "kwds", ")", "->", "Not", ":", "\n", "        ", "if", "\"name\"", "not", "in", "kwds", ":", "\n", "            ", "kwds", "[", "\"name\"", "]", "=", "f\"\u00ac({self.name})\"", "\n", "", "return", "Not", "(", "*", "self", ".", "_formula_vars", "(", "self", ")", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And": [[845, 849], ["logic.And", "logic._Formula._formula_name", "logic._Formula._formula_vars"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_name", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_vars"], ["def", "And", "(", "self", ",", "*", "formulae", ":", "_Formula", ",", "**", "kwds", ")", "->", "And", ":", "\n", "        ", "if", "\"name\"", "not", "in", "kwds", ":", "\n", "            ", "kwds", "[", "\"name\"", "]", "=", "self", ".", "_formula_name", "(", "self", ",", "*", "formulae", ",", "connective", "=", "\"\u2227\"", ")", "\n", "", "return", "And", "(", "*", "self", ".", "_formula_vars", "(", "self", ")", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or": [[853, 857], ["logic.Or", "logic._Formula._formula_name", "logic._Formula._formula_vars"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_name", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_vars"], ["def", "Or", "(", "self", ",", "*", "formulae", ":", "_Formula", ",", "**", "kwds", ")", "->", "Or", ":", "\n", "        ", "if", "\"name\"", "not", "in", "kwds", ":", "\n", "            ", "kwds", "[", "\"name\"", "]", "=", "self", ".", "_formula_name", "(", "self", ",", "*", "formulae", ",", "connective", "=", "\"\u2228\"", ")", "\n", "", "return", "Or", "(", "*", "self", ".", "_formula_vars", "(", "self", ",", "*", "formulae", ")", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies": [[861, 865], ["logic.Implies", "logic._Formula._formula_name", "logic._Formula._formula_vars"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_name", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_vars"], ["def", "Implies", "(", "self", ",", "formula", ":", "_Formula", ",", "**", "kwds", ")", "->", "Implies", ":", "\n", "        ", "if", "\"name\"", "not", "in", "kwds", ":", "\n", "            ", "kwds", "[", "\"name\"", "]", "=", "self", ".", "_formula_name", "(", "self", ",", "formula", ",", "connective", "=", "\"\u2192\"", ")", "\n", "", "return", "Implies", "(", "*", "self", ".", "_formula_vars", "(", "self", ",", "formula", ")", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional": [[869, 873], ["logic.Bidirectional", "logic._Formula._formula_name", "logic._Formula._formula_vars"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_name", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._formula_vars"], ["def", "Bidirectional", "(", "self", ",", "formula", ":", "_Formula", ",", "**", "kwds", ")", "->", "Bidirectional", ":", "\n", "        ", "if", "\"name\"", "not", "in", "kwds", ":", "\n", "            ", "kwds", "[", "\"name\"", "]", "=", "self", ".", "_formula_name", "(", "self", ",", "formula", ",", "connective", "=", "\"\u2194\"", ")", "\n", "", "return", "Bidirectional", "(", "*", "self", ".", "_formula_vars", "(", "self", ",", "formula", ")", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._LeafFormula.__init__": [[883, 887], ["logic._Formula.__init__", "logic._NodeActivation", "kwds.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwds", ")", "\n", "self", ".", "neuron", "=", "_NodeActivation", "(", ")", "(", "\n", "self", ".", "propositional", ",", "self", ".", "world", ",", "**", "kwds", ".", "get", "(", "\"neuron\"", ",", "{", "}", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Proposition.__init__": [[908, 910], ["logic._LeafFormula.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "\"\"", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "arity", "=", "1", ",", "propositional", "=", "True", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Proposition._add_facts": [[911, 920], ["logic._Formula._add_facts"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._add_facts"], ["", "def", "_add_facts", "(", "self", ",", "fact", ":", "Fact", ")", "->", "None", ":", "\n", "        ", "\"\"\"Populate proposition with facts\n\n        Facts required in bool, tuple or None\n        None fact assumes `Unknown`\n        tuple fact required in bounds form `(Lower, Upper)`\n\n        \"\"\"", "\n", "super", "(", ")", ".", "_add_facts", "(", "fact", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Predicate.__init__": [[944, 949], ["logic._LeafFormula.__init__", "logic.Predicate._update_variables", "Exception", "tuple", "logic.Variable", "range"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._update_variables"], ["def", "__init__", "(", "self", ",", "name", ":", "Optional", "[", "str", "]", "=", "\"\"", ",", "arity", ":", "int", "=", "1", ",", "**", "kwds", ")", ":", "\n", "        ", "if", "arity", "is", "None", ":", "\n", "            ", "raise", "Exception", "(", "f\"arity expected as int > 0, received {arity}\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "arity", "=", "arity", ",", "propositional", "=", "False", ",", "**", "kwds", ")", "\n", "self", ".", "_update_variables", "(", "tuple", "(", "Variable", "(", "f\"x{i}\"", ")", "for", "i", "in", "range", "(", "self", ".", "arity", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Predicate._add_facts": [[950, 962], ["logic._Formula._add_facts"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._add_facts"], ["", "def", "_add_facts", "(", "self", ",", "facts", ":", "Union", "[", "dict", ",", "set", "]", ")", "->", "None", ":", "\n", "        ", "r\"\"\"Populate predicate with facts\n\n        Facts required in dict or set\n            - dict for grounding-based facts\n            - set for broadcasting facts across all groundings\n              requires a set of 1 item\n        dict keys for groundings and values as facts\n        tuple facts required in bounds form `(Lower, Upper)`\n\n        \"\"\"", "\n", "super", "(", ")", ".", "_add_facts", "(", "facts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._ConnectiveFormula.__init__": [[965, 967], ["logic._Formula.__init__"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "formula", ":", "_Formula", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "formula", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._ConnectiveNeuron.__init__": [[970, 980], ["logic._ConnectiveFormula.__init__", "logic._ConnectiveNeuron.neuron.function", "logic._ConnectiveNeuron.neuron.function", "logic._NeuralActivation", "kwds.get().get", "kwds.get", "kwds.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__", "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.function", "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.function"], ["    ", "def", "__init__", "(", "self", ",", "*", "formula", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "formula", ",", "**", "kwds", ")", "\n", "self", ".", "neuron", "=", "_NeuralActivation", "(", "kwds", ".", "get", "(", "\"neuron\"", ",", "{", "}", ")", ".", "get", "(", "\"type\"", ")", ")", "(", "\n", "self", ".", "propositional", ",", "self", ".", "arity", ",", "self", ".", "world", ",", "**", "kwds", ".", "get", "(", "\"neuron\"", ",", "{", "}", ")", "\n", ")", "\n", "self", ".", "func", "=", "self", ".", "neuron", ".", "function", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "direction", "=", "Direction", ".", "UPWARD", "\n", ")", "\n", "self", ".", "func_inv", "=", "self", ".", "neuron", ".", "function", "(", "\n", "self", ".", "__class__", ".", "__name__", ",", "direction", "=", "Direction", ".", "DOWNWARD", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._ConnectiveNeuron.upward": [[982, 1000], ["_gm.upward_bounds", "logic._ConnectiveNeuron.neuron.aggregate_bounds", "logic._ConnectiveNeuron.func", "logic._ConnectiveNeuron.grounding_table.values", "logic._ConnectiveNeuron.grounding_table.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.upward_bounds", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values"], ["", "def", "upward", "(", "\n", "self", ",", "groundings", ":", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", "=", "None", ",", "**", "kwds", "\n", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "None", "]", ":", "\n", "        ", "upward_bounds", "=", "_gm", ".", "upward_bounds", "(", "self", ",", "self", ".", "operands", ",", "groundings", ")", "\n", "if", "upward_bounds", "is", "None", ":", "# contradiction arresting", "\n", "            ", "return", "\n", "", "input_bounds", ",", "groundings", "=", "upward_bounds", "\n", "grounding_rows", "=", "(", "\n", "None", "\n", "if", "self", ".", "propositional", "\n", "else", "(", "\n", "self", ".", "grounding_table", ".", "values", "(", ")", "\n", "if", "groundings", "is", "None", "\n", "else", "[", "self", ".", "grounding_table", ".", "get", "(", "g", ")", "for", "g", "in", "groundings", "]", "\n", ")", "\n", ")", "\n", "result", "=", "self", ".", "neuron", ".", "aggregate_bounds", "(", "grounding_rows", ",", "self", ".", "func", "(", "input_bounds", ")", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._ConnectiveNeuron.downward": [[1001, 1036], ["tuple", "_gm.downward_bounds", "logic._ConnectiveNeuron.func_inv", "enumerate", "op.neuron.aggregate_bounds", "op.grounding_table.values", "enumerate", "len", "logic._Grounding", "op.grounding_table.get", "str", "tuple", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.downward_bounds", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values"], ["", "def", "downward", "(", "\n", "self", ",", "\n", "index", ":", "int", "=", "None", ",", "\n", "groundings", ":", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", "=", "None", ",", "\n", "**", "kwds", ",", "\n", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "None", "]", ":", "\n", "        ", "operands", "=", "tuple", "(", "self", ".", "operands", ")", "\n", "downward_bounds", "=", "_gm", ".", "downward_bounds", "(", "self", ",", "operands", ",", "groundings", ")", "\n", "if", "downward_bounds", "is", "None", ":", "# contradiction arresting", "\n", "            ", "return", "\n", "", "out_bounds", ",", "input_bounds", ",", "groundings", "=", "downward_bounds", "\n", "new_bounds", "=", "self", ".", "func_inv", "(", "out_bounds", ",", "input_bounds", ")", "\n", "op_indices", "=", "(", "\n", "enumerate", "(", "operands", ")", "if", "index", "is", "None", "else", "(", "[", "(", "index", ",", "operands", "[", "index", "]", ")", "]", ")", "\n", ")", "\n", "result", "=", "0", "\n", "for", "op_index", ",", "op", "in", "op_indices", ":", "\n", "            ", "if", "op", ".", "propositional", ":", "\n", "                ", "op_grounding_rows", "=", "None", "\n", "", "else", ":", "\n", "                ", "if", "groundings", "is", "None", ":", "\n", "                    ", "op_grounding_rows", "=", "op", ".", "grounding_table", ".", "values", "(", ")", "\n", "", "else", ":", "\n", "                    ", "op_grounding_rows", "=", "[", "None", "]", "*", "len", "(", "groundings", ")", "\n", "for", "g_i", ",", "g", "in", "enumerate", "(", "groundings", ")", ":", "\n", "                        ", "op_g", "=", "[", "\n", "str", "(", "g", ".", "partial_grounding", "[", "slot", "]", ")", "\n", "for", "slot", "in", "self", ".", "operand_map", "[", "op_index", "]", "\n", "]", "\n", "op_g", "=", "_Grounding", "(", "tuple", "(", "op_g", ")", "if", "len", "(", "op_g", ")", ">", "1", "else", "op_g", "[", "0", "]", ")", "\n", "op_grounding_rows", "[", "g_i", "]", "=", "op", ".", "grounding_table", ".", "get", "(", "op_g", ")", "\n", "", "", "", "result", "=", "result", "+", "op", ".", "neuron", ".", "aggregate_bounds", "(", "\n", "op_grounding_rows", ",", "new_bounds", "[", "...", ",", "op_index", "]", "\n", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._ConnectiveNeuron.logical_loss": [[1037, 1087], ["logic._ConnectiveNeuron.params", "isinstance", "torch.where", "torch.where", "isinstance", "torch.where().sum.detach().clone", "torch.where.detach().clone", "torch.where().sum", "torch.where", "isinstance", "torch.where().sum", "torch.where", "torch.where().sum.square", "torch.where.square", "slacks_true.detach().clone", "slacks_false.detach().clone", "torch.where().sum.detach", "torch.where.detach", "torch.where", "torch.where", "slacks_true.detach", "slacks_false.detach"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params"], ["", "def", "logical_loss", "(", "\n", "self", ",", "coeff", ":", "float", "=", "None", ",", "slacks", ":", "Union", "[", "bool", ",", "float", "]", "=", "None", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"Logical loss to create a loss on logical constraint violation\n\n        Assumes a soft logic computation and calculates the loss on constraints\n        as defined in [equations 86-89](https://arxiv.org/pdf/2006.13155.pdf)\n        when slacks are given, the constraints are allowed to be violated\n        however this affects the neuron interpretability and should only be\n        used if the model is not strictly required to obey a classical\n        definition of logic\n\n        \"\"\"", "\n", "a", ",", "b", ",", "w", "=", "self", ".", "params", "(", "\"alpha\"", ",", "\"bias\"", ",", "\"weights\"", ")", "\n", "T", ",", "F", "=", "a", ",", "1", "-", "a", "\n", "coeff", "=", "1", "if", "coeff", "is", "None", "else", "coeff", "\n", "if", "isinstance", "(", "self", ",", "And", ")", ":", "\n", "            ", "TRUE", "=", "b", "-", "(", "w", "*", "(", "1", "-", "T", ")", ")", ".", "sum", "(", ")", "\n", "FALSE", "=", "b", "-", "(", "w", "*", "(", "1", "-", "F", ")", ")", "\n", "true_hinge", "=", "torch", ".", "where", "(", "TRUE", "<", "T", ",", "T", "-", "TRUE", ",", "TRUE", "*", "0", ")", "\n", "false_hinge", "=", "torch", ".", "where", "(", "FALSE", ">", "F", ",", "FALSE", "-", "F", ",", "FALSE", "*", "0", ")", "\n", "if", "slacks", ":", "\n", "                ", "if", "slacks", "is", "True", ":", "\n", "                    ", "slacks_false", "=", "false_hinge", "*", "(", "false_hinge", ">", "0", ")", "\n", "slacks_true", "=", "true_hinge", "*", "(", "true_hinge", ">", "0", ")", "\n", "false_hinge", "-=", "slacks_false", "\n", "true_hinge", "-=", "slacks_true", "\n", "self", ".", "neuron", ".", "slacks", "=", "(", "\n", "slacks_true", ".", "detach", "(", ")", ".", "clone", "(", ")", ",", "\n", "slacks_false", ".", "detach", "(", ")", ".", "clone", "(", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "false_hinge", "-=", "slacks", "\n", "", "", "self", ".", "neuron", ".", "feasibility", "=", "(", "\n", "true_hinge", ".", "detach", "(", ")", ".", "clone", "(", ")", ",", "\n", "false_hinge", ".", "detach", "(", ")", ".", "clone", "(", ")", ",", "\n", ")", "\n", "\n", "", "elif", "isinstance", "(", "self", ",", "Or", ")", ":", "\n", "            ", "TRUE", "=", "1", "-", "b", "+", "(", "w", "*", "T", ")", "\n", "FALSE", "=", "1", "-", "b", "+", "(", "w", "*", "F", ")", ".", "sum", "(", ")", "\n", "true_hinge", "=", "torch", ".", "where", "(", "TRUE", "<", "T", ",", "T", "-", "TRUE", ",", "TRUE", "*", "0", ")", ".", "sum", "(", ")", "\n", "false_hinge", "=", "torch", ".", "where", "(", "FALSE", ">", "F", ",", "FALSE", "-", "F", ",", "FALSE", "*", "0", ")", "\n", "", "elif", "isinstance", "(", "self", ",", "Implies", ")", ":", "\n", "            ", "TRUE", "=", "1", "-", "b", "+", "(", "w", "*", "T", ")", "# T = 1-F for x and T for y", "\n", "FALSE", "=", "1", "-", "b", "+", "(", "w", "[", "0", "]", "*", "(", "1", "-", "T", ")", ")", "+", "(", "w", "[", "1", "]", "*", "F", ")", "\n", "true_hinge", "=", "torch", ".", "where", "(", "TRUE", "<", "T", ",", "T", "-", "TRUE", ",", "TRUE", "*", "0", ")", ".", "sum", "(", ")", "\n", "false_hinge", "=", "torch", ".", "where", "(", "FALSE", ">", "F", ",", "FALSE", "-", "F", ",", "FALSE", "*", "0", ")", "\n", "", "result", "=", "(", "true_hinge", ".", "square", "(", ")", "+", "false_hinge", ".", "square", "(", ")", ")", ".", "sum", "(", ")", "\n", "return", "coeff", "*", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._BinaryNeuron.__init__": [[1092, 1099], ["logic._ConnectiveNeuron.__init__", "len", "Exception", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "formula", ",", "**", "kwds", ")", ":", "\n", "        ", "if", "len", "(", "formula", ")", "!=", "2", ":", "\n", "            ", "raise", "Exception", "(", "\n", "\"Binary neurons expect 2 formulae as inputs, received \"", "\n", "f\"{len(formula)}\"", "\n", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "formula", ",", "arity", "=", "2", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NAryNeuron.__init__": [[1104, 1106], ["logic._ConnectiveNeuron.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "formula", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "formula", ",", "arity", "=", "len", "(", "formula", ")", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Bidirectional.__init__": [[1236, 1242], ["logic._BinaryNeuron.__init__", "logic.Bidirectional.neuron.function", "logic.Bidirectional.neuron.function", "logic.Implies", "logic.Implies"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__", "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.function", "home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.function", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies"], ["def", "__init__", "(", "self", ",", "*", "formula", ",", "**", "kwds", ")", ":", "\n", "        ", "lhs", ",", "rhs", "=", "formula", "\n", "self", ".", "Imp1", ",", "self", ".", "Imp2", "=", "Implies", "(", "lhs", ",", "rhs", ")", ",", "Implies", "(", "rhs", ",", "lhs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "Imp1", ",", "self", ".", "Imp2", ",", "**", "kwds", ")", "\n", "self", ".", "func", "=", "self", ".", "neuron", ".", "function", "(", "\"And\"", ",", "direction", "=", "Direction", ".", "UPWARD", ")", "\n", "self", ".", "func_inv", "=", "self", ".", "neuron", ".", "function", "(", "\"And\"", ",", "direction", "=", "Direction", ".", "DOWNWARD", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Bidirectional.upward": [[1243, 1247], ["logic.Bidirectional.Imp1.upward", "logic.Bidirectional.Imp2.upward", "logic._ConnectiveNeuron.upward"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward"], ["", "def", "upward", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "self", ".", "Imp1", ".", "upward", "(", "*", "args", ",", "**", "kwds", ")", "\n", "self", ".", "Imp2", ".", "upward", "(", "*", "args", ",", "**", "kwds", ")", "\n", "return", "super", "(", ")", ".", "upward", "(", "*", "args", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Bidirectional.downward": [[1248, 1252], ["logic.Bidirectional.Imp1.downward", "logic.Bidirectional.Imp2.downward", "logic._ConnectiveNeuron.downward"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward"], ["", "def", "downward", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "self", ".", "Imp1", ".", "downward", "(", "*", "args", ",", "**", "kwds", ")", "\n", "self", ".", "Imp2", ".", "downward", "(", "*", "args", ",", "**", "kwds", ")", "\n", "return", "super", "(", ")", ".", "downward", "(", "*", "args", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._UnaryOperator.__init__": [[1257, 1263], ["logic._ConnectiveFormula.__init__", "len", "Exception", "len"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "formula", ":", "_Formula", ",", "**", "kwds", ")", ":", "\n", "        ", "if", "len", "(", "formula", ")", "!=", "1", ":", "\n", "            ", "raise", "Exception", "(", "\n", "\"Unary operator expect 1 formula as input, received \"", "f\"{len(formula)}\"", "\n", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "formula", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Not.__init__": [[1295, 1301], ["kwds.setdefault", "logic._UnaryOperator.__init__", "isinstance", "logic._NodeActivation", "kwds.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "operand", ",", "**", "kwds", ")", ":", "\n", "        ", "self", ".", "operand", "=", "operand", "[", "0", "]", "if", "isinstance", "(", "operand", ",", "Tuple", ")", "else", "operand", "\n", "kwds", ".", "setdefault", "(", "\"name\"", ",", "\"Not_\"", "+", "self", ".", "operand", ".", "name", ")", "\n", "super", "(", ")", ".", "__init__", "(", "operand", ",", "arity", "=", "1", ",", "**", "kwds", ")", "\n", "self", ".", "neuron", "=", "_NodeActivation", "(", ")", "(", "\n", "self", ".", "propositional", ",", "self", ".", "world", ",", "**", "kwds", ".", "get", "(", "\"neuron\"", ",", "{", "}", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Not.upward": [[1303, 1313], ["logic.Not.neuron.aggregate_bounds", "tuple", "_utils.negate_bounds", "logic.Not.operand.get_facts", "logic.Not._add_groundings"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings"], ["", "def", "upward", "(", "self", ",", "**", "kwds", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "if", "self", ".", "propositional", ":", "\n", "            ", "groundings", "=", "{", "None", "}", "\n", "", "else", ":", "\n", "            ", "groundings", "=", "tuple", "(", "self", ".", "operand", ".", "groundings", ")", "\n", "for", "g", "in", "groundings", ":", "\n", "                ", "if", "g", "not", "in", "self", ".", "grounding_table", ":", "\n", "                    ", "self", ".", "_add_groundings", "(", "g", ")", "\n", "", "", "", "return", "self", ".", "neuron", ".", "aggregate_bounds", "(", "\n", "None", ",", "_utils", ".", "negate_bounds", "(", "self", ".", "operand", ".", "get_facts", "(", "*", "groundings", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Not.downward": [[1315, 1325], ["logic.Not.operand.neuron.aggregate_bounds", "tuple", "_utils.negate_bounds", "logic.Not.get_facts", "logic.Not.operand._add_groundings"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.negate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._add_groundings"], ["", "def", "downward", "(", "self", ",", "**", "kwds", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "if", "self", ".", "propositional", ":", "\n", "            ", "groundings", "=", "{", "None", "}", "\n", "", "else", ":", "\n", "            ", "groundings", "=", "tuple", "(", "self", ".", "groundings", ")", "\n", "for", "g", "in", "groundings", ":", "\n", "                ", "if", "g", "not", "in", "self", ".", "operand", ".", "groundings", ":", "\n", "                    ", "self", ".", "operand", ".", "_add_groundings", "(", "g", ")", "\n", "", "", "", "return", "self", ".", "operand", ".", "neuron", ".", "aggregate_bounds", "(", "\n", "None", ",", "_utils", ".", "negate_bounds", "(", "self", ".", "get_facts", "(", "*", "groundings", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.__init__": [[1347, 1359], ["logic._Formula.__init__", "kwds.get", "logic._Quantifier._update_variables", "tuple", "set", "logic._Quantifier._set_activation", "logic._Quantifier.var_remap[].index"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula._update_variables", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._set_activation"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "args", "[", "-", "1", "]", ",", "arity", "=", "1", ",", "propositional", "=", "True", ",", "**", "kwds", ")", "\n", "self", ".", "fully_grounded", "=", "kwds", ".", "get", "(", "\"fully_grounded\"", ",", "False", ")", "\n", "\n", "# dimensions to quantify over", "\n", "self", ".", "_update_variables", "(", "args", "[", ":", "-", "1", "]", ")", "\n", "self", ".", "unique_var_slots", "=", "tuple", "(", "\n", "self", ".", "var_remap", "[", "0", "]", ".", "index", "(", "v", ")", "for", "v", "in", "self", ".", "unique_vars", "\n", ")", "\n", "\n", "self", ".", "_grounding_set", "=", "set", "(", ")", "\n", "self", ".", "_set_activation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward": [[1360, 1379], ["len", "logic._Quantifier._upward_bounds", "logic._Quantifier.neuron.aggregate_bounds", "len", "logic._Quantifier._set_activation", "logic._Quantifier.func", "logic._Quantifier.permute", "isinstance"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._upward_bounds", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._set_activation"], ["", "def", "upward", "(", "self", ",", "**", "kwds", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "None", "]", ":", "\n", "        ", "r\"\"\"Returns sum of bounds tightening from UPWARD inference\"\"\"", "\n", "n_groundings", "=", "len", "(", "self", ".", "_grounding_set", ")", "\n", "input_bounds", "=", "self", ".", "_upward_bounds", "(", "self", ".", "operands", "[", "0", "]", ")", "\n", "if", "input_bounds", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "if", "len", "(", "self", ".", "_grounding_set", ")", ">", "n_groundings", ":", "\n", "            ", "self", ".", "_set_activation", "(", ")", "\n", "", "result", "=", "self", ".", "neuron", ".", "aggregate_bounds", "(", "\n", "None", ",", "\n", "self", ".", "func", "(", "input_bounds", ".", "permute", "(", "[", "1", ",", "0", "]", ")", ")", ",", "\n", "bound", "=", "(", "\n", "(", "\"upper\"", "if", "isinstance", "(", "self", ",", "ForAll", ")", "else", "\"lower\"", ")", "\n", "if", "not", "self", ".", "fully_grounded", "\n", "else", "None", "\n", ")", ",", "\n", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._set_activation": [[1380, 1407], ["logic._Quantifier.neuron.function", "isinstance", "logic._NeuralActivation", "len", "isinstance"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.neuron.neuron._NeuronActivation.function"], ["", "def", "_set_activation", "(", "self", ")", "->", "None", ":", "\n", "        ", "\"\"\"Updates the neural activation according to grounding dimension size\n\n        The computation of a quantifier is implemented via one of the weighed\n            neurons, And/Or for ForAll/Exists.\n        At present, weighted quantifiers have not been well studied and is\n            therefore turned off\n        However the dimension of computation is different, computing over the\n            groundings of the input formula instead of multiple formulae, since\n            there can only be one formula to quantify over.\n        The activation is therefore required to grow according to number of\n            groundings present in the formula, which can grow as groundings\n            propagate via inference.\n\n        \"\"\"", "\n", "operator", "=", "(", "\n", "\"And\"", "\n", "if", "isinstance", "(", "self", ",", "ForAll", ")", "\n", "else", "(", "\"Or\"", "if", "isinstance", "(", "self", ",", "Exists", ")", "else", "None", ")", "\n", ")", "\n", "self", ".", "neuron", "=", "_NeuralActivation", "(", ")", "(", "\n", "self", ".", "propositional", ",", "\n", "len", "(", "self", ".", "_grounding_set", ")", ",", "\n", "self", ".", "world", ",", "\n", "neuron", "=", "{", "\"weights_learning\"", ":", "False", ",", "\"bias_learning\"", ":", "False", "}", ",", "\n", ")", "\n", "self", ".", "func", "=", "self", ".", "neuron", ".", "function", "(", "operator", ",", "direction", "=", "Direction", ".", "UPWARD", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.has_free_variables": [[1408, 1412], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "has_free_variables", "(", "self", ")", "->", "bool", ":", "\n", "        ", "r\"\"\"Returns True if the quantifier contains free variables\"\"\"", "\n", "return", "{", "*", "self", ".", "variables", "}", "!=", "{", "*", "self", ".", "var_remap", "[", "0", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.true_groundings": [[1413, 1422], ["set", "tuple", "str", "logic._Quantifier.operands[].state"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "@", "property", "\n", "def", "true_groundings", "(", "self", ")", "->", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", ":", "\n", "        ", "r\"\"\"Returns set of groundings that are True\"\"\"", "\n", "return", "set", "(", "\n", "tuple", "(", "\n", "str", "(", "g", ".", "partial_grounding", "[", "slot", "]", ")", "\n", "for", "g", "in", "self", ".", "_grounding_set", "\n", "if", "self", ".", "operands", "[", "0", "]", ".", "state", "(", "g", ")", "is", "Fact", ".", "TRUE", "\n", "for", "slot", "in", "self", ".", "unique_var_slots", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._upward_bounds": [[1425, 1440], ["set", "set", "operand.get_facts", "len", "_gm.is_grounding_in_bindings"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic._gm.is_grounding_in_bindings"], ["", "def", "_upward_bounds", "(", "self", ",", "operand", ":", "_Formula", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "None", "]", ":", "\n", "        ", "r\"\"\"set Quantifer grounding table and return operand tensor\"\"\"", "\n", "operand_grounding_set", "=", "set", "(", "operand", ".", "grounding_table", ")", "\n", "if", "len", "(", "operand_grounding_set", ")", "==", "0", ":", "\n", "            ", "return", "\n", "\n", "", "self", ".", "_grounding_set", "=", "set", "(", "\n", "[", "\n", "grounding", "\n", "for", "grounding", "in", "operand_grounding_set", "\n", "if", "_gm", ".", "is_grounding_in_bindings", "(", "self", ",", "0", ",", "grounding", ")", "\n", "]", "\n", ")", "\n", "result", "=", "operand", ".", "get_facts", "(", "*", "self", ".", "_grounding_set", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.groundings": [[1441, 1444], ["set", "map"], "methods", ["None"], ["", "@", "property", "\n", "def", "groundings", "(", "self", ")", "->", "Set", "[", "Union", "[", "str", ",", "Tuple", "[", "str", ",", "...", "]", "]", "]", ":", "\n", "        ", "return", "set", "(", "map", "(", "_Grounding", ".", "eval", ",", "self", ".", "_grounding_set", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._add_facts": [[1445, 1448], ["logic._Formula._add_facts", "logic._Quantifier._set_activation"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier._set_activation"], ["", "def", "_add_facts", "(", "self", ",", "facts", ":", "Union", "[", "Tuple", "[", "float", ",", "float", "]", ",", "Fact", ",", "Set", "]", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "_add_facts", "(", "facts", ")", "\n", "self", ".", "_set_activation", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.__init__": [[1466, 1473], ["kwds.setdefault", "logic._Quantifier.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "kwds", ".", "setdefault", "(", "\n", "\"name\"", ",", "\n", "\"All_\"", "\n", "+", "(", "args", "[", "-", "1", "]", "[", "0", "]", ".", "name", "if", "isinstance", "(", "args", "[", "-", "1", "]", ",", "Tuple", ")", "else", "args", "[", "-", "1", "]", ".", "name", ")", ",", "\n", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward": [[1474, 1483], ["logic.ForAll.get_facts", "operand.grounding_table.keys", "operand.neuron.aggregate_bounds", "operand.grounding_table.get"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys", "home.repos.pwc.inspect_result.IBM_LNN.activations.node._NodeActivation.aggregate_bounds"], ["", "def", "downward", "(", "self", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"Returns sum of bounds tightening from DOWNWARD inference\"\"\"", "\n", "operand", "=", "self", ".", "operands", "[", "0", "]", "\n", "current_bounds", "=", "self", ".", "get_facts", "(", ")", "\n", "groundings", "=", "operand", ".", "grounding_table", ".", "keys", "(", ")", "\n", "result", "=", "operand", ".", "neuron", ".", "aggregate_bounds", "(", "\n", "[", "operand", ".", "grounding_table", ".", "get", "(", "g", ")", "for", "g", "in", "groundings", "]", ",", "current_bounds", "\n", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.Exists.__init__": [[1501, 1508], ["kwds.setdefault", "logic._Quantifier.__init__", "isinstance"], "methods", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwds", ")", ":", "\n", "        ", "kwds", ".", "setdefault", "(", "\n", "\"name\"", ",", "\n", "\"Some_\"", "\n", "+", "(", "args", "[", "-", "1", "]", "[", "0", "]", ".", "name", "if", "isinstance", "(", "args", "[", "-", "1", "]", ",", "Tuple", ")", "else", "args", "[", "-", "1", "]", ".", "name", ")", ",", "\n", ")", "\n", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NodeActivation.__call__": [[1511, 1514], ["getattr", "importlib.import_module"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "propositional", ":", "bool", ",", "world", ":", "World", ",", "**", "kwds", ")", ":", "\n", "        ", "return", "getattr", "(", "import_module", "(", "\"lnn.neural.activations.node\"", ")", ",", "\"_NodeActivation\"", ")", "(", "\n", "propositional", ",", "world", ",", "**", "kwds", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__init__": [[1520, 1526], ["importlib.import_module", "logic._NeuralActivation.neuron_type.name.lower"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "type", "=", "None", ")", ":", "\n", "        ", "self", ".", "neuron_type", "=", "(", "\n", "type", "if", "type", "else", "(", "NeuralActivationClass", ".", "LukasiewiczTransparent", ")", "\n", ")", "\n", "self", ".", "module", "=", "import_module", "(", "\n", "f\"lnn.neural.methods.{self.neuron_type.name.lower()}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._NeuralActivation.__call__": [[1528, 1531], ["getattr"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "propositional", ":", "bool", ",", "arity", ":", "int", ",", "world", ":", "World", ",", "**", "kwds", ")", ":", "\n", "        ", "return", "getattr", "(", "self", ".", "module", ",", "self", ".", "neuron_type", ".", "name", ")", "(", "\n", "propositional", ",", "arity", ",", "world", ",", "**", "kwds", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.general.test_predicate.test_predicate_called": [[12, 24], ["pytest.mark.parametrize", "lnn.Predicate", "pytest.raises", "CompoundFormulae", "pytest.raises", "CompoundFormulae", "pytest.raises", "CompoundFormulae", "lnn.Predicate.", "lnn.Predicate."], "function", ["None"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"CompoundFormulae\"", ",", "[", "And", ",", "Or", ",", "Implies", ",", "Bidirectional", "]", ")", "\n", "def", "test_predicate_called", "(", "CompoundFormulae", ")", ":", "\n", "    ", "P", "=", "Predicate", "(", "\"P\"", ",", "arity", "=", "0", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "CompoundFormulae", "(", "P", ",", "P", "(", ")", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "CompoundFormulae", "(", "P", "(", ")", ",", "P", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "CompoundFormulae", "(", "P", ",", "P", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_or_1.test_upward": [[22, 50], ["lnn.truth_table", "lnn.Proposition", "lnn.Proposition", "lnn.Or", "numpy.logical_or", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "lnn.bool_to_fact", "list", "map"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], [")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "{", "\"contradiction\"", ":", "0.1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "0", "]", "<=", "0.5", "\n", ")", ",", "f\"expected input A to be downweighted <= 0., received {weights[0]}\"", "\n", "assert", "bounds", "is", "TRUE", ",", "f\"expected bounds to remain True, received {bounds}\"", "\n", "\n", "\n", "", "if", "__name__", "==", "\"__main__\"", ":", "\n", "    ", "test_upward", "(", ")", "\n", "print", "(", "\"success\"", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_simple_graph_1.test_1": [[10, 32], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Or", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state", "model[].is_unweighted", "model[].params"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.is_unweighted", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params"], ["def", "test_1", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"A&B\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "model", "[", "\"A|B\"", "]", "=", "Or", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"B\"", ":", "FALSE", "}", ")", "\n", "model", ".", "train", "(", "epochs", "=", "11", ",", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights_and", "=", "model", "[", "\"A&B\"", "]", ".", "params", "(", "\"weights\"", ")", "[", "1", "]", "\n", "weights_or", ",", "bias_or", "=", "model", "[", "\"A|B\"", "]", ".", "params", "(", "\"weights\"", ",", "\"bias\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "model", "[", "\"A|B\"", "]", ".", "is_unweighted", "(", ")", ",", "(", "\n", "\"expected A|B to be unweighted, received \"", "f\"w: {weights_or}, b: {bias_or}\"", "\n", ")", "\n", "assert", "(", "\n", "weights_and", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B in A&B to be downweighted, received {weights_and}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bidirectional_1.test_1": [[10, 31], ["lnn.Model", "lnn.Model.add_propositions", "A.Bidirectional", "lnn.Model.add_formulae", "lnn.truth_table", "lnn.Model.add_facts", "lnn.Model.upward", "lnn.Model.flush", "model[].print"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_propositions", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["def", "test_1", "(", "output", "=", "False", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    training in the upward direction\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "A", ",", "B", "=", "model", ".", "add_propositions", "(", "\"A\"", ",", "\"B\"", ")", "\n", "AB", "=", "A", ".", "Bidirectional", "(", "B", ",", "name", "=", "\"A <-> B\"", ")", "\n", "model", ".", "add_formulae", "(", "AB", ")", "\n", "for", "rows", "in", "truth_table", "(", "2", ")", ":", "\n", "        ", "model", ".", "add_facts", "(", "\n", "{", "\n", "A", ".", "name", ":", "rows", "[", "0", "]", ",", "\n", "B", ".", "name", ":", "rows", "[", "1", "]", ",", "\n", "}", "\n", ")", "\n", "model", ".", "upward", "(", ")", "\n", "if", "output", ":", "\n", "            ", "model", "[", "AB", ".", "name", "]", ".", "print", "(", ")", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_1": [[12, 40], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    training in the upward direction\n    \"\"\"", "\n", "# model", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "# rules", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "# facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "\n", "# train/inference", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_2": [[42, 65], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    training in both directions\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "\n", "model", "[", "\"A\"", "]", ",", "\n", "model", "[", "\"B\"", "]", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "model", ".", "train", "(", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_3": [[67, 92], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_3", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B, C) - reduce the weight on B\n    training in both directions\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"C\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "model", "[", "\"A\"", "]", ",", "\n", "model", "[", "\"B\"", "]", ",", "\n", "model", "[", "\"C\"", "]", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", ",", "\"C\"", ":", "TRUE", "}", ")", "\n", "model", ".", "train", "(", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"and\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_multiple": [[94, 137], ["lnn.Model", "random.sample", "tqdm", "lnn.And", "lnn.Model.train", "model[].state", "model[].params().numpy", "enumerate", "lnn.Proposition", "lnn.Model.add_facts", "lnn.Model.print", "range", "model[].get_facts().tolist", "enumerate", "model[].params", "model[].get_facts"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts"], ["", "def", "test_multiple", "(", "output", "=", "False", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(n inputs) - reduce the weight on r random\n    training in both directions\n    \"\"\"", "\n", "inputs", "=", "(", "10", ",", "100", ",", "1000", ")", "\n", "for", "n", "in", "inputs", ":", "\n", "        ", "r", "=", "n", "-", "1", "\n", "model", "=", "Model", "(", ")", "\n", "neuron", "=", "{", "\"alpha\"", ":", "1", "-", "1e-5", "}", "\n", "prop", "=", "[", "f\"P{i}\"", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "truths", "=", "[", "TRUE", "]", "*", "n", "\n", "truths", "[", ":", "r", "]", "=", "[", "FALSE", "]", "*", "r", "\n", "truths", "=", "random", ".", "sample", "(", "truths", ",", "n", ")", "\n", "from", "tqdm", "import", "tqdm", "\n", "\n", "for", "idx", ",", "p", "in", "tqdm", "(", "\n", "enumerate", "(", "prop", ")", ",", "desc", "=", "\"populating graph\"", ",", "total", "=", "n", ",", "disable", "=", "True", "\n", ")", ":", "\n", "            ", "model", "[", "f\"{p}\"", "]", "=", "Proposition", "(", "neuron", "=", "neuron", ")", "\n", "model", ".", "add_facts", "(", "{", "f\"{p}\"", ":", "truths", "[", "idx", "]", "}", ")", "\n", "", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "*", "[", "model", "[", "f\"{p}\"", "]", "for", "p", "in", "prop", "]", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "neuron", "\n", ")", "\n", "model", ".", "train", "(", "losses", "=", "[", "\"contradiction\"", "]", ",", "learning_rate", "=", "1e-1", ")", "\n", "\n", "if", "output", ":", "\n", "            ", "model", ".", "print", "(", "params", "=", "True", ")", "\n", "\n", "# test operator bounds", "\n", "", "prediction", "=", "model", "[", "\"and\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "(", "\n", "f\"received {prediction} \"", "f\"{model['and'].get_facts().tolist()}\"", "\n", ")", "\n", "\n", "# test operator weights", "\n", "false_idxs", "=", "[", "idx", "for", "idx", ",", "truth", "in", "enumerate", "(", "truths", ")", "if", "not", "truth", "]", "\n", "weights", "=", "model", "[", "\"and\"", "]", ".", "params", "(", "\"weights\"", ",", "detach", "=", "True", ")", ".", "numpy", "(", ")", "\n", "for", "w", "in", "weights", "[", "false_idxs", "]", ":", "\n", "            ", "assert", "(", "\n", "w", "<=", "0.5", "+", "1e-5", "\n", ")", ",", "f\"expected False input to be downweighted <= 1., received {w}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_bias": [[139, 157], ["lnn.Model", "lnn.And", "lnn.Model.train", "model[].params", "lnn.Proposition", "lnn.Model.add_facts", "range"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts"], ["", "", "", "def", "test_bias", "(", ")", ":", "\n", "    ", "\"\"\"decrease bias for contradictory facts\n\n    given a False And, for all True inputs\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "n", "=", "1000", "\n", "prop", "=", "[", "f\"P{i}\"", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "for", "p", "in", "prop", ":", "\n", "        ", "model", "[", "f\"{p}\"", "]", "=", "Proposition", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "f\"{p}\"", ":", "TRUE", "}", ")", "\n", "", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "*", "[", "model", "[", "f\"{p}\"", "]", "for", "p", "in", "prop", "]", ",", "\n", "world", "=", "CLOSED", ",", "\n", ")", "\n", "model", ".", "train", "(", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "bias", "=", "model", "[", "\"and\"", "]", ".", "params", "(", "\"bias\"", ")", "\n", "assert", "bias", "<=", "1e-5", ",", "f\"expected bias <= 0, received {bias}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_all": [[159, 181], ["lnn.Model", "lnn.And", "lnn.Model.train", "model[].state", "model[].params", "all", "lnn.Proposition", "lnn.Model.add_facts", "range"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts"], ["", "def", "test_all", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False And, for all True inputs - drop all weights\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "n", "=", "1000", "\n", "prop", "=", "[", "f\"P{i}\"", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "for", "p", "in", "prop", ":", "\n", "        ", "model", "[", "f\"{p}\"", "]", "=", "Proposition", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "f\"{p}\"", ":", "FALSE", "}", ")", "\n", "", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "*", "[", "model", "[", "f\"{p}\"", "]", "for", "p", "in", "prop", "]", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", ".", "train", "(", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "bounds", "=", "model", "[", "\"and\"", "]", ".", "state", "(", ")", "\n", "assert", "bounds", "is", "TRUE", ",", "f\"expected bounds to remain True, received {bounds}\"", "\n", "weights", "=", "model", "[", "\"and\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "assert", "all", "(", "\n", "[", "w", "<=", "0.5", "+", "1e-5", "for", "w", "in", "weights", "]", "\n", ")", ",", "f\"expected all inputs to be downweighted (\u00b10.0), received {weights}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_supervised_1.test_1": [[21, 71], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Or", "lnn.And", "lnn.Implies", "lnn.Model.add_facts", "lnn.Model.add_labels", "lnn.Model.train", "model[].state", "model[].state", "model[].state", "all"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"test supervised, contradiction and logical loss for all neurons\"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "A", "=", "model", "[", "\"A\"", "]", "=", "Proposition", "(", ")", "\n", "B", "=", "model", "[", "\"B\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"A|B\"", "]", "=", "Or", "(", "A", ",", "B", ",", "world", "=", "World", ".", "FALSE", ",", "neuron", "=", "{", "\"bias_learning\"", ":", "False", "}", ")", "\n", "model", "[", "\"A&B\"", "]", "=", "And", "(", "A", ",", "B", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "{", "\"bias_learning\"", ":", "False", "}", ")", "\n", "model", "[", "\"A->B\"", "]", "=", "Implies", "(", "A", ",", "B", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "FALSE", ",", "\"B\"", ":", "TRUE", "}", ")", "\n", "model", ".", "add_labels", "(", "\n", "{", "\n", "\"A|B\"", ":", "FALSE", ",", "\n", "\"A&B\"", ":", "TRUE", ",", "\n", "\"A->B\"", ":", "FALSE", ",", "\n", "}", "\n", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", ",", "\"supervised\"", ":", "1", ",", "\"logical\"", ":", "2e-2", "}", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "epochs", "=", "3e2", ",", "\n", "learning_rate", "=", "5e-2", ",", "\n", "losses", "=", "losses", ",", "\n", "parameter_history", "=", "parameter_history", ",", "\n", ")", "\n", "\n", "state", "=", "model", "[", "\"A|B\"", "]", ".", "state", "(", ")", "\n", "eps", "=", "1e-3", "\n", "assert", "state", "is", "FALSE", ",", "f\"expected A|B to be FALSE, received {state}\"", "\n", "w", "=", "model", "[", "\"A|B\"", "]", ".", "neuron", ".", "weights", "\n", "assert", "(", "\n", "1", "-", "eps", "<=", "w", "[", "0", "]", "and", "0", "<=", "w", "[", "1", "]", "<=", "eps", "\n", ")", ",", "f\"expected A|B weights to be in [\u00b11, <=.5], received {w}\"", "\n", "\n", "state", "=", "model", "[", "\"A&B\"", "]", ".", "state", "(", ")", "\n", "assert", "state", "is", "TRUE", ",", "f\"expected A&B to be TRUE, received {state}\"", "\n", "w", "=", "model", "[", "\"A&B\"", "]", ".", "neuron", ".", "weights", "\n", "assert", "(", "\n", "1", "-", "eps", "<=", "w", "[", "1", "]", "and", "0", "<=", "w", "[", "0", "]", "<=", "eps", "\n", ")", ",", "f\"expected A&B weights to be [<=.5, \u00b11], received {w}\"", "\n", "\n", "state", "=", "model", "[", "\"A->B\"", "]", ".", "state", "(", ")", "\n", "assert", "state", "is", "FALSE", ",", "f\"expected A->B to be FALSE, received {state}\"", "\n", "w", "=", "model", "[", "\"A->B\"", "]", ".", "neuron", ".", "weights", "\n", "assert", "all", "(", "\n", "(", "0", "<=", "w", ")", "+", "(", "w", "<=", "eps", ")", "\n", ")", ",", "f\"expected A->B weights to be in [0, .5], received {w}\"", "\n", "\n", "return", "model", ",", "total_loss", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_logical_1.test_1": [[10, 28], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Or", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Model.add_labels", "lnn.Model.train"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train"], ["def", "test_1", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", ")", "\n", "AB", "=", "model", "[", "\"A&B\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ")", "\n", "model", "[", "\"A|B\"", "]", "=", "Or", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"B\"", ":", "FALSE", "}", ")", "\n", "model", ".", "add_labels", "(", "{", "AB", ".", "name", ":", "TRUE", "}", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "AB", ",", "\"bias\"", ":", "AB", "}", "\n", "losses", "=", "[", "\"logical\"", ",", "\"supervised\"", "]", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "losses", "=", "losses", ",", "learning_rate", "=", "0.1", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "return", "total_loss", ",", "losses", ",", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_implies_1.test_true_operator": [[10, 37], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_true_operator", "(", ")", ":", "\n", "    ", "\"\"\"decrease bias for contradictory facts\n\n    given a True Implies, for (True, False) inputs\n        all inputs are telling the operator that it is incorrect\n        - computation should recognise that the contradiction comes from\n        the assignment of the truth values and not the inputs\n        - the input weights should therefore remain the same and the bias\n        should be corrected to fix the user's mistake\n    under this configuration, the parent operand defaults to the expected\n        behavior of an implication\n        - subtract input information from True to become False\n        - both LHS and RHS are incapable of subtracting information, therefore\n        the operator is incorrect\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "TRUE", ",", "\"RHS\"", ":", "FALSE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "bias", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"bias\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "bias", "<=", "1e-5", ",", "f\"expected bias to be downweighted <= 0., received {bias}\"", "\n", "assert", "bounds", "is", "TRUE", ",", "f\"expected operator bounds to remain True, received {bounds}\"", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_implies_1.test_false_operator_1": [[39, 58], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_false_operator_1", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False Implies, for (False, Unknown) inputs\n    expects LHS innput to be downweighted\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "neuron", "=", "{", "\"alpha\"", ":", "1", "-", "1e-5", "}", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "CLOSED", ",", "neuron", "=", "neuron", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "FALSE", ",", "\"RHS\"", ":", "UNKNOWN", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "0", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input LHS to be downweighted <= .5, received {weights[0]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds AB to remain False, received {bounds}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_implies_1.test_false_operator_2": [[60, 83], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state", "all"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_false_operator_2", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False Implies, for (False, True) inputs\n    expects both inputs to be downweighted\n    under this configuration, the parent operand defaults to the expected\n        behavior of an implication\n        - add input information from False to become True\n        - both LHS and RHS add information, and are therefore incorrect\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "CLOSED", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "FALSE", ",", "\"RHS\"", ":", "TRUE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "all", "(", "\n", "[", "w", "<=", "1", "/", "2", "for", "w", "in", "weights", "]", "\n", ")", ",", "f\"expected both inputs to be downweighted <= .5, received {weights}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds AB to remain False, received {bounds}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_implies_1.test_false_operator_3": [[85, 106], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_false_operator_3", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False Implies, for (True, True) inputs\n    The LHS agrees with the operator that the operator bounds could be False,\n    both the operator and the LHS therefore conclude that the RHS is the source\n    of the contradiction - downweight RHS\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "neuron", "=", "{", "\"alpha\"", ":", "1", "-", "1e-5", "}", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "CLOSED", ",", "neuron", "=", "neuron", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "TRUE", ",", "\"RHS\"", ":", "TRUE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input RHS to be downweighted <= .5, received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds AB to remain False, received {bounds}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_and_n.test_upward": [[10, 50], ["list", "range", "list.append", "lnn.And", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "lnn.Proposition", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward ,n-input conjunction three-valued truth table\"\"\"", "\n", "\n", "TT", "=", "[", "\n", "# A, B, And(A, B, B, B, ...)", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "FALSE", "]", ",", "\n", "[", "FALSE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "UNKNOWN", ",", "TRUE", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "And", "(", "*", "propositions", ",", "name", "=", "\"And_n\"", ")", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "}", "\n", "facts", "[", "\"p1\"", "]", "=", "row", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "2", ",", "n", ")", ":", "\n", "            ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "row", "[", "1", "]", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"And_n\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "GT", "\n", ")", ",", "f\"And({row[0]}, {row[1]}...) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_and_n.test_downward": [[52, 91], ["list", "range", "list.append", "lnn.And", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Model.flush", "lnn.Proposition", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "    ", "TT", "=", "[", "\n", "# B, And(A, B, B, ...), A", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "TRUE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "TRUE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "# contradiction at B [downward]", "\n", "[", "FALSE", ",", "FALSE", ",", "UNKNOWN", "]", ",", "\n", "[", "FALSE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "# contradiction at And [upward]", "\n", "]", "\n", "\n", "# define the rules", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "And", "(", "*", "propositions", ",", "name", "=", "\"And_n\"", ")", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "}", "\n", "facts", "[", "\"And_n\"", "]", "=", "row", "[", "1", "]", "\n", "for", "i", "in", "range", "(", "2", ",", "n", ")", ":", "\n", "            ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "row", "[", "0", "]", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "downward", "(", "index", "=", "0", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"p1\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "GT", ",", "(", "\n", "f\"And(A, {row[0]}, ...)={row[1]} expected\"", "\n", "+", "\" A={GT}, received {prediction}\"", "\n", ")", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_and_lukasiewicz_1.test": [[11, 52], ["numpy.linspace", "numpy.meshgrid", "lnn.Proposition", "lnn.Proposition", "lnn.And", "range", "print", "range", "max", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "lnn.Model.flush", "model[].get_facts"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts"], ["def", "test", "(", ")", ":", "\n", "    ", "\"\"\"Unittest for upward 2-input real-value conjunction\"\"\"", "\n", "\n", "samples", "=", "21", "\n", "steps", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "samples", ")", "\n", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "steps", ",", "steps", ")", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "And", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "\n", "# rules per model", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "row", "in", "range", "(", "samples", ")", ":", "\n", "        ", "for", "col", "in", "range", "(", "samples", ")", ":", "\n", "# inputs", "\n", "            ", "a", ",", "b", "=", "x", "[", "row", "]", "[", "col", "]", ",", "y", "[", "row", "]", "[", "col", "]", "\n", "\n", "# ground truth", "\n", "GT", "=", "max", "(", "0", ",", "a", "+", "b", "-", "1", ")", "\n", "\n", "# facts per model", "\n", "facts", "=", "{", "\"A\"", ":", "(", "a", ",", "a", ")", ",", "\"B\"", ":", "(", "b", ",", "b", ")", "}", "\n", "\n", "# load data into a new model", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "\n", "# evaluate the conjunction", "\n", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "get_facts", "(", ")", "[", "0", "]", "\n", "assert", "(", "\n", "prediction", "-", "GT", "<=", "1e-7", "\n", ")", ",", "f\"And({a}, {b}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "", "", "print", "(", "\"success\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_2.test": [[13, 48], ["lnn.truth_table", "lnn.Proposition", "lnn.Proposition", "lnn.Proposition", "lnn.And", "print", "functools.reduce", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "map", "lnn.bool_to_fact", "lnn.bool_to_fact"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], ["def", "test", "(", ")", ":", "\n", "    ", "\"\"\"Unittest for upward 3-input boolean truth table\"\"\"", "\n", "\n", "TT", "=", "truth_table", "(", "3", ")", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "C", "=", "Proposition", "(", "\"C\"", ")", "\n", "A_B_C", "=", "And", "(", "A", ",", "B", ",", "C", ",", "name", "=", "\"A_B_C\"", ")", "\n", "\n", "formulae", "=", "[", "A_B_C", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# ground truth", "\n", "        ", "GT", "=", "reduce", "(", "np", ".", "logical_and", ",", "map", "(", "fact_to_bool", ",", "row", ")", ")", "\n", "\n", "# facts per model", "\n", "facts", "=", "{", "\"A\"", ":", "row", "[", "0", "]", ",", "\"B\"", ":", "row", "[", "1", "]", ",", "\"C\"", ":", "row", "[", "2", "]", "}", "\n", "\n", "# load data into a new model", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "\n", "# evaluate the conjunction", "\n", "model", "[", "\"A_B_C\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "prediction", "=", "model", "[", "\"A_B_C\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "bool_to_fact", "(", "\n", "GT", "\n", ")", ",", "f\"And{row} expected {bool_to_fact(GT)}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "", "print", "(", "\"success\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_0.test_upward": [[10, 37], ["lnn.Model", "lnn.Model.add_propositions", "lnn.Or", "lnn.Model.add_facts", "lnn.Model.add_labels", "lnn.Model.train"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_propositions", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward, 2-input conjunction boolean truth table\"\"\"", "\n", "\n", "# instantiate a context", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "# define the rules", "\n", "A", ",", "B", "=", "model", ".", "add_propositions", "(", "\"A\"", ",", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Or", "(", "A", ",", "B", ")", "\n", "\n", "# set the facts", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "TRUE", ",", "\n", "\"B\"", ":", "FALSE", ",", "\n", "}", "\n", ")", "\n", "\n", "# set labels", "\n", "model", ".", "add_labels", "(", "{", "\"AB\"", ":", "FALSE", "}", ")", "\n", "\n", "# learning/reasoning", "\n", "losses", "=", "{", "\"supervised\"", ":", "None", ",", "\"logical\"", ":", "1e-1", ",", "\"contradiction\"", ":", "None", "}", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", ")", "\n", "\n", "return", "model", ",", "total_loss", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_or_1.test_downward": [[52, 105], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Or", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], []], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_implies_1.test_upward": [[10, 47], ["lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward ,2-input implies three-valued truth table\"\"\"", "\n", "\n", "# Kleene and Priest logics", "\n", "TT", "=", "[", "\n", "# A, B, Implies(A, B)", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "FALSE", ",", "TRUE", "]", ",", "\n", "[", "UNKNOWN", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "UNKNOWN", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "FALSE", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "Implies", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"A\"", ":", "row", "[", "0", "]", ",", "\"B\"", ":", "row", "[", "1", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "==", "GT", "\n", ")", ",", "f\"And({row[0]}, {row[1]}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_implies_1.test_downward": [[49, 81], ["lnn.Proposition", "lnn.Proposition", "lnn.Implies", "enumerate", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "    ", "TT", "=", "[", "\n", "# B, Implies(A, B), A", "\n", "[", "TRUE", ",", "TRUE", ",", "UNKNOWN", "]", ",", "\n", "[", "TRUE", ",", "FALSE", ",", "TRUE", "]", ",", "# contradition at B [downward]", "\n", "[", "TRUE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "# True at And [upward]", "\n", "[", "FALSE", ",", "TRUE", ",", "FALSE", "]", ",", "\n", "[", "FALSE", ",", "FALSE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "Implies", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "TT", ")", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"B\"", ":", "row", "[", "0", "]", ",", "\"AB\"", ":", "row", "[", "1", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"AB\"", "]", ".", "downward", "(", "index", "=", "0", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "GT", ",", "f\"{i}: Expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_unpacking_propositions.test": [[10, 18], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Model.nodes.values"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values"], ["def", "test", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"Smokes\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"Friends\"", "]", "=", "Proposition", "(", ")", "\n", "\n", "smokes", ",", "friends", "=", "model", ".", "nodes", ".", "values", "(", ")", "\n", "assert", "smokes", ".", "name", "==", "\"Smokes\"", ",", "\"Didn't get smokes proposition\"", "\n", "assert", "friends", ".", "name", "==", "\"Friends\"", ",", "\"Didn't get friends proposition\"", "\n", "", ""]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_not_1.test_upward": [[10, 49], ["lnn.Proposition", "lnn.Not", "lnn.Not", "lnn.fact_to_bool", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.fact_to_bool", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward ,2-input conjunction three-valued truth table\"\"\"", "\n", "\n", "TT", "=", "[", "\n", "# A, Not(A)", "\n", "[", "TRUE", ",", "FALSE", "]", ",", "\n", "[", "FALSE", ",", "TRUE", "]", ",", "\n", "[", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "\n", "try", ":", "\n", "        ", "NotA", "=", "Not", "(", "A", ",", "A", ",", "name", "=", "\"NotA\"", ")", "\n", "assert", "False", ",", "\"Not should not accept multiple inputs\"", "\n", "", "except", "TypeError", ":", "\n", "        ", "pass", "\n", "\n", "", "NotA", "=", "Not", "(", "A", ",", "name", "=", "\"NotA\"", ")", "\n", "formulae", "=", "[", "NotA", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "fact_to_bool", "(", "row", "[", "1", "]", ")", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"A\"", ":", "row", "[", "0", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"NotA\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"NotA\"", "]", ".", "state", "(", "to_bool", "=", "True", ")", "\n", "assert", "(", "\n", "prediction", "is", "GT", "\n", ")", ",", "f\"Not({row[0]}, {row[1]}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_not_1.test_downward": [[51, 85], ["lnn.Model", "lnn.Proposition", "lnn.Not", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "# define model rules", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"NotA\"", "]", "=", "Not", "(", "model", "[", "\"A\"", "]", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"NotA\"", ":", "TRUE", "}", ")", "\n", "model", "[", "\"NotA\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input A to be False, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"NotA\"", ":", "FALSE", "}", ")", "\n", "model", "[", "\"NotA\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input A to be True, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"NotA\"", ":", "UNKNOWN", "}", ")", "\n", "model", "[", "\"NotA\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "UNKNOWN", "\n", ")", ",", "f\"Expected input A to be Unknown, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model": [[16, 19], ["lnn.Model"], "function", ["None"], ["@", "pytest", ".", "fixture", "\n", "def", "model", "(", ")", ":", "\n", "    ", "return", "Model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.p": [[21, 25], ["lnn.Proposition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "p", "(", "model", ")", ":", "\n", "    ", "p", "=", "model", "[", "\"p\"", "]", "=", "Proposition", "(", ")", "\n", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.q": [[27, 31], ["lnn.Proposition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "q", "(", "model", ")", ":", "\n", "    ", "q", "=", "model", "[", "\"q\"", "]", "=", "Proposition", "(", ")", "\n", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.r": [[33, 37], ["lnn.Proposition"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "\n", "def", "r", "(", "model", ")", ":", "\n", "    ", "r", "=", "model", "[", "\"r\"", "]", "=", "Proposition", "(", ")", "\n", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table": [[39, 44], ["lnn.truth_table_dict", "model.add_facts", "model.inference", "rule.state", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model", "test_inference_rules.model"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table_dict", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.model"], ["", "def", "assert_rule_for_truth_table", "(", "model", ",", "rule", ",", "variables", ")", ":", "\n", "    ", "for", "test_case", "in", "truth_table_dict", "(", "*", "variables", ")", ":", "\n", "        ", "model", ".", "add_facts", "(", "test_case", ")", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "rule", ".", "state", "(", ")", "is", "TRUE", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_modus_ponens": [[46, 61], ["lnn.Implies", "lnn.Implies", "model.add_facts", "model.inference", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "q.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "", "def", "test_modus_ponens", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (p \u2227 (p \u279e q)) \u279e q\n    \"\"\"", "\n", "# Downwards", "\n", "p_implies_q", "=", "model", "[", "\"p_implies_q\"", "]", "=", "Implies", "(", "p", ",", "q", ")", "\n", "modus_ponens", "=", "model", "[", "\"modus_ponens\"", "]", "=", "Implies", "(", "And", "(", "p", ",", "p_implies_q", ")", ",", "q", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "p", ".", "name", ":", "TRUE", ",", "p_implies_q", ".", "name", ":", "TRUE", "}", ")", "\n", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "q", ".", "state", "(", ")", "is", "TRUE", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "modus_ponens", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_modus_tolens": [[63, 79], ["lnn.Not", "lnn.Implies", "lnn.And", "model.add_facts", "model.inference", "test_inference_rules.assert_rule_for_truth_table", "p.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_modus_tolens", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (\u00acq \u2227 (p \u279e q)) \u279e \u00acp\n    \"\"\"", "\n", "# Downwards", "\n", "not_q", "=", "model", "[", "\"not_q\"", "]", "=", "Not", "(", "q", ")", "\n", "p_implies_q", "=", "model", "[", "\"p_implies_q\"", "]", "=", "Implies", "(", "p", ",", "q", ")", "\n", "modus_tollens", "=", "model", "[", "\"modus_tollens\"", "]", "=", "And", "(", "not_q", ",", "p_implies_q", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "q", ".", "name", ":", "FALSE", ",", "p_implies_q", ".", "name", ":", "TRUE", "}", ")", "\n", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "p", ".", "state", "(", ")", "is", "FALSE", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "modus_tollens", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_associative": [[81, 92], ["lnn.Or", "lnn.Or", "lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.Or", "lnn.Or"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or"], ["", "def", "test_associative", "(", "model", ",", "p", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u2228 q) \u2228 r) \u279e (p \u2228 (q \u2228 r))\n    \"\"\"", "\n", "lhs", "=", "model", "[", "\"lhs\"", "]", "=", "Or", "(", "Or", "(", "p", ",", "q", ")", ",", "r", ")", "\n", "rhs", "=", "model", "[", "\"rhs\"", "]", "=", "Or", "(", "p", ",", "Or", "(", "q", ",", "r", ")", ")", "\n", "\n", "associative", "=", "model", "[", "\"associative\"", "]", "=", "Implies", "(", "lhs", ",", "rhs", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "associative", ",", "[", "\"p\"", ",", "\"q\"", ",", "\"r\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_commutative": [[94, 103], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "lnn.And"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["", "def", "test_commutative", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (p \u2227 q)  \u279e (q \u2227 p)\n    \"\"\"", "\n", "\n", "commutative", "=", "model", "[", "\"commutative\"", "]", "=", "Implies", "(", "And", "(", "p", ",", "q", ")", ",", "And", "(", "q", ",", "p", ")", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "commutative", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_exportation": [[105, 115], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.Implies", "lnn.Implies", "lnn.And", "lnn.Implies"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies"], ["", "def", "test_exportation", "(", "model", ",", "p", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u2227 q)  \u279e r) \u279e (p \u279e (q \u279e r))\n    \"\"\"", "\n", "exportation", "=", "model", "[", "\"exportation\"", "]", "=", "Implies", "(", "\n", "Implies", "(", "And", "(", "p", ",", "q", ")", ",", "r", ")", ",", "Implies", "(", "p", ",", "Implies", "(", "q", ",", "r", ")", ")", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "exportation", ",", "[", "\"p\"", ",", "\"q\"", ",", "\"r\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_transposition": [[117, 127], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.Implies", "lnn.Implies", "lnn.Not", "lnn.Not"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not"], ["", "def", "test_transposition", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (p \u279e q)  \u279e (\u00acq \u279e \u00acp)\n    \"\"\"", "\n", "transposition", "=", "model", "[", "\"transposition\"", "]", "=", "Implies", "(", "\n", "Implies", "(", "p", ",", "q", ")", ",", "Implies", "(", "Not", "(", "q", ")", ",", "Not", "(", "p", ")", ")", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "transposition", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_hypothetical_syllogism": [[129, 139], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "lnn.Implies", "lnn.Implies", "lnn.Implies"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies"], ["", "def", "test_hypothetical_syllogism", "(", "model", ",", "p", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u279e q) \u2227 (q \u279e r)) \u279e (p \u279e r)\n    \"\"\"", "\n", "hypothetical_syllogism", "=", "model", "[", "\"hypothetical_syllogism\"", "]", "=", "Implies", "(", "\n", "And", "(", "Implies", "(", "p", ",", "q", ")", ",", "Implies", "(", "q", ",", "r", ")", ")", ",", "Implies", "(", "p", ",", "r", ")", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "hypothetical_syllogism", ",", "[", "\"p\"", ",", "\"q\"", ",", "\"r\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_material_implication": [[141, 151], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.Implies", "lnn.Or", "lnn.Not"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not"], ["", "def", "test_material_implication", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (p \u279e q)  \u279e (\u00acp \u2228 q)\n    \"\"\"", "\n", "material_implication", "=", "model", "[", "\"material_implication\"", "]", "=", "Implies", "(", "\n", "Implies", "(", "p", ",", "q", ")", ",", "Or", "(", "Not", "(", "p", ")", ",", "q", ")", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "material_implication", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_distributive": [[153, 163], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "lnn.Or", "lnn.Or", "lnn.And", "lnn.And"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["", "def", "test_distributive", "(", "model", ",", "p", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u2228 q) \u2227 r) \u279e ((p \u2227 r) \u2228 (q \u2227 r))\n    \"\"\"", "\n", "distributive", "=", "model", "[", "\"distributive\"", "]", "=", "Implies", "(", "\n", "And", "(", "Or", "(", "p", ",", "q", ")", ",", "r", ")", ",", "Or", "(", "And", "(", "p", ",", "r", ")", ",", "And", "(", "q", ",", "r", ")", ")", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "distributive", ",", "[", "\"p\"", ",", "\"q\"", ",", "\"r\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_absorption": [[165, 173], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.Implies", "lnn.Implies", "lnn.And"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["", "def", "test_absorption", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (p \u279e q) \u279e (p \u279e (p \u2227 q))\n    \"\"\"", "\n", "absorption", "=", "model", "[", "\"absorption\"", "]", "=", "Implies", "(", "Implies", "(", "p", ",", "q", ")", ",", "Implies", "(", "p", ",", "And", "(", "p", ",", "q", ")", ")", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "absorption", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_disjunctive_syllogism": [[175, 190], ["lnn.And", "lnn.Implies", "model.add_facts", "model.inference", "model.flush", "test_inference_rules.assert_rule_for_truth_table", "lnn.Or", "lnn.Not", "q.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_disjunctive_syllogism", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u2228 q) \u2227 \u00acp) \u279e q\n    \"\"\"", "\n", "lhs", "=", "model", "[", "\"lhs\"", "]", "=", "And", "(", "Or", "(", "p", ",", "q", ")", ",", "Not", "(", "p", ")", ")", "\n", "disjunctive_syllogism", "=", "model", "[", "\"disjunctive_syllogism\"", "]", "=", "Implies", "(", "lhs", ",", "q", ")", "\n", "\n", "# Downwards", "\n", "model", ".", "add_facts", "(", "{", "lhs", ".", "name", ":", "TRUE", "}", ")", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "q", ".", "state", "(", ")", "is", "TRUE", "\n", "\n", "model", ".", "flush", "(", ")", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "disjunctive_syllogism", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_addition": [[192, 211], ["lnn.Or", "lnn.Implies", "model.add_facts", "model.inference", "model.flush", "test_inference_rules.assert_rule_for_truth_table", "lnn.Or.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_addition", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    p \u279e (p \u2228 q)\n    \"\"\"", "\n", "p_or_q", "=", "model", "[", "\"p_or_q\"", "]", "=", "Or", "(", "p", ",", "q", ")", "\n", "addition", "=", "model", "[", "\"addition\"", "]", "=", "Implies", "(", "p", ",", "p_or_q", ")", "\n", "\n", "# Downwards", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "p", ".", "name", ":", "TRUE", ",", "\n", "}", "\n", ")", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "p_or_q", ".", "state", "(", ")", "is", "TRUE", "\n", "\n", "model", ".", "flush", "(", ")", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "addition", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_simplification": [[213, 228], ["lnn.And", "lnn.Implies", "model.add_facts", "model.inference", "model.flush", "test_inference_rules.assert_rule_for_truth_table", "p.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_simplification", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    (p \u2227 q) \u279e p\n    \"\"\"", "\n", "p_and_q", "=", "model", "[", "\"p_and_q\"", "]", "=", "And", "(", "p", ",", "q", ")", "\n", "simplification", "=", "model", "[", "\"simplification\"", "]", "=", "Implies", "(", "p_and_q", ",", "p", ")", "\n", "\n", "# Downwards", "\n", "model", ".", "add_facts", "(", "{", "p_and_q", ".", "name", ":", "TRUE", "}", ")", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "p", ".", "state", "(", ")", "is", "TRUE", "\n", "\n", "model", ".", "flush", "(", ")", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "simplification", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_conjunction": [[230, 245], ["lnn.And", "lnn.Implies", "model.add_facts", "model.inference", "model.flush", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "lnn.And.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_conjunction", "(", "model", ",", "p", ",", "q", ")", ":", "\n", "    ", "\"\"\"\n    ((p) \u2227 (q)) \u279e (p \u2227 q)\n    \"\"\"", "\n", "p_and_q", "=", "model", "[", "\"p_and_q\"", "]", "=", "And", "(", "p", ",", "q", ")", "\n", "conjunction", "=", "model", "[", "\"conjunction\"", "]", "=", "Implies", "(", "p_and_q", ",", "And", "(", "p", ",", "q", ")", ")", "\n", "\n", "# Downwards", "\n", "model", ".", "add_facts", "(", "{", "p", ".", "name", ":", "TRUE", ",", "q", ".", "name", ":", "TRUE", "}", ")", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "p_and_q", ".", "state", "(", ")", "is", "TRUE", "\n", "\n", "model", ".", "flush", "(", ")", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "conjunction", ",", "[", "\"p\"", ",", "\"q\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_double_negation": [[247, 267], ["lnn.Not", "lnn.Implies", "model.add_facts", "model.inference", "model.flush", "test_inference_rules.assert_rule_for_truth_table", "lnn.Not", "lnn.Not.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_double_negation", "(", "model", ",", "p", ")", ":", "\n", "    ", "\"\"\"\n    p \u279e (\u00ac\u00acp)\n    \"\"\"", "\n", "\n", "not_not_p", "=", "model", "[", "\"not_not_p\"", "]", "=", "Not", "(", "Not", "(", "p", ")", ")", "\n", "double_negation", "=", "model", "[", "\"double_negation\"", "]", "=", "Implies", "(", "p", ",", "not_not_p", ")", "\n", "\n", "# Downwards", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "p", ".", "name", ":", "TRUE", ",", "\n", "}", "\n", ")", "\n", "model", ".", "inference", "(", ")", "\n", "assert", "not_not_p", ".", "state", "(", ")", "is", "TRUE", "\n", "\n", "model", ".", "flush", "(", ")", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "double_negation", ",", "[", "\"p\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_disjunctive_simplification": [[269, 279], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.Or"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or"], ["", "def", "test_disjunctive_simplification", "(", "model", ",", "p", ")", ":", "\n", "    ", "\"\"\"\n    (p \u2228 p) \u279e p\n    \"\"\"", "\n", "disjunctive_simplification", "=", "model", "[", "\"disjunctive_simplification\"", "]", "=", "Implies", "(", "\n", "Or", "(", "p", ",", "p", ")", ",", "p", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "disjunctive_simplification", ",", "[", "\"p\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_resolution": [[281, 289], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "lnn.Or", "lnn.Or", "lnn.Or", "lnn.Not"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not"], ["", "def", "test_resolution", "(", "model", ",", "p", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u2228 q) \u2227 (\u00acp \u2228 r)) \u279e (q \u2228 r)\n    \"\"\"", "\n", "resolution", "=", "model", "[", "\"resolution\"", "]", "=", "Implies", "(", "And", "(", "Or", "(", "p", ",", "q", ")", ",", "Or", "(", "Not", "(", "p", ")", ",", "r", ")", ")", ",", "Or", "(", "q", ",", "r", ")", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "resolution", ",", "[", "\"p\"", ",", "\"q\"", ",", "\"r\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.test_disjunction_elimination": [[291, 301], ["lnn.Implies", "test_inference_rules.assert_rule_for_truth_table", "lnn.And", "lnn.Implies", "lnn.Implies", "lnn.Or"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.assert_rule_for_truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or"], ["", "def", "test_disjunction_elimination", "(", "model", ",", "p", ",", "q", ",", "r", ")", ":", "\n", "    ", "\"\"\"\n    ((p \u279e q) \u2227 (r \u279e q) \u2227 (p \u2228 r)) \u279e q\n    \"\"\"", "\n", "disjunction_elimination", "=", "model", "[", "\"disjunction_elimination\"", "]", "=", "Implies", "(", "\n", "And", "(", "Implies", "(", "p", ",", "q", ")", ",", "Implies", "(", "r", ",", "q", ")", ",", "Or", "(", "p", ",", "r", ")", ")", ",", "q", "\n", ")", "\n", "\n", "# Upwards", "\n", "assert_rule_for_truth_table", "(", "model", ",", "disjunction_elimination", ",", "[", "\"p\"", ",", "\"q\"", ",", "\"r\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_not_1.test_upward": [[10, 22], ["range", "lnn.Model", "lnn.Not", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Proposition"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "GTs", "=", "[", "TRUE", ",", "FALSE", ",", "UNKNOWN", "]", "\n", "inputs", "=", "[", "FALSE", ",", "TRUE", ",", "UNKNOWN", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"not\"", "]", "=", "Not", "(", "Proposition", "(", "\"A\"", ")", ")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "inputs", "[", "i", "]", "}", ")", "\n", "model", "[", "\"not\"", "]", ".", "upward", "(", ")", "\n", "prediction", "=", "model", "[", "\"not\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "GTs", "[", "i", "]", "\n", ")", ",", "f\"expected Not({inputs[i]}) = {GTs[i]}, received {prediction}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_not_1.test_downward": [[24, 36], ["range", "lnn.Model", "lnn.Not", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Proposition"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Not", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "    ", "GTs", "=", "[", "TRUE", ",", "FALSE", ",", "UNKNOWN", "]", "\n", "inputs", "=", "[", "FALSE", ",", "TRUE", ",", "UNKNOWN", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"not\"", "]", "=", "Not", "(", "Proposition", "(", "\"A\"", ")", ")", "\n", "model", ".", "add_facts", "(", "{", "\"not\"", ":", "inputs", "[", "i", "]", "}", ")", "\n", "model", "[", "\"not\"", "]", ".", "downward", "(", ")", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "GTs", "[", "i", "]", "\n", ")", ",", "f\"expected Not({inputs[i]}) = {GTs[i]}, received A={prediction}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_upward": [[22, 48], ["lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.truth_table", "numpy.logical_and", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "lnn.bool_to_fact", "list", "map"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], ["model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "# facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "\n", "# train/inference", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "return", "model", "\n", "\n", "\n", "", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    training in both directions\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_1.test_downward": [[50, 152], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "lnn.Model.flush", "model[].downward", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "lnn.Model.flush", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "\n", "model", "[", "\"A\"", "]", ",", "\n", "model", "[", "\"B\"", "]", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "model", ".", "train", "(", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "\n", "", "def", "test_3", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B, C) - reduce the weight on B\n    training in both directions\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"C\"", "]", "=", "Proposition", "(", ")", "\n", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "model", "[", "\"A\"", "]", ",", "\n", "model", "[", "\"B\"", "]", ",", "\n", "model", "[", "\"C\"", "]", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", ",", "\"C\"", ":", "TRUE", "}", ")", "\n", "model", ".", "train", "(", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"and\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "\n", "", "def", "test_multiple", "(", "output", "=", "False", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(n inputs) - reduce the weight on r random\n    training in both directions\n    \"\"\"", "\n", "inputs", "=", "(", "10", ",", "100", ",", "1000", ")", "\n", "for", "n", "in", "inputs", ":", "\n", "        ", "r", "=", "n", "-", "1", "\n", "model", "=", "Model", "(", ")", "\n", "neuron", "=", "{", "\"alpha\"", ":", "1", "-", "1e-5", "}", "\n", "prop", "=", "[", "f\"P{i}\"", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "truths", "=", "[", "TRUE", "]", "*", "n", "\n", "truths", "[", ":", "r", "]", "=", "[", "FALSE", "]", "*", "r", "\n", "truths", "=", "random", ".", "sample", "(", "truths", ",", "n", ")", "\n", "from", "tqdm", "import", "tqdm", "\n", "\n", "for", "idx", ",", "p", "in", "tqdm", "(", "\n", "enumerate", "(", "prop", ")", ",", "desc", "=", "\"populating graph\"", ",", "total", "=", "n", ",", "disable", "=", "True", "\n", ")", ":", "\n", "            ", "model", "[", "f\"{p}\"", "]", "=", "Proposition", "(", "neuron", "=", "neuron", ")", "\n", "model", ".", "add_facts", "(", "{", "f\"{p}\"", ":", "truths", "[", "idx", "]", "}", ")", "\n", "", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "*", "[", "model", "[", "f\"{p}\"", "]", "for", "p", "in", "prop", "]", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "neuron", "\n", ")", "\n", "model", ".", "train", "(", "losses", "=", "[", "\"contradiction\"", "]", ",", "learning_rate", "=", "1e-1", ")", "\n", "\n", "if", "output", ":", "\n", "            ", "model", ".", "print", "(", "params", "=", "True", ")", "\n", "\n", "# test operator bounds", "\n", "", "prediction", "=", "model", "[", "\"and\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "(", "\n", "f\"received {prediction} \"", "f\"{model['and'].get_facts().tolist()}\"", "\n", ")", "\n", "\n", "# test operator weights", "\n", "false_idxs", "=", "[", "idx", "for", "idx", ",", "truth", "in", "enumerate", "(", "truths", ")", "if", "not", "truth", "]", "\n", "weights", "=", "model", "[", "\"and\"", "]", ".", "params", "(", "\"weights\"", ",", "detach", "=", "True", ")", ".", "numpy", "(", ")", "\n", "for", "w", "in", "weights", "[", "false_idxs", "]", ":", "\n", "            ", "assert", "(", "\n", "w", "<=", "0.5", "+", "1e-5", "\n", ")", ",", "f\"expected False input to be downweighted <= 1., received {w}\"", "\n", "\n", "\n", "", "", "", "def", "test_bias", "(", ")", ":", "\n", "    ", "\"\"\"decrease bias for contradictory facts\n\n    given a False And, for all True inputs\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "n", "=", "1000", "\n", "prop", "=", "[", "f\"P{i}\"", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "for", "p", "in", "prop", ":", "\n", "        ", "model", "[", "f\"{p}\"", "]", "=", "Proposition", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "f\"{p}\"", ":", "TRUE", "}", ")", "\n", "", "model", "[", "\"and\"", "]", "=", "And", "(", "\n", "*", "[", "model", "[", "f\"{p}\"", "]", "for", "p", "in", "prop", "]", ",", "\n", "world", "=", "CLOSED", ",", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_implies_lukasiewicz_1.test": [[11, 52], ["numpy.linspace", "numpy.meshgrid", "lnn.Proposition", "lnn.Proposition", "lnn.Implies", "range", "print", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "lnn.Model.flush", "model[].get_facts"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts"], ["def", "test", "(", ")", ":", "\n", "    ", "\"\"\"Unittest for upward 2-input real-value implication\"\"\"", "\n", "\n", "samples", "=", "21", "\n", "steps", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "samples", ")", "\n", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "steps", ",", "steps", ")", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "Implies", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "\n", "# rules per model", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "row", "in", "range", "(", "samples", ")", ":", "\n", "        ", "for", "col", "in", "range", "(", "samples", ")", ":", "\n", "# inputs", "\n", "            ", "a", ",", "b", "=", "x", "[", "row", "]", "[", "col", "]", ",", "y", "[", "row", "]", "[", "col", "]", "\n", "\n", "# ground truth", "\n", "GT", "=", "1", "-", "a", "+", "b", "\n", "\n", "# facts per model", "\n", "facts", "=", "{", "\"A\"", ":", "(", "a", ",", "a", ")", ",", "\"B\"", ":", "(", "b", ",", "b", ")", "}", "\n", "\n", "# load data into a new model", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "\n", "# evaluate the implication", "\n", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "get_facts", "(", ")", "[", "0", "]", "\n", "assert", "(", "\n", "prediction", "-", "GT", "<=", "1e-7", "\n", ")", ",", "f\"And({a}, {b}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "", "", "print", "(", "\"success\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_n.test_upward": [[11, 71], ["list", "range", "numpy.random.random", "list", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "list.append", "lnn.And", "map", "lnn.Proposition", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward n-input conjunction boolean truth table\"\"\"", "\n", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "And", "(", "*", "propositions", ",", "name", "=", "\"And_n\"", ")", "]", "\n", "\n", "dat", "=", "np", ".", "random", ".", "random", "(", "n", ")", "\n", "row", "=", "list", "(", "map", "(", "lambda", "x", ":", "TRUE", "if", "x", ">=", "0.5", "else", "FALSE", ",", "dat", ")", ")", "\n", "\n", "# get ground truth", "\n", "GT", "=", "TRUE", "\n", "for", "t", "in", "row", ":", "\n", "        ", "if", "t", "is", "FALSE", ":", "\n", "            ", "GT", "=", "FALSE", "\n", "\n", "# load model and reason over facts", "\n", "", "", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "row", "[", "i", "]", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"And_n\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "GT", ",", "f\"And({row}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n", "# Test the case of all True", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "TRUE", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"And_n\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"And({row}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n", "# Test the case of all False", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "FALSE", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"And_n\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"And({row}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_and_n.test_downward": [[73, 147], ["list", "range", "lnn.Model", "range", "lnn.And", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "list.append", "model[].state", "model[].state", "model[].state", "model[].state", "lnn.Proposition", "str", "range", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_downward", "(", ")", ":", "\n", "# define model rules", "\n", "    ", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "propositions", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", "=", "propositions", "[", "i", "]", "\n", "", "model", "[", "\"And_n\"", "]", "=", "And", "(", "*", "propositions", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "TRUE", ",", "\n", "\"And_n\"", ":", "TRUE", ",", "\n", "}", "\n", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input A to be True, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input to be True, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "FALSE", ",", "\"And_n\"", ":", "TRUE", "}", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "CONTRADICTION", "\n", ")", ",", "f\"Expected input A to be Contradiction, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input to be True, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"And_n\"", ":", "FALSE", "}", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input A to be True, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "UNKNOWN", "\n", ")", ",", "f\"Expected input to be Unknown, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# Test the case of all True except one", "\n", "model", ".", "add_facts", "(", "{", "\"P\"", "+", "str", "(", "i", ")", ":", "TRUE", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"And_n\"", ":", "FALSE", "}", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input A to be False, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input to be True, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_api_syntax.test": [[10, 30], ["lnn.Model", "lnn.Model.add_propositions", "lnn.Model.add_propositions", "smokes.And().Implies", "lnn.Model.add_formulae", "lnn.Model.add_facts", "lnn.Model.infer", "model[].state", "smokes.And"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_propositions", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_propositions", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["def", "test", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "\n", "smokes", ",", "friends", "=", "model", ".", "add_propositions", "(", "\"Smokes\"", ",", "\"Friends\"", ")", "\n", "# check that more propositions can be added", "\n", "colleagues", ",", "gender", "=", "model", ".", "add_propositions", "(", "\"Colleagues\"", ",", "\"GenderAlike\"", ")", "\n", "assert", "colleagues", ".", "name", "==", "\"Colleagues\"", "\n", "assert", "gender", ".", "name", "==", "\"GenderAlike\"", "\n", "\n", "formula", "=", "smokes", ".", "And", "(", "colleagues", ",", "gender", ")", ".", "Implies", "(", "friends", ",", "world", "=", "AXIOM", ")", "\n", "\n", "facts", "=", "{", "\"Smokes\"", ":", "TRUE", ",", "\"Colleagues\"", ":", "TRUE", ",", "\"GenderAlike\"", ":", "TRUE", "}", "\n", "\n", "model", ".", "add_formulae", "(", "formula", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", ".", "infer", "(", ")", "\n", "\n", "assert", "model", "[", "\"Friends\"", "]", ".", "state", "(", ")", "==", "TRUE", ",", "\"Not friends :-(\"", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_or_lukasiewicz_1.test": [[11, 51], ["numpy.linspace", "numpy.meshgrid", "lnn.Proposition", "lnn.Proposition", "lnn.Or", "range", "print", "range", "min", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts"], ["def", "test", "(", ")", ":", "\n", "    ", "\"\"\"Unittest for upward 2-input real-value disjunction\"\"\"", "\n", "\n", "samples", "=", "21", "\n", "steps", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "samples", ")", "\n", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "steps", ",", "steps", ")", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "Or", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "\n", "# rules per model", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "row", "in", "range", "(", "samples", ")", ":", "\n", "        ", "for", "col", "in", "range", "(", "samples", ")", ":", "\n", "# inputs", "\n", "            ", "a", ",", "b", "=", "x", "[", "row", "]", "[", "col", "]", ",", "y", "[", "row", "]", "[", "col", "]", "\n", "\n", "# ground truth", "\n", "GT", "=", "min", "(", "a", "+", "b", ",", "1", ")", "\n", "\n", "# facts per model", "\n", "facts", "=", "{", "\"A\"", ":", "(", "a", ",", "a", ")", ",", "\"B\"", ":", "(", "b", ",", "b", ")", "}", "\n", "\n", "# load data into a new model", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "\n", "# evaluate the disjunction", "\n", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "get_facts", "(", ")", "[", "0", "]", "\n", "assert", "(", "\n", "prediction", "-", "GT", "<=", "1e-7", "\n", ")", ",", "f\"And({a}, {b}) expected {GT}, received {prediction}\"", "\n", "", "", "print", "(", "\"success\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_and_1.test_upward": [[10, 46], ["lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward ,2-input conjunction three-valued truth table\"\"\"", "\n", "\n", "TT", "=", "[", "\n", "# A, B, And(A, B)", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "FALSE", "]", ",", "\n", "[", "FALSE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "UNKNOWN", ",", "TRUE", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "And", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"A\"", ":", "row", "[", "0", "]", ",", "\"B\"", ":", "row", "[", "1", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "GT", "\n", ")", ",", "f\"And({row[0]}, {row[1]}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_and_1.test_downward": [[48, 84], ["lnn.Proposition", "lnn.Proposition", "lnn.And", "enumerate", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "    ", "TT", "=", "[", "\n", "# B, And(A, B), A", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "TRUE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "TRUE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "# contradiction at B [downward]", "\n", "[", "FALSE", ",", "FALSE", ",", "UNKNOWN", "]", ",", "\n", "[", "FALSE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "# contradiction at And [upward]", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "And", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "TT", ")", ":", "\n", "# load model and reason over facts", "\n", "        ", "facts", "=", "{", "\"B\"", ":", "row", "[", "0", "]", ",", "\"AB\"", ":", "row", "[", "1", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"AB\"", "]", ".", "downward", "(", "index", "=", "0", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "row", "[", "2", "]", "\n", ")", ",", "f\"{i} And{row} Expected {row[2]}, received {prediction}\"", "\n", "\n", "prediction", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "row", "[", "0", "]", "\n", ")", ",", "f\"{i} And{row} Expected {row[0]}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_rv_and_n.test_upward": [[11, 48], ["list", "range", "numpy.linspace", "range", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts", "lnn.Model.flush", "list.append", "lnn.And", "max", "print", "round", "round", "lnn.Proposition", "prediction[].item", "prediction[].item", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["def", "test_upward", "(", "output", "=", "False", ")", ":", "\n", "    ", "\"\"\"standard upward n-input conjunction boolean truth table\"\"\"", "\n", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "And", "(", "*", "propositions", ",", "name", "=", "\"And_n\"", ")", "]", "\n", "\n", "dat", "=", "np", ".", "linspace", "(", "0.001", ",", "1.0", ",", "n", ")", "\n", "GT", "=", "dat", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "GT", "=", "max", "(", "0", ",", "GT", "+", "dat", "[", "i", "]", "-", "1", ")", "\n", "\n", "", "if", "output", ":", "\n", "        ", "print", "(", "\"Ground truth\"", ",", "GT", ")", "\n", "\n", "# load model and reason over facts", "\n", "", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "(", "dat", "[", "i", "]", ",", "dat", "[", "i", "]", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"And_n\"", "]", ".", "get_facts", "(", ")", "\n", "assert", "prediction", "[", "0", "]", "==", "prediction", "[", "1", "]", ",", "(", "\n", "\"Lower and upper bounds are not the same, \"", "\n", "+", "f\"got {prediction[0]}, {prediction[1]}\"", "\n", ")", "\n", "assert", "round", "(", "prediction", "[", "0", "]", ".", "item", "(", ")", ",", "4", ")", "==", "round", "(", "\n", "GT", ",", "4", "\n", ")", ",", "f\"And(...) failed, expected {GT}, received {prediction[0].item()}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_rv_and_n.test_downward": [[50, 113], ["list", "range", "numpy.linspace", "range", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts", "lnn.Model.add_facts", "lnn.Model.downward", "model[].get_facts", "numpy.linspace", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts", "lnn.Model.add_facts", "lnn.Model.downward", "model[].get_facts", "list.append", "lnn.And", "max", "print", "round", "round", "lnn.Proposition", "prediction[].item", "p0[].item", "prediction[].item", "prediction[].item", "prediction[].item", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["", "def", "test_downward", "(", "output", "=", "False", ")", ":", "\n", "    ", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "And", "(", "*", "propositions", ",", "name", "=", "\"And_n\"", ")", "]", "\n", "\n", "dat", "=", "np", ".", "linspace", "(", "1.0", ",", "1.0", ",", "n", ")", "\n", "GT", "=", "dat", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "GT", "=", "max", "(", "0", ",", "GT", "+", "dat", "[", "i", "]", "-", "1", ")", "\n", "\n", "", "if", "output", ":", "\n", "        ", "print", "(", "\"Ground truth\"", ",", "GT", ")", "\n", "\n", "# load model and reason over facts", "\n", "", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "(", "dat", "[", "i", "]", ",", "dat", "[", "i", "]", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# now make one of the inputs unknown", "\n", "p0", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "Fact", ".", "UNKNOWN", "}", ")", "\n", "model", ".", "downward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "assert", "prediction", "[", "0", "]", "==", "prediction", "[", "1", "]", ",", "(", "\n", "\"Lower and upper bounds are not the same, \"", "\n", "+", "f\"got {prediction[0]}, {prediction[1]}\"", "\n", ")", "\n", "assert", "round", "(", "prediction", "[", "0", "]", ".", "item", "(", ")", ",", "4", ")", "==", "round", "(", "\n", "p0", "[", "0", "]", ".", "item", "(", ")", ",", "4", "\n", ")", ",", "f\"And(...) failed, expected {GT}, received {prediction[0].item()}\"", "\n", "\n", "# now make the AND false", "\n", "dat", "=", "np", ".", "linspace", "(", "0.0", ",", "1.0", ",", "n", ")", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "(", "dat", "[", "i", "]", ",", "dat", "[", "i", "]", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"And_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# now make one of the inputs unknown", "\n", "p0", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "Fact", ".", "UNKNOWN", "}", ")", "\n", "model", ".", "downward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "assert", "(", "\n", "prediction", "[", "0", "]", ".", "item", "(", ")", "==", "0", "and", "prediction", "[", "1", "]", ".", "item", "(", ")", "==", "1", "\n", ")", ",", "\"p0 should be UNKNOWN\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_or_n.test_upward": [[10, 49], ["list", "range", "list.append", "lnn.Or", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "lnn.Proposition", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward ,n-input disjunction three-valued truth table\"\"\"", "\n", "\n", "TT", "=", "[", "\n", "# A, B, Or(A, B, ...)", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "UNKNOWN", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "UNKNOWN", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "FALSE", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "Or", "(", "*", "propositions", ",", "name", "=", "\"Or_n\"", ")", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"p1\"", ":", "row", "[", "0", "]", "}", "\n", "for", "i", "in", "range", "(", "2", ",", "n", ")", ":", "\n", "            ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "row", "[", "1", "]", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"Or_n\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "GT", "\n", ")", ",", "f\"Or({row[0]}, {row[1]}...) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_or_n.test_downward": [[51, 88], ["list", "range", "list.append", "lnn.Or", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].downward", "model[].state", "lnn.Model.flush", "lnn.Proposition", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "    ", "TT", "=", "[", "\n", "# B, Or(A, B, ...), A", "\n", "[", "FALSE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "FALSE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "TRUE", ",", "FALSE", ",", "FALSE", "]", ",", "# contradiction at B", "\n", "[", "TRUE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "# contradiction at Or()", "\n", "[", "TRUE", ",", "TRUE", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "Or", "(", "*", "propositions", ",", "name", "=", "\"Or_n\"", ")", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"Or_n\"", ":", "row", "[", "1", "]", "}", "\n", "for", "i", "in", "range", "(", "2", ",", "n", ")", ":", "\n", "            ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "row", "[", "0", "]", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "downward", "(", "index", "=", "0", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"p1\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "GT", ",", "(", "\n", "f\"Or(A, {row[0]}, ...)={row[1]} expected A={GT}, \"", "+", "\"received {prediction}\"", "\n", ")", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_simple.test_1": [[21, 59], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Or", "lnn.Model.add_facts", "lnn.Model.train", "model[].params", "model[].params", "all"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.params"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    given Or(A, B) - do not do anything\n    training in the upward direction\n    \"\"\"", "\n", "# model", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "# rules", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ",", "world", "=", "AXIOM", ")", "\n", "model", "[", "\"A|B\"", "]", "=", "Or", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ")", "\n", "\n", "# facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "\n", "# train/inference", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", ",", "\"logical\"", ":", "1e-1", "}", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "pbar", "=", "False", ",", "\n", "direction", "=", "UPWARD", ",", "\n", "losses", "=", "losses", ",", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", ",", "\n", ")", "\n", "\n", "A_and_B_weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "assert", "A_and_B_weights", "[", "1", "]", "<=", "0.5", ",", "(", "\n", "\"expected input B to be downweighted <= .5, \"", "f\"received {A_and_B_weights[1]}\"", "\n", ")", "\n", "A_or_B_weights", "=", "model", "[", "\"A|B\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "assert", "all", "(", "A_or_B_weights", ">", "0.99", ")", ",", "(", "\n", "\"expected weights at A or B to remain high, \"", "f\"received {A_or_B_weights}\"", "\n", ")", "\n", "\n", "return", "model", ",", "total_loss", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_rv_or_n.test_upward": [[11, 48], ["list", "range", "numpy.linspace", "range", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts", "lnn.Model.flush", "list.append", "lnn.Or", "min", "print", "round", "round", "lnn.Proposition", "prediction[].item", "prediction[].item", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["def", "test_upward", "(", "output", "=", "False", ")", ":", "\n", "    ", "\"\"\"standard upward n-input disjunction boolean truth table\"\"\"", "\n", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "Or", "(", "*", "propositions", ",", "name", "=", "\"Or_n\"", ")", "]", "\n", "\n", "dat", "=", "np", ".", "linspace", "(", "0.0001", ",", "0.001", ",", "n", ")", "\n", "GT", "=", "dat", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "GT", "=", "min", "(", "1", ",", "GT", "+", "dat", "[", "i", "]", ")", "\n", "\n", "", "if", "output", ":", "\n", "        ", "print", "(", "\"Ground truth:\"", ",", "GT", ")", "\n", "\n", "# load model and reason over facts", "\n", "", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "(", "dat", "[", "i", "]", ",", "dat", "[", "i", "]", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"Or_n\"", "]", ".", "get_facts", "(", ")", "\n", "assert", "prediction", "[", "0", "]", "==", "prediction", "[", "1", "]", ",", "(", "\n", "\"Lower and upper bounds are not the same, \"", "\n", "+", "f\"got {prediction[0]}, {prediction[1]}\"", "\n", ")", "\n", "assert", "round", "(", "prediction", "[", "0", "]", ".", "item", "(", ")", ",", "4", ")", "==", "round", "(", "\n", "GT", ",", "4", "\n", ")", ",", "f\"Or(...) failed, expected {GT}, received {prediction[0].item()}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_rv_or_n.test_downward": [[50, 113], ["list", "range", "numpy.linspace", "range", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts", "lnn.Model.add_facts", "lnn.Model.downward", "model[].get_facts", "numpy.linspace", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].get_facts", "lnn.Model.add_facts", "lnn.Model.downward", "model[].get_facts", "list.append", "lnn.Or", "min", "print", "round", "round", "lnn.Proposition", "prediction[].item", "p0[].item", "prediction[].item", "prediction[].item", "prediction[].item", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print"], ["", "def", "test_downward", "(", "output", "=", "False", ")", ":", "\n", "    ", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "Or", "(", "*", "propositions", ",", "name", "=", "\"Or_n\"", ")", "]", "\n", "\n", "dat", "=", "np", ".", "linspace", "(", "0.0", ",", "0.0", ",", "n", ")", "\n", "GT", "=", "dat", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "GT", "=", "min", "(", "1", ",", "GT", "+", "dat", "[", "i", "]", ")", "\n", "\n", "", "if", "output", ":", "\n", "        ", "print", "(", "\"Ground truth\"", ",", "GT", ")", "\n", "\n", "# load model and reason over facts", "\n", "", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "(", "dat", "[", "i", "]", ",", "dat", "[", "i", "]", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# now make one of the inputs unknown", "\n", "p0", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "Fact", ".", "UNKNOWN", "}", ")", "\n", "model", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "assert", "prediction", "[", "0", "]", "==", "prediction", "[", "1", "]", ",", "(", "\n", "\"Lower and upper bounds are not the same, \"", "\n", "+", "f\"got {prediction[0]}, {prediction[1]}\"", "\n", ")", "\n", "assert", "round", "(", "prediction", "[", "0", "]", ".", "item", "(", ")", ",", "4", ")", "==", "round", "(", "\n", "p0", "[", "0", "]", ".", "item", "(", ")", ",", "4", "\n", ")", ",", "f\"Or(...) failed, expected {GT}, received {prediction[0].item()}\"", "\n", "\n", "# now make the OR True", "\n", "dat", "=", "np", ".", "linspace", "(", "0.0", ",", "1.0", ",", "n", ")", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "0", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "(", "dat", "[", "i", "]", ",", "dat", "[", "i", "]", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# now make one of the inputs unknown", "\n", "p0", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "Fact", ".", "UNKNOWN", "}", ")", "\n", "model", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"p0\"", "]", ".", "get_facts", "(", ")", "\n", "assert", "(", "\n", "prediction", "[", "0", "]", ".", "item", "(", ")", "==", "0", "and", "prediction", "[", "1", "]", ".", "item", "(", ")", "==", "1", "\n", ")", ",", "\"p0 should be UNKNOWN\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_or_n.test_upward": [[11, 71], ["list", "range", "numpy.random.random", "list", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "range", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "list.append", "lnn.Or", "map", "lnn.Proposition", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward n-input disjunction boolean truth table\"\"\"", "\n", "\n", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "", "formulae", "=", "[", "Or", "(", "*", "propositions", ",", "name", "=", "\"Or_n\"", ")", "]", "\n", "\n", "dat", "=", "np", ".", "random", ".", "random", "(", "n", ")", "\n", "row", "=", "list", "(", "map", "(", "lambda", "x", ":", "TRUE", "if", "x", ">=", "0.5", "else", "FALSE", ",", "dat", ")", ")", "\n", "\n", "# get ground truth", "\n", "GT", "=", "FALSE", "\n", "for", "t", "in", "row", ":", "\n", "        ", "if", "t", "is", "TRUE", ":", "\n", "            ", "GT", "=", "TRUE", "\n", "\n", "# load model and reason over facts", "\n", "", "", "facts", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "row", "[", "i", "]", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"Or_n\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "GT", ",", "f\"Or({row}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n", "# Test the case of all True", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "TRUE", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"Or_n\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Or({row}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n", "# Test the case of all False", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "facts", "[", "\"p\"", "+", "str", "(", "i", ")", "]", "=", "FALSE", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"Or_n\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Or({row}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_or_n.test_downward": [[73, 157], ["list", "range", "lnn.Model", "range", "lnn.Or", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "lnn.Model.add_facts", "lnn.Model.add_facts", "model[].downward", "model[].state", "range", "lnn.Model.flush", "list.append", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "lnn.Proposition", "str", "range", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_downward", "(", ")", ":", "\n", "# define model rules", "\n", "    ", "n", "=", "1000", "\n", "propositions", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "propositions", ".", "append", "(", "Proposition", "(", "\"p\"", "+", "str", "(", "i", ")", ")", ")", "\n", "\n", "", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "propositions", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", "=", "propositions", "[", "i", "]", "\n", "", "model", "[", "\"Or_n\"", "]", "=", "Or", "(", "*", "propositions", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "FALSE", ",", "\"Or_n\"", ":", "FALSE", "}", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input A to be False, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input to be False, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"Or_n\"", ":", "TRUE", "}", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input A to be True, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "UNKNOWN", "\n", ")", ",", "f\"Expected input to be Unknown, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "FALSE", ",", "\"Or_n\"", ":", "TRUE", "}", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input A to be False, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "UNKNOWN", "\n", ")", ",", "f\"Expected input to be Unknown, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# define model facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"Or_n\"", ":", "FALSE", "}", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "CONTRADICTION", "\n", ")", ",", "f\"Expected input A to be Contradiction, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input to be False, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n", "# test model facts for All False except one", "\n", "model", ".", "add_facts", "(", "{", "\"P\"", "+", "str", "(", "i", ")", ":", "FALSE", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"Or_n\"", ":", "TRUE", "}", ")", "\n", "model", "[", "\"Or_n\"", "]", ".", "downward", "(", ")", "\n", "\n", "# evaluate", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "f\"Expected input A to be True, received {prediction}\"", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "n", "-", "1", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"P\"", "+", "str", "(", "i", ")", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "FALSE", ",", "f\"Expected input to be False, received {prediction}\"", "\n", "", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_names.test": [[10, 27], ["lnn.Proposition", "lnn.Proposition", "lnn.And", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "for", "name", "in", "[", "\"A^B\"", ",", "\"A\u2227B\"", ",", "\"A&B\"", "]", ":", "\n", "        ", "\"\"\"allow unicode characters in names\"\"\"", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "And", "(", "A", ",", "B", ",", "name", "=", "name", ")", "# This name should be accepted", "\n", "assert", "AB", "is", "not", "None", "\n", "\n", "formulae", "=", "[", "AB", "]", "\n", "facts", "=", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "TRUE", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "name", "]", ".", "upward", "(", ")", "\n", "\n", "prediction", "=", "model", "[", "name", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "TRUE", ",", "\"\ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_or_1.test_upward": [[10, 46], ["lnn.Proposition", "lnn.Proposition", "lnn.Or", "enumerate", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["def", "test_upward", "(", ")", ":", "\n", "    ", "\"\"\"standard upward ,2-input disjunction three-valued truth table\"\"\"", "\n", "\n", "TT", "=", "[", "\n", "# A, B, Or(A, B)", "\n", "[", "TRUE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "FALSE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "UNKNOWN", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "UNKNOWN", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "UNKNOWN", ",", "FALSE", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "Or", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "TT", ")", ":", "\n", "# get ground truth", "\n", "        ", "GT", "=", "row", "[", "2", "]", "\n", "\n", "# load model and reason over facts", "\n", "facts", "=", "{", "\"A\"", ":", "row", "[", "0", "]", ",", "\"B\"", ":", "row", "[", "1", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "prediction", "is", "GT", "\n", ")", ",", "f\"{i} Or({row[0]}, {row[1]}) expected {GT}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_tri_or_1.test_downward": [[48, 87], ["lnn.Proposition", "lnn.Proposition", "lnn.Or", "enumerate", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush"], ["", "", "def", "test_downward", "(", ")", ":", "\n", "    ", "TT", "=", "[", "\n", "# B, Or(A, B), A", "\n", "[", "FALSE", ",", "FALSE", ",", "FALSE", "]", ",", "\n", "[", "FALSE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "\n", "[", "FALSE", ",", "TRUE", ",", "TRUE", "]", ",", "\n", "[", "TRUE", ",", "FALSE", ",", "FALSE", "]", ",", "# contradiction at B", "\n", "[", "TRUE", ",", "UNKNOWN", ",", "UNKNOWN", "]", ",", "# contradiction at Or()", "\n", "[", "TRUE", ",", "TRUE", ",", "UNKNOWN", "]", ",", "\n", "]", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "AB", "=", "Or", "(", "A", ",", "B", ",", "name", "=", "\"AB\"", ")", "\n", "formulae", "=", "[", "AB", "]", "\n", "\n", "for", "i", ",", "row", "in", "enumerate", "(", "TT", ")", ":", "\n", "# load model and reason over facts", "\n", "        ", "facts", "=", "{", "\"B\"", ":", "row", "[", "0", "]", ",", "\"AB\"", ":", "row", "[", "1", "]", "}", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "model", "[", "\"AB\"", "]", ".", "downward", "(", "index", "=", "0", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"A\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "row", "[", "2", "]", ",", "(", "\n", "f\"{i}: Or(A, {row[0]}) = {row[1]}, Expected A={row[2]}, \"", "\n", "f\"received {prediction}\"", "\n", ")", "\n", "\n", "# evaluate the conjunction", "\n", "prediction", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "row", "[", "0", "]", ",", "(", "\n", "f\"{i}: Or(A, {row[0]}) = {row[1]}, Expected B={row[0]}, \"", "\n", "f\"received {prediction}\"", "\n", ")", "\n", "model", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_implies_1.test_upward": [[22, 48], ["lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.truth_table", "numpy.logical_or", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "model[].upward", "model[].state", "lnn.Model.flush", "numpy.logical_not", "lnn.fact_to_bool", "lnn.bool_to_fact", "lnn.fact_to_bool"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.fact_to_bool", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.fact_to_bool"], ["\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "TRUE", ",", "\"RHS\"", ":", "FALSE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "bias", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"bias\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "bias", "<=", "1e-5", ",", "f\"expected bias to be downweighted <= 0., received {bias}\"", "\n", "assert", "bounds", "is", "TRUE", ",", "f\"expected operator bounds to remain True, received {bounds}\"", "\n", "\n", "return", "model", "\n", "\n", "\n", "", "def", "test_false_operator_1", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False Implies, for (False, Unknown) inputs\n    expects LHS innput to be downweighted\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "neuron", "=", "{", "\"alpha\"", ":", "1", "-", "1e-5", "}", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_bool_implies_1.test_downward": [[50, 102], ["lnn.Model", "lnn.Proposition", "lnn.Proposition", "lnn.Implies", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.flush", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state", "lnn.Model.add_facts", "model[].downward", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.flush", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic.ForAll.downward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "FALSE", ",", "\"RHS\"", ":", "UNKNOWN", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "0", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input LHS to be downweighted <= .5, received {weights[0]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds AB to remain False, received {bounds}\"", "\n", "\n", "\n", "", "def", "test_false_operator_2", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False Implies, for (False, True) inputs\n    expects both inputs to be downweighted\n    under this configuration, the parent operand defaults to the expected\n        behavior of an implication\n        - add input information from False to become True\n        - both LHS and RHS add information, and are therefore incorrect\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "CLOSED", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "FALSE", ",", "\"RHS\"", ":", "TRUE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "all", "(", "\n", "[", "w", "<=", "1", "/", "2", "for", "w", "in", "weights", "]", "\n", ")", ",", "f\"expected both inputs to be downweighted <= .5, received {weights}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds AB to remain False, received {bounds}\"", "\n", "\n", "\n", "", "def", "test_false_operator_3", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given a False Implies, for (True, True) inputs\n    The LHS agrees with the operator that the operator bounds could be False,\n    both the operator and the LHS therefore conclude that the RHS is the source\n    of the contradiction - downweight RHS\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "neuron", "=", "{", "\"alpha\"", ":", "1", "-", "1e-5", "}", "\n", "model", "[", "\"LHS\"", "]", "=", "Proposition", "(", "\"LHS\"", ")", "\n", "model", "[", "\"RHS\"", "]", "=", "Proposition", "(", "\"RHS\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"LHS\"", "]", ",", "model", "[", "\"RHS\"", "]", ",", "world", "=", "CLOSED", ",", "neuron", "=", "neuron", ")", "\n", "model", ".", "add_facts", "(", "{", "\"LHS\"", ":", "TRUE", ",", "\"RHS\"", ":", "TRUE", "}", ")", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "[", "\"contradiction\"", "]", ")", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.lifted.grecian_1.test": [[10, 38], ["lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_formulae", "lnn.Model.infer", "lnn.Predicate.Implies", "lnn.Predicate.Implies", "lnn.Predicate.Implies", "lnn.Predicate.Or", "lnn.Model.nodes.keys"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.keys"], ["def", "test", "(", ")", ":", "\n", "# create empty model", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "\n", "# define the rules/knowledge", "\n", "Grecian", "=", "model", "[", "\"G\"", "]", "=", "Predicate", "(", ")", "\n", "Human", "=", "model", "[", "\"H\"", "]", "=", "Predicate", "(", ")", "\n", "Mortal", "=", "model", "[", "\"M\"", "]", "=", "Predicate", "(", ")", "\n", "Lived", "=", "model", "[", "\"L\"", "]", "=", "Predicate", "(", ")", "\n", "Alive", "=", "model", "[", "\"A\"", "]", "=", "Predicate", "(", ")", "\n", "\n", "formulae", "=", "[", "\n", "Grecian", ".", "Implies", "(", "Human", ")", ",", "\n", "Human", ".", "Implies", "(", "Mortal", ")", ",", "\n", "Mortal", ".", "Implies", "(", "Lived", ".", "Or", "(", "Alive", ")", ")", ",", "\n", "]", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ",", "world", "=", "AXIOM", ")", "\n", "\n", "# perform inference/learning on the model", "\n", "model", ".", "infer", "(", "lifted", "=", "True", ")", "\n", "\n", "GT", "=", "[", "\"(G \u2192 M)\"", ",", "\"(H \u2192 (L \u2228 A))\"", ",", "\"(G \u2192 (L \u2228 A))\"", "]", "\n", "for", "gt", "in", "GT", ":", "\n", "        ", "assert", "(", "\n", "gt", "in", "model", ".", "nodes", ".", "keys", "(", ")", "\n", ")", ",", "f\"lifted preprocessing could not find {gt} in the model\"", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_atlocation_1.test": [[12, 140], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Variable", "lnn.Variable", "lnn.Variable", "lnn.Variable", "itertools.permutations", "list", "itertools.permutations", "list", "enumerate", "lnn.And", "lnn.Model.train", "len", "all", "lnn.ForAll", "subrules.append", "str", "lnn.Bidirectional", "chosen_idx.append", "rule_idx.append", "str", "lnn.And", "model.add_predicates.", "model.add_predicates.", "model.add_predicates.", "model.add_predicates.", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["def", "test", "(", ")", ":", "\n", "# background data (features)", "\n", "    ", "B", "=", "{", "\n", "\"atlocation\"", ":", "[", "(", "\"hat\"", ",", "\"rack\"", ")", ",", "(", "\"moccasins\"", ",", "\"cabinet\"", ")", ",", "(", "\"tissue\"", ",", "\"basket\"", ")", "]", ",", "\n", "\"related_to\"", ":", "[", "\n", "(", "\"shoe cabinet\"", ",", "\"cabinet\"", ")", ",", "\n", "(", "\"hat rack\"", ",", "\"rack\"", ")", ",", "\n", "(", "\"top hat\"", ",", "\"hat\"", ")", ",", "\n", "(", "\"blue moccasins\"", ",", "\"moccasins\"", ")", ",", "\n", "(", "\"used tissue\"", ",", "\"tissue\"", ")", ",", "\n", "(", "\"wastepaper basket\"", ",", "\"basket\"", ")", ",", "\n", "]", ",", "\n", "}", "\n", "\n", "# positive (target) labels", "\n", "P", "=", "{", "\n", "\"put\"", ":", "[", "\n", "(", "\"top hat\"", ",", "\"hat rack\"", ")", ",", "\n", "(", "\"blue moccasins\"", ",", "\"shoe cabinet\"", ")", ",", "\n", "(", "\"used tissue\"", ",", "\"wastepaper basket\"", ")", ",", "\n", "]", "\n", "}", "\n", "\n", "# Predicates:", "\n", "# ['atlocation( x,y)', 'atlocation( x,u)', 'atlocation( x,v)',", "\n", "#  'atlocation( y,x)', 'atlocation( y,u)', 'atlocation( y,v)',", "\n", "#  'atlocation( u,x)', 'atlocation( u,y)', 'atlocation( u,v)',", "\n", "#  'atlocation( v,x)', 'atlocation( v,y)', 'related_to( x,y)',", "\n", "#  'related_to( x,u)', 'related_to( x,v)', 'related_to( y,x)',", "\n", "#  'related_to( y,u)', 'related_to( y,v)', 'related_to( u,x)',", "\n", "#  'related_to( u,y)', 'related_to( u,v)', 'related_to( v,x)',", "\n", "#  'related_to( v,y)']", "\n", "\n", "# Learned rule:", "\n", "# put(x,y):- related_to(x,u) \u2227 atlocation(u,v) \u2227 related_to(y,v)", "\n", "\n", "valid_rules", "=", "[", "\n", "[", "\"x, u\"", ",", "\"u, v\"", ",", "\"y, v\"", "]", ",", "\n", "[", "\"x, v\"", ",", "\"v, u\"", ",", "\"y, u\"", "]", ",", "\n", "[", "\"y, u\"", ",", "\"v, u\"", ",", "\"x, v\"", "]", ",", "\n", "[", "\"y, v\"", ",", "\"u, v\"", ",", "\"x, u\"", "]", ",", "\n", "]", "\n", "\n", "# Subrule template:", "\n", "# put(x,y):- related_to(*,*) \u2227 atlocation(*,*) \u2227 related_to(*,*) [x,y,u,v]", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "atlocation", "=", "model", ".", "add_predicates", "(", "2", ",", "\"atlocation\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "related_to", "=", "model", ".", "add_predicates", "(", "2", ",", "\"related_to\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "put", "=", "model", ".", "add_predicates", "(", "2", ",", "\"put\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"atlocation\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"atlocation\"", "]", "}", ",", "\n", "\"related_to\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"related_to\"", "]", "}", ",", "\n", "\"put\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "P", "[", "\"put\"", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "u", "=", "Variable", "(", "\"u\"", ")", "\n", "v", "=", "Variable", "(", "\"v\"", ")", "\n", "\n", "variables", "=", "[", "x", ",", "y", ",", "u", ",", "v", "]", "\n", "pairs", "=", "itertools", ".", "permutations", "(", "variables", ",", "2", ")", "# e.g. [(x, y), ...]", "\n", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "# e.g. [((x, y), (x, z)), ...]", "\n", "# Order of predicates in body matters, so permutations are needed.", "\n", "rule_vars", "=", "itertools", ".", "permutations", "(", "pairs", ",", "3", ")", "\n", "rule_vars", "=", "list", "(", "rule_vars", ")", "\n", "\n", "\"\"\"\n    rule_vars = [((x, u), (u, v), (y, v)), ((x, y), (x, u), (x, v)),\n                 ((x, y), (x, u), (y, x)), ((x, v), (v, u), (y, u)),\n                 ((u, y), (u, v), (v, u)), ((y, v), (u, y), (v, u)),\n                 ((x, u), (u, x), (v, u)), ((x, u), (x, v), (y, u)),\n                 ((x, u), (u, v), (v, x)), ((x, y), (y, x), (v, x))]\n    \"\"\"", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "\n", "subrules", "=", "[", "]", "\n", "for", "i", ",", "preds_vars", "in", "enumerate", "(", "rule_vars", ")", ":", "\n", "        ", "vars1", ",", "vars2", ",", "vars3", "=", "preds_vars", "\n", "model", "[", "str", "(", "i", ")", "]", "=", "ForAll", "(", "\n", "Bidirectional", "(", "\n", "And", "(", "\n", "related_to", "(", "*", "vars1", ")", ",", "\n", "atlocation", "(", "*", "vars2", ")", ",", "\n", "related_to", "(", "*", "vars3", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "put", "(", "x", ",", "y", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "fully_grounded", "=", "True", ",", "\n", ")", "\n", "subrules", ".", "append", "(", "model", "[", "str", "(", "i", ")", "]", ")", "\n", "\n", "", "rule", "=", "model", "[", "\"rule\"", "]", "=", "And", "(", "\n", "*", "subrules", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "{", "\"bias_learning\"", ":", "False", "}", "\n", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", "\n", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "chosen_idx", "=", "[", "]", "\n", "rule_idx", "=", "[", "]", "\n", "weighted_idx", "=", "(", "rule", ".", "neuron", ".", "weights", "==", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "for", "idx", "in", "weighted_idx", ":", "\n", "        ", "subrule_forall", "=", "rule", ".", "operands", "[", "idx", "]", "\n", "if", "subrule_forall", ".", "neuron", ".", "bounds_table", "[", "0", "]", "[", "0", "]", "==", "1", ":", "\n", "            ", "subrule_bidirectional", "=", "subrule_forall", ".", "operands", "[", "0", "]", "\n", "subrule_implication", "=", "subrule_bidirectional", ".", "Imp1", "\n", "subrule_and", "=", "subrule_implication", ".", "operands", "[", "0", "]", "\n", "subrule_and_vars", "=", "subrule_and", ".", "binding_str", "\n", "chosen_idx", ".", "append", "(", "subrule_and_vars", ")", "\n", "rule_idx", ".", "append", "(", "idx", ")", "\n", "\n", "", "", "num_chosen", "=", "len", "(", "chosen_idx", ")", "\n", "assert", "num_chosen", "==", "4", ",", "\"expected 4 got \"", "+", "str", "(", "num_chosen", ")", "\n", "\n", "assert", "all", "(", "[", "r", "in", "valid_rules", "for", "r", "in", "chosen_idx", "]", ")", ",", "\"some rule(s)\"", "+", "\"are not found\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_bool_and_1.test": [[21, 53], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Variable", "lnn.And", "lnn.Model.train", "model[].state().values", "all", "p1", "p2", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["# rules", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "# facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "\n", "# train/inference", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "return", "model", "\n", "\n", "\n", "", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    training in both directions\n    \"\"\"", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "\n", "model", "[", "\"A\"", "]", ",", "\n", "model", "[", "\"B\"", "]", ",", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_atlocation_2.prune_rules": [[23, 73], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.ForAll", "lnn.Model.infer", "sum", "lnn.Implies", "lnn.And", "model.add_predicates.", "model.add_predicates.", "model.add_predicates.", "model.add_predicates.", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "prune_rules", "(", "B", ",", "P", ",", "variables", ",", "rule_vars", ")", ":", "\n", "    ", "\"\"\"\n    This function performs inference on background facts using rule defined\n    by 'rule_vars' and return the number of predicted facts that agree\n    with examples in P.\n    :param B:  Background facts.\n    :param P:  Positive examples.\n    :param variables: Set of variables.\n    :param rule_vars: Variable configuration for candidate rule.\n    :return: Sum of facts correctly predicted as True.\n    \"\"\"", "\n", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "model", "=", "Model", "(", ")", "\n", "atlocation", "=", "model", ".", "add_predicates", "(", "2", ",", "\"atlocation\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "related_to", "=", "model", ".", "add_predicates", "(", "2", ",", "\"related_to\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "put", "=", "model", ".", "add_predicates", "(", "2", ",", "\"put\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"atlocation\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"atlocation\"", "]", "}", ",", "\n", "\"related_to\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"related_to\"", "]", "}", ",", "\n", "\"put\"", ":", "{", "pair", ":", "UNKNOWN", "for", "pair", "in", "P", "[", "\"put\"", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# Set ground truth for target predicate", "\n", "GT", "=", "{", "}", "\n", "for", "grounding", "in", "P", "[", "\"put\"", "]", ":", "\n", "        ", "GT", "[", "grounding", "]", "=", "TRUE", "\n", "\n", "", "x", ",", "y", ",", "u", ",", "v", "=", "variables", "\n", "vars1", ",", "vars2", ",", "vars3", "=", "rule_vars", "\n", "model", "[", "\"test_rule\"", "]", "=", "ForAll", "(", "\n", "Implies", "(", "\n", "And", "(", "\n", "related_to", "(", "*", "vars1", ")", ",", "\n", "atlocation", "(", "*", "vars2", ")", ",", "\n", "related_to", "(", "*", "vars3", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "put", "(", "x", ",", "y", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "\n", "return", "sum", "(", "[", "model", "[", "\"put\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_atlocation_2.test": [[75, 232], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Variable", "lnn.Variable", "lnn.Variable", "lnn.Variable", "itertools.permutations", "list", "itertools.permutations", "list", "enumerate", "lnn.And", "lnn.Model.train", "set", "set.union", "set.union", "all", "set", "set", "valid_sub_rules.append", "lnn.ForAll", "subrules.append", "test_supervised_atlocation_2.prune_rules", "lnn.Bidirectional", "str", "lnn.And", "model.add_predicates.", "model.add_predicates.", "model.add_predicates.", "model.add_predicates.", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_atlocation_2.prune_rules", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["", "def", "test", "(", ")", ":", "\n", "# background data (features)", "\n", "    ", "B", "=", "{", "\n", "\"atlocation\"", ":", "[", "\n", "(", "\"towel\"", ",", "\"towel rail\"", ")", ",", "\n", "(", "\"cap\"", ",", "\"hat rack\"", ")", ",", "\n", "(", "\"flour\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"handsoap\"", ",", "\"sink\"", ")", ",", "\n", "(", "\"sugar\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"shoes\"", ",", "\"cabinet\"", ")", ",", "\n", "(", "\"peanut oil\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"bathrobe\"", ",", "\"hook\"", ")", ",", "\n", "(", "\"white cap\"", ",", "\"hat rack\"", ")", ",", "\n", "]", ",", "\n", "\"related_to\"", ":", "[", "\n", "(", "\"white cap\"", ",", "\"white cap\"", ")", ",", "\n", "(", "\"hat rack\"", ",", "\"hat rack\"", ")", ",", "\n", "(", "\"shelf\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"handsoap\"", ",", "\"handsoap\"", ")", ",", "\n", "(", "\"bathrobe\"", ",", "\"bathrobe\"", ")", ",", "\n", "(", "\"flour\"", ",", "\"flour\"", ")", ",", "\n", "(", "\"towel\"", ",", "\"towel\"", ")", ",", "\n", "(", "\"towel rail\"", ",", "\"towel rail\"", ")", ",", "\n", "(", "\"peanut oil\"", ",", "\"peanut oil\"", ")", ",", "\n", "(", "\"wall hook\"", ",", "\"hook\"", ")", ",", "\n", "(", "\"sugar\"", ",", "\"sugar\"", ")", ",", "\n", "(", "\"sink\"", ",", "\"sink\"", ")", ",", "\n", "(", "\"climbing shoes\"", ",", "\"shoes\"", ")", ",", "\n", "(", "\"brown cap\"", ",", "\"cap\"", ")", ",", "\n", "(", "\"white cap\"", ",", "\"cap\"", ")", ",", "\n", "(", "\"shoe cabinet\"", ",", "\"cabinet\"", ")", ",", "\n", "]", ",", "\n", "}", "\n", "\n", "# (noisy) positive (target) labels", "\n", "P", "=", "{", "\n", "\"put\"", ":", "[", "\n", "(", "\"towel\"", ",", "\"towel rail\"", ")", ",", "\n", "(", "\"flour\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"handsoap\"", ",", "\"sink\"", ")", ",", "\n", "(", "\"sugar\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"peanut oil\"", ",", "\"shelf\"", ")", ",", "\n", "(", "\"bathrobe\"", ",", "\"wall hook\"", ")", ",", "\n", "(", "\"brown cap\"", ",", "\"hat rack\"", ")", ",", "\n", "(", "\"white cap\"", ",", "\"hat rack\"", ")", ",", "\n", "(", "\"flour\"", ",", "\"folding chair\"", ")", ",", "\n", "(", "\"sugar\"", ",", "\"folding chair\"", ")", ",", "\n", "(", "\"peanut oil\"", ",", "\"folding chair\"", ")", ",", "\n", "]", "\n", "}", "\n", "\n", "# Predicates:", "\n", "# ['atlocation( x,y)', 'atlocation( x,u)', 'atlocation( x,v)',", "\n", "#  'atlocation( y,x)', 'atlocation( y,u)', 'atlocation( y,v)',", "\n", "#  'atlocation( u,x)', 'atlocation( u,y)', 'atlocation( u,v)',", "\n", "#  'atlocation( v,x)', 'atlocation( v,y)', 'related_to( x,y)',", "\n", "#  'related_to( x,u)', 'related_to( x,v)', 'related_to( y,x)',", "\n", "#  'related_to( y,u)', 'related_to( y,v)', 'related_to( u,x)',", "\n", "#  'related_to( u,y)', 'related_to( u,v)', 'related_to( v,x)',", "\n", "#  'related_to( v,y)']", "\n", "\n", "# Learned rule:", "\n", "# put(x,y):- related_to(x,u) \u2227 atlocation(u,v) \u2227 related_to(y,v)", "\n", "\n", "valid_rules", "=", "[", "\n", "[", "\"x, u\"", ",", "\"u, v\"", ",", "\"y, v\"", "]", ",", "\n", "[", "\"x, v\"", ",", "\"v, u\"", ",", "\"y, u\"", "]", ",", "\n", "[", "\"y, u\"", ",", "\"v, u\"", ",", "\"x, v\"", "]", ",", "\n", "[", "\"y, v\"", ",", "\"u, v\"", ",", "\"x, u\"", "]", ",", "\n", "]", "\n", "\n", "# Subrule template:", "\n", "# put(x,y):- related_to(*,*) \u2227 atlocation(*,*) \u2227 related_to(*,*) [x,y,u,v]", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "atlocation", "=", "model", ".", "add_predicates", "(", "2", ",", "\"atlocation\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "related_to", "=", "model", ".", "add_predicates", "(", "2", ",", "\"related_to\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "put", "=", "model", ".", "add_predicates", "(", "2", ",", "\"put\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"atlocation\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"atlocation\"", "]", "}", ",", "\n", "\"related_to\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"related_to\"", "]", "}", ",", "\n", "\"put\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "P", "[", "\"put\"", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "u", "=", "Variable", "(", "\"u\"", ")", "\n", "v", "=", "Variable", "(", "\"v\"", ")", "\n", "\n", "variables", "=", "[", "x", ",", "y", ",", "u", ",", "v", "]", "\n", "pairs", "=", "itertools", ".", "permutations", "(", "variables", ",", "2", ")", "# e.g. [(x, y), ...]", "\n", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "# e.g. [((x, y), (x, z)), ...]", "\n", "# Order of predicates in body matters, so permutations are needed.", "\n", "rule_vars", "=", "itertools", ".", "permutations", "(", "pairs", ",", "3", ")", "\n", "rule_vars", "=", "list", "(", "rule_vars", ")", "\n", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "\n", "subrules", "=", "[", "]", "\n", "valid_sub_rules", "=", "[", "]", "\n", "head_vars", "=", "(", "x", ",", "y", ")", "\n", "for", "i", ",", "preds_vars", "in", "enumerate", "(", "rule_vars", ")", ":", "\n", "        ", "vars1", ",", "vars2", ",", "vars3", "=", "preds_vars", "\n", "body_vars", "=", "set", "(", "vars1", ")", "\n", "body_vars", "=", "set", ".", "union", "(", "body_vars", ",", "set", "(", "vars2", ")", ")", "\n", "body_vars", "=", "set", ".", "union", "(", "body_vars", ",", "set", "(", "vars3", ")", ")", "\n", "# Filter rules who have head variables not appearing in body.", "\n", "if", "all", "(", "[", "var", "in", "body_vars", "for", "var", "in", "head_vars", "]", ")", ":", "\n", "            ", "valid_sub_rules", ".", "append", "(", "preds_vars", ")", "\n", "model", "[", "str", "(", "i", ")", "]", "=", "ForAll", "(", "\n", "Bidirectional", "(", "\n", "And", "(", "\n", "related_to", "(", "*", "vars1", ")", ",", "\n", "atlocation", "(", "*", "vars2", ")", ",", "\n", "related_to", "(", "*", "vars3", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "put", "(", "x", ",", "y", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "fully_grounded", "=", "True", ",", "\n", ")", "\n", "subrules", ".", "append", "(", "model", "[", "str", "(", "i", ")", "]", ")", "\n", "\n", "", "", "rule", "=", "model", "[", "\"rule\"", "]", "=", "And", "(", "\n", "*", "subrules", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "{", "\"bias_learning\"", ":", "False", "}", "\n", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", "\n", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "chosen_idx", "=", "[", "]", "\n", "best_value", "=", "0", "\n", "weighted_idx", "=", "(", "rule", ".", "neuron", ".", "weights", "==", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "for", "idx", "in", "weighted_idx", ":", "\n", "        ", "subrule_forall", "=", "rule", ".", "operands", "[", "idx", "]", "\n", "if", "subrule_forall", ".", "neuron", ".", "bounds_table", "[", "0", "]", "[", "0", "]", "==", "1", ":", "\n", "            ", "rule_value", "=", "prune_rules", "(", "B", ",", "P", ",", "variables", ",", "valid_sub_rules", "[", "idx", "]", ")", "\n", "# Pick rule with highest agreement with facts.", "\n", "if", "rule_value", ">", "best_value", ":", "\n", "                ", "best_value", "=", "rule_value", "\n", "subrule_bidirectional", "=", "subrule_forall", ".", "operands", "[", "0", "]", "\n", "subrule_implication", "=", "subrule_bidirectional", ".", "Imp1", "\n", "subrule_and", "=", "subrule_implication", ".", "operands", "[", "0", "]", "\n", "subrule_and_vars", "=", "subrule_and", ".", "binding_str", "\n", "chosen_idx", "=", "subrule_and_vars", "\n", "\n", "", "", "", "assert", "chosen_idx", "in", "valid_rules", ",", "\"Incorrect rule.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_family_tree.test_1": [[13, 129], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Variable", "lnn.Variable", "lnn.Variable", "itertools.permutations", "list", "itertools.combinations", "list", "enumerate", "lnn.And", "lnn.Model.train", "len", "lnn.ForAll", "subrules.append", "str", "str", "lnn.Bidirectional", "chosen_idx.append", "str", "lnn.And", "p", "str", "b", "b", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.p"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"\n    In this test all positive examples are provided.\n    :return:\n    \"\"\"", "\n", "\n", "# background data (features)", "\n", "\n", "B", "=", "[", "\n", "\"isFather\"", ",", "\n", "[", "\n", "(", "\"a\"", ",", "\"b\"", ")", ",", "\n", "(", "\"b\"", ",", "\"c\"", ")", ",", "\n", "(", "\"d\"", ",", "\"e\"", ")", ",", "\n", "(", "\"f\"", ",", "\"g\"", ")", ",", "\n", "(", "\"e\"", ",", "\"h\"", ")", ",", "\n", "(", "\"g\"", ",", "\"a\"", ")", ",", "\n", "(", "\"d\"", ",", "\"f\"", ")", ",", "\n", "(", "\"a\"", ",", "\"j\"", ")", ",", "\n", "(", "\"g\"", ",", "\"i\"", ")", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "# positive (target) labels for isGrandFather(x,y)", "\n", "\n", "P1", "=", "[", "\n", "\"isGrandFather\"", ",", "\n", "[", "\n", "(", "\"a\"", ",", "\"c\"", ")", ",", "\n", "(", "\"g\"", ",", "\"b\"", ")", ",", "\n", "(", "\"f\"", ",", "\"a\"", ")", ",", "\n", "(", "\"d\"", ",", "\"g\"", ")", ",", "\n", "(", "\"d\"", ",", "\"h\"", ")", ",", "\n", "(", "\"g\"", ",", "\"j\"", ")", ",", "\n", "(", "\"f\"", ",", "\"i\"", ")", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "# positive (target) labels for isSibling(x,y)", "\n", "P2", "=", "[", "\n", "\"isSibling\"", ",", "\n", "[", "(", "\"j\"", ",", "\"b\"", ")", ",", "(", "\"b\"", ",", "\"j\"", ")", ",", "(", "\"a\"", ",", "\"i\"", ")", ",", "(", "\"i\"", ",", "\"a\"", ")", ",", "(", "\"f\"", ",", "\"e\"", ")", ",", "(", "\"e\"", ",", "\"f\"", ")", "]", ",", "\n", "]", "\n", "\n", "# The rule templates are", "\n", "#   isGrandFather(x,y) -> isFather(*,*) \u2227 isFather(*,*) [x,y,z]", "\n", "#   isSibling(x,y) <-> (isFather(*,*) \u2227 isFather(*,*)) [x,y,z]", "\n", "\n", "# The rules learned are:", "\n", "#   isGrandFather(x,y):- isFather(x,z) \u2227 isFather(z,y)", "\n", "#   isGrandFather(x,y) <-> (isFather(x,z) \u2227 isFather(z,y))", "\n", "\n", "#   isSibling(x,y):- isFather(z,x) \u2227 isFather(z,y)", "\n", "#   isSibling(x,y) <-> (isFather(z,x) \u2227 isFather(z,y))", "\n", "\n", "for", "target", "in", "[", "(", "P1", ",", "[", "\"x, z\"", ",", "\"z, y\"", "]", ")", ",", "(", "P2", ",", "[", "\"z, x\"", ",", "\"z, y\"", "]", ")", "]", ":", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "b", ",", "p", "=", "model", ".", "add_predicates", "(", "2", ",", "B", "[", "0", "]", ",", "target", "[", "0", "]", "[", "0", "]", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "b", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "1", "]", "}", ",", "\n", "p", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "target", "[", "0", "]", "[", "1", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "variables", "=", "[", "x", ",", "y", ",", "z", "]", "\n", "pairs", "=", "itertools", ".", "permutations", "(", "variables", ",", "2", ")", "# e.g. [(x, y), ...]", "\n", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "# e.g. [((x, y), (x, z)), ...]", "\n", "rule_vars", "=", "itertools", ".", "combinations", "(", "pairs", ",", "2", ")", "\n", "rule_vars", "=", "list", "(", "rule_vars", ")", "\n", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "\n", "subrules", "=", "[", "]", "\n", "for", "i", ",", "preds_vars", "in", "enumerate", "(", "rule_vars", ")", ":", "\n", "            ", "vars1", ",", "vars2", "=", "preds_vars", "\n", "model", "[", "str", "(", "i", ")", "]", "=", "ForAll", "(", "\n", "Bidirectional", "(", "\n", "And", "(", "b", "(", "*", "vars1", ")", ",", "b", "(", "*", "vars2", ")", ",", "neuron", "=", "neuron", ")", ",", "p", "(", "x", ",", "y", ")", ",", "neuron", "=", "neuron", "\n", ")", ",", "\n", "fully_grounded", "=", "True", ",", "\n", ")", "\n", "subrules", ".", "append", "(", "model", "[", "str", "(", "i", ")", "]", ")", "\n", "\n", "", "rule", "=", "model", "[", "\"rule\"", "]", "=", "And", "(", "\n", "*", "subrules", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "{", "\"bias_learning\"", ":", "False", "}", "\n", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", "\n", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "chosen_idx", "=", "[", "]", "\n", "weighted_idx", "=", "(", "rule", ".", "neuron", ".", "weights", "==", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "for", "idx", "in", "weighted_idx", ":", "\n", "            ", "subrule_forall", "=", "rule", ".", "operands", "[", "idx", "]", "\n", "if", "subrule_forall", ".", "neuron", ".", "bounds_table", "[", "0", "]", "[", "0", "]", "==", "1", ":", "\n", "                ", "subrule_bidirectional", "=", "subrule_forall", ".", "operands", "[", "0", "]", "\n", "subrule_implication", "=", "subrule_bidirectional", ".", "Imp1", "\n", "subrule_and", "=", "subrule_implication", ".", "operands", "[", "0", "]", "\n", "subrule_and_vars", "=", "subrule_and", ".", "binding_str", "\n", "chosen_idx", ".", "append", "(", "subrule_and_vars", ")", "\n", "\n", "", "", "num_chosen", "=", "len", "(", "chosen_idx", ")", "\n", "assert", "num_chosen", "==", "1", ",", "\"expected 1 got \"", "+", "str", "(", "num_chosen", ")", "\n", "assert", "chosen_idx", "[", "0", "]", "==", "target", "[", "1", "]", ",", "(", "\n", "\"expected \"", "+", "str", "(", "target", "[", "1", "]", ")", "+", "\" got \"", "+", "str", "(", "chosen_idx", "[", "0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_family_tree.test_2": [[132, 263], ["itertools.permutations", "list", "lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Variable", "lnn.Variable", "lnn.Variable", "itertools.permutations", "list", "itertools.combinations", "list", "enumerate", "lnn.And", "lnn.Model.train", "len", "lnn.ForAll", "subrules.append", "str", "str", "lnn.Bidirectional", "chosen_idx.append", "str", "lnn.And", "p", "str", "b", "b", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.p"], ["", "", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"\n    In this test all positive examples are provided and the rest are assumed\n    negative.\n    :return:\n    \"\"\"", "\n", "\n", "# Constants", "\n", "C", "=", "{", "\"a\"", ",", "\"b\"", ",", "\"c\"", ",", "\"d\"", ",", "\"e\"", ",", "\"f\"", ",", "\"g\"", ",", "\"h\"", ",", "\"i\"", ",", "\"j\"", "}", "\n", "# Binary grounding pairs", "\n", "groundings", "=", "itertools", ".", "permutations", "(", "C", ",", "2", ")", "\n", "groundings", "=", "list", "(", "groundings", ")", "\n", "\n", "# background data (features)", "\n", "\n", "B", "=", "[", "\n", "\"isFather\"", ",", "\n", "[", "\n", "(", "\"a\"", ",", "\"b\"", ")", ",", "\n", "(", "\"b\"", ",", "\"c\"", ")", ",", "\n", "(", "\"d\"", ",", "\"e\"", ")", ",", "\n", "(", "\"f\"", ",", "\"g\"", ")", ",", "\n", "(", "\"e\"", ",", "\"h\"", ")", ",", "\n", "(", "\"g\"", ",", "\"a\"", ")", ",", "\n", "(", "\"d\"", ",", "\"f\"", ")", ",", "\n", "(", "\"a\"", ",", "\"j\"", ")", ",", "\n", "(", "\"g\"", ",", "\"i\"", ")", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "# positive (target) labels for isGrandFather(x,y)", "\n", "\n", "P1", "=", "[", "\n", "\"isGrandFather\"", ",", "\n", "[", "\n", "(", "\"a\"", ",", "\"c\"", ")", ",", "\n", "(", "\"g\"", ",", "\"b\"", ")", ",", "\n", "(", "\"f\"", ",", "\"a\"", ")", ",", "\n", "(", "\"d\"", ",", "\"g\"", ")", ",", "\n", "(", "\"d\"", ",", "\"h\"", ")", ",", "\n", "(", "\"g\"", ",", "\"j\"", ")", ",", "\n", "(", "\"f\"", ",", "\"i\"", ")", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "# positive (target) labels for isSibling(x,y)", "\n", "P2", "=", "[", "\n", "\"isSibling\"", ",", "\n", "[", "(", "\"j\"", ",", "\"b\"", ")", ",", "(", "\"b\"", ",", "\"j\"", ")", ",", "(", "\"a\"", ",", "\"i\"", ")", ",", "(", "\"i\"", ",", "\"a\"", ")", ",", "(", "\"f\"", ",", "\"e\"", ")", ",", "(", "\"e\"", ",", "\"f\"", ")", "]", ",", "\n", "]", "\n", "\n", "# The rule templates are", "\n", "#   isGrandFather(x,y) -> isFather(*,*) \u2227 isFather(*,*) [x,y,z]", "\n", "#   isSibling(x,y) <-> (isFather(*,*) \u2227 isFather(*,*)) [x,y,z]", "\n", "\n", "# The rules learned are:", "\n", "#   isGrandFather(x,y):- isFather(x,z) \u2227 isFather(z,y)", "\n", "#   isGrandFather(x,y) <-> (isFather(x,z) \u2227 isFather(z,y))", "\n", "\n", "#   isSibling(x,y):- isFather(z,x) \u2227 isFather(z,y)", "\n", "#   isSibling(x,y) <-> (isFather(z,x) \u2227 isFather(z,y))", "\n", "\n", "for", "target", "in", "[", "(", "P1", ",", "[", "\"x, z\"", ",", "\"z, y\"", "]", ")", ",", "(", "P2", ",", "[", "\"z, x\"", ",", "\"z, y\"", "]", ")", "]", ":", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "b", ",", "p", "=", "model", ".", "add_predicates", "(", "2", ",", "B", "[", "0", "]", ",", "target", "[", "0", "]", "[", "0", "]", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "b", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "1", "]", "}", ",", "\n", "p", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "target", "[", "0", "]", "[", "1", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# Negative facts", "\n", "model", ".", "add_facts", "(", "\n", "{", "p", ".", "name", ":", "{", "pair", ":", "FALSE", "for", "pair", "in", "groundings", "if", "pair", "not", "in", "target", "[", "0", "]", "[", "1", "]", "}", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "variables", "=", "[", "x", ",", "y", ",", "z", "]", "\n", "pairs", "=", "itertools", ".", "permutations", "(", "variables", ",", "2", ")", "# e.g. [(x, y), ...]", "\n", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "# e.g. [((x, y), (x, z)), ...]", "\n", "rule_vars", "=", "itertools", ".", "combinations", "(", "pairs", ",", "2", ")", "\n", "rule_vars", "=", "list", "(", "rule_vars", ")", "\n", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "\n", "subrules", "=", "[", "]", "\n", "for", "i", ",", "preds_vars", "in", "enumerate", "(", "rule_vars", ")", ":", "\n", "            ", "vars1", ",", "vars2", "=", "preds_vars", "\n", "model", "[", "str", "(", "i", ")", "]", "=", "ForAll", "(", "\n", "Bidirectional", "(", "\n", "And", "(", "b", "(", "*", "vars1", ")", ",", "b", "(", "*", "vars2", ")", ",", "neuron", "=", "neuron", ")", ",", "p", "(", "x", ",", "y", ")", ",", "neuron", "=", "neuron", "\n", ")", ",", "\n", "fully_grounded", "=", "True", ",", "\n", ")", "\n", "subrules", ".", "append", "(", "model", "[", "str", "(", "i", ")", "]", ")", "\n", "\n", "", "rule", "=", "model", "[", "\"rule\"", "]", "=", "And", "(", "*", "subrules", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", "\n", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "chosen_idx", "=", "[", "]", "\n", "weighted_idx", "=", "(", "rule", ".", "neuron", ".", "weights", "==", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "for", "idx", "in", "weighted_idx", ":", "\n", "            ", "subrule_forall", "=", "rule", ".", "operands", "[", "idx", "]", "\n", "if", "subrule_forall", ".", "neuron", ".", "bounds_table", "[", "0", "]", "[", "0", "]", "==", "1", ":", "\n", "                ", "subrule_bidirectional", "=", "subrule_forall", ".", "operands", "[", "0", "]", "\n", "subrule_implication", "=", "subrule_bidirectional", ".", "Imp1", "\n", "subrule_and", "=", "subrule_implication", ".", "operands", "[", "0", "]", "\n", "subrule_and_vars", "=", "subrule_and", ".", "binding_str", "\n", "chosen_idx", ".", "append", "(", "subrule_and_vars", ")", "\n", "\n", "", "", "num_chosen", "=", "len", "(", "chosen_idx", ")", "\n", "assert", "num_chosen", "==", "1", ",", "\"expected 1 got \"", "+", "str", "(", "num_chosen", ")", "\n", "assert", "chosen_idx", "[", "0", "]", "==", "target", "[", "1", "]", ",", "(", "\n", "\"expected \"", "\n", "+", "str", "(", "target", "[", "1", "]", ")", "\n", "+", "\" got \"", "\n", "+", "str", "(", "chosen_idx", "[", "0", "]", ")", "\n", "+", "\" from \"", "\n", "+", "str", "(", "chosen_idx", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_family_tree.test_3": [[266, 404], ["itertools.permutations", "list", "lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Variable", "lnn.Variable", "lnn.Variable", "itertools.permutations", "list", "itertools.combinations", "list", "enumerate", "lnn.And", "lnn.Model.train", "len", "lnn.ForAll", "subrules.append", "lnn.And.print", "str", "lnn.Bidirectional", "chosen_idx.append", "str", "lnn.And", "p", "str", "random.choices", "b", "b", "str", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.p"], ["", "", "def", "test_3", "(", "output", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    In this test all positive examples are provided and the rest are assumed\n    negative.\n    :return:\n    \"\"\"", "\n", "\n", "# Constants", "\n", "C", "=", "{", "\"a\"", ",", "\"b\"", ",", "\"c\"", ",", "\"d\"", ",", "\"e\"", ",", "\"f\"", ",", "\"g\"", ",", "\"h\"", ",", "\"i\"", ",", "\"j\"", "}", "\n", "# Binary grounding pairs", "\n", "groundings", "=", "itertools", ".", "permutations", "(", "C", ",", "2", ")", "\n", "groundings", "=", "list", "(", "groundings", ")", "\n", "\n", "# background data (features)", "\n", "\n", "B", "=", "[", "\n", "\"isFather\"", ",", "\n", "[", "\n", "(", "\"a\"", ",", "\"b\"", ")", ",", "\n", "(", "\"b\"", ",", "\"c\"", ")", ",", "\n", "(", "\"d\"", ",", "\"e\"", ")", ",", "\n", "(", "\"f\"", ",", "\"g\"", ")", ",", "\n", "(", "\"e\"", ",", "\"h\"", ")", ",", "\n", "(", "\"g\"", ",", "\"a\"", ")", ",", "\n", "(", "\"d\"", ",", "\"f\"", ")", ",", "\n", "(", "\"a\"", ",", "\"j\"", ")", ",", "\n", "(", "\"g\"", ",", "\"i\"", ")", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "# positive (target) labels for isGrandFather(x,y)", "\n", "\n", "P1", "=", "[", "\n", "\"isGrandFather\"", ",", "\n", "[", "\n", "(", "\"a\"", ",", "\"c\"", ")", ",", "\n", "(", "\"g\"", ",", "\"b\"", ")", ",", "\n", "(", "\"f\"", ",", "\"a\"", ")", ",", "\n", "(", "\"d\"", ",", "\"g\"", ")", ",", "\n", "(", "\"d\"", ",", "\"h\"", ")", ",", "\n", "(", "\"g\"", ",", "\"j\"", ")", ",", "\n", "(", "\"f\"", ",", "\"i\"", ")", ",", "\n", "]", ",", "\n", "]", "\n", "\n", "# positive (target) labels for isSibling(x,y)", "\n", "P2", "=", "[", "\n", "\"isSibling\"", ",", "\n", "[", "(", "\"j\"", ",", "\"b\"", ")", ",", "(", "\"b\"", ",", "\"j\"", ")", ",", "(", "\"a\"", ",", "\"i\"", ")", ",", "(", "\"i\"", ",", "\"a\"", ")", ",", "(", "\"f\"", ",", "\"e\"", ")", ",", "(", "\"e\"", ",", "\"f\"", ")", "]", ",", "\n", "]", "\n", "\n", "# The rule templates are", "\n", "#   isGrandFather(x,y) -> isFather(*,*) \u2227 isFather(*,*) [x,y,z]", "\n", "#   isSibling(x,y) <-> (isFather(*,*) \u2227 isFather(*,*)) [x,y,z]", "\n", "\n", "# The rules learned are:", "\n", "#   isGrandFather(x,y):- isFather(x,z) \u2227 isFather(z,y)", "\n", "#   isGrandFather(x,y) <-> (isFather(x,z) \u2227 isFather(z,y))", "\n", "\n", "#   isSibling(x,y):- isFather(z,x) \u2227 isFather(z,y)", "\n", "#   isSibling(x,y) <-> (isFather(z,x) \u2227 isFather(z,y))", "\n", "\n", "for", "target", "in", "[", "(", "P1", ",", "[", "\"x, z\"", ",", "\"z, y\"", "]", ")", ",", "(", "P2", ",", "[", "\"z, x\"", ",", "\"z, y\"", "]", ")", "]", ":", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "b", ",", "p", "=", "model", ".", "add_predicates", "(", "2", ",", "B", "[", "0", "]", ",", "target", "[", "0", "]", "[", "0", "]", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "b", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "1", "]", "[", "0", ":", "-", "2", "]", "}", ",", "\n", "p", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "target", "[", "0", "]", "[", "1", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# Negative facts", "\n", "neg_facts", "=", "[", "pair", "for", "pair", "in", "groundings", "if", "pair", "not", "in", "target", "[", "0", "]", "[", "1", "]", "]", "\n", "model", ".", "add_facts", "(", "\n", "{", "p", ".", "name", ":", "{", "pair", ":", "FALSE", "for", "pair", "in", "random", ".", "choices", "(", "neg_facts", ",", "k", "=", "7", ")", "}", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "variables", "=", "[", "x", ",", "y", ",", "z", "]", "\n", "pairs", "=", "itertools", ".", "permutations", "(", "variables", ",", "2", ")", "# e.g. [(x, y), ...]", "\n", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "# e.g. [((x, y), (x, z)), ...]", "\n", "# For this specific example, the order of predicates in the body", "\n", "# does not matter. In general we should use permutations because", "\n", "# order matters.", "\n", "rule_vars", "=", "itertools", ".", "combinations", "(", "pairs", ",", "2", ")", "\n", "rule_vars", "=", "list", "(", "rule_vars", ")", "\n", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "\n", "subrules", "=", "[", "]", "\n", "for", "i", ",", "preds_vars", "in", "enumerate", "(", "rule_vars", ")", ":", "\n", "            ", "vars1", ",", "vars2", "=", "preds_vars", "\n", "model", "[", "str", "(", "i", ")", "]", "=", "ForAll", "(", "\n", "Bidirectional", "(", "\n", "And", "(", "b", "(", "*", "vars1", ")", ",", "b", "(", "*", "vars2", ")", ",", "neuron", "=", "neuron", ")", ",", "p", "(", "x", ",", "y", ")", ",", "neuron", "=", "neuron", "\n", ")", ",", "\n", "fully_grounded", "=", "True", ",", "\n", ")", "\n", "subrules", ".", "append", "(", "model", "[", "str", "(", "i", ")", "]", ")", "\n", "\n", "", "rule", "=", "model", "[", "\"rule\"", "]", "=", "And", "(", "*", "subrules", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", "\n", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "chosen_idx", "=", "[", "]", "\n", "weighted_idx", "=", "(", "rule", ".", "neuron", ".", "weights", "==", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "for", "idx", "in", "weighted_idx", ":", "\n", "            ", "subrule_forall", "=", "rule", ".", "operands", "[", "idx", "]", "\n", "if", "subrule_forall", ".", "neuron", ".", "bounds_table", "[", "0", "]", "[", "0", "]", "==", "1", ":", "\n", "                ", "subrule_bidirectional", "=", "subrule_forall", ".", "operands", "[", "0", "]", "\n", "subrule_implication", "=", "subrule_bidirectional", ".", "Imp1", "\n", "subrule_and", "=", "subrule_implication", ".", "operands", "[", "0", "]", "\n", "subrule_and_vars", "=", "subrule_and", ".", "binding_str", "\n", "chosen_idx", ".", "append", "(", "subrule_and_vars", ")", "\n", "\n", "", "", "if", "output", ":", "\n", "            ", "rule", ".", "print", "(", "params", "=", "True", ")", "\n", "\n", "", "num_chosen", "=", "len", "(", "chosen_idx", ")", "\n", "assert", "num_chosen", "==", "1", ",", "f\"expected 1 got {num_chosen} in {chosen_idx}\"", "\n", "assert", "chosen_idx", "[", "0", "]", "==", "target", "[", "1", "]", ",", "(", "\n", "\"expected \"", "\n", "+", "str", "(", "target", "[", "1", "]", ")", "\n", "+", "\" got \"", "\n", "+", "str", "(", "chosen_idx", "[", "0", "]", ")", "\n", "+", "\" from \"", "\n", "+", "str", "(", "chosen_idx", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_supervised_atagent_1.test": [[12, 99], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Variable", "lnn.Variable", "itertools.permutations", "list", "lnn.And", "lnn.Model.train", "len", "str", "str", "str", "lnn.ForAll", "subrules.append", "chosen_idx.append", "len", "lnn.Bidirectional", "str", "lnn.And", "model.add_predicates.", "model.add_predicates.", "model.add_predicates."], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Bidirectional", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["def", "test", "(", ")", ":", "\n", "# background data (features)", "\n", "    ", "B", "=", "{", "\n", "\"at-agent\"", ":", "[", "(", "\"cabinet\"", ",", ")", ",", "(", "\"wardrobe\"", ",", ")", ",", "(", "\"hanger\"", ",", ")", ",", "(", "\"ladderback chair\"", ",", ")", "]", ",", "\n", "\"in\"", ":", "[", "\n", "(", "\"cabinet\"", ",", "\"shoe\"", ")", ",", "\n", "(", "\"wardrobe\"", ",", "\"shirt\"", ")", ",", "\n", "(", "\"hanger\"", ",", "\"coat\"", ")", ",", "\n", "(", "\"ladderback chair\"", ",", "\"tuna\"", ")", ",", "\n", "]", ",", "\n", "}", "\n", "\n", "# positive (target) labels", "\n", "P", "=", "{", "\"take\"", ":", "[", "(", "\"shoe\"", ",", ")", ",", "(", "\"shirt\"", ",", ")", ",", "(", "\"coat\"", ",", ")", ",", "(", "\"tuna\"", ",", ")", "]", "}", "\n", "\n", "# Predicates:", "\n", "# ['at-agent(x)', 'at-agent(z)', 'in(x,z)', 'in(z,x)']", "\n", "\n", "# Subrule template:", "\n", "# take(x):- at-agent(*) \u2227 in(*, *) [x, z]", "\n", "\n", "# Learned rule:", "\n", "# take(x):- at-agent(z) \u2227 in(z, x)", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "at_agent", "=", "model", ".", "add_predicates", "(", "1", ",", "\"at-agent\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "in_", "=", "model", ".", "add_predicates", "(", "2", ",", "\"in\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "take", "=", "model", ".", "add_predicates", "(", "1", ",", "\"take\"", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"at-agent\"", ":", "{", "c", ":", "TRUE", "for", "c", "in", "B", "[", "\"at-agent\"", "]", "}", ",", "\n", "\"in\"", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "\"in\"", "]", "}", ",", "\n", "\"take\"", ":", "{", "c", ":", "TRUE", "for", "c", "in", "P", "[", "\"take\"", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "variables", "=", "[", "x", ",", "z", "]", "\n", "singles", "=", "[", "(", "x", ",", ")", ",", "(", "z", ",", ")", "]", "\n", "pairs", "=", "itertools", ".", "permutations", "(", "variables", ",", "2", ")", "# e.g. [(x, y), ...]", "\n", "pairs", "=", "list", "(", "pairs", ")", "\n", "\n", "neuron", "=", "{", "\"bias_learning\"", ":", "False", ",", "\"weights_learning\"", ":", "False", "}", "\n", "\n", "subrules", "=", "[", "]", "\n", "for", "single", "in", "singles", ":", "\n", "        ", "for", "pair", "in", "pairs", ":", "\n", "            ", "k", "=", "str", "(", "len", "(", "subrules", ")", ")", "\n", "model", "[", "k", "]", "=", "ForAll", "(", "\n", "Bidirectional", "(", "\n", "And", "(", "at_agent", "(", "*", "single", ")", ",", "in_", "(", "*", "pair", ")", ",", "neuron", "=", "neuron", ")", ",", "\n", "take", "(", "x", ")", ",", "\n", "neuron", "=", "neuron", ",", "\n", ")", ",", "\n", "fully_grounded", "=", "True", ",", "\n", ")", "\n", "subrules", ".", "append", "(", "model", "[", "k", "]", ")", "\n", "\n", "", "", "rule", "=", "model", "[", "\"rule\"", "]", "=", "And", "(", "\n", "*", "subrules", ",", "world", "=", "World", ".", "AXIOM", ",", "neuron", "=", "{", "\"bias_learning\"", ":", "False", "}", "\n", ")", "\n", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", "\n", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "chosen_idx", "=", "[", "]", "\n", "weighted_idx", "=", "(", "rule", ".", "neuron", ".", "weights", "==", "1", ")", ".", "nonzero", "(", "as_tuple", "=", "True", ")", "[", "0", "]", "\n", "for", "idx", "in", "weighted_idx", ":", "\n", "        ", "subrule_forall", "=", "rule", ".", "operands", "[", "idx", "]", "\n", "if", "subrule_forall", ".", "neuron", ".", "bounds_table", "[", "0", "]", "[", "0", "]", "==", "1", ":", "\n", "            ", "subrule_bidirectional", "=", "subrule_forall", ".", "operands", "[", "0", "]", "\n", "subrule_implication", "=", "subrule_bidirectional", ".", "Imp1", "\n", "subrule_and", "=", "subrule_implication", ".", "operands", "[", "0", "]", "\n", "subrule_and_vars", "=", "subrule_and", ".", "binding_str", "\n", "chosen_idx", ".", "append", "(", "subrule_and_vars", ")", "\n", "\n", "", "", "num_chosen", "=", "len", "(", "chosen_idx", ")", "\n", "assert", "num_chosen", "==", "1", ",", "\"expected 1 got \"", "+", "str", "(", "num_chosen", ")", "\n", "assert", "chosen_idx", "[", "0", "]", "==", "[", "\"z\"", ",", "\"z, x\"", "]", ",", "(", "\n", "\"expected \"", "+", "str", "(", "[", "\"z\"", ",", "\"z, x\"", "]", ")", "+", "\" got \"", "+", "str", "(", "chosen_idx", "[", "0", "]", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_bool_and_supervised_1.test": [[20, 60], ["lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Variable", "lnn.And", "lnn.Model.add_labels", "lnn.Model.train", "model[].state().values", "all", "p1", "p2", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.train", "home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.values", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "p1", ",", "p2", "=", "model", ".", "add_predicates", "(", "1", ",", "\"P1\"", ",", "\"P2\"", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "p1", ".", "name", ":", "{", "\"0\"", ":", "TRUE", ",", "\"1\"", ":", "TRUE", ",", "\"2\"", ":", "TRUE", ",", "\"3\"", ":", "TRUE", "}", ",", "\n", "p2", ".", "name", ":", "{", "\n", "\"0\"", ":", "TRUE", ",", "\n", "\"1\"", ":", "UNKNOWN", ",", "\n", "\"2\"", ":", "FALSE", ",", "\n", "\"3\"", ":", "FALSE", ",", "\n", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "p1", "(", "x", ")", ",", "p2", "(", "x", ")", ")", "\n", "model", ".", "add_labels", "(", "\n", "{", "\n", "\"AB\"", ":", "{", "\n", "\"0\"", ":", "TRUE", ",", "\n", "\"1\"", ":", "UNKNOWN", ",", "\n", "\"2\"", ":", "TRUE", ",", "\n", "\"3\"", ":", "FALSE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "parameter_history", "=", "{", "\"weights\"", ":", "True", ",", "\"bias\"", ":", "True", "}", "\n", "losses", "=", "[", "\"logical\"", ",", "\"supervised\"", "]", "\n", "total_loss", ",", "_", "=", "model", ".", "train", "(", "\n", "direction", "=", "UPWARD", ",", "losses", "=", "losses", ",", "parameter_history", "=", "parameter_history", "\n", ")", "\n", "\n", "predictions", "=", "model", "[", "p1", ".", "name", "]", ".", "state", "(", ")", ".", "values", "(", ")", "\n", "assert", "all", "(", "[", "fact", "is", "TRUE", "for", "fact", "in", "predictions", "]", ")", ",", "(", "\n", "\"expected AB Facts to all be TRUE, received bounds \"", "\n", "f\"{[p.name for p in predictions]}\"", "\n", ")", "\n", "\n", "return", "model", ",", "total_loss", ",", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_rv_and_2.test_and": [[11, 62], ["numpy.linspace", "numpy.meshgrid", "lnn.Variable", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.And", "range", "model[].upward", "range", "prediction[].item", "prediction[].item", "lnn.Model.add_facts", "float", "lnn.Model.add_labels", "model[].get_facts", "model[].get_labels", "round", "round", "max", "label.item"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_labels"], ["def", "test_and", "(", ")", ":", "\n", "    ", "\"\"\"FOL upward 2-input conjunction real value truth table\"\"\"", "\n", "\n", "samples", "=", "101", "\n", "steps", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "samples", ")", "\n", "x_grid", ",", "y_grid", "=", "np", ".", "meshgrid", "(", "steps", ",", "steps", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Predicate", "(", ")", "\n", "model", "[", "\"B\"", "]", "=", "Predicate", "(", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", "(", "x", ")", ",", "model", "[", "\"B\"", "]", "(", "x", ")", ")", "\n", "\n", "for", "row", "in", "range", "(", "samples", ")", ":", "\n", "        ", "for", "col", "in", "range", "(", "samples", ")", ":", "\n", "\n", "# inputs", "\n", "            ", "a", ",", "b", "=", "x_grid", "[", "row", "]", "[", "col", "]", ",", "y_grid", "[", "row", "]", "[", "col", "]", "\n", "\n", "# facts per model", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "{", "\n", "f\"({row}, {col})\"", ":", "(", "a", ",", "a", ")", ",", "\n", "}", ",", "\n", "\"B\"", ":", "{", "\n", "f\"({row}, {col})\"", ":", "(", "b", ",", "b", ")", ",", "\n", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# ground truth", "\n", "GT", "=", "float", "(", "max", "(", "0", ",", "a", "+", "b", "-", "1", ")", ")", "\n", "model", ".", "add_labels", "(", "{", "\"AB\"", ":", "{", "f\"({row}, {col})\"", ":", "(", "GT", ",", "GT", ")", "}", "}", ")", "\n", "\n", "# evaluate the conjunction", "\n", "", "", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "for", "g", "in", "model", "[", "\"AB\"", "]", ".", "groundings", ":", "\n", "        ", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "get_facts", "(", "g", ")", "[", "0", "]", "\n", "label", "=", "model", "[", "\"AB\"", "]", ".", "get_labels", "(", "g", ")", "[", "0", "]", "\n", "lower_bound", "=", "prediction", "[", "0", "]", ".", "item", "(", ")", "\n", "upper_bound", "=", "prediction", "[", "1", "]", ".", "item", "(", ")", "\n", "assert", "(", "\n", "lower_bound", "==", "upper_bound", "\n", ")", ",", "f\"Expected upper and lower bound to be the same but \\\n            got {lower_bound}, {upper_bound}\"", "\n", "assert", "round", "(", "lower_bound", ",", "4", ")", "==", "round", "(", "\n", "label", ".", "item", "(", ")", ",", "4", "\n", ")", ",", "f\"And({a}, {b}) expected {label}, but got {lower_bound}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_rv_and_2.test_or": [[64, 114], ["numpy.linspace", "numpy.meshgrid", "lnn.Variable", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Or", "range", "model[].upward", "range", "prediction[].item", "prediction[].item", "lnn.Model.add_facts", "float", "lnn.Model.add_labels", "model[].get_facts", "model[].get_labels", "round", "round", "min", "label.item"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Or", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_labels"], ["", "", "def", "test_or", "(", ")", ":", "\n", "    ", "\"\"\"FOL upward 2-input disjunction real value truth table\"\"\"", "\n", "\n", "samples", "=", "101", "\n", "steps", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "samples", ")", "\n", "x_grid", ",", "y_grid", "=", "np", ".", "meshgrid", "(", "steps", ",", "steps", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Predicate", "(", ")", "\n", "model", "[", "\"B\"", "]", "=", "Predicate", "(", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Or", "(", "model", "[", "\"A\"", "]", "(", "x", ")", ",", "model", "[", "\"B\"", "]", "(", "x", ")", ")", "\n", "\n", "for", "row", "in", "range", "(", "samples", ")", ":", "\n", "        ", "for", "col", "in", "range", "(", "samples", ")", ":", "\n", "# inputs", "\n", "            ", "a", ",", "b", "=", "x_grid", "[", "row", "]", "[", "col", "]", ",", "y_grid", "[", "row", "]", "[", "col", "]", "\n", "\n", "# facts per model", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "{", "\n", "f\"({row}, {col})\"", ":", "(", "a", ",", "a", ")", ",", "\n", "}", ",", "\n", "\"B\"", ":", "{", "\n", "f\"({row}, {col})\"", ":", "(", "b", ",", "b", ")", ",", "\n", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# ground truth", "\n", "GT", "=", "float", "(", "min", "(", "1", ",", "a", "+", "b", ")", ")", "\n", "model", ".", "add_labels", "(", "{", "\"AB\"", ":", "{", "f\"({row}, {col})\"", ":", "(", "GT", ",", "GT", ")", "}", "}", ")", "\n", "\n", "# evaluate the conjunction", "\n", "", "", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "for", "g", "in", "model", "[", "\"AB\"", "]", ".", "groundings", ":", "\n", "        ", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "get_facts", "(", "g", ")", "[", "0", "]", "\n", "label", "=", "model", "[", "\"AB\"", "]", ".", "get_labels", "(", "g", ")", "[", "0", "]", "\n", "lower_bound", "=", "prediction", "[", "0", "]", ".", "item", "(", ")", "\n", "upper_bound", "=", "prediction", "[", "1", "]", ".", "item", "(", ")", "\n", "assert", "(", "\n", "lower_bound", "==", "upper_bound", "\n", ")", ",", "f\"Expected upper and lower bound to be the same but \\\n                got {lower_bound}, {upper_bound}\"", "\n", "assert", "round", "(", "lower_bound", ",", "4", ")", "==", "round", "(", "\n", "label", ".", "item", "(", ")", ",", "4", "\n", ")", ",", "f\"And({a}, {b}) expected {label}, but got {lower_bound}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_rv_and_2.test_implies": [[116, 166], ["numpy.linspace", "numpy.meshgrid", "lnn.Variable", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Implies", "range", "model[].upward", "range", "prediction[].item", "prediction[].item", "lnn.Model.add_facts", "float", "lnn.Model.add_labels", "model[].get_facts", "model[].get_labels", "round", "round", "min", "label.item"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_labels", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.get_labels"], ["", "", "def", "test_implies", "(", ")", ":", "\n", "    ", "\"\"\"FOL upward 2-input implies real value truth table\"\"\"", "\n", "\n", "samples", "=", "101", "\n", "steps", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "samples", ")", "\n", "x_grid", ",", "y_grid", "=", "np", ".", "meshgrid", "(", "steps", ",", "steps", ")", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"A\"", "]", "=", "Predicate", "(", ")", "\n", "model", "[", "\"B\"", "]", "=", "Predicate", "(", ")", "\n", "model", "[", "\"AB\"", "]", "=", "Implies", "(", "model", "[", "\"A\"", "]", "(", "x", ")", ",", "model", "[", "\"B\"", "]", "(", "x", ")", ")", "\n", "\n", "for", "row", "in", "range", "(", "samples", ")", ":", "\n", "        ", "for", "col", "in", "range", "(", "samples", ")", ":", "\n", "# inputs", "\n", "            ", "a", ",", "b", "=", "x_grid", "[", "row", "]", "[", "col", "]", ",", "y_grid", "[", "row", "]", "[", "col", "]", "\n", "\n", "# facts per model", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "{", "\n", "f\"({row}, {col})\"", ":", "(", "a", ",", "a", ")", ",", "\n", "}", ",", "\n", "\"B\"", ":", "{", "\n", "f\"({row}, {col})\"", ":", "(", "b", ",", "b", ")", ",", "\n", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "# ground truth", "\n", "GT", "=", "float", "(", "min", "(", "1", ",", "1", "-", "a", "+", "b", ")", ")", "\n", "model", ".", "add_labels", "(", "{", "\"AB\"", ":", "{", "f\"({row}, {col})\"", ":", "(", "GT", ",", "GT", ")", "}", "}", ")", "\n", "\n", "# evaluate the conjunction", "\n", "", "", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "for", "g", "in", "model", "[", "\"AB\"", "]", ".", "groundings", ":", "\n", "        ", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "get_facts", "(", "g", ")", "[", "0", "]", "\n", "label", "=", "model", "[", "\"AB\"", "]", ".", "get_labels", "(", "g", ")", "[", "0", "]", "\n", "lower_bound", "=", "prediction", "[", "0", "]", ".", "item", "(", ")", "\n", "upper_bound", "=", "prediction", "[", "1", "]", ".", "item", "(", ")", "\n", "assert", "(", "\n", "lower_bound", "==", "upper_bound", "\n", ")", ",", "f\"Expected upper and lower bound to be the same but \\\n                got {lower_bound}, {upper_bound}\"", "\n", "assert", "round", "(", "lower_bound", ",", "4", ")", "==", "round", "(", "\n", "label", ".", "item", "(", ")", ",", "4", "\n", ")", ",", "f\"And({a}, {b}) expected {label}, but got {lower_bound}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_quantifier_free_var.test_1": [[10, 36], ["map", "lnn.Model", "lnn.Model.add_predicates", "lnn.Exists", "lnn.Model.add_facts", "lnn.Model.upward", "model.add_predicates.", "set"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"Quantifier with free variables, upward on predicate\"\"\"", "\n", "p", ",", "c", "=", "map", "(", "Variable", ",", "(", "\"dbo:Person\"", ",", "\"dbo:City\"", ")", ")", "\n", "model", "=", "Model", "(", ")", "\n", "mayor", "=", "model", ".", "add_predicates", "(", "2", ",", "\"dbo:Mayor\"", ")", "\n", "\n", "# List all the mayors of Boston", "\n", "Some", "=", "model", "[", "\"Some\"", "]", "=", "Exists", "(", "p", ",", "mayor", "(", "p", ",", "c", ")", ")", "\n", "\n", "GT", "=", "[", "\"dbr:Marty_Walsh_(politician)\"", ",", "\"dbr:Lori_Lightfoot\"", "]", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "mayor", ".", "name", ":", "{", "\n", "(", "\"dbr:Kim_Janey\"", ",", "\"dbr:Boston\"", ")", ":", "UNKNOWN", ",", "\n", "(", "GT", "[", "0", "]", ",", "\"dbr:Boston\"", ")", ":", "TRUE", ",", "\n", "(", "\"dbr:Tishaura_Jones\"", ",", "\"dbr:St._Louis\"", ")", ":", "UNKNOWN", ",", "\n", "(", "GT", "[", "1", "]", ",", "\"dbr:Chicago\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "assert", "Some", ".", "true_groundings", "==", "set", "(", "\n", "GT", "\n", ")", ",", "f\"expected True groundings to be {GT}, received {Some.true_groundings}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_quantifier_free_var.test_2": [[38, 74], ["map", "lnn.Model", "lnn.Model.add_predicates", "lnn.Exists", "lnn.Model.add_facts", "lnn.Model.upward", "model.add_predicates.", "set", "set"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward"], ["", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"Quantifier with free variables, upward on predicate\n    UNKNOWN result when not fully grounded\n    \"\"\"", "\n", "p", ",", "c", "=", "map", "(", "Variable", ",", "(", "\"dbo:Person\"", ",", "\"dbo:City\"", ")", ")", "\n", "model", "=", "Model", "(", ")", "\n", "mayor", "=", "model", ".", "add_predicates", "(", "2", ",", "\"dbo:Mayor\"", ")", "\n", "\n", "# List all the mayors of Boston", "\n", "Some", "=", "model", "[", "\"Some\"", "]", "=", "Exists", "(", "p", ",", "mayor", "(", "p", ",", "(", "c", ",", "[", "\"dbr:Chicago\"", ",", "\"dbr:Boston\"", "]", ")", ")", ")", "\n", "\n", "GT_truth", "=", "[", "\"dbr:Marty_Walsh_(politician)\"", "]", "\n", "GT_bindings", "=", "[", "\n", "(", "\"dbr:Lori_Lightfoot\"", ",", "\"dbr:Chicago\"", ")", ",", "\n", "(", "\"dbr:Kim_Janey\"", ",", "\"dbr:Boston\"", ")", ",", "\n", "(", "GT_truth", "[", "0", "]", ",", "\"dbr:Boston\"", ")", ",", "\n", "]", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "mayor", ".", "name", ":", "{", "\n", "GT_bindings", "[", "0", "]", ":", "UNKNOWN", ",", "\n", "GT_bindings", "[", "1", "]", ":", "UNKNOWN", ",", "\n", "(", "\"dbr:Tishaura_Jones\"", ",", "\"dbr:St._Louis\"", ")", ":", "UNKNOWN", ",", "\n", "GT_bindings", "[", "2", "]", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "assert", "Some", ".", "groundings", "==", "set", "(", "GT_bindings", ")", ",", "(", "\n", "f\"expected groundings to be bound to GT bindings {GT_bindings}, \"", "\n", "f\"received {Some.groundings}\"", "\n", ")", "\n", "assert", "Some", ".", "true_groundings", "==", "set", "(", "GT_truth", ")", ",", "(", "\n", "f\"expected True groundings to be {GT_truth}, \"", "\n", "f\"received {Some.true_groundings}\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_quantifier_free_var.test_3": [[78, 98], ["lnn.Variable", "lnn.Model", "lnn.Model.add_predicates", "lnn.ForAll", "lnn.Exists", "lnn.Model.add_facts", "lnn.Model.upward", "A", "S", "lnn.Exists.state", "lnn.ForAll.state", "lnn.Exists.state", "lnn.ForAll.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_3", "(", ")", ":", "\n", "    ", "\"\"\"Quantifier with free variables, upward on predicate\n    Single predicate truth updates quantifier truth\n    \"\"\"", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "=", "Model", "(", ")", "\n", "A", ",", "S", "=", "model", ".", "add_predicates", "(", "1", ",", "\"A\"", ",", "\"S\"", ")", "\n", "All", "=", "model", "[", "\"All\"", "]", "=", "ForAll", "(", "x", ",", "A", "(", "x", ")", ")", "\n", "Some", "=", "model", "[", "\"Some\"", "]", "=", "Exists", "(", "x", ",", "S", "(", "x", ")", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "{", "\"0\"", ":", "TRUE", ",", "\"1\"", ":", "TRUE", ",", "\"2\"", ":", "FALSE", "}", ",", "\n", "\"S\"", ":", "{", "\"0\"", ":", "FALSE", ",", "\"1\"", ":", "FALSE", ",", "\"2\"", ":", "TRUE", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "assert", "Some", ".", "state", "(", ")", "is", "TRUE", ",", "f\"ForAll expected as TRUE, received {Some.state()}\"", "\n", "assert", "All", ".", "state", "(", ")", "is", "FALSE", ",", "f\"Exists expected as FALSE, received {All.state()}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_square_rectangle.test_1": [[10, 49], ["lnn.Variable", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.ForAll", "lnn.ForAll", "lnn.Exists", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "lnn.Model.infer", "dict", "all", "lnn.Implies", "lnn.Implies", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"Simple theorem proving example\n    Square(c)\n    Square(k)\n\n    \"\"\"", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "square", "=", "Predicate", "(", "name", "=", "\"square\"", ")", "\n", "rectangle", "=", "Predicate", "(", "name", "=", "\"rectangle\"", ")", "\n", "foursides", "=", "Predicate", "(", "name", "=", "\"foursides\"", ")", "\n", "square_rect", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "square", "(", "x", ")", ",", "rectangle", "(", "x", ")", ",", "name", "=", "\"square-rect\"", ")", ",", "\n", "name", "=", "\"all-square-rect\"", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "rect_foursides", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "rectangle", "(", "x", ")", ",", "foursides", "(", "x", ")", ",", "name", "=", "\"rect-foursides\"", ")", ",", "\n", "name", "=", "\"all-rect-foursides\"", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "query", "=", "Exists", "(", "x", ",", "foursides", "(", "x", ")", ",", "name", "=", "\"foursided_objects\"", ")", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "square", ",", "rectangle", ",", "square_rect", ",", "rect_foursides", ",", "query", ")", "\n", "model", ".", "add_facts", "(", "{", "\"square\"", ":", "{", "\"c\"", ":", "Fact", ".", "TRUE", ",", "\"k\"", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "steps", ",", "facts_inferred", "=", "model", ".", "infer", "(", ")", "\n", "\n", "# Currently finishes in 4 inference steps", "\n", "assert", "steps", "==", "4", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "GT_o", "=", "dict", "(", "[", "(", "(", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "(", "(", "\"k\"", ")", ",", "Fact", ".", "TRUE", ")", "]", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"foursided_objects\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_quantifier_bound_var.test_1": [[10, 35], ["lnn.Variable", "lnn.Model", "lnn.Model.add_predicates", "lnn.ForAll", "lnn.Exists", "lnn.Model.add_facts", "lnn.Model.upward", "A", "S", "lnn.ForAll.state", "lnn.Exists.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"Quantifier with bounded variables, upward on predicate\n    UNKNOWN result when not fully grounded\n    \"\"\"", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "=", "Model", "(", ")", "\n", "A", ",", "S", "=", "model", ".", "add_predicates", "(", "1", ",", "\"A\"", ",", "\"S\"", ")", "\n", "All", "=", "model", "[", "\"All\"", "]", "=", "ForAll", "(", "x", ",", "A", "(", "x", ")", ")", "\n", "Some", "=", "model", "[", "\"Some\"", "]", "=", "Exists", "(", "x", ",", "S", "(", "x", ")", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "{", "\"0\"", ":", "TRUE", ",", "\"1\"", ":", "TRUE", ",", "\"2\"", ":", "TRUE", "}", ",", "\n", "\"S\"", ":", "{", "\"0\"", ":", "FALSE", ",", "\"1\"", ":", "FALSE", ",", "\"2\"", ":", "FALSE", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "predictions", "=", "[", "All", ".", "state", "(", ")", ",", "Some", ".", "state", "(", ")", "]", "\n", "assert", "predictions", "[", "0", "]", "is", "UNKNOWN", ",", "(", "\n", "f\"ForAll expected as UNKNOWN, received {predictions[0]}\"", "\n", "\"cannot learn to be TRUE unless fully grounded\"", "\n", ")", "\n", "assert", "predictions", "[", "1", "]", "is", "UNKNOWN", ",", "(", "\n", "f\"Exists expected as UNKNOWN, received {predictions[1]}\"", "\n", "\"cannot learn to be FALSE unless fully grounded\"", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_quantifier_bound_var.test_2": [[39, 59], ["lnn.Variable", "lnn.Model", "lnn.Model.add_predicates", "lnn.ForAll", "lnn.Exists", "lnn.Model.add_facts", "lnn.Model.upward", "A", "S", "lnn.Exists.state", "lnn.ForAll.state", "lnn.Exists.state", "lnn.ForAll.state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"Quantifier with bounded variables, upward on predicate\n    Single predicate truth updates quantifier truth\n    \"\"\"", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "model", "=", "Model", "(", ")", "\n", "A", ",", "S", "=", "model", ".", "add_predicates", "(", "1", ",", "\"A\"", ",", "\"S\"", ")", "\n", "All", "=", "model", "[", "\"All\"", "]", "=", "ForAll", "(", "x", ",", "A", "(", "x", ")", ")", "\n", "Some", "=", "model", "[", "\"Some\"", "]", "=", "Exists", "(", "x", ",", "S", "(", "x", ")", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"A\"", ":", "{", "\"0\"", ":", "TRUE", ",", "\"1\"", ":", "TRUE", ",", "\"2\"", ":", "FALSE", "}", ",", "\n", "\"S\"", ":", "{", "\"0\"", ":", "FALSE", ",", "\"1\"", ":", "FALSE", ",", "\"2\"", ":", "TRUE", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "assert", "Some", ".", "state", "(", ")", "is", "TRUE", ",", "f\"ForAll expected as TRUE, received {Some.state()}\"", "\n", "assert", "All", ".", "state", "(", ")", "is", "FALSE", ",", "f\"Exists expected as FALSE, received {All.state()}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.fol.test_american.test_1": [[21, 111], ["map", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.ForAll", "lnn.ForAll", "lnn.ForAll", "lnn.ForAll", "lnn.Exists", "lnn.Model.add_facts", "lnn.Model.infer", "dict", "all", "lnn.Implies", "lnn.Implies", "lnn.Implies", "lnn.Implies", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.And", "lnn.Predicate.", "lnn.And", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"The 'American' theorem proving example\"\"\"", "\n", "\n", "x", ",", "y", ",", "z", ",", "w", "=", "map", "(", "Variable", ",", "[", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\"w\"", "]", ")", "\n", "model", "=", "Model", "(", ")", "# Instantiate a model.", "\n", "\n", "# Define and add predicates to the model.", "\n", "owns", "=", "model", "[", "\"owns\"", "]", "=", "Predicate", "(", "arity", "=", "2", ",", "name", "=", "\"owns\"", ")", "\n", "missile", "=", "model", "[", "\"missile\"", "]", "=", "Predicate", "(", "\"missile\"", ")", "\n", "american", "=", "model", "[", "\"american\"", "]", "=", "Predicate", "(", "\"american\"", ")", "\n", "enemy", "=", "model", "[", "\"enemy\"", "]", "=", "Predicate", "(", "arity", "=", "2", ",", "name", "=", "\"enemy\"", ")", "\n", "hostile", "=", "model", "[", "\"hostile\"", "]", "=", "Predicate", "(", "\"hostile\"", ")", "\n", "criminal", "=", "model", "[", "\"criminal\"", "]", "=", "Predicate", "(", "\"criminal\"", ")", "\n", "weapon", "=", "model", "[", "\"weapon\"", "]", "=", "Predicate", "(", "\"weapon\"", ")", "\n", "sells", "=", "model", "[", "\"sells\"", "]", "=", "Predicate", "(", "arity", "=", "3", ",", "name", "=", "\"sells\"", ")", "\n", "\n", "# Define and add the background knowledge to  the model.", "\n", "model", "[", "\"america-enemies\"", "]", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "\n", "enemy", "(", "x", ",", "(", "y", ",", "\"America\"", ")", ")", ",", "hostile", "(", "x", ")", ",", "name", "=", "\"enemy->hostile\"", ",", "join", "=", "Join", ".", "OUTER", "\n", ")", ",", "\n", "name", "=", "\"america-enemies\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", "[", "\"crime\"", "]", "=", "ForAll", "(", "\n", "x", ",", "\n", "y", ",", "\n", "z", ",", "\n", "Implies", "(", "\n", "And", "(", "\n", "american", "(", "x", ")", ",", "\n", "weapon", "(", "y", ")", ",", "\n", "sells", "(", "x", ",", "y", ",", "z", ")", ",", "\n", "hostile", "(", "z", ")", ",", "\n", "name", "=", "\"american-to-hostile\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", ")", ",", "\n", "criminal", "(", "x", ")", ",", "\n", "name", "=", "\"implies-criminal\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", ")", ",", "\n", "name", "=", "\"crime\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", "[", "\"nono_missiles_byWest\"", "]", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "\n", "And", "(", "missile", "(", "x", ")", ",", "owns", "(", "(", "y", ",", "\"Nono\"", ")", ",", "x", ")", ",", "name", "=", "\"nono-missile\"", ",", "join", "=", "Join", ".", "OUTER", ")", ",", "\n", "sells", "(", "(", "z", ",", "\"West\"", ")", ",", "x", ",", "(", "y", ",", "\"Nono\"", ")", ")", ",", "\n", "name", "=", "\"West-to-Nono\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", ")", ",", "\n", "name", "=", "\"nono_missiles_byWest\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "model", "[", "\"missiles-are-weapons\"", "]", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "missile", "(", "x", ")", ",", "weapon", "(", "x", ")", ",", "name", "=", "\"missile-weapon\"", ",", "join", "=", "Join", ".", "OUTER", ")", ",", "\n", "name", "=", "\"missiles-are-weapons\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "\n", "# Define queries", "\n", "model", "[", "\"query\"", "]", "=", "Exists", "(", "x", ",", "criminal", "(", "x", ")", ",", "name", "=", "\"who-is-criminal\"", ",", "join", "=", "Join", ".", "OUTER", ")", "\n", "\n", "# Add facts to model.", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"owns\"", ":", "{", "(", "\"Nono\"", ",", "\"M1\"", ")", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"missile\"", ":", "{", "\"M1\"", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"american\"", ":", "{", "\"West\"", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"enemy\"", ":", "{", "(", "\"Nono\"", ",", "\"America\"", ")", ":", "Fact", ".", "TRUE", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "steps", ",", "facts_inferred", "=", "model", ".", "infer", "(", ")", "\n", "\n", "# Currently finishes in 5 inference steps", "\n", "assert", "steps", "==", "5", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "GT_o", "=", "dict", "(", "[", "(", "(", "\"West\"", ")", ",", "Fact", ".", "TRUE", ")", "]", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"query\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_2.test": [[13, 49], ["lnn.truth_table", "lnn.Model", "lnn.Variable", "range", "lnn.And", "range", "model[].upward", "range", "print", "functools.reduce", "lnn.Predicate", "lnn.Model.add_facts", "len", "model[].state", "map", "str", "lnn.bool_to_fact", "range", "enumerate"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], ["def", "test", "(", ")", ":", "\n", "    ", "\"\"\"Unittest for upward 3-input boolean truth table\"\"\"", "\n", "\n", "TT", "=", "truth_table", "(", "3", ")", "\n", "\n", "# define the rules", "\n", "A", "=", "Proposition", "(", "\"A\"", ")", "\n", "B", "=", "Proposition", "(", "\"B\"", ")", "\n", "C", "=", "Proposition", "(", "\"C\"", ")", "\n", "A_B_C", "=", "And", "(", "A", ",", "B", ",", "C", ",", "name", "=", "\"A_B_C\"", ")", "\n", "\n", "formulae", "=", "[", "A_B_C", "]", "\n", "\n", "for", "row", "in", "TT", ":", "\n", "# ground truth", "\n", "        ", "GT", "=", "reduce", "(", "np", ".", "logical_and", ",", "map", "(", "fact_to_bool", ",", "row", ")", ")", "\n", "\n", "# facts per model", "\n", "facts", "=", "{", "\"A\"", ":", "row", "[", "0", "]", ",", "\"B\"", ":", "row", "[", "1", "]", ",", "\"C\"", ":", "row", "[", "2", "]", "}", "\n", "\n", "# load data into a new model", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "*", "formulae", ")", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "\n", "# evaluate the conjunction", "\n", "model", "[", "\"A_B_C\"", "]", ".", "upward", "(", ")", "\n", "\n", "# test the prediction", "\n", "prediction", "=", "model", "[", "\"A_B_C\"", "]", ".", "state", "(", ")", "\n", "assert", "prediction", "is", "bool_to_fact", "(", "\n", "GT", "\n", ")", ",", "f\"And{row} expected {bool_to_fact(GT)}, received {prediction}\"", "\n", "model", ".", "flush", "(", ")", "\n", "", "print", "(", "\"success\"", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_ilp_and_implies_1.test_1": [[10, 63], ["dict", "dict", "zip", "lnn.Variable", "lnn.Variable", "lnn.Variable", "lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.And", "lnn.Model.infer", "all", "model.add_predicates.", "model.add_predicates.", "len", "len", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"\n    And(isFather(x,z),isFather(z,y))\n    Using expanded outer joins\n    Closed World Assumption on isFather\n    \"\"\"", "\n", "\n", "GT_i", "=", "{", "(", "\"a\"", ",", "\"b\"", ",", "\"c\"", ")", ":", "Fact", ".", "TRUE", "}", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"a\"", ",", "\"b\"", ",", "\"b\"", ")", ",", "Fact", ".", "FALSE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"b\"", ",", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"c\"", ",", "\"b\"", ")", ",", "Fact", ".", "FALSE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"a\"", ",", "\"b\"", ")", ",", "Fact", ".", "FALSE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"c\"", ",", "\"c\"", ")", ",", "Fact", ".", "FALSE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"b\"", ",", "\"c\"", ")", ",", "Fact", ".", "FALSE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"a\"", ",", "\"b\"", ")", ",", "Fact", ".", "FALSE", ")", ",", "\n", "]", "\n", ")", "\n", "GT_op", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"a\"", ",", "\"b\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"b\"", ",", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"c\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"a\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"c\"", ",", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"b\"", ",", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"a\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "for", "join", ",", "GT", "in", "zip", "(", "[", "Join", ".", "INNER", ",", "Join", ".", "OUTER", "]", ",", "[", "GT_i", ",", "GT_o", ",", "GT_op", "]", ")", ":", "\n", "\n", "# background data (features)", "\n", "        ", "B", "=", "[", "\"isFather\"", ",", "[", "(", "\"a\"", ",", "\"b\"", ")", ",", "(", "\"b\"", ",", "\"c\"", ")", "]", "]", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "vars1", "=", "(", "x", ",", "z", ")", "\n", "vars2", "=", "(", "z", ",", "y", ")", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "b", "=", "model", ".", "add_predicates", "(", "2", ",", "B", "[", "0", "]", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "model", ".", "add_facts", "(", "{", "b", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "1", "]", "}", "}", ")", "\n", "\n", "model", "[", "\"rule\"", "]", "=", "And", "(", "b", "(", "*", "vars1", ")", ",", "b", "(", "*", "vars2", ")", ",", "join", "=", "join", ")", "\n", "\n", "model", ".", "infer", "(", "direction", "=", "UPWARD", ")", "\n", "\n", "assert", "all", "(", "[", "model", "[", "\"rule\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"rule\"", "]", ".", "groundings", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_ilp_and_implies_1.test_2": [[65, 117], ["dict", "zip", "lnn.Variable", "lnn.Variable", "lnn.Variable", "lnn.Model", "lnn.Model.add_predicates", "lnn.Model.add_facts", "lnn.Implies", "lnn.Model.infer", "all", "p", "lnn.And", "len", "len", "b", "b", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_predicates", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.propositional.test_inference_rules.p", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["", "", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"\n    Implies(isGrandFather(x,y),And(isFather(x,z),isFather(z,y))\n    Using expanded outer joins\n    Closed World Assumption on isFather and isGrandFather\n    \"\"\"", "\n", "GT_i", "=", "{", "(", "\"a\"", ",", "\"c\"", ",", "\"b\"", ")", ":", "Fact", ".", "TRUE", "}", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"a\"", ",", "\"b\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"b\"", ",", "\"a\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"c\"", ",", "\"a\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"c\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"b\"", ",", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"c\"", ",", "\"c\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"a\"", ",", "\"c\"", ",", "\"c\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"b\"", ",", "\"a\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"b\"", ",", "\"c\"", ",", "\"b\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", ",", "\n", ")", "\n", "\n", "for", "join", ",", "GT", "in", "zip", "(", "[", "Join", ".", "INNER", ",", "Join", ".", "OUTER", "]", ",", "[", "GT_i", ",", "GT_o", "]", ")", ":", "\n", "# background data (features)", "\n", "        ", "B", "=", "[", "\"isFather\"", ",", "[", "(", "\"a\"", ",", "\"b\"", ")", ",", "(", "\"b\"", ",", "\"c\"", ")", "]", "]", "\n", "\n", "# positive (target) labels for isGrandFather(x,y)", "\n", "P1", "=", "[", "\"isGrandFather\"", ",", "[", "(", "\"a\"", ",", "\"c\"", ")", "]", "]", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "vars1", "=", "(", "x", ",", "z", ")", "\n", "vars2", "=", "(", "z", ",", "y", ")", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "b", ",", "p", "=", "model", ".", "add_predicates", "(", "2", ",", "B", "[", "0", "]", ",", "P1", "[", "0", "]", ",", "world", "=", "World", ".", "FALSE", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "b", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "B", "[", "1", "]", "}", ",", "\n", "p", ".", "name", ":", "{", "pair", ":", "TRUE", "for", "pair", "in", "P1", "[", "1", "]", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"rule\"", "]", "=", "Implies", "(", "\n", "p", "(", "x", ",", "y", ")", ",", "And", "(", "b", "(", "*", "vars1", ")", ",", "b", "(", "*", "vars2", ")", ",", "join", "=", "join", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "model", ".", "infer", "(", "direction", "=", "UPWARD", ")", "\n", "\n", "assert", "all", "(", "[", "model", "[", "\"rule\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"rule\"", "]", ".", "groundings", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_binding_1.test": [[10, 124], ["lnn.Model", "map", "lnn.Predicate", "dict", "lnn.Model.add_facts", "lnn.Predicate", "dict", "lnn.Model.add_facts", "lnn.And", "model[].upward", "lnn.And", "model[].upward", "lnn.And", "model[].upward", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward"], ["def", "test", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ")", ")", "\n", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "p2_facts", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"s1\"", ",", "\"s7\"", ")", ",", "TRUE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s6\"", ")", ",", "TRUE", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s3\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s4\"", ",", "\"s6\"", ")", ",", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2\"", ":", "p2_facts", "}", ")", "\n", "\n", "model", "[", "\"p2a\"", "]", "=", "Predicate", "(", "\"p2a\"", ",", "arity", "=", "2", ")", "\n", "p2a_facts", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"s1\"", ",", "\"s7\"", ")", ",", "TRUE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s5\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s4\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s3\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s7\"", ",", "\"s6\"", ")", ",", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2a\"", ":", "p2a_facts", "}", ")", "\n", "\n", "# the unbounded case", "\n", "model", "[", "\"p2_and_p2a\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "x", ",", "y", ")", ")", "\n", "# GT = dict([", "\n", "#    (('s1', 's7'), TRUE),", "\n", "#    (('s1', 's6'), FALSE),", "\n", "#    (('s3', 's7'), FALSE),", "\n", "#    (('s2', 's6'), FALSE),", "\n", "#    (('s4', 's6'), UNKNOWN),", "\n", "#    (('s2', 's5'), FALSE),", "\n", "#    (('s4', 's7'), FALSE),", "\n", "#     (('s7', 's6'), UNKNOWN)])", "\n", "\n", "model", "[", "\"p2_and_p2a\"", "]", ".", "upward", "(", ")", "\n", "# assert all([model['p2_and_p2a'].state(groundings=g) is GT[g]", "\n", "#            for g in GT]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['p2_and_p2a'].state()) == len(GT), \"FAILED \ud83d\ude14\"", "\n", "\n", "# One variable bound", "\n", "model", "[", "\"p2_and_p2b\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "x", ",", "(", "y", ",", "\"s7\"", ")", ")", ")", "\n", "# GT = dict([", "\n", "#    (('s1', 's7'), TRUE),", "\n", "#    (('s3', 's7'), FALSE),", "\n", "#    (('s4', 's7'), FALSE)])", "\n", "\n", "model", "[", "\"p2_and_p2b\"", "]", ".", "upward", "(", ")", "\n", "# assert all([model['p2_and_p2b'].state(groundings=g) is GT[g]", "\n", "#            for g in GT]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['p2_and_p2b'].state()) == len(GT), \"FAILED \ud83d\ude14\"", "\n", "\n", "# One variable bound to a list", "\n", "model", "[", "\"p2_and_p2c\"", "]", "=", "And", "(", "\n", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "(", "x", ",", "[", "\"s1\"", ",", "\"s2\"", "]", ")", ",", "(", "y", ",", "\"s6\"", ")", ")", "\n", ")", "\n", "\n", "# GT = dict([", "\n", "#    (('s1', 's6'), FALSE),", "\n", "#    (('s2', 's6'), FALSE)])", "\n", "model", "[", "\"p2_and_p2c\"", "]", ".", "upward", "(", ")", "\n", "# assert all([model['p2_and_p2c'].state(groundings=g) is GT[g]", "\n", "#            for g in GT]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['p2_and_p2c'].state()) == len(GT), \"FAILED \ud83d\ude14\"", "\n", "\n", "# 1 variable vs 2 variables bound", "\n", "model", "[", "\"p1\"", "]", "=", "Predicate", "(", "\"p1\"", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"p1\"", ":", "{", "\"s1\"", ":", "TRUE", ",", "\"s2\"", ":", "TRUE", ",", "\"s3\"", ":", "TRUE", ",", "\"s4\"", ":", "FALSE", ",", "\"s10\"", ":", "FALSE", "}", "}", "\n", ")", "\n", "model", "[", "\"p1_and_p2\"", "]", "=", "And", "(", "model", "[", "\"p1\"", "]", "(", "(", "x", ",", "[", "\"s1\"", ",", "\"s2\"", "]", ")", ")", ",", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ")", "\n", "model", "[", "\"p1_and_p2\"", "]", ".", "upward", "(", ")", "\n", "# GT = dict([", "\n", "#    (('s1', 's6'), TRUE),", "\n", "#    (('s2', 's6'), FALSE),", "\n", "#    (('s1', 's7'), TRUE),", "\n", "#    (('s2', 's5'), UNKNOWN)])", "\n", "# assert all([model['p1_and_p2'].state(groundings=g) is GT[g]", "\n", "#            for g in GT]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['p1_and_p2'].state()) == len(GT), \"FAILED \ud83d\ude14\"", "\n", "\n", "# 2 variable vs 3 variables bound", "\n", "model", "[", "\"p3\"", "]", "=", "Predicate", "(", "\"p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p3\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s5\"", ",", "\"s3\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s4\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s8\"", ",", "\"s3\"", ")", ":", "FALSE", ",", "\n", "(", "\"s2\"", ",", "\"s8\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ",", "\"s8\"", ")", ":", "FALSE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p3\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p3\"", "]", "(", "x", ",", "(", "z", ",", "\"s4\"", ")", ",", "y", ")", ")", "\n", "model", "[", "\"p2_and_p3\"", "]", ".", "upward", "(", ")", "\n", "# GT = dict([", "\n", "#    (('s1', 's7', 's4'), TRUE)])", "\n", "# assert all([model['p2_and_p3'].state(groundings=g) is GT[g]", "\n", "#            for g in GT]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['p2_and_p3'].state()) == len(GT), \"FAILED \ud83d\ude14\"", "\n", "\n", "# 2 variable vs 2 variable reversed, bound", "\n", "model", "[", "\"p2r\"", "]", "=", "Predicate", "(", "\"p2r\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2r\"", ":", "{", "(", "\"s6\"", ",", "\"s2\"", ")", ":", "TRUE", ",", "(", "\"s7\"", ",", "\"s1\"", ")", ":", "FALSE", "}", "}", ")", "\n", "model", "[", "\"p2_and_p2r\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2r\"", "]", "(", "(", "y", ",", "[", "\"s7\"", ",", "\"s3\"", "]", ")", ",", "x", ")", ")", "\n", "model", "[", "\"p2_and_p2r\"", "]", ".", "upward", "(", ")", "\n", "# GT = dict([", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_njoin_outer_1.test": [[10, 224], ["lnn.Model", "map", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "dict", "lnn.And", "model[].upward", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "dict", "lnn.And", "model[].upward", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "join", "=", "Join", ".", "OUTER", "\n", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", ",", "a", ",", "b", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\"a\"", ",", "\"b\"", ")", ")", "\n", "\n", "# TEST 1", "\n", "\n", "# This is the normal 2 var vs 2 var ; should go thru the memory join", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x2\"", ",", "\"y2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"p2a\"", "]", "=", "Predicate", "(", "\"p2a\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2a\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y3\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "# print(\"Predicates before outer Join\")", "\n", "# model['p2'].print()", "\n", "# model['p2a'].print()", "\n", "\n", "# GT_i = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p2a\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", ")", "\n", "model", "[", "\"p2_and_p2a\"", "]", ".", "upward", "(", ")", "\n", "\n", "# print(\"Predicates After Join\")", "\n", "# model['p2'].print()", "\n", "# model['p2a'].print()", "\n", "# model['p2_and_p2a'].print()", "\n", "\n", "# for g in GT_o :", "\n", "#    print(g, model['p2_and_p2a'].state(groundings=g), GT_o[g])", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 2", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "upward", "(", ")", "\n", "# model['t2_p3_and_t2_p2'].print()", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 3", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "model", "[", "\"t3_p1\"", "]", "=", "Predicate", "(", "\"t3_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t3_p1\"", ":", "{", "(", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"z4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t3_p1\"", "]", "(", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "upward", "(", ")", "\n", "# model['t2_p3_and_t2_p2_t3_p1'].print()", "\n", "\n", "# GT_inner = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "# for g in GT_o:", "\n", "#    print(g, model['t2_p3_and_t2_p2_t3_p1'].state(groundings=g), GT_o[g])", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 4", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t4_p1\"", "]", "=", "Predicate", "(", "\"t4_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t4_p1\"", ":", "{", "(", "\"x1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t4_p1\"", "]", "(", "x", ")", ",", "join", "=", "join", "\n", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "upward", "(", ")", "\n", "#  model['t2_p3_and_t2_p2_t4_p1'].print()", "\n", "\n", "# for g in GT_o:", "\n", "#    print(g, model['t2_p3_and_t2_p2_t4_p1'].state(groundings=g), GT_o[g])", "\n", "\n", "# GT_i = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 5", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t5_p2\"", "]", "=", "Predicate", "(", "\"t5_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t5_p2\"", ":", "{", "(", "\"a1\"", ",", "\"b1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"a2\"", ",", "\"b2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t5_p2\"", "]", "(", "a", ",", "b", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "upward", "(", ")", "\n", "# model['t2_p3_and_t2_p2_t5_p2'].print()", "\n", "\n", "# GT_inner = dict([", "\n", "#    (('x1', 'y1', 'z1','a1','b1'), Fact.TRUE),", "\n", "#   (('x1', 'y1', 'z1','a2','b2'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_1.test": [[13, 39], ["lnn.truth_table", "print", "functools.reduce", "lnn.Variable", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.And", "lnn.Model.add_facts", "model[].upward", "model[].state", "map", "lnn.bool_to_fact"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], ["    ", "\"\"\"decrease weights for contradictory facts\n\n    given And(A, B) - reduce the weight on B\n    training in the upward direction\n    \"\"\"", "\n", "# model", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "# rules", "\n", "model", "[", "\"A\"", "]", "=", "Proposition", "(", "\"A\"", ")", "\n", "model", "[", "\"B\"", "]", "=", "Proposition", "(", "\"B\"", ")", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "model", "[", "\"A\"", "]", ",", "model", "[", "\"B\"", "]", ",", "world", "=", "World", ".", "AXIOM", ")", "\n", "\n", "# facts", "\n", "model", ".", "add_facts", "(", "{", "\"A\"", ":", "TRUE", ",", "\"B\"", ":", "FALSE", "}", ")", "\n", "\n", "# train/inference", "\n", "model", ".", "train", "(", "direction", "=", "UPWARD", ",", "losses", "=", "{", "\"contradiction\"", ":", "1", "}", ")", "\n", "\n", "weights", "=", "model", "[", "\"AB\"", "]", ".", "params", "(", "\"weights\"", ")", "\n", "bounds", "=", "model", "[", "\"B\"", "]", ".", "state", "(", ")", "\n", "assert", "(", "\n", "weights", "[", "1", "]", "<=", "1", "/", "2", "\n", ")", ",", "f\"expected input B to be downweighted <= 0., received {weights[1]}\"", "\n", "assert", "bounds", "is", "FALSE", ",", "f\"expected bounds to remain False, received {bounds}\"", "\n", "\n", "return", "model", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_njoin_1.test": [[10, 144], ["lnn.Model", "map", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "dict", "lnn.And", "model[].upward", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "lnn.And", "model[].upward", "dict", "all", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ")", ")", "\n", "\n", "# This is the normal 2 var vs 2 var ; should go thru the memory join", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p2\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s2\"", ",", "\"s6\"", ")", ":", "FALSE", ",", "\n", "(", "\"s3\"", ",", "\"s7\"", ")", ":", "FALSE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p2a\"", "]", "=", "Predicate", "(", "\"p2a\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p2a\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s6\"", ")", ":", "FALSE", ",", "\n", "(", "\"s2\"", ",", "\"s5\"", ")", ":", "FALSE", ",", "\n", "(", "\"s4\"", ",", "\"s7\"", ")", ":", "FALSE", ",", "\n", "(", "\"s7\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "GT", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"s1\"", ",", "\"s7\"", ")", ",", "TRUE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s3\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s4\"", ",", "\"s6\"", ")", ",", "UNKNOWN", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s5\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s4\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s7\"", ",", "\"s6\"", ")", ",", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p2a\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "x", ",", "y", ")", ")", "\n", "model", "[", "\"p2_and_p2a\"", "]", ".", "upward", "(", ")", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# 1 variable vs 2 variables", "\n", "\n", "model", "=", "Model", "(", ")", "# Reset the model for each new test.", "\n", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p2\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s2\"", ",", "\"s6\"", ")", ":", "FALSE", ",", "\n", "(", "\"s3\"", ",", "\"s7\"", ")", ":", "FALSE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p1\"", "]", "=", "Predicate", "(", "\"p1\"", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"p1\"", ":", "{", "\"s1\"", ":", "TRUE", ",", "\"s2\"", ":", "TRUE", ",", "\"s3\"", ":", "TRUE", ",", "\"s4\"", ":", "FALSE", ",", "\"s10\"", ":", "FALSE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"p1_and_p2\"", "]", "=", "And", "(", "model", "[", "\"p1\"", "]", "(", "x", ")", ",", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ")", "\n", "model", "[", "\"p1_and_p2\"", "]", ".", "upward", "(", ")", "\n", "\n", "GT", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"s1\"", ",", "\"s6\"", ")", ",", "TRUE", ")", ",", "\n", "(", "(", "\"s3\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s7\"", ")", ",", "TRUE", ")", ",", "\n", "(", "(", "\"s4\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p1_and_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p1_and_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# 2 variable vs 3 variables", "\n", "model", "[", "\"p3\"", "]", "=", "Predicate", "(", "\"p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p3\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s5\"", ",", "\"s3\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s4\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s8\"", ",", "\"s3\"", ")", ":", "FALSE", ",", "\n", "(", "\"s2\"", ",", "\"s8\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ",", "\"s8\"", ")", ":", "FALSE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p3\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p3\"", "]", "(", "x", ",", "z", ",", "y", ")", ")", "\n", "model", "[", "\"p2_and_p3\"", "]", ".", "upward", "(", ")", "\n", "\n", "GT", "=", "dict", "(", "[", "(", "(", "\"s2\"", ",", "\"s6\"", ",", "\"s8\"", ")", ",", "FALSE", ")", ",", "(", "(", "\"s1\"", ",", "\"s7\"", ",", "\"s4\"", ")", ",", "TRUE", ")", "]", ")", "\n", "assert", "all", "(", "model", "[", "\"p2_and_p3\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p3\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# 1 vs 2 vs 3", "\n", "model", "[", "\"p1_and_p2_and_p3\"", "]", "=", "And", "(", "\n", "model", "[", "\"p1\"", "]", "(", "x", ")", ",", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p3\"", "]", "(", "x", ",", "z", ",", "y", ")", "\n", ")", "\n", "model", "[", "\"p1_and_p2_and_p3\"", "]", ".", "upward", "(", ")", "\n", "\n", "GT", "=", "dict", "(", "[", "(", "(", "\"s2\"", ",", "\"s6\"", ",", "\"s8\"", ")", ",", "FALSE", ")", ",", "(", "(", "\"s1\"", ",", "\"s7\"", ",", "\"s4\"", ")", ",", "TRUE", ")", "]", ")", "\n", "assert", "all", "(", "\n", "model", "[", "\"p1_and_p2_and_p3\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p1_and_p2_and_p3\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# 2 variable vs 2 variable reversed", "\n", "model", "[", "\"p2r\"", "]", "=", "Predicate", "(", "\"p2r\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2r\"", ":", "{", "(", "\"s6\"", ",", "\"s2\"", ")", ":", "TRUE", ",", "(", "\"s7\"", ",", "\"s1\"", ")", ":", "FALSE", "}", "}", ")", "\n", "model", "[", "\"p2_and_p2r\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2r\"", "]", "(", "y", ",", "x", ")", ")", "\n", "model", "[", "\"p2_and_p2r\"", "]", ".", "upward", "(", ")", "\n", "GT", "=", "dict", "(", "[", "(", "(", "\"s2\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "(", "(", "\"s1\"", ",", "\"s7\"", ")", ",", "FALSE", ")", "]", ")", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p2_and_p2r\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p2r\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_njoin_outer_pruned_2.test": [[10, 252], ["lnn.Model", "map", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_facts", "model[].state", "model[].state", "dict", "lnn.And", "model[].state", "model[].state", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "dict", "lnn.And", "model[].state", "model[].state", "model[].upward", "model[].print", "model[].state", "model[].state", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].state", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "model[].state", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].state", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "model[].state", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].state", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "model[].state", "dict", "all", "len", "len", "len", "len", "len", "len", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "join", "=", "Join", ".", "OUTER_PRUNED", "\n", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", ",", "a", ",", "b", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\"a\"", ",", "\"b\"", ")", ")", "\n", "\n", "# TEST 1", "\n", "\n", "# This is the normal 2 var vs 2 var ; should go thru the memory join", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "# model.add_facts({'p2': {", "\n", "#    ('x1', 'y1'): Fact.TRUE,", "\n", "#    ('x2', 'y2'): Fact.TRUE}})", "\n", "\n", "model", "[", "\"p2a\"", "]", "=", "Predicate", "(", "\"p2a\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2a\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y3\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"p2\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"p2a\"", "]", ".", "state", "(", ")", "\n", "\n", "# GT_i = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p2a\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", ")", "\n", "# model['p2_and_p2a'].upward()", "\n", "# model['p2_and_p2a'].print()", "\n", "\n", "v1_after", "=", "model", "[", "\"p2\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"p2a\"", "]", ".", "state", "(", ")", "\n", "\n", "# assert (v1_after == v1_before),  \"FAILED \ud83d\ude14\"", "\n", "# assert (v2_after == v2_before),  \"FAILED \ud83d\ude14\"", "\n", "# assert all([model['p2_and_p2a'].state(groundings=g) is GT_o[g]", "\n", "#            for g in GT_o]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['p2_and_p2a'].state()) == len(GT_o), \"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 2", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "# model.add_facts({'t2_p2': {", "\n", "#    ('y1', 'z1'): Fact.TRUE,", "\n", "#    ('y2', 'z2'): Fact.TRUE}})", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "upward", "(", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "print", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "# assert (v1_after == v1_before),  \"FAILED \ud83d\ude14\"", "\n", "# assert (v2_after == v2_before),  \"FAILED \ud83d\ude14\"", "\n", "\n", "# assert all([model['t2_p3_and_t2_p2'].state(groundings=g) is GT_o[g]", "\n", "#            for g in GT_o]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['t2_p3_and_t2_p2'].state()) == len(GT_o), \"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 3", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "model", "[", "\"t3_p1\"", "]", "=", "Predicate", "(", "\"t3_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t3_p1\"", ":", "{", "(", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"z4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t3_p1\"", "]", "(", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_before", "=", "model", "[", "\"t3_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_after", "=", "model", "[", "\"t3_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v3_after", "==", "v3_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 4", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t4_p1\"", "]", "=", "Predicate", "(", "\"t4_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t4_p1\"", ":", "{", "(", "\"x1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t4_p1\"", "]", "(", "x", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_before", "=", "model", "[", "\"t4_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_after", "=", "model", "[", "\"t4_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v3_after", "==", "v3_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 5", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t5_p2\"", "]", "=", "Predicate", "(", "\"t5_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t5_p2\"", ":", "{", "(", "\"a1\"", ",", "\"b1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"a2\"", ",", "\"b2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t5_p2\"", "]", "(", "a", ",", "b", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_before", "=", "model", "[", "\"t5_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_after", "=", "model", "[", "\"t5_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v3_after", "==", "v3_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_5.test_1": [[12, 36], ["zip", "lnn.Model", "tuple", "list", "lnn.Predicate", "lnn.Predicate", "lnn.And", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Model.infer", "map", "lnn.Predicate.", "lnn.Predicate.", "len", "len", "range"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"\n    And(P1(x0), P2(x0, x1, ..., xn))\n    \"\"\"", "\n", "for", "join", ",", "gt", "in", "zip", "(", "[", "Join", ".", "INNER", ",", "Join", ".", "OUTER", "]", ",", "[", "1", ",", "3", "]", ")", ":", "\n", "        ", "n_vars", "=", "1000", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "var_labels", "=", "tuple", "(", "f\"x{i}\"", "for", "i", "in", "range", "(", "0", ",", "n_vars", ")", ")", "\n", "variables", "=", "list", "(", "map", "(", "Variable", ",", "var_labels", ")", ")", "\n", "\n", "p0", "=", "model", "[", "\"p0\"", "]", "=", "Predicate", "(", ")", "\n", "p1", "=", "model", "[", "\"p1\"", "]", "=", "Predicate", "(", "arity", "=", "n_vars", ")", "\n", "\n", "model", "[", "\"And\"", "]", "=", "And", "(", "\n", "p0", "(", "variables", "[", "0", "]", ")", ",", "p1", "(", "*", "variables", ")", ",", "world", "=", "World", ".", "AXIOM", ",", "join", "=", "join", "\n", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "{", "\"0\"", ":", "TRUE", ",", "\"1\"", ":", "TRUE", ",", "\"2\"", ":", "TRUE", "}", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p1\"", ":", "{", "(", "\"0\"", ",", ")", "*", "n_vars", ":", "TRUE", "}", "}", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "assert", "len", "(", "model", "[", "\"And\"", "]", ".", "groundings", ")", "==", "gt", ",", "(", "\n", "f\"Expected {gt} grounding, \"", "f\"received {len(model['And'].groundings)}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_5.test_2": [[39, 64], ["zip", "lnn.Model", "tuple", "list", "lnn.Predicate", "lnn.Predicate", "random.randrange", "lnn.And", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Model.infer", "map", "lnn.Predicate.", "lnn.Predicate.", "len", "len", "range"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["", "", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"\n    And(P1(xr), P2(x0, x1, ..., xn))\n    \"\"\"", "\n", "for", "join", ",", "gt", "in", "zip", "(", "[", "Join", ".", "INNER", ",", "Join", ".", "OUTER", "]", ",", "[", "1", ",", "3", "]", ")", ":", "\n", "        ", "n_vars", "=", "1000", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "var_labels", "=", "tuple", "(", "f\"x{i}\"", "for", "i", "in", "range", "(", "0", ",", "n_vars", ")", ")", "\n", "variables", "=", "list", "(", "map", "(", "Variable", ",", "var_labels", ")", ")", "\n", "\n", "p0", "=", "model", "[", "\"p0\"", "]", "=", "Predicate", "(", ")", "\n", "p1", "=", "model", "[", "\"p1\"", "]", "=", "Predicate", "(", "arity", "=", "n_vars", ")", "\n", "\n", "r", "=", "random", ".", "randrange", "(", "0", ",", "n_vars", ")", "\n", "model", "[", "\"And\"", "]", "=", "And", "(", "\n", "p0", "(", "variables", "[", "r", "]", ")", ",", "p1", "(", "*", "variables", ")", ",", "world", "=", "World", ".", "AXIOM", ",", "join", "=", "join", "\n", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "{", "\"0\"", ":", "TRUE", ",", "\"1\"", ":", "TRUE", ",", "\"2\"", ":", "TRUE", "}", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p1\"", ":", "{", "(", "\"0\"", ",", ")", "*", "n_vars", ":", "TRUE", "}", "}", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "assert", "len", "(", "model", "[", "\"And\"", "]", ".", "groundings", ")", "==", "gt", ",", "(", "\n", "f\"Expected {gt} grounding, \"", "f\"received {len(model['And'].groundings)}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_5.test_3": [[67, 110], ["zip", "lnn.Model", "tuple", "list", "lnn.Predicate", "lnn.Predicate", "lnn.And", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Model.infer", "map", "lnn.Predicate.", "lnn.Predicate.", "len", "len", "range"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["", "", "def", "test_3", "(", ")", ":", "\n", "    ", "\"\"\"\n    And(P1(x0, x1, x2), P2(x0, x1, ..., xn))\n    \"\"\"", "\n", "n_vars", "=", "5", "\n", "\n", "for", "join", ",", "gt", "in", "zip", "(", "[", "Join", ".", "INNER", ",", "Join", ".", "OUTER", "]", ",", "[", "3", ",", "3", "]", ")", ":", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "var_labels", "=", "tuple", "(", "f\"x{i}\"", "for", "i", "in", "range", "(", "0", ",", "n_vars", ")", ")", "\n", "variables", "=", "list", "(", "map", "(", "Variable", ",", "var_labels", ")", ")", "\n", "\n", "p0", "=", "model", "[", "\"p0\"", "]", "=", "Predicate", "(", "arity", "=", "3", ")", "\n", "p1", "=", "model", "[", "\"p1\"", "]", "=", "Predicate", "(", "arity", "=", "n_vars", ")", "\n", "\n", "model", "[", "\"And\"", "]", "=", "And", "(", "\n", "p0", "(", "variables", "[", "0", "]", ",", "variables", "[", "1", "]", ",", "variables", "[", "2", "]", ")", ",", "\n", "p1", "(", "*", "variables", ")", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p0\"", ":", "{", "\n", "(", "\"0\"", ",", "\"0\"", ",", "\"0\"", ")", ":", "TRUE", ",", "\n", "(", "\"0\"", ",", "\"0\"", ",", "\"1\"", ")", ":", "TRUE", ",", "\n", "(", "\"0\"", ",", "\"0\"", ",", "\"2\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p1\"", ":", "{", "\n", "(", "\"0\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", ")", ":", "TRUE", ",", "\n", "(", "\"0\"", ",", "\"0\"", ",", "\"1\"", ",", "\"0\"", ",", "\"0\"", ")", ":", "TRUE", ",", "\n", "(", "\"0\"", ",", "\"0\"", ",", "\"2\"", ",", "\"0\"", ",", "\"0\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "assert", "len", "(", "model", "[", "\"And\"", "]", ".", "groundings", ")", "==", "gt", ",", "(", "\n", "f\"Expected {gt} groundings, \"", "f\"received {len(model['And'].groundings)}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_5.test_4": [[113, 144], ["zip", "lnn.Model", "tuple", "list", "lnn.Predicate", "lnn.Predicate", "lnn.And", "random.sample", "tuple", "lnn.Model.add_facts", "lnn.Model.add_facts", "lnn.Model.infer", "map", "lnn.Predicate.", "lnn.Predicate.", "range", "len", "len", "range"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer"], ["", "", "def", "test_4", "(", ")", ":", "\n", "    ", "\"\"\"\n    And(P1(nc3), P2(x0, x1, ..., xn))\n    \"\"\"", "\n", "n_vars", "=", "1000", "\n", "\n", "for", "join", ",", "gt", "in", "zip", "(", "[", "Join", ".", "INNER", ",", "Join", ".", "OUTER", "]", ",", "[", "3", ",", "3", "]", ")", ":", "\n", "\n", "        ", "model", "=", "Model", "(", ")", "\n", "var_labels", "=", "tuple", "(", "f\"x{i}\"", "for", "i", "in", "range", "(", "0", ",", "n_vars", ")", ")", "\n", "variables", "=", "list", "(", "map", "(", "Variable", ",", "var_labels", ")", ")", "\n", "\n", "p0", "=", "model", "[", "\"p0\"", "]", "=", "Predicate", "(", "arity", "=", "n_vars", ")", "\n", "p1", "=", "model", "[", "\"p1\"", "]", "=", "Predicate", "(", "arity", "=", "n_vars", ")", "\n", "\n", "model", "[", "\"And\"", "]", "=", "And", "(", "p0", "(", "*", "variables", ")", ",", "p1", "(", "*", "variables", ")", ",", "world", "=", "World", ".", "AXIOM", ",", "join", "=", "join", ")", "\n", "\n", "key_arr", "=", "[", "\"0\"", "]", "*", "n_vars", "\n", "random_indices", "=", "random", ".", "sample", "(", "range", "(", "1", ",", "n_vars", ")", ",", "3", ")", "\n", "\n", "for", "i", "in", "random_indices", ":", "\n", "            ", "key_arr", "[", "i", "]", "=", "\"1\"", "\n", "\n", "", "key", "=", "tuple", "(", "key_arr", ")", "\n", "\n", "model", ".", "add_facts", "(", "{", "\"p0\"", ":", "{", "key", ":", "TRUE", ",", "(", "\"0\"", ",", ")", "*", "n_vars", ":", "TRUE", "}", "}", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p1\"", ":", "{", "key", ":", "TRUE", ",", "(", "\"1\"", ",", ")", "*", "n_vars", ":", "TRUE", "}", "}", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "assert", "len", "(", "model", "[", "\"And\"", "]", ".", "groundings", ")", "==", "gt", ",", "(", "\n", "f\"Expected {gt} groundings, \"", "f\"received {len(model['And'].groundings)}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_qa.test_1": [[10, 43], ["lnn.Variable", "lnn.Variable", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Exists", "lnn.Model.add_formulae", "lnn.Model.infer", "lnn.And"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["def", "test_1", "(", ")", ":", "\n", "    ", "join", "=", "Join", ".", "OUTER", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "model", "[", "\"director\"", "]", "=", "Predicate", "(", "\"director\"", ",", "arity", "=", "2", ")", "\n", "model", "[", "\"starring\"", "]", "=", "Predicate", "(", "\"starring\"", ",", "arity", "=", "2", ")", "\n", "\n", "facts", "=", "{", "\n", "\"director\"", ":", "{", "(", "\"William_Shatner\"", ",", "\"The_captains\"", ")", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"starring\"", ":", "{", "\n", "(", "\"William_Shatner\"", ",", "\"The_captains\"", ")", ":", "Fact", ".", "TRUE", ",", "\n", "(", "\"Patrick_Stewart\"", ",", "\"The_captains\"", ")", ":", "Fact", ".", "TRUE", ",", "\n", "}", ",", "\n", "}", "\n", "model", ".", "add_facts", "(", "facts", ")", "\n", "\n", "query", "=", "Exists", "(", "\n", "x", ",", "\n", "And", "(", "\n", "model", "[", "\"director\"", "]", "(", "(", "x", ",", "\"William_Shatner\"", ")", ",", "y", ")", ",", "\n", "model", "[", "\"starring\"", "]", "(", "x", ",", "y", ")", ",", "\n", "join", "=", "join", ",", "\n", ")", ",", "\n", "name", "=", "\"Shatner-stars\"", ",", "\n", ")", "\n", "model", ".", "add_formulae", "(", "query", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "\n", "assert", "query", ".", "true_groundings", "==", "{", "\"William_Shatner\"", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_qa.test_2": [[45, 80], ["lnn.Variable", "lnn.Variable", "lnn.Variable", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Exists", "lnn.Model.add_formulae", "lnn.Model.infer", "lnn.And"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.infer", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And"], ["", "def", "test_2", "(", ")", ":", "\n", "    ", "join", "=", "Join", ".", "OUTER", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "y", "=", "Variable", "(", "\"y\"", ")", "\n", "z", "=", "Variable", "(", "\"z\"", ")", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "model", "[", "\"director\"", "]", "=", "Predicate", "(", "\"director\"", ",", "arity", "=", "2", ")", "\n", "model", "[", "\"starring\"", "]", "=", "Predicate", "(", "\"starring\"", ",", "arity", "=", "2", ")", "\n", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"director\"", ":", "{", "(", "\"William_Shatner\"", ",", "\"The_captains\"", ")", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"starring\"", ":", "{", "\n", "(", "\"William_Shatner\"", ",", "\"The_captains\"", ")", ":", "Fact", ".", "TRUE", ",", "\n", "(", "\"Patrick_Stewart\"", ",", "\"The_captains\"", ")", ":", "Fact", ".", "TRUE", ",", "\n", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "query", "=", "Exists", "(", "\n", "z", ",", "\n", "And", "(", "\n", "model", "[", "\"director\"", "]", "(", "(", "x", ",", "\"William_Shatner\"", ")", ",", "y", ")", ",", "\n", "model", "[", "\"starring\"", "]", "(", "z", ",", "y", ")", ",", "\n", "join", "=", "join", ",", "\n", ")", ",", "\n", "name", "=", "\"Shatner-stars\"", ",", "\n", ")", "\n", "model", ".", "add_formulae", "(", "query", ")", "\n", "\n", "model", ".", "infer", "(", ")", "\n", "\n", "assert", "query", ".", "true_groundings", "==", "{", "\"William_Shatner\"", ",", "\"Patrick_Stewart\"", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_njoin_outer_pruned_1.test": [[10, 248], ["lnn.Model", "map", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "model[].state", "model[].state", "dict", "lnn.And", "model[].upward", "model[].state", "model[].state", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "dict", "lnn.And", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].state", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "model[].state", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].state", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "model[].state", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].state", "model[].state", "model[].state", "model[].upward", "model[].state", "model[].state", "model[].state", "dict", "all", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "join", "=", "Join", ".", "OUTER_PRUNED", "\n", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", ",", "a", ",", "b", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\"a\"", ",", "\"b\"", ")", ")", "\n", "\n", "# TEST 1", "\n", "\n", "# This is the normal 2 var vs 2 var ; should go thru the memory join", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x2\"", ",", "\"y2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"p2a\"", "]", "=", "Predicate", "(", "\"p2a\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2a\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y3\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"p2\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"p2a\"", "]", ".", "state", "(", ")", "\n", "\n", "# GT_i = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p2a\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", ")", "\n", "model", "[", "\"p2_and_p2a\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"p2\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"p2a\"", "]", ".", "state", "(", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 2", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 3", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "model", "[", "\"t3_p1\"", "]", "=", "Predicate", "(", "\"t3_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t3_p1\"", ":", "{", "(", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"z4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t3_p1\"", "]", "(", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_before", "=", "model", "[", "\"t3_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_after", "=", "model", "[", "\"t3_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v3_after", "==", "v3_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 4", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t4_p1\"", "]", "=", "Predicate", "(", "\"t4_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t4_p1\"", ":", "{", "(", "\"x1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t4_p1\"", "]", "(", "x", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_before", "=", "model", "[", "\"t4_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_after", "=", "model", "[", "\"t4_p1\"", "]", ".", "state", "(", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v3_after", "==", "v3_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 5", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t5_p2\"", "]", "=", "Predicate", "(", "\"t5_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t5_p2\"", ":", "{", "(", "\"a1\"", ",", "\"b1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"a2\"", ",", "\"b2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t5_p2\"", "]", "(", "a", ",", "b", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "v1_before", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_before", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_before", "=", "model", "[", "\"t5_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "upward", "(", ")", "\n", "\n", "v1_after", "=", "model", "[", "\"t2_p3\"", "]", ".", "state", "(", ")", "\n", "v2_after", "=", "model", "[", "\"t2_p2\"", "]", ".", "state", "(", ")", "\n", "v3_after", "=", "model", "[", "\"t5_p2\"", "]", ".", "state", "(", ")", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "v1_after", "==", "v1_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v2_after", "==", "v2_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "v3_after", "==", "v3_before", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_3.test": [[13, 54], ["lnn.truth_table", "lnn.Model", "map", "range", "lnn.And", "range", "model[].upward", "range", "print", "functools.reduce", "lnn.Predicate", "lnn.Model.add_facts", "len", "model[].state", "map", "lnn.bool_to_fact", "str", "str", "range", "enumerate"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], ["def", "test", "(", ")", ":", "\n", "    ", "\"\"\"FOL upward n-input conjunction boolean truth table\n\n    10 predicates input to 1 conjunction, with binary groundings (x, y)\n    collapses the truth table rows to groundings, instead of separate models\n    \"\"\"", "\n", "\n", "n_preds", "=", "10", "\n", "TT", "=", "truth_table", "(", "n_preds", ")", "\n", "\n", "# get ground truth", "\n", "GT", "=", "[", "reduce", "(", "np", ".", "logical_and", ",", "map", "(", "fact_to_bool", ",", "row", ")", ")", "for", "row", "in", "TT", "]", "\n", "\n", "# load model and reason over facts", "\n", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ")", ")", "\n", "\n", "for", "pred", "in", "range", "(", "n_preds", ")", ":", "\n", "        ", "model", "[", "f\"P{pred}\"", "]", "=", "Predicate", "(", "arity", "=", "2", ")", "\n", "", "model", "[", "\"AB\"", "]", "=", "And", "(", "*", "[", "model", "[", "f\"P{pred}\"", "]", "(", "x", ",", "y", ")", "for", "pred", "in", "range", "(", "n_preds", ")", "]", ")", "\n", "\n", "# set model facts", "\n", "for", "pred", "in", "range", "(", "n_preds", ")", ":", "\n", "        ", "model", ".", "add_facts", "(", "\n", "{", "\n", "f\"P{pred}\"", ":", "{", "\n", "(", "f\"{row}\"", ",", "f\"{row}\"", ")", ":", "truth", "[", "pred", "]", "for", "row", ",", "truth", "in", "enumerate", "(", "TT", ")", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "# inference", "\n", "", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "for", "row", "in", "range", "(", "len", "(", "TT", ")", ")", ":", "\n", "        ", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", "(", "str", "(", "row", ")", ",", "str", "(", "row", ")", ")", ")", "\n", "assert", "prediction", "is", "bool_to_fact", "(", "\n", "GT", "[", "row", "]", "\n", ")", ",", "f\"And({TT[:, row]}) expected {GT}, received {prediction}\"", "\n", "", "print", "(", "\"success\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_shared_var_set.test_1": [[10, 34], ["lnn.Variable", "lnn.Predicate", "lnn.Predicate", "lnn.ForAll", "lnn.Model", "lnn.Model.add_formulae", "lnn.Model.add_facts", "lnn.Model.upward", "lnn.Implies", "len", "lnn.Predicate.", "lnn.Predicate."], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies"], ["def", "test_1", "(", ")", ":", "\n", "    ", "\"\"\"Simple theorem proving example\n    Unary predicates with overlapping variable set.\n    \"\"\"", "\n", "\n", "x", "=", "Variable", "(", "\"x\"", ")", "\n", "square", "=", "Predicate", "(", "name", "=", "\"square\"", ")", "\n", "rectangle", "=", "Predicate", "(", "name", "=", "\"rectangle\"", ")", "\n", "\n", "square_rect", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "square", "(", "x", ")", ",", "rectangle", "(", "x", ")", ",", "name", "=", "\"square-rect\"", ",", "join", "=", "Join", ".", "OUTER", ")", ",", "\n", "name", "=", "\"all-square-rect\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "\n", "model", "=", "Model", "(", ")", "\n", "model", ".", "add_formulae", "(", "square", ",", "rectangle", ",", "square_rect", ")", "\n", "model", ".", "add_facts", "(", "{", "\"square\"", ":", "{", "\"c\"", ":", "Fact", ".", "TRUE", ",", "\"k\"", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "\n", "assert", "len", "(", "rectangle", ".", "groundings", ")", "==", "2", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_shared_var_set.test_2": [[36, 63], ["map", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.ForAll", "lnn.Model.add_facts", "lnn.Model.upward", "lnn.Implies", "len", "lnn.Predicate.", "lnn.Predicate."], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.Implies"], ["", "def", "test_2", "(", ")", ":", "\n", "    ", "\"\"\"\n    Binary and unary predicates with an overlapping variable subset.\n    :return:\n    \"\"\"", "\n", "\n", "x", ",", "y", "=", "map", "(", "Variable", ",", "[", "\"x\"", ",", "\"y\"", "]", ")", "\n", "model", "=", "Model", "(", ")", "# Instantiate a model.", "\n", "\n", "enemy", "=", "model", "[", "\"enemy\"", "]", "=", "Predicate", "(", "arity", "=", "2", ",", "name", "=", "\"enemy\"", ")", "\n", "hostile", "=", "model", "[", "\"hostile\"", "]", "=", "Predicate", "(", "name", "=", "\"hostile\"", ")", "\n", "\n", "model", "[", "\"america-enemies\"", "]", "=", "ForAll", "(", "\n", "x", ",", "\n", "Implies", "(", "\n", "enemy", "(", "x", ",", "(", "y", ",", "\"America\"", ")", ")", ",", "hostile", "(", "x", ")", ",", "name", "=", "\"enemy->hostile\"", ",", "join", "=", "Join", ".", "OUTER", "\n", ")", ",", "\n", "name", "=", "\"america-enemies\"", ",", "\n", "join", "=", "Join", ".", "OUTER", ",", "\n", "world", "=", "World", ".", "AXIOM", ",", "\n", ")", "\n", "\n", "# Add facts to model.", "\n", "model", ".", "add_facts", "(", "{", "\"enemy\"", ":", "{", "(", "\"Nono\"", ",", "\"America\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "assert", "len", "(", "hostile", ".", "groundings", ")", "==", "1", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_shared_var_set.test_3": [[65, 85], ["map", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.And", "lnn.Model.add_formulae", "lnn.Model.add_facts", "lnn.Model.upward", "lnn.Predicate.", "lnn.Predicate.", "len"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward"], ["", "def", "test_3", "(", ")", ":", "\n", "    ", "\"\"\"\n    Tenary and binary predicates with an overlapping variable subset.\n    :return:\n    \"\"\"", "\n", "\n", "x", ",", "y", ",", "z", "=", "map", "(", "Variable", ",", "[", "\"x\"", ",", "\"y\"", ",", "\"z\"", "]", ")", "\n", "model", "=", "Model", "(", ")", "# Instantiate a model.", "\n", "\n", "f1", "=", "Predicate", "(", "name", "=", "\"F1\"", ",", "arity", "=", "3", ")", "\n", "f2", "=", "Predicate", "(", "name", "=", "\"F2\"", ",", "arity", "=", "2", ")", "\n", "\n", "rule", "=", "And", "(", "f1", "(", "x", ",", "y", ",", "z", ")", ",", "f2", "(", "x", ",", "y", ")", ",", "join", "=", "Join", ".", "OUTER", ")", "\n", "\n", "model", ".", "add_formulae", "(", "f1", ",", "f2", ",", "rule", ")", "\n", "model", ".", "add_facts", "(", "{", "\"F1\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "\n", "assert", "len", "(", "f2", ".", "groundings", ")", "==", "1", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_shared_var_set.test_4": [[87, 114], ["map", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Model", "lnn.And", "lnn.Model.add_formulae", "lnn.Model.add_facts", "lnn.Model.upward", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "lnn.Predicate.", "len"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.lnn.model.Model.add_formulae", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward"], ["", "def", "test_4", "(", ")", ":", "\n", "    ", "\"\"\"\n    Tenary predicate (x,y,z) and 3 unary predicates (x),(y),(z) requiring\n    product join and overlapping variable subset.\n    :return:\n    \"\"\"", "\n", "\n", "x", ",", "y", ",", "z", "=", "map", "(", "Variable", ",", "[", "\"x\"", ",", "\"y\"", ",", "\"z\"", "]", ")", "\n", "american", "=", "Predicate", "(", "\"american\"", ")", "\n", "hostile", "=", "Predicate", "(", "\"hostile\"", ")", "\n", "weapon", "=", "Predicate", "(", "\"weapon\"", ")", "\n", "sells", "=", "Predicate", "(", "arity", "=", "3", ",", "name", "=", "\"sells\"", ")", "\n", "\n", "model", "=", "Model", "(", ")", "# Instantiate a model.", "\n", "rule", "=", "And", "(", "american", "(", "x", ")", ",", "weapon", "(", "y", ")", ",", "hostile", "(", "z", ")", ",", "sells", "(", "x", ",", "y", ",", "z", ")", ",", "join", "=", "Join", ".", "OUTER", ")", "\n", "model", ".", "add_formulae", "(", "american", ",", "hostile", ",", "weapon", ",", "rule", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"american\"", ":", "{", "\"West\"", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"hostile\"", ":", "{", "\"Nono\"", ":", "Fact", ".", "TRUE", "}", ",", "\n", "\"weapon\"", ":", "{", "\"m1\"", ":", "Fact", ".", "TRUE", "}", ",", "\n", "}", "\n", ")", "\n", "\n", "model", ".", "upward", "(", ")", "\n", "\n", "assert", "len", "(", "sells", ".", "groundings", ")", "==", "1", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_njoin_2.test": [[10, 103], ["lnn.Model", "map", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.And", "model[].upward", "dict", "all", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "all", "len", "len", "len", "len", "len", "len", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ")", ")", "\n", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p2\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s2\"", ",", "\"s6\"", ")", ":", "FALSE", ",", "\n", "(", "\"s3\"", ",", "\"s7\"", ")", ":", "FALSE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p1_null\"", "]", "=", "Predicate", "(", "\"p1_null\"", ")", "\n", "model", "[", "\"p1_and_p2\"", "]", "=", "And", "(", "model", "[", "\"p1_null\"", "]", "(", "x", ")", ",", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ")", "\n", "model", "[", "\"p1_and_p2\"", "]", ".", "upward", "(", ")", "\n", "\n", "GT", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"s1\"", ",", "\"s6\"", ")", ",", "UNKNOWN", ")", ",", "\n", "(", "(", "\"s3\"", ",", "\"s7\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s7\"", ")", ",", "UNKNOWN", ")", ",", "\n", "(", "(", "\"s4\"", ",", "\"s6\"", ")", ",", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p1_and_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p1_and_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# 2 variable vs 3 variables", "\n", "model", "[", "\"p2_null\"", "]", "=", "Predicate", "(", "\"p2_null\"", ",", "arity", "=", "2", ")", "\n", "model", "[", "\"p3\"", "]", "=", "Predicate", "(", "\"p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p3\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s5\"", ",", "\"s3\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s4\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s8\"", ",", "\"s3\"", ")", ":", "FALSE", ",", "\n", "(", "\"s2\"", ",", "\"s8\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ",", "\"s8\"", ")", ":", "FALSE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p3\"", "]", "=", "And", "(", "model", "[", "\"p2_null\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p3\"", "]", "(", "x", ",", "z", ",", "y", ")", ")", "\n", "model", "[", "\"p2_and_p3\"", "]", ".", "upward", "(", ")", "\n", "GT", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"s4\"", ",", "\"s8\"", ",", "\"s6\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s3\"", ",", "\"s8\"", ")", ",", "FALSE", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s3\"", ",", "\"s5\"", ")", ",", "UNKNOWN", ")", ",", "\n", "(", "(", "\"s2\"", ",", "\"s6\"", ",", "\"s8\"", ")", ",", "UNKNOWN", ")", ",", "\n", "(", "(", "\"s1\"", ",", "\"s7\"", ",", "\"s4\"", ")", ",", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "all", "(", "model", "[", "\"p2_and_p3\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p3\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# 1 vs 2 vs 3", "\n", "model", "=", "Model", "(", ")", "# Reset the model for each new test.", "\n", "model", "[", "\"p1_null\"", "]", "=", "Predicate", "(", "\"p1_null\"", ")", "\n", "\n", "model", "[", "\"p2_null\"", "]", "=", "Predicate", "(", "\"p2_null\"", ",", "arity", "=", "2", ")", "\n", "model", "[", "\"p3\"", "]", "=", "Predicate", "(", "\"p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\n", "\"p3\"", ":", "{", "\n", "(", "\"s1\"", ",", "\"s5\"", ",", "\"s3\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s4\"", ",", "\"s7\"", ")", ":", "TRUE", ",", "\n", "(", "\"s1\"", ",", "\"s8\"", ",", "\"s3\"", ")", ":", "FALSE", ",", "\n", "(", "\"s2\"", ",", "\"s8\"", ",", "\"s6\"", ")", ":", "TRUE", ",", "\n", "(", "\"s4\"", ",", "\"s6\"", ",", "\"s8\"", ")", ":", "FALSE", ",", "\n", "}", "\n", "}", "\n", ")", "\n", "\n", "model", "[", "\"p1_and_p2_and_p3\"", "]", "=", "And", "(", "\n", "model", "[", "\"p1_null\"", "]", "(", "x", ")", ",", "model", "[", "\"p2_null\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p3\"", "]", "(", "x", ",", "z", ",", "y", ")", "\n", ")", "\n", "model", "[", "\"p1_and_p2_and_p3\"", "]", ".", "upward", "(", ")", "\n", "\n", "assert", "all", "(", "\n", "model", "[", "\"p1_and_p2_and_p3\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT", "[", "g", "]", "for", "g", "in", "GT", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p1_and_p2_and_p3\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_gm_njoin_outer_2.test": [[10, 229], ["lnn.Model", "map", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "dict", "lnn.And", "model[].upward", "all", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "dict", "lnn.And", "model[].upward", "model[].print", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Predicate", "lnn.And", "model[].upward", "model[].print", "dict", "lnn.Model", "lnn.Predicate", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "model[].print", "dict", "lnn.Model", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.Predicate", "lnn.Model.add_facts", "lnn.And", "model[].upward", "dict", "all", "len", "len", "len", "len", "model[].state", "model[].state", "model[].state", "model[].state"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state"], ["def", "test", "(", ")", ":", "\n", "    ", "join", "=", "Join", ".", "OUTER", "\n", "model", "=", "Model", "(", ")", "\n", "x", ",", "y", ",", "z", ",", "a", ",", "b", "=", "map", "(", "Variable", ",", "(", "\"x\"", ",", "\"y\"", ",", "\"z\"", ",", "\"a\"", ",", "\"b\"", ")", ")", "\n", "\n", "# TEST 1", "\n", "\n", "# This is the normal 2 var vs 2 var ; should go thru the memory join", "\n", "model", "[", "\"p2\"", "]", "=", "Predicate", "(", "\"p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x2\"", ",", "\"y2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"p2a\"", "]", "=", "Predicate", "(", "\"p2a\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"p2a\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y3\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "# print(\"Predicates before outer Join\")", "\n", "# model['p2'].print()", "\n", "# model['p2a'].print()", "\n", "\n", "# GT_i = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x2\"", ",", "\"y3\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"p2_and_p2a\"", "]", "=", "And", "(", "model", "[", "\"p2\"", "]", "(", "x", ",", "y", ")", ",", "model", "[", "\"p2a\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", ")", "\n", "model", "[", "\"p2_and_p2a\"", "]", ".", "upward", "(", ")", "\n", "\n", "# print(\"Predicates After Join\")", "\n", "# model['p2'].print()", "\n", "# model['p2a'].print()", "\n", "# model['p2_and_p2a'].print()", "\n", "\n", "# for g in GT_o :", "\n", "#    print(g, model['p2_and_p2a'].state(groundings=g), GT_o[g])", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"p2_and_p2a\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 2", "\n", "model", "=", "Model", "(", ")", "\n", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "# model.add_facts({'t2_p2': {", "\n", "#    ('y1', 'z1'): Fact.TRUE,", "\n", "#    ('y2', 'z2'): Fact.TRUE}})", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "upward", "(", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2\"", "]", ".", "print", "(", ")", "\n", "\n", "# assert all([model['t2_p3_and_t2_p2'].state(groundings=g) is GT_o[g]", "\n", "#            for g in GT_o]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['t2_p3_and_t2_p2'].state()) == len(GT_o), \"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 3", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "# model.add_facts({'t2_p2': {", "\n", "#    ('y1', 'z1'): Fact.TRUE,", "\n", "#    ('y2', 'z2'): Fact.TRUE}})", "\n", "model", "[", "\"t3_p1\"", "]", "=", "Predicate", "(", "\"t3_p1\"", ")", "\n", "# model.add_facts({'t3_p1': {", "\n", "#    ('z1'): Fact.TRUE,", "\n", "#    ('z4'): Fact.TRUE}})", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t3_p1\"", "]", "(", "z", ")", ",", "join", "=", "join", "\n", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "upward", "(", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t3_p1\"", "]", ".", "print", "(", ")", "\n", "\n", "# GT_inner = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z4\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "# for g in GT_o:", "\n", "#    print(g, model['t2_p3_and_t2_p2_t3_p1'].state(groundings=g), GT_o[g])", "\n", "\n", "# assert all([model['t2_p3_and_t2_p2_t3_p1'].state(groundings=g) is GT_o[g]", "\n", "#            for g in GT_o]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['t2_p3_and_t2_p2_t3_p1'].state())", "\n", "#  == len(GT_o), \"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 4", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "# model.add_facts({'t2_p3': {", "\n", "#    ('x1', 'y1', 'z1'): Fact.TRUE,", "\n", "#    ('x3', 'y3', 'z3'): Fact.TRUE}})", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t4_p1\"", "]", "=", "Predicate", "(", "\"t4_p1\"", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t4_p1\"", ":", "{", "(", "\"x1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x4\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t4_p1\"", "]", "(", "x", ")", ",", "join", "=", "join", "\n", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "upward", "(", ")", "\n", "model", "[", "\"t2_p3_and_t2_p2_t4_p1\"", "]", ".", "print", "(", ")", "\n", "\n", "# for g in GT_o:", "\n", "#    print(g, model['t2_p3_and_t2_p2_t4_p1'].state(groundings=g), GT_o[g])", "\n", "\n", "# GT_i = dict([", "\n", "#    (('x1', 'y1', 'z1'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y1\"", ",", "\"z1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y3\"", ",", "\"z3\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x4\"", ",", "\"y2\"", ",", "\"z2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "# assert all([model['t2_p3_and_t2_p2_t4_p1'].state(groundings=g)", "\n", "#            is GT_o[g] for g in GT_o]), \"FAILED \ud83d\ude14\"", "\n", "# assert len(model['t2_p3_and_t2_p2_t4_p1'].state()) ==", "\n", "# len(GT_o), \"FAILED \ud83d\ude14\"", "\n", "\n", "# TEST 5", "\n", "model", "=", "Model", "(", ")", "\n", "model", "[", "\"t2_p3\"", "]", "=", "Predicate", "(", "\"t2_p3\"", ",", "arity", "=", "3", ")", "\n", "model", ".", "add_facts", "(", "\n", "{", "\"t2_p3\"", ":", "{", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ")", ":", "Fact", ".", "TRUE", "}", "}", "\n", ")", "\n", "\n", "model", "[", "\"t2_p2\"", "]", "=", "Predicate", "(", "\"t2_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t2_p2\"", ":", "{", "(", "\"y1\"", ",", "\"z1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"y2\"", ",", "\"z2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t5_p2\"", "]", "=", "Predicate", "(", "\"t5_p2\"", ",", "arity", "=", "2", ")", "\n", "model", ".", "add_facts", "(", "{", "\"t5_p2\"", ":", "{", "(", "\"a1\"", ",", "\"b1\"", ")", ":", "Fact", ".", "TRUE", ",", "(", "\"a2\"", ",", "\"b2\"", ")", ":", "Fact", ".", "TRUE", "}", "}", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", "=", "And", "(", "\n", "model", "[", "\"t2_p3\"", "]", "(", "x", ",", "y", ",", "z", ")", ",", "model", "[", "\"t2_p2\"", "]", "(", "y", ",", "z", ")", ",", "model", "[", "\"t5_p2\"", "]", "(", "a", ",", "b", ")", ",", "join", "=", "join", "\n", ")", "\n", "\n", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "upward", "(", ")", "\n", "# model['t2_p3_and_t2_p2_t5_p2'].print()", "\n", "\n", "# GT_inner = dict([", "\n", "#    (('x1', 'y1', 'z1','a1','b1'), Fact.TRUE),", "\n", "#   (('x1', 'y1', 'z1','a2','b2'), Fact.TRUE)])", "\n", "\n", "GT_o", "=", "dict", "(", "\n", "[", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a1\"", ",", "\"b1\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "TRUE", ")", ",", "\n", "(", "(", "\"x1\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y1\"", ",", "\"z1\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y3\"", ",", "\"z3\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "(", "(", "\"x3\"", ",", "\"y2\"", ",", "\"z2\"", ",", "\"a2\"", ",", "\"b2\"", ")", ",", "Fact", ".", "UNKNOWN", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "assert", "all", "(", "\n", "[", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", "groundings", "=", "g", ")", "is", "GT_o", "[", "g", "]", "for", "g", "in", "GT_o", "]", "\n", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "assert", "len", "(", "model", "[", "\"t2_p3_and_t2_p2_t5_p2\"", "]", ".", "state", "(", ")", ")", "==", "len", "(", "GT_o", ")", ",", "\"FAILED \ud83d\ude14\"", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.gm.test_bool_and_4.test": [[13, 49], ["lnn.truth_table", "lnn.Model", "tuple", "list", "range", "lnn.And", "range", "model[].upward", "range", "print", "functools.reduce", "map", "lnn.Predicate", "lnn.Model.add_facts", "len", "model[].state", "lnn.fact_to_bool", "range", "lnn.bool_to_fact", "range", "enumerate", "str"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.truth_table", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.And", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Quantifier.upward", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.print", "home.repos.pwc.inspect_result.IBM_LNN.parameters.node._NodeParameters.add_facts", "home.repos.pwc.inspect_result.IBM_LNN.symbolic.logic._Formula.state", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.fact_to_bool", "home.repos.pwc.inspect_result.IBM_LNN.lnn.utils.bool_to_fact"], ["def", "test", "(", ")", ":", "\n", "    ", "n_preds", "=", "2", "\n", "n_vars", "=", "1000", "\n", "TT", "=", "truth_table", "(", "n_preds", ")", "\n", "\n", "# get ground truth", "\n", "GT", "=", "[", "reduce", "(", "np", ".", "logical_and", ",", "fact_to_bool", "(", "*", "row", ")", ")", "for", "row", "in", "TT", "]", "\n", "\n", "# load model and reason over facts", "\n", "model", "=", "Model", "(", ")", "\n", "var_labels", "=", "tuple", "(", "f\"x{i}\"", "for", "i", "in", "range", "(", "0", ",", "n_vars", ")", ")", "\n", "variables", "=", "list", "(", "map", "(", "Variable", ",", "var_labels", ")", ")", "\n", "\n", "for", "pred", "in", "range", "(", "n_preds", ")", ":", "\n", "        ", "model", "[", "f\"P{pred}\"", "]", "=", "Predicate", "(", "arity", "=", "n_vars", ")", "\n", "\n", "", "preds", "=", "[", "model", "[", "f\"P{pred}\"", "]", "(", "*", "variables", ")", "for", "pred", "in", "range", "(", "n_preds", ")", "]", "\n", "model", "[", "\"AB\"", "]", "=", "And", "(", "*", "preds", ")", "\n", "\n", "# set model facts", "\n", "for", "pred", "in", "range", "(", "n_preds", ")", ":", "\n", "\n", "        ", "test_case", "=", "{", "(", "f\"{row}\"", ",", ")", "*", "n_vars", ":", "truth", "[", "pred", "]", "for", "row", ",", "truth", "in", "enumerate", "(", "TT", ")", "}", "\n", "model", ".", "add_facts", "(", "{", "f\"P{pred}\"", ":", "test_case", "}", ")", "\n", "\n", "# inference", "\n", "", "model", "[", "\"AB\"", "]", ".", "upward", "(", ")", "\n", "\n", "# evaluate the conjunction", "\n", "for", "row", "in", "range", "(", "len", "(", "TT", ")", ")", ":", "\n", "        ", "state", "=", "(", "str", "(", "row", ")", ",", ")", "*", "n_vars", "\n", "prediction", "=", "model", "[", "\"AB\"", "]", ".", "state", "(", "state", ")", "\n", "assert", "prediction", "is", "bool_to_fact", "(", "\n", "GT", "[", "row", "]", "\n", ")", ",", "f\"And({TT[row]}) expected {GT}, received {prediction}\"", "\n", "", "print", "(", "\"success\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.source.conf.docstring": [[57, 63], ["commonmark.Parser().parse", "commonmark.ReStructuredTextRenderer().render", "lines.clear", "commonmark.ReStructuredTextRenderer().render.splitlines", "commonmark.Parser", "commonmark.ReStructuredTextRenderer"], "function", ["home.repos.pwc.inspect_result.IBM_LNN.lnn._utils.UniqueNameAssumption.clear"], ["def", "docstring", "(", "app", ",", "what", ",", "name", ",", "obj", ",", "options", ",", "lines", ")", ":", "\n", "    ", "md", "=", "\"\\n\"", ".", "join", "(", "lines", ")", "\n", "ast", "=", "commonmark", ".", "Parser", "(", ")", ".", "parse", "(", "md", ")", "\n", "rst", "=", "commonmark", ".", "ReStructuredTextRenderer", "(", ")", ".", "render", "(", "ast", ")", "\n", "lines", ".", "clear", "(", ")", "\n", "lines", "+=", "rst", ".", "splitlines", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.IBM_LNN.source.conf.setup": [[65, 67], ["app.connect"], "function", ["None"], ["", "def", "setup", "(", "app", ")", ":", "\n", "    ", "app", ".", "connect", "(", "\"autodoc-process-docstring\"", ",", "docstring", ")", "\n", "", ""]]}