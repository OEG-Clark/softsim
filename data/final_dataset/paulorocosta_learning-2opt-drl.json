{"home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.create_tour": [[6, 19], ["random.sample", "list", "range"], "function", ["None"], ["def", "create_tour", "(", "N", ")", ":", "\n", "    ", "\"\"\"\n    Create an initial tour for the TSP\n\n    :param int tour_length: Tour length\n    :param bool rand:  Generate random tour\n\n    :return: list with a TSP tour\n    \"\"\"", "\n", "\n", "tour", "=", "random", ".", "sample", "(", "range", "(", "N", ")", ",", "N", ")", "\n", "\n", "return", "list", "(", "tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.calculate_distances": [[21, 35], ["scipy.spatial.distance_matrix"], "function", ["None"], ["", "def", "calculate_distances", "(", "positions", ")", ":", "\n", "    ", "\"\"\"\n    Calculate a all distances between poistions\n\n    :param np.array positions: Positions of (tour_len, 2) points\n    :return: list with all distances\n    \"\"\"", "\n", "\n", "# def length(x, y):", "\n", "#     return np.linalg.norm(np.asarray(x) - np.asarray(y))", "\n", "# distances = [[length(x, y) for y in positions] for x in positions]", "\n", "\n", "distances", "=", "distance_matrix", "(", "positions", ",", "positions", ")", "\n", "return", "distances", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.route_distance": [[37, 51], ["int", "int"], "function", ["None"], ["", "def", "route_distance", "(", "tour", ",", "distances", ")", ":", "\n", "    ", "\"\"\"\n    Calculate a tour distance (including 0)\n\n    :param list tour: TSP tour\n    :param list : list with all distances\n    :return dist: Distance of a tour\n    \"\"\"", "\n", "dist", "=", "0", "\n", "prev", "=", "tour", "[", "-", "1", "]", "\n", "for", "node", "in", "tour", ":", "\n", "        ", "dist", "+=", "distances", "[", "int", "(", "prev", ")", "]", "[", "int", "(", "node", ")", "]", "\n", "prev", "=", "node", "\n", "", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.swap_2opt": [[53, 74], ["numpy.append", "numpy.append", "list", "numpy.flip", "int", "len", "len"], "function", ["None"], ["", "def", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Swaps two edges by reversing a section of nodes\n\n    :param list tour: TSP tour\n    :param int i: First index for the swap\n    :param int j: Second index for the swap\n    \"\"\"", "\n", "# assert tour[0] == 0 and tour[-1] != 0", "\n", "if", "k", "<=", "i", ":", "\n", "        ", "i_a", "=", "i", "\n", "i", "=", "k", "\n", "k", "=", "i_a", "\n", "", "assert", "i", ">=", "0", "and", "i", "<", "(", "len", "(", "tour", ")", "-", "1", ")", "\n", "assert", "k", ">=", "i", "and", "k", "<", "len", "(", "tour", ")", "\n", "new_tour", "=", "tour", "[", "0", ":", "i", "]", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "np", ".", "flip", "(", "tour", "[", "i", ":", "k", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "tour", "[", "k", "+", "1", ":", "]", ")", "\n", "# assert len(new_tour) == len(tour)", "\n", "new_tour", "=", "[", "int", "(", "i", ")", "for", "i", "in", "new_tour", "]", "\n", "return", "list", "(", "new_tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.heuristic_2opt_fi": [[76, 120], ["new_mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "new_mp_utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "new_mp_utils.swap_2opt", "new_mp_utils.route_distance", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_fi", "(", "positions", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "best_tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "break", "\n", "", "", "if", "improvement", ":", "\n", "                ", "break", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "return", "best_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.heuristic_2opt_bi": [[122, 168], ["new_mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "new_mp_utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "new_mp_utils.swap_2opt", "new_mp_utils.route_distance", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_bi", "(", "positions", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "# print(\"i,j\", i,k)", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "", "", "", "tour", "=", "best_tour", "\n", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "# return best_tour, best_distance/10000", "\n", "\n", "return", "best_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.heuristic_2opt_fi_restart": [[170, 217], ["new_mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "new_mp_utils.route_distance", "range", "range", "len", "len", "range", "range", "new_mp_utils.create_tour", "len", "len", "len", "new_mp_utils.swap_2opt", "new_mp_utils.route_distance", "len"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_fi_restart", "(", "positions", ",", "steps", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "restart_distance", "=", "best_distance", "\n", "# print(\"initial distance\", best_distance)", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "tour", "=", "new_tour", "\n", "break", "\n", "", "", "if", "improvement", ":", "\n", "                ", "break", "\n", "", "", "if", "improvement", "is", "False", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "tour", "=", "create_tour", "(", "len", "(", "tour", ")", ")", "\n", "best_distance", "=", "1e10", "\n", "", "if", "n", "==", "steps", "-", "1", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "return", "restart_distance", "/", "10000", "\n", "# return_dict[procnum] = restart_tour, restart_distance/10000", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.new_mp_utils.heuristic_2opt_bi_restart": [[221, 277], ["new_mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "new_mp_utils.route_distance", "range", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "new_mp_utils.create_tour", "len", "len", "len", "new_mp_utils.swap_2opt", "new_mp_utils.route_distance", "len", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_bi_restart", "(", "positions", ",", "steps", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "restart_distance", "=", "best_distance", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "", "", "", "tour", "=", "best_tour", "\n", "if", "improvement", "is", "False", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "tour", "=", "create_tour", "(", "len", "(", "tour", ")", ")", "\n", "best_distance", "=", "1e10", "\n", "", "if", "n", "==", "steps", "-", "1", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "return", "restart_distance", "/", "10000", "\n", "# return_dict[procnum] = restart_tour, restart_distance/10000", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.istarmap.istarmap": [[5, 26], ["multiprocessing.Pool._get_tasks", "multiprocessing.IMapIterator", "istarmap.._taskqueue.put", "ValueError", "ValueError", "istarmap.._guarded_task_generation"], "function", ["None"], ["def", "istarmap", "(", "self", ",", "func", ",", "iterable", ",", "chunksize", "=", "1", ")", ":", "\n", "    ", "\"\"\"starmap-version of imap\n    \"\"\"", "\n", "if", "self", ".", "_state", "!=", "mpp", ".", "RUN", ":", "\n", "        ", "raise", "ValueError", "(", "\"Pool not running\"", ")", "\n", "\n", "", "if", "chunksize", "<", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Chunksize must be 1+, not {0:n}\"", ".", "format", "(", "\n", "chunksize", ")", ")", "\n", "\n", "", "task_batches", "=", "mpp", ".", "Pool", ".", "_get_tasks", "(", "func", ",", "iterable", ",", "chunksize", ")", "\n", "result", "=", "mpp", ".", "IMapIterator", "(", "self", ".", "_cache", ")", "\n", "self", ".", "_taskqueue", ".", "put", "(", "\n", "(", "\n", "self", ".", "_guarded_task_generation", "(", "result", ".", "_job", ",", "\n", "mpp", ".", "starmapstar", ",", "\n", "task_batches", ")", ",", "\n", "result", ".", "_set_length", "\n", ")", ")", "\n", "return", "(", "item", "for", "chunk", "in", "result", "for", "item", "in", "chunk", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.create_tour": [[6, 19], ["random.sample", "list", "range"], "function", ["None"], ["def", "create_tour", "(", "N", ")", ":", "\n", "    ", "\"\"\"\n    Create an initial tour for the TSP\n\n    :param int tour_length: Tour length\n    :param bool rand:  Generate random tour\n\n    :return: list with a TSP tour\n    \"\"\"", "\n", "\n", "tour", "=", "random", ".", "sample", "(", "range", "(", "N", ")", ",", "N", ")", "\n", "\n", "return", "list", "(", "tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.calculate_distances": [[21, 35], ["scipy.spatial.distance_matrix"], "function", ["None"], ["", "def", "calculate_distances", "(", "positions", ")", ":", "\n", "    ", "\"\"\"\n    Calculate a all distances between poistions\n\n    :param np.array positions: Positions of (tour_len, 2) points\n    :return: list with all distances\n    \"\"\"", "\n", "\n", "# def length(x, y):", "\n", "#     return np.linalg.norm(np.asarray(x) - np.asarray(y))", "\n", "# distances = [[length(x, y) for y in positions] for x in positions]", "\n", "\n", "distances", "=", "distance_matrix", "(", "positions", ",", "positions", ")", "\n", "return", "distances", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.route_distance": [[37, 51], ["int", "int"], "function", ["None"], ["", "def", "route_distance", "(", "tour", ",", "distances", ")", ":", "\n", "    ", "\"\"\"\n    Calculate a tour distance (including 0)\n\n    :param list tour: TSP tour\n    :param list : list with all distances\n    :return dist: Distance of a tour\n    \"\"\"", "\n", "dist", "=", "0", "\n", "prev", "=", "tour", "[", "-", "1", "]", "\n", "for", "node", "in", "tour", ":", "\n", "        ", "dist", "+=", "distances", "[", "int", "(", "prev", ")", "]", "[", "int", "(", "node", ")", "]", "\n", "prev", "=", "node", "\n", "", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.swap_2opt": [[53, 74], ["numpy.append", "numpy.append", "list", "numpy.flip", "int", "len", "len"], "function", ["None"], ["", "def", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Swaps two edges by reversing a section of nodes\n\n    :param list tour: TSP tour\n    :param int i: First index for the swap\n    :param int j: Second index for the swap\n    \"\"\"", "\n", "# assert tour[0] == 0 and tour[-1] != 0", "\n", "if", "k", "<=", "i", ":", "\n", "        ", "i_a", "=", "i", "\n", "i", "=", "k", "\n", "k", "=", "i_a", "\n", "", "assert", "i", ">=", "0", "and", "i", "<", "(", "len", "(", "tour", ")", "-", "1", ")", "\n", "assert", "k", ">=", "i", "and", "k", "<", "len", "(", "tour", ")", "\n", "new_tour", "=", "tour", "[", "0", ":", "i", "]", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "np", ".", "flip", "(", "tour", "[", "i", ":", "k", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "tour", "[", "k", "+", "1", ":", "]", ")", "\n", "# assert len(new_tour) == len(tour)", "\n", "new_tour", "=", "[", "int", "(", "i", ")", "for", "i", "in", "new_tour", "]", "\n", "return", "list", "(", "new_tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.heuristic_2opt_fi": [[76, 121], ["mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "mp_utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "print", "range", "len", "len", "range", "range", "len", "len", "len", "mp_utils.swap_2opt", "mp_utils.route_distance", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_fi", "(", "positions", ",", "procnum", ",", "return_dict", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "best_tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "break", "\n", "", "", "if", "improvement", ":", "\n", "                ", "break", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "print", "(", "\"done\"", ")", "\n", "return_dict", "[", "procnum", "]", "=", "best_tour", ",", "best_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.heuristic_2opt_bi": [[123, 169], ["mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "mp_utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "mp_utils.swap_2opt", "mp_utils.route_distance", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_bi", "(", "positions", ",", "procnum", ",", "return_dict", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "# print(\"i,j\", i,k)", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "", "", "", "tour", "=", "best_tour", "\n", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "# return best_tour, best_distance/10000", "\n", "\n", "return_dict", "[", "procnum", "]", "=", "best_tour", ",", "best_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.heuristic_2opt_fi_restart": [[171, 219], ["mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "mp_utils.route_distance", "range", "range", "len", "len", "range", "range", "mp_utils.create_tour", "len", "len", "len", "mp_utils.swap_2opt", "mp_utils.route_distance", "len"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_fi_restart", "(", "positions", ",", "steps", ",", "procnum", ",", "return_dict", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "restart_distance", "=", "best_distance", "\n", "# print(\"initial distance\", best_distance)", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "tour", "=", "new_tour", "\n", "break", "\n", "", "", "if", "improvement", ":", "\n", "                ", "break", "\n", "", "", "if", "improvement", "is", "False", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "tour", "=", "create_tour", "(", "len", "(", "tour", ")", ")", "\n", "best_distance", "=", "1e10", "\n", "", "if", "n", "==", "steps", "-", "1", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "# return restart_tour, restart_distance/10000", "\n", "return_dict", "[", "procnum", "]", "=", "restart_tour", ",", "restart_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.mp_utils.heuristic_2opt_bi_restart": [[222, 279], ["mp_utils.calculate_distances", "numpy.rint", "distances.astype.astype", "mp_utils.route_distance", "range", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "mp_utils.create_tour", "len", "len", "len", "mp_utils.swap_2opt", "mp_utils.route_distance", "len", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_bi_restart", "(", "positions", ",", "steps", ",", "procnum", ",", "return_dict", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "restart_distance", "=", "best_distance", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "", "", "", "tour", "=", "best_tour", "\n", "if", "improvement", "is", "False", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "tour", "=", "create_tour", "(", "len", "(", "tour", ")", ")", "\n", "best_distance", "=", "1e10", "\n", "", "if", "n", "==", "steps", "-", "1", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "# return restart_tour, restart_distance/10000", "\n", "return_dict", "[", "procnum", "]", "=", "restart_tour", ",", "restart_distance", "/", "10000", "\n", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.GenerateOptimalSolutions.GenerateOptimalTSP.__init__": [[12, 20], ["GenerateOptimalSolutions.GenerateOptimalTSP.generate_data", "numpy.random.seed"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.generate_data"], ["def", "__init__", "(", "self", ",", "data_size", ",", "n_points", ",", "solve", "=", "True", ",", "\n", "seed", "=", "12345", ")", ":", "\n", "        ", "self", ".", "data_size", "=", "data_size", "\n", "self", ".", "n_points", "=", "n_points", "\n", "self", ".", "solve", "=", "solve", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "data", "=", "self", ".", "generate_data", "(", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.GenerateOptimalSolutions.GenerateOptimalTSP.generate_data": [[21, 63], ["tqdm.tqdm.tqdm", "enumerate", "tqdm.tqdm.tqdm", "pandas.DataFrame", "pandas.DataFrame.to_json", "range", "tqdm.tqdm.tqdm.set_description", "numpy.random.random", "points_list.append", "enumerate", "tqdm.tqdm.tqdm.set_description", "concorde.tsp.TSPSolver.from_data", "concorde.tsp.TSPSolver.from_data.solve", "solutions.append", "opt_dists.append", "str", "len"], "methods", ["None"], ["", "def", "generate_data", "(", "self", ")", ":", "\n", "\n", "        ", "points_list", "=", "[", "]", "\n", "solutions", "=", "[", "]", "\n", "opt_dists", "=", "[", "]", "\n", "\n", "data_iter", "=", "tqdm", "(", "range", "(", "self", ".", "data_size", ")", ",", "unit", "=", "'data'", ")", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "data_iter", ")", ":", "\n", "            ", "data_iter", ".", "set_description", "(", "'Generating data points %i/%i'", "\n", "%", "(", "i", "+", "1", ",", "self", ".", "data_size", ")", ")", "\n", "\n", "points", "=", "np", ".", "random", ".", "random", "(", "(", "self", ".", "n_points", ",", "2", ")", ")", "\n", "\n", "points_list", ".", "append", "(", "points", ")", "\n", "\n", "# solutions_iter: for tqdm", "\n", "", "solutions_iter", "=", "tqdm", "(", "points_list", ",", "unit", "=", "'solve'", ")", "\n", "if", "self", ".", "solve", ":", "\n", "            ", "for", "i", ",", "points", "in", "enumerate", "(", "solutions_iter", ")", ":", "\n", "                ", "solutions_iter", ".", "set_description", "(", "'Solved %i/%i'", "\n", "%", "(", "i", "+", "1", ",", "len", "(", "points_list", ")", ")", ")", "\n", "\n", "points_scaled", "=", "points", "*", "10000", "\n", "solver", "=", "TSPSolver", ".", "from_data", "(", "points_scaled", "[", ":", ",", "0", "]", ",", "\n", "points_scaled", "[", ":", ",", "1", "]", ",", "\n", "'EUC_2D'", ")", "\n", "\n", "sol", "=", "solver", ".", "solve", "(", "time_bound", "=", "-", "1", ",", "verbose", "=", "True", ")", "\n", "\n", "opt_tour", ",", "opt_dist", "=", "sol", ".", "tour", ",", "sol", ".", "optimal_value", "/", "10000", "\n", "solutions", ".", "append", "(", "opt_tour", ")", "\n", "opt_dists", ".", "append", "(", "opt_dist", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "solutions", "=", "None", "\n", "opt_dists", "=", "None", "\n", "\n", "", "data", "=", "{", "'Points'", ":", "points_list", ",", "\n", "'OptTour'", ":", "solutions", ",", "\n", "'OptDistance'", ":", "opt_dists", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ")", "\n", "df", ".", "to_json", "(", "path_or_buf", "=", "'data/data_test'", "+", "str", "(", "self", ".", "n_points", ")", "+", "'.json'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.TSPDataset.__init__": [[21, 36], ["torch.utils.data.Dataset.__init__", "len", "open", "pickle.load", "torch.FloatTensor().uniform_", "os.path.splitext", "torch.FloatTensor", "range", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["    ", "def", "__init__", "(", "self", ",", "filename", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "1000000", ",", "offset", "=", "0", ",", "distribution", "=", "None", ")", ":", "\n", "        ", "super", "(", "TSPDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "if", "filename", "is", "not", "None", ":", "\n", "            ", "assert", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "==", "'.pkl'", "\n", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "self", ".", "data", "=", "[", "torch", ".", "FloatTensor", "(", "row", ")", "for", "row", "in", "(", "data", "[", "offset", ":", "offset", "+", "num_samples", "]", ")", "]", "\n", "", "", "else", ":", "\n", "# Sample points randomly in [0, 1] square", "\n", "            ", "self", ".", "data", "=", "[", "torch", ".", "FloatTensor", "(", "size", ",", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "for", "i", "in", "range", "(", "num_samples", ")", "]", "\n", "\n", "", "self", ".", "size", "=", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.TSPDataset.__len__": [[37, 39], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.TSPDataset.__getitem__": [[40, 42], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data", "[", "idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.check_extension": [[7, 11], ["os.path.splitext"], "function", ["None"], ["def", "check_extension", "(", "filename", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "1", "]", "!=", "\".pkl\"", ":", "\n", "        ", "return", "filename", "+", "\".pkl\"", "\n", "", "return", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.load_dataset": [[13, 17], ["open", "pickle.load", "att_paper_utils.check_extension"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.check_extension"], ["", "def", "load_dataset", "(", "filename", ")", ":", "\n", "\n", "    ", "with", "open", "(", "check_extension", "(", "filename", ")", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "return", "pickle", ".", "load", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.make_dataset": [[44, 46], ["att_paper_utils.TSPDataset"], "function", ["None"], ["", "", "def", "make_dataset", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "TSPDataset", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph.__init__": [[15, 51], ["matplotlib.figure", "matplotlib.figure.suptitle", "matplotlib.subplot2grid", "matplotlib.subplot2grid", "matplotlib.subplot2grid", "matplotlib.subplots_adjust"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "window_size", "=", "10", ",", "time", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Initialise TSP matplotlib Graphs\n\n        :param int window_size: window size of the distances\n        \"\"\"", "\n", "\n", "self", ".", "window_size", "=", "window_size", "\n", "# create a figure on screen and set the title", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "fig", ".", "suptitle", "(", "'TSP'", ")", "\n", "# create top subplot for net worth axis", "\n", "self", ".", "best_distance_ax", "=", "plt", ".", "subplot2grid", "(", "(", "12", ",", "1", ")", ",", "\n", "(", "0", ",", "0", ")", ",", "\n", "rowspan", "=", "2", ",", "\n", "colspan", "=", "1", ")", "\n", "\n", "# create bottom subplot for TSP plots", "\n", "self", ".", "tour_ax", "=", "plt", ".", "subplot2grid", "(", "(", "12", ",", "1", ")", ",", "\n", "(", "3", ",", "0", ")", ",", "\n", "rowspan", "=", "4", ",", "\n", "colspan", "=", "1", ")", "\n", "\n", "# create 2nd bottom subplot for TSP plots", "\n", "self", ".", "best_tour_ax", "=", "plt", ".", "subplot2grid", "(", "(", "12", ",", "1", ")", ",", "\n", "(", "8", ",", "0", ")", ",", "\n", "rowspan", "=", "4", ",", "\n", "colspan", "=", "1", ")", "\n", "\n", "# add padding to make graph easier to view", "\n", "plt", ".", "subplots_adjust", "(", "left", "=", "0.11", ",", "\n", "bottom", "=", "0.24", ",", "\n", "right", "=", "0.90", ",", "\n", "top", "=", "0.90", ",", "\n", "wspace", "=", "0.2", ",", "\n", "hspace", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph._render_distances": [[54, 109], ["TSPGraph.TSPGraph.best_distance_ax.clear", "TSPGraph.TSPGraph.best_distance_ax.plot", "TSPGraph.TSPGraph.best_distance_ax.plot", "TSPGraph.TSPGraph.best_distance_ax.legend", "TSPGraph.TSPGraph.best_distance_ax.legend", "TSPGraph.TSPGraph.get_frame().set_alpha", "TSPGraph.TSPGraph.best_distance_ax.annotate", "TSPGraph.TSPGraph.best_distance_ax.annotate", "TSPGraph.TSPGraph.best_distance_ax.set_ylim", "max", "TSPGraph.TSPGraph.get_frame", "dict", "dict", "numpy.maximum"], "methods", ["None"], ["", "def", "_render_distances", "(", "self", ",", "step_range", ")", ":", "\n", "        ", "\"\"\"\n        Render distances\n\n        :param list step_range: Steps to consider from the episode\n        \"\"\"", "\n", "\n", "# clear the frame rendered last step", "\n", "self", ".", "best_distance_ax", ".", "clear", "(", ")", "\n", "self", ".", "best_distances", "=", "[", "x", "/", "10000", "for", "x", "in", "self", ".", "best_distances", "]", "\n", "self", ".", "current_distances", "=", "[", "x", "/", "10000", "for", "x", "in", "self", ".", "current_distances", "]", "\n", "# plot the distances", "\n", "self", ".", "best_distance_ax", ".", "plot", "(", "step_range", ",", "\n", "self", ".", "best_distances", ",", "\n", "'-'", ",", "label", "=", "'Best Distance'", ",", "\n", "color", "=", "\"darkred\"", ")", "\n", "self", ".", "best_distance_ax", ".", "plot", "(", "step_range", ",", "\n", "self", ".", "current_distances", ",", "\n", "'-'", ",", "label", "=", "'Current Distance'", ",", "color", "=", "\"black\"", ")", "\n", "\n", "# show legend, which uses the labels defined above", "\n", "self", ".", "best_distance_ax", ".", "legend", "(", ")", "\n", "legend", "=", "self", ".", "best_distance_ax", ".", "legend", "(", "loc", "=", "0", ",", "ncol", "=", "2", ",", "prop", "=", "{", "'size'", ":", "8", "}", ")", "\n", "legend", ".", "get_frame", "(", ")", ".", "set_alpha", "(", "0.4", ")", "\n", "\n", "# save the last seen distance and the last step", "\n", "last_distance", "=", "self", ".", "current_distances", "[", "-", "1", "]", "\n", "best_distance", "=", "self", ".", "best_distances", "[", "-", "1", "]", "\n", "last_step", "=", "self", ".", "step_range", "[", "-", "1", "]", "\n", "\n", "# annotate the current distance on the graph", "\n", "self", ".", "best_distance_ax", ".", "annotate", "(", "'{0:.2f}'", ".", "format", "(", "last_distance", ")", ",", "\n", "(", "last_step", ",", "last_distance", ")", ",", "\n", "xytext", "=", "(", "last_step", ",", "last_distance", ")", ",", "\n", "bbox", "=", "dict", "(", "boxstyle", "=", "'round'", ",", "\n", "fc", "=", "'w'", ",", "ec", "=", "'k'", ",", "lw", "=", "1", ")", ",", "\n", "color", "=", "\"black\"", ",", "\n", "fontsize", "=", "8", ")", "\n", "\n", "\n", "# annotate the current distance on the graph", "\n", "\n", "self", ".", "best_distance_ax", ".", "annotate", "(", "'{0:.2f}'", ".", "format", "(", "best_distance", ")", ",", "\n", "(", "last_step", ",", "best_distance", ")", ",", "\n", "xytext", "=", "(", "last_step", ",", "best_distance", ")", ",", "\n", "bbox", "=", "dict", "(", "boxstyle", "=", "'round'", ",", "\n", "fc", "=", "'w'", ",", "ec", "=", "'k'", ",", "lw", "=", "1", ")", ",", "\n", "color", "=", "\"darkred\"", ",", "\n", "fontsize", "=", "8", ")", "\n", "\n", "\n", "# Add space above \"max distance\"", "\n", "self", ".", "best_distance_ax", ".", "set_ylim", "(", "0", ",", "\n", "max", "(", "np", ".", "maximum", "(", "self", ".", "best_distances", ",", "\n", "self", ".", "current_distances", ")", "*", "2", ")", ")", "\n", "# plt.show(block=False)", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph._render_tour": [[111, 185], ["axis.clear", "axis.scatter", "axis.scatter", "len", "range", "axis.annotate", "numpy.linalg.norm", "dict", "axis.text", "axis.annotate", "numpy.linalg.norm", "range", "dict", "dict"], "methods", ["None"], ["", "def", "_render_tour", "(", "self", ",", "positions", ",", "axis", ")", ":", "\n", "        ", "\"\"\"\n        Render TSP solutions in 2D\n\n        :param np.array positions: Positions of (tour_len, 2) points\n        \"\"\"", "\n", "# clear the frame rendered last step", "\n", "# self.tour_ax.clear()", "\n", "axis", ".", "clear", "(", ")", "\n", "# transform positions to np array", "\n", "# solution is eq. to traversing the graph in order", "\n", "solution", "=", "[", "x", "for", "x", "in", "range", "(", "positions", ".", "shape", "[", "0", "]", ")", "]", "\n", "\n", "# plot scatters - red: depot", "\n", "# self.tour_ax.scatter(positions[:, 0], positions[:, 1])", "\n", "# self.tour_ax.scatter(positions[0, 0], positions[0, 1], color='darkred')", "\n", "\n", "\n", "axis", ".", "scatter", "(", "positions", "[", ":", ",", "0", "]", ",", "positions", "[", ":", ",", "1", "]", ")", "\n", "axis", ".", "scatter", "(", "positions", "[", "0", ",", "0", "]", ",", "positions", "[", "0", ",", "1", "]", ",", "color", "=", "'darkred'", ")", "\n", "\n", "#plot segments connecting the nodes and calculate tour distance", "\n", "start_node", "=", "0", "\n", "distance", "=", "0.", "\n", "N", "=", "len", "(", "solution", ")", "\n", "for", "i", "in", "range", "(", "N", "-", "1", ")", ":", "\n", "\n", "            ", "start_pos", "=", "positions", "[", "start_node", "]", "\n", "next_node", "=", "solution", "[", "i", "+", "1", "]", "\n", "end_pos", "=", "positions", "[", "next_node", "]", "\n", "\n", "# self.tour_ax.annotate(\"\",", "\n", "#                       xy=start_pos, xycoords='data',", "\n", "#                       xytext=end_pos, textcoords='data',", "\n", "#                       arrowprops=dict(arrowstyle=\"-\",", "\n", "#                                       connectionstyle=\"arc3\"))", "\n", "\n", "axis", ".", "annotate", "(", "\"\"", ",", "\n", "xy", "=", "start_pos", ",", "xycoords", "=", "'data'", ",", "\n", "xytext", "=", "end_pos", ",", "textcoords", "=", "'data'", ",", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "\"-\"", ",", "\n", "connectionstyle", "=", "\"arc3\"", ")", ")", "\n", "\n", "distance", "+=", "np", ".", "linalg", ".", "norm", "(", "end_pos", "-", "start_pos", ")", "\n", "start_node", "=", "next_node", "\n", "\n", "# self.tour_ax.annotate(\"\",", "\n", "#                       xy=positions[start_node], xycoords='data',", "\n", "#                       xytext=positions[0], textcoords='data',", "\n", "#                       arrowprops=dict(arrowstyle=\"-\",", "\n", "#                                       connectionstyle=\"arc3\"))", "\n", "", "axis", ".", "annotate", "(", "\"\"", ",", "\n", "xy", "=", "positions", "[", "start_node", "]", ",", "xycoords", "=", "'data'", ",", "\n", "xytext", "=", "positions", "[", "0", "]", ",", "textcoords", "=", "'data'", ",", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "\"-\"", ",", "\n", "connectionstyle", "=", "\"arc3\"", ")", ")", "\n", "\n", "distance", "+=", "np", ".", "linalg", ".", "norm", "(", "positions", "[", "start_node", "]", "-", "positions", "[", "0", "]", ")", "\n", "textstr", "=", "\"N nodes: %d\\nTotal length: %.2f\"", "%", "(", "N", ",", "distance", ")", "\n", "props", "=", "dict", "(", "boxstyle", "=", "'round'", ",", "facecolor", "=", "'wheat'", ",", "alpha", "=", "0.5", ")", "\n", "# self.tour_ax.text(0.05, 0.95,", "\n", "#                   textstr,", "\n", "#                   transform=self.tour_ax.transAxes,", "\n", "#                   fontsize=\"small\",", "\n", "#                   verticalalignment='top',", "\n", "#                   bbox=props)", "\n", "\n", "\n", "axis", ".", "text", "(", "0.05", ",", "0.95", ",", "\n", "textstr", ",", "\n", "transform", "=", "axis", ".", "transAxes", ",", "\n", "fontsize", "=", "\"small\"", ",", "\n", "verticalalignment", "=", "'top'", ",", "\n", "bbox", "=", "props", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph.render": [[187, 225], ["numpy.zeros", "numpy.zeros", "max", "range", "slice", "TSPGraph.TSPGraph._render_distances", "TSPGraph.TSPGraph._render_tour", "TSPGraph.TSPGraph._render_tour", "TSPGraph.TSPGraph.tour_ax.set_title", "TSPGraph.TSPGraph.best_tour_ax.set_title", "TSPGraph.TSPGraph.tour_ax.get_xaxis().set_visible", "matplotlib.setp", "matplotlib.pause", "TSPGraph.TSPGraph.best_distance_ax.get_xticklabels", "TSPGraph.TSPGraph.tour_ax.get_xaxis"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph._render_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph._render_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph._render_tour"], ["", "def", "render", "(", "self", ",", "\n", "current_step", ",", "\n", "best_distances", ",", "\n", "current_distances", ",", "\n", "state", ",", "\n", "best_state", ")", ":", "\n", "        ", "\"\"\"\n        Render TSP distances and solutions in 2D\n\n        :param int current_step: current episode step\n        :param list best_distances: best distances found in an episode\n        :param list current_distances: current distances in an episode\n        :param torch.tensor state: positions of (tour_len, 2) points\n        \"\"\"", "\n", "\n", "self", ".", "best_distances", "=", "np", ".", "zeros", "(", "self", ".", "window_size", ")", "\n", "self", ".", "current_distances", "=", "np", ".", "zeros", "(", "self", ".", "window_size", ")", "\n", "\n", "window_start", "=", "max", "(", "current_step", "-", "self", ".", "window_size", ",", "0", ")", "\n", "self", ".", "step_range", "=", "range", "(", "window_start", ",", "current_step", "+", "1", ")", "\n", "s", "=", "slice", "(", "window_start", ",", "current_step", "+", "1", ")", "\n", "self", ".", "best_distances", "=", "best_distances", "[", "s", "]", "\n", "self", ".", "current_distances", "=", "current_distances", "[", "s", "]", "\n", "\n", "self", ".", "_render_distances", "(", "self", ".", "step_range", ")", "\n", "self", ".", "_render_tour", "(", "state", ",", "self", ".", "tour_ax", ")", "\n", "self", ".", "_render_tour", "(", "best_state", ",", "self", ".", "best_tour_ax", ")", "\n", "\n", "self", ".", "tour_ax", ".", "set_title", "(", "'Current Tour'", ",", "fontsize", "=", "8", ")", "\n", "self", ".", "best_tour_ax", ".", "set_title", "(", "'Best Tour'", ",", "fontsize", "=", "8", ")", "\n", "# hide duplicate labels", "\n", "\n", "self", ".", "tour_ax", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "plt", ".", "setp", "(", "self", ".", "best_distance_ax", ".", "get_xticklabels", "(", ")", ",", "visible", "=", "False", ")", "\n", "# self.fig.canvas.draw()", "\n", "# Necessary to view frames before they are unrendered", "\n", "# plt.show(block=False)", "\n", "plt", ".", "pause", "(", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPGraph.TSPGraph.close": [[229, 231], ["matplotlib.close"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.close"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "plt", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaper.GenerateOptimalTSP.__init__": [[18, 24], ["att_paper_utils.make_dataset", "len", "OptimalAttentionPaper.GenerateOptimalTSP.generate_data"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.make_dataset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.generate_data"], ["def", "__init__", "(", "self", ",", "data_path", ",", "n_points", ",", "solve", "=", "True", ")", ":", "\n", "        ", "self", ".", "data", "=", "utils", ".", "make_dataset", "(", "filename", "=", "data_path", ")", "\n", "self", ".", "data_size", "=", "len", "(", "self", ".", "data", ")", "\n", "self", ".", "n_points", "=", "n_points", "\n", "self", ".", "solve", "=", "solve", "\n", "self", ".", "generate_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaper.GenerateOptimalTSP.generate_data": [[25, 69], ["tqdm.tqdm.tqdm", "enumerate", "tqdm.tqdm.tqdm", "pandas.DataFrame", "pandas.DataFrame.to_json", "range", "tqdm.tqdm.tqdm.set_description", "numpy.array", "points_list.append", "enumerate", "print", "tqdm.tqdm.tqdm.set_description", "concorde.tsp.TSPSolver.from_data", "concorde.tsp.TSPSolver.from_data.solve", "solutions.append", "opt_dists.append", "numpy.mean", "numpy.sqrt", "len", "numpy.std", "len", "str"], "methods", ["None"], ["", "def", "generate_data", "(", "self", ")", ":", "\n", "\n", "        ", "points_list", "=", "[", "]", "\n", "solutions", "=", "[", "]", "\n", "opt_dists", "=", "[", "]", "\n", "\n", "data_iter", "=", "tqdm", "(", "range", "(", "self", ".", "data_size", ")", ",", "unit", "=", "'data'", ")", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "data_iter", ")", ":", "\n", "            ", "data_iter", ".", "set_description", "(", "'Generating data points %i/%i'", "\n", "%", "(", "i", "+", "1", ",", "self", ".", "data_size", ")", ")", "\n", "\n", "points", "=", "np", ".", "array", "(", "self", ".", "data", "[", "i", "]", ")", "\n", "\n", "points_list", ".", "append", "(", "points", ")", "\n", "\n", "# solutions_iter: for tqdm", "\n", "", "solutions_iter", "=", "tqdm", "(", "points_list", ",", "unit", "=", "'solve'", ")", "\n", "if", "self", ".", "solve", ":", "\n", "            ", "for", "i", ",", "points", "in", "enumerate", "(", "solutions_iter", ")", ":", "\n", "                ", "solutions_iter", ".", "set_description", "(", "'Solved %i/%i'", "\n", "%", "(", "i", "+", "1", ",", "len", "(", "points_list", ")", ")", ")", "\n", "\n", "points_scaled", "=", "points", "*", "10000", "\n", "solver", "=", "TSPSolver", ".", "from_data", "(", "points_scaled", "[", ":", ",", "0", "]", ",", "\n", "points_scaled", "[", ":", ",", "1", "]", ",", "\n", "'EUC_2D'", ")", "\n", "sol", "=", "solver", ".", "solve", "(", "time_bound", "=", "-", "1", ",", "verbose", "=", "False", ")", "\n", "opt_tour", ",", "opt_dist", "=", "sol", ".", "tour", ",", "sol", ".", "optimal_value", "/", "10000", "\n", "solutions", ".", "append", "(", "opt_tour", ")", "\n", "opt_dists", ".", "append", "(", "opt_dist", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "solutions", "=", "None", "\n", "opt_dists", "=", "None", "\n", "\n", "", "if", "self", ".", "solve", ":", "\n", "\n", "            ", "print", "(", "'  [*] Avg Optimal Tour {:.5f} +- {:.5f}'", ".", "format", "(", "np", ".", "mean", "(", "opt_dists", ")", ",", "2", "*", "np", ".", "std", "(", "opt_dists", ")", "/", "np", ".", "sqrt", "(", "len", "(", "opt_dists", ")", ")", ")", ")", "\n", "\n", "", "data", "=", "{", "'Points'", ":", "points_list", ",", "\n", "'OptTour'", ":", "solutions", ",", "\n", "'OptDistance'", ":", "opt_dists", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ")", "\n", "df", ".", "to_json", "(", "path_or_buf", "=", "'data/att-TSP'", "+", "str", "(", "self", ".", "n_points", ")", "+", "'-data-test'", "+", "'.json'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP20.buffer.__init__": [[192, 200], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "# action & reward buffer", "\n", "        ", "self", ".", "actions", "=", "[", "]", "\n", "self", ".", "states", "=", "[", "]", "\n", "self", ".", "log_probs", "=", "[", "]", "\n", "self", ".", "rewards", "=", "[", "]", "\n", "self", ".", "values", "=", "[", "]", "\n", "self", ".", "entropies", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP20.buffer.clear_buffer": [[201, 208], ["None"], "methods", ["None"], ["", "def", "clear_buffer", "(", "self", ")", ":", "\n", "        ", "del", "self", ".", "actions", "[", ":", "]", "\n", "del", "self", ".", "states", "[", ":", "]", "\n", "del", "self", ".", "log_probs", "[", ":", "]", "\n", "del", "self", ".", "rewards", "[", ":", "]", "\n", "del", "self", ".", "values", "[", ":", "]", "\n", "del", "self", ".", "entropies", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP20.select_action": [[210, 221], ["policy", "buffer.log_probs.append", "buffer.states.append", "buffer.actions.append", "buffer.values.append", "buffer.entropies.append"], "function", ["None"], ["", "", "def", "select_action", "(", "state", ",", "hidden", ",", "buffer", ",", "best_state", ")", ":", "\n", "\n", "    ", "probs", ",", "action", ",", "log_probs_action", ",", "v", ",", "entropy", ",", "hidden", "=", "policy", "(", "state", ",", "\n", "best_state", ",", "\n", "hidden", ")", "\n", "buffer", ".", "log_probs", ".", "append", "(", "log_probs_action", ")", "\n", "buffer", ".", "states", ".", "append", "(", "state", ")", "\n", "buffer", ".", "actions", ".", "append", "(", "action", ")", "\n", "buffer", ".", "values", ".", "append", "(", "v", ")", "\n", "buffer", ".", "entropies", ".", "append", "(", "entropy", ")", "\n", "return", "action", ",", "v", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP20.learn": [[223, 317], ["reversed", "torch.stack().detach", "torch.stack().detach", "torch.stack", "torch.stack", "torch.stack().mean().unsqueeze", "torch.stack().mean().unsqueeze", "torch.stack().mean().unsqueeze", "torch.stack().mean().unsqueeze", "optimizer.zero_grad", "p_loss.backward", "numpy.concatenate", "r_loss.backward", "optimizer.step", "torch.stack().detach.mean", "advantages.mean", "numpy.sqrt", "numpy.max", "numpy.var", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "epoch_train_policy_loss.update", "epoch_train_entropy_loss.update", "epoch_train_value_loss.update", "epoch_train_loss.update", "PGTSP20.buffer.clear_buffer", "epoch_train_policy_loss.reset", "epoch_train_entropy_loss.reset", "epoch_train_value_loss.reset", "epoch_train_loss.reset", "torch.zeros().to", "torch.zeros().to", "range", "torch.stack().detach.insert", "torch.stack().detach.mean", "torch.stack().detach.std", "numpy.finfo().eps.item", "torch.stack().mean().unsqueeze.sum().mean", "numpy.mean", "numpy.abs", "p_loss.item", "v_loss.item", "loss.item", "len", "torch.stack", "torch.stack", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "p.grad.data.cpu().numpy().flatten", "numpy.square", "e_loss.item", "torch.zeros", "torch.zeros", "advantages.detach", "torch.stack().mean().unsqueeze.sum", "policy.parameters", "numpy.finfo", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "p.grad.data.cpu().numpy", "p.grad.data.cpu"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.step", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP50_100.buffer.clear_buffer", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset"], ["", "def", "learn", "(", "R", ",", "t_s", ",", "beta", ",", "zeta", ",", "count_learn", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"\n    Training. Calcultes actor and critic losses and performs backprop.\n    \"\"\"", "\n", "\n", "count_steps", "=", "0", "\n", "sum_returns", "=", "0.0", "\n", "sum_advantage", "=", "0.0", "\n", "sum_loss_actor", "=", "0.0", "\n", "sum_loss_critic", "=", "0.0", "\n", "sum_entropy", "=", "0.0", "\n", "sum_loss_total", "=", "0.0", "\n", "sum_grads_l2", "=", "0.0", "\n", "sum_grads_max", "=", "0.0", "\n", "sum_grads_var", "=", "0.0", "\n", "\n", "# Starting sum of losses for logging", "\n", "if", "t_s", "==", "0", ":", "\n", "        ", "epoch_train_policy_loss", ".", "reset", "(", ")", "\n", "epoch_train_entropy_loss", ".", "reset", "(", ")", "\n", "epoch_train_value_loss", ".", "reset", "(", ")", "\n", "epoch_train_loss", ".", "reset", "(", ")", "\n", "\n", "# Returns", "\n", "", "if", "R", "is", "None", ":", "\n", "        ", "R", "=", "torch", ".", "zeros", "(", "(", "args", ".", "batch_size", ",", "1", ")", ")", ".", "to", "(", "device", ")", "\n", "", "returns", "=", "[", "]", "# returns for each state discounted", "\n", "for", "s", "in", "reversed", "(", "range", "(", "len", "(", "buffer", ".", "rewards", ")", ")", ")", ":", "\n", "        ", "R", "=", "buffer", ".", "rewards", "[", "s", "]", "+", "args", ".", "gamma", "*", "R", "\n", "returns", ".", "insert", "(", "0", ",", "R", ")", "\n", "\n", "", "returns", "=", "torch", ".", "stack", "(", "returns", ")", ".", "detach", "(", ")", "\n", "if", "not", "args", ".", "no_norm_return", ":", "\n", "        ", "r_mean", "=", "returns", ".", "mean", "(", ")", "\n", "r_std", "=", "returns", ".", "std", "(", ")", "\n", "eps", "=", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ".", "item", "(", ")", "# small number to avoid div/0", "\n", "returns", "=", "(", "returns", "-", "r_mean", ")", "/", "(", "r_std", "+", "eps", ")", "\n", "\n", "# num of experiences in this \"batch\" of experiences", "\n", "", "n_experiences", "=", "args", ".", "batch_size", "*", "args", ".", "n", "\n", "# transform lists to tensor", "\n", "values", "=", "torch", ".", "stack", "(", "buffer", ".", "values", ")", "\n", "log_probs", "=", "torch", ".", "stack", "(", "buffer", ".", "log_probs", ")", ".", "mean", "(", "2", ")", ".", "unsqueeze", "(", "2", ")", "\n", "entropies", "=", "torch", ".", "stack", "(", "buffer", ".", "entropies", ")", ".", "mean", "(", "2", ")", ".", "unsqueeze", "(", "2", ")", "\n", "advantages", "=", "returns", "-", "values", "\n", "p_loss", "=", "(", "-", "log_probs", "*", "advantages", ".", "detach", "(", ")", ")", ".", "mean", "(", ")", "\n", "v_loss", "=", "zeta", "*", "(", "returns", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "e_loss", "=", "(", "0.9", "**", "(", "epoch", "+", "1", ")", ")", "*", "beta", "*", "entropies", ".", "sum", "(", "0", ")", ".", "mean", "(", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "p_loss", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "grads", "=", "np", ".", "concatenate", "(", "[", "p", ".", "grad", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "for", "p", "in", "policy", ".", "parameters", "(", ")", "\n", "if", "p", ".", "grad", "is", "not", "None", "]", ")", "\n", "\n", "r_loss", "=", "-", "e_loss", "+", "v_loss", "\n", "\n", "r_loss", ".", "backward", "(", ")", "\n", "# nn.utils.clip_grad_norm_(policy.parameters(), args.max_grad_norm)", "\n", "optimizer", ".", "step", "(", ")", "\n", "loss", "=", "p_loss", "+", "r_loss", "\n", "\n", "# track statistics", "\n", "sum_returns", "+=", "returns", ".", "mean", "(", ")", "\n", "sum_advantage", "+=", "advantages", ".", "mean", "(", ")", "\n", "sum_loss_actor", "+=", "p_loss", "\n", "sum_loss_critic", "+=", "v_loss", "\n", "sum_loss_total", "+=", "loss", "\n", "sum_entropy", "+=", "e_loss", "\n", "\n", "sum_grads_l2", "+=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "np", ".", "square", "(", "grads", ")", ")", ")", "\n", "sum_grads_max", "+=", "np", ".", "max", "(", "np", ".", "abs", "(", "grads", ")", ")", "\n", "sum_grads_var", "+=", "np", ".", "var", "(", "grads", ")", "\n", "\n", "count_steps", "+=", "1", "\n", "\n", "writer", ".", "add_scalar", "(", "\"Returns\"", ",", "sum_returns", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Advantage\"", ",", "sum_advantage", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Actor\"", ",", "sum_loss_actor", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Critic\"", ",", "sum_loss_critic", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Entropy\"", ",", "sum_entropy", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Total\"", ",", "sum_loss_total", "/", "count_steps", ",", "count_learn", ")", "\n", "\n", "writer", ".", "add_scalar", "(", "\"Gradients_L2\"", ",", "sum_grads_l2", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Gradients_Max\"", ",", "sum_grads_max", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Gradients_Var\"", ",", "sum_grads_var", "/", "count_steps", ",", "count_learn", ")", "\n", "\n", "epoch_train_policy_loss", ".", "update", "(", "p_loss", ".", "item", "(", ")", ",", "n_experiences", ")", "\n", "epoch_train_entropy_loss", ".", "update", "(", "e_loss", ".", "item", "(", ")", "/", "args", ".", "n", ",", "n_experiences", ")", "\n", "epoch_train_value_loss", ".", "update", "(", "v_loss", ".", "item", "(", ")", ",", "n_experiences", ")", "\n", "epoch_train_loss", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "n_experiences", ")", "\n", "\n", "buffer", ".", "clear_buffer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.__init__": [[11, 23], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initiate TSP Environment\n\n        :param torch tensor points: points in 2D shape (seq_len, 2)\n        :param int nof_points: seq_len\n        \"\"\"", "\n", "super", "(", "TSPInstanceEnv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "visualization", "=", "None", "\n", "self", ".", "observation_space", "=", "None", "\n", "self", ".", "action_space", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.reset": [[24, 72], ["numpy.copy", "TSPEnvironment.TSPInstanceEnv.tour.copy", "utils.calculate_distances", "numpy.rint", "TSPEnvironment.TSPInstanceEnv.distances.astype", "numpy.copy", "TSPEnvironment.TSPInstanceEnv.tour.copy", "utils.route_distance", "TSPEnvironment.TSPInstanceEnv.keep_tour.copy", "TSPEnvironment.TSPInstanceEnv.reset_tour.copy", "TSPEnvironment.TSPInstanceEnv.hist_best_distance.append", "TSPEnvironment.TSPInstanceEnv.hist_current_distance.append", "TSPEnvironment.TSPInstanceEnv._next_observation"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._next_observation"], ["", "def", "reset", "(", "self", ",", "points", ",", "tour", ",", "T", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Reset the TSP Environment\n        \"\"\"", "\n", "self", ".", "T", "=", "T", "\n", "self", ".", "points", "=", "points", "\n", "self", ".", "state", "=", "np", ".", "copy", "(", "self", ".", "points", ")", "\n", "# set the current step to 0", "\n", "self", ".", "current_step", "=", "0", "\n", "self", ".", "n_bad_actions", "=", "0", "\n", "\n", "# initiate memory", "\n", "self", ".", "hist_best_distance", "=", "[", "]", "\n", "self", ".", "hist_current_distance", "=", "[", "]", "\n", "\n", "# tour: list with an initial random tour", "\n", "self", ".", "tour", "=", "tour", "\n", "# reset_tour: list with the initial tour of points", "\n", "self", ".", "reset_tour", "=", "self", ".", "tour", ".", "copy", "(", ")", "\n", "\n", "# distances: list of lists with all distances for points", "\n", "self", ".", "distances", "=", "utils", ".", "calculate_distances", "(", "self", ".", "state", ")", "\n", "self", ".", "distances", "=", "np", ".", "rint", "(", "self", ".", "distances", "*", "10000", ")", "\n", "self", ".", "distances", "=", "self", ".", "distances", ".", "astype", "(", "int", ")", "\n", "\n", "# state: reorder the points with the random tour before starting", "\n", "# this is the initial state", "\n", "self", ".", "state", "=", "self", ".", "state", "[", "self", ".", "tour", ",", ":", "]", "\n", "self", ".", "best_state", "=", "np", ".", "copy", "(", "self", ".", "state", ")", "\n", "# keep_tours: tour for computing distances (invariant to state)", "\n", "self", ".", "keep_tour", "=", "self", ".", "tour", ".", "copy", "(", ")", "\n", "\n", "# tour_distance: distance of the current tour", "\n", "self", ".", "tour_distance", "=", "utils", ".", "route_distance", "(", "self", ".", "keep_tour", ",", "\n", "self", ".", "distances", ")", "\n", "\n", "# current best: save the initial tour (keep_tour) and distance", "\n", "self", ".", "current_best_distance", "=", "self", ".", "tour_distance", "\n", "self", ".", "current_best_tour", "=", "self", ".", "keep_tour", ".", "copy", "(", ")", "\n", "\n", "# before going to the next state tour gets reset", "\n", "self", ".", "tour", "=", "self", ".", "reset_tour", ".", "copy", "(", ")", "\n", "\n", "# update memory", "\n", "self", ".", "hist_best_distance", ".", "append", "(", "self", ".", "current_best_distance", ")", "\n", "self", ".", "hist_current_distance", ".", "append", "(", "self", ".", "tour_distance", ")", "\n", "\n", "return", "self", ".", "_next_observation", "(", ")", ",", "self", ".", "best_state", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._next_observation": [[73, 79], ["None"], "methods", ["None"], ["", "def", "_next_observation", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Next observation of the TSP Environment\n        \"\"\"", "\n", "observation", "=", "self", ".", "state", "\n", "return", "observation", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.step": [[80, 94], ["TSPEnvironment.TSPInstanceEnv._take_action", "TSPEnvironment.TSPInstanceEnv._next_observation"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._take_action", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._next_observation"], ["", "def", "step", "(", "self", ",", "action", ")", ":", "\n", "        ", "\"\"\"\n        Next observation of the TSP Environment\n        :param torch tensor action: int (a,b) shape: (1, 2)\n        \"\"\"", "\n", "self", ".", "current_step", "+=", "1", "\n", "\n", "reward", "=", "self", ".", "_take_action", "(", "action", ")", "\n", "observation", "=", "self", ".", "_next_observation", "(", ")", "\n", "done", "=", "False", "# only stop by number of actions", "\n", "if", "self", ".", "T", "is", "not", "None", ":", "\n", "            ", "self", ".", "T", "-=", "1", "\n", "\n", "", "return", "observation", ",", "reward", ",", "done", ",", "self", ".", "best_state", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._take_action": [[95, 133], ["utils.swap_2opt", "utils.swap_2opt_new", "TSPEnvironment.TSPInstanceEnv.new_tour_distance.copy", "TSPEnvironment.TSPInstanceEnv.hist_current_distance.append", "TSPEnvironment.TSPInstanceEnv.hist_best_distance.append", "TSPEnvironment.TSPInstanceEnv.new_keep_tour.copy", "TSPEnvironment.TSPInstanceEnv.reset_tour.copy", "round", "TSPEnvironment.TSPInstanceEnv.new_keep_tour.copy", "numpy.copy", "min"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt_new"], ["", "def", "_take_action", "(", "self", ",", "action", ")", ":", "\n", "        ", "\"\"\"\n        Take action in the TSP Env\n        :param torch.tensor action: indices (i, j) where i <= j shape: (1, 2)\n        \"\"\"", "\n", "# tour: new reset tour after a 2opt move", "\n", "self", ".", "tour", "=", "utils", ".", "swap_2opt", "(", "self", ".", "tour", ",", "\n", "action", "[", "0", "]", ",", "\n", "action", "[", "1", "]", ")", "\n", "\n", "# keep_tour: same 2opt move on keep_tour to keep history", "\n", "self", ".", "new_keep_tour", ",", "self", ".", "new_tour_distance", "=", "utils", ".", "swap_2opt_new", "(", "self", ".", "keep_tour", ",", "\n", "action", "[", "0", "]", ",", "\n", "action", "[", "1", "]", ",", "\n", "self", ".", "tour_distance", ",", "\n", "self", ".", "distances", ")", "\n", "\n", "self", ".", "state", "=", "self", ".", "state", "[", "self", ".", "tour", ",", ":", "]", "\n", "self", ".", "tour_distance", "=", "self", ".", "new_tour_distance", ".", "copy", "(", ")", "\n", "if", "(", "self", ".", "current_best_distance", ">", "self", ".", "tour_distance", ")", ":", "\n", "            ", "reward", "=", "self", ".", "current_best_distance", "-", "self", ".", "tour_distance", "\n", "reward", "=", "round", "(", "min", "(", "reward", "/", "10000", ",", "1.0", ")", ",", "4", ")", "\n", "self", ".", "current_best_distance", "=", "self", ".", "tour_distance", "\n", "self", ".", "current_best_tour", "=", "self", ".", "new_keep_tour", ".", "copy", "(", ")", "\n", "self", ".", "best_state", "=", "np", ".", "copy", "(", "self", ".", "state", ")", "\n", "\n", "", "else", ":", "\n", "            ", "reward", "=", "0.0", "\n", "\n", "# update memory", "\n", "", "self", ".", "hist_current_distance", ".", "append", "(", "self", ".", "tour_distance", ")", "\n", "self", ".", "hist_best_distance", ".", "append", "(", "self", ".", "current_best_distance", ")", "\n", "self", ".", "keep_tour", "=", "self", ".", "new_keep_tour", ".", "copy", "(", ")", "\n", "\n", "# before going to the next state tour gets reset", "\n", "self", ".", "tour", "=", "self", ".", "reset_tour", ".", "copy", "(", ")", "\n", "\n", "return", "reward", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._render_to_file": [[135, 149], ["open", "open.write", "open.write", "open.write", "open.write", "open.close"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.close"], ["", "def", "_render_to_file", "(", "self", ",", "filename", "=", "'render.txt'", ")", ":", "\n", "        ", "\"\"\"\n        Render experiences to a file\n\n        :param str filename: filename\n        \"\"\"", "\n", "\n", "file", "=", "open", "(", "filename", ",", "'a+'", ")", "\n", "file", ".", "write", "(", "f'Step: {self.current_step}\\n'", ")", "\n", "file", ".", "write", "(", "f'Current Tour: {self.keep_tour}\\n'", ")", "\n", "file", ".", "write", "(", "f'Best Tour: {self.current_best_tour}\\n'", ")", "\n", "file", ".", "write", "(", "f'Best Distance: {self.current_best_distance}\\n'", ")", "\n", "\n", "file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.render": [[150, 171], ["TSPEnvironment.TSPInstanceEnv._render_to_file", "kwargs.get", "TSPGraph.TSPGraph.TSPGraph", "TSPEnvironment.TSPInstanceEnv.visualization.render"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv._render_to_file", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.render"], ["", "def", "render", "(", "self", ",", "mode", "=", "'live'", ",", "window_size", "=", "10", ",", "time", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Rendering the episode to file or live\n\n        :param str mode: select mode 'live' or 'file'\n        :param int window_size: cost window size for the renderer\n        :param title mode: title of the rendere graph\n        \"\"\"", "\n", "assert", "mode", "==", "'file'", "or", "mode", "==", "'live'", "\n", "# Render the environment", "\n", "if", "mode", "==", "'file'", ":", "\n", "            ", "self", ".", "_render_to_file", "(", "kwargs", ".", "get", "(", "'filename'", ",", "'render.txt'", ")", ")", "\n", "", "if", "mode", "==", "'live'", ":", "\n", "            ", "if", "self", ".", "visualization", "is", "None", ":", "\n", "                ", "self", ".", "visualization", "=", "TSPGraph", "(", "window_size", ",", "time", ")", "\n", "", "if", "self", ".", "current_step", ">=", "window_size", ":", "\n", "                ", "self", ".", "visualization", ".", "render", "(", "self", ".", "current_step", ",", "\n", "self", ".", "hist_best_distance", ",", "\n", "self", ".", "hist_current_distance", ",", "\n", "self", ".", "state", ",", "\n", "self", ".", "best_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.close": [[172, 179], ["TSPEnvironment.TSPInstanceEnv.visualization.close"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.TSPInstanceEnv.close"], ["", "", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Close live rendering\n        \"\"\"", "\n", "if", "self", ".", "visualization", "is", "not", "None", ":", "\n", "            ", "self", ".", "visualization", ".", "close", "(", ")", "\n", "self", ".", "visualization", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.__init__": [[183, 189], ["numpy.random.choice"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "n_envs", ",", "n_nodes", ",", "T", "=", "None", ")", ":", "\n", "        ", "self", ".", "n_envs", "=", "n_envs", "\n", "self", ".", "env", "=", "env", "\n", "self", ".", "n_nodes", "=", "n_nodes", "\n", "self", ".", "env_idx", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "n_envs", ")", "\n", "self", ".", "T", "=", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.create_envs": [[190, 195], ["range", "TSPEnvironment.VecEnv.envs.append", "TSPEnvironment.VecEnv.env"], "methods", ["None"], ["", "def", "create_envs", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "envs", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_envs", ")", ":", "\n", "            ", "self", ".", "envs", ".", "append", "(", "self", ".", "env", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.reset": [[196, 216], ["TSPEnvironment.VecEnv.create_envs", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "env.reset", "TSPEnvironment.VecEnv.best_distances.copy", "range"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.create_envs", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset"], ["", "", "def", "reset", "(", "self", ",", "points", ",", "T", "=", "None", ")", ":", "\n", "        ", "self", ".", "create_envs", "(", ")", "\n", "observations", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "self", ".", "n_nodes", ",", "2", ")", ")", "\n", "best_observations", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "self", ".", "n_nodes", ",", "2", ")", ")", "\n", "self", ".", "best_distances", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "1", ")", ")", "\n", "self", ".", "distances", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "1", ")", ")", "\n", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "self", ".", "n_nodes", ")", "]", "\n", "idx", "=", "0", "\n", "for", "env", "in", "self", ".", "envs", ":", "\n", "            ", "observations", "[", "idx", "]", ",", "best_observations", "[", "idx", "]", "=", "env", ".", "reset", "(", "points", "[", "idx", "]", ",", "\n", "tour", ",", "\n", "T", ")", "\n", "self", ".", "best_distances", "[", "idx", "]", "=", "env", ".", "current_best_distance", "\n", "self", ".", "distances", "[", "idx", "]", "=", "env", ".", "tour_distance", "\n", "idx", "+=", "1", "\n", "\n", "", "self", ".", "current_step", "=", "0", "\n", "\n", "return", "observations", ",", "self", ".", "best_distances", ".", "copy", "(", ")", ",", "best_observations", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.step": [[217, 239], ["numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "numpy.ndarray", "env.step", "TSPEnvironment.VecEnv.best_distances.copy", "TSPEnvironment.VecEnv.distances.copy"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.step"], ["", "def", "step", "(", "self", ",", "actions", ")", ":", "\n", "\n", "        ", "observations", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "self", ".", "n_nodes", ",", "2", ")", ")", "\n", "best_observations", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "self", ".", "n_nodes", ",", "2", ")", ")", "\n", "rewards", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "1", ")", ")", "\n", "dones", "=", "np", ".", "ndarray", "(", "(", "self", ".", "n_envs", ",", "1", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "idx", "=", "0", "\n", "for", "env", "in", "self", ".", "envs", ":", "\n", "            ", "obs", ",", "reward", ",", "done", ",", "best_obs", "=", "env", ".", "step", "(", "actions", "[", "idx", "]", ")", "\n", "self", ".", "best_distances", "[", "idx", "]", "=", "env", ".", "current_best_distance", "\n", "self", ".", "distances", "[", "idx", "]", "=", "env", ".", "tour_distance", "\n", "observations", "[", "idx", "]", "=", "obs", "\n", "best_observations", "[", "idx", "]", "=", "best_obs", "\n", "rewards", "[", "idx", "]", "=", "reward", "\n", "dones", "[", "idx", "]", "=", "done", "\n", "idx", "+=", "1", "\n", "\n", "", "self", ".", "current_step", "+=", "1", "\n", "return", "observations", ",", "rewards", ",", "dones", ",", "self", ".", "best_distances", ".", "copy", "(", ")", ",", "self", ".", "distances", ".", "copy", "(", ")", ",", "best_observations", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.render": [[240, 244], ["env_to_render.render"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.render"], ["", "def", "render", "(", "self", ",", "mode", "=", "'live'", ",", "window_size", "=", "1", ",", "time", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "env_to_render", "=", "self", ".", "envs", "[", "self", ".", "env_idx", "]", "\n", "env_to_render", ".", "render", "(", "mode", ",", "window_size", ",", "self", ".", "current_step", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.calc_avg_distance": [[245, 247], ["numpy.mean"], "methods", ["None"], ["", "def", "calc_avg_distance", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "mean", "(", "self", ".", "best_distances", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.__init__": [[416, 419], ["utils.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset"], ["def", "__init__", "(", "self", ",", "name", "=", "'None'", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "self", ".", "name", "=", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset": [[420, 430], ["utils.AverageMeter.reset_history"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset_history"], ["", "def", "reset", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "self", ".", "exp_avg", "=", "0", "\n", "self", ".", "min", "=", "0", "\n", "self", ".", "max", "=", "0", "\n", "self", ".", "reset_history", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset_history": [[431, 440], ["None"], "methods", ["None"], ["", "def", "reset_history", "(", "self", ")", ":", "\n", "\n", "        ", "self", ".", "hist", "=", "{", "\"val\"", ":", "[", "]", ",", "\n", "\"avg\"", ":", "[", "]", ",", "\n", "\"sum\"", ":", "[", "]", ",", "\n", "\"count\"", ":", "[", "]", ",", "\n", "\"exp_avg\"", ":", "[", "]", ",", "\n", "\"min\"", ":", "[", "]", ",", "\n", "\"max\"", ":", "[", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update": [[441, 466], ["utils.AverageMeter.hist[].append", "utils.AverageMeter.hist[].append", "utils.AverageMeter.hist[].append", "utils.AverageMeter.hist[].append", "utils.AverageMeter.hist[].append", "utils.AverageMeter.hist[].append", "utils.AverageMeter.hist[].append"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "val", ",", "n", "=", "1", ",", "rate", "=", "0.1", ")", ":", "\n", "\n", "        ", "self", ".", "val", "=", "val", "\n", "self", ".", "sum", "+=", "val", "*", "n", "\n", "self", ".", "count", "+=", "n", "\n", "self", ".", "avg", "=", "self", ".", "sum", "/", "self", ".", "count", "\n", "\n", "if", "self", ".", "count", ">", "1", ":", "\n", "            ", "self", ".", "exp_avg", "=", "rate", "*", "val", "+", "(", "1", "-", "rate", ")", "*", "self", ".", "exp_avg", "\n", "if", "val", "<", "self", ".", "min", ":", "\n", "                ", "self", ".", "min", "=", "val", "\n", "", "if", "val", ">", "self", ".", "max", ":", "\n", "                ", "self", ".", "max", "=", "val", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "exp_avg", "=", "val", "\n", "self", ".", "min", "=", "val", "\n", "self", ".", "max", "=", "val", "\n", "\n", "", "self", ".", "hist", "[", "\"val\"", "]", ".", "append", "(", "self", ".", "val", ")", "\n", "self", ".", "hist", "[", "\"sum\"", "]", ".", "append", "(", "self", ".", "sum", ")", "\n", "self", ".", "hist", "[", "\"count\"", "]", ".", "append", "(", "self", ".", "count", ")", "\n", "self", ".", "hist", "[", "\"avg\"", "]", ".", "append", "(", "self", ".", "avg", ")", "\n", "self", ".", "hist", "[", "\"exp_avg\"", "]", ".", "append", "(", "self", ".", "exp_avg", ")", "\n", "self", ".", "hist", "[", "\"min\"", "]", ".", "append", "(", "self", ".", "min", ")", "\n", "self", ".", "hist", "[", "\"max\"", "]", ".", "append", "(", "self", ".", "max", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.log": [[467, 476], ["utils.AverageMeter.reset_history", "logger.keys", "logger[].keys", "[].extend"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset_history"], ["", "def", "log", "(", "self", ",", "logger", ")", ":", "\n", "\n", "        ", "if", "self", ".", "name", "not", "in", "logger", ".", "keys", "(", ")", ":", "\n", "            ", "logger", "[", "self", ".", "name", "]", "=", "self", ".", "hist", "\n", "", "else", ":", "\n", "            ", "for", "key", "in", "logger", "[", "self", ".", "name", "]", ".", "keys", "(", ")", ":", "\n", "                ", "logger", "[", "self", ".", "name", "]", "[", "key", "]", ".", "extend", "(", "self", ".", "hist", "[", "key", "]", ")", "\n", "\n", "", "", "self", ".", "reset_history", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.tsp_opt": [[9, 42], ["len", "range", "min", "numpy.linalg.norm", "numpy.asarray", "utils.tsp_opt.length"], "function", ["None"], ["def", "tsp_opt", "(", "points", ")", ":", "\n", "    ", "\"\"\"\n    Dynamic programing solution for the TSP - O(2^n*n^2)\n    https://gist.github.com/mlalevic/6222750\n\n    :param points: List of (x, y) points\n    :return: Optimal solution\n    \"\"\"", "\n", "\n", "def", "length", "(", "x_coord", ",", "y_coord", ")", ":", "\n", "        ", "return", "np", ".", "linalg", ".", "norm", "(", "np", ".", "asarray", "(", "x_coord", ")", "-", "np", ".", "asarray", "(", "y_coord", ")", ")", "\n", "\n", "# Calculate all lengths", "\n", "", "all_distances", "=", "[", "[", "length", "(", "x", ",", "y", ")", "for", "y", "in", "points", "]", "for", "x", "in", "points", "]", "\n", "# Initial value - just distance from 0 to every other point + keep the track of edges", "\n", "A", "=", "{", "(", "frozenset", "(", "[", "0", ",", "idx", "+", "1", "]", ")", ",", "idx", "+", "1", ")", ":", "(", "dist", ",", "[", "0", ",", "idx", "+", "1", "]", ")", "\n", "for", "idx", ",", "dist", "in", "enumerate", "(", "all_distances", "[", "0", "]", "[", "1", ":", "]", ")", "}", "\n", "cnt", "=", "len", "(", "points", ")", "\n", "for", "m", "in", "range", "(", "2", ",", "cnt", ")", ":", "\n", "        ", "B", "=", "{", "}", "\n", "for", "S", "in", "[", "frozenset", "(", "C", ")", "|", "{", "0", "}", "\n", "for", "C", "in", "itertools", ".", "combinations", "(", "range", "(", "1", ",", "cnt", ")", ",", "m", ")", "]", ":", "\n", "            ", "for", "j", "in", "S", "-", "{", "0", "}", ":", "\n", "# This will use 0th index of tuple for ordering, the same as if key=itemgetter(0) used", "\n", "                ", "B", "[", "(", "S", ",", "j", ")", "]", "=", "min", "(", "[", "(", "A", "[", "(", "S", "-", "{", "j", "}", ",", "k", ")", "]", "[", "0", "]", "+", "all_distances", "[", "k", "]", "[", "j", "]", ",", "A", "[", "(", "S", "-", "{", "j", "}", ",", "k", ")", "]", "[", "1", "]", "+", "[", "j", "]", ")", "\n", "for", "k", "in", "S", "if", "k", "!=", "0", "and", "k", "!=", "j", "]", ")", "\n", "", "", "A", "=", "B", "\n", "", "res", "=", "min", "(", "[", "(", "A", "[", "d", "]", "[", "0", "]", "+", "all_distances", "[", "0", "]", "[", "d", "[", "1", "]", "]", ",", "A", "[", "d", "]", "[", "1", "]", ")", "for", "d", "in", "iter", "(", "A", ")", "]", ")", "\n", "\n", "# dist = route_distance(res, all_distances)", "\n", "# print(res)", "\n", "# print(dist)", "\n", "return", "np", ".", "asarray", "(", "res", "[", "1", "]", ")", ",", "res", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.plot_tsp_solution": [[44, 80], ["matplotlib.subplots", "ax[].set_title", "ax[].set_title", "ax[].scatter", "ax[].scatter", "len", "range", "dict", "ax[].text", "matplotlib.tight_layout", "matplotlib.show", "ax[].annotate", "numpy.linalg.norm", "dict"], "function", ["None"], ["", "def", "plot_tsp_solution", "(", "positions", ",", "solution", ")", ":", "\n", "    ", "\"\"\"\n    Plot TSP solutions in 2D\n\n    :param np.array positions: Positions of (tour_len, 2) points\n    :param list solution: tour of the TSP\n    :return: 2 plots (Positions and Positions+Solution)\n    \"\"\"", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "2", ",", "sharex", "=", "True", ",", "sharey", "=", "True", ")", "# Prepare 2 plots", "\n", "ax", "[", "0", "]", ".", "set_title", "(", "'Raw nodes'", ")", "\n", "ax", "[", "1", "]", ".", "set_title", "(", "'Optimised tour'", ")", "\n", "ax", "[", "0", "]", ".", "scatter", "(", "positions", "[", ":", ",", "0", "]", ",", "positions", "[", ":", ",", "1", "]", ")", "# Plot A", "\n", "ax", "[", "1", "]", ".", "scatter", "(", "positions", "[", ":", ",", "0", "]", ",", "positions", "[", ":", ",", "1", "]", ")", "# Plot B", "\n", "start_node", "=", "0", "\n", "distance", "=", "0.", "\n", "N", "=", "len", "(", "solution", ")", "\n", "for", "i", "in", "range", "(", "N", "-", "1", ")", ":", "\n", "        ", "start_pos", "=", "positions", "[", "start_node", "]", "\n", "next_node", "=", "solution", "[", "i", "+", "1", "]", "\n", "end_pos", "=", "positions", "[", "next_node", "]", "\n", "ax", "[", "1", "]", ".", "annotate", "(", "\"\"", ",", "\n", "xy", "=", "start_pos", ",", "xycoords", "=", "'data'", ",", "\n", "xytext", "=", "end_pos", ",", "textcoords", "=", "'data'", ",", "\n", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "\"<-\"", ",", "\n", "connectionstyle", "=", "\"arc3\"", ")", ")", "\n", "distance", "+=", "np", ".", "linalg", ".", "norm", "(", "end_pos", "-", "start_pos", ")", "\n", "start_node", "=", "next_node", "\n", "\n", "", "textstr", "=", "\"N nodes: %d\\nTotal length: %.3f\"", "%", "(", "N", "-", "1", ",", "distance", ")", "\n", "props", "=", "dict", "(", "boxstyle", "=", "'round'", ",", "facecolor", "=", "'wheat'", ",", "alpha", "=", "0.5", ")", "\n", "ax", "[", "1", "]", ".", "text", "(", "0.05", ",", "0.95", ",", "textstr", ",", "transform", "=", "ax", "[", "1", "]", ".", "transAxes", ",", "fontsize", "=", "14", ",", "\n", "verticalalignment", "=", "'top'", ",", "bbox", "=", "props", ")", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour": [[82, 102], ["random.sample", "list", "range"], "function", ["None"], ["", "def", "create_tour", "(", "tour_length", ",", "seed", "=", "12345", ",", "rand", "=", "True", ",", "nearest_neighbour", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Create an initial tour for the TSP\n\n    :param int tour_length: Tour length\n    :param bool rand:  Generate random tour\n    :param bool nearest_neighbour: Genarate nearest neighbour tour\n    :return: list with a TSP tour\n    \"\"\"", "\n", "assert", "rand", "!=", "nearest_neighbour", ",", "\"Parameters rand and nearest_neighbour cannot have the same value\"", "\n", "# np.random.seed(seed=seed)", "\n", "if", "rand", ":", "\n", "        ", "N", "=", "tour_length", "\n", "\n", "tour", "=", "random", ".", "sample", "(", "range", "(", "N", ")", ",", "N", ")", "\n", "# tour = np.append([0],", "\n", "# np.random.choice(np.arange(1, N), N-1, replace=False))", "\n", "# tour = np.append(np.random.choice(np.arange(0, N), N-1, replace=False))", "\n", "return", "list", "(", "tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances": [[104, 118], ["scipy.spatial.distance_matrix"], "function", ["None"], ["", "", "def", "calculate_distances", "(", "positions", ")", ":", "\n", "    ", "\"\"\"\n    Calculate a all distances between poistions\n\n    :param np.array positions: Positions of (tour_len, 2) points\n    :return: list with all distances\n    \"\"\"", "\n", "\n", "# def length(x, y):", "\n", "#     return np.linalg.norm(np.asarray(x) - np.asarray(y))", "\n", "# distances = [[length(x, y) for y in positions] for x in positions]", "\n", "\n", "distances", "=", "distance_matrix", "(", "positions", ",", "positions", ")", "\n", "return", "distances", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance": [[119, 133], ["int", "int"], "function", ["None"], ["", "def", "route_distance", "(", "tour", ",", "distances", ")", ":", "\n", "    ", "\"\"\"\n    Calculate a tour distance (including 0)\n\n    :param list tour: TSP tour\n    :param list : list with all distances\n    :return dist: Distance of a tour\n    \"\"\"", "\n", "dist", "=", "0", "\n", "prev", "=", "tour", "[", "-", "1", "]", "\n", "for", "node", "in", "tour", ":", "\n", "        ", "dist", "+=", "distances", "[", "int", "(", "prev", ")", "]", "[", "int", "(", "node", ")", "]", "\n", "prev", "=", "node", "\n", "", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt": [[135, 156], ["numpy.append", "numpy.append", "list", "numpy.flip", "int", "len", "len"], "function", ["None"], ["", "def", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Swaps two edges by reversing a section of nodes\n\n    :param list tour: TSP tour\n    :param int i: First index for the swap\n    :param int j: Second index for the swap\n    \"\"\"", "\n", "# assert tour[0] == 0 and tour[-1] != 0", "\n", "if", "k", "<=", "i", ":", "\n", "        ", "i_a", "=", "i", "\n", "i", "=", "k", "\n", "k", "=", "i_a", "\n", "", "assert", "i", ">=", "0", "and", "i", "<", "(", "len", "(", "tour", ")", "-", "1", ")", "\n", "assert", "k", ">=", "i", "and", "k", "<", "len", "(", "tour", ")", "\n", "new_tour", "=", "tour", "[", "0", ":", "i", "]", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "np", ".", "flip", "(", "tour", "[", "i", ":", "k", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "tour", "[", "k", "+", "1", ":", "]", ")", "\n", "# assert len(new_tour) == len(tour)", "\n", "new_tour", "=", "[", "int", "(", "i", ")", "for", "i", "in", "new_tour", "]", "\n", "return", "list", "(", "new_tour", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt_": [[158, 198], ["tour.copy", "tour.copy.append", "tour.copy.insert", "numpy.append", "numpy.append", "new_tour.astype().tolist.astype().tolist", "new_tour.astype().tolist.copy", "new_tour.copy.append", "new_tour.copy.insert", "numpy.flip", "len", "new_tour.astype().tolist.astype", "len"], "function", ["None"], ["", "def", "swap_2opt_", "(", "tour", ",", "i", ",", "k", ",", "tour_distance", ",", "distances", ")", ":", "\n", "    ", "\"\"\"\n    Swaps two edges by reversing a section of nodes\n\n    :param list tour: TSP tour\n    :param int i: First index for the swap\n    :param int j: Second index for the swap\n    \"\"\"", "\n", "# assert tour[0] == 0 and tour[-1] != 0", "\n", "if", "k", "<=", "i", ":", "\n", "        ", "i_a", "=", "i", "\n", "i", "=", "k", "\n", "k", "=", "i_a", "\n", "", "assert", "i", ">=", "0", "and", "i", "<", "(", "len", "(", "tour", ")", "-", "1", ")", "\n", "assert", "k", ">=", "i", "and", "k", "<", "len", "(", "tour", ")", "\n", "\n", "distance", "=", "tour_distance", "\n", "\n", "aux_tour", "=", "tour", ".", "copy", "(", ")", "\n", "aux_tour", ".", "append", "(", "tour", "[", "0", "]", ")", "\n", "aux_tour", ".", "insert", "(", "0", ",", "tour", "[", "-", "1", "]", ")", "\n", "\n", "distance", "=", "distance", "-", "(", "distances", "[", "aux_tour", "[", "i", "]", "]", "[", "aux_tour", "[", "i", "+", "1", "]", "]", "\n", "+", "distances", "[", "aux_tour", "[", "k", "+", "1", "]", "]", "[", "aux_tour", "[", "k", "+", "2", "]", "]", ")", "\n", "\n", "new_tour", "=", "tour", "[", "0", ":", "i", "]", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "np", ".", "flip", "(", "tour", "[", "i", ":", "k", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "tour", "[", "k", "+", "1", ":", "]", ")", "\n", "# assert len(new_tour) == len(tour)", "\n", "# new_tour = [int(i) for i in new_tour]", "\n", "new_tour", "=", "new_tour", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "\n", "aux_new_tour", "=", "new_tour", ".", "copy", "(", ")", "\n", "aux_new_tour", ".", "append", "(", "new_tour", "[", "0", "]", ")", "\n", "aux_new_tour", ".", "insert", "(", "0", ",", "new_tour", "[", "-", "1", "]", ")", "\n", "\n", "distance", "=", "distance", "+", "(", "distances", "[", "aux_new_tour", "[", "i", "]", "]", "[", "aux_new_tour", "[", "i", "+", "1", "]", "]", "\n", "+", "distances", "[", "aux_new_tour", "[", "k", "+", "1", "]", "]", "[", "aux_new_tour", "[", "k", "+", "2", "]", "]", ")", "\n", "\n", "return", "new_tour", ",", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt_new": [[200, 249], ["numpy.append", "numpy.append", "new_tour.astype().tolist.astype().tolist", "numpy.flip", "len", "len", "len", "new_tour.astype().tolist.astype", "len"], "function", ["None"], ["", "def", "swap_2opt_new", "(", "tour", ",", "i", ",", "k", ",", "tour_distance", ",", "D", ")", ":", "\n", "    ", "\"\"\"\n    Swaps two edges by reversing a section of nodes\n\n    :param list tour: TSP tour\n    :param int i: First index for the swap\n    :param int j: Second index for the swap\n    \"\"\"", "\n", "# assert tour[0] == 0 and tour[-1] != 0", "\n", "if", "k", "<=", "i", ":", "\n", "        ", "i_a", "=", "i", "\n", "i", "=", "k", "\n", "k", "=", "i_a", "\n", "", "assert", "i", ">=", "0", "and", "i", "<", "(", "len", "(", "tour", ")", "-", "1", ")", "\n", "assert", "k", ">=", "i", "and", "k", "<", "len", "(", "tour", ")", "\n", "\n", "distance", "=", "tour_distance", "\n", "# print(\"tour distance before 2 opt\", distance)", "\n", "\n", "if", "i", ">", "0", ":", "\n", "        ", "pred_i", "=", "i", "-", "1", "\n", "", "else", ":", "\n", "        ", "pred_i", "=", "len", "(", "tour", ")", "-", "1", "\n", "\n", "", "if", "k", "<", "len", "(", "tour", ")", "-", "1", ":", "\n", "        ", "suc_k", "=", "k", "+", "1", "\n", "", "else", ":", "\n", "        ", "suc_k", "=", "0", "\n", "# print(pred_i)", "\n", "# print(suc_k)", "\n", "\n", "", "remove", "=", "D", "[", "tour", "[", "pred_i", "]", "]", "[", "tour", "[", "i", "]", "]", "+", "D", "[", "tour", "[", "k", "]", "]", "[", "tour", "[", "suc_k", "]", "]", "\n", "\n", "\n", "# print(\"remove\", remove)", "\n", "\n", "distance", "-=", "remove", "\n", "\n", "\n", "new_tour", "=", "tour", "[", "0", ":", "i", "]", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "np", ".", "flip", "(", "tour", "[", "i", ":", "k", "+", "1", "]", ",", "axis", "=", "0", ")", ")", "\n", "new_tour", "=", "np", ".", "append", "(", "new_tour", ",", "tour", "[", "k", "+", "1", ":", "]", ")", "\n", "new_tour", "=", "new_tour", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "\n", "\n", "add", "=", "D", "[", "new_tour", "[", "pred_i", "]", "]", "[", "new_tour", "[", "i", "]", "]", "+", "D", "[", "new_tour", "[", "k", "]", "]", "[", "new_tour", "[", "suc_k", "]", "]", "\n", "# print(\"add\", add)", "\n", "distance", "+=", "add", "\n", "# print(\"tour distance after 2 opt\", distance)", "\n", "return", "new_tour", ",", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.run_2opt": [[269, 325], ["utils.calculate_distances", "utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "len", "len", "utils.swap_2opt", "utils.route_distance", "np.array.append", "np.array.append", "np.array.append", "sorted"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "run_2opt", "(", "tour", ",", "positions", ",", "return_indices", "=", "True", ",", "return_first", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "# swap_indices: list with nodes to swap", "\n", "swap_nodes", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "best_tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "# print(new_distance)", "\n", "# print(new_tour)", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "swap_nodes", ".", "append", "(", "sorted", "(", "[", "new_tour", "[", "i", "]", ",", "new_tour", "[", "k", "]", "]", ")", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "break", "# improvement --> return to the top of 1st loop", "\n", "# if just the first move stop the 2nd loop and stop the while loop", "\n", "", "", "if", "return_first", "and", "improvement", ":", "\n", "                ", "improvement", "=", "False", "\n", "break", "\n", "# if improvement:", "\n", "#     break", "\n", "# print(\"final distance\", best_distance)", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "swap_nodes", "=", "np", ".", "array", "(", "swap_nodes", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "if", "return_indices", ":", "\n", "        ", "return", "best_distance", ",", "best_tour", ",", "tours", ",", "swap_indices", "\n", "", "else", ":", "\n", "        ", "return", "best_distance", ",", "best_tour", ",", "tours", ",", "swap_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.run_2opt_policy": [[327, 381], ["utils.calculate_distances", "utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "utils.swap_2opt", "utils.route_distance", "np.array.append", "np.array.append", "np.array.append", "sorted"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "", "def", "run_2opt_policy", "(", "positions", ",", "return_first", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "# swap_indices: list with nodes to swap", "\n", "swap_nodes", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "best_tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "# print(new_distance)", "\n", "# print(new_tour)", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "swap_nodes", ".", "append", "(", "sorted", "(", "[", "new_tour", "[", "i", "]", ",", "new_tour", "[", "k", "]", "]", ")", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "break", "# improvement", "\n", "# if just the first move stop the 2nd loop and stop the while loop", "\n", "", "", "if", "return_first", "and", "improvement", ":", "\n", "                ", "improvement", "=", "False", "\n", "break", "\n", "# if improvement:", "\n", "#     break", "\n", "# print(\"final distance\", best_distance)", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "swap_nodes", "=", "np", ".", "array", "(", "swap_nodes", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "return", "swap_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.index_to_action": [[383, 391], ["range", "range", "numpy.array"], "function", ["None"], ["", "def", "index_to_action", "(", "nof_points", ")", ":", "\n", "    ", "action_dic", "=", "{", "}", "\n", "dic_idx", "=", "0", "\n", "for", "i", "in", "range", "(", "1", ",", "nof_points", "-", "1", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "nof_points", ")", ":", "\n", "            ", "action_dic", "[", "dic_idx", "]", "=", "np", ".", "array", "(", "[", "i", ",", "j", "]", ")", "\n", "dic_idx", "+=", "1", "\n", "", "", "return", "action_dic", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.batch_pair_squared_dist": [[393, 410], ["y.permute().contiguous", "torch.clamp", "torch.sum", "torch.diag_embed", "torch.bmm", "torch.bmm", "y.permute", "torch.bmm", "torch.sqrt"], "function", ["None"], ["", "def", "batch_pair_squared_dist", "(", "x", ",", "y", ")", ":", "\n", "    ", "'''\n    Modified from https://discuss.pytorch.org/t/efficient-distance-matrix-computation/9065/3\n    Input: x is a bxNxd matrix y is an optional bxMxd matirx\n    Output: dist is a bxNxM matrix where dist[b,i,j] is the square norm between x[b,i,:] and y[b,j,:]\n    i.e. dist[i,j] = ||x[b,i,:]-y[b,j,:]||^2\n    '''", "\n", "x_norm", "=", "(", "x", "**", "2", ")", ".", "sum", "(", "2", ")", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "y_t", "=", "y", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "y_norm", "=", "(", "y", "**", "2", ")", ".", "sum", "(", "2", ")", ".", "view", "(", "y", ".", "shape", "[", "0", "]", ",", "1", ",", "y", ".", "shape", "[", "1", "]", ")", "\n", "dist", "=", "x_norm", "+", "y_norm", "-", "2.0", "*", "torch", ".", "bmm", "(", "x", ",", "y_t", ")", "\n", "dist", "[", "dist", "!=", "dist", "]", "=", "0", "# replace nan values with 0", "\n", "dist", "=", "torch", ".", "clamp", "(", "dist", ",", "0.0", ",", "np", ".", "inf", ")", "\n", "S", "=", "torch", ".", "sum", "(", "dist", ",", "dim", "=", "2", ")", "\n", "S_d", "=", "torch", ".", "diag_embed", "(", "1", "/", "torch", ".", "sqrt", "(", "S", ")", ",", "offset", "=", "0", ",", "dim1", "=", "-", "2", ",", "dim2", "=", "-", "1", ")", "\n", "dist", "=", "torch", ".", "bmm", "(", "torch", ".", "bmm", "(", "S_d", ",", "dist", ")", ",", "S_d", ")", "\n", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.run_2opt_policy_bi": [[478, 538], ["utils.calculate_distances", "utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "len", "range", "range", "len", "len", "len", "utils.swap_2opt", "utils.route_distance", "np.array.append", "np.array.append", "np.array.append", "sorted"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "", "def", "run_2opt_policy_bi", "(", "positions", ",", "return_first", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "# swap_indices: list with nodes to swap", "\n", "swap_nodes", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "# print(\"new_candidate_dist\", new_distance)", "\n", "# print(\"new_cadidate_tour\", new_tour)", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "# print(\"accept new dist\", new_distance)", "\n", "# print(\"aceept_new_tour\", new_tour)", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "swap_nodes", ".", "append", "(", "sorted", "(", "[", "new_tour", "[", "i", "]", ",", "new_tour", "[", "k", "]", "]", ")", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "if", "return_first", ":", "\n", "                        ", "break", "# improvement --> return to the top of 1st loop", "\n", "\n", "# if just the first move stop the 2nd loop and stop the while loop", "\n", "", "", "", "if", "return_first", "and", "improvement", ":", "\n", "                ", "improvement", "=", "False", "\n", "break", "\n", "\n", "\n", "# print(\"final distance\", best_distance)", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "swap_nodes", "=", "np", ".", "array", "(", "swap_nodes", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "if", "len", "(", "swap_indices", ")", ">", "0", ":", "\n", "        ", "return", "swap_indices", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.heuristic_2opt_fi": [[543, 588], ["utils.calculate_distances", "numpy.rint", "distances.astype.astype", "utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "utils.swap_2opt", "utils.route_distance", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "", "def", "heuristic_2opt_fi", "(", "positions", ",", "procnum", ",", "return_dict", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "best_tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "break", "\n", "", "", "if", "improvement", ":", "\n", "                ", "break", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "return_dict", "[", "procnum", "]", "=", "best_tour", ",", "best_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.heuristic_2opt_bi": [[595, 638], ["utils.calculate_distances", "numpy.rint", "distances.astype.astype", "utils.route_distance", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "utils.swap_2opt", "utils.route_distance", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_bi", "(", "positions", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "while", "improvement", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "", "", "", "tour", "=", "best_tour", "\n", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "return", "best_tour", ",", "best_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.heuristic_2opt_fi_restart": [[647, 694], ["utils.calculate_distances", "numpy.rint", "distances.astype.astype", "utils.route_distance", "range", "range", "len", "len", "range", "range", "utils.create_tour", "len", "len", "len", "utils.swap_2opt", "utils.route_distance", "len"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_fi_restart", "(", "positions", ",", "steps", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "restart_distance", "=", "best_distance", "\n", "# print(\"initial distance\", best_distance)", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "tour", "=", "new_tour", "\n", "break", "\n", "", "", "if", "improvement", ":", "\n", "                ", "break", "\n", "", "", "if", "improvement", "is", "False", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "tour", "=", "create_tour", "(", "len", "(", "tour", ")", ")", "\n", "best_distance", "=", "1e10", "\n", "", "if", "n", "==", "steps", "-", "1", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "return", "restart_tour", ",", "restart_distance", "/", "10000", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.heuristic_2opt_bi_restart": [[698, 754], ["utils.calculate_distances", "numpy.rint", "distances.astype.astype", "utils.route_distance", "range", "numpy.array", "numpy.array", "numpy.array", "range", "len", "len", "range", "range", "utils.create_tour", "len", "len", "len", "utils.swap_2opt", "utils.route_distance", "len", "np.array.append", "np.array.append"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.calculate_distances", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.create_tour", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.swap_2opt", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.route_distance"], ["", "def", "heuristic_2opt_bi_restart", "(", "positions", ",", "steps", ")", ":", "\n", "    ", "\"\"\"\n    Improves an existing route using 2-opt until no improvement is found\n\n    :param list tour: TSP tour\n    :param list distances: distances between points (i, j)\n    :param bool return_indices: return list of indices otherwise return nodes\n    :param bool return_first: return just the first 2opt move\n    :param bool return_first: return just the first 2opt move\n    \"\"\"", "\n", "improvement", "=", "True", "\n", "tour", "=", "[", "x", "for", "x", "in", "range", "(", "len", "(", "positions", ")", ")", "]", "\n", "best_tour", "=", "tour", "\n", "distances", "=", "calculate_distances", "(", "positions", ")", "\n", "distances", "=", "np", ".", "rint", "(", "distances", "*", "10000", ")", "\n", "distances", "=", "distances", ".", "astype", "(", "int", ")", "\n", "best_distance", "=", "route_distance", "(", "tour", ",", "distances", ")", "\n", "restart_distance", "=", "best_distance", "\n", "# tours: list with tours", "\n", "tours", "=", "[", "]", "\n", "# swap_indices: list with indices to swap", "\n", "swap_indices", "=", "[", "]", "\n", "\n", "# print(\"initial distance\", best_distance)", "\n", "for", "n", "in", "range", "(", "steps", ")", ":", "\n", "        ", "improvement", "=", "False", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "best_tour", ")", "-", "1", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "i", "+", "1", ",", "len", "(", "best_tour", ")", ")", ":", "\n", "                ", "new_tour", "=", "swap_2opt", "(", "tour", ",", "i", ",", "k", ")", "\n", "new_distance", "=", "route_distance", "(", "new_tour", ",", "distances", ")", "\n", "if", "new_distance", "<", "best_distance", ":", "\n", "                    ", "swap_indices", ".", "append", "(", "[", "i", ",", "k", "]", ")", "\n", "tours", ".", "append", "(", "best_tour", ")", "\n", "best_distance", "=", "new_distance", "\n", "best_tour", "=", "new_tour", "\n", "improvement", "=", "True", "\n", "", "", "", "tour", "=", "best_tour", "\n", "if", "improvement", "is", "False", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "tour", "=", "create_tour", "(", "len", "(", "tour", ")", ")", "\n", "best_distance", "=", "1e10", "\n", "", "if", "n", "==", "steps", "-", "1", ":", "\n", "            ", "if", "best_distance", "<", "restart_distance", ":", "\n", "                ", "restart_distance", "=", "best_distance", "\n", "restart_tour", "=", "best_tour", "\n", "\n", "", "", "", "assert", "len", "(", "best_tour", ")", "==", "len", "(", "tour", ")", "\n", "\n", "swap_indices", "=", "np", ".", "array", "(", "swap_indices", ")", "\n", "best_tour", "=", "np", ".", "array", "(", "best_tour", ")", "\n", "tours", "=", "np", ".", "array", "(", "tours", ")", "\n", "\n", "return", "restart_tour", ",", "restart_distance", "/", "10000", "\n", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.Encoder.__init__": [[15, 65], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["def", "__init__", "(", "self", ",", "\n", "input_dim", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_nodes", ",", "\n", "n_rnn_layers", ")", ":", "\n", "        ", "\"\"\"\n        Initialise Encoder\n        :param int input_dim: Number of input dimensions\n        :param int embedding_dim: Number of embbeding dimensions\n        :param int hidden_dim: Number of hidden units of the RNN\n        :param int n_layers: Number of RNN layers\n        :param int n_nodes: Number of nodes in the TSP\n        \"\"\"", "\n", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_rnn_layers", "=", "n_rnn_layers", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_nodes", "=", "n_nodes", "\n", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "input_dim", ",", "embedding_dim", ")", "\n", "\n", "self", ".", "g_embedding", "=", "nn", ".", "Linear", "(", "embedding_dim", ",", "hidden_dim", ")", "\n", "self", ".", "g_embedding1", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", "\n", "self", ".", "g_embedding2", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", "\n", "\n", "self", ".", "rnn0", "=", "nn", ".", "LSTM", "(", "input_size", "=", "embedding_dim", ",", "\n", "hidden_size", "=", "hidden_dim", ",", "\n", "num_layers", "=", "n_rnn_layers", ",", "\n", "batch_first", "=", "True", ")", "\n", "\n", "self", ".", "rnn", "=", "nn", ".", "LSTM", "(", "input_size", "=", "embedding_dim", ",", "\n", "hidden_size", "=", "hidden_dim", ",", "\n", "num_layers", "=", "n_rnn_layers", ",", "\n", "batch_first", "=", "True", ")", "\n", "\n", "self", ".", "h0", "=", "Parameter", "(", "torch", ".", "zeros", "(", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "c0", "=", "Parameter", "(", "torch", ".", "zeros", "(", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n", "self", ".", "rnn0_reversed", "=", "nn", ".", "LSTM", "(", "input_size", "=", "embedding_dim", ",", "\n", "hidden_size", "=", "hidden_dim", ",", "\n", "num_layers", "=", "n_rnn_layers", ",", "\n", "batch_first", "=", "True", ")", "\n", "\n", "self", ".", "rnn_reversed", "=", "nn", ".", "LSTM", "(", "input_size", "=", "embedding_dim", ",", "\n", "hidden_size", "=", "hidden_dim", ",", "\n", "num_layers", "=", "n_rnn_layers", ",", "\n", "batch_first", "=", "True", ")", "\n", "\n", "self", ".", "W_f", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", "\n", "self", ".", "W_b", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.Encoder.forward": [[66, 131], ["input.size", "utils.batch_pair_squared_dist", "ActorCriticNetwork.Encoder.embedding", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "rnn_input[].unsqueeze", "ActorCriticNetwork.Encoder.rnn0.flatten_parameters", "ActorCriticNetwork.Encoder.rnn0", "ActorCriticNetwork.Encoder.rnn.flatten_parameters", "ActorCriticNetwork.Encoder.rnn", "rnn_input_reversed[].unsqueeze", "ActorCriticNetwork.Encoder.rnn0_reversed.flatten_parameters", "ActorCriticNetwork.Encoder.rnn0_reversed", "ActorCriticNetwork.Encoder.rnn_reversed.flatten_parameters", "ActorCriticNetwork.Encoder.rnn_reversed", "torch.tanh", "torch.tanh", "torch.tanh", "ActorCriticNetwork.Encoder.h0.unsqueeze().unsqueeze().repeat", "ActorCriticNetwork.Encoder.h0.unsqueeze().unsqueeze().repeat", "h0.unsqueeze().repeat.unsqueeze().repeat.detach", "h0.unsqueeze().repeat.unsqueeze().repeat.detach", "h0.unsqueeze().repeat.unsqueeze().repeat.unsqueeze().repeat", "c0.unsqueeze().repeat.unsqueeze().repeat.unsqueeze().repeat", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "ActorCriticNetwork.Encoder.W_f", "ActorCriticNetwork.Encoder.W_b", "ActorCriticNetwork.Encoder.h0.unsqueeze().unsqueeze", "ActorCriticNetwork.Encoder.h0.unsqueeze().unsqueeze", "h0.unsqueeze().repeat.unsqueeze().repeat.unsqueeze", "c0.unsqueeze().repeat.unsqueeze().repeat.unsqueeze", "ActorCriticNetwork.Encoder.g_embedding", "ActorCriticNetwork.Encoder.g_embedding1", "ActorCriticNetwork.Encoder.g_embedding2", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "torch.flip", "ActorCriticNetwork.Encoder.h0.unsqueeze", "ActorCriticNetwork.Encoder.h0.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.batch_pair_squared_dist"], ["", "def", "forward", "(", "self", ",", "input", ",", "hidden", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Encoder: Forward-pass\n\n        :param Tensor input: Graph inputs (bs, n_nodes, 2)\n        :param Tensor hidden: hidden vectors passed as inputs from t-1\n        \"\"\"", "\n", "\n", "batch_size", "=", "input", ".", "size", "(", "0", ")", "\n", "\n", "edges", "=", "utils", ".", "batch_pair_squared_dist", "(", "input", ",", "input", ")", "\n", "edges", ".", "requires_grad", "=", "False", "\n", "\n", "# embedding shared across all nodes", "\n", "embedded_input", "=", "self", ".", "embedding", "(", "input", ")", "\n", "\n", "if", "hidden", "is", "None", ":", "\n", "            ", "h0", "=", "self", ".", "h0", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "self", ".", "n_rnn_layers", ",", "\n", "batch_size", ",", "\n", "self", ".", "hidden_dim", ")", "\n", "c0", "=", "self", ".", "h0", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "self", ".", "n_rnn_layers", ",", "\n", "batch_size", ",", "\n", "self", ".", "hidden_dim", ")", "\n", "", "else", ":", "\n", "            ", "h0", ",", "c0", "=", "hidden", "\n", "h0", "=", "h0", ".", "detach", "(", ")", "\n", "c0", "=", "h0", ".", "detach", "(", ")", "\n", "\n", "h0", "=", "h0", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "self", ".", "n_rnn_layers", ",", "1", ",", "1", ")", "\n", "c0", "=", "c0", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "self", ".", "n_rnn_layers", ",", "1", ",", "1", ")", "\n", "\n", "", "g_embedding", "=", "embedded_input", "+", "F", ".", "relu", "(", "torch", ".", "bmm", "(", "edges", ",", "self", ".", "g_embedding", "(", "embedded_input", ")", ")", ")", "\n", "g_embedding", "=", "g_embedding", "+", "F", ".", "relu", "(", "torch", ".", "bmm", "(", "edges", ",", "self", ".", "g_embedding1", "(", "g_embedding", ")", ")", ")", "\n", "g_embedding", "=", "g_embedding", "+", "F", ".", "relu", "(", "torch", ".", "bmm", "(", "edges", ",", "self", ".", "g_embedding2", "(", "g_embedding", ")", ")", ")", "\n", "\n", "rnn_input", "=", "g_embedding", "\n", "rnn_input_reversed", "=", "torch", ".", "flip", "(", "g_embedding", ",", "[", "1", "]", ")", "\n", "\n", "# first RNN reads the last node on the input", "\n", "rnn0_input", "=", "rnn_input", "[", ":", ",", "-", "1", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "rnn0", ".", "flatten_parameters", "(", ")", "\n", "_", ",", "(", "h0", ",", "c0", ")", "=", "self", ".", "rnn0", "(", "rnn0_input", ",", "(", "h0", ",", "c0", ")", ")", "\n", "# second RNN reads the sequence of nodes", "\n", "self", ".", "rnn", ".", "flatten_parameters", "(", ")", "\n", "s_out", ",", "s_hidden", "=", "self", ".", "rnn", "(", "rnn_input", ",", "(", "h0", ",", "c0", ")", ")", "\n", "\n", "# first RNN reads the last node on the input", "\n", "rnn0_input_reversed", "=", "rnn_input_reversed", "[", ":", ",", "-", "1", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "rnn0_reversed", ".", "flatten_parameters", "(", ")", "\n", "_", ",", "(", "h0_r", ",", "c0_r", ")", "=", "self", ".", "rnn0_reversed", "(", "rnn0_input_reversed", ")", "\n", "# second RNN reads the sequence of nodes", "\n", "self", ".", "rnn_reversed", ".", "flatten_parameters", "(", ")", "\n", "s_out_reversed", ",", "s_hidden_reversed", "=", "self", ".", "rnn_reversed", "(", "rnn_input_reversed", ",", "\n", "(", "h0_r", ",", "c0_r", ")", ")", "\n", "\n", "s_out", "=", "tanh", "(", "self", ".", "W_f", "(", "s_out", ")", "\n", "+", "self", ".", "W_b", "(", "torch", ".", "flip", "(", "s_out_reversed", ",", "[", "1", "]", ")", ")", ")", "\n", "\n", "s_hidden", "=", "(", "s_hidden", "[", "0", "]", "+", "s_hidden_reversed", "[", "0", "]", ",", "\n", "s_hidden", "[", "1", "]", "+", "s_hidden_reversed", "[", "1", "]", ")", "\n", "\n", "return", "s_out", ",", "s_hidden", ",", "_", ",", "g_embedding", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.Attention.__init__": [[138, 158], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "torch.nn.init.uniform_", "float", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["def", "__init__", "(", "self", ",", "hidden_dim", ",", "C", "=", "10.0", ",", "T", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "Attention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\"\"\"\n        :param int hidden_dim: Number of hidden units in the query/ref\n        \"\"\"", "\n", "self", ".", "W1", "=", "nn", ".", "Conv1d", "(", "in_channels", "=", "hidden_dim", ",", "out_channels", "=", "hidden_dim", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "W2", "=", "nn", ".", "Linear", "(", "in_features", "=", "hidden_dim", ",", "\n", "out_features", "=", "hidden_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "V", "=", "nn", ".", "Linear", "(", "in_features", "=", "hidden_dim", ",", "\n", "out_features", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "C", "=", "C", "\n", "self", ".", "T", "=", "T", "\n", "\n", "# Initialize vector V", "\n", "torch", ".", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "V", ".", "weight", ",", "\n", "a", "=", "-", "1.0", "/", "math", ".", "sqrt", "(", "hidden_dim", ")", ",", "\n", "b", "=", "1.0", "/", "math", ".", "sqrt", "(", "hidden_dim", ")", ")", "\n", "self", ".", "_inf", "=", "float", "(", "'-inf'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.Attention.forward": [[159, 200], ["ref.permute.permute.permute", "ActorCriticNetwork.Attention.W1", "ref_W1.permute.permute.permute", "ActorCriticNetwork.Attention.W2().unsqueeze", "ActorCriticNetwork.Attention.V", "u_i.masked_fill_.masked_fill_.squeeze", "u_i.masked_fill_.masked_fill_.masked_fill_", "torch.softmax", "torch.softmax", "torch.softmax", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "q_a.squeeze.squeeze.squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.softmax.unsqueeze", "ActorCriticNetwork.Attention.W2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "\n", "ref", ",", "\n", "q", ",", "\n", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Attention - Forward-pass\n\n        :param Tensor decoder_state: Hidden state h of the decoder\n        :param Tensor encoder_outputs: Outputs of the encoder\n        :param Boolean mask: Selection mask\n        :return: tuple of - (Attentioned hidden state, Alphas)\n        \"\"\"", "\n", "# ref: (batch_size, n_nodes, hidden_dim)", "\n", "# permute: (batch_size, hidden_dim, n_nodes) for conv1d", "\n", "ref", "=", "ref", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "ref_W1", "=", "self", ".", "W1", "(", "ref", ")", "\n", "# ref_W1: (batch_size, n_nodes, hidden_dim)", "\n", "ref_W1", "=", "ref_W1", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "# q_W2: (batch_size, 1, hidden_dim)", "\n", "q_W2", "=", "self", ".", "W2", "(", "q", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# u_i: (batch_size, n_nodes, 1)", "\n", "u_i", "=", "self", ".", "V", "(", "tanh", "(", "ref_W1", "+", "q_W2", ")", ")", "\n", "\n", "# u_i: (batch_size, n_nodes)", "\n", "u_i", "=", "u_i", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "u_i", "=", "u_i", ".", "masked_fill_", "(", "mask", ",", "self", ".", "_inf", ")", "\n", "# print(\"u_i after mask\", u_i)", "\n", "\n", "u_i", "=", "self", ".", "C", "*", "tanh", "(", "u_i", "/", "self", ".", "T", ")", "\n", "# probs: (batch_size, n_nodes)", "\n", "probs", "=", "F", ".", "softmax", "(", "u_i", ",", "dim", "=", "1", ")", "\n", "\n", "# q_a: (batch, 1, hidden_dim)", "\n", "q_a", "=", "torch", ".", "bmm", "(", "probs", ".", "unsqueeze", "(", "1", ")", ",", "ref_W1", ")", "\n", "# hidden_state_dec: (batch, hidden_dim)", "\n", "q_a", "=", "q_a", ".", "squeeze", "(", "1", ")", "\n", "\n", "return", "probs", ",", "q_a", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.Decoder.__init__": [[207, 233], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "ActorCriticNetwork.Attention", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.init.uniform_", "torch.init.uniform_", "torch.init.uniform_", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "math.sqrt", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["def", "__init__", "(", "self", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_actions", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "n_actions", "=", "n_actions", "\n", "\n", "self", ".", "W_0", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", "\n", "self", ".", "W_1", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", "\n", "\n", "self", ".", "W_star", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", "//", "2", ")", "\n", "self", ".", "W_s", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", "//", "2", ")", "\n", "\n", "self", ".", "att", "=", "Attention", "(", "hidden_dim", ")", "\n", "\n", "self", ".", "mask", "=", "Parameter", "(", "torch", ".", "ones", "(", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "runner", "=", "Parameter", "(", "torch", ".", "zeros", "(", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n", "self", ".", "init_dec", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "hidden_dim", ")", ",", "\n", "requires_grad", "=", "False", ")", "\n", "\n", "nn", ".", "init", ".", "uniform_", "(", "self", ".", "init_dec", ",", "-", "1", "/", "math", ".", "sqrt", "(", "hidden_dim", ")", ",", "\n", "1", "/", "math", ".", "sqrt", "(", "hidden_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.Decoder.forward": [[234, 333], ["ref.size", "ref.size", "ActorCriticNetwork.Decoder.mask.repeat", "ActorCriticNetwork.Decoder.runner.repeat", "range", "runner.unsqueeze().expand().long.unsqueeze().expand().long.unsqueeze().expand().long", "ActorCriticNetwork.Decoder.init_dec.unsqueeze().expand", "range", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.tanh", "torch.tanh", "torch.tanh", "ActorCriticNetwork.Decoder.att", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical", "torch.distributions.Categorical.sample.unsqueeze().expand", "one_pointers.unsqueeze.unsqueeze.unsqueeze", "one_pointers.unsqueeze.unsqueeze.expand().bool", "masked_dec_input.view", "torch.cat().permute.append", "torch.cat().permute.append", "torch.cat().permute.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "entropy.append", "runner.unsqueeze().expand().long.unsqueeze().expand().long.unsqueeze().expand", "ActorCriticNetwork.Decoder.init_dec.unsqueeze", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.sample", "torch.distributions.Categorical.log_prob", "torch.distributions.Categorical.log_prob", "torch.distributions.Categorical.log_prob", "torch.distributions.Categorical.entropy", "torch.distributions.Categorical.entropy", "torch.distributions.Categorical.entropy", "torch.distributions.Categorical.log_prob", "torch.distributions.Categorical.log_prob", "torch.distributions.Categorical.log_prob", "torch.distributions.Categorical.entropy", "torch.distributions.Categorical.entropy", "torch.distributions.Categorical.entropy", "prob.unsqueeze", "torch.distributions.Categorical.sample.unsqueeze", "torch.distributions.Categorical.log_prob.unsqueeze", "torch.distributions.Categorical.entropy.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "ActorCriticNetwork.Decoder.W_star", "ActorCriticNetwork.Decoder.W_s", "ActorCriticNetwork.Decoder.W_1", "ActorCriticNetwork.Decoder.W_0", "torch.distributions.Categorical.sample.unsqueeze", "one_pointers.unsqueeze.unsqueeze.expand", "runner.unsqueeze().expand().long.unsqueeze().expand().long.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "ref", ",", "inp", ",", "actions", "=", "None", ",", "g_emb", "=", "None", ",", "q_star", "=", "None", ")", ":", "\n", "\n", "        ", "batch_size", "=", "ref", ".", "size", "(", "0", ")", "\n", "n_nodes", "=", "ref", ".", "size", "(", "1", ")", "\n", "\n", "if", "g_emb", "is", "not", "None", ":", "\n", "            ", "g_emb", ",", "_", "=", "torch", ".", "max", "(", "g_emb", ",", "dim", "=", "1", ")", "\n", "\n", "# mask: (batch, n_nodes) filled with 1's", "\n", "", "mask", "=", "self", ".", "mask", ".", "repeat", "(", "(", "batch_size", ",", "n_nodes", ")", ")", "\n", "\n", "# runner: (input_lenght) tensor filled with 0's", "\n", "runner", "=", "self", ".", "runner", ".", "repeat", "(", "n_nodes", ")", "\n", "# runner: (input_lenght) tensor from {0 to input_lenght-1}", "\n", "for", "i", "in", "range", "(", "n_nodes", ")", ":", "\n", "            ", "runner", ".", "data", "[", "i", "]", "=", "i", "\n", "# (batch, seq_len) filled with {0,...,seq-len-1}", "\n", "", "runner", "=", "runner", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "if", "q_star", "is", "not", "None", ":", "\n", "            ", "q_star_h", ",", "q_star_c", "=", "q_star", "\n", "q_h", ",", "q_c", "=", "q", "\n", "\n", "q_h", "=", "torch", ".", "cat", "(", "[", "self", ".", "W_star", "(", "q_star_h", ")", ",", "self", ".", "W_s", "(", "q_h", ")", "]", ",", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "# h,c: input should be tuple(2) of (batch_size, hidden_dim)", "\n", "            ", "q_h", ",", "q_c", "=", "q", "\n", "# dec_input: (batch_size, embedding_dim)", "\n", "", "dec_input", "=", "self", ".", "init_dec", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "batch_size", ",", "-", "1", ")", "\n", "if", "g_emb", "is", "not", "None", ":", "\n", "            ", "h", "=", "q_h", "+", "g_emb", "\n", "", "else", ":", "\n", "            ", "h", "=", "q_h", "\n", "# lists for the outputs", "\n", "", "probs", "=", "[", "]", "\n", "pointers", "=", "[", "]", "\n", "log_probs_pts", "=", "[", "]", "\n", "entropy", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_actions", ")", ":", "\n", "            ", "if", "i", "==", "0", ":", "\n", "# if it's the first output mask the last index", "\n", "                ", "mask", "[", ":", ",", "-", "1", "]", "=", "0", "\n", "", "if", "i", "==", "1", ":", "\n", "# return the last index", "\n", "                ", "mask", "[", ":", ",", "-", "1", "]", "=", "1", "\n", "\n", "", "h", "=", "tanh", "(", "self", ".", "W_1", "(", "h", ")", "+", "self", ".", "W_0", "(", "dec_input", ")", ")", "\n", "\n", "prob", ",", "_", "=", "self", ".", "att", "(", "ref", ",", "h", ",", "torch", ".", "eq", "(", "mask", ",", "0", ")", ")", "\n", "\n", "# # Masking selected inputs", "\n", "# masked_outs: (batch, seq_len)", "\n", "masked_prob", "=", "prob", "*", "mask", "\n", "\n", "c", "=", "torch", ".", "distributions", ".", "Categorical", "(", "masked_prob", ")", "\n", "if", "actions", "is", "None", ":", "\n", "                ", "indices", "=", "c", ".", "sample", "(", ")", "\n", "log_probs_idx", "=", "c", ".", "log_prob", "(", "indices", ")", "\n", "dist_entropy", "=", "c", ".", "entropy", "(", ")", "\n", "", "else", ":", "\n", "                ", "indices", "=", "actions", "[", ":", ",", "i", "]", "\n", "log_probs_idx", "=", "c", ".", "log_prob", "(", "indices", ")", "\n", "dist_entropy", "=", "c", ".", "entropy", "(", ")", "\n", "\n", "", "repeat_indices", "=", "indices", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "-", "1", ",", "n_nodes", ")", "\n", "\n", "# 1-pointers probs indices i.e. if idx= 4 and len = 5", "\n", "# one_hot_pointers[0] = [0, 0 , 0 , 0 , 1]", "\n", "# one_hot_pointers: (batch_size, seq_len)", "\n", "one_pointers", "=", "(", "runner", "==", "repeat_indices", ")", ".", "float", "(", ")", "\n", "lower_pointers", "=", "(", "runner", "<=", "repeat_indices", ")", ".", "float", "(", ")", "\n", "\n", "# Update mask to ignore seen indices", "\n", "# (mask gets updated from 1 --> 0 for seen indices)", "\n", "# mask: (batch_size, seq_len)", "\n", "mask", "=", "mask", "*", "(", "1", "-", "lower_pointers", ")", "\n", "\n", "# embbeding mask: boolean (batch size, seq_len, embbeding_dim)", "\n", "# True for the pointed input False otherwise", "\n", "one_pointers", "=", "one_pointers", ".", "unsqueeze", "(", "2", ")", "\n", "dec_input_mask", "=", "one_pointers", ".", "expand", "(", "-", "1", ",", "\n", "-", "1", ",", "\n", "self", ".", "hidden_dim", ")", ".", "bool", "(", ")", "\n", "masked_dec_input", "=", "inp", "[", "dec_input_mask", ".", "data", "]", "\n", "dec_input", "=", "masked_dec_input", ".", "view", "(", "batch_size", ",", "self", ".", "hidden_dim", ")", "\n", "\n", "# outputs: list of softmax outputs of size (1, batch_size, seq_len)", "\n", "probs", ".", "append", "(", "prob", ".", "unsqueeze", "(", "0", ")", ")", "\n", "pointers", ".", "append", "(", "indices", ".", "unsqueeze", "(", "1", ")", ")", "\n", "log_probs_pts", ".", "append", "(", "log_probs_idx", ".", "unsqueeze", "(", "1", ")", ")", "\n", "entropy", ".", "append", "(", "dist_entropy", ".", "unsqueeze", "(", "1", ")", ")", "\n", "\n", "", "probs", "=", "torch", ".", "cat", "(", "probs", ")", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "# pointers: index outputs (batch_size, n_actions)", "\n", "pointers", "=", "torch", ".", "cat", "(", "pointers", ",", "1", ")", "\n", "log_probs_pts", "=", "torch", ".", "cat", "(", "log_probs_pts", ",", "1", ")", "\n", "entropies", "=", "torch", ".", "cat", "(", "entropy", ",", "1", ")", "\n", "\n", "return", "probs", ",", "pointers", ",", "log_probs_pts", ",", "entropies", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.ActorCriticNetwork.__init__": [[341, 383], ["torch.Module.__init__", "ActorCriticNetwork.Encoder", "ActorCriticNetwork.Encoder", "ActorCriticNetwork.Decoder", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["def", "__init__", "(", "self", ",", "\n", "input_dim", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_nodes", ",", "\n", "n_rnn_layers", ",", "\n", "n_actions", ",", "\n", "graph_ref", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        :param int embedding_dim: Number of embbeding dimensions\n        :param int hidden_dim: Encoder/Decoder hidden units\n        :param int lstm_layers: Number of LSTM layers\n        :param bool bidir: Bidirectional\n        :param bool batch_first: Batch first in the LSTM\n        \"\"\"", "\n", "\n", "super", "(", "ActorCriticNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "encoder", "=", "Encoder", "(", "input_dim", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_nodes", ",", "\n", "n_rnn_layers", ")", "\n", "\n", "self", ".", "encoder_star", "=", "Encoder", "(", "input_dim", ",", "\n", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_nodes", ",", "\n", "n_rnn_layers", ")", "\n", "\n", "self", ".", "decoder_a", "=", "Decoder", "(", "embedding_dim", ",", "\n", "hidden_dim", ",", "\n", "n_actions", ")", "\n", "\n", "self", ".", "W_star", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", "//", "2", ")", "\n", "self", ".", "W_s", "=", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", "//", "2", ")", "\n", "\n", "self", ".", "decoder_c", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_dim", ",", "1", ")", ")", "\n", "self", ".", "graph_ref", "=", "graph_ref", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.ActorCriticNetwork.ActorCriticNetwork.forward": [[384, 407], ["ActorCriticNetwork.ActorCriticNetwork.encoder_star", "ActorCriticNetwork.ActorCriticNetwork.encoder", "ActorCriticNetwork.ActorCriticNetwork.decoder_a", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.mean().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "ActorCriticNetwork.ActorCriticNetwork.decoder_c", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "ActorCriticNetwork.ActorCriticNetwork.W_star", "ActorCriticNetwork.ActorCriticNetwork.W_s"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "inputs_star", ",", "hidden", "=", "None", ",", "actions", "=", "None", ")", ":", "\n", "\n", "        ", "_", ",", "s_hidden_star", ",", "_", ",", "_", "=", "self", ".", "encoder_star", "(", "inputs_star", ",", "hidden", ")", "\n", "\n", "s_out", ",", "s_hidden", ",", "_", ",", "g_embedding", "=", "self", ".", "encoder", "(", "inputs", ",", "hidden", ")", "\n", "\n", "# enc_h: get the last layer of the LSTM encoder", "\n", "enc_h", "=", "(", "s_hidden", "[", "0", "]", "[", "-", "1", "]", ",", "s_hidden", "[", "1", "]", "[", "-", "1", "]", ")", "\n", "enc_h_star", "=", "(", "s_hidden_star", "[", "0", "]", "[", "-", "1", "]", ",", "s_hidden_star", "[", "1", "]", "[", "-", "1", "]", ")", "\n", "\n", "probs", ",", "pts", ",", "log_probs_pts", ",", "entropies", "=", "self", ".", "decoder_a", "(", "enc_h", ",", "\n", "s_out", ",", "\n", "s_out", ",", "\n", "actions", ",", "\n", "g_embedding", ",", "\n", "enc_h_star", ")", "\n", "\n", "v_g", "=", "torch", ".", "mean", "(", "g_embedding", ",", "dim", "=", "1", ")", ".", "squeeze", "(", "1", ")", "\n", "h_v", "=", "torch", ".", "cat", "(", "[", "self", ".", "W_star", "(", "enc_h_star", "[", "0", "]", ")", ",", "self", ".", "W_s", "(", "enc_h", "[", "0", "]", ")", "]", ",", "\n", "dim", "=", "1", ")", "\n", "v", "=", "self", ".", "decoder_c", "(", "v_g", "+", "h_v", ")", "\n", "\n", "return", "probs", ",", "pts", ",", "log_probs_pts", ",", "v", ",", "entropies", ",", "enc_h", "\n", "", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP50_100.buffer.__init__": [[196, 204], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "# action & reward buffer", "\n", "        ", "self", ".", "actions", "=", "[", "]", "\n", "self", ".", "states", "=", "[", "]", "\n", "self", ".", "log_probs", "=", "[", "]", "\n", "self", ".", "rewards", "=", "[", "]", "\n", "self", ".", "values", "=", "[", "]", "\n", "self", ".", "entropies", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP50_100.buffer.clear_buffer": [[205, 212], ["None"], "methods", ["None"], ["", "def", "clear_buffer", "(", "self", ")", ":", "\n", "        ", "del", "self", ".", "actions", "[", ":", "]", "\n", "del", "self", ".", "states", "[", ":", "]", "\n", "del", "self", ".", "log_probs", "[", ":", "]", "\n", "del", "self", ".", "rewards", "[", ":", "]", "\n", "del", "self", ".", "values", "[", ":", "]", "\n", "del", "self", ".", "entropies", "[", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP50_100.select_action": [[214, 225], ["policy", "buffer.log_probs.append", "buffer.states.append", "buffer.actions.append", "buffer.values.append", "buffer.entropies.append"], "function", ["None"], ["", "", "def", "select_action", "(", "state", ",", "hidden", ",", "buffer", ",", "best_state", ")", ":", "\n", "\n", "    ", "probs", ",", "action", ",", "log_probs_action", ",", "v", ",", "entropy", ",", "hidden", "=", "policy", "(", "state", ",", "\n", "best_state", ",", "\n", "hidden", ")", "\n", "buffer", ".", "log_probs", ".", "append", "(", "log_probs_action", ")", "\n", "buffer", ".", "states", ".", "append", "(", "state", ")", "\n", "buffer", ".", "actions", ".", "append", "(", "action", ")", "\n", "buffer", ".", "values", ".", "append", "(", "v", ")", "\n", "buffer", ".", "entropies", ".", "append", "(", "entropy", ")", "\n", "return", "action", ",", "v", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP50_100.learn": [[227, 323], ["reversed", "torch.stack().detach", "torch.stack().detach", "torch.stack", "torch.stack", "torch.stack().mean().unsqueeze", "torch.stack().mean().unsqueeze", "torch.stack().mean().unsqueeze", "torch.stack().mean().unsqueeze", "optimizer.zero_grad", "numpy.concatenate", "optimizer.step", "torch.stack().detach.mean", "advantages.mean", "numpy.sqrt", "numpy.max", "numpy.var", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "epoch_train_policy_loss.update", "epoch_train_entropy_loss.update", "epoch_train_value_loss.update", "epoch_train_loss.update", "PGTSP50_100.buffer.clear_buffer", "epoch_train_policy_loss.reset", "epoch_train_entropy_loss.reset", "epoch_train_value_loss.reset", "epoch_train_loss.reset", "torch.zeros().to", "torch.zeros().to", "range", "torch.stack().detach.insert", "torch.stack().detach.mean", "torch.stack().detach.std", "numpy.finfo().eps.item", "torch.stack().mean().unsqueeze.sum().mean", "apex.amp.scale_loss", "scaled_p_loss.backward", "apex.amp.scale_loss", "scaled_r_loss.backward", "numpy.mean", "numpy.abs", "p_loss.item", "v_loss.item", "loss.item", "len", "torch.stack", "torch.stack", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "torch.stack().mean", "p.grad.data.cpu().numpy().flatten", "numpy.square", "e_loss.item", "torch.zeros", "torch.zeros", "advantages.detach", "torch.stack().mean().unsqueeze.sum", "policy.parameters", "numpy.finfo", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "p.grad.data.cpu().numpy", "p.grad.data.cpu"], "function", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.TSPEnvironment.VecEnv.step", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.update", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.PGTSP50_100.buffer.clear_buffer", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.utils.AverageMeter.reset"], ["", "def", "learn", "(", "R", ",", "t_s", ",", "beta", ",", "zeta", ",", "count_learn", ",", "epoch", ")", ":", "\n", "    ", "\"\"\"\n    Training. Calcultes actor and critic losses and performs backprop.\n    \"\"\"", "\n", "\n", "count_steps", "=", "0", "\n", "sum_returns", "=", "0.0", "\n", "sum_advantage", "=", "0.0", "\n", "sum_loss_actor", "=", "0.0", "\n", "sum_loss_critic", "=", "0.0", "\n", "sum_entropy", "=", "0.0", "\n", "sum_loss_total", "=", "0.0", "\n", "sum_grads_l2", "=", "0.0", "\n", "sum_grads_max", "=", "0.0", "\n", "sum_grads_var", "=", "0.0", "\n", "\n", "# Starting sum of losses for logging", "\n", "if", "t_s", "==", "0", ":", "\n", "        ", "epoch_train_policy_loss", ".", "reset", "(", ")", "\n", "epoch_train_entropy_loss", ".", "reset", "(", ")", "\n", "epoch_train_value_loss", ".", "reset", "(", ")", "\n", "epoch_train_loss", ".", "reset", "(", ")", "\n", "\n", "# Returns", "\n", "", "if", "R", "is", "None", ":", "\n", "        ", "R", "=", "torch", ".", "zeros", "(", "(", "args", ".", "batch_size", ",", "1", ")", ")", ".", "to", "(", "device", ")", "\n", "", "returns", "=", "[", "]", "# returns for each state discounted", "\n", "for", "s", "in", "reversed", "(", "range", "(", "len", "(", "buffer", ".", "rewards", ")", ")", ")", ":", "\n", "        ", "R", "=", "buffer", ".", "rewards", "[", "s", "]", "+", "args", ".", "gamma", "*", "R", "\n", "returns", ".", "insert", "(", "0", ",", "R", ")", "\n", "\n", "", "returns", "=", "torch", ".", "stack", "(", "returns", ")", ".", "detach", "(", ")", "\n", "if", "not", "args", ".", "no_norm_return", ":", "\n", "        ", "r_mean", "=", "returns", ".", "mean", "(", ")", "\n", "r_std", "=", "returns", ".", "std", "(", ")", "\n", "eps", "=", "np", ".", "finfo", "(", "np", ".", "float32", ")", ".", "eps", ".", "item", "(", ")", "# small number to avoid div/0", "\n", "returns", "=", "(", "returns", "-", "r_mean", ")", "/", "(", "r_std", "+", "eps", ")", "\n", "\n", "# num of experiences in this \"batch\" of experiences", "\n", "", "n_experiences", "=", "args", ".", "batch_size", "*", "args", ".", "n", "\n", "# transform lists to tensor", "\n", "values", "=", "torch", ".", "stack", "(", "buffer", ".", "values", ")", "\n", "log_probs", "=", "torch", ".", "stack", "(", "buffer", ".", "log_probs", ")", ".", "mean", "(", "2", ")", ".", "unsqueeze", "(", "2", ")", "\n", "entropies", "=", "torch", ".", "stack", "(", "buffer", ".", "entropies", ")", ".", "mean", "(", "2", ")", ".", "unsqueeze", "(", "2", ")", "\n", "advantages", "=", "returns", "-", "values", "\n", "p_loss", "=", "(", "-", "log_probs", "*", "advantages", ".", "detach", "(", ")", ")", ".", "mean", "(", ")", "\n", "v_loss", "=", "zeta", "*", "(", "returns", "-", "values", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "e_loss", "=", "(", "0.9", "**", "(", "epoch", "+", "1", ")", ")", "*", "beta", "*", "entropies", ".", "sum", "(", "0", ")", ".", "mean", "(", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "with", "amp", ".", "scale_loss", "(", "p_loss", ",", "optimizer", ")", "as", "scaled_p_loss", ":", "\n", "        ", "scaled_p_loss", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "# p_loss.backward(retain_graph=True)", "\n", "", "grads", "=", "np", ".", "concatenate", "(", "[", "p", ".", "grad", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "for", "p", "in", "policy", ".", "parameters", "(", ")", "\n", "if", "p", ".", "grad", "is", "not", "None", "]", ")", "\n", "\n", "r_loss", "=", "-", "e_loss", "+", "v_loss", "\n", "with", "amp", ".", "scale_loss", "(", "r_loss", ",", "optimizer", ")", "as", "scaled_r_loss", ":", "\n", "        ", "scaled_r_loss", ".", "backward", "(", ")", "\n", "# r_loss.backward()", "\n", "# nn.utils.clip_grad_norm_(policy.parameters(), args.max_grad_norm)", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "loss", "=", "p_loss", "+", "r_loss", "\n", "\n", "# track statistics", "\n", "sum_returns", "+=", "returns", ".", "mean", "(", ")", "\n", "sum_advantage", "+=", "advantages", ".", "mean", "(", ")", "\n", "sum_loss_actor", "+=", "p_loss", "\n", "sum_loss_critic", "+=", "v_loss", "\n", "sum_loss_total", "+=", "loss", "\n", "sum_entropy", "+=", "e_loss", "\n", "\n", "sum_grads_l2", "+=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "np", ".", "square", "(", "grads", ")", ")", ")", "\n", "sum_grads_max", "+=", "np", ".", "max", "(", "np", ".", "abs", "(", "grads", ")", ")", "\n", "sum_grads_var", "+=", "np", ".", "var", "(", "grads", ")", "\n", "\n", "count_steps", "+=", "1", "\n", "\n", "writer", ".", "add_scalar", "(", "\"Returns\"", ",", "sum_returns", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Advantage\"", ",", "sum_advantage", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Actor\"", ",", "sum_loss_actor", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Critic\"", ",", "sum_loss_critic", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Entropy\"", ",", "sum_entropy", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Loss_Total\"", ",", "sum_loss_total", "/", "count_steps", ",", "count_learn", ")", "\n", "\n", "writer", ".", "add_scalar", "(", "\"Gradients_L2\"", ",", "sum_grads_l2", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Gradients_Max\"", ",", "sum_grads_max", "/", "count_steps", ",", "count_learn", ")", "\n", "writer", ".", "add_scalar", "(", "\"Gradients_Var\"", ",", "sum_grads_var", "/", "count_steps", ",", "count_learn", ")", "\n", "\n", "epoch_train_policy_loss", ".", "update", "(", "p_loss", ".", "item", "(", ")", ",", "n_experiences", ")", "\n", "epoch_train_entropy_loss", ".", "update", "(", "e_loss", ".", "item", "(", ")", "/", "args", ".", "n", ",", "n_experiences", ")", "\n", "epoch_train_value_loss", ".", "update", "(", "v_loss", ".", "item", "(", ")", ",", "n_experiences", ")", "\n", "epoch_train_loss", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "n_experiences", ")", "\n", "\n", "buffer", ".", "clear_buffer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.DataGenerator.TSPDataset.__init__": [[14, 38], ["torch.utils.data.Dataset.__init__", "len", "random.seed", "print", "pandas.read_json", "random.sample", "tqdm.tqdm.tqdm", "range", "range", "DataGenerator.TSPDataset.data_set.append", "DataGenerator.TSPDataset.opt.append", "torch.FloatTensor().uniform_", "DataGenerator.TSPDataset.data_set.append", "len", "torch.from_numpy", "numpy.array", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset_fname", "=", "None", ",", "size", "=", "50", ",", "num_samples", "=", "10", ",", "seed", "=", "None", ")", ":", "\n", "        ", "super", "(", "TSPDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "data_set", "=", "[", "]", "\n", "self", ".", "opt", "=", "[", "]", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "random", ".", "seed", "(", "seed", ")", "\n", "", "if", "dataset_fname", "is", "not", "None", ":", "\n", "            ", "print", "(", "'  [*] Loading dataset from {}'", ".", "format", "(", "dataset_fname", ")", ")", "\n", "dset", "=", "pd", ".", "read_json", "(", "dataset_fname", ")", "\n", "ids", "=", "random", ".", "sample", "(", "range", "(", "len", "(", "dset", ")", ")", ",", "num_samples", ")", "\n", "for", "i", "in", "tqdm", "(", "ids", ")", ":", "\n", "                ", "self", ".", "data_set", ".", "append", "(", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "dset", ".", "iloc", "[", "i", ",", "\n", "0", "]", ")", ")", ")", "\n", "self", ".", "opt", ".", "append", "(", "dset", ".", "iloc", "[", "i", ",", "-", "1", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "\n", "# randomly sample points uniformly from [0, 1]^2", "\n", "            ", "for", "i", "in", "range", "(", "num_samples", ")", ":", "\n", "                ", "x", "=", "torch", ".", "FloatTensor", "(", "size", ",", "2", ")", ".", "uniform_", "(", "0", ",", "1", ")", "\n", "self", ".", "data_set", ".", "append", "(", "x", ")", "\n", "\n", "", "", "self", ".", "size", "=", "len", "(", "self", ".", "data_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.DataGenerator.TSPDataset.__len__": [[39, 41], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.DataGenerator.TSPDataset.__getitem__": [[42, 44], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "self", ".", "data_set", "[", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.__init__": [[21, 27], ["att_paper_utils.make_dataset", "len", "OptimalAttentionPaperMP.GenerateOptimalTSP.generate_data"], "methods", ["home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.att_paper_utils.make_dataset", "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.generate_data"], ["def", "__init__", "(", "self", ",", "data_path", ",", "n_points", ",", "solve", "=", "True", ")", ":", "\n", "        ", "self", ".", "data", "=", "utils", ".", "make_dataset", "(", "filename", "=", "data_path", ")", "\n", "self", ".", "data_size", "=", "len", "(", "self", ".", "data", ")", "\n", "self", ".", "n_points", "=", "n_points", "\n", "self", ".", "solve", "=", "solve", "\n", "self", ".", "generate_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.paulorocosta_learning-2opt-drl.None.OptimalAttentionPaperMP.GenerateOptimalTSP.generate_data": [[28, 92], ["tqdm.tqdm.tqdm", "enumerate", "tqdm.tqdm.tqdm", "pandas.DataFrame", "pandas.DataFrame.to_json", "range", "tqdm.tqdm.tqdm.set_description", "numpy.array", "points_list.append", "os.cpu_count", "enumerate", "print", "multiprocessing.Pool", "concorde.tsp.TSPSolver.from_data", "result.extend", "multiprocessing.Pool", "p.imap", "numpy.mean", "numpy.sqrt", "numpy.std", "len", "str"], "methods", ["None"], ["", "def", "generate_data", "(", "self", ")", ":", "\n", "\n", "        ", "points_list", "=", "[", "]", "\n", "solutions", "=", "[", "]", "\n", "opt_dists", "=", "[", "]", "\n", "\n", "data_iter", "=", "tqdm", "(", "range", "(", "self", ".", "data_size", ")", ",", "unit", "=", "'data'", ")", "\n", "for", "i", ",", "_", "in", "enumerate", "(", "data_iter", ")", ":", "\n", "            ", "data_iter", ".", "set_description", "(", "'Generating data points %i/%i'", "\n", "%", "(", "i", "+", "1", ",", "self", ".", "data_size", ")", ")", "\n", "\n", "points", "=", "np", ".", "array", "(", "self", ".", "data", "[", "i", "]", ")", "\n", "\n", "points_list", ".", "append", "(", "points", ")", "\n", "\n", "# solutions_iter: for tqdm", "\n", "", "solutions_iter", "=", "tqdm", "(", "points_list", ",", "unit", "=", "'solve'", ")", "\n", "if", "self", ".", "solve", ":", "\n", "\n", "            ", "num_cpus", "=", "os", ".", "cpu_count", "(", ")", "\n", "\n", "result", "=", "[", "]", "\n", "# start = time.perf_counter()", "\n", "with", "mp", ".", "Pool", "(", "num_cpus", ")", "as", "p", ":", "\n", "                ", "r", "=", "p", ".", "map", "\n", "", "for", "i", ",", "points", "in", "enumerate", "(", "solutions_iter", ")", ":", "\n", "                ", "points_scaled", "=", "points", "*", "10000", "\n", "solver", "=", "TSPSolver", ".", "from_data", "(", "points_scaled", "[", ":", ",", "0", "]", ",", "\n", "points_scaled", "[", ":", ",", "1", "]", ",", "\n", "'EUC_2D'", ")", "\n", "with", "mp", ".", "Pool", "(", "num_cpus", ")", "as", "p", ":", "\n", "                        ", "r", "=", "p", ".", "imap", "(", "solver", ".", "solve", ")", "\n", "\n", "", "result", ".", "extend", "(", "r", ")", "\n", "\n", "\n", "\n", "\n", "# for i, points in enumerate(solutions_iter):", "\n", "#     solutions_iter.set_description('Solved %i/%i'", "\n", "#                                    % (i+1, len(points_list)))", "\n", "#", "\n", "#     points_scaled = points*10000", "\n", "#     solver = TSPSolver.from_data(points_scaled[:, 0],", "\n", "#                                  points_scaled[:, 1],", "\n", "#                                  'EUC_2D')", "\n", "#     sol = solver.solve(time_bound=-1, verbose=False)", "\n", "#     opt_tour, opt_dist = sol.tour, sol.optimal_value/10000", "\n", "#     solutions.append(opt_tour)", "\n", "#     opt_dists.append(opt_dist)", "\n", "\n", "", "", "else", ":", "\n", "            ", "solutions", "=", "None", "\n", "opt_dists", "=", "None", "\n", "\n", "", "if", "self", ".", "solve", ":", "\n", "\n", "            ", "print", "(", "'  [*] Avg Optimal Tour {:.5f} +- {:.5f}'", ".", "format", "(", "np", ".", "mean", "(", "opt_dists", ")", ",", "2", "*", "np", ".", "std", "(", "opt_dists", ")", "/", "np", ".", "sqrt", "(", "len", "(", "opt_dists", ")", ")", ")", ")", "\n", "\n", "", "data", "=", "{", "'Points'", ":", "points_list", ",", "\n", "'OptTour'", ":", "solutions", ",", "\n", "'OptDistance'", ":", "opt_dists", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ")", "\n", "df", ".", "to_json", "(", "path_or_buf", "=", "'data/att-TSP'", "+", "str", "(", "self", ".", "n_points", ")", "+", "'-data-test'", "+", "'.json'", ")", "\n", "\n"]]}