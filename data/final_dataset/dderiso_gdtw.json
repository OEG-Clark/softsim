{"home.repos.pwc.inspect_result.dderiso_gdtw.None.setup.BuildExt.build_extensions": [[21, 35], ["super().build_extensions", "os.system", "setuptools.setup.BuildExt.compiler.compiler_so.append", "setuptools.setup.BuildExt.compiler.compiler_so.remove"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.None.setup.BuildExt.build_extensions"], ["  ", "def", "build_extensions", "(", "self", ")", ":", "\n", "    ", "cc", "=", "os", ".", "environ", "[", "\"CC\"", "]", "if", "\"CC\"", "in", "os", ".", "environ", "else", "None", "\n", "if", "sys", ".", "platform", "==", "'darwin'", ":", "\n", "      ", "if", "os", ".", "system", "(", "\"which clang\"", ")", "==", "0", ":", "\n", "        ", "cc", "=", "\"clang\"", "\n", "self", ".", "compiler", ".", "compiler_so", ".", "append", "(", "'-stdlib=libc++'", ")", "\n", "self", ".", "compiler", ".", "compiler_so", ".", "remove", "(", "'-Wstrict-prototypes'", ")", "# gets rid of a useless warning", "\n", "", "", "elif", "sys", ".", "platform", "==", "'linux'", ":", "\n", "      ", "cc", "=", "\"g++\"", "\n", "", "if", "cc", "is", "not", "None", ":", "\n", "      ", "self", ".", "compiler", ".", "compiler_so", "[", "0", "]", "=", "cc", "\n", "self", ".", "compiler", ".", "compiler", "[", "0", "]", "=", "cc", "\n", "self", ".", "compiler", ".", "linker_so", "[", "0", "]", "=", "cc", "\n", "", "super", "(", "BuildExt", ",", "self", ")", ".", "build_extensions", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.Signal.__init__": [[32, 40], ["signal.Signal.check_signal"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.Signal.check_signal"], ["    ", "def", "__init__", "(", "self", ",", "z", ",", "name", ",", "N", ",", "scale_signals", "=", "True", ",", "scale_range", "=", "[", "-", "1", ",", "1", "]", ",", "verbose", "=", "0", ")", ":", "\n", "        ", "self", ".", "scale_signals", "=", "scale_signals", "\n", "self", ".", "scale_range", "=", "scale_range", "\n", "self", ".", "N", "=", "N", "\n", "self", ".", "z", "=", "z", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "check_signal", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.Signal.check_signal": [[41, 122], ["callable", "numpy.linspace().astype", "signal.Signal.z_f", "isinstance", "isinstance", "numpy.array", "numpy.linspace().astype", "signal.piecewise_linear_interpolate", "isinstance", "numpy.linspace", "utils.scale", "signal.piecewise_linear_interpolate", "utils.scale", "print", "signal.Signal.z_f().min", "signal.Signal.z_f().max", "signal.Signal.z_f", "print", "numpy.linspace", "len", "ValueError", "signal.piecewise_linear_interpolate", "ValueError", "isinstance", "isinstance", "numpy.array", "ValueError", "utils.scale", "isinstance", "isinstance", "numpy.array", "signal.Signal.z_f", "signal.Signal.z_f", "ValueError"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.piecewise_linear_interpolate", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.utils.scale", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.piecewise_linear_interpolate", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.utils.scale", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.piecewise_linear_interpolate", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.utils.scale"], ["", "def", "check_signal", "(", "self", ")", ":", "\n", "\n", "# Case 1: If our signal is a function,", "\n", "        ", "if", "callable", "(", "self", ".", "z", ")", ":", "\n", "\n", "# we'll keep it that way, though we may scale it.", "\n", "            ", "self", ".", "z_f", "=", "self", ".", "z", "\n", "# Since we're not given an explicit time sequence, we'll construct one assuming evenly spaced samples,", "\n", "t_z", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "self", ".", "N", ")", ".", "astype", "(", "np", ".", "double", ")", "\n", "# and generate an array.", "\n", "self", ".", "z_a", "=", "self", ".", "z_f", "(", "t_z", ")", "\n", "\n", "# If the user wants us to scale the signals, we'll have to test the range of the function.", "\n", "if", "self", ".", "scale_signals", ":", "\n", "# If the signal function doesn't already have the desired range,", "\n", "                ", "if", "self", ".", "z_f", "(", "t_z", ")", ".", "min", "(", ")", "!=", "self", ".", "scale_range", "[", "0", "]", "or", "self", ".", "z_f", "(", "t_z", ")", ".", "max", "(", ")", "!=", "self", ".", "scale_range", "[", "1", "]", ":", "\n", "# we'll construct a new scaled signal (which may be inaccurate)", "\n", "                    ", "self", ".", "z_a", "=", "scale", "(", "self", ".", "z_f", "(", "t_z", ")", ",", "self", ".", "scale_range", ")", "\n", "self", ".", "z_f", "=", "piecewise_linear_interpolate", "(", "t_z", ",", "self", ".", "z_a", ")", "\n", "# and alert the user of this choice.", "\n", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                        ", "print", "(", "f\"Signal {self.name} is given as a function that not scaled to the desired range. We're scaling it for you (which may be inaccurate), or else you'll have to modify the function yourself so that it meets the desired range.\"", ")", "\n", "\n", "# Case 2: If z is a sequence,", "\n", "", "", "", "", "elif", "isinstance", "(", "self", ".", "z", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "self", ".", "z", ",", "list", ")", ":", "\n", "# then ensure it's a numpy array.", "\n", "            ", "self", ".", "z_a", "=", "np", ".", "array", "(", "self", ".", "z", ",", "dtype", "=", "np", ".", "double", ")", "\n", "\n", "# If the user requests us to scale this signal (recommended to prevent numerical underflow),", "\n", "if", "self", ".", "scale_signals", ":", "\n", "# we'll scale the sequence to the desired range, given by the parameter self.scale_range.", "\n", "                ", "self", ".", "z_a", "=", "scale", "(", "self", ".", "z_a", ",", "self", ".", "scale_range", ")", "\n", "\n", "# Since we're not given an explicit time sequence, we'll construct one assuming evenly spaced samples,", "\n", "", "t_z", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "self", ".", "z_a", ".", "shape", "[", "0", "]", ")", ".", "astype", "(", "np", ".", "double", ")", "\n", "# and alert the user of this asssumption.", "\n", "if", "self", ".", "verbose", ">", "0", ":", "\n", "                ", "print", "(", "f\"Assuming {self.name} is sampled at even intervals. If this is incorrect, please set t_{self.name} explicitly by passing a tuple containing (array of signal samples, array of time steps).\"", ")", "\n", "\n", "# Finally, we'll construct a function from our signal samples using piecewise linear interpolation.", "\n", "", "self", ".", "z_f", "=", "piecewise_linear_interpolate", "(", "t_z", ",", "self", ".", "z_a", ")", "\n", "\n", "# Case 3: If z is a tuple,", "\n", "", "elif", "isinstance", "(", "self", ".", "z", ",", "tuple", ")", ":", "\n", "# then we would expect there to be only two elements: samples and time steps.", "\n", "            ", "if", "len", "(", "self", ".", "z", ")", "!=", "2", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Signal {self.name} is given as a tuple, but does not have 2 entries. A signal tuple should have the following form: (N-dimensional array of samples [x_1, x_2, ..., x_T], 1-dimensional array of time points [t_1, ..., t_T]).\"", ")", "\n", "# If that's true,", "\n", "", "else", ":", "\n", "# we'll unpack it", "\n", "                ", "self", ".", "z_a", ",", "t_z", "=", "self", ".", "z", "\n", "# and inspect the samples ", "\n", "if", "isinstance", "(", "self", ".", "z_a", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "self", ".", "z_a", ",", "list", ")", ":", "\n", "# to ensure it's a numpy array.", "\n", "                    ", "self", ".", "z_a", "=", "np", ".", "array", "(", "self", ".", "z_a", ",", "dtype", "=", "np", ".", "double", ")", "\n", "# If the samples aren't given as a sequence, then we'll have to stop here.", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "f\"Signal {self.name} is given as a tuple, but the first entry is not an array.\"", ")", "\n", "\n", "# If the user requests us to scale this signal (recommended to prevent numerical underflow),", "\n", "", "if", "self", ".", "scale_signals", ":", "\n", "# we'll scale the sequence to the desired range, given by the parameter self.scale_range.", "\n", "                    ", "self", ".", "z_a", "=", "scale", "(", "self", ".", "z_a", ",", "self", ".", "scale_range", ")", "\n", "\n", "# We'll also inspect the time steps ", "\n", "", "if", "isinstance", "(", "t_z", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "t_z", ",", "list", ")", ":", "\n", "# to ensure it's a numpy array", "\n", "                    ", "t_z", "=", "np", ".", "array", "(", "t_z", ",", "dtype", "=", "np", ".", "double", ")", "\n", "# and see if it's multidimensional. ", "\n", "if", "t_z", ".", "ndim", ">", "1", ":", "\n", "# If so, we'll complain.", "\n", "                        ", "raise", "ValueError", "(", "f\"Signal {name} is given as a tuple, but the second entry (time) is given as a multidimensional array. Time can only be 1-D.\"", ")", "\n", "\n", "# Finally, we'll construct a function from our signal samples using piecewise linear interpolation.", "\n", "", "", "self", ".", "z_f", "=", "piecewise_linear_interpolate", "(", "t_z", ",", "self", ".", "z_a", ")", "\n", "\n", "# If we're not given a signal, then we'll obviously throw an error.", "\n", "", "", "elif", "self", ".", "z", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Signal {self.name} is missing. Both signals (x and y) are required.\"", ")", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.Signal.get": [[123, 125], ["None"], "methods", ["None"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "z_a", ",", "self", ".", "z_f", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.piecewise_linear_interpolate": [[14, 16], ["numpy.interp"], "function", ["None"], ["def", "piecewise_linear_interpolate", "(", "t_z", ",", "z", ")", ":", "\n", "    ", "return", "lambda", "t_", ":", "np", ".", "interp", "(", "t_", ",", "t_z", ",", "z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.memoize": [[17, 25], ["hash", "arg.tobytes", "signal.array_to_memoized_f.f"], "function", ["None"], ["", "def", "memoize", "(", "f", ")", ":", "\n", "    ", "cache", "=", "{", "}", "\n", "def", "memoized_f", "(", "arg", ")", ":", "\n", "        ", "arg_hash", "=", "hash", "(", "arg", ".", "tobytes", "(", ")", ")", "\n", "if", "arg_hash", "not", "in", "cache", ":", "\n", "            ", "cache", "[", "arg_hash", "]", "=", "f", "(", "arg", ")", "\n", "", "return", "cache", "[", "arg_hash", "]", "\n", "", "return", "memoized_f", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.array_to_memoized_f": [[26, 30], ["signal.memoize", "numpy.interp"], "function", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.memoize"], ["", "def", "array_to_memoized_f", "(", "t_x", ",", "x", ")", ":", "\n", "    ", "def", "f", "(", "t_", ")", ":", "\n", "        ", "return", "np", ".", "interp", "(", "t_", ",", "t_x", ",", "x", ")", "\n", "", "return", "memoize", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.signal": [[126, 128], ["signal.Signal.get", "signal.Signal"], "function", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.Signal.get"], ["", "", "def", "signal", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "Signal", "(", "*", "args", ",", "**", "kwargs", ")", ".", "get", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.warp.warp": [[4, 8], ["gdtw.GDTW().set_params().run", "GDTW().set_params().run.x_f", "GDTW().set_params().run.f_tau.copy", "gdtw.GDTW().set_params", "dict", "gdtw.GDTW"], "function", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.run", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.set_params"], ["def", "warp", "(", "x", "=", "None", ",", "y", "=", "None", ",", "t", "=", "None", ",", "params", "=", "{", "}", ")", ":", "\n", "# directional warping: x(phi(t)) ~ y(t)", "\n", "    ", "g", "=", "GDTW", "(", ")", ".", "set_params", "(", "dict", "(", "params", ",", "x", "=", "x", ",", "y", "=", "y", ",", "t", "=", "t", ")", ")", ".", "run", "(", ")", "\n", "return", "g", ".", "phi", ",", "g", ".", "x_f", "(", "g", ".", "tau", ")", ",", "g", ".", "f_tau", ".", "copy", "(", ")", ",", "g", "", "", ""]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.__init__": [[8, 57], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "# generic input vars", "\n", "        ", "self", ".", "x", "=", "None", "\n", "self", ".", "x_a", "=", "None", "\n", "self", ".", "x_f", "=", "None", "\n", "self", ".", "y", "=", "None", "\n", "self", ".", "y_a", "=", "None", "\n", "self", ".", "y_f", "=", "None", "\n", "\n", "# params and loss, regularizer functionals", "\n", "self", ".", "t", "=", "None", "# t we integrate over", "\n", "self", ".", "lambda_cum", "=", "1", "\n", "self", ".", "lambda_inst", "=", ".1", "\n", "self", ".", "Loss", "=", "\"L2\"", "\n", "self", ".", "R_cum", "=", "\"L2\"", "\n", "self", ".", "R_inst", "=", "\"L2\"", "\n", "self", ".", "loss_f", "=", "None", "\n", "\n", "# search space size", "\n", "self", ".", "N", "=", "None", "\n", "self", ".", "N_default", "=", "300", "\n", "self", ".", "M", "=", "None", "\n", "self", ".", "M_max", "=", "300", "\n", "self", ".", "eta", "=", ".15", "\n", "\n", "# slope constraints and boundary conditions", "\n", "self", ".", "s_min", "=", "1e-8", "\n", "self", ".", "s_max", "=", "1e8", "\n", "self", ".", "s_beta", "=", "0", "\n", "self", ".", "BC_start_stop", "=", "True", "\n", "\n", "# termination conditions", "\n", "self", ".", "max_iters", "=", "10", "\n", "self", ".", "epsilon_abs", "=", "1e-1", "\n", "self", ".", "epsilon_rel", "=", "1e-2", "\n", "\n", "# for inspecting each iteration", "\n", "self", ".", "callback", "=", "False", "\n", "\n", "# misc.", "\n", "self", ".", "verbose", "=", "0", "\n", "self", ".", "uid", "=", "None", "\n", "\n", "# private", "\n", "self", ".", "vectorized_Loss", "=", "False", "\n", "self", ".", "D", "=", "None", "\n", "self", ".", "iteration", "=", "0", "\n", "self", ".", "time_solve", "=", "None", "\n", "self", ".", "f_tau_", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.allocate": [[58, 73], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.double", "numpy.interp"], "methods", ["None"], ["", "def", "allocate", "(", "self", ")", ":", "\n", "# graph", "\n", "        ", "self", ".", "Tau", "=", "np", ".", "zeros", "(", "(", "self", ".", "N", ",", "self", ".", "M", ")", ",", "dtype", "=", "np", ".", "double", ")", "\n", "self", ".", "u", "=", "None", "\n", "self", ".", "l", "=", "None", "\n", "self", ".", "u_orig", "=", "None", "\n", "self", ".", "l_orig", "=", "None", "\n", "\n", "# solution", "\n", "self", ".", "tau", "=", "np", ".", "zeros", "(", "self", ".", "N", ",", "dtype", "=", "np", ".", "double", ")", "# phi is continuous", "\n", "self", ".", "path", "=", "np", ".", "zeros", "(", "self", ".", "N", ",", "dtype", "=", "np", ".", "int", ")", "# path is discrete", "\n", "self", ".", "f_tau", "=", "np", ".", "double", "(", "0.0", ")", "\n", "self", ".", "phi", "=", "lambda", "t_", ":", "np", ".", "interp", "(", "t_", ",", "self", ".", "t", ",", "self", ".", "tau", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.compute_taus": [[74, 99], ["numpy.stack", "numpy.vstack", "numpy.dot", "numpy.min().astype", "numpy.max().astype", "numpy.min", "numpy.max", "gdtw.GDTW.u.copy", "gdtw.GDTW.l.copy", "numpy.min", "numpy.max", "numpy.double", "numpy.ones", "numpy.min", "numpy.max", "numpy.repeat", "numpy.repeat", "numpy.arange().astype", "numpy.double", "numpy.arange"], "methods", ["None"], ["", "def", "compute_taus", "(", "self", ")", ":", "\n", "# initial u and ls", "\n", "        ", "if", "self", ".", "iteration", "==", "0", ":", "\n", "            ", "self", ".", "u", "=", "np", ".", "min", "(", "[", "self", ".", "s_beta", "+", "self", ".", "s_max", "*", "self", ".", "t", ",", "self", ".", "s_beta", "+", "1", "-", "self", ".", "s_min", "*", "(", "1", "-", "self", ".", "t", ")", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "double", ")", "\n", "self", ".", "l", "=", "np", ".", "max", "(", "[", "self", ".", "s_min", "*", "self", ".", "t", ",", "-", "self", ".", "s_beta", "+", "1", "-", "self", ".", "s_max", "*", "(", "1", "-", "self", ".", "t", ")", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "double", ")", "\n", "\n", "# restrict domain of phi to domain of t, since x and y may not be defined outside [t_min, t_max]", "\n", "self", ".", "u", "=", "np", ".", "min", "(", "[", "self", ".", "u", ",", "np", ".", "repeat", "(", "1", ",", "self", ".", "N", ")", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "l", "=", "np", ".", "max", "(", "[", "self", ".", "l", ",", "np", ".", "repeat", "(", "0", ",", "self", ".", "N", ")", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "u_orig", "=", "self", ".", "u", ".", "copy", "(", ")", "\n", "self", ".", "l_orig", "=", "self", ".", "l", ".", "copy", "(", ")", "\n", "\n", "# update u and l by factor eta, keep within bounds of original l and u", "\n", "", "else", ":", "\n", "            ", "tau_range", "=", "self", ".", "eta", "*", "(", "self", ".", "u", "-", "self", ".", "l", ")", "/", "np", ".", "double", "(", "2.", ")", "\n", "self", ".", "u", "=", "np", ".", "min", "(", "[", "self", ".", "tau", "+", "tau_range", ",", "self", ".", "u_orig", "]", ",", "axis", "=", "0", ")", "\n", "self", ".", "l", "=", "np", ".", "max", "(", "[", "self", ".", "tau", "-", "tau_range", ",", "self", ".", "l_orig", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# compute taus for given an u and l", "\n", "", "a", "=", "np", ".", "stack", "(", "(", "self", ".", "l", ",", "self", ".", "u", "-", "self", ".", "l", ")", ",", "axis", "=", "1", ")", "\n", "b", "=", "np", ".", "vstack", "(", "(", "np", ".", "ones", "(", "self", ".", "M", ")", ",", "np", ".", "arange", "(", "self", ".", "M", ")", ".", "astype", "(", "np", ".", "double", ")", "/", "np", ".", "double", "(", "self", ".", "M", "-", "1", ")", ")", ")", "\n", "self", ".", "Tau", "=", "np", ".", "dot", "(", "a", ",", "b", ")", "\n", "# sanity check: this should decrease as u[i] shrinks towards phi[i] ", "\n", "# print( self.u[int(self.N/2)] - self.l[int(self.N/2)] )", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.compute_dist_matrix": [[100, 118], ["gdtw.GDTW.x_f", "numpy.tile", "time.time", "gdtw.GDTW.y_f().reshape", "print", "numpy.isnan", "gdtw.GDTW.y_f", "time.time"], "methods", ["None"], ["", "def", "compute_dist_matrix", "(", "self", ")", ":", "\n", "# The pre-computed distance matrix must satisfy: D[i,j] = Loss( x(Tau[i,j]) - y(t[i]) )", "\n", "# Note: scipy.spatial.distance.cdist won't work since t is a vector and tau is a matrix.", "\n", "        ", "if", "self", ".", "verbose", ">", "0", ":", "time_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# We'll compute x(tau) and assign infinitity at undefined points.", "\n", "X", "=", "self", ".", "x_f", "(", "self", ".", "Tau", ")", "\n", "X", "[", "np", ".", "isnan", "(", "X", ")", "]", "=", "np", ".", "inf", "\n", "\n", "# We repeat y(t) so that it's the same shape of x(tau).", "\n", "Y", "=", "np", ".", "tile", "(", "self", ".", "y_f", "(", "self", ".", "t", ")", ".", "reshape", "(", "(", "self", ".", "N", ",", "1", ")", ")", ",", "(", "1", ",", "self", ".", "M", ")", ")", "\n", "\n", "# We apply the processed loss function.", "\n", "self", ".", "D", "=", "(", "X", "-", "Y", ")", "**", "2", "\n", "\n", "# Finally, we'll report the time it took to do all of this.", "\n", "if", "self", ".", "verbose", ">", "0", ":", "print", "(", "f\"Pre-computed loss: {time.time() - time_start :03.4f} sec\"", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.run": [[122, 128], ["gdtw.GDTW.check_params", "gdtw.GDTW.allocate", "gdtw.GDTW.offer_suggestions", "gdtw.GDTW.iterate"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.check_params", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.allocate", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.offer_suggestions", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.iterate"], ["", "def", "run", "(", "self", ")", ":", "\n", "        ", "self", ".", "check_params", "(", ")", "\n", "self", ".", "allocate", "(", ")", "\n", "self", ".", "offer_suggestions", "(", ")", "\n", "self", ".", "iterate", "(", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.solve": [[129, 150], ["time.time", "gdtwcpp.solve", "numpy.double", "numpy.double", "numpy.double", "numpy.double", "ValueError", "time.time"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.solve"], ["", "def", "solve", "(", "self", ")", ":", "\n", "        ", "time_start", "=", "time", ".", "time", "(", ")", "\n", "i", "=", "solve", "(", "\n", "self", ".", "t", ",", "\n", "self", ".", "Tau", ",", "\n", "self", ".", "D", ",", "\n", "self", ".", "R_cum", ",", "\n", "self", ".", "R_inst", ",", "\n", "np", ".", "double", "(", "self", ".", "lambda_cum", ")", ",", "\n", "np", ".", "double", "(", "self", ".", "lambda_inst", ")", ",", "\n", "np", ".", "double", "(", "self", ".", "s_min", ")", ",", "\n", "np", ".", "double", "(", "self", ".", "s_max", ")", ",", "\n", "self", ".", "BC_start_stop", ",", "\n", "self", ".", "verbose", ",", "\n", "self", ".", "tau", ",", "\n", "self", ".", "path", ",", "\n", "self", ".", "f_tau", "\n", ")", "\n", "if", "i", "==", "-", "1", ":", "raise", "ValueError", "(", "\"C++ code failed.\"", ")", "\n", "self", ".", "time_solve", "=", "time", ".", "time", "(", ")", "-", "time_start", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.iterate": [[151, 167], ["numpy.arange().astype", "gdtw.GDTW.compute_taus", "gdtw.GDTW.compute_dist_matrix", "gdtw.GDTW.solve", "gdtw.GDTW.f_tau.copy", "numpy.arange", "gdtw.GDTW.print_iteration", "gdtw.GDTW.callback", "numpy.abs", "print", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.compute_taus", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.compute_dist_matrix", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.solve", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.print_iteration"], ["", "def", "iterate", "(", "self", ")", ":", "\n", "        ", "for", "self", ".", "iteration", "in", "np", ".", "arange", "(", "self", ".", "max_iters", ")", ".", "astype", "(", "np", ".", "int", ")", ":", "\n", "# compute graph and solve", "\n", "            ", "self", ".", "compute_taus", "(", ")", "\n", "self", ".", "compute_dist_matrix", "(", ")", "\n", "self", ".", "solve", "(", ")", "\n", "# optional methods", "\n", "if", "self", ".", "verbose", ">", "1", ":", "self", ".", "print_iteration", "(", ")", "\n", "if", "self", ".", "callback", ":", "self", ".", "callback", "(", "self", ")", "\n", "# early termination", "\n", "if", "self", ".", "iteration", ">", "0", "and", "self", ".", "f_tau_", "!=", "np", ".", "inf", ":", "\n", "                ", "if", "np", ".", "abs", "(", "self", ".", "f_tau", "-", "self", ".", "f_tau_", ")", "<=", "self", ".", "epsilon_abs", "+", "self", ".", "epsilon_rel", "*", "np", ".", "abs", "(", "self", ".", "f_tau_", ")", ":", "\n", "                    ", "if", "self", ".", "verbose", ">", "2", ":", "print", "(", "\"Stopping criterion met.\"", ")", "\n", "break", "\n", "", "", "self", ".", "f_tau_", "=", "self", ".", "f_tau", ".", "copy", "(", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.print_iteration": [[168, 172], ["print", "print"], "methods", ["None"], ["", "def", "print_iteration", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "iteration", "==", "0", ":", "print", "(", "f'\\titeration{\" \"*4}solver{\" \"*4}f(phi)'", ")", "\n", "print", "(", "f'\\t{self.iteration:3}/{self.max_iters:3}{\" \"*6}{self.time_solve:03.4f}{\" \"*3}{self.f_tau:8.6f}'", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.serialize": [[173, 185], ["gdtw.GDTW.x_f", "gdtw.GDTW.f_tau.copy"], "methods", ["None"], ["", "def", "serialize", "(", "self", ")", ":", "\n", "        ", "result", "=", "{", "\n", "\"t\"", ":", "self", ".", "t", ",", "\n", "\"tau\"", ":", "self", ".", "tau", ",", "\n", "\"phi\"", ":", "self", ".", "phi", ",", "\n", "\"y\"", ":", "self", ".", "y_a", ",", "\n", "\"x\"", ":", "self", ".", "x_a", ",", "\n", "\"x_hat\"", ":", "self", ".", "x_f", "(", "self", ".", "tau", ")", ",", "\n", "\"f_tau\"", ":", "self", ".", "f_tau", ".", "copy", "(", ")", ",", "\n", "\"params\"", ":", "self", ".", "param_list", "\n", "}", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.set_params": [[189, 193], ["gdtw.GDTW.__dict__.update", "params.items"], "methods", ["None"], ["", "def", "set_params", "(", "self", ",", "params", "=", "{", "}", ")", ":", "\n", "        ", "self", ".", "param_list", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "params", ".", "items", "(", ")", "if", "k", "not", "in", "[", "\"x\"", ",", "\"y\"", "]", "}", "\n", "self", ".", "__dict__", ".", "update", "(", "params", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.check_params": [[194, 286], ["signal.signal.signal", "signal.signal.signal", "utils.process_function", "isinstance", "isinstance", "numpy.array", "isinstance", "numpy.min().astype", "print", "ValueError", "isinstance", "numpy.linspace", "isinstance", "print", "print", "numpy.linspace", "ValueError", "numpy.min", "isinstance", "isinstance", "print", "print", "numpy.linspace", "isinstance", "isinstance", "numpy.unique", "print", "print", "numpy.array", "numpy.around", "numpy.array", "numpy.diff"], "methods", ["home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.signal", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.signal.signal", "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.utils.process_function"], ["", "def", "check_params", "(", "self", ")", ":", "\n", "# If time is given as a sequence,", "\n", "        ", "if", "isinstance", "(", "self", ".", "t", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "self", ".", "t", ",", "list", ")", ":", "\n", "# we'll ensure it's a numpy array", "\n", "            ", "self", ".", "t", "=", "np", ".", "array", "(", "self", ".", "t", ",", "dtype", "=", "np", ".", "double", ")", "\n", "# and then check if it's multidimensional. ", "\n", "if", "self", ".", "t", ".", "ndim", ">", "1", ":", "\n", "# If so we'll throw an error.", "\n", "                ", "raise", "ValueError", "(", "f\"Time is multi-dimensional; we can only accept a 1-D sequence.\"", ")", "\n", "\n", "# If we're not given an N, we'll use the length of time as our N", "\n", "", "if", "not", "isinstance", "(", "self", ".", "N", ",", "int", ")", ":", "# works for both int and np.int", "\n", "                ", "self", ".", "N", "=", "self", ".", "t", ".", "shape", "[", "0", "]", "\n", "# and alert the user.", "\n", "if", "self", ".", "verbose", ">", "1", ":", "\n", "                    ", "print", "(", "f\"Setting N={self.N} == len(t).\"", ")", "\n", "\n", "# Otherwise, we'll check to see if our given N and t agree.", "\n", "", "", "else", ":", "\n", "# If they agree, that's great,", "\n", "                ", "if", "self", ".", "N", "==", "self", ".", "t", ".", "shape", "[", "0", "]", ":", "\n", "                    ", "pass", "\n", "# otherwise, we'll need to choose one.", "\n", "", "else", ":", "\n", "# If t is irregularly sampled (10 decimal place precision),", "\n", "                    ", "if", "np", ".", "unique", "(", "np", ".", "around", "(", "np", ".", "diff", "(", "self", ".", "t", ")", ",", "10", ")", ")", ".", "shape", "[", "0", "]", ">", "1", ":", "\n", "# we'll want to use that t to integrate over,", "\n", "                        ", "self", ".", "N", "=", "self", ".", "t", ".", "shape", "[", "0", "]", "\n", "# and alert the user of this choice.", "\n", "if", "self", ".", "verbose", ">", "1", ":", "\n", "                            ", "print", "(", "f\"Over-riding your choice of N: N = {self.N} == len(t). Since t is irregularly sampled, we'll want to integrate over that vector.\"", ")", "\n", "# If N is bigger than t,", "\n", "", "", "elif", "self", ".", "N", ">", "self", ".", "t", ".", "shape", "[", "0", "]", ":", "\n", "# we'll use the smaller value,", "\n", "                        ", "self", ".", "N", "=", "self", ".", "t", ".", "shape", "[", "0", "]", "\n", "# and alert the user of this choice.", "\n", "if", "self", ".", "verbose", ">", "1", ":", "\n", "                            ", "print", "(", "f\"Over-riding your choice of N: N = {self.N} == len(t). Since N is greater than the length of t.\"", ")", "\n", "# Otherwise,", "\n", "", "", "else", ":", "\n", "# we'll default to the value given by N and rebuild t, ", "\n", "                        ", "self", ".", "t", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "self", ".", "N", ",", "dtype", "=", "np", ".", "double", ")", "\n", "# and alert the user of this choice.", "\n", "if", "self", ".", "verbose", ">", "1", ":", "\n", "                            ", "print", "(", "f\"You've set both t and N, but they don't agree: i.e. len(t) > N. We're keeping your choice of N = {self.N}.\"", ")", "\n", "\n", "# Otherwise, if N is given and t is not, we'll construct a sequence based on N.", "\n", "", "", "", "", "", "elif", "isinstance", "(", "self", ".", "N", ",", "int", ")", ":", "\n", "            ", "self", ".", "t", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "self", ".", "N", ",", "dtype", "=", "np", ".", "double", ")", "\n", "\n", "# It could be the case that both t and N are not given,", "\n", "", "else", ":", "\n", "# which will be indicated here,", "\n", "            ", "if", "self", ".", "t", "is", "None", "and", "self", ".", "N", "is", "None", ":", "\n", "                ", "if", "isinstance", "(", "self", ".", "x", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "self", ".", "x", ",", "list", ")", ":", "\n", "                    ", "self", ".", "N", "=", "np", ".", "array", "(", "self", ".", "x", ")", ".", "shape", "[", "0", "]", "\n", "", "elif", "isinstance", "(", "self", ".", "y", ",", "np", ".", "ndarray", ")", "or", "isinstance", "(", "self", ".", "y", ",", "list", ")", ":", "\n", "                    ", "self", ".", "N", "=", "np", ".", "array", "(", "self", ".", "y", ")", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "# We'll use the default value of N", "\n", "                    ", "self", ".", "N", "=", "self", ".", "N_default", "\n", "", "self", ".", "t", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "self", ".", "N", ",", "dtype", "=", "np", ".", "double", ")", "\n", "# and alert the user.", "\n", "if", "self", ".", "verbose", ">", "1", ":", "\n", "                    ", "print", "(", "f\"Setting N={self.N} since neither vector t or integer N is set.\"", ")", "\n", "# If we end up here, then the only explanation is that t is incorrect.", "\n", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Time t is set incorrectly. It must be a 1-D sequence.\"", ")", "\n", "\n", "# If M is not given or is unreasonably large,", "\n", "", "", "if", "not", "isinstance", "(", "self", ".", "M", ",", "int", ")", "or", "self", ".", "M", ">=", "self", ".", "N", ":", "\n", "# we'll set it to the smaller of either the default size or a little over half of N,", "\n", "            ", "self", ".", "M", "=", "np", ".", "min", "(", "(", "self", ".", "N", "*", ".55", ",", "self", ".", "M_max", ")", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "# and alert the user of this choice.", "\n", "if", "self", ".", "verbose", ">", "1", ":", "\n", "                ", "print", "(", "f\"Setting M={self.M}\"", ")", "\n", "\n", "# We'll also ensure M is odd so that there's a center point (aka. j_center in our C++ code).", "\n", "", "", "self", ".", "M", "=", "self", ".", "M", "if", "self", ".", "M", "%", "2", "==", "1", "else", "self", ".", "M", "+", "1", "\n", "\n", "# We'll alert the user of these final parameters.", "\n", "if", "self", ".", "verbose", ">", "0", ":", "\n", "            ", "print", "(", "f\"M={self.M}, N={self.N}\"", ")", "\n", "\n", "# Signals are given as generic inputs x and y. We'll parse these here.", "\n", "", "self", ".", "x_a", ",", "self", ".", "x_f", "=", "signal", "(", "self", ".", "x", ",", "\"x\"", ",", "self", ".", "N", ")", "\n", "self", ".", "y_a", ",", "self", ".", "y_f", "=", "signal", "(", "self", ".", "y", ",", "\"y\"", ",", "self", ".", "N", ")", "\n", "\n", "# Finally, we'll process our loss function.", "\n", "self", ".", "loss_f", "=", "process_function", "(", "self", ".", "Loss", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.gdtw.GDTW.offer_suggestions": [[287, 308], ["numpy.min", "print", "print", "print", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "print", "print", "numpy.nanmin", "numpy.nanmax", "numpy.nanmin", "numpy.nanmax", "callable", "callable", "gdtw.GDTW.x_f", "gdtw.GDTW.x_f", "gdtw.GDTW.y_f", "gdtw.GDTW.y_f"], "methods", ["None"], ["", "def", "offer_suggestions", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ">", "0", ":", "\n", "            ", "M_suggested", "=", "np", ".", "min", "(", "(", "self", ".", "N", "*", ".55", ",", "self", ".", "M_max", ")", ")", "\n", "\n", "if", "self", ".", "M", "<", "M_suggested", ":", "\n", "                ", "print", "(", "f\"Suggestion: M is too small. Increasing M from {self.M} to ~{M_suggested} may offer better results.\"", ")", "\n", "\n", "", "if", "self", ".", "M", ">", "(", "self", ".", "N", ")", ":", "\n", "                ", "print", "(", "f\"Suggestion: M is too big. Decreasing M from {self.M} to ~{M_suggested} will be faster.\"", ")", "\n", "\n", "", "if", "(", "self", ".", "s_beta", "!=", "0", "and", "(", "not", "callable", "(", "self", ".", "x", ")", "or", "not", "callable", "(", "self", ".", "y", ")", ")", ")", ":", "\n", "                ", "print", "(", "f\"Suggestion:\\n   x(t) and y(t) are defined over time domain [{0},{1}], but since you've set beta={self.s_beta}, this method will search over tau with a range of [{0-self.s_beta},{1+self.s_beta}].\\n   The problem is that you've provided an array instead of a function for x(t) or y(t).\\n   This method doesn't perform prediction, and so it won't impute values for x(tau) or y(tau) where tau < min(t) or tau > max(t).\\n   Please make sure you use a function to define x and y instead of an array, or you'll have some spurrious results for tau outside the range of t.\"", ")", "\n", "\n", "", "range_x", "=", "[", "np", ".", "round", "(", "np", ".", "nanmin", "(", "self", ".", "x_f", "(", "self", ".", "t", ")", ")", ",", "1", ")", ",", "np", ".", "round", "(", "np", ".", "nanmax", "(", "self", ".", "x_f", "(", "self", ".", "t", ")", ")", ",", "1", ")", "]", "\n", "range_y", "=", "[", "np", ".", "round", "(", "np", ".", "nanmin", "(", "self", ".", "y_f", "(", "self", ".", "t", ")", ")", ",", "1", ")", ",", "np", ".", "round", "(", "np", ".", "nanmax", "(", "self", ".", "y_f", "(", "self", ".", "t", ")", ")", ",", "1", ")", "]", "\n", "\n", "if", "(", "range_x", "[", "0", "]", "!=", "-", "1.0", "or", "range_x", "[", "1", "]", "!=", "1.0", "or", "range_y", "[", "0", "]", "!=", "-", "1.0", "or", "range_y", "[", "1", "]", "!=", "1.0", ")", ":", "\n", "                ", "print", "(", "f\"Suggestion: x(t) and y(t) do not have a range [-1,1] (they have range(x)={range_x} and range(y)={range_y}.\"", ")", "\n", "print", "(", "f\"You may want to set scale_signals=True so the Loss function doesn't dominate the regularizers in the objective function.\"", ")", "\n", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.utils.scale": [[3, 5], ["numpy.nanmax", "numpy.nanmin", "numpy.nanmin"], "function", ["None"], ["def", "scale", "(", "seq", ",", "range", "=", "[", "-", "1", ",", "1", "]", ")", ":", "\n", "    ", "return", "(", "range", "[", "1", "]", "-", "range", "[", "0", "]", ")", "*", "(", "(", "seq", "-", "np", ".", "nanmin", "(", "seq", ")", ")", "/", "np", ".", "nanmax", "(", "seq", "-", "np", ".", "nanmin", "(", "seq", ")", ")", ")", "+", "range", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.dderiso_gdtw.gdtw.utils.process_function": [[6, 46], ["isinstance", "callable", "ValueError", "numpy.linalg.norm", "ValueError", "ValueError", "f", "numpy.vectorize", "np.vectorize.", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "print"], "function", ["None"], ["", "def", "process_function", "(", "f", ")", ":", "\n", "# Our API is a first pass. We'll improve this later. For now, we take the choice of ", "\n", "# loss and regularization functionals as a string or a callable function.", "\n", "# We'll parse this API here and return a callable function or None.", "\n", "\n", "# default", "\n", "    ", "f_out", "=", "None", "\n", "\n", "# Determine if the function is given as a string (indicates that the user wants a C++ function),", "\n", "if", "isinstance", "(", "f", ",", "str", ")", ":", "\n", "# if so convert the string into a function.", "\n", "        ", "if", "f", "==", "\"L1\"", ":", "f_out", "=", "lambda", "x_", ",", "axis", "=", "1", ":", "np", ".", "linalg", ".", "norm", "(", "x_", ",", "ord", "=", "1", ",", "axis", "=", "axis", ")", "\n", "elif", "f", "==", "\"L2\"", ":", "f_out", "=", "lambda", "x_", ",", "axis", "=", "1", ":", "np", ".", "linalg", ".", "norm", "(", "x_", ",", "ord", "=", "2", ",", "axis", "=", "axis", ")", "**", "2", "\n", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Error: String is not recognized by this API. You can use one of the built-in C function by passing a string such as 'L1' or 'L2'.\"", ")", "\n", "\n", "# Or, if it's a callable function (indicates that the user wrote this function),", "\n", "", "", "elif", "callable", "(", "f", ")", ":", "\n", "# we'll test it ability to be vectorized by running it on a test array and seeing if the shape is preserved.", "\n", "        ", "if", "f", "(", "np", ".", "zeros", "(", "10", ")", ")", ".", "shape", "==", "10", ":", "\n", "            ", "try", ":", "\n", "# If it's vectorizable, make it so,", "\n", "                ", "f_out", "=", "np", ".", "vectorize", "(", "f", ")", "\n", "", "except", ":", "\n", "# otherwise, alert the user", "\n", "                ", "if", "verbose", ">", "1", ":", "\n", "                    ", "print", "(", "\"Could not vectorize function, proceeding with a loop (slower).\"", ")", "\n", "\n", "# and run the function as a loop (slower).", "\n", "", "f_out", "=", "lambda", "x_", ":", "[", "f", "for", "x_i", "in", "x_", "]", "\n", "\n", "# We'll test this to be sure.", "\n", "", "", "if", "f_out", "(", "np", ".", "zeros", "(", "10", ")", ")", ".", "shape", "!=", "10", ":", "\n", "            ", "raise", "ValueError", "(", "\"Error: If you define your own Python function (slower than C), it must accept and return a matrix of the same shape. Yours does not.\"", ")", "\n", "\n", "# Finally, alert the user if the function is neither.", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Error: Function is neither a String nor callable function.\"", ")", "\n", "\n", "", "return", "f_out", "\n", "\n"]]}