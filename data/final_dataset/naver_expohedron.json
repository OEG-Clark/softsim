{"home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.__init__": [[28, 35], ["len", "np.all", "np.all", "utils.invert_permutation", "np.argsort"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation"], ["def", "__init__", "(", "self", ",", "pbm", ":", "np", ".", "ndarray", ",", "relevance_vector", ":", "np", ".", "ndarray", ")", ":", "\n", "        ", "assert", "np", ".", "all", "(", "0", "<=", "relevance_vector", ")", "and", "np", ".", "all", "(", "relevance_vector", "<=", "1", ")", ",", "\"The values of `relevance_vector` must all be between 0 and 1\"", "\n", "self", ".", "relevance_vector", "=", "relevance_vector", "\n", "self", ".", "pbm", "=", "pbm", "\n", "self", ".", "n", "=", "len", "(", "relevance_vector", ")", "\n", "self", ".", "prp_vertex", "=", "pbm", "[", "invert_permutation", "(", "np", ".", "argsort", "(", "-", "relevance_vector", ")", ")", "]", "\n", "self", ".", "prp_utility", "=", "self", ".", "prp_vertex", "@", "relevance_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.__repr__": [[36, 40], ["str", "str", "str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "string1", "=", "\"PBM expohedron:\\n\\trelevance_vector of length \"", "+", "str", "(", "self", ".", "n", ")", "+", "\" :\\n\\t\"", "+", "str", "(", "self", ".", "relevance_vector", ")", "\n", "string2", "=", "\"\\n\\tPBM = \"", "+", "str", "(", "self", ".", "pbm", ")", "\n", "return", "string1", "+", "string2", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.__str__": [[41, 43], ["expohedron.PBMexpohedron.__repr__"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.__repr__"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.is_inside": [[44, 46], ["expohedron.majorized"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized"], ["", "def", "is_inside", "(", "self", ",", "point", ":", "np", ".", "ndarray", ")", "->", "bool", ":", "\n", "        ", "return", "majorized", "(", "point", ",", "self", ".", "pbm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.get_vertex": [[47, 59], ["utils.is_ranking", "utils.invert_permutation"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.is_ranking", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation"], ["", "def", "get_vertex", "(", "self", ",", "ranking", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n            Given a ranking, a relevance vector and an abandon probability, computes the exposure vector (in the document space)\n\n            The ranking is such that when applied to the document indices\n        :param ranking: A matrix of size D x D\n        :type ranking: numpy.array\n        :return: A column vector of size D\n        :rtype: numpy.array\n        \"\"\"", "\n", "assert", "is_ranking", "(", "ranking", ")", "\n", "return", "self", ".", "pbm", "[", "invert_permutation", "(", "ranking", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.utility": [[60, 62], ["None"], "methods", ["None"], ["", "def", "utility", "(", "self", ",", "exposure_vector", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "        ", "return", "exposure_vector", "@", "self", ".", "relevance_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.nutility": [[63, 65], ["expohedron.PBMexpohedron.utility"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.utility"], ["", "def", "nutility", "(", "self", ",", "exposure_vector", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "        ", "return", "self", ".", "utility", "(", "exposure_vector", ")", "/", "self", ".", "prp_utility", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.unfairness": [[66, 82], ["utils.compute_unfairness", "expohedron.PBMexpohedron.demographic_fairness_target", "expohedron.PBMexpohedron.meritocratic_target_exposure", "ValueError"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.compute_unfairness", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.demographic_fairness_target", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.meritocratic_target_exposure"], ["", "def", "unfairness", "(", "self", ",", "exposure_vector", ":", "np", ".", "ndarray", ",", "fairness", ":", "str", "=", "\"meritocratic\"", ",", "\n", "p_norm", ":", "float", "=", "2", ",", "meritocratic_endpoint", ":", "str", "=", "\"intersection\"", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n\n        :param fairness:\n        :param p_norm:\n        :param meritocratic_endpoint:\n        :return:\n        \"\"\"", "\n", "if", "fairness", "==", "\"demographic\"", ":", "\n", "            ", "target", "=", "self", ".", "demographic_fairness_target", "(", ")", "\n", "", "elif", "fairness", "==", "\"meritocratic\"", ":", "\n", "            ", "target", "=", "self", ".", "meritocratic_target_exposure", "(", "type", "=", "meritocratic_endpoint", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid value for `fairness`\"", ")", "\n", "", "return", "compute_unfairness", "(", "exposure_vector", ",", "target", ",", "p_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.nunfairness": [[83, 94], ["expohedron.PBMexpohedron.unfairness", "expohedron.PBMexpohedron.unfairness"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.unfairness", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.unfairness"], ["", "def", "nunfairness", "(", "self", ",", "exposure_vector", ":", "np", ".", "ndarray", ",", "fairness", ":", "str", "=", "\"meritocratic\"", ",", "\n", "p_norm", ":", "float", "=", "2", ",", "meritocratic_endpoint", ":", "str", "=", "\"intersection\"", ")", "->", "float", ":", "\n", "        ", "\"\"\"\n            Normalized unfairness\n        :param fairness:\n        :param p_norm:\n        :param meritocratic_endpoint:\n        :return:\n        \"\"\"", "\n", "return", "self", ".", "unfairness", "(", "exposure_vector", ",", "fairness", ",", "p_norm", ",", "meritocratic_endpoint", ")", "/", "self", ".", "unfairness", "(", "self", ".", "prp_vertex", ",", "fairness", ",", "p_norm", ",", "meritocratic_endpoint", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.demographic_fairness_target": [[95, 105], ["np.ones", "np.ones", "np.ones", "np.ones"], "methods", ["None"], ["", "def", "demographic_fairness_target", "(", "self", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n            Computes the feasible demographic target exposure vector\n\n        :param expohedron: The expohedron to consider\n        :type expohedron: DBNexpohedron\n        :return: The demographic target exposure\n        :rtype: numpy.ndarray\n        \"\"\"", "\n", "return", "np", ".", "ones", "(", "self", ".", "n", ")", "*", "(", "self", ".", "prp_vertex", "@", "np", ".", "ones", "(", "self", ".", "n", ")", ")", "/", "(", "np", ".", "ones", "(", "self", ".", "n", ")", "@", "np", ".", "ones", "(", "self", ".", "n", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.meritocratic_target_exposure": [[106, 123], ["expohedron.PBMexpohedron.is_inside", "expohedron.PBMexpohedron.demographic_fairness_target", "expohedron.find_face_intersection", "np.ones", "np.ones"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.is_inside", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.demographic_fairness_target", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection"], ["", "def", "meritocratic_target_exposure", "(", "self", ",", "type", ":", "str", "=", "\"intersection\"", ")", "->", "np", ".", "ndarray", ":", "\n", "        ", "\"\"\"\n                Computes the feasible meritocratic target exposure vector\n\n            :param type: How to find a feasible target if the \"true\" one is infeasible\n            :type type: str, optional\n            :return: The meritocratic target exposure\n            :rtype: numpy.ndarray\n        \"\"\"", "\n", "assert", "type", "==", "\"intersection\"", ",", "\"Only intersection method is currently supported\"", "\n", "true_fairness_endpoint", "=", "self", ".", "relevance_vector", "*", "(", "self", ".", "prp_vertex", "@", "np", ".", "ones", "(", "self", ".", "n", ")", ")", "/", "(", "self", ".", "relevance_vector", "@", "np", ".", "ones", "(", "self", ".", "n", ")", ")", "\n", "if", "self", ".", "is_inside", "(", "true_fairness_endpoint", ")", ":", "\n", "            ", "return", "true_fairness_endpoint", "\n", "", "else", ":", "\n", "            ", "demographic_fairness_point", "=", "self", ".", "demographic_fairness_target", "(", ")", "\n", "direction", "=", "true_fairness_endpoint", "-", "demographic_fairness_point", "\n", "return", "find_face_intersection", "(", "self", ".", "pbm", ",", "demographic_fairness_point", ",", "direction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.target_exposure": [[124, 131], ["expohedron.PBMexpohedron.demographic_fairness_target", "expohedron.PBMexpohedron.meritocratic_target_exposure", "ValueError"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.demographic_fairness_target", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.PBMexpohedron.meritocratic_target_exposure"], ["", "", "def", "target_exposure", "(", "self", ",", "fairness", ":", "str", ",", "meritocratic_endpoint", ":", "str", "=", "\"intersection\"", ")", ":", "\n", "        ", "if", "fairness", "==", "\"demographic\"", ":", "\n", "            ", "return", "self", ".", "demographic_fairness_target", "(", ")", "\n", "", "elif", "fairness", "==", "\"meritocratic\"", ":", "\n", "            ", "return", "self", ".", "meritocratic_target_exposure", "(", "type", "=", "meritocratic_endpoint", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Invalid value for `fairness`\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.__init__": [[184, 196], ["len", "np.all", "issubclass", "np.sort", "len", "np.all", "np.all", "len", "len", "np.sort", "np.arange"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "gamma", ",", "zone", ",", "splits", ")", ":", "\n", "        ", "n", "=", "len", "(", "gamma", ")", "\n", "assert", "np", ".", "all", "(", "np", ".", "sort", "(", "zone", ")", "==", "np", ".", "arange", "(", "0", ",", "n", ")", ")", ",", "\"zone must be a permutation\"", "\n", "assert", "n", "==", "len", "(", "zone", ")", "\n", "assert", "issubclass", "(", "splits", ".", "dtype", ".", "type", ",", "np", ".", "integer", ")", ",", "\"splits must contain integer indices\"", "\n", "assert", "np", ".", "all", "(", "0", "<=", "splits", ")", "and", "np", ".", "all", "(", "splits", "<", "n", ")", ",", "\"The indices in split must be in the adequate range\"", "\n", "assert", "len", "(", "splits", ")", ">", "0", ",", "\"All faces must have at least one split. The whole expohedron has exactly one split\"", "\n", "\n", "self", ".", "gamma", "=", "np", ".", "sort", "(", "gamma", ")", "\n", "self", ".", "zone", "=", "zone", "\n", "self", ".", "splits", "=", "splits", "\n", "self", ".", "dim", "=", "n", "-", "len", "(", "splits", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.contains": [[197, 208], ["expohedron.majorized", "len", "np.setdiff1d", "np.where", "np.abs", "np.cumsum", "np.cumsum"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized"], ["", "def", "contains", "(", "self", ",", "point", ":", "np", ".", "array", ",", "tolerance", ":", "float", "=", "1e-12", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n            Checks if a point is inside the face\n        :param point:\n        :return:\n        :rtype: bool\n        \"\"\"", "\n", "maj", "=", "majorized", "(", "point", ",", "self", ".", "gamma", ")", "# majorization condition", "\n", "face_condition", ":", "bool", "=", "len", "(", "np", ".", "setdiff1d", "(", "self", ".", "splits", ",", "np", ".", "where", "(", "np", ".", "abs", "(", "np", ".", "cumsum", "(", "point", "[", "self", ".", "zone", "]", ")", "-", "np", ".", "cumsum", "(", "self", ".", "gamma", ")", ")", "<", "tolerance", ")", "[", "0", "]", ")", ")", "==", "0", "# Check if the splits", "\n", "# of `point` are a subset of `self.splits`", "\n", "return", "maj", "and", "face_condition", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.equal": [[209, 217], ["np.all", "utils.invert_permutation", "utils.invert_permutation"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation"], ["", "def", "equal", "(", "self", ",", "face", ":", "\"Face\"", ")", "->", "bool", ":", "\n", "        ", "\"\"\"\n            Checks if `self` is equal to `face`\n        :param face:\n        :return:\n        :rtype: bool\n        \"\"\"", "\n", "return", "np", ".", "all", "(", "invert_permutation", "(", "self", ".", "zone", ")", "[", "self", ".", "splits", "]", "==", "invert_permutation", "(", "face", ".", "zone", ")", "[", "face", ".", "splits", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized": [[133, 147], ["np.all", "np.abs", "np.cumsum", "np.cumsum", "np.sum", "np.sum", "np.sort", "np.sort"], "function", ["None"], ["", "", "", "def", "majorized", "(", "a", ":", "np", ".", "array", ",", "b", ":", "np", ".", "array", ",", "tolerance", ":", "float", "=", "LOW_TOLERANCE", ")", "->", "bool", ":", "\n", "    ", "\"\"\"\n        Checks whether `a` is majorized by `b`: a<b\n\n        :param a: The left hand side of the comparison a<b\n        :type a: numpy.array\n        :param b: The right hand side of the comparison a<b\n        :type b: numpy.array\n        :param tolerance: the tolerance that is allowed\n        :type tolerance: float\n        :return: `True` if a < b, false otherwise\n        :rtype: bool\n    \"\"\"", "\n", "return", "np", ".", "all", "(", "np", ".", "cumsum", "(", "-", "np", ".", "sort", "(", "-", "a", ")", ")", "<=", "np", ".", "cumsum", "(", "-", "np", ".", "sort", "(", "-", "b", ")", ")", "+", "tolerance", ")", "and", "np", ".", "abs", "(", "np", ".", "sum", "(", "a", ")", "-", "np", ".", "sum", "(", "b", ")", ")", "<", "tolerance", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.sample_point_in_expohedron": [[149, 171], ["len", "np.zeros", "np.random.uniform", "expohedron.majorized", "np.sum", "np.sum"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized"], ["", "def", "sample_point_in_expohedron", "(", "gamma", ":", "np", ".", "ndarray", ",", "size", ":", "int", "=", "1", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n    Sample a random point inside the expohedron.\n\n    This is achieved by accept-reject sampling in the simplex\n    :param gamma: The PBM exposures\n    :type gamma: numpy.ndarray\n    :param size: The number of points to sample\n    :type size: int, optional\n    :return: A matrix whose rows are the sampled points in the expohedron\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "result", "=", "np", ".", "zeros", "(", "(", "size", ",", "n", ")", ")", "*", "np", ".", "nan", "\n", "k", "=", "0", "\n", "while", "k", "<", "size", ":", "\n", "        ", "sample", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0", ",", "high", "=", "1", ",", "size", "=", "n", ")", "\n", "sample", "=", "sample", "/", "np", ".", "sum", "(", "sample", ")", "*", "np", ".", "sum", "(", "gamma", ")", "\n", "if", "majorized", "(", "sample", ",", "gamma", ")", ":", "\n", "            ", "result", "[", "k", ",", ":", "]", "=", "sample", "\n", "k", "+=", "1", "\n", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.error_correction": [[219, 247], ["len", "expohedron.majorized", "np.argsort", "np.cumsum", "np.cumsum", "np.cumsum", "min", "len", "np.abs"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized"], ["", "", "def", "error_correction", "(", "point", ":", "np", ".", "ndarray", ",", "direction", ":", "np", ".", "ndarray", ",", "face", ":", "Face", ",", "tol", ":", "float", "=", "HIGH_TOLERANCE", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Correct numerical imprecisions in a point on a face\n\n        Given a point `point` on a face `face` of an expohedron, and a half-line `direction` on which `point` lies`, corrects numerical imprecisions in `point`.\n        NB: The imprecise point MUST still be majorized by `face.gamma`.\n    :param point: The point to correct\n    :type point: numpy.ndarray\n    :param direction: The direction in which the point must be corrected\n    :type direction: numpy.ndarray\n    :param face: The face on which the point actually lies\n    :type face: Face\n    :param tol: The allowed tolerance for the corrected point\n    :type tol: float, optional\n    :return: The corrected point\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "n", "=", "len", "(", "point", ")", "\n", "assert", "n", "==", "len", "(", "direction", ")", ",", "\"`direction must have same length as `point`\"", "\n", "assert", "majorized", "(", "point", ",", "face", ".", "gamma", ")", ",", "\"`point` must be majorized by `face.gamma`\"", "\n", "\n", "zone", "=", "np", ".", "argsort", "(", "direction", ")", "\n", "# `face.zone` is the base we are working in", "\n", "Gk", "=", "np", ".", "cumsum", "(", "face", ".", "gamma", "[", "zone", "]", ")", "\n", "Sk", "=", "np", ".", "cumsum", "(", "point", "[", "zone", "]", ")", "\n", "Dk", "=", "np", ".", "cumsum", "(", "direction", "[", "zone", "]", ")", "\n", "Lambda", "=", "min", "(", "np", ".", "abs", "(", "(", "Gk", "-", "Sk", ")", "[", "0", ":", "(", "n", "-", "1", ")", "]", "/", "Dk", "[", "0", ":", "(", "n", "-", "1", ")", "]", ")", ")", "\n", "return", "point", "+", "Lambda", "*", "direction", "\n", "# todo check if this works whatever zone `face` is defined in", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.project_on_face_subspace": [[251, 270], ["len", "expohedron.find_face_subspace", "len", "utils.project_on_affine_subspace", "utils.project_on_subspace"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_affine_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace"], ["", "def", "project_on_face_subspace", "(", "point_to_project", ":", "np", ".", "ndarray", ",", "face", ":", "Face", ",", "affine", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n        Projects  the point `point_to_project` onto the linear subspace corresponding to `face`. If `affine is True` then the affine subspace is used\n    :param point_to_project: The point to project\n    :type point_to_project: numpy.ndarray\n    :param face: The face on whose subspace we seek to project\n    :type face: Face\n    :param affine: Whether the projection should be on the affine subspace. Default is `False`\n    :type affine: bool, optional\n    :return: The projection\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "n", "=", "len", "(", "point_to_project", ")", "\n", "assert", "n", "==", "len", "(", "face", ".", "gamma", ")", ",", "\"`point_to_project` must have same length as `face.gamma`.\"", "\n", "face_orth", "=", "find_face_subspace", "(", "face", ")", "\n", "if", "affine", ":", "\n", "        ", "return", "project_on_affine_subspace", "(", "point_to_project", ",", "face_orth", ".", "T", ",", "offset", "=", "face", ".", "gamma", "[", "face", ".", "zone", "]", ")", "# todo check this", "\n", "", "else", ":", "\n", "        ", "return", "project_on_subspace", "(", "point_to_project", ",", "face_orth", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace": [[272, 282], ["expohedron.find_face_subspace_without_parent"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace_without_parent"], ["", "", "def", "find_face_subspace", "(", "face", ":", "Face", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Given a face of the expohedron, finds all the normal vectors to the smallest linear subspace containing that face.\n\n    :param face: The face whose subspace is to be found\n    :type face: Face\n    :return: A matrix whose rows are an orthonormal basis to the complement of the linear subspace. A such that S = {x | Ax=0}.\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "return", "find_face_subspace_without_parent", "(", "face", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace_without_parent": [[284, 306], ["len", "np.zeros", "np.arange", "orth", "np.ones", "np.sum", "np.sum", "utils.invert_permutation"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation"], ["", "def", "find_face_subspace_without_parent", "(", "face", ":", "Face", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Computes the smallest linear subspace in which `face` lies. Returns the orthonormal vectors to the subspace.\n    :param face: The face whose subspace is to be computed\n    :type face: Face\n    :return: The normal vectors\n    \"\"\"", "\n", "n", "=", "len", "(", "face", ".", "gamma", ")", "# The dimensionality of the space", "\n", "n_orth", "=", "n", "-", "face", ".", "dim", "# The dimensionality of the orthogonal space", "\n", "A", "=", "np", ".", "zeros", "(", "(", "n_orth", ",", "n", ")", ")", "\n", "for", "j", "in", "np", ".", "arange", "(", "0", ",", "n_orth", ")", ":", "\n", "        ", "i", "=", "face", ".", "splits", "[", "j", "]", "\n", "nu", "=", "np", ".", "ones", "(", "n", ")", "\n", "s1", "=", "np", ".", "sum", "(", "face", ".", "gamma", "[", "0", ":", "i", "+", "1", "]", ")", "\n", "s2", "=", "np", ".", "sum", "(", "face", ".", "gamma", "[", "i", "+", "1", ":", "n", "]", ")", "\n", "if", "s2", "==", "0", ":", "\n", "            ", "psi", "=", "1", "\n", "", "else", ":", "\n", "            ", "psi", "=", "s1", "/", "s2", "\n", "", "nu", "[", "i", "+", "1", ":", "n", "]", "=", "-", "psi", "\n", "A", "[", "j", ",", ":", "]", "=", "nu", "[", "invert_permutation", "(", "face", ".", "zone", ")", "]", "\n", "", "return", "orth", "(", "A", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection": [[308, 334], ["np.all", "np.linalg.norm", "Warning", "np.sum", "expohedron.find_face_intersection_same_ordering", "expohedron.find_face_intersection_bisection", "np.argsort", "np.argsort", "str"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_same_ordering", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_bisection"], ["", "def", "find_face_intersection", "(", "gamma", ":", "np", ".", "ndarray", ",", "starting_point", ":", "np", ".", "ndarray", ",", "direction", ":", "np", ".", "ndarray", ",", "precision", ":", "float", "=", "1e-12", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Finds the intersection of a half-line with the border of the expohedron\n\n        Given a starting point `starting_point` in an expohedron given by `gamma` and given a direction vector `direction`, this function find\n        the intersection of the half line starting at `starting_point` with direction `direction` with the border of the polytope\n    :param gamma: A vertex of the PBM-expohedron\n    :type gamma: numpy.ndarray\n    :param starting_point: the starting point of the half line\n    :type starting_point: numpy.ndarray\n    :param direction: the direction of the half line\n    :type direction: numpy.ndarray\n    :param precision: THe precision to be used for the bisection method\n    :type precision: float, optional\n    :return: The intersection of the half-line with the border of the polytope\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "if", "np", ".", "linalg", ".", "norm", "(", "direction", ")", "<", "precision", ":", "\n", "        ", "Warning", "(", "\"`direction` has norm lower than \"", "+", "str", "(", "precision", ")", "+", "\". Assumed to be 0. Returning `starting_point`.\"", ")", "\n", "return", "starting_point", "\n", "", "assert", "np", ".", "sum", "(", "direction", ")", "<", "LOW_TOLERANCE", ",", "\"`direction`'s elements must sum to zero\"", "\n", "\n", "if", "np", ".", "all", "(", "np", ".", "argsort", "(", "starting_point", ")", "==", "np", ".", "argsort", "(", "direction", ")", ")", ":", "\n", "        ", "return", "find_face_intersection_same_ordering", "(", "gamma", ",", "starting_point", ",", "direction", ")", "\n", "", "else", ":", "\n", "        ", "return", "find_face_intersection_bisection", "(", "gamma", ",", "starting_point", ",", "direction", ",", "precision", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_same_ordering": [[336, 379], ["len", "np.cumsum", "np.cumsum", "np.cumsum", "np.where", "min", "np.all", "np.argsort", "np.all", "len", "len", "len", "len", "np.sum", "np.sort", "np.abs", "np.sort", "np.sort", "np.where", "np.argsort"], "function", ["None"], ["", "", "def", "find_face_intersection_same_ordering", "(", "gamma", ":", "np", ".", "ndarray", ",", "starting_point", ":", "np", ".", "ndarray", ",", "direction", ":", "np", ".", "ndarray", ",", "override_order_constraint", ":", "bool", "=", "False", ",", "\n", "zone", ":", "np", ".", "ndarray", "=", "None", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Given a starting point `starting_point` in an expohedron given by `gamma` and given a direction vector `direction`, this function finds\n\n        the intersection of the half line starting at `starting_point` with direction `direction` with the border of the polytope\n        This is done under the assumption that all points in the half-line have the same ordering\n        voir p. 71 et 88 de mon carnet\n    :param gamma: A vertex of the PBM-expohedron\n    :type gamma: numpy.ndarray\n    :param starting_point: the starting point of the half line\n    :type starting_point: numpy.ndarray\n    :param direction: the direction of the half line\n    :type direction: numpy.ndarray\n    :param override_order_constraint: If `True` the order constraint is not checked and can be overridden\n    :type override_order_constraint: bool, optional\n    :param zone: This parameter serves to lift ambiguity whenever the starting point is in several zones. If this argument is given and `starting_point` is indeed in `zone`, then `zone is chosen`\n    :type zone: np.ndarray, optional\n    :return: The intersection of the half-line with the border of the polytope\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "if", "zone", "is", "not", "None", ":", "\n", "        ", "assert", "np", ".", "all", "(", "starting_point", "[", "zone", "]", "==", "np", ".", "sort", "(", "starting_point", ")", ")", ",", "\"The starting point is not in given zone\"", "\n", "", "else", ":", "\n", "        ", "zone", "=", "np", ".", "argsort", "(", "starting_point", ")", "\n", "", "if", "not", "override_order_constraint", ":", "\n", "        ", "assert", "np", ".", "all", "(", "np", ".", "sort", "(", "starting_point", ")", "==", "starting_point", "[", "np", ".", "argsort", "(", "direction", ")", "]", ")", ",", "\"Both starting point and direction need to have the same ordering\"", "\n", "", "assert", "len", "(", "gamma", ")", "==", "len", "(", "starting_point", ")", ",", "\"gamma and starting_point must have same length\"", "\n", "assert", "len", "(", "gamma", ")", "==", "len", "(", "direction", ")", ",", "\"gamma and direction must have same length\"", "\n", "assert", "np", ".", "sum", "(", "direction", ")", "<", "LOW_TOLERANCE", ",", "\"`direction`'s elements must sum to zero\"", "\n", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "Gk", "=", "np", ".", "cumsum", "(", "np", ".", "sort", "(", "gamma", ")", ")", "\n", "Sk", "=", "np", ".", "cumsum", "(", "starting_point", "[", "zone", "]", ")", "\n", "Dk", "=", "np", ".", "cumsum", "(", "direction", "[", "zone", "]", ")", "\n", "# eliminate the coordinates where Dk is zero; no information about Lambda can be obtained from them. todo: refer to a proof in paper", "\n", "\n", "# Lambda = min((Gk - Sk)[0:(n - 1)] / Dk[0:(n - 1)])", "\n", "indices", "=", "np", ".", "where", "(", "np", ".", "abs", "(", "Dk", ")", ">", "1e-12", ")", "\n", "bounds", "=", "(", "Gk", "-", "Sk", ")", "[", "indices", "]", "/", "Dk", "[", "indices", "]", "\n", "Lambda", "=", "min", "(", "bounds", "[", "np", ".", "where", "(", "bounds", ">=", "0", ")", "]", ",", "default", "=", "0", ")", "\n", "\n", "return", "starting_point", "+", "Lambda", "*", "direction", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_bisection": [[381, 433], ["len", "expohedron.majorized", "expohedron.majorized", "len", "len", "np.sum", "expohedron.majorized", "np.all", "np.sum", "np.sum", "expohedron.post_correction", "np.sum", "np.abs", "expohedron.identify_face"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face"], ["", "def", "find_face_intersection_bisection", "(", "gamma", ":", "np", ".", "ndarray", ",", "starting_point", ":", "np", ".", "ndarray", ",", "direction", ":", "np", ".", "ndarray", ",", "precision", ":", "float", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Executes a bisection search in the PBM-expohedron using the majorization criterion.\n\n        It finds the intersection of a half-line starting at `starting_point` in the direction `direction` with the border of the expohedron defined by `gamma`.\n    :param gamma: Any vertex of the PBM-expohedron\n    :type gamma: numpy.ndarray\n    :param starting_point: The starting point of the half-line\n    :type starting_point: numpy.ndarray\n    :param direction: The direction of the half-line\n    :type direction: numpy.ndarray\n    :param precision: The presicion required for termination of bisection\n    :type precision: float, optional\n    :return: The intersection of the expohedron's boundary with the half-line\n    :rtype numpy.ndarray\n    \"\"\"", "\n", "# 0. Input checks", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "assert", "n", "==", "len", "(", "starting_point", ")", ",", "\"`starting_point` does not have the same length as `gamma`.\"", "\n", "assert", "n", "==", "len", "(", "direction", ")", ",", "\"`direction` does not have the same length as `gamma`.\"", "\n", "assert", "majorized", "(", "starting_point", ",", "gamma", ")", ",", "\"`starting_point` needs to be majorized by `gamma`. Check your inputs or decrease majorization tolerance.\"", "\n", "\n", "# direction = direction / np.linalg.norm(direction)  # normalize direction", "\n", "# 1. Find upper and lower bound", "\n", "k", "=", "1", "\n", "while", "majorized", "(", "(", "starting_point", "+", "k", "*", "direction", ")", "/", "np", ".", "sum", "(", "(", "starting_point", "+", "k", "*", "direction", ")", ")", "*", "np", ".", "sum", "(", "gamma", ")", ",", "gamma", ")", ":", "# We make sure the tested point is in the", "\n", "# hyperplane containing the expohedron", "\n", "        ", "k", "*=", "2", "\n", "", "upper_bound", "=", "(", "starting_point", "+", "k", "*", "direction", ")", "/", "np", ".", "sum", "(", "(", "starting_point", "+", "k", "*", "direction", ")", ")", "*", "np", ".", "sum", "(", "gamma", ")", "\n", "lower_bound", "=", "starting_point", "\n", "\n", "# 2. Do bisection", "\n", "nb_iterations", "=", "0", "\n", "# face = identify_face(gamma, starting_point)", "\n", "while", "True", ":", "\n", "        ", "nb_iterations", "+=", "1", "\n", "center", "=", "(", "upper_bound", "+", "lower_bound", ")", "/", "2", "\n", "# center = center / np.sum(center) * np.sum(gamma)", "\n", "if", "majorized", "(", "center", ",", "gamma", ",", "tolerance", "=", "precision", ")", ":", "# project center on face's affine subspace", "\n", "            ", "lower_bound", "=", "center", "\n", "# face = identify_face(gamma, lower_bound)", "\n", "# lower_bound = post_correction(face, lower_bound)", "\n", "", "else", ":", "\n", "            ", "upper_bound", "=", "center", "\n", "", "if", "np", ".", "all", "(", "np", ".", "abs", "(", "upper_bound", "-", "lower_bound", ")", "<", "precision", ")", ":", "\n", "            ", "return", "post_correction", "(", "identify_face", "(", "gamma", ",", "lower_bound", ")", ",", "lower_bound", ")", "\n", "# return lower_bound", "\n", "# return find_face_intersection_same_ordering(gamma, lower_bound, direction, override_order_constraint=True)", "\n", "# elif np.all(np.abs(upper_bound - lower_bound) < precision):", "\n", "#     return lower_bound / np.sum(lower_bound) * np.sum(gamma)", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face": [[435, 457], ["len", "np.where", "expohedron.Face", "len", "np.argsort", "np.abs", "np.cumsum", "np.cumsum", "np.sort", "np.sort"], "function", ["None"], ["", "", "", "def", "identify_face", "(", "gamma", ":", "np", ".", "ndarray", ",", "point_on_face", ":", "np", ".", "ndarray", ",", "tolerance", ":", "float", "=", "LOW_TOLERANCE", ")", "->", "Face", ":", "\n", "    ", "\"\"\"\n        Computes the smallest face of the `gamma`-PBM-expohedron of which `point` is situated\n\n    :param gamma: A vertex of the expohedron\n    :type gamma: numpy.array\n    :param point_on_face: The point to be examined\n    :type point_on_face: numpy.array\n    :param tolerance: The allowed tolerance\n    :type: float, optional\n    :return: The smallest face in which the intersection lies\n\n    A tuple containing:\n            (1) The permutation corresponding to an order-preserving zone\n            (2) The indices of the splits and the dimensionality of the face\n    :rtype: Face\n    \"\"\"", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "assert", "n", "==", "len", "(", "point_on_face", ")", "\n", "\n", "splits", "=", "np", ".", "where", "(", "np", ".", "abs", "(", "np", ".", "cumsum", "(", "np", ".", "sort", "(", "gamma", ")", ")", "-", "np", ".", "cumsum", "(", "np", ".", "sort", "(", "point_on_face", ")", ")", ")", "<", "tolerance", ")", "\n", "return", "Face", "(", "gamma", ",", "np", ".", "argsort", "(", "point_on_face", ")", ",", "splits", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction": [[459, 476], ["expohedron.find_face_subspace", "face.contains", "utils.project_on_subspace", "utils.invert_permutation"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.contains", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation"], ["", "def", "post_correction", "(", "face", ":", "Face", ",", "point", ":", "np", ".", "ndarray", ",", "tolerance", ":", "float", "=", "DEFAULT_TOLERANCE", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Projects a point `point` onto the smallest *affine* subspace that contains the face `face`.\n    :param face: The face on whose subspace to project\n    :type face: Face\n    :param point: The point to project\n    :type point: numpy.ndarray\n    :param tolerance: The allowed tolerance\n    :type tolerance: float, optional\n    :return: The projected point, that must now lie on the affine subspace\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "vertex_of_face", "=", "face", ".", "gamma", "[", "invert_permutation", "(", "face", ".", "zone", ")", "]", "\n", "face_subspace", "=", "find_face_subspace", "(", "face", ")", "\n", "projected_point", "=", "project_on_subspace", "(", "point", "-", "vertex_of_face", ",", "face_subspace", ".", "T", ")", "+", "vertex_of_face", "\n", "assert", "face", ".", "contains", "(", "projected_point", ")", ",", "\"There has been an error in the projection on a face's subspace\"", "\n", "return", "projected_point", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.caratheodory_decomposition_pbm_gls": [[478, 541], ["expohedron.majorized", "np.sort", "len", "np.zeros", "np.zeros", "expohedron.identify_face", "np.arange", "np.squeeze", "np.all", "np.any", "expohedron.identify_face", "np.all", "utils.project_on_subspace", "expohedron.find_face_intersection", "expohedron.post_correction", "np.where", "np.abs", "warnings.warn", "utils.invert_permutation", "expohedron.identify_face", "expohedron.identify_face", "np.where", "np.abs", "np.abs", "np.argsort", "np.abs", "expohedron.find_face_subspace", "np.linalg.norm", "np.linalg.norm", "utils.invert_permutation", "expohedron.identify_face", "expohedron.identify_face", "np.sum", "str", "expohedron.identify_face", "np.argsort"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face"], ["", "def", "caratheodory_decomposition_pbm_gls", "(", "gamma", ":", "np", ".", "ndarray", ",", "point", ":", "np", ".", "ndarray", ",", "tol", ":", "float", "=", "HIGH_TOLERANCE", ")", ":", "\n", "    ", "\"\"\"\n    Finds the Carath\u00e9odory decomposition of a point `x` in a PBM-expohedron with vertex `gamma` using the GLS method\n\n    This is done using the GLS procedure\n    A non-zero tolerance is necessary to account for numerical imprecision\n    :param gamma: The initial vertex of the expohedron\n    :type gamma: numpy.ndarray\n    :param point: The point to decompose\n    :type point: numpy.ndarray\n    :param tol: The allowed tolerance\n    :type tol: float\n    :return: A tuple whose first element is a (matrix whose columns contain the vertices of the decomposition)\n        and whose second element is a vector of convex coefficients. We have `point == vertices @ convex_coefficients`.\n    :rtype:\n    \"\"\"", "\n", "assert", "majorized", "(", "point", ",", "gamma", ")", ",", "\"`x` is not majorized by `gamma`. Only points inside the expohedron can be decomposed as a convex sum of its vertices.\"", "\n", "\n", "gamma", "=", "np", ".", "sort", "(", "gamma", ")", "# We work with an increasing permutation of gamma", "\n", "n", "=", "len", "(", "point", ")", "\n", "vertices", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", "# Initializing the vertices (empty for now)", "\n", "convex_coefficients", "=", "np", ".", "zeros", "(", "n", ")", "# Initializing the convex coefficients (empty for now)", "\n", "\n", "face", "=", "identify_face", "(", "gamma", ",", "point", ")", "\n", "\n", "vertices", "[", ":", ",", "0", "]", "=", "gamma", "[", "invert_permutation", "(", "np", ".", "argsort", "(", "point", ")", ")", "]", "# Initialize the initial vertex", "\n", "convex_coefficients", "[", "0", "]", "=", "1", "\n", "x", "=", "point", "\n", "dim", "=", "identify_face", "(", "gamma", ",", "x", ")", ".", "dim", "\n", "for", "i", "in", "np", ".", "arange", "(", "0", ",", "n", "-", "1", ")", ":", "\n", "# pdb.set_trace()", "\n", "        ", "if", "np", ".", "all", "(", "np", ".", "abs", "(", "vertices", "@", "convex_coefficients", "-", "point", ")", "<", "tol", ")", ":", "\n", "            ", "return", "convex_coefficients", ",", "vertices", "\n", "", "v", "=", "vertices", "[", ":", ",", "i", "]", "\n", "approx_direction", "=", "x", "-", "v", "\n", "direction", "=", "project_on_subspace", "(", "approx_direction", ",", "find_face_subspace", "(", "identify_face", "(", "gamma", ",", "x", ")", ")", ".", "T", ")", "\n", "# direction = approx_direction", "\n", "intersection", "=", "find_face_intersection", "(", "gamma", ",", "v", ",", "direction", ")", "\n", "intersection", "=", "post_correction", "(", "identify_face", "(", "gamma", ",", "intersection", ")", ",", "intersection", ")", "\n", "old_ci", "=", "convex_coefficients", "[", "i", "]", "\n", "convex_coefficients", "[", "i", "]", "=", "np", ".", "linalg", ".", "norm", "(", "intersection", "-", "x", ")", "/", "np", ".", "linalg", ".", "norm", "(", "intersection", "-", "v", ")", "*", "convex_coefficients", "[", "i", "]", "\n", "convex_coefficients", "[", "i", "+", "1", "]", "=", "old_ci", "-", "convex_coefficients", "[", "i", "]", "\n", "vertices", "[", ":", ",", "i", "+", "1", "]", "=", "gamma", "[", "invert_permutation", "(", "np", ".", "argsort", "(", "intersection", ")", ")", "]", "# Choose a vertex with the same ordering as `u`", "\n", "old_x", "=", "x", "\n", "x", "=", "intersection", "# `u`, the intersection, is the new point to decompose", "\n", "assert", "identify_face", "(", "gamma", ",", "x", ")", ".", "dim", "<", "dim", ",", "\"At each step, the dimensionality of the face must be reduced\"", "\n", "dim", "=", "identify_face", "(", "gamma", ",", "x", ")", ".", "dim", "\n", "if", "identify_face", "(", "gamma", ",", "x", ")", ".", "dim", "==", "0", ":", "\n", "            ", "break", "# if we finish on a vertex early, then we break", "\n", "\n", "# Remove vertices whose coefficients are below a certain threshold", "\n", "", "", "convex_coefficients", "[", "np", ".", "where", "(", "convex_coefficients", "<", "MAX_TOLERANCE", ")", "]", "=", "0", "# Affect 0 to negligible coefficients", "\n", "indices", "=", "np", ".", "squeeze", "(", "np", ".", "where", "(", "convex_coefficients", "!=", "0", ")", ")", "\n", "convex_coefficients", "=", "convex_coefficients", "[", "indices", "]", "\n", "vertices", "=", "vertices", "[", ":", ",", "indices", "]", "\n", "\n", "# Final test", "\n", "assert", "np", ".", "abs", "(", "np", ".", "sum", "(", "convex_coefficients", ")", "-", "1", ")", "<", "tol", ",", "\"Convex coefficients must sum to 1\"", "\n", "assert", "np", ".", "all", "(", "np", ".", "abs", "(", "vertices", "@", "convex_coefficients", "-", "point", ")", "<", "ULTRA_LOW_TOLERANCE", ")", ",", "\"Carath\u00e9odory decomposition did not work\"", "\n", "if", "np", ".", "any", "(", "np", ".", "abs", "(", "vertices", "@", "convex_coefficients", "-", "point", ")", ">", "DEFAULT_TOLERANCE", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"Beware, Carath\u00e9odory decomposition has reconstruction precision lower than \"", "+", "str", "(", "DEFAULT_TOLERANCE", ")", ",", "RuntimeWarning", ")", "\n", "\n", "", "return", "convex_coefficients", ",", "vertices", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.billiard.billiard_word": [[8, 32], ["all", "abs", "heapq.heappop", "heapq.heappush", "range", "sum", "len"], "function", ["None"], ["def", "billiard_word", "(", "frequency", ")", ":", "\n", "    ", "\"\"\"\n    We break ties by order in the input.\n\n    Example\n    ------\n    To make the first 20 letters of the balanced sequence\n        0, 1, 1, 0, 1, 0, 1, 1, 0, 1, ...,\n    which repeats every 5 letters, do\n        from billiard_word import billiard_word\n        gen = billiard_word([2/5, 3/5])\n        sequence = [next(gen) for _ in range(20)]\n    \"\"\"", "\n", "import", "heapq", "\n", "\n", "assert", "all", "(", "_", ">", "0", "for", "_", "in", "frequency", ")", "\n", "assert", "abs", "(", "sum", "(", "frequency", ")", "-", "1.", ")", "<", "1e-9", "\n", "\n", "tiny", "=", "1e-9", "# control roundoff issues for finite words", "\n", "heap", "=", "[", "(", "tiny", "*", "_", ",", "_", ")", "for", "_", "in", "range", "(", "len", "(", "frequency", ")", ")", "]", "\n", "while", "True", ":", "\n", "        ", "phase", ",", "letter", "=", "heapq", ".", "heappop", "(", "heap", ")", "\n", "heapq", ".", "heappush", "(", "heap", ",", "(", "phase", "+", "1.", "/", "frequency", "[", "letter", "]", ",", "letter", ")", ")", "\n", "yield", "letter", "\n", "", "", ""]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.PrecisionError.__init__": [[18, 22], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "expression", ",", "message", ")", ":", "\n", "        ", "self", ".", "expression", "=", "expression", "\n", "self", ".", "message", "=", "message", "\n", "self", ".", "counter", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.pareto_curve_pbm": [[24, 74], ["np.all", "utils.vprint", "utils.vprint", "pareto.fairness_endpoint", "utils.vprint", "utils.vprint", "np.eye", "np.all", "UserWarning", "utils.vprint", "expohedron.identify_face", "utils.vprint", "utils.project_on_subspace", "utils.vprint", "expohedron.find_face_intersection", "utils.vprint", "pareto_endpoints.append", "len", "str", "np.sort", "np.sort", "np.abs", "expohedron.find_face_subspace", "str", "str", "str", "str", "np.sort", "str", "str"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace"], ["", "", "def", "pareto_curve_pbm", "(", "pbm", ":", "np", ".", "ndarray", ",", "relevance_values", ":", "np", ".", "ndarray", ",", "fairness", ":", "str", ",", "p_norm", ":", "float", "=", "2", ",", "grouping", ":", "np", ".", "ndarray", "=", "None", ",", "verbose", ":", "int", "=", "0", ")", "->", "list", ":", "\n", "    ", "\"\"\"\n        Finds the Pareto curve for the multi-objective fairness-utility problem\n\n    :param pbm: The Position-Based Model (PBM) defining the expohedron\n    :type pbm: numpy.ndarray\n    :param relevance_values: The relevance values of the documents to rank\n    :type relevance_values: numpy.ndarray\n    :param fairness: The type of fairness to be used. Can be \"demographic\" for demographic fairness or \"meritocratic\" for meritocratic fairness\n    :type fairness: str\n    :param p_norm: The norm to be used for the fairness objective. Only p=2 is currently supported.\n    :type p_norm: int, optional\n    :param grouping: The group membership matrix of the documents\n    :type grouping: numpy.ndarray\n    :return: The endpoint of the line segments that constitute the Pareto frontier\n    :rtype: list\n    \"\"\"", "\n", "# 0. Input checks", "\n", "assert", "p_norm", "==", "2", ",", "\"Only the 2-norm is currently supported\"", "\n", "# assert fairness == \"demographic\", \"Only demographic fairness is currently supported\"", "\n", "assert", "np", ".", "all", "(", "pbm", ">=", "0", ")", ",", "\"Exposures must be positive\"", "\n", "if", "grouping", "is", "None", ":", "\n", "        ", "grouping", "=", "np", ".", "eye", "(", "len", "(", "pbm", ")", ")", "\n", "", "if", "not", "np", ".", "all", "(", "-", "np", ".", "sort", "(", "-", "pbm", ")", "==", "pbm", ")", ":", "\n", "        ", "UserWarning", "(", "\"You gave me a PBM that does not have strictly decreasing exposure. Are you sure this is what you want to do ?\"", ")", "\n", "\n", "# 1. Find Fairness starting point and utility endpoint", "\n", "", "vprint", "(", "\"\\n-------- Finding Pareto Curve --------\\n\"", ",", "verbose", ")", "\n", "vprint", "(", "\"---- Finding Fairness endpoint ----\\n\"", ",", "verbose", ")", "\n", "starting_point", "=", "fairness_endpoint", "(", "pbm", ",", "relevance_values", ",", "grouping", ",", "verbose", "=", "verbose", ")", "\n", "vprint", "(", "\"The fairness endpoint is \"", "+", "str", "(", "starting_point", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"\\n---- Computing the rest of the Pareto curve ----\\n\"", ",", "verbose", ")", "\n", "# end_point = -np.argsort(-relevance_values)  # The PRP solution", "\n", "# NB: The endpoint is uncertain at this moment, if there are duplicates in the relevance values. However the performance in terms of C-utility of the endpoint is known.", "\n", "prp_utility", "=", "-", "np", ".", "sort", "(", "-", "relevance_values", ")", "@", "-", "np", ".", "sort", "(", "-", "pbm", ")", "\n", "\n", "# 2. Find segments", "\n", "current_point", "=", "starting_point", "\n", "pareto_endpoints", "=", "[", "current_point", "]", "\n", "while", "not", "np", ".", "abs", "(", "current_point", "@", "relevance_values", "-", "prp_utility", ")", "<", "1e-6", ":", "\n", "        ", "vprint", "(", "\"Current utility is \"", "+", "str", "(", "current_point", "@", "relevance_values", ")", "+", "\" while the PRP utility is \"", "+", "str", "(", "prp_utility", ")", ",", "verbose", ")", "\n", "face", "=", "identify_face", "(", "pbm", ",", "current_point", ")", "\n", "vprint", "(", "\"We are on a face of dimension \"", "+", "str", "(", "face", ".", "dim", ")", "+", "\" with splits \"", "+", "str", "(", "face", ".", "splits", ")", ",", "verbose", ")", "\n", "face_orthogonal", "=", "find_face_subspace", "(", "face", ")", ".", "T", "\n", "direction", "=", "project_on_subspace", "(", "relevance_values", ",", "face_orthogonal", ")", "\n", "vprint", "(", "\"The projection of the relevance vector on the current face is \"", "+", "str", "(", "direction", ")", ",", "verbose", ")", "\n", "current_point", "=", "find_face_intersection", "(", "pbm", ",", "starting_point", ",", "direction", ")", "\n", "vprint", "(", "\"Intersection with the expohedron at \"", "+", "str", "(", "current_point", ")", ",", "verbose", ")", "\n", "pareto_endpoints", ".", "append", "(", "current_point", ")", "\n", "", "return", "pareto_endpoints", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.pareto_curve_pbm_individual": [[76, 157], ["np.all", "len", "utils.vprint", "utils.vprint", "expohedron.identify_face", "expohedron.post_correction", "utils.vprint", "utils.vprint", "utils.vprint", "utils.vprint", "utils.vprint", "utils.vprint", "utils.vprint", "expohedron.identify_face", "utils.vprint", "utils.vprint", "len", "len", "utils.vprint", "np.sort", "np.sort", "np.abs", "utils.vprint", "expohedron.find_face_subspace", "utils.project_on_subspace", "utils.vprint", "utils.vprint", "utils.vprint", "utils.vprint", "expohedron.find_face_intersection", "expohedron.identify_face", "expohedron.post_correction", "utils.vprint", "pareto.append", "np.ones", "np.mean", "utils.vprint", "str", "str", "str", "str", "pareto.PrecisionError", "str", "str", "str", "np.sort", "utils.vprint", "pareto.fairness_endpoint_individual_meritocratic_intersection", "str", "str", "str", "str", "str", "ValueError", "str", "str", "str", "np.abs", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint_individual_meritocratic_intersection"], ["", "def", "pareto_curve_pbm_individual", "(", "pbm", ":", "np", ".", "ndarray", ",", "relevance_values", ":", "np", ".", "ndarray", ",", "fairness", ":", "str", ",", "p_norm", ":", "float", "=", "2", ",", "meritocratic_endpoint", ":", "str", "=", "\"intersection\"", ",", "verbose", ":", "int", "=", "0", ")", "->", "list", ":", "\n", "    ", "\"\"\"\n        Computes The Pareto curve for individual fairness with a PBM model using the expohedron.\n\n    :param pbm: The Position Based Model (PBM) to be used. Must be ordered from first to last rank, and must be decreasing\n    :type pbm: numpy.ndarray\n    :param relevance_values: The relevance values of the documents\n    :type relevance_values: numpy.ndarray\n    :param fairness: The fairness type. \"demographic\" or \"meritocratic\" are the two possible options\n    :type fairness: str\n    :param p_norm: The norm to be used for the fairness objective. Only p=2 is currently implemented\n    :type p_norm: float, optional\n    :param verbose: How talkative should I be ?\n    :type verbose: int, optional\n    :return: The Pareto curve in the form of a list of points making up the endpoints of connected line segments\n    :rtype: list\n    \"\"\"", "\n", "\n", "# 0. Input checks", "\n", "assert", "p_norm", "==", "2", ",", "\"Only p_norm==2 is currently implemented\"", "\n", "assert", "len", "(", "pbm", ")", "==", "len", "(", "relevance_values", ")", "\n", "assert", "fairness", "==", "\"demographic\"", "or", "fairness", "==", "\"meritocratic\"", "\n", "assert", "meritocratic_endpoint", "==", "\"intersection\"", ",", "\"Only the endpoint method is currently implemented\"", "\n", "assert", "np", ".", "all", "(", "-", "np", ".", "sort", "(", "-", "pbm", ")", "==", "pbm", ")", ",", "\"`pbm` must be decreasing\"", "\n", "n", "=", "len", "(", "pbm", ")", "\n", "\n", "# 1. Compute Starting point", "\n", "vprint", "(", "\"\\n-------- Finding Pareto Curve --------\\n\"", ",", "verbose", ")", "\n", "vprint", "(", "\"---- Finding Fairness endpoint ----\\n\"", ",", "verbose", ")", "\n", "if", "fairness", "==", "\"demographic\"", ":", "\n", "        ", "vprint", "(", "\"Demographic fairness chosen. The starting point is the expohedron's barycenter\"", ",", "verbose", ")", "\n", "starting_point", "=", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "pbm", ")", "# The starting point is the barycenter", "\n", "", "elif", "fairness", "==", "\"meritocratic\"", ":", "\n", "        ", "vprint", "(", "\"Meritocratic fairness chosen\"", ",", "verbose", ")", "\n", "if", "meritocratic_endpoint", "==", "\"intersection\"", ":", "\n", "            ", "vprint", "(", "\"Using the intersection method\"", ",", "verbose", ")", "\n", "starting_point", "=", "fairness_endpoint_individual_meritocratic_intersection", "(", "pbm", ",", "relevance_values", ")", "\n", "", "elif", "meritocratic_endpoint", "==", "\"projection\"", ":", "\n", "            ", "raise", "ValueError", "(", "\"Projection method not yet implemented\"", ")", "\n", "\n", "# 2. Trace the Pareto frontier", "\n", "", "", "pareto", "=", "[", "starting_point", "]", "\n", "prp_utility", "=", "np", ".", "sort", "(", "pbm", ")", "@", "np", ".", "sort", "(", "relevance_values", ")", "\n", "current_point", "=", "starting_point", "\n", "current_utility", "=", "current_point", "@", "relevance_values", "\n", "current_face", "=", "identify_face", "(", "pbm", ",", "current_point", ")", "\n", "corrected_point", "=", "post_correction", "(", "current_face", ",", "current_point", ")", "\n", "vprint", "(", "\"The fairness endpoint is \"", "+", "str", "(", "starting_point", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"Current utility is \"", "+", "str", "(", "current_point", "@", "relevance_values", ")", "+", "\".\\nPRP utility is     \"", "+", "str", "(", "prp_utility", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"Current point is \"", "+", "str", "(", "current_point", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"On face of dimension \"", "+", "str", "(", "current_face", ".", "dim", ")", "+", "\" with splits \"", "+", "str", "(", "current_face", ".", "splits", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"\\n---- Computing the rest of the Pareto curve ----\\n\"", ",", "verbose", ")", "\n", "k", "=", "0", "\n", "while", "np", ".", "abs", "(", "current_utility", "-", "prp_utility", ")", ">", "UTILITY_PRECISION", ":", "\n", "        ", "k", "+=", "1", "\n", "vprint", "(", "\"\\n\\n-- S T E P   \"", "+", "str", "(", "k", ")", "+", "\" --\\n\"", ",", "verbose", ")", "\n", "face_orth", "=", "find_face_subspace", "(", "current_face", ")", "\n", "direction", "=", "project_on_subspace", "(", "relevance_values", ",", "face_orth", ".", "T", ")", "\n", "direction", "[", "np", ".", "abs", "(", "direction", ")", "<", "1e-13", "]", "=", "0.", "\n", "vprint", "(", "\"The projection of the relevance vector on the current face is \"", "+", "str", "(", "direction", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"Current utility is \"", "+", "str", "(", "current_point", "@", "relevance_values", ")", "+", "\".\\nPRP utility is     \"", "+", "str", "(", "prp_utility", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"Current point is \"", "+", "str", "(", "current_point", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"On face of dimension \"", "+", "str", "(", "current_face", ".", "dim", ")", "+", "\" with splits \"", "+", "str", "(", "current_face", ".", "splits", ")", ",", "verbose", ")", "\n", "new_point", "=", "find_face_intersection", "(", "pbm", ",", "corrected_point", ",", "direction", ")", "\n", "new_face", "=", "identify_face", "(", "pbm", ",", "new_point", ")", "\n", "corrected_point", "=", "post_correction", "(", "new_face", ",", "new_point", ")", "\n", "new_utility", "=", "new_point", "@", "relevance_values", "\n", "if", "not", "new_face", ".", "dim", "<", "current_face", ".", "dim", ":", "\n", "            ", "raise", "PrecisionError", "(", "\"if not face.dim < current_dim\"", ",", "\"A precision error is likely to have occurred\"", ")", "\n", "", "vprint", "(", "\"Intersection with the expohedron at \"", "+", "str", "(", "new_point", ")", ",", "verbose", ")", "\n", "pareto", ".", "append", "(", "new_point", ")", "\n", "current_point", "=", "new_point", "\n", "current_utility", "=", "new_utility", "\n", "current_face", "=", "new_face", "\n", "", "assert", "current_utility", "-", "prp_utility", "<=", "1e-6", ",", "\"We get a utility that is higher than PRP, so there is an error somewhere\"", "\n", "vprint", "(", "\"\\n\\n--- Utility Endpoint ---\\n\"", ",", "verbose", ")", "\n", "vprint", "(", "\"Current utility is \"", "+", "str", "(", "current_point", "@", "relevance_values", ")", "+", "\".\\nPRP utility is     \"", "+", "str", "(", "prp_utility", ")", ",", "verbose", ")", "\n", "face", "=", "identify_face", "(", "pbm", ",", "current_point", ")", "\n", "vprint", "(", "\"Current point is \"", "+", "str", "(", "current_point", ")", ",", "verbose", ")", "\n", "vprint", "(", "\"On face of dimension \"", "+", "str", "(", "face", ".", "dim", ")", "+", "\" with splits \"", "+", "str", "(", "face", ".", "splits", ")", "+", "\" in zone \"", "+", "str", "(", "face", ".", "zone", ")", ",", "verbose", ")", "\n", "return", "pareto", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint_individual_meritocratic_intersection": [[159, 180], ["len", "expohedron.majorized", "len", "np.sum", "expohedron.find_face_intersection", "np.sum", "np.ones", "np.mean", "expohedron.identify_face"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face"], ["", "def", "fairness_endpoint_individual_meritocratic_intersection", "(", "pbm", ":", "np", ".", "ndarray", ",", "relevance_values", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Computes the fairness endpoint for meritocratic individual fairness\n\n    :param pbm: The Position Based Model (PBM)\n    :type pbm: numpy.ndarray\n    :param relevance_values: The vector of relevance values\n    :type relevance_values: numpy.ndarray\n    :return: The intersection between the true target and the barycenter of the expohedron\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "n", "=", "len", "(", "pbm", ")", "\n", "assert", "n", "==", "len", "(", "relevance_values", ")", "\n", "true_target", "=", "relevance_values", "/", "np", ".", "sum", "(", "relevance_values", ")", "*", "np", ".", "sum", "(", "pbm", ")", "\n", "if", "majorized", "(", "true_target", ",", "pbm", ")", ":", "\n", "        ", "return", "true_target", "\n", "", "else", ":", "\n", "        ", "barycenter", "=", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "pbm", ")", "\n", "intersection", "=", "find_face_intersection", "(", "pbm", ",", "barycenter", ",", "true_target", "-", "barycenter", ")", "\n", "assert", "identify_face", "(", "pbm", ",", "intersection", ")", ".", "dim", "<", "n", "-", "1", ",", "\"The intersection must lie on a face of the expohedron that is not the expohedron itself\"", "\n", "return", "intersection", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint": [[182, 234], ["len", "utils.vprint", "utils.project_on_subspace", "utils.vprint", "expohedron.find_face_intersection", "utils.vprint", "expohedron.majorized", "utils.vprint", "len", "np.all", "expohedron.identify_face", "utils.vprint", "expohedron.find_face_subspace", "np.concatenate", "utils.vprint", "utils.project_on_subspace", "utils.vprint", "expohedron.find_face_intersection", "utils.vprint", "expohedron.majorized", "np.sum", "np.mean", "np.ones", "ValueError", "str", "str", "orth", "np.sum", "np.sum", "str", "np.abs", "str", "str", "str", "np.sum", "np.linalg.matrix_rank", "str", "str", "str", "np.linalg.matrix_rank"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized"], ["", "", "def", "fairness_endpoint", "(", "pbm", ":", "np", ".", "ndarray", ",", "relevance_values", ":", "np", ".", "ndarray", ",", "grouping", ":", "np", ".", "ndarray", "=", "None", ",", "fairness", ":", "str", "=", "\"demographic\"", ",", "verbose", ":", "int", "=", "0", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Finds the Pareto-optimal point that minimizes the unfairness for demographic group-fairness\n\n    :param pbm: The Position Based Model (PBM) to be used. It is an array containing the exposures from first to last rank\n    :type pbm: numpy.ndarray\n    :param relevance_values: The relevance values of the items to be ranked.\n    :type relevance_values: numpy.ndarray\n    :param grouping: The aggregation matrix to go from item exposure to group exposure\n    :type grouping: numpy.ndarray, optional\n    :param fairness: The type of fairness to be used\n    :type fairness: str, optional\n    :return: The maximal-utility point amongst the minimal unfairness points\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "n", "=", "len", "(", "pbm", ")", "\n", "assert", "n", "==", "len", "(", "relevance_values", ")", ",", "\"Not the right amount of relevance values\"", "\n", "if", "grouping", "is", "None", "and", "fairness", "==", "\"meritocratic\"", ":", "\n", "        ", "return", "relevance_values", "/", "np", ".", "sum", "(", "relevance_values", ")", "*", "np", ".", "sum", "(", "pbm", ")", "\n", "", "assert", "n", "==", "grouping", ".", "shape", "[", "1", "]", ",", "\"Grouping matrix has has not as many columns as there are documents\"", "\n", "assert", "fairness", "==", "\"demographic\"", ",", "\"For now, only demographic fairness is supported\"", "\n", "\n", "subspace", "=", "grouping", "\n", "if", "fairness", "==", "\"demographic\"", ":", "\n", "        ", "p1", "=", "np", ".", "mean", "(", "pbm", ")", "*", "np", ".", "ones", "(", "n", ")", "\n", "", "elif", "fairness", "==", "\"meritocratic\"", ":", "\n", "        ", "p1", "=", "relevance_values", "/", "np", ".", "sum", "(", "relevance_values", ")", "*", "np", ".", "sum", "(", "pbm", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"`fairness` must be either 'demographic' or 'meritocratic'.\"", ")", "\n", "", "vprint", "(", "\"Barycenter: \"", "+", "str", "(", "p1", ")", ",", "verbose", ")", "\n", "direction", "=", "project_on_subspace", "(", "relevance_values", ",", "subspace", ")", "\n", "vprint", "(", "\"Going into direction \"", "+", "str", "(", "direction", ")", "+", "\" after projection on a subspace with \"", "+", "str", "(", "np", ".", "linalg", ".", "matrix_rank", "(", "subspace", ")", ")", "+", "\" orthogonal vectors\"", ",", "\n", "verbose", ")", "\n", "p2", "=", "find_face_intersection", "(", "pbm", ",", "p1", ",", "direction", ")", "\n", "vprint", "(", "\"Intersecting the expohedron at \"", "+", "str", "(", "p2", ")", ",", "verbose", ")", "\n", "majorized", "(", "p2", ",", "pbm", ")", "\n", "while", "not", "np", ".", "all", "(", "np", ".", "abs", "(", "p2", "-", "p1", ")", "<", "DEFAULT_TOLERANCE", ")", ":", "\n", "        ", "p1", "=", "p2", "\n", "face", "=", "identify_face", "(", "gamma", "=", "pbm", ",", "point_on_face", "=", "p1", ")", "\n", "vprint", "(", "\"Last point is on a face of dimension \"", "+", "str", "(", "face", ".", "dim", ")", "+", "\" with splits \"", "+", "str", "(", "face", ".", "splits", ")", ",", "verbose", ")", "\n", "face_orthogonal", "=", "find_face_subspace", "(", "face", ")", "\n", "subspace", "=", "np", ".", "concatenate", "(", "(", "subspace", ",", "face_orthogonal", ".", "T", ")", ",", "axis", "=", "0", ")", "\n", "subspace", "=", "orth", "(", "subspace", ".", "T", ")", ".", "T", "\n", "vprint", "(", "\"The intersection of the previous subspace with the face's subspace has \"", "+", "str", "(", "np", ".", "linalg", ".", "matrix_rank", "(", "subspace", ")", ")", "+", "\" orthogonal vectors\"", ",", "\n", "verbose", ")", "\n", "direction", "=", "project_on_subspace", "(", "relevance_values", ",", "subspace", ")", "\n", "vprint", "(", "\"The direction projected on this subspace is \"", "+", "str", "(", "direction", ")", ",", "verbose", ")", "\n", "p2", "=", "find_face_intersection", "(", "pbm", ",", "p1", ",", "direction", ")", "\n", "vprint", "(", "\"Intersecting the expohedron at \"", "+", "str", "(", "p2", ")", ",", "verbose", ")", "\n", "majorized", "(", "p2", ",", "pbm", ")", "\n", "", "vprint", "(", "\"Last two points were identical. Returning last point.\"", ",", "verbose", ")", "\n", "return", "p2", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.pareto_curve_objective_space_individual": [[236, 256], ["len", "np.zeros", "np.zeros", "np.arange", "np.sort", "np.sort", "utils.compute_unfairness"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.compute_unfairness"], ["", "def", "pareto_curve_objective_space_individual", "(", "pareto_curve_expohedron", ":", "list", ",", "pbm", ":", "np", ".", "ndarray", ",", "relevance_values", ":", "np", ".", "ndarray", ",", "target", ":", "np", ".", "ndarray", ",", "p_norm", ":", "float", "=", "2", ")", "->", "tuple", ":", "\n", "    ", "\"\"\"\n        Takes a Pareto-curve in the expohedron and computes the corresponding Pareto-curve in the objective space\n\n    :param pareto_curve_expohedron:\n    :param pbm:\n    :param relevance_values:\n    :param target:\n    :param p_norm:\n    :return: The nPBM utility and the unfairness\n    \"\"\"", "\n", "n", "=", "len", "(", "pareto_curve_expohedron", ")", "\n", "utility_vector", "=", "np", ".", "zeros", "(", "n", ")", "\n", "unfairness_vector", "=", "np", ".", "zeros", "(", "n", ")", "\n", "prp_utility", "=", "np", ".", "sort", "(", "pbm", ")", "@", "np", ".", "sort", "(", "relevance_values", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "0", ",", "n", ")", ":", "\n", "        ", "v", "=", "pareto_curve_expohedron", "[", "i", "]", "\n", "utility_vector", "[", "i", "]", "=", "v", "@", "relevance_values", "/", "prp_utility", "\n", "unfairness_vector", "[", "i", "]", "=", "compute_unfairness", "(", "v", ",", "target", ",", "p_norm", ")", "\n", "", "return", "utility_vector", ",", "unfairness_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.scalarized_objective_within_pareto_segment": [[258, 285], ["utils.nutility", "np.linalg.norm", "np.linalg.norm"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.nutility"], ["", "def", "scalarized_objective_within_pareto_segment", "(", "alpha", ":", "float", ",", "scalarization", ":", "float", ",", "\n", "point1", ":", "np", ".", "ndarray", ",", "point2", ":", "np", ".", "ndarray", ",", "\n", "target_exposure", ":", "np", ".", "ndarray", ",", "\n", "pbm", ":", "np", ".", "ndarray", ",", "\n", "relevance_vector", ":", "np", ".", "ndarray", ",", "\n", "prp_exposure", ",", "\n", "fairness", ":", "str", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n        given a convex combination of two exposure vectors, computes the value of the scalarized objective\n\n            min \u03b1 (-U) + (1-\u03b1) F\n\n    :param alpha: The convex combination parameter of the two exposure vectors\n    :type alpha: float\n    :param scalarization: The scalarization parameter\n    :type scalarization: float\n    :param point1: An exposure vector\n    :type point1: numpy.ndarray\n    :param point2: An exposure vector\n    :type point2: numpy.ndarray\n    :param pbm: The PBM\n    :type pbm: numpy.ndarray\n    :return: The value of the objective function\n    :rtype: float\n    \"\"\"", "\n", "exposure", "=", "alpha", "*", "point1", "+", "(", "1", "-", "alpha", ")", "*", "point2", "\n", "return", "scalarization", "*", "(", "-", "nutility", "(", "exposure", ",", "pbm", ",", "relevance_vector", ")", ")", "+", "(", "1", "-", "scalarization", ")", "*", "(", "np", ".", "linalg", ".", "norm", "(", "exposure", "-", "target_exposure", ")", "/", "np", ".", "linalg", ".", "norm", "(", "prp_exposure", "-", "target_exposure", ")", ")", "**", "2", "# expohedron.nunfairness(exposure, fairness) ** 2", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.get_pareto_point_for_scalarization": [[287, 328], ["scipy.optimize.Bounds", "np.arange", "scipy.optimize.minimize", "len", "objective", "objective", "objective", "utils.nutility", "utils.nutility", "len", "np.linalg.norm", "np.linalg.norm", "utils.nutility", "np.linalg.norm", "np.linalg.norm", "np.linalg.norm", "np.linalg.norm"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.nutility", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.nutility", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.nutility"], ["", "def", "get_pareto_point_for_scalarization", "(", "pareto_curve", ":", "list", ",", "target_exposure", ":", "np", ".", "ndarray", ",", "\n", "pbm", ":", "np", ".", "ndarray", ",", "prp_exposure", ",", "alpha", ":", "float", ",", "\n", "fairness", ":", "str", ",", "relevance_vector", ":", "np", ".", "ndarray", ")", "->", "tuple", ":", "\n", "    ", "\"\"\"\n        Given a Pareto front in an expohedron, and a scalarization parameter `alpha` computes the optimum of the scalarized problem\n\n            min \u03b1 (-U) + (1-\u03b1) F\n\n    :param pareto_curve: The pareto curve in the expohedron\n    :type pareto_curve: list\n    :param target_exposure: The target exposure vector\n    :type target_exposure: numpy.ndarray\n    :param expohedron: The expohedron\n    :type expohedron: DBNexpohedron\n    :param alpha: The scalarization parameter\n    :type alpha: float\n    :return: The optimal utility, the optimal unfairness and the optimal exposure\n    :rtype: Tuple[float, float, numpy.ndarray]\n    \"\"\"", "\n", "\n", "objective", "=", "lambda", "exposure", ":", "alpha", "*", "(", "-", "nutility", "(", "exposure", ",", "pbm", ",", "relevance_vector", ")", ")", "+", "(", "1", "-", "alpha", ")", "*", "(", "np", ".", "linalg", ".", "norm", "(", "exposure", "-", "target_exposure", ")", "/", "np", ".", "linalg", ".", "norm", "(", "prp_exposure", "-", "target_exposure", ")", ")", "**", "2", "# expohedron.nunfairness(exposure, fairness) ** 2", "\n", "bounds", "=", "Bounds", "(", "0", ",", "1", ")", "\n", "# Find the line segment on which the optimal exposure lies", "\n", "if", "len", "(", "pareto_curve", ")", "==", "1", ":", "# pathological case", "\n", "        ", "exposure_opt", "=", "pareto_curve", "[", "0", "]", "\n", "return", "nutility", "(", "exposure_opt", ",", "pbm", ")", ",", "(", "np", ".", "linalg", ".", "norm", "(", "exposure_opt", "-", "target_exposure", ")", "/", "np", ".", "linalg", ".", "norm", "(", "prp_exposure", "-", "target_exposure", ")", ")", "**", "2", ",", "exposure_opt", "\n", "", "for", "i", "in", "np", ".", "arange", "(", "0", ",", "len", "(", "pareto_curve", ")", "-", "1", ")", ":", "\n", "        ", "o1", "=", "objective", "(", "pareto_curve", "[", "i", "]", ")", "\n", "o2", "=", "objective", "(", "pareto_curve", "[", "i", "+", "1", "]", ")", "\n", "if", "o2", ">", "o1", ":", "break", "# optimal point is in line segment [i, i+1]", "\n", "# try:", "\n", "#     a = pareto_curve[i]", "\n", "# except UnboundLocalError:", "\n", "#     a = 1", "\n", "", "sol", "=", "minimize", "(", "scalarized_objective_within_pareto_segment", ",", "0", ",", "\n", "(", "alpha", ",", "pareto_curve", "[", "i", "]", ",", "pareto_curve", "[", "i", "+", "1", "]", ",", "target_exposure", ",", "pbm", ",", "relevance_vector", ",", "prp_exposure", ",", "fairness", ")", ",", "\n", "method", "=", "\"Nelder-Mead\"", ",", "bounds", "=", "bounds", ")", "\n", "exposure_opt", "=", "sol", ".", "x", "[", "0", "]", "*", "pareto_curve", "[", "i", "]", "+", "(", "1", "-", "sol", ".", "x", "[", "0", "]", ")", "*", "pareto_curve", "[", "i", "+", "1", "]", "\n", "assert", "objective", "(", "exposure_opt", ")", "==", "sol", ".", "fun", "\n", "return", "nutility", "(", "exposure_opt", ",", "pbm", ",", "relevance_vector", ")", ",", "(", "np", ".", "linalg", ".", "norm", "(", "exposure_opt", "-", "target_exposure", ")", "/", "np", ".", "linalg", ".", "norm", "(", "prp_exposure", "-", "target_exposure", ")", ")", "**", "2", ",", "exposure_opt", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.is_ranking": [[9, 23], ["numpy.all", "len", "len", "str", "numpy.sort", "numpy.arange"], "function", ["None"], ["def", "is_ranking", "(", "ranking", ":", "np", ".", "ndarray", ",", "size", ":", "int", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n        Checks if `ranking` is a ranking, i.e. performs simple asserts to check if `ranking` is a valid ranking\n    :param ranking: a ranking whose formatting is to be checked\n    :type ranking: np.ndarray\n    :param size: The size of the ranking, optional\n    :type size: int\n    \"\"\"", "\n", "if", "size", "is", "not", "None", ":", "\n", "        ", "assert", "len", "(", "ranking", ")", "==", "size", ",", "\"`ranking` must be of size \"", "+", "str", "(", "size", ")", "\n", "", "else", ":", "\n", "        ", "size", "=", "len", "(", "ranking", ")", "\n", "", "assert", "np", ".", "all", "(", "np", ".", "sort", "(", "ranking", ")", "==", "np", ".", "arange", "(", "0", ",", "size", ")", ")", ",", "\"`ranking` is not a permutation of {0,...,n-1}\"", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation": [[25, 35], ["numpy.argsort"], "function", ["None"], ["", "def", "invert_permutation", "(", "permutation", ")", ":", "\n", "    ", "\"\"\"\n    Inverts a permutation: If `permutation[i]==j`, then `invert_permutation(permutation)[j]==i`.\n\n    :param permutation: A permutation represented as an array containing the integers 0 to n\n    :type permutation: numpy.ndarray\n    :return: The inverse permutation\n    :rtype: numpy.ndarray\n    \"\"\"", "\n", "return", "np", ".", "argsort", "(", "permutation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace": [[37, 59], ["scipy.linalg.orth", "len"], "function", ["None"], ["", "def", "project_on_subspace", "(", "point_to_project", ":", "np", ".", "ndarray", ",", "normal_vectors", ":", "np", ".", "ndarray", ")", "->", "np", ".", "array", ":", "\n", "    ", "\"\"\"\n        Given an (m x n)-matrix `A`, this function computes the projection of `point_to_project` onto the linear subspace S = {x in R^n | Ax = 0}.\n\n        The rows of matrix `A` are vectors orthogonal to the subspace\n    :param point_to_project: The point to project on the linear subspace\n    :type point_to_project: numpy.ndarray\n    :param normal_vectors: A matrix whose rows are normal vectors to the subspace\n    :return:\n    \"\"\"", "\n", "n", "=", "normal_vectors", ".", "shape", "[", "1", "]", "\n", "assert", "n", "==", "len", "(", "point_to_project", ")", ",", "\"The normal vectors must have the same dimension as the `point_to_project`\"", "\n", "\n", "# if False:  # Method using span", "\n", "#     # Compute Moore-Penrose pseudo inverse", "\n", "#     Ad = A.T @ np.linalg.inv(A @ A.T)  # `Ad` is the Moore-Penrose pseudo inverse", "\n", "#     D = np.eye(n) - Ad @ A", "\n", "#     P = orth(D)", "\n", "#     return P @ (P.T @ point_to_project)", "\n", "# else:", "\n", "P", "=", "orth", "(", "normal_vectors", ".", "T", ")", "\n", "return", "point_to_project", "-", "P", "@", "(", "P", ".", "T", "@", "point_to_project", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_affine_subspace": [[61, 70], ["utils.project_on_subspace"], "function", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace"], ["", "def", "project_on_affine_subspace", "(", "point_to_project", ":", "np", ".", "ndarray", ",", "normal_vectors", ":", "np", ".", "ndarray", ",", "offset", ":", "np", ".", "ndarray", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "\"\"\"\n        Projects `point_to_project` onto the affine subspace with normal vectors `normal_vectors` and with an offset `offset`\n    :param point_to_project: The point to project\n    :param normal_vectors: A matrix whose rows contain the normal vectors to the subspace\n    :param offset: Any point that is contained by the affine subspace\n    :return: The projection of `point_to_project` onto the affine subspace\n    \"\"\"", "\n", "return", "project_on_subspace", "(", "point_to_project", "-", "offset", ",", "normal_vectors", ")", "+", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.compute_unfairness": [[72, 88], ["numpy.linalg.norm", "len", "len"], "function", ["None"], ["", "def", "compute_unfairness", "(", "exposure_vector", ":", "np", ".", "ndarray", ",", "target", ":", "np", ".", "ndarray", ",", "p_norm", ":", "float", "=", "2", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n        Computes an unfairness value of an exposure vector w.r.t a target exposure vector\n\n    :param exposure_vector: The exposure vector of the documents\n    :type exposure_vector: numpy.ndarray\n    :param target: The vector of target exposures of the documents\n    :type target: numpy.ndarray\n    :param p_norm: The norm with which the unfairness is to be computed\n    :type p_norm: float, optional\n    :return: The unfairness of the exposure vector\n    :rtype: float\n    \"\"\"", "\n", "assert", "1", "<=", "p_norm", ",", "\"`p_norm` must be greater than 1\"", "\n", "assert", "len", "(", "exposure_vector", ")", "==", "len", "(", "target", ")", ",", "\"`exposure_vector` and `target` must have same length\"", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "exposure_vector", "-", "target", ",", "ord", "=", "p_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.nutility": [[90, 92], ["numpy.sort", "numpy.sort"], "function", ["None"], ["", "def", "nutility", "(", "exposure", ",", "pbm", ",", "relevance_vector", ")", "->", "float", ":", "\n", "    ", "return", "exposure", "@", "relevance_vector", "/", "(", "np", ".", "sort", "(", "relevance_vector", ")", "@", "np", ".", "sort", "(", "pbm", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.None.utils.vprint": [[94, 97], ["print"], "function", ["None"], ["", "def", "vprint", "(", "msg", ":", "str", ",", "lvl", ":", "int", "=", "0", ")", ":", "\n", "    ", "if", "lvl", "==", "1", ":", "\n", "        ", "print", "(", "msg", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_pareto.Pareto.test_fairness_endpoint": [[13, 60], ["numpy.array", "numpy.array", "numpy.array", "pareto.fairness_endpoint", "numpy.array", "test_pareto.Pareto.assertTrue", "numpy.array", "numpy.array", "numpy.array", "pareto.fairness_endpoint", "numpy.array", "test_pareto.Pareto.assertTrue", "numpy.array", "numpy.array", "numpy.eye", "pareto.fairness_endpoint", "test_pareto.Pareto.assertTrue", "numpy.array", "numpy.array", "numpy.array", "pareto.fairness_endpoint", "numpy.array", "test_pareto.Pareto.assertTrue", "numpy.random.rand", "numpy.random.rand", "pareto.fairness_endpoint", "test_pareto.Pareto.assertTrue", "numpy.all", "numpy.all", "numpy.ones", "numpy.all", "numpy.all", "numpy.sum", "numpy.all", "numpy.sum", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.fairness_endpoint"], ["    ", "def", "test_fairness_endpoint", "(", "self", ")", ":", "\n", "# Case 1: 3 documents, 2 groups, no duplicate relevance values, endpoint is vertex", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "3", ",", "2", ",", "1", "]", ")", "\n", "tol", "=", "1e-9", "\n", "rho", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.6", ",", "0.9", "]", ")", "\n", "grouping", "=", "np", ".", "array", "(", "[", "[", "1", ",", "1", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "computed_point", "=", "fairness_endpoint", "(", "gamma", ",", "rho", ",", "grouping", ")", "\n", "theoretical_point", "=", "np", ".", "array", "(", "[", "1.", ",", "3.", ",", "2.", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "computed_point", "-", "theoretical_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 2: 4 documents, 2 groups, duplicate relevance values, endpoint is vertex", "\n", "gamma", "=", "np", ".", "array", "(", "[", "4", ",", "3", ",", "2", ",", "1", "]", ")", "\n", "tol", "=", "1e-9", "\n", "rho", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.6", ",", "0.9", ",", "0.9", "]", ")", "\n", "grouping", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "computed_point", "=", "fairness_endpoint", "(", "gamma", ",", "rho", ",", "grouping", ")", "\n", "theoretical_point", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "4", ",", "3", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "computed_point", "-", "theoretical_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 3: 10 documents, 10 groups, duplicate relevance values, endpoint is barycenter", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", ",", "10", "]", ")", "\n", "tol", "=", "1e-9", "\n", "rho", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.6", ",", "0.9", ",", "0.8", ",", "0.1", ",", "0.3", ",", "0.7", ",", "0.2", ",", "0.4", ",", "1", "]", ")", "\n", "grouping", "=", "np", ".", "eye", "(", "10", ")", "\n", "computed_point", "=", "fairness_endpoint", "(", "gamma", ",", "rho", ",", "grouping", ")", "\n", "theoretical_point", "=", "5.5", "*", "np", ".", "ones", "(", "10", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "computed_point", "-", "theoretical_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 4: 4 documents, 2 groups, no duplicate relevance values, endpoint is not vertex", "\n", "gamma", "=", "np", ".", "array", "(", "[", "4", ",", "3", ",", "2", ",", "1", "]", ")", "\n", "tol", "=", "1e-9", "\n", "rho", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.6", ",", "0.8", ",", "0.9", "]", ")", "\n", "grouping", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "computed_point", "=", "fairness_endpoint", "(", "gamma", ",", "rho", ",", "grouping", ")", "\n", "theoretical_point", "=", "np", ".", "array", "(", "[", "1.5", ",", "1.5", ",", "3.5", ",", "3.5", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "computed_point", "-", "theoretical_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 4: Meritocratic individual fairness", "\n", "ndoc", "=", "10", "\n", "gamma", "=", "np", ".", "random", ".", "rand", "(", "ndoc", ")", "\n", "rho", "=", "np", ".", "random", ".", "rand", "(", "ndoc", ")", "\n", "computed_point", "=", "fairness_endpoint", "(", "gamma", ",", "rho", ",", "fairness", "=", "\"meritocratic\"", ",", "grouping", "=", "None", ")", "\n", "theoretical_point", "=", "rho", "/", "np", ".", "sum", "(", "rho", ")", "*", "np", ".", "sum", "(", "gamma", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "computed_point", "-", "theoretical_point", ")", "<", "tol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_pareto.Pareto.test_pareto_curve_pbm": [[61, 79], ["numpy.array", "numpy.array", "numpy.array", "pareto.pareto_curve_pbm", "test_pareto.Pareto.assertTrue", "test_pareto.Pareto.assertTrue", "numpy.array", "numpy.array", "pareto.pareto_curve_pbm", "numpy.array", "numpy.array", "numpy.all", "numpy.all", "numpy.array", "numpy.abs", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.pareto.pareto_curve_pbm", "home.repos.pwc.inspect_result.naver_expohedron.None.pareto.pareto_curve_pbm"], ["", "def", "test_pareto_curve_pbm", "(", "self", ")", ":", "\n", "# Case 1", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "4", ",", "3", ",", "2", ",", "1", "]", ")", "\n", "tol", "=", "1e-9", "\n", "rho", "=", "np", ".", "array", "(", "[", "0.5", ",", "0.6", ",", "0.8", ",", "0.9", "]", ")", "\n", "grouping", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", ",", "0", ",", "1", "]", ",", "\n", "[", "1", ",", "0", ",", "1", ",", "0", "]", "]", ")", "\n", "computed_pareto_curve", "=", "pareto_curve_pbm", "(", "gamma", ",", "rho", ",", "fairness", "=", "\"demographic\"", ",", "grouping", "=", "grouping", ")", "\n", "theoretical_pareto_curve", "=", "[", "np", ".", "array", "(", "[", "1.5", ",", "1.5", ",", "3.5", ",", "3.5", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "]", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "theoretical_pareto_curve", "[", "0", "]", "-", "computed_pareto_curve", "[", "0", "]", ")", "<", "tol", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "theoretical_pareto_curve", "[", "1", "]", "-", "computed_pareto_curve", "[", "1", "]", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 2: Meritocratic individual fairness, 3 documents, regular hexagon", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "tol", "=", "1e-9", "\n", "rho", "=", "np", ".", "array", "(", "[", "2", ",", "1.5", ",", "2.5", "]", ")", "\n", "computed_pareto_curve", "=", "pareto_curve_pbm", "(", "gamma", ",", "rho", ",", "fairness", "=", "\"meritocratic\"", ",", "grouping", "=", "None", ")", "\n", "theoretical_pareto_curve", "=", "[", "np", ".", "array", "(", "[", "2", ",", "1.5", ",", "2.5", "]", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_utils.Utils.test_invert_permutation": [[12, 16], ["np.array", "invert_permutation", "test_utils.Utils.assertTrue", "np.all", "np.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.invert_permutation"], ["    ", "def", "test_invert_permutation", "(", "self", ")", ":", "\n", "        ", "pi", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "5", ",", "3", ",", "2", ",", "4", "]", ")", "\n", "inv_pi", "=", "invert_permutation", "(", "pi", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "inv_pi", "==", "np", ".", "array", "(", "[", "1", ",", "0", ",", "4", ",", "3", ",", "5", ",", "2", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_utils.Utils.test_project_on_subspace": [[17, 24], ["np.array", "np.random.rand", "project_on_subspace", "test_utils.Utils.assertLess", "np.abs", "np.sum"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace"], ["", "def", "test_project_on_subspace", "(", "self", ")", ":", "\n", "        ", "G", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "1", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", "]", "]", ")", "\n", "z", "=", "np", ".", "random", ".", "rand", "(", "6", ")", "\n", "y", "=", "project_on_subspace", "(", "z", ",", "G", ")", "\n", "self", ".", "assertLess", "(", "np", ".", "abs", "(", "np", ".", "sum", "(", "G", "@", "y", ")", ")", ",", "1e-12", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_majorized": [[14, 24], ["numpy.array", "test_expohedron.Expohedron.assertTrue", "test_expohedron.Expohedron.assertTrue", "test_expohedron.Expohedron.assertFalse", "test_expohedron.Expohedron.assertFalse", "majorized", "majorized", "majorized", "majorized", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized"], ["    ", "def", "test_majorized", "(", "self", ")", ":", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", "\n", "# Case 1: Properly majorized", "\n", "self", ".", "assertTrue", "(", "majorized", "(", "np", ".", "array", "(", "[", "4", ",", "4", ",", "2", ",", "2", ",", "3", "]", ")", ",", "gamma", ")", ")", "\n", "# Case 2: Majorized at the limit", "\n", "self", ".", "assertTrue", "(", "majorized", "(", "np", ".", "array", "(", "[", "5", ",", "4", ",", "3", ",", "2", ",", "1", "]", ")", ",", "gamma", ")", ")", "\n", "# Case 3: Not majorized but cumsum equal", "\n", "self", ".", "assertFalse", "(", "majorized", "(", "np", ".", "array", "(", "[", "5", ",", "5", ",", "1", ",", "1", ",", "3", "]", ")", ",", "gamma", ")", ")", "\n", "# Case 4: Not majorized", "\n", "self", ".", "assertFalse", "(", "majorized", "(", "np", ".", "array", "(", "[", "5", ",", "1", ",", "2", ",", "2", ",", "1", "]", ")", ",", "gamma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_error_correction": [[25, 49], ["numpy.array", "len", "numpy.array", "Face", "Face.contains", "error_correction", "test_expohedron.Expohedron.assertTrue", "numpy.array", "len", "numpy.array", "Face", "Face.contains", "error_correction", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "numpy.all", "numpy.array", "numpy.array", "numpy.all", "numpy.mean", "numpy.mean", "numpy.ones", "numpy.ones", "numpy.mean", "numpy.abs", "numpy.ones", "numpy.ones", "numpy.mean", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.contains", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.error_correction", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.contains", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.error_correction"], ["", "def", "test_error_correction", "(", "self", ")", ":", "\n", "        ", "tol", "=", "1e-15", "\n", "\n", "# Case 1: `point` is a vertex", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "point", "=", "np", ".", "array", "(", "[", "2", ",", "1", ",", "4", ",", "3", "]", ")", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "1", ",", "0", ",", "3", ",", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "assert", "face", ".", "contains", "(", "point", ")", "\n", "noise", "=", "1e-9", "\n", "noisy_point", "=", "(", "1", "-", "noise", ")", "*", "point", "+", "noise", "*", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "gamma", ")", "\n", "corrected_point", "=", "error_correction", "(", "noisy_point", ",", "point", "-", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "gamma", ")", ",", "face", ",", "tol", "=", "tol", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "corrected_point", "-", "point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 2:", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "point", "=", "np", ".", "array", "(", "[", "2", ",", "1", ",", "4", ",", "3", "]", ")", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "1", ",", "0", ",", "3", ",", "2", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", ")", "\n", "assert", "face", ".", "contains", "(", "point", ")", "\n", "noise", "=", "1e-9", "\n", "noisy_point", "=", "(", "1", "-", "noise", ")", "*", "point", "+", "noise", "*", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "gamma", ")", "\n", "corrected_point", "=", "error_correction", "(", "noisy_point", ",", "point", "-", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "gamma", ")", ",", "face", ",", "tol", "=", "tol", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "corrected_point", "-", "point", ")", "<", "tol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_Face": [[50, 57], ["numpy.array", "Face", "test_expohedron.Expohedron.assertTrue", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "Face.contains", "Face.contains", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.contains", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.Face.contains"], ["", "def", "test_Face", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test the function of the `Face` object\"\"\"", "\n", "# Case 1: `contains`", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "3", "]", ")", ")", "\n", "self", ".", "assertTrue", "(", "face", ".", "contains", "(", "np", ".", "array", "(", "[", "1.1", ",", "1.9", ",", "3.6", ",", "3.4", "]", ")", ")", ")", "\n", "self", ".", "assertTrue", "(", "face", ".", "contains", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "4", ",", "3", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_identify_face": [[58, 80], ["numpy.array", "numpy.array", "identify_face", "test_expohedron.Expohedron.assertEqual", "test_expohedron.Expohedron.assertTrue", "test_expohedron.Expohedron.assertTrue", "numpy.array", "identify_face", "test_expohedron.Expohedron.assertEqual", "test_expohedron.Expohedron.assertTrue", "test_expohedron.Expohedron.assertTrue", "numpy.array", "identify_face", "test_expohedron.Expohedron.assertEqual", "test_expohedron.Expohedron.assertTrue", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.all", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face"], ["", "def", "test_identify_face", "(", "self", ")", ":", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "\n", "# Case 1: Edge", "\n", "point", "=", "np", ".", "array", "(", "[", "2.5", ",", "2.5", ",", "1", "]", ")", "\n", "face", "=", "identify_face", "(", "gamma", ",", "point", ")", "\n", "self", ".", "assertEqual", "(", "face", ".", "dim", ",", "1", ")", "# Check dimension", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "face", ".", "zone", "==", "np", ".", "array", "(", "[", "2", ",", "0", ",", "1", "]", ")", ")", "or", "np", ".", "all", "(", "face", ".", "zone", "==", "np", ".", "array", "(", "[", "2", ",", "1", ",", "0", "]", ")", ")", ")", "# Check zone", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "face", ".", "splits", "==", "np", ".", "array", "(", "[", "0", ",", "2", "]", ")", ")", ")", "# Check splits", "\n", "\n", "# Case 2: Vertex", "\n", "point", "=", "np", ".", "array", "(", "[", "2", ",", "3", ",", "1", "]", ")", "\n", "face", "=", "identify_face", "(", "gamma", ",", "point", ")", "\n", "self", ".", "assertEqual", "(", "face", ".", "dim", ",", "0", ")", "# Check dimension", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "face", ".", "zone", "==", "np", ".", "array", "(", "[", "2", ",", "0", ",", "1", "]", ")", ")", ")", "# Check zone", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "face", ".", "splits", "==", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ")", ")", "# Check splits", "\n", "\n", "# Case 2: Facet", "\n", "point", "=", "np", ".", "array", "(", "[", "1.5", ",", "2", ",", "2.5", "]", ")", "\n", "face", "=", "identify_face", "(", "gamma", ",", "point", ")", "\n", "self", ".", "assertEqual", "(", "face", ".", "dim", ",", "2", ")", "# Check dimension", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "face", ".", "splits", "==", "np", ".", "array", "(", "[", "2", "]", ")", ")", ")", "# Check splits", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_find_face_intersection_same_ordering": [[81, 109], ["numpy.array", "numpy.array", "numpy.array", "find_face_intersection_same_ordering", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "find_face_intersection_same_ordering", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "find_face_intersection_same_ordering", "test_expohedron.Expohedron.assertTrue", "numpy.array", "find_face_intersection_same_ordering", "test_expohedron.Expohedron.assertTrue", "numpy.all", "numpy.all", "numpy.all", "numpy.arange", "numpy.mean", "numpy.ones", "numpy.all", "numpy.abs", "numpy.abs", "numpy.array", "numpy.abs", "numpy.argsort", "numpy.abs", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_same_ordering", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_same_ordering", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_same_ordering", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection_same_ordering"], ["", "def", "test_find_face_intersection_same_ordering", "(", "self", ")", ":", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "tol", "=", "1e-12", "\n", "\n", "# Case 1: From barycenter", "\n", "point", "=", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "-", "1.5", ",", "0.5", ",", "1", "]", ")", "\n", "u", "=", "find_face_intersection_same_ordering", "(", "gamma", ",", "point", ",", "direction", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "1", ",", "2", "+", "1", "/", "3", ",", "2", "+", "2", "/", "3", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 2: Intersection within face", "\n", "point", "=", "np", ".", "array", "(", "[", "1.6", ",", "1.4", ",", "3", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "-", "1", ",", "0", "]", ")", "\n", "u", "=", "find_face_intersection_same_ordering", "(", "gamma", ",", "point", ",", "direction", ",", "override_order_constraint", "=", "True", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "2.", ",", "1.", ",", "3.", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 2: Intersection within face, specified zone", "\n", "point", "=", "np", ".", "array", "(", "[", "1.5", ",", "1.5", ",", "3", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "-", "1", ",", "0", "]", ")", "\n", "u", "=", "find_face_intersection_same_ordering", "(", "gamma", ",", "point", ",", "direction", ",", "override_order_constraint", "=", "True", ",", "zone", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "2", "]", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "2.", ",", "1.", ",", "3.", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 4: 10 dimensions", "\n", "gamma", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "+", "1", "\n", "point", "=", "np", ".", "mean", "(", "gamma", ")", "*", "np", ".", "ones", "(", "10", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "-", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "u", "=", "find_face_intersection_same_ordering", "(", "gamma", ",", "point", ",", "direction", ",", "zone", "=", "np", ".", "argsort", "(", "direction", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "10", ",", "1", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_find_face_intersection": [[110, 144], ["numpy.array", "numpy.array", "numpy.array", "find_face_intersection", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "find_face_intersection", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "find_face_intersection", "test_expohedron.Expohedron.assertTrue", "numpy.array", "find_face_intersection", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "numpy.array", "test_expohedron.Expohedron.assertRaises", "numpy.all", "numpy.all", "numpy.all", "numpy.arange", "numpy.mean", "numpy.ones", "numpy.all", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "find_face_intersection", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection"], ["", "def", "test_find_face_intersection", "(", "self", ")", ":", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "tol", "=", "1e-12", "\n", "\n", "# Case 1: From barycenter", "\n", "point", "=", "np", ".", "array", "(", "[", "2", ",", "2", ",", "2", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "-", "1.5", ",", "0.5", ",", "1", "]", ")", "\n", "u", "=", "find_face_intersection", "(", "gamma", ",", "point", ",", "direction", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "1", ",", "2", "+", "1", "/", "3", ",", "2", "+", "2", "/", "3", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 2: Intersection not in same zone as starting point", "\n", "point", "=", "np", ".", "array", "(", "[", "1.5", ",", "2", ",", "2.5", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "-", "1", "]", ")", "\n", "u", "=", "find_face_intersection", "(", "gamma", ",", "point", ",", "direction", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "3.", ",", "2.", ",", "1.", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 3: Intersection within face", "\n", "point", "=", "np", ".", "array", "(", "[", "1.6", ",", "1.4", ",", "3", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "-", "1", ",", "0", "]", ")", "\n", "u", "=", "find_face_intersection", "(", "gamma", ",", "point", ",", "direction", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "2.", ",", "1.", ",", "3.", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 4: 10 dimensions", "\n", "gamma", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "+", "1", "\n", "point", "=", "np", ".", "mean", "(", "gamma", ")", "*", "np", ".", "ones", "(", "10", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "-", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "u", "=", "find_face_intersection", "(", "gamma", ",", "point", ",", "direction", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "u", "-", "np", ".", "array", "(", "[", "10", ",", "1", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", ",", "5.5", "]", ")", "<", "tol", ")", ")", ")", "\n", "\n", "# Case 5: Inadmissible direction", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "point", "=", "np", ".", "array", "(", "[", "1.5", ",", "2", ",", "2.5", "]", ")", "\n", "direction", "=", "np", ".", "array", "(", "[", "1", ",", "1", ",", "-", "1", "]", ")", "\n", "self", ".", "assertRaises", "(", "AssertionError", ",", "lambda", ":", "find_face_intersection", "(", "gamma", ",", "point", ",", "direction", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_find_face_subspace": [[145, 185], ["numpy.array", "Face", "find_face_subspace", "test_expohedron.Expohedron.assertTrue", "Face", "find_face_subspace", "test_expohedron.Expohedron.assertTrue", "Face", "find_face_subspace", "test_expohedron.Expohedron.assertEqual", "numpy.arange", "Face", "find_face_subspace", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.random.seed", "numpy.random.rand", "Face", "find_face_subspace", "test_expohedron.Expohedron.assertEqual", "numpy.array", "test_expohedron.Expohedron.assertTrue", "project_on_subspace", "numpy.array", "numpy.ones", "numpy.linalg.norm", "numpy.all", "numpy.array", "numpy.array", "numpy.all", "numpy.array", "numpy.array", "numpy.linalg.matrix_rank", "numpy.arange", "numpy.array", "numpy.all", "numpy.log", "numpy.array", "numpy.array", "numpy.linalg.matrix_rank", "numpy.all", "numpy.array", "numpy.ones", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.arange", "numpy.abs", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_subspace", "home.repos.pwc.inspect_result.naver_expohedron.None.utils.project_on_subspace"], ["", "def", "test_find_face_subspace", "(", "self", ")", ":", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "tol", "=", "1e-12", "\n", "\n", "# Case 1: Facet", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ",", "splits", "=", "np", ".", "array", "(", "[", "2", "]", ")", ")", "\n", "face_orth", "=", "find_face_subspace", "(", "face", ")", "\n", "A", "=", "np", ".", "ones", "(", "3", ")", "/", "np", ".", "linalg", ".", "norm", "(", "np", ".", "ones", "(", "3", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "face_orth", "-", "A", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 2: Edge", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "0", ",", "2", ",", "1", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "2", "]", ")", ")", "\n", "face_orth", "=", "find_face_subspace", "(", "face", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "face_orth", ".", "T", "@", "(", "gamma", "[", "np", ".", "array", "(", "[", "0", ",", "2", ",", "1", "]", ")", "]", "-", "gamma", "[", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", "]", ")", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 3: Vertex", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "0", ",", "2", ",", "1", "]", ")", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ")", "\n", "face_orth", "=", "find_face_subspace", "(", "face", ")", "\n", "self", ".", "assertEqual", "(", "np", ".", "linalg", ".", "matrix_rank", "(", "face_orth", ")", ",", "3", ")", "\n", "\n", "# Case 4: 10 documents, 3 splits", "\n", "gamma", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "+", "1", "\n", "order", "=", "np", ".", "arange", "(", "0", ",", "10", ")", "\n", "face", "=", "Face", "(", "gamma", ",", "order", ",", "np", ".", "array", "(", "[", "1", ",", "7", ",", "9", "]", ")", ")", "# `gamma` is in `face`", "\n", "face_orth", "=", "find_face_subspace", "(", "face", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "face_orth", ".", "T", "@", "(", "np", ".", "array", "(", "[", "1.1", ",", "1.9", ",", "3", ",", "4", ",", "5", ",", "5", ",", "8", ",", "8", ",", "9.5", ",", "9.5", "]", ")", "-", "gamma", ")", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 5: Check persistent bug", "\n", "point", "=", "np", ".", "array", "(", "[", "0.43082352", ",", "0.86915565", ",", "0.42050336", ",", "0.90150568", ",", "0.56522123", ",", "0.64855314", ",", "0.75271679", ",", "0.73036695", ",", "0.58062715", ",", "0.65549705", "]", ")", "\n", "n_doc", "=", "10", "\n", "gamma", "=", "1", "/", "np", ".", "log", "(", "np", ".", "arange", "(", "0", ",", "n_doc", ")", "+", "2", ")", "# The DCG exposures", "\n", "np", ".", "random", ".", "seed", "(", "5", ")", "\n", "rho", "=", "np", ".", "random", ".", "rand", "(", "n_doc", ")", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "2", ",", "0", ",", "4", ",", "8", ",", "5", ",", "9", ",", "7", ",", "6", ",", "1", ",", "3", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "9", "]", ")", ")", "\n", "face_orth", "=", "find_face_subspace", "(", "face", ")", "\n", "self", ".", "assertEqual", "(", "np", ".", "linalg", ".", "matrix_rank", "(", "face_orth", ")", ",", "2", ")", "\n", "direction_1", "=", "np", ".", "array", "(", "[", "-", "1", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "face_orth", ".", "T", "@", "direction_1", ")", "<", "tol", ")", ")", "\n", "\n", "direction", "=", "project_on_subspace", "(", "rho", ",", "face_orth", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_caratheodory_decomposition_pbm_gls": [[186, 222], ["numpy.array", "numpy.array", "test_expohedron.Expohedron.assertTrue", "caratheodory_decomposition_pbm_gls", "test_expohedron.Expohedron.assertTrue", "numpy.array", "test_expohedron.Expohedron.assertTrue", "caratheodory_decomposition_pbm_gls", "test_expohedron.Expohedron.assertTrue", "numpy.array", "test_expohedron.Expohedron.assertTrue", "caratheodory_decomposition_pbm_gls", "test_expohedron.Expohedron.assertTrue", "len", "numpy.array", "find_face_intersection", "caratheodory_decomposition_pbm_gls", "test_expohedron.Expohedron.assertTrue", "majorized", "numpy.all", "majorized", "numpy.all", "majorized", "numpy.all", "numpy.log", "numpy.sum", "numpy.ones", "numpy.mean", "numpy.all", "numpy.sum", "identify_face", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.arange", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.caratheodory_decomposition_pbm_gls", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.caratheodory_decomposition_pbm_gls", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.caratheodory_decomposition_pbm_gls", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.find_face_intersection", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.caratheodory_decomposition_pbm_gls", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.majorized", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.identify_face"], ["", "def", "test_caratheodory_decomposition_pbm_gls", "(", "self", ")", ":", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", ")", "\n", "tol", "=", "1e-9", "\n", "\n", "# Case 1: Arbitrary point", "\n", "point", "=", "np", ".", "array", "(", "[", "3.", ",", "3.", ",", "2.", ",", "4.", ",", "3.", "]", ")", "\n", "self", ".", "assertTrue", "(", "majorized", "(", "point", ",", "gamma", ")", ")", "\n", "coefficients", ",", "vertices", "=", "caratheodory_decomposition_pbm_gls", "(", "gamma", ",", "point", ")", "\n", "reconstructed_point", "=", "vertices", "@", "coefficients", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "point", "-", "reconstructed_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 2: Barycenter", "\n", "point", "=", "np", ".", "array", "(", "[", "3.", ",", "3.", ",", "3.", ",", "3.", ",", "3.", "]", ")", "\n", "self", ".", "assertTrue", "(", "majorized", "(", "point", ",", "gamma", ")", ")", "\n", "coefficients", ",", "vertices", "=", "caratheodory_decomposition_pbm_gls", "(", "gamma", ",", "point", ")", "\n", "reconstructed_point", "=", "vertices", "@", "coefficients", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "point", "-", "reconstructed_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 3: Point in face", "\n", "point", "=", "np", ".", "array", "(", "[", "1.", ",", "2.5", ",", "2.5", ",", "4.5", ",", "4.5", "]", ")", "\n", "self", ".", "assertTrue", "(", "majorized", "(", "point", ",", "gamma", ")", ")", "\n", "coefficients", ",", "vertices", "=", "caratheodory_decomposition_pbm_gls", "(", "gamma", ",", "point", ")", "\n", "reconstructed_point", "=", "vertices", "@", "coefficients", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "point", "-", "reconstructed_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 4: DCG expohedron", "\n", "gamma", "=", "1", "/", "np", ".", "log", "(", "np", ".", "arange", "(", "0", ",", "3", ")", "+", "2", ")", "\n", "n", "=", "len", "(", "gamma", ")", "\n", "point", "=", "np", ".", "array", "(", "[", "0.3", ",", "0.5", ",", "0.55", "]", ")", "\n", "point", "=", "point", "/", "np", ".", "sum", "(", "point", ")", "*", "np", ".", "sum", "(", "gamma", ")", "\n", "barycenter", "=", "np", ".", "ones", "(", "n", ")", "*", "np", ".", "mean", "(", "gamma", ")", "\n", "point", "=", "find_face_intersection", "(", "gamma", ",", "barycenter", ",", "point", "-", "barycenter", ")", "\n", "assert", "identify_face", "(", "gamma", ",", "point", ")", ".", "dim", "<", "n", "-", "1", ",", "\"The intersection must lie on a face of the expohedron that is not the expohedron itself\"", "\n", "coefficients", ",", "vertices", "=", "caratheodory_decomposition_pbm_gls", "(", "gamma", ",", "point", ")", "\n", "reconstructed_point", "=", "vertices", "@", "coefficients", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "point", "-", "reconstructed_point", ")", "<", "tol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_post_correction": [[223, 239], ["numpy.array", "Face", "numpy.array", "post_correction", "test_expohedron.Expohedron.assertTrue", "numpy.array", "Face", "numpy.array", "post_correction", "test_expohedron.Expohedron.assertTrue", "numpy.array", "numpy.array", "numpy.all", "numpy.array", "numpy.array", "numpy.all", "numpy.abs", "numpy.array", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction", "home.repos.pwc.inspect_result.naver_expohedron.None.expohedron.post_correction"], ["", "def", "test_post_correction", "(", "self", ")", ":", "\n", "# Case 1: 4 documents", "\n", "        ", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "tol", "=", "1e-15", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "2", "]", ")", ")", "\n", "point", "=", "np", ".", "array", "(", "[", "2", ",", "1", ",", "3", "]", ")", "\n", "post_point", "=", "post_correction", "(", "face", ",", "point", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "point", "-", "post_point", ")", "<", "tol", ")", ")", "\n", "\n", "# Case 2: 4 documents", "\n", "gamma", "=", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "4", "]", ")", "\n", "tol", "=", "1e-15", "\n", "face", "=", "Face", "(", "gamma", ",", "np", ".", "array", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", ",", "np", ".", "array", "(", "[", "1", ",", "3", "]", ")", ")", "\n", "point", "=", "np", ".", "array", "(", "[", "1.1", ",", "1.9", ",", "3.6", ",", "3.4", "]", ")", "\n", "post_point", "=", "post_correction", "(", "face", ",", "point", "+", "0.01", "*", "np", ".", "array", "(", "[", "0.1", ",", "0.1", ",", "0.2", ",", "0.2", "]", ")", ")", "\n", "self", ".", "assertTrue", "(", "np", ".", "all", "(", "np", ".", "abs", "(", "point", "-", "post_point", ")", "<", "tol", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_expohedron.Expohedron.test_project_on_face_subspace": [[240, 244], ["None"], "methods", ["None"], ["", "def", "test_project_on_face_subspace", "(", "self", ")", ":", "\n", "# Case 1", "\n", "# todo", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.naver_expohedron.tests.test_billiard.Pareto.test_billiard": [[10, 22], ["billiard_word", "test_billiard.Pareto.assertTrue", "billiard_word", "test_billiard.Pareto.assertTrue", "billiard_word", "test_billiard.Pareto.assertTrue", "billiard_word", "test_billiard.Pareto.assertTrue", "next", "next", "next", "next", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.naver_expohedron.None.billiard.billiard_word", "home.repos.pwc.inspect_result.naver_expohedron.None.billiard.billiard_word", "home.repos.pwc.inspect_result.naver_expohedron.None.billiard.billiard_word", "home.repos.pwc.inspect_result.naver_expohedron.None.billiard.billiard_word"], ["    ", "def", "test_billiard", "(", "self", ")", ":", "\n", "        ", "gen", "=", "billiard_word", "(", "[", "2", "/", "5", ",", "3", "/", "5", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "next", "(", "gen", ")", "for", "i", "in", "range", "(", "10", ")", "]", "==", "[", "0", ",", "1", ",", "1", ",", "0", ",", "1", "]", "*", "2", ")", "\n", "\n", "gen", "=", "billiard_word", "(", "[", "3", "/", "5", ",", "2", "/", "5", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "next", "(", "gen", ")", "for", "i", "in", "range", "(", "10", ")", "]", "==", "[", "0", ",", "1", ",", "0", ",", "1", ",", "0", "]", "*", "2", ")", "\n", "\n", "gen", "=", "billiard_word", "(", "[", "1", "/", "3", ",", "1", "/", "3", ",", "1", "/", "3", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "next", "(", "gen", ")", "for", "i", "in", "range", "(", "30", ")", "]", "==", "[", "0", ",", "1", ",", "2", "]", "*", "10", ")", "\n", "\n", "gen", "=", "billiard_word", "(", "[", "3", "/", "5", ",", "1", "/", "10", ",", "3", "/", "10", "]", ")", "\n", "self", ".", "assertTrue", "(", "[", "next", "(", "gen", ")", "for", "i", "in", "range", "(", "30", ")", "]", "==", "[", "0", ",", "1", ",", "2", ",", "0", ",", "0", ",", "2", ",", "0", ",", "0", ",", "2", ",", "0", "]", "*", "3", ")", "\n", "\n"]]}