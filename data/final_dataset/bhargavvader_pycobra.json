{"home.repos.pwc.inspect_result.bhargavvader_pycobra.docs.plot_voronoi_clustering.plot_cluster_voronoi": [[51, 75], ["numpy.hstack", "scipy.spatial.Voronoi", "pycobra.visualisation.voronoi_finite_polygons_2d", "matplotlib.subplots", "ax.scatter", "ax.axis", "matplotlib.xlim", "matplotlib.ylim", "ax.plot", "ax.fill", "numpy.reshape", "numpy.reshape", "zip", "len", "len"], "function", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.voronoi_finite_polygons_2d"], ["def", "plot_cluster_voronoi", "(", "data", ",", "algo", ")", ":", "\n", "# passing input space to set up voronoi regions.", "\n", "    ", "points", "=", "np", ".", "hstack", "(", "(", "np", ".", "reshape", "(", "data", "[", ":", ",", "0", "]", ",", "(", "len", "(", "data", "[", ":", ",", "0", "]", ")", ",", "1", ")", ")", ",", "np", ".", "reshape", "(", "data", "[", ":", ",", "1", "]", ",", "(", "len", "(", "data", "[", ":", ",", "1", "]", ")", ",", "1", ")", ")", ")", ")", "\n", "vor", "=", "Voronoi", "(", "points", ")", "\n", "# use helper Voronoi", "\n", "regions", ",", "vertices", "=", "voronoi_finite_polygons_2d", "(", "vor", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plot", "=", "ax", ".", "scatter", "(", "[", "]", ",", "[", "]", ")", "\n", "indice", "=", "0", "\n", "for", "region", "in", "regions", ":", "\n", "        ", "ax", ".", "plot", "(", "data", "[", ":", ",", "0", "]", "[", "indice", "]", ",", "data", "[", ":", ",", "1", "]", "[", "indice", "]", ",", "'ko'", ")", "\n", "polygon", "=", "vertices", "[", "region", "]", "\n", "# if it isn't gradient based we just color red or blue depending on whether that point uses the machine in question", "\n", "color", "=", "algo", ".", "labels_", "[", "indice", "]", "\n", "# we assume only two ", "\n", "if", "color", "==", "0", ":", "\n", "            ", "color", "=", "'r'", "\n", "", "else", ":", "\n", "            ", "color", "=", "'b'", "\n", "", "ax", ".", "fill", "(", "*", "zip", "(", "*", "polygon", ")", ",", "alpha", "=", "0.4", ",", "color", "=", "color", ",", "label", "=", "\"\"", ")", "\n", "indice", "+=", "1", "\n", "", "ax", ".", "axis", "(", "'equal'", ")", "\n", "plt", ".", "xlim", "(", "vor", ".", "min_bound", "[", "0", "]", "-", "0.1", ",", "vor", ".", "max_bound", "[", "0", "]", "+", "0.1", ")", "\n", "plt", ".", "ylim", "(", "vor", ".", "min_bound", "[", "1", "]", "-", "0.1", ",", "vor", ".", "max_bound", "[", "1", "]", "+", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.setUp": [[18, 48], ["numpy.random.RandomState", "numpy.random.RandomState.uniform().reshape", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.visualisation.Visualisation", "test_indices.TestVisualisation.cobra_vis.indice_info", "pycobra.ewa.Ewa", "pycobra.ewa.Ewa.fit", "pycobra.visualisation.Visualisation", "numpy.exp", "numpy.random.RandomState.uniform", "numpy.power", "numpy.power"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.indice_info", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# setting up our random data-set", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "\n", "# D1 = train machines; D2 = create COBRA; D3 = calibrate epsilon, alpha; D4 = testing", "\n", "n_features", "=", "20", "\n", "D1", ",", "D2", ",", "D3", ",", "D4", "=", "200", ",", "200", ",", "200", ",", "200", "\n", "D", "=", "D1", "+", "D2", "+", "D3", "+", "D4", "\n", "X", "=", "rng", ".", "uniform", "(", "-", "1", ",", "1", ",", "D", "*", "n_features", ")", ".", "reshape", "(", "D", ",", "n_features", ")", "\n", "Y", "=", "np", ".", "power", "(", "X", "[", ":", ",", "1", "]", ",", "2", ")", "+", "np", ".", "power", "(", "X", "[", ":", ",", "3", "]", ",", "3", ")", "+", "np", ".", "exp", "(", "X", "[", ":", ",", "10", "]", ")", "\n", "\n", "# training data-set", "\n", "X_train", "=", "X", "[", ":", "D1", "+", "D2", "]", "\n", "X_test", "=", "X", "[", "D1", "+", "D2", "+", "D3", ":", "D1", "+", "D2", "+", "D3", "+", "D4", "]", "\n", "# for testing", "\n", "Y_train", "=", "Y", "[", ":", "D1", "+", "D2", "]", "\n", "Y_test", "=", "Y", "[", "D1", "+", "D2", "+", "D3", ":", "D1", "+", "D2", "+", "D3", "+", "D4", "]", "\n", "\n", "cobra", "=", "Cobra", "(", "random_state", "=", "0", ",", "epsilon", "=", "0.5", ")", "\n", "cobra", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "self", ".", "test_data", "=", "X_test", "\n", "self", ".", "test_response", "=", "Y_test", "\n", "self", ".", "cobra", "=", "cobra", "\n", "self", ".", "cobra_vis", "=", "Visualisation", "(", "self", ".", "cobra", ",", "self", ".", "test_data", "[", "0", ":", "4", "]", ",", "self", ".", "test_response", "[", "0", ":", "4", "]", ",", "random_state", "=", "0", ")", "\n", "self", ".", "indices", ",", "self", ".", "mse", "=", "self", ".", "cobra_vis", ".", "indice_info", "(", "self", ".", "test_data", "[", "0", ":", "4", "]", ",", "self", ".", "test_response", "[", "0", ":", "4", "]", ",", "epsilon", "=", "self", ".", "cobra", ".", "epsilon", ")", "\n", "\n", "ewa", "=", "Ewa", "(", "random_state", "=", "0", ")", "\n", "ewa", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "self", ".", "ewa", "=", "ewa", "\n", "self", ".", "ewa_vis", "=", "Visualisation", "(", "self", ".", "ewa", ",", "self", ".", "test_data", "[", "0", ":", "4", "]", ",", "self", ".", "test_response", "[", "0", ":", "4", "]", ",", "random_state", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.test_indice_info": [[49, 54], ["test_indices.TestVisualisation.assertAlmostEqual"], "methods", ["None"], ["", "def", "test_indice_info", "(", "self", ")", ":", "\n", "# expected_indices, expected_mse = ('svm','lasso', 'ridge'), 0.32062807318499864", "\n", "# self.assertEqual(sorted(expected_indices), sorted(self.indices[0]))", "\n", "        ", "expected_mse", "=", "0.32062807318499864", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "self", ".", "mse", "[", "0", "]", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.test_voronoi": [[55, 66], ["test_indices.TestVisualisation.cobra_vis.voronoi", "test_indices.TestVisualisation.assertAlmostEqual", "test_indices.TestVisualisation.assertAlmostEqual", "test_indices.TestVisualisation.cobra_vis.voronoi", "test_indices.TestVisualisation.assertAlmostEqual", "test_indices.TestVisualisation.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.voronoi", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.voronoi"], ["", "def", "test_voronoi", "(", "self", ")", ":", "\n", "\n", "        ", "vor", "=", "self", ".", "cobra_vis", ".", "voronoi", "(", "indice_info", "=", "self", ".", "indices", ")", "\n", "min_bound", ",", "max_bound", "=", "-", "0.19956180892237763", ",", "0.9046027692022134", "\n", "self", ".", "assertAlmostEqual", "(", "min_bound", ",", "vor", ".", "min_bound", "[", "0", "]", ")", "\n", "self", ".", "assertAlmostEqual", "(", "max_bound", ",", "vor", ".", "max_bound", "[", "0", "]", ")", "\n", "\n", "vor_", "=", "self", ".", "cobra_vis", ".", "voronoi", "(", "indice_info", "=", "self", ".", "indices", ",", "single", "=", "True", ")", "\n", "min_bound", ",", "max_bound", "=", "-", "0.19956180892237763", ",", "0.9046027692022134", "\n", "self", ".", "assertAlmostEqual", "(", "min_bound", ",", "vor_", ".", "min_bound", "[", "0", "]", ")", "\n", "self", ".", "assertAlmostEqual", "(", "max_bound", ",", "vor_", ".", "max_bound", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.test_boxplot": [[67, 76], ["test_indices.TestVisualisation.cobra_vis.boxplot", "test_indices.TestVisualisation.assertEqual", "test_indices.TestVisualisation.ewa_vis.boxplot", "test_indices.TestVisualisation.assertEqual", "len", "len"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.boxplot", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.boxplot"], ["", "@", "pytest", ".", "mark", ".", "slow", "\n", "def", "test_boxplot", "(", "self", ")", ":", "\n", "\n", "        ", "expected_data_len", "=", "100", "\n", "data", "=", "self", ".", "cobra_vis", ".", "boxplot", "(", "info", "=", "True", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "data", "[", "\"Cobra\"", "]", ")", ",", "expected_data_len", ")", "\n", "\n", "data", "=", "self", ".", "ewa_vis", ".", "boxplot", "(", "info", "=", "True", ")", "\n", "self", ".", "assertEqual", "(", "len", "(", "data", "[", "\"Cobra\"", "]", ")", ",", "expected_data_len", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.test_QQ": [[77, 79], ["test_indices.TestVisualisation.cobra_vis.QQ"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.QQ"], ["", "def", "test_QQ", "(", "self", ")", ":", "\n", "        ", "self", ".", "cobra_vis", ".", "QQ", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.test_color_cobra": [[80, 82], ["test_indices.TestVisualisation.cobra_vis.color_cobra"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.color_cobra"], ["", "def", "test_color_cobra", "(", "self", ")", ":", "\n", "        ", "self", ".", "cobra_vis", ".", "color_cobra", "(", "indice_info", "=", "self", ".", "indices", ",", "single", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_indices.TestVisualisation.test_machines": [[83, 85], ["test_indices.TestVisualisation.cobra_vis.plot_machines"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.plot_machines"], ["", "def", "test_machines", "(", "self", ")", ":", "\n", "        ", "self", ".", "cobra_vis", ".", "plot_machines", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cobra.TestPrediction.setUp": [[16, 47], ["numpy.random.RandomState", "numpy.random.RandomState.uniform().reshape", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.ewa.Ewa", "pycobra.ewa.Ewa.fit", "pycobra.kernelcobra.KernelCobra", "pycobra.kernelcobra.KernelCobra.fit", "numpy.exp", "numpy.random.RandomState.uniform", "numpy.power", "numpy.power"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# setting up our random data-set", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "\n", "# D1 = train machines; D2 = create COBRA; D3 = calibrate epsilon, alpha; D4 = testing", "\n", "n_features", "=", "20", "\n", "D1", ",", "D2", ",", "D3", ",", "D4", "=", "200", ",", "200", ",", "200", ",", "200", "\n", "D", "=", "D1", "+", "D2", "+", "D3", "+", "D4", "\n", "X", "=", "rng", ".", "uniform", "(", "-", "1", ",", "1", ",", "D", "*", "n_features", ")", ".", "reshape", "(", "D", ",", "n_features", ")", "\n", "Y", "=", "np", ".", "power", "(", "X", "[", ":", ",", "1", "]", ",", "2", ")", "+", "np", ".", "power", "(", "X", "[", ":", ",", "3", "]", ",", "3", ")", "+", "np", ".", "exp", "(", "X", "[", ":", ",", "10", "]", ")", "\n", "\n", "# training data-set", "\n", "X_train", "=", "X", "[", ":", "D1", "+", "D2", "]", "\n", "X_test", "=", "X", "[", "D1", "+", "D2", "+", "D3", ":", "D1", "+", "D2", "+", "D3", "+", "D4", "]", "\n", "# for testing", "\n", "Y_train", "=", "Y", "[", ":", "D1", "+", "D2", "]", "\n", "Y_test", "=", "Y", "[", "D1", "+", "D2", "+", "D3", ":", "D1", "+", "D2", "+", "D3", "+", "D4", "]", "\n", "\n", "cobra", "=", "Cobra", "(", "random_state", "=", "0", ",", "epsilon", "=", "0.5", ")", "\n", "cobra", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "ewa", "=", "Ewa", "(", "random_state", "=", "0", ")", "\n", "ewa", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "kernel", "=", "KernelCobra", "(", "random_state", "=", "0", ")", "\n", "kernel", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "self", ".", "test_data", "=", "X_test", "\n", "self", ".", "cobra", "=", "cobra", "\n", "self", ".", "ewa", "=", "ewa", "\n", "self", ".", "kernelcobra", "=", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cobra.TestPrediction.test_cobra_predict": [[48, 52], ["test_cobra.TestPrediction.cobra.predict", "test_cobra.TestPrediction.assertAlmostEqual", "test_cobra.TestPrediction.test_data[].reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "test_cobra_predict", "(", "self", ")", ":", "\n", "        ", "expected", "=", "2.7310842344617035", "\n", "result", "=", "self", ".", "cobra", ".", "predict", "(", "self", ".", "test_data", "[", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected", ",", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cobra.TestPrediction.test_ewa_predict": [[53, 57], ["test_cobra.TestPrediction.ewa.predict", "test_cobra.TestPrediction.assertAlmostEqual", "test_cobra.TestPrediction.test_data[].reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "test_ewa_predict", "(", "self", ")", ":", "\n", "        ", "expected", "=", "2.7656847636961603", "\n", "result", "=", "self", ".", "ewa", ".", "predict", "(", "self", ".", "test_data", "[", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected", ",", "result", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cobra.TestPrediction.test_kernel_predict": [[58, 62], ["test_cobra.TestPrediction.kernelcobra.predict", "test_cobra.TestPrediction.assertAlmostEqual", "test_cobra.TestPrediction.test_data[].reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "test_kernel_predict", "(", "self", ")", ":", "\n", "        ", "expected", "=", "2.613685190585763", "\n", "result", "=", "self", ".", "kernelcobra", ".", "predict", "(", "self", ".", "test_data", "[", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected", ",", "result", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cobra.TestPrediction.test_estimators": [[63, 67], ["sklearn.utils.estimator_checks.check_estimator", "sklearn.utils.estimator_checks.check_estimator", "sklearn.utils.estimator_checks.check_estimator"], "methods", ["None"], ["", "def", "test_estimators", "(", "self", ")", ":", "\n", "        ", "check_estimator", "(", "Cobra", ")", "\n", "check_estimator", "(", "Ewa", ")", "\n", "check_estimator", "(", "KernelCobra", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.setUp": [[14, 44], ["numpy.random.RandomState", "numpy.random.RandomState.uniform().reshape", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.ewa.Ewa", "pycobra.ewa.Ewa.fit", "pycobra.diagnostics.Diagnostics", "pycobra.diagnostics.Diagnostics", "numpy.exp", "numpy.random.RandomState.uniform", "numpy.power", "numpy.power"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# setting up our random data-set", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "\n", "# D1 = train machines; D2 = create COBRA; D3 = calibrate epsilon, alpha; D4 = testing", "\n", "n_features", "=", "20", "\n", "D1", ",", "D2", ",", "D3", ",", "D4", "=", "200", ",", "200", ",", "200", ",", "200", "\n", "D", "=", "D1", "+", "D2", "+", "D3", "+", "D4", "\n", "X", "=", "rng", ".", "uniform", "(", "-", "1", ",", "1", ",", "D", "*", "n_features", ")", ".", "reshape", "(", "D", ",", "n_features", ")", "\n", "Y", "=", "np", ".", "power", "(", "X", "[", ":", ",", "1", "]", ",", "2", ")", "+", "np", ".", "power", "(", "X", "[", ":", ",", "3", "]", ",", "3", ")", "+", "np", ".", "exp", "(", "X", "[", ":", ",", "10", "]", ")", "\n", "\n", "# training data-set", "\n", "X_train", "=", "X", "[", ":", "D1", "+", "D2", "]", "\n", "X_test", "=", "X", "[", "D1", "+", "D2", "+", "D3", ":", "D1", "+", "D2", "+", "D3", "+", "D4", "]", "\n", "# for testing", "\n", "Y_train", "=", "Y", "[", ":", "D1", "+", "D2", "]", "\n", "Y_test", "=", "Y", "[", "D1", "+", "D2", "+", "D3", ":", "D1", "+", "D2", "+", "D3", "+", "D4", "]", "\n", "\n", "cobra", "=", "Cobra", "(", "random_state", "=", "0", ",", "epsilon", "=", "0.5", ")", "\n", "cobra", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "ewa", "=", "Ewa", "(", "random_state", "=", "0", ")", "\n", "ewa", ".", "fit", "(", "X_train", ",", "Y_train", ")", "\n", "\n", "self", ".", "test_data", "=", "X_test", "\n", "self", ".", "test_response", "=", "Y_test", "\n", "self", ".", "cobra", "=", "cobra", "\n", "self", ".", "ewa", "=", "ewa", "\n", "self", ".", "cobra_diagnostics", "=", "Diagnostics", "(", "self", ".", "cobra", ",", "random_state", "=", "0", ")", "\n", "self", ".", "cobra_diagnostics_ewa", "=", "Diagnostics", "(", "self", ".", "ewa", ",", "random_state", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_alpha": [[45, 50], ["test_diagnostics.TestOptimal.cobra_diagnostics.optimal_alpha", "test_diagnostics.TestOptimal.assertEqual", "test_diagnostics.TestOptimal.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_alpha"], ["", "def", "test_alpha", "(", "self", ")", ":", "\n", "        ", "alpha", ",", "mse", "=", "self", ".", "cobra_diagnostics", ".", "optimal_alpha", "(", "self", ".", "test_data", ",", "self", ".", "test_response", ")", "\n", "expected_alpha", ",", "expected_mse", "=", "5", ",", "0.06878994911340372", "\n", "self", ".", "assertEqual", "(", "expected_alpha", ",", "alpha", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "mse", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_alpha_grid": [[51, 57], ["test_diagnostics.TestOptimal.cobra_diagnostics.optimal_alpha_grid", "test_diagnostics.TestOptimal.assertEqual", "test_diagnostics.TestOptimal.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_alpha_grid"], ["", "@", "pytest", ".", "mark", ".", "slow", "\n", "def", "test_alpha_grid", "(", "self", ")", ":", "\n", "        ", "(", "alpha", ",", "epsilon", ")", ",", "mse", "=", "self", ".", "cobra_diagnostics", ".", "optimal_alpha_grid", "(", "self", ".", "test_data", "[", "0", "]", ",", "self", ".", "test_response", "[", "0", "]", ")", "\n", "expected_alpha", ",", "expected_mse", "=", "1", ",", "0.01331659692231877", "\n", "self", ".", "assertEqual", "(", "expected_alpha", ",", "alpha", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "mse", "[", "0", "]", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_machines_grid": [[58, 64], ["test_diagnostics.TestOptimal.cobra_diagnostics.optimal_machines_grid", "test_diagnostics.TestOptimal.assertEqual", "test_diagnostics.TestOptimal.assertAlmostEqual", "sorted", "sorted"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_machines_grid"], ["", "@", "pytest", ".", "mark", ".", "slow", "\n", "def", "test_machines_grid", "(", "self", ")", ":", "\n", "        ", "(", "machines", ",", "epsilon", ")", ",", "mse", "=", "self", ".", "cobra_diagnostics", ".", "optimal_machines_grid", "(", "self", ".", "test_data", "[", "0", "]", ",", "self", ".", "test_response", "[", "0", "]", ")", "\n", "expected_machines", ",", "expected_mse", "=", "(", "'svm'", ",", "'ridge'", ")", ",", "1.92151481985802e-05", "\n", "self", ".", "assertEqual", "(", "sorted", "(", "expected_machines", ")", ",", "sorted", "(", "machines", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "mse", "[", "0", "]", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_machines": [[65, 70], ["test_diagnostics.TestOptimal.cobra_diagnostics.optimal_machines", "test_diagnostics.TestOptimal.assertEqual", "test_diagnostics.TestOptimal.assertAlmostEqual", "sorted", "sorted"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_machines"], ["", "def", "test_machines", "(", "self", ")", ":", "\n", "        ", "machines", ",", "mse", "=", "self", ".", "cobra_diagnostics", ".", "optimal_machines", "(", "self", ".", "test_data", ",", "self", ".", "test_response", ")", "\n", "expected_machines", ",", "expected_mse", "=", "(", "'random_forest'", ",", "'ridge'", ",", "'tree'", ")", ",", "0.06668194656833465", "\n", "self", ".", "assertEqual", "(", "sorted", "(", "expected_machines", ")", ",", "sorted", "(", "machines", ")", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "mse", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_epsilon": [[71, 75], ["test_diagnostics.TestOptimal.cobra_diagnostics.optimal_epsilon", "test_diagnostics.TestOptimal.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_epsilon"], ["", "def", "test_epsilon", "(", "self", ")", ":", "\n", "        ", "epsilon", ",", "mse", "=", "self", ".", "cobra_diagnostics", ".", "optimal_epsilon", "(", "self", ".", "test_data", ",", "self", ".", "test_response", ")", "\n", "expected_epsilon", "=", "0.3709790878655187", "\n", "self", ".", "assertAlmostEqual", "(", "expected_epsilon", ",", "epsilon", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_split": [[76, 81], ["test_diagnostics.TestOptimal.cobra_diagnostics.optimal_split", "test_diagnostics.TestOptimal.assertEqual", "test_diagnostics.TestOptimal.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_split"], ["", "def", "test_split", "(", "self", ")", ":", "\n", "        ", "split", ",", "mse", "=", "self", ".", "cobra_diagnostics", ".", "optimal_split", "(", "self", ".", "test_data", ",", "self", ".", "test_response", ")", "\n", "expected_split", ",", "expected_mse", "=", "(", "0.5", ",", "0.5", ")", ",", "0.06878994911340372", "\n", "self", ".", "assertEqual", "(", "expected_split", ",", "split", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "mse", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_diagnostics.TestOptimal.test_beta": [[82, 87], ["test_diagnostics.TestOptimal.cobra_diagnostics_ewa.optimal_beta", "test_diagnostics.TestOptimal.assertAlmostEqual", "test_diagnostics.TestOptimal.assertAlmostEqual"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_beta"], ["", "def", "test_beta", "(", "self", ")", ":", "\n", "        ", "beta", ",", "mse", "=", "self", ".", "cobra_diagnostics_ewa", ".", "optimal_beta", "(", "self", ".", "test_data", ",", "self", ".", "test_response", ")", "\n", "expected_beta", ",", "expected_mse", "=", "0.1", ",", "0.07838339131485009", "\n", "self", ".", "assertAlmostEqual", "(", "expected_beta", ",", "beta", ",", "places", "=", "3", ")", "\n", "self", ".", "assertAlmostEqual", "(", "expected_mse", ",", "mse", ",", "places", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cc.TestPrediction.setUp": [[12, 20], ["numpy.random.RandomState", "sklearn.datasets.load_breast_cancer", "pycobra.classifiercobra.ClassifierCobra().fit", "pycobra.classifiercobra.ClassifierCobra"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["    ", "def", "setUp", "(", "self", ")", ":", "\n", "# setting up our random data-set", "\n", "        ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "bc", "=", "datasets", ".", "load_breast_cancer", "(", ")", "\n", "self", ".", "X", "=", "bc", ".", "data", "[", ":", "-", "20", "]", "\n", "self", ".", "y", "=", "bc", ".", "target", "[", ":", "-", "20", "]", "\n", "self", ".", "test_data", "=", "bc", ".", "data", "[", "-", "20", ":", "]", "\n", "self", ".", "cc", "=", "ClassifierCobra", "(", "random_state", "=", "0", ")", ".", "fit", "(", "self", ".", "X", ",", "self", ".", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.tests.test_cc.TestPrediction.test_cc_predict": [[21, 25], ["test_cc.TestPrediction.cc.predict", "test_cc.TestPrediction.assertEqual", "test_cc.TestPrediction.test_data[].reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "test_cc_predict", "(", "self", ")", ":", "\n", "        ", "expected", "=", "1", "\n", "result", "=", "self", ".", "cc", ".", "predict", "(", "self", ".", "test_data", "[", "0", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "self", ".", "assertEqual", "(", "expected", ",", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.__init__": [[21, 55], ["diagnostics.Diagnostics.load_MSE", "diagnostics.Diagnostics.load_errors", "type", "type"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.load_MSE", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.load_errors"], ["def", "__init__", "(", "self", ",", "aggregate", ",", "X_test", "=", "None", ",", "y_test", "=", "None", ",", "load_MSE", "=", "False", ",", "random_state", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        aggregate: pycobra.cobra.Cobra or pycobra.cobra.Ewa object\n            aggregate on which we want to run our analysis on.\n\n        X_test : array-like, shape = [n_samples, n_features], optional.\n            Testing data.\n\n        y_test : array-like, shape = [n_samples], optional.\n            Test data target values.\n\n        load_MSE: bool, optional\n            loads MSE and error bound values into diagnostics object.\n\n        random_state: integer or a numpy.random.RandomState object.\n            Set the state of the random number generator to pass on to shuffle and loading machines, to ensure\n            reproducibility of your experiments, for example.\n        \"\"\"", "\n", "self", ".", "aggregate", "=", "aggregate", "\n", "# X_test and y_test is only to compare MSEs of machines.", "\n", "self", ".", "X_test", "=", "X_test", "\n", "self", ".", "y_test", "=", "y_test", "\n", "\n", "if", "load_MSE", "and", "X_test", "is", "not", "None", "and", "type", "(", "self", ".", "aggregate", ")", "is", "not", "ClassifierCobra", ":", "\n", "            ", "self", ".", "load_MSE", "(", ")", "\n", "\n", "", "if", "type", "(", "self", ".", "aggregate", ")", "is", "ClassifierCobra", "and", "load_MSE", ":", "\n", "            ", "self", ".", "load_errors", "(", ")", "\n", "\n", "", "self", ".", "random_state", "=", "random_state", "\n", "if", "self", ".", "random_state", "is", "None", ":", "\n", "            ", "self", ".", "random_state", "=", "self", ".", "aggregate", ".", "random_state", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.load_MSE": [[57, 88], ["math.pow", "diagnostics.Diagnostics.aggregate.estimators_[].predict", "sklearn.metrics.mean_squared_error", "len", "type", "diagnostics.Diagnostics.aggregate.predict", "sklearn.metrics.mean_squared_error", "len"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "", "def", "load_MSE", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes MSE and error bound for each Machine based on test data.\n\n        Returns\n        -------\n        self : returns an instance of self.\n\n        \"\"\"", "\n", "self", ".", "machine_test_results", "=", "{", "}", "\n", "self", ".", "machine_MSE", "=", "{", "}", "\n", "\n", "\n", "names_dict", "=", "{", "Cobra", ":", "\"Cobra\"", ",", "Ewa", ":", "\"EWA\"", "}", "\n", "\n", "for", "name", "in", "names_dict", ":", "\n", "            ", "if", "type", "(", "self", ".", "aggregate", ")", "is", "name", ":", "\n", "                ", "self", ".", "machine_test_results", "[", "names_dict", "[", "name", "]", "]", "=", "self", ".", "aggregate", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "self", ".", "machine_MSE", "[", "names_dict", "[", "name", "]", "]", "=", "mean_squared_error", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "names_dict", "[", "name", "]", "]", ")", "\n", "\n", "\n", "", "", "for", "machine", "in", "self", ".", "aggregate", ".", "estimators_", ":", "\n", "            ", "self", ".", "machine_test_results", "[", "machine", "]", "=", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "# add MSE", "\n", "self", ".", "machine_MSE", "[", "machine", "]", "=", "mean_squared_error", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "machine", "]", ")", "\n", "\n", "# COBRA bound error", "\n", "", "power", "=", "-", "2", "/", "(", "len", "(", "self", ".", "aggregate", ".", "estimators_", ")", "+", "2", ")", "\n", "self", ".", "error_bound", "=", "math", ".", "pow", "(", "len", "(", "self", ".", "aggregate", ".", "X_l_", ")", ",", "power", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.load_errors": [[89, 108], ["diagnostics.Diagnostics.aggregate.predict", "sklearn.metrics.accuracy_score", "diagnostics.Diagnostics.aggregate.estimators_[].predict", "sklearn.metrics.accuracy_score"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "load_errors", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Computes accuracy score for each Machine based on test data.\n\n        Returns\n        -------\n        self : returns an instance of self.\n\n        \"\"\"", "\n", "self", ".", "machine_test_results", "=", "{", "}", "\n", "self", ".", "machine_error", "=", "{", "}", "\n", "\n", "self", ".", "machine_test_results", "[", "\"ClassifierCobra\"", "]", "=", "self", ".", "aggregate", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "self", ".", "machine_error", "[", "\"ClassifierCobra\"", "]", "=", "1", "-", "accuracy_score", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "\"ClassifierCobra\"", "]", ")", "\n", "\n", "for", "machine", "in", "self", ".", "aggregate", ".", "estimators_", ":", "\n", "            ", "self", ".", "machine_test_results", "[", "machine", "]", "=", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "# add MSE", "\n", "self", ".", "machine_error", "[", "machine", "]", "=", "1", "-", "accuracy_score", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "machine", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_alpha": [[109, 157], ["range", "min", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "len", "pycobra.cobra.Cobra.predict", "numpy.square", "pycobra.cobra.Cobra.predict", "sklearn.metrics.mean_squared_error"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "", "def", "optimal_alpha", "(", "self", ",", "X", ",", "y", ",", "single", "=", "False", ",", "epsilon", "=", "None", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal alpha for testing data for the COBRA predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want optimal alpha values\n\n        y: float\n            Target value for query to compare.\n\n        single: boolean, optional\n            Option to calculate optimal alpha for a single query point instead.\n\n        info: bool, optional\n            Returns MSE dictionary for each alpha value\n\n        epsilon: float, optional\n            fixed epsilon value to help determine optimal alpha.\n\n        Returns\n        -------\n\n        MSE: dictionary mapping alpha with mean squared errors\n        opt: optimal alpha combination\n\n        \"\"\"", "\n", "if", "epsilon", "is", "None", ":", "\n", "            ", "epsilon", "=", "self", ".", "aggregate", ".", "epsilon", "\n", "\n", "", "MSE", "=", "{", "}", "\n", "for", "alpha", "in", "range", "(", "1", ",", "len", "(", "self", ".", "aggregate", ".", "estimators_", ")", "+", "1", ")", ":", "\n", "            ", "machine", "=", "Cobra", "(", "random_state", "=", "self", ".", "random_state", ",", "epsilon", "=", "epsilon", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "# for a single data point", "\n", "if", "single", ":", "\n", "                ", "result", "=", "machine", ".", "predict", "(", "X", ",", "alpha", "=", "alpha", ")", "\n", "MSE", "[", "alpha", "]", "=", "np", ".", "square", "(", "y", "-", "result", ")", "\n", "", "else", ":", "\n", "                ", "results", "=", "machine", ".", "predict", "(", "X", ",", "alpha", "=", "alpha", ")", "\n", "MSE", "[", "alpha", "]", "=", "(", "mean_squared_error", "(", "y", ",", "results", ")", ")", "\n", "\n", "", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_machines": [[159, 213], ["numpy.arange", "min", "diagnostics.Diagnostics.aggregate.estimators_.keys", "list", "len", "itertools.combinations", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.cobra.Cobra.split_data", "pycobra.cobra.Cobra.load_default", "pycobra.cobra.Cobra.load_machine_predictions", "pycobra.cobra.Cobra.predict", "numpy.square", "pycobra.cobra.Cobra.predict", "sklearn.metrics.mean_squared_error", "X.reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_machines", "(", "self", ",", "X", ",", "y", ",", "single", "=", "False", ",", "epsilon", "=", "None", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal combination of machines for testing data for the COBRA predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want optimal machine combinations.\n\n        y: float\n            Target value for query to compare.\n\n        single: boolean, optional\n            Option to calculate optimal machine combinations for a single query point instead.\n\n        info: bool, optional\n            Returns MSE dictionary for each machine combination value\n\n        epsilon: float, optional\n            fixed epsilon value to help determine optimal machines.\n\n        Returns\n        -------\n\n        MSE: dictionary mapping machines with mean squared errors\n        opt: optimal machines combination\n\n        \"\"\"", "\n", "if", "epsilon", "is", "None", ":", "\n", "            ", "epsilon", "=", "self", ".", "aggregate", ".", "epsilon", "\n", "\n", "", "n_machines", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "self", ".", "aggregate", ".", "estimators_", ")", "+", "1", ")", "\n", "MSE", "=", "{", "}", "\n", "for", "num", "in", "n_machines", ":", "\n", "            ", "machine_names", "=", "self", ".", "aggregate", ".", "estimators_", ".", "keys", "(", ")", "\n", "use", "=", "list", "(", "itertools", ".", "combinations", "(", "machine_names", ",", "num", ")", ")", "\n", "for", "combination", "in", "use", ":", "\n", "                ", "machine", "=", "Cobra", "(", "random_state", "=", "self", ".", "random_state", ",", "epsilon", "=", "epsilon", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ",", "default", "=", "False", ")", "\n", "machine", ".", "split_data", "(", ")", "\n", "machine", ".", "load_default", "(", "machine_list", "=", "combination", ")", "\n", "machine", ".", "load_machine_predictions", "(", ")", "\n", "if", "single", ":", "\n", "                    ", "result", "=", "machine", ".", "predict", "(", "X", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "MSE", "[", "combination", "]", "=", "np", ".", "square", "(", "y", "-", "result", ")", "\n", "", "else", ":", "\n", "                    ", "results", "=", "machine", ".", "predict", "(", "X", ")", "\n", "MSE", "[", "combination", "]", "=", "(", "mean_squared_error", "(", "y", ",", "results", ")", ")", "\n", "\n", "", "", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_epsilon": [[215, 259], ["min", "numpy.linspace", "min", "sorted", "len", "max", "min", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.cobra.Cobra.predict", "sklearn.metrics.mean_squared_error", "range"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_epsilon", "(", "self", ",", "X", ",", "y", ",", "line_points", "=", "200", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal epsilon value for the COBRA predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want for optimal epsilon.\n\n        y: float\n            Target value for query to compare.\n\n        line_points: integer, optional\n            Number of epsilon values to traverse the grid.\n\n        info: bool, optional\n            Returns MSE dictionary for each epsilon value.\n\n        Returns\n        -------\n\n        MSE: dictionary mapping epsilon with mean squared errors\n        opt: optimal epsilon value\n\n        \"\"\"", "\n", "\n", "a", ",", "size", "=", "sorted", "(", "self", ".", "aggregate", ".", "all_predictions_", ")", ",", "len", "(", "self", ".", "aggregate", ".", "all_predictions_", ")", "\n", "res", "=", "[", "a", "[", "i", "+", "1", "]", "-", "a", "[", "i", "]", "for", "i", "in", "range", "(", "size", ")", "if", "i", "+", "1", "<", "size", "]", "\n", "emin", "=", "min", "(", "res", ")", "\n", "emax", "=", "max", "(", "a", ")", "-", "min", "(", "a", ")", "\n", "erange", "=", "np", ".", "linspace", "(", "emin", ",", "emax", ",", "line_points", ")", "\n", "\n", "MSE", "=", "{", "}", "\n", "for", "epsilon", "in", "erange", ":", "\n", "            ", "machine", "=", "Cobra", "(", "random_state", "=", "self", ".", "random_state", ",", "epsilon", "=", "epsilon", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "results", "=", "machine", ".", "predict", "(", "X", ")", "\n", "MSE", "[", "epsilon", "]", "=", "(", "mean_squared_error", "(", "y", ",", "results", ")", ")", "\n", "\n", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_split": [[261, 322], ["min", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.cobra.Cobra.split_data", "pycobra.cobra.Cobra.load_default", "pycobra.cobra.Cobra.load_machine_predictions", "pycobra.cobra.Cobra.predict", "sklearn.metrics.mean_squared_error", "plt.plot", "int", "int", "ratio.append", "mse.append", "len", "len"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_split", "(", "self", ",", "X", ",", "y", ",", "split", "=", "None", ",", "epsilon", "=", "None", ",", "info", "=", "False", ",", "graph", "=", "False", ")", ":", "\n", "\n", "        ", "\"\"\"\n        Find the optimal combination split (D_k, D_l) for fixed epsilon value for the COBRA predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want for optimal split.\n\n        y: float\n            Target value for query to compare.\n\n        epsilon: float, optional.\n            fixed epsilon value to help determine optimal machines.\n\n        split: list, optional.\n            D_k, D_l break-up to calculate MSE\n\n        info: bool, optional.\n            Returns MSE dictionary for each split.\n\n        graph: bool, optional.\n            Plots graph of MSE vs split\n\n        Returns\n        -------\n\n        MSE: dictionary mapping split with mean squared errors\n        opt: optimal epsilon value\n\n        \"\"\"", "\n", "if", "epsilon", "is", "None", ":", "\n", "            ", "epsilon", "=", "self", ".", "aggregate", ".", "epsilon", "\n", "\n", "", "if", "split", "is", "None", ":", "\n", "            ", "split", "=", "[", "(", "0.20", ",", "0.80", ")", ",", "(", "0.40", ",", "0.60", ")", ",", "(", "0.50", ",", "0.50", ")", ",", "(", "0.60", ",", "0.40", ")", ",", "(", "0.80", ",", "0.20", ")", "]", "\n", "\n", "", "MSE", "=", "{", "}", "\n", "for", "k", ",", "l", "in", "split", ":", "\n", "            ", "machine", "=", "Cobra", "(", "random_state", "=", "self", ".", "random_state", ",", "epsilon", "=", "epsilon", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ",", "default", "=", "False", ")", "\n", "machine", ".", "split_data", "(", "int", "(", "k", "*", "len", "(", "self", ".", "aggregate", ".", "X_", ")", ")", ",", "int", "(", "(", "k", "+", "l", ")", "*", "len", "(", "self", ".", "aggregate", ".", "X_", ")", ")", ")", "\n", "machine", ".", "load_default", "(", ")", "\n", "machine", ".", "load_machine_predictions", "(", ")", "\n", "results", "=", "machine", ".", "predict", "(", "X", ")", "\n", "MSE", "[", "(", "k", ",", "l", ")", "]", "=", "(", "mean_squared_error", "(", "y", ",", "results", ")", ")", "\n", "\n", "", "if", "graph", ":", "\n", "            ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "ratio", ",", "mse", "=", "[", "]", ",", "[", "]", "\n", "for", "value", "in", "split", ":", "\n", "                ", "ratio", ".", "append", "(", "value", "[", "0", "]", ")", "\n", "mse", ".", "append", "(", "MSE", "[", "value", "]", ")", "\n", "", "plt", ".", "plot", "(", "ratio", ",", "mse", ")", "\n", "\n", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_alpha_grid": [[324, 373], ["min", "numpy.linspace", "numpy.arange", "min", "sorted", "len", "max", "min", "range", "len", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.cobra.Cobra.predict", "numpy.square", "X.reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_alpha_grid", "(", "self", ",", "X", ",", "y", ",", "line_points", "=", "200", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal epsilon and alpha for a single query point for the COBRA predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want optimal alpha and epsilon values\n\n        y: float\n            Target value for query to compare.\n\n        line_points: integer, optional\n            Number of epsilon values to traverse the grid.\n\n        info: bool, optional\n            Returns MSE dictionary for each epsilon/alpha value\n\n        Returns\n        -------\n\n        MSE: dictionary mapping (alpha, epsilon) with mean squared errors\n        opt: optimal epislon/alpha combination\n\n        \"\"\"", "\n", "\n", "# code to find maximum and minimum distance between predictions to create grid", "\n", "a", ",", "size", "=", "sorted", "(", "self", ".", "aggregate", ".", "all_predictions_", ")", ",", "len", "(", "self", ".", "aggregate", ".", "all_predictions_", ")", "\n", "res", "=", "[", "a", "[", "i", "+", "1", "]", "-", "a", "[", "i", "]", "for", "i", "in", "range", "(", "size", ")", "if", "i", "+", "1", "<", "size", "]", "\n", "emin", "=", "min", "(", "res", ")", "\n", "emax", "=", "max", "(", "a", ")", "-", "min", "(", "a", ")", "\n", "erange", "=", "np", ".", "linspace", "(", "emin", ",", "emax", ",", "line_points", ")", "\n", "n_machines", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "self", ".", "aggregate", ".", "estimators_", ")", "+", "1", ")", "\n", "MSE", "=", "{", "}", "\n", "\n", "# looping over epsilon and alpha values", "\n", "for", "epsilon", "in", "erange", ":", "\n", "            ", "for", "num", "in", "n_machines", ":", "\n", "                ", "machine", "=", "Cobra", "(", "random_state", "=", "self", ".", "random_state", ",", "epsilon", "=", "epsilon", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "result", "=", "machine", ".", "predict", "(", "X", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "alpha", "=", "num", ")", "\n", "MSE", "[", "(", "num", ",", "epsilon", ")", "]", "=", "np", ".", "square", "(", "y", "-", "result", ")", "\n", "\n", "", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_machines_grid": [[375, 428], ["min", "numpy.linspace", "numpy.arange", "min", "sorted", "len", "max", "min", "range", "len", "diagnostics.Diagnostics.aggregate.estimators_.keys", "list", "itertools.combinations", "pycobra.cobra.Cobra", "pycobra.cobra.Cobra.fit", "pycobra.cobra.Cobra.split_data", "pycobra.cobra.Cobra.load_default", "pycobra.cobra.Cobra.load_machine_predictions", "pycobra.cobra.Cobra.predict", "numpy.square", "X.reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_machines_grid", "(", "self", ",", "X", ",", "y", ",", "line_points", "=", "200", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal epsilon and machine-combination for a single query point for the COBRA predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want optimal machines and epsilon values\n\n        y: float\n            Target value for query to compare.\n\n        line_points: integer, optional\n            Number of epsilon values to traverse the grid.\n\n        info: bool, optional\n            Returns MSE dictionary for each epsilon/machine value.\n\n        Returns\n        -------\n\n        MSE: dictionary mapping (machine combination, epsilon) with mean squared errors\n        opt: optimal epislon/machine combination\n\n        \"\"\"", "\n", "\n", "# code to find maximum and minimum distance between predictions to create grid", "\n", "a", ",", "size", "=", "sorted", "(", "self", ".", "aggregate", ".", "all_predictions_", ")", ",", "len", "(", "self", ".", "aggregate", ".", "all_predictions_", ")", "\n", "res", "=", "[", "a", "[", "i", "+", "1", "]", "-", "a", "[", "i", "]", "for", "i", "in", "range", "(", "size", ")", "if", "i", "+", "1", "<", "size", "]", "\n", "emin", "=", "min", "(", "res", ")", "\n", "emax", "=", "max", "(", "a", ")", "-", "min", "(", "a", ")", "\n", "erange", "=", "np", ".", "linspace", "(", "emin", ",", "emax", ",", "line_points", ")", "\n", "n_machines", "=", "np", ".", "arange", "(", "1", ",", "len", "(", "self", ".", "aggregate", ".", "estimators_", ")", "+", "1", ")", "\n", "MSE", "=", "{", "}", "\n", "\n", "for", "epsilon", "in", "erange", ":", "\n", "            ", "for", "num", "in", "n_machines", ":", "\n", "                ", "machine_names", "=", "self", ".", "aggregate", ".", "estimators_", ".", "keys", "(", ")", "\n", "use", "=", "list", "(", "itertools", ".", "combinations", "(", "machine_names", ",", "num", ")", ")", "\n", "for", "combination", "in", "use", ":", "\n", "                    ", "machine", "=", "Cobra", "(", "random_state", "=", "self", ".", "random_state", ",", "epsilon", "=", "epsilon", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ",", "default", "=", "False", ")", "\n", "machine", ".", "split_data", "(", ")", "\n", "machine", ".", "load_default", "(", "machine_list", "=", "combination", ")", "\n", "machine", ".", "load_machine_predictions", "(", ")", "\n", "result", "=", "machine", ".", "predict", "(", "X", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "MSE", "[", "(", "combination", ",", "epsilon", ")", "]", "=", "np", ".", "square", "(", "y", "-", "result", ")", "\n", "\n", "", "", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_beta": [[430, 471], ["min", "numpy.arange", "pycobra.ewa.Ewa", "pycobra.ewa.Ewa.fit", "pycobra.ewa.Ewa.predict", "sklearn.metrics.mean_squared_error"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_beta", "(", "self", ",", "X", ",", "y", ",", "betas", "=", "None", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal beta value for the Ewa predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want for optimal beta.\n\n        y: float\n            Target value for query to compare.\n\n        betas: list, optional\n            List of beta values to iterate over for optimal beta.\n\n        info: bool, optional\n            Returns MSE dictionary for each beta value.\n\n        Returns\n        -------\n\n        MSE: dictionary mapping epsilon with mean squared errors\n        opt: optimal beta value\n\n        \"\"\"", "\n", "\n", "if", "betas", "is", "None", ":", "\n", "            ", "betas", "=", "np", ".", "arange", "(", "0.1", ",", "10", ")", "\n", "\n", "", "MSE", "=", "{", "}", "\n", "for", "beta", "in", "betas", ":", "\n", "            ", "machine", "=", "Ewa", "(", "random_state", "=", "self", ".", "random_state", ",", "beta", "=", "beta", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "results", "=", "machine", ".", "predict", "(", "X", ")", "\n", "MSE", "[", "beta", "]", "=", "(", "mean_squared_error", "(", "y", ",", "results", ")", ")", "\n", "\n", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_kernelbandwidth": [[473, 514], ["min", "numpy.arange", "pycobra.kernelcobra.KernelCobra", "pycobra.kernelcobra.KernelCobra.fit", "pycobra.kernelcobra.KernelCobra.predict", "sklearn.metrics.mean_squared_error"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "optimal_kernelbandwidth", "(", "self", ",", "X", ",", "y", ",", "bandwidths", "=", "None", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Find the optimal bandwidth value for the KernelCobra predictor.\n\n        Parameteres\n        -----------\n\n        X: array-like, [n_features]\n            Vector for which we want for optimal bandwidths.\n\n        y: float\n            Target value for query to compare.\n\n        bandwidths: list, optional\n            List of bandwidth values to iterate over for optimal bandwidth.\n\n        info: bool, optional\n            Returns MSE dictionary for each bandwidth value.\n\n        Returns\n        -------\n\n        MSE: dictionary mapping epsilon with mean squared errors\n        opt: optimal bandwidth value\n\n        \"\"\"", "\n", "\n", "if", "bandwidths", "is", "None", ":", "\n", "            ", "bandwidths", "=", "np", ".", "arange", "(", "0.05", ",", "2.55", ",", "step", "=", "0.10", ")", "\n", "\n", "", "MSE", "=", "{", "}", "\n", "for", "bandwidth", "in", "bandwidths", ":", "\n", "            ", "machine", "=", "KernelCobra", "(", "random_state", "=", "self", ".", "random_state", ")", "\n", "machine", ".", "fit", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "results", "=", "machine", ".", "predict", "(", "X", ",", "bandwidth", "=", "bandwidth", ")", "\n", "MSE", "[", "bandwidth", "]", "=", "(", "mean_squared_error", "(", "y", ",", "results", ")", ")", "\n", "\n", "", "if", "info", ":", "\n", "            ", "return", "MSE", "\n", "", "opt", "=", "min", "(", "MSE", ",", "key", "=", "MSE", ".", "get", ")", "\n", "return", "opt", ",", "MSE", "[", "opt", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.__init__": [[53, 57], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "random_state", "=", "None", ",", "epsilon", "=", "None", ",", "machine_list", "=", "'basic'", ")", ":", "\n", "        ", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "machine_list", "=", "machine_list", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.fit": [[58, 101], ["sklearn.utils.validation.check_X_y", "cobra.Cobra.split_data", "cobra.Cobra.load_default", "cobra.Cobra.load_machine_predictions"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "default", "=", "True", ",", "X_k", "=", "None", ",", "X_l", "=", "None", ",", "y_k", "=", "None", ",", "y_l", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        X: array-like, [n_samples, n_features]\n            Training data which will be used to create the COBRA aggregate.\n\n        y: array-like, shape = [n_samples]\n            Target values used to train the machines used in the aggregation.\n\n        default: bool, optional\n            If set as true then sets up COBRA with default machines and splitting.\n\n        X_k : shape = [n_samples, n_features]\n            Training data which is used to train the machines used in the aggregation.\n            Can be loaded directly into COBRA; if not, the split_data method is used as default.\n\n        y_k : array-like, shape = [n_samples]\n            Target values used to train the machines used in the aggregation.\n\n        X_l : shape = [n_samples, n_features]\n            Training data which is used to form the aggregate.\n            Can be loaded directly into COBRA; if not, the split_data method is used as default.\n\n        y_l : array-like, shape = [n_samples]\n            Target values which are actually used to form the aggregate.\n        \"\"\"", "\n", "\n", "X", ",", "y", "=", "check_X_y", "(", "X", ",", "y", ")", "\n", "self", ".", "X_", "=", "X", "\n", "self", ".", "y_", "=", "y", "\n", "self", ".", "X_k_", "=", "X_k", "\n", "self", ".", "X_l_", "=", "X_l", "\n", "self", ".", "y_k_", "=", "y_k", "\n", "self", ".", "y_l_", "=", "y_l", "\n", "self", ".", "estimators_", "=", "{", "}", "\n", "# set-up COBRA with default machines", "\n", "if", "default", ":", "\n", "            ", "self", ".", "split_data", "(", ")", "\n", "self", ".", "load_default", "(", "machine_list", "=", "self", ".", "machine_list", ")", "\n", "self", ".", "load_machine_predictions", "(", ")", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.set_epsilon": [[103, 136], ["cobra.Cobra.split_data", "cobra.Cobra.load_default", "cobra.Cobra.load_machine_predictions", "min", "numpy.linspace", "sklearn.model_selection.GridSearchCV", "sklearn.model_selection.GridSearchCV.fit", "sorted", "len", "max", "min", "range"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["", "def", "set_epsilon", "(", "self", ",", "X_epsilon", "=", "None", ",", "y_epsilon", "=", "None", ",", "grid_points", "=", "50", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n\n        X_epsilon : shape = [n_samples, n_features]\n            Used if no epsilon is passed to find the optimal epsilon for data passed.\n\n        y_epsilon : array-like, shape = [n_samples]\n            Used if no epsilon is passed to find the optimal epsilon for data passed.\n\n        grid_points: int, optional\n            If no epsilon value is passed, this parameter controls how many points on the grid to traverse.\n   \n        \"\"\"", "\n", "\n", "# if no epsilon value is passed, we set up COBRA to perform CV and find an optimal epsilon.", "\n", "if", "self", ".", "epsilon", "is", "None", "and", "X_epsilon", "is", "not", "None", ":", "\n", "            ", "self", ".", "X_", "=", "X_epsilon", "\n", "self", ".", "y_", "=", "y_epsilon", "\n", "self", ".", "split_data", "(", ")", "\n", "self", ".", "load_default", "(", ")", "\n", "self", ".", "load_machine_predictions", "(", ")", "\n", "a", ",", "size", "=", "sorted", "(", "self", ".", "all_predictions_", ")", ",", "len", "(", "self", ".", "all_predictions_", ")", "\n", "res", "=", "[", "a", "[", "i", "+", "1", "]", "-", "a", "[", "i", "]", "for", "i", "in", "range", "(", "size", ")", "if", "i", "+", "1", "<", "size", "]", "\n", "emin", "=", "min", "(", "res", ")", "\n", "emax", "=", "max", "(", "a", ")", "-", "min", "(", "a", ")", "\n", "erange", "=", "np", ".", "linspace", "(", "emin", ",", "emax", ",", "grid_points", ")", "\n", "tuned_parameters", "=", "[", "{", "'epsilon'", ":", "erange", "}", "]", "\n", "clf", "=", "GridSearchCV", "(", "self", ",", "tuned_parameters", ",", "scoring", "=", "\"neg_mean_squared_error\"", ")", "\n", "clf", ".", "fit", "(", "X_epsilon", ",", "y_epsilon", ")", "\n", "self", ".", "epsilon", "=", "clf", ".", "best_params_", "[", "\"epsilon\"", "]", "\n", "self", ".", "estimators_", ",", "self", ".", "machine_predictions_", "=", "{", "}", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.pred": [[138, 202], ["range", "cobra.Cobra.estimators_[].predict", "set", "range", "len", "len", "len", "len", "points.append", "logger.info", "math.fabs", "select[].add", "logger.info"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "", "def", "pred", "(", "self", ",", "X", ",", "alpha", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Performs the COBRA aggregation scheme, used in predict method.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        alpha: int, optional\n            alpha refers to the number of machines the prediction must be close to to be considered during aggregation.\n\n        info: boolean, optional\n            If info is true the list of points selected in the aggregation is returned.\n\n        Returns\n        -------\n        avg: prediction\n\n        \"\"\"", "\n", "\n", "# dictionary mapping machine to points selected", "\n", "select", "=", "{", "}", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "# machine prediction", "\n", "            ", "val", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "X", ")", "\n", "select", "[", "machine", "]", "=", "set", "(", ")", "\n", "# iterating from l to n", "\n", "# replace with numpy iteration", "\n", "for", "count", "in", "range", "(", "0", ",", "len", "(", "self", ".", "X_l_", ")", ")", ":", "\n", "                ", "try", ":", "\n", "# if value is close to prediction, select the indice", "\n", "                    ", "if", "math", ".", "fabs", "(", "self", ".", "machine_predictions_", "[", "machine", "]", "[", "count", "]", "-", "val", ")", "<=", "self", ".", "epsilon", ":", "\n", "                        ", "select", "[", "machine", "]", ".", "add", "(", "count", ")", "\n", "", "", "except", "(", "ValueError", ",", "TypeError", ")", "as", "e", ":", "\n", "                    ", "logger", ".", "info", "(", "\"Error in indice selection\"", ")", "\n", "continue", "\n", "\n", "", "", "", "points", "=", "[", "]", "\n", "# count is the indice number.", "\n", "for", "count", "in", "range", "(", "0", ",", "len", "(", "self", ".", "X_l_", ")", ")", ":", "\n", "# row check is number of machines which picked up a particular point", "\n", "            ", "row_check", "=", "0", "\n", "for", "machine", "in", "select", ":", "\n", "                ", "if", "count", "in", "select", "[", "machine", "]", ":", "\n", "                    ", "row_check", "+=", "1", "\n", "", "", "if", "row_check", "==", "alpha", ":", "\n", "                ", "points", ".", "append", "(", "count", ")", "\n", "\n", "# if no points are selected, return 0", "\n", "", "", "if", "len", "(", "points", ")", "==", "0", ":", "\n", "            ", "if", "info", ":", "\n", "                ", "logger", ".", "info", "(", "\"No points were selected, prediction is 0\"", ")", "\n", "return", "(", "0", ",", "0", ")", "\n", "", "return", "0", "\n", "\n", "# aggregate", "\n", "", "avg", "=", "0", "\n", "for", "point", "in", "points", ":", "\n", "            ", "avg", "+=", "self", ".", "y_l_", "[", "point", "]", "\n", "", "avg", "=", "avg", "/", "len", "(", "points", ")", "\n", "\n", "if", "info", ":", "\n", "            ", "return", "avg", ",", "points", "\n", "", "return", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.predict": [[204, 249], ["sklearn.utils.validation.check_array", "numpy.zeros", "len", "cobra.Cobra.pred", "len", "sklearn.utils.validation.check_array.reshape", "cobra.Cobra.pred", "len", "cobra.Cobra.pred", "len", "vector.reshape", "vector.reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred"], ["", "def", "predict", "(", "self", ",", "X", ",", "alpha", "=", "None", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Performs the COBRA aggregation scheme, calls pred.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        alpha: int, optional\n            alpha refers to the number of machines the prediction must be close to to be considered during aggregation.\n\n        info: boolean, optional\n            If info is true the list of points selected in the aggregation is returned.\n\n        Returns\n        -------\n        result: prediction\n\n        \"\"\"", "\n", "\n", "# sets alpha as the total number of machines as a default value", "\n", "\n", "X", "=", "check_array", "(", "X", ")", "\n", "\n", "if", "alpha", "is", "None", ":", "\n", "            ", "alpha", "=", "len", "(", "self", ".", "estimators_", ")", "\n", "", "if", "X", ".", "ndim", "==", "1", ":", "\n", "            ", "return", "self", ".", "pred", "(", "X", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "info", "=", "info", ",", "alpha", "=", "alpha", ")", "\n", "\n", "", "result", "=", "np", ".", "zeros", "(", "len", "(", "X", ")", ")", "\n", "avg_points", "=", "0", "\n", "index", "=", "0", "\n", "for", "vector", "in", "X", ":", "\n", "            ", "if", "info", ":", "\n", "                ", "result", "[", "index", "]", ",", "points", "=", "self", ".", "pred", "(", "vector", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "info", "=", "info", ",", "alpha", "=", "alpha", ")", "\n", "avg_points", "+=", "len", "(", "points", ")", "\n", "", "else", ":", "\n", "                ", "result", "[", "index", "]", "=", "self", ".", "pred", "(", "vector", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "info", "=", "info", ",", "alpha", "=", "alpha", ")", "\n", "", "index", "+=", "1", "\n", "\n", "", "if", "info", ":", "\n", "            ", "avg_points", "=", "avg_points", "/", "len", "(", "X_array", ")", "\n", "return", "result", ",", "avg_points", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.split_data": [[251, 291], ["sklearn.utils.shuffle", "int", "int", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "split_data", "(", "self", ",", "k", "=", "None", ",", "l", "=", "None", ",", "shuffle_data", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Split the data into different parts for training machines and for aggregation.\n\n        Parameters\n        ----------\n        k : int, optional\n            k is the number of points used to train the machines.\n            Those are the first k points of the data provided.\n\n        l: int, optional\n            l is the number of points used to form the COBRA aggregate.\n\n        shuffle: bool, optional\n            Boolean value to decide to shuffle the data before splitting.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "if", "shuffle_data", ":", "\n", "            ", "self", ".", "X_", ",", "self", ".", "y_", "=", "shuffle", "(", "self", ".", "X_", ",", "self", ".", "y_", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "", "if", "k", "is", "None", "and", "l", "is", "None", ":", "\n", "            ", "k", "=", "int", "(", "len", "(", "self", ".", "X_", ")", "/", "2", ")", "\n", "l", "=", "int", "(", "len", "(", "self", ".", "X_", ")", ")", "\n", "\n", "", "if", "k", "is", "not", "None", "and", "l", "is", "None", ":", "\n", "            ", "l", "=", "len", "(", "self", ".", "X_", ")", "-", "k", "\n", "\n", "", "if", "l", "is", "not", "None", "and", "k", "is", "None", ":", "\n", "            ", "k", "=", "len", "(", "self", ".", "X_", ")", "-", "l", "\n", "\n", "", "self", ".", "X_k_", "=", "self", ".", "X_", "[", ":", "k", "]", "\n", "self", ".", "X_l_", "=", "self", ".", "X_", "[", "k", ":", "l", "]", "\n", "self", ".", "y_k_", "=", "self", ".", "y_", "[", ":", "k", "]", "\n", "self", ".", "y_l_", "=", "self", ".", "y_", "[", "k", ":", "l", "]", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.load_default": [[293, 331], ["sklearn.linear_model.LassoCV().fit", "sklearn.tree.DecisionTreeRegressor().fit", "sklearn.linear_model.RidgeCV().fit", "sklearn.ensemble.RandomForestRegressor().fit", "sklearn.svm.LinearSVR().fit", "sklearn.linear_model.SGDRegressor().fit", "sklearn.linear_model.BayesianRidge().fit", "sklearn.linear_model.LassoCV", "sklearn.tree.DecisionTreeRegressor", "sklearn.linear_model.RidgeCV", "sklearn.ensemble.RandomForestRegressor", "sklearn.svm.LinearSVR", "sklearn.linear_model.SGDRegressor", "sklearn.linear_model.BayesianRidge"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["", "def", "load_default", "(", "self", ",", "machine_list", "=", "'basic'", ")", ":", "\n", "        ", "\"\"\"\n        Loads 4 different scikit-learn regressors by default. The advanced list adds more machines. \n\n        Parameters\n        ----------\n        machine_list: optional, list of strings\n            List of default machine names to be loaded.\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "if", "machine_list", "==", "'basic'", ":", "\n", "            ", "machine_list", "=", "[", "'tree'", ",", "'ridge'", ",", "'random_forest'", ",", "'svm'", "]", "\n", "", "if", "machine_list", "==", "'advanced'", ":", "\n", "            ", "machine_list", "=", "[", "'lasso'", ",", "'tree'", ",", "'ridge'", ",", "'random_forest'", ",", "'svm'", ",", "'bayesian_ridge'", ",", "'sgd'", "]", "\n", "\n", "", "self", ".", "estimators_", "=", "{", "}", "\n", "for", "machine", "in", "machine_list", ":", "\n", "            ", "try", ":", "\n", "                ", "if", "machine", "==", "'lasso'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'lasso'", "]", "=", "linear_model", ".", "LassoCV", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'tree'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'tree'", "]", "=", "DecisionTreeRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'ridge'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'ridge'", "]", "=", "linear_model", ".", "RidgeCV", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'random_forest'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'random_forest'", "]", "=", "RandomForestRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'svm'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'svm'", "]", "=", "LinearSVR", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'sgd'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'sgd'", "]", "=", "linear_model", ".", "SGDRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'bayesian_ridge'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'bayesian_ridge'", "]", "=", "linear_model", ".", "BayesianRidge", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "", "except", "ValueError", ":", "\n", "                ", "continue", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.load_machine": [[333, 355], ["None"], "methods", ["None"], ["", "def", "load_machine", "(", "self", ",", "machine_name", ",", "machine", ")", ":", "\n", "        ", "\"\"\"\n        Adds a machine to be used during the aggregation strategy.\n        The machine object must have been trained using X_k and y_k, and must have a 'predict()' method.\n        After the machine is loaded, for it to be used during aggregation, load_machine_predictions must be run.\n\n        Parameters\n        ----------\n        machine_name : string\n            Name of the machine you are loading\n\n        machine: machine/regressor object\n            The regressor machine object which is mapped to the machine_name\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "self", ".", "estimators_", "[", "machine_name", "]", "=", "machine", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.cobra.Cobra.load_machine_predictions": [[357, 383], ["numpy.array", "cobra.Cobra.estimators_[].predict", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "load_machine_predictions", "(", "self", ",", "predictions", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Stores the trained machines' predicitons on training data in a dictionary, to be used for predictions.\n        Should be run after all the machines to be used for aggregation is loaded.\n\n        Parameters\n        ----------\n        predictions: dictionary, optional\n            A pre-existing machine:predictions dictionary can also be loaded.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "self", ".", "machine_predictions_", "=", "{", "}", "\n", "self", ".", "all_predictions_", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "if", "predictions", "is", "None", ":", "\n", "            ", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "                ", "self", ".", "machine_predictions_", "[", "machine", "]", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_l_", ")", "\n", "# all_predictions_ is used in the diagnostics class, and for initialising epsilon", "\n", "self", ".", "all_predictions_", "=", "np", ".", "append", "(", "self", ".", "all_predictions_", ",", "self", ".", "machine_predictions_", "[", "machine", "]", ")", "\n", "\n", "", "", "if", "predictions", "is", "not", "None", ":", "\n", "            ", "self", ".", "machine_predictions_", "=", "predictions", "\n", "\n", "", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.__init__": [[225, 288], ["len", "type", "visualisation.Visualisation.aggregate.predict", "sklearn.metrics.mean_squared_error", "sklearn.metrics.accuracy_score", "visualisation.Visualisation.estimators_[].predict", "type", "sklearn.metrics.mean_squared_error", "type", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "sklearn.metrics.accuracy_score", "type", "visualisation.Visualisation.aggregate.predict", "visualisation.Visualisation.aggregate.predict"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["def", "__init__", "(", "self", ",", "aggregate", ",", "X_test", ",", "y_test", ",", "plot_size", "=", "8", ",", "estimators", "=", "{", "}", ",", "random_state", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        aggregate: pycobra.cobra.Cobra or pycobra.cobra.Ewa object\n            aggregate on which we want to run our analysis on.\n\n        X_test : array-like, shape = [n_samples, n_features].\n            Testing data.\n\n        y_test : array-like, shape = [n_samples].\n            Test data target values.\n\n        plot_size: int, optional\n            Size of matplotlib plots.\n\n        estimators: list, optional\n            List of machine objects to visualise. Default is machines used in aggregate.\n\n        \"\"\"", "\n", "self", ".", "aggregate", "=", "aggregate", "\n", "self", ".", "X_test", "=", "X_test", "\n", "self", ".", "y_test", "=", "y_test", "\n", "self", ".", "plot_size", "=", "plot_size", "\n", "self", ".", "estimators", "=", "estimators", "\n", "# load results so plotting doesn't need parameters", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "self", ".", "machine_test_results", "=", "{", "}", "\n", "self", ".", "machine_MSE", "=", "{", "}", "\n", "\n", "if", "len", "(", "self", ".", "estimators", ")", "==", "0", ":", "\n", "            ", "self", ".", "estimators", "=", "self", ".", "aggregate", ".", "estimators_", "\n", "\n", "# if we are visualising ClassifierCobra then we must use accuracy score instead of MSE", "\n", "", "if", "type", "(", "aggregate", ")", "is", "ClassifierCobra", ":", "\n", "            ", "self", ".", "machine_test_results", "[", "\"ClassifierCobra\"", "]", "=", "self", ".", "aggregate", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "self", ".", "machine_error", "[", "\"ClassifierCobra\"", "]", "=", "1", "-", "accuracy_score", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "\"ClassifierCobra\"", "]", ")", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "                ", "self", ".", "machine_test_results", "[", "machine", "]", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "# add MSE", "\n", "self", ".", "machine_error", "[", "machine", "]", "=", "1", "-", "accuracy_score", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "machine", "]", ")", "\n", "\n", "\n", "", "", "names_dict", "=", "{", "Cobra", ":", "\"Cobra\"", ",", "Ewa", ":", "\"EWA\"", ",", "KernelCobra", ":", "\"KernelCobra\"", "}", "\n", "for", "name", "in", "names_dict", ":", "\n", "            ", "if", "type", "(", "aggregate", ")", "==", "name", ":", "\n", "                ", "if", "type", "(", "aggregate", ")", "==", "KernelCobra", ":", "\n", "                    ", "self", ".", "machine_test_results", "[", "names_dict", "[", "name", "]", "]", "=", "self", ".", "aggregate", ".", "predict", "(", "self", ".", "X_test", ",", "bandwidth", "=", "kwargs", "[", "\"bandwidth_kernel\"", "]", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "machine_test_results", "[", "names_dict", "[", "name", "]", "]", "=", "self", ".", "aggregate", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "", "self", ".", "machine_MSE", "[", "names_dict", "[", "name", "]", "]", "=", "mean_squared_error", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "names_dict", "[", "name", "]", "]", ")", "\n", "\n", "", "", "for", "machine", "in", "self", ".", "estimators", ":", "\n", "            ", "if", "type", "(", "self", ".", "estimators", "[", "machine", "]", ")", "==", "KernelCobra", ":", "\n", "                ", "self", ".", "machine_test_results", "[", "machine", "]", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ",", "bandwidth", "=", "kwargs", "[", "\"bandwidth_kernel\"", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "machine_test_results", "[", "machine", "]", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "", "self", ".", "machine_MSE", "[", "machine", "]", "=", "mean_squared_error", "(", "self", ".", "y_test", ",", "self", ".", "machine_test_results", "[", "machine", "]", ")", "\n", "\n", "\n", "", "self", ".", "random_state", "=", "random_state", "\n", "if", "self", ".", "random_state", "is", "None", ":", "\n", "            ", "self", ".", "random_state", "=", "self", ".", "aggregate", ".", "random_state", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.plot_machines": [[290, 333], ["matplotlib.figure", "matplotlib.figure", "zip", "matplotlib.legend", "matplotlib.legend", "matplotlib.show", "matplotlib.show", "numpy.linspace", "visualisation.gen_machine_colors", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.xlabel", "matplotlib.xlabel", "len", "len", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.scatter", "len"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.gen_machine_colors"], ["", "", "def", "plot_machines", "(", "self", ",", "machines", "=", "None", ",", "colors", "=", "None", ",", "plot_indices", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Plot the results of the machines versus the actual answers (testing space).\n\n        Parameters\n        ----------\n        machines: list, optional\n            List of machines to plot.\n        colors: list, optional\n            Colors of machines.\n        plot_indices: boolean, optional.\n            Plots truth values against indices.\n\n        \"\"\"", "\n", "\n", "if", "machines", "is", "None", ":", "\n", "            ", "machines", "=", "self", ".", "estimators", "\n", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "(", "self", ".", "plot_size", ",", "self", ".", "plot_size", ")", ")", "\n", "\n", "if", "plot_indices", "or", "self", ".", "X_test", ".", "size", "!=", "self", ".", "y_test", ".", "size", ":", "\n", "            ", "linspace", "=", "np", ".", "linspace", "(", "0", ",", "len", "(", "self", ".", "y_test", ")", ",", "len", "(", "self", ".", "y_test", ")", ")", "\n", "\n", "", "if", "colors", "is", "None", ":", "\n", "            ", "colors", "=", "gen_machine_colors", "(", "only_colors", "=", "True", ",", "num_colors", "=", "len", "(", "machines", ")", "+", "1", ")", "\n", "\n", "", "if", "plot_indices", "or", "self", ".", "X_test", ".", "size", "!=", "self", ".", "y_test", ".", "size", ":", "\n", "            ", "plt", ".", "scatter", "(", "linspace", ",", "self", ".", "y_test", ",", "color", "=", "colors", "[", "0", "]", ",", "label", "=", "\"Truth\"", ")", "\n", "", "else", ":", "\n", "            ", "plt", ".", "scatter", "(", "self", ".", "X_test", ",", "self", ".", "y_test", ",", "color", "=", "colors", "[", "0", "]", ",", "label", "=", "\"Truth\"", ")", "\n", "\n", "", "for", "machine", ",", "color", "in", "zip", "(", "machines", ",", "colors", "[", "1", ":", "]", ")", ":", "\n", "            ", "if", "plot_indices", "or", "self", ".", "X_test", ".", "size", "!=", "self", ".", "y_test", ".", "size", ":", "\n", "                ", "plt", ".", "scatter", "(", "linspace", ",", "self", ".", "machine_test_results", "[", "machine", "]", ",", "color", "=", "color", ",", "label", "=", "machine", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "scatter", "(", "self", ".", "X_test", ",", "self", ".", "machine_test_results", "[", "machine", "]", ",", "color", "=", "color", ",", "label", "=", "machine", ")", "\n", "\n", "", "", "if", "plot_indices", ":", "\n", "            ", "plt", ".", "xlabel", "(", "\"Point Indice\"", ")", "\n", "\n", "", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "return", "plt", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.QQ": [[335, 365], ["matplotlib.figure", "matplotlib.figure", "matplotlib.gca", "matplotlib.gca", "math.fabs", "max", "matplotlib.gca.set_xlim", "matplotlib.gca.set_ylim", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.gca.plot", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.legend", "matplotlib.show", "matplotlib.show", "min", "max", "max", "matplotlib.gca.get_xlim", "matplotlib.gca.get_ylim", "min", "min", "min", "max", "min", "max", "min", "min", "max", "max", "min", "min", "max", "max"], "methods", ["None"], ["", "def", "QQ", "(", "self", ",", "machine", "=", "\"Cobra\"", ")", ":", "\n", "        ", "\"\"\"\n        Plots the machine results vs the actual results in the form of a QQ-plot.\n\n        Parameters\n        ----------\n        machine: string, optional\n            Name of machine to perform QQ-plot.\n        \"\"\"", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "self", ".", "plot_size", ",", "self", ".", "plot_size", ")", ")", "\n", "axes", "=", "plt", ".", "gca", "(", ")", "\n", "pred", "=", "self", ".", "machine_test_results", "[", "machine", "]", "\n", "\n", "# this is to make the plot look neater", "\n", "min_limits", "=", "math", ".", "fabs", "(", "min", "(", "min", "(", "pred", ")", ",", "min", "(", "self", ".", "y_test", ")", ")", ")", "\n", "max_limits", "=", "max", "(", "max", "(", "pred", ")", ",", "max", "(", "self", ".", "y_test", ")", ")", "\n", "axes", ".", "set_xlim", "(", "[", "min", "(", "min", "(", "pred", ")", ",", "min", "(", "self", ".", "y_test", ")", ")", "-", "min_limits", ",", "max", "(", "max", "(", "pred", ")", ",", "max", "(", "self", ".", "y_test", ")", ")", "+", "max_limits", "]", ")", "\n", "axes", ".", "set_ylim", "(", "[", "min", "(", "min", "(", "pred", ")", ",", "min", "(", "self", ".", "y_test", ")", ")", "-", "min_limits", ",", "max", "(", "max", "(", "pred", ")", ",", "max", "(", "self", ".", "y_test", ")", ")", "+", "max_limits", "]", ")", "\n", "\n", "# scatter the machine responses versus the actual y_test", "\n", "plt", ".", "scatter", "(", "self", ".", "y_test", ",", "pred", ",", "label", "=", "machine", ")", "\n", "axes", ".", "plot", "(", "axes", ".", "get_xlim", "(", ")", ",", "axes", ".", "get_ylim", "(", ")", ",", "ls", "=", "\"--\"", ",", "c", "=", "\".3\"", ")", "\n", "\n", "# labels", "\n", "plt", ".", "xlabel", "(", "'RESPONSES'", ")", "\n", "plt", ".", "ylabel", "(", "'PREDICTED'", ")", "\n", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "show", "(", ")", "\n", "return", "plt", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.boxplot": [[367, 551], ["seaborn.set", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.figure", "matplotlib.figure", "matplotlib.show", "matplotlib.show", "seaborn.boxplot", "matplotlib.title", "matplotlib.title", "seaborn.violinplot", "matplotlib.title", "matplotlib.title", "seaborn.boxplot", "seaborn.stripplot", "matplotlib.title", "matplotlib.title", "type", "range", "type", "range", "type", "range", "type", "range", "pycobra.cobra.Cobra", "sklearn.utils.shuffle", "pycobra.cobra.Cobra.fit", "pycobra.cobra.Cobra.split_data", "pycobra.cobra.Cobra.load_machine_predictions", "MSE[].append", "pandas.DataFrame", "pycobra.kernelcobra.KernelCobra", "sklearn.utils.shuffle", "pycobra.kernelcobra.KernelCobra.fit", "pycobra.kernelcobra.KernelCobra.split_data", "pycobra.kernelcobra.KernelCobra.load_machine_predictions", "MSE[].append", "pandas.DataFrame", "pycobra.ewa.Ewa", "sklearn.utils.shuffle", "pycobra.ewa.Ewa.fit", "pycobra.ewa.Ewa.split_data", "pycobra.ewa.Ewa.load_machine_weights", "sklearn.utils.shuffle", "MSE[].append", "pandas.DataFrame", "pycobra.classifiercobra.ClassifierCobra", "sklearn.utils.shuffle", "pycobra.classifiercobra.ClassifierCobra.fit", "pycobra.classifiercobra.ClassifierCobra.split_data", "pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "sklearn.utils.shuffle", "errors[].append", "pandas.DataFrame", "visualisation.Visualisation.estimators.items", "visualisation.Visualisation.aggregate.estimators_[].fit", "pycobra.cobra.Cobra.load_machine", "MSE[].append", "sklearn.metrics.mean_squared_error", "visualisation.Visualisation.estimators.items", "visualisation.Visualisation.aggregate.estimators_[].fit", "pycobra.kernelcobra.KernelCobra.load_machine", "MSE[].append", "sklearn.metrics.mean_squared_error", "visualisation.Visualisation.aggregate.estimators_.items", "visualisation.Visualisation.aggregate.estimators_[].fit", "pycobra.ewa.Ewa.load_machine", "MSE[].append", "sklearn.metrics.mean_squared_error", "visualisation.Visualisation.aggregate.estimators_.items", "visualisation.Visualisation.aggregate.estimators_[].fit", "pycobra.classifiercobra.ClassifierCobra.load_machine", "errors[].append", "visualisation.Visualisation.estimators[].fit", "visualisation.Visualisation.estimators[].fit", "sklearn.metrics.mean_squared_error", "pycobra.cobra.Cobra.predict", "visualisation.Visualisation.estimators[].fit", "visualisation.Visualisation.estimators[].fit", "sklearn.metrics.mean_squared_error", "pycobra.kernelcobra.KernelCobra.predict", "visualisation.Visualisation.estimators[].fit", "visualisation.Visualisation.estimators[].fit", "sklearn.metrics.mean_squared_error", "pycobra.ewa.Ewa.predict", "sklearn.metrics.accuracy_score", "type", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "type", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "type", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "visualisation.Visualisation.estimators[].predict", "sklearn.metrics.accuracy_score", "pycobra.classifiercobra.ClassifierCobra.predict", "visualisation.Visualisation.estimators[].predict"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.boxplot", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.boxplot", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.load_machine_weights", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "boxplot", "(", "self", ",", "reps", "=", "100", ",", "info", "=", "False", ",", "dataframe", "=", "None", ",", "kind", "=", "\"normal\"", ")", ":", "\n", "        ", "\"\"\"\n        Plots boxplots of machines.\n\n        Parameters\n        ----------\n        reps: int, optional\n            Number of times to repeat experiments for boxplot.\n\n        info: boolean, optional\n            Returns data \n\n        \"\"\"", "\n", "\n", "kwargs", "=", "self", ".", "kwargs", "\n", "if", "dataframe", "is", "None", ":", "\n", "            ", "if", "type", "(", "self", ".", "aggregate", ")", "is", "Cobra", ":", "\n", "\n", "                ", "MSE", "=", "{", "k", ":", "[", "]", "for", "k", ",", "v", "in", "self", ".", "estimators", ".", "items", "(", ")", "}", "\n", "MSE", "[", "\"Cobra\"", "]", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "reps", ")", ":", "\n", "                    ", "cobra", "=", "Cobra", "(", "epsilon", "=", "self", ".", "aggregate", ".", "epsilon", ")", "\n", "X", ",", "y", "=", "shuffle", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "cobra", ".", "fit", "(", "X", ",", "y", ",", "default", "=", "False", ")", "\n", "cobra", ".", "split_data", "(", "shuffle_data", "=", "True", ")", "\n", "\n", "for", "machine", "in", "self", ".", "aggregate", ".", "estimators_", ":", "\n", "                        ", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ".", "fit", "(", "cobra", ".", "X_k_", ",", "cobra", ".", "y_k_", ")", "\n", "cobra", ".", "load_machine", "(", "machine", ",", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ")", "\n", "\n", "", "cobra", ".", "load_machine_predictions", "(", ")", "\n", "\n", "for", "machine", "in", "self", ".", "estimators", ":", "\n", "                        ", "if", "\"Cobra\"", "in", "machine", ":", "\n", "                            ", "self", ".", "estimators", "[", "machine", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "", "else", ":", "\n", "                            ", "self", ".", "estimators", "[", "machine", "]", ".", "fit", "(", "cobra", ".", "X_k_", ",", "cobra", ".", "y_k_", ")", "\n", "", "try", ":", "\n", "                            ", "if", "type", "(", "self", ".", "estimators", "[", "machine", "]", ")", "==", "KernelCobra", ":", "\n", "                                ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ",", "bandwidth", "=", "kwargs", "[", "\"bandwidth_kernel\"", "]", ")", "\n", "", "else", ":", "\n", "                                ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "", "", "except", "KeyError", ":", "\n", "                            ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "\n", "", "MSE", "[", "machine", "]", ".", "append", "(", "mean_squared_error", "(", "self", ".", "y_test", ",", "preds", ")", ")", "\n", "\n", "", "MSE", "[", "\"Cobra\"", "]", ".", "append", "(", "mean_squared_error", "(", "self", ".", "y_test", ",", "cobra", ".", "predict", "(", "self", ".", "X_test", ")", ")", ")", "\n", "\n", "", "try", ":", "\n", "                    ", "dataframe", "=", "pd", ".", "DataFrame", "(", "data", "=", "MSE", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "return", "MSE", "\n", "\n", "", "", "if", "type", "(", "self", ".", "aggregate", ")", "is", "KernelCobra", ":", "\n", "\n", "                ", "MSE", "=", "{", "k", ":", "[", "]", "for", "k", ",", "v", "in", "self", ".", "estimators", ".", "items", "(", ")", "}", "\n", "MSE", "[", "\"KernalCobra\"", "]", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "reps", ")", ":", "\n", "                    ", "kernel", "=", "KernelCobra", "(", ")", "\n", "X", ",", "y", "=", "shuffle", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ")", "\n", "kernel", ".", "fit", "(", "X", ",", "y", ",", "default", "=", "False", ")", "\n", "kernel", ".", "split_data", "(", "shuffle_data", "=", "True", ")", "\n", "\n", "for", "machine", "in", "self", ".", "aggregate", ".", "estimators_", ":", "\n", "                        ", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ".", "fit", "(", "kernel", ".", "X_k_", ",", "kernel", ".", "y_k_", ")", "\n", "kernel", ".", "load_machine", "(", "machine", ",", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ")", "\n", "\n", "", "kernel", ".", "load_machine_predictions", "(", ")", "\n", "\n", "for", "machine", "in", "self", ".", "estimators", ":", "\n", "                        ", "if", "\"Cobra\"", "in", "machine", ":", "\n", "                            ", "self", ".", "estimators", "[", "machine", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "", "else", ":", "\n", "                            ", "self", ".", "estimators", "[", "machine", "]", ".", "fit", "(", "cobra", ".", "X_k_", ",", "cobra", ".", "y_k_", ")", "\n", "\n", "", "try", ":", "\n", "                            ", "if", "type", "(", "self", ".", "estimators", "[", "machine", "]", ")", "==", "KernelCobra", ":", "\n", "                                ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ",", "bandwidth", "=", "kwargs", "[", "\"bandwidth_kernel\"", "]", ")", "\n", "", "else", ":", "\n", "                                ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "", "", "except", "KeyError", ":", "\n", "                            ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "\n", "", "MSE", "[", "machine", "]", ".", "append", "(", "mean_squared_error", "(", "self", ".", "y_test", ",", "preds", ")", ")", "\n", "\n", "", "MSE", "[", "\"KernelCobra\"", "]", ".", "append", "(", "mean_squared_error", "(", "self", ".", "y_test", ",", "kernel", ".", "predict", "(", "self", ".", "X_test", ",", "bandwidth", "=", "kwargs", "[", "bandwidth_kernel", "]", ")", ")", ")", "\n", "\n", "", "try", ":", "\n", "                    ", "dataframe", "=", "pd", ".", "DataFrame", "(", "data", "=", "MSE", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "return", "MSE", "\n", "\n", "\n", "", "", "if", "type", "(", "self", ".", "aggregate", ")", "is", "Ewa", ":", "\n", "\n", "                ", "MSE", "=", "{", "k", ":", "[", "]", "for", "k", ",", "v", "in", "self", ".", "aggregate", ".", "estimators_", ".", "items", "(", ")", "}", "\n", "MSE", "[", "\"EWA\"", "]", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "reps", ")", ":", "\n", "                    ", "ewa", "=", "Ewa", "(", "random_state", "=", "self", ".", "random_state", ",", "beta", "=", "self", ".", "aggregate", ".", "beta", ")", "\n", "X", ",", "y", "=", "shuffle", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ",", "random_state", "=", "self", ".", "aggregate", ".", "random_state", ")", "\n", "ewa", ".", "fit", "(", "X", ",", "y", ",", "default", "=", "False", ")", "\n", "ewa", ".", "split_data", "(", "shuffle_data", "=", "True", ")", "\n", "\n", "for", "machine", "in", "self", ".", "estimators", ":", "\n", "                        ", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ".", "fit", "(", "ewa", ".", "X_k_", ",", "ewa", ".", "y_k_", ")", "\n", "ewa", ".", "load_machine", "(", "machine", ",", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ")", "\n", "\n", "", "ewa", ".", "load_machine_weights", "(", "self", ".", "aggregate", ".", "beta", ")", "\n", "X_test", ",", "y_test", "=", "shuffle", "(", "self", ".", "X_test", ",", "self", ".", "y_test", ",", "random_state", "=", "self", ".", "aggregate", ".", "random_state", ")", "\n", "for", "machine", "in", "self", ".", "estimators", ":", "\n", "                        ", "if", "\"EWA\"", "in", "machine", ":", "\n", "                            ", "self", ".", "estimators", "[", "machine", "]", ".", "fit", "(", "X", ",", "y", ")", "\n", "", "else", ":", "\n", "                            ", "self", ".", "estimators", "[", "machine", "]", ".", "fit", "(", "ewa", ".", "X_k_", ",", "ewa", ".", "y_k_", ")", "\n", "", "try", ":", "\n", "                            ", "if", "type", "(", "self", ".", "estimators", "[", "machine", "]", ")", "==", "KernelCobra", ":", "\n", "                                ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ",", "bandwidth", "=", "kwargs", "[", "\"bandwidth_kernel\"", "]", ")", "\n", "", "else", ":", "\n", "                                ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "", "", "except", "KeyError", ":", "\n", "                            ", "preds", "=", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_test", ")", "\n", "", "MSE", "[", "machine", "]", ".", "append", "(", "mean_squared_error", "(", "y_test", ",", "preds", ")", ")", "\n", "\n", "", "MSE", "[", "\"EWA\"", "]", ".", "append", "(", "mean_squared_error", "(", "y_test", ",", "ewa", ".", "predict", "(", "X_test", ")", ")", ")", "\n", "\n", "", "try", ":", "\n", "                    ", "dataframe", "=", "pd", ".", "DataFrame", "(", "data", "=", "MSE", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "return", "MSE", "\n", "\n", "", "", "if", "type", "(", "self", ".", "aggregate", ")", "is", "ClassifierCobra", ":", "\n", "\n", "                ", "errors", "=", "{", "k", ":", "[", "]", "for", "k", ",", "v", "in", "self", ".", "aggregate", ".", "estimators_", ".", "items", "(", ")", "}", "\n", "errors", "[", "\"ClassifierCobra\"", "]", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "reps", ")", ":", "\n", "                    ", "cc", "=", "ClassifierCobra", "(", "random_state", "=", "self", ".", "random_state", ")", "\n", "X", ",", "y", "=", "shuffle", "(", "self", ".", "aggregate", ".", "X_", ",", "self", ".", "aggregate", ".", "y_", ",", "random_state", "=", "self", ".", "aggregate", ".", "random_state", ")", "\n", "cc", ".", "fit", "(", "X", ",", "y", ",", "default", "=", "False", ")", "\n", "cc", ".", "split_data", "(", "shuffle_data", "=", "True", ")", "\n", "\n", "for", "machine", "in", "self", ".", "aggregate", ".", "estimators_", ":", "\n", "                        ", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ".", "fit", "(", "cc", ".", "X_k_", ",", "cc", ".", "y_k_", ")", "\n", "cc", ".", "load_machine", "(", "machine", ",", "self", ".", "aggregate", ".", "estimators_", "[", "machine", "]", ")", "\n", "\n", "", "cc", ".", "load_machine_predictions", "(", ")", "\n", "X_test", ",", "y_test", "=", "shuffle", "(", "self", ".", "X_test", ",", "self", ".", "y_test", ",", "random_state", "=", "self", ".", "aggregate", ".", "random_state", ")", "\n", "for", "machine", "in", "self", ".", "estimators", ":", "\n", "                        ", "errors", "[", "machine", "]", ".", "append", "(", "1", "-", "accuracy_score", "(", "y_test", ",", "self", ".", "estimators", "[", "machine", "]", ".", "predict", "(", "X_test", ")", ")", ")", "\n", "", "errors", "[", "\"ClassifierCobra\"", "]", ".", "append", "(", "1", "-", "accuracy_score", "(", "y_test", ",", "cc", ".", "predict", "(", "X_test", ")", ")", ")", "\n", "\n", "", "try", ":", "\n", "                    ", "dataframe", "=", "pd", ".", "DataFrame", "(", "data", "=", "errors", ")", "\n", "", "except", "ValueError", ":", "\n", "                    ", "return", "errors", "\n", "\n", "\n", "\n", "# code for different boxplot styles using the python graph gallery tutorial:", "\n", "# https://python-graph-gallery.com/39-hidden-data-under-boxplot/", "\n", "\n", "", "", "", "sns", ".", "set", "(", "style", "=", "\"whitegrid\"", ")", "\n", "\n", "if", "kind", "==", "\"normal\"", ":", "\n", "            ", "sns", ".", "boxplot", "(", "data", "=", "dataframe", ")", "\n", "plt", ".", "title", "(", "\"Boxplot\"", ")", "\n", "\n", "", "if", "kind", "==", "\"violin\"", ":", "\n", "            ", "sns", ".", "violinplot", "(", "data", "=", "dataframe", ")", "\n", "plt", ".", "title", "(", "\"Violin Plot\"", ")", "\n", "\n", "", "if", "kind", "==", "\"jitterplot\"", ":", "\n", "            ", "ax", "=", "sns", ".", "boxplot", "(", "data", "=", "dataframe", ")", "\n", "ax", "=", "sns", ".", "stripplot", "(", "data", "=", "dataframe", ",", "color", "=", "\"orange\"", ",", "jitter", "=", "0.2", ",", "size", "=", "2.5", ")", "\n", "plt", ".", "title", "(", "\"Boxplot with jitter\"", ",", "loc", "=", "\"left\"", ")", "\n", "\n", "", "plt", ".", "ylabel", "(", "\"Mean Squared Errors\"", ")", "\n", "plt", ".", "xlabel", "(", "\"Estimators\"", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "self", ".", "plot_size", ",", "self", ".", "plot_size", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n", "\n", "if", "info", ":", "\n", "            ", "return", "dataframe", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.indice_info": [[552, 594], ["pycobra.diagnostics.Diagnostics", "zip", "zip", "pycobra.diagnostics.Diagnostics.optimal_machines_grid", "pycobra.diagnostics.Diagnostics.optimal_machines"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_machines_grid", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.diagnostics.Diagnostics.optimal_machines"], ["", "", "def", "indice_info", "(", "self", ",", "X_test", "=", "None", ",", "y_test", "=", "None", ",", "epsilon", "=", "None", ",", "line_points", "=", "200", ")", ":", "\n", "        ", "\"\"\"\n        Method to return information about each indices (query) optimal machines for testing data.\n\n        Parameters\n        ----------\n        epsilon: float, optional\n            Epsilon value to use for diagnostics\n\n        line_points: int, optional\n            if epsilon is not passed, optimal epsilon is found per point.\n\n        Returns\n        -------\n\n        indice_info: dicitonary mapping indice to optimal machines.\n\n        MSE: dictionary mapping indice to mean squared error for optimal machines for that point.\n\n        \"\"\"", "\n", "\n", "if", "X_test", "is", "None", ":", "\n", "            ", "X_test", "=", "self", ".", "X_test", "\n", "", "if", "y_test", "is", "None", ":", "\n", "            ", "y_test", "=", "self", ".", "y_test", "\n", "\n", "", "indice", "=", "0", "\n", "indice_info", "=", "{", "}", "\n", "MSE", "=", "{", "}", "\n", "cobra_diagnostics", "=", "Diagnostics", "(", "aggregate", "=", "self", ".", "aggregate", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "if", "epsilon", "is", "None", ":", "\n", "            ", "for", "data_point", ",", "response", "in", "zip", "(", "X_test", ",", "y_test", ")", ":", "\n", "                ", "info", "=", "cobra_diagnostics", ".", "optimal_machines_grid", "(", "data_point", ",", "response", ",", "line_points", "=", "line_points", ")", "\n", "indice_info", "[", "indice", "]", ",", "MSE", "[", "indice", "]", "=", "info", "[", "0", "]", "[", "0", "]", ",", "info", "[", "1", "]", "\n", "indice", "+=", "1", "\n", "", "", "else", ":", "\n", "            ", "for", "data_point", ",", "response", "in", "zip", "(", "X_test", ",", "y_test", ")", ":", "\n", "                ", "info", "=", "cobra_diagnostics", ".", "optimal_machines", "(", "data_point", ",", "response", ",", "single", "=", "True", ",", "epsilon", "=", "epsilon", ")", "\n", "indice_info", "[", "indice", "]", ",", "MSE", "[", "indice", "]", "=", "info", "[", "0", "]", ",", "info", "[", "1", "]", "\n", "indice", "+=", "1", "\n", "\n", "", "", "return", "indice_info", ",", "MSE", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.color_cobra": [[596, 669], ["visualisation.Visualisation.indice_info", "matplotlib.ion", "matplotlib.ion", "matplotlib.subplots", "matplotlib.subplots", "ax.scatter", "visualisation.gen_machine_colors", "ax.set_title", "ax.scatter", "matplotlib.legend", "matplotlib.legend", "visualisation.gen_machine_colors", "zip", "matplotlib.ion", "matplotlib.ion", "matplotlib.subplots", "matplotlib.subplots", "ax.scatter", "ax.set_xlim", "ax.set_ylim", "ax.set_title", "visualisation.create_labels", "len", "ax.scatter"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.indice_info", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.gen_machine_colors", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.gen_machine_colors", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.create_labels"], ["", "def", "color_cobra", "(", "self", ",", "X_test", "=", "None", ",", "y_test", "=", "None", ",", "line_points", "=", "200", ",", "epsilon", "=", "None", ",", "indice_info", "=", "None", ",", "plot_machines", "=", "[", "\"ridge\"", ",", "\"lasso\"", ",", "\"random_forest\"", ",", "\"tree\"", "]", ",", "single", "=", "False", ",", "machine_colors", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Plot the input space and color query points based on the optimal machine used for that point.\n\n        Parameters\n        ----------\n        epsilon: float, optional\n            Epsilon value to use for diagnostics. Used to find indice_info if it isn't passed.\n\n        line_points: int, optional\n            if epsilon is not passed, optimal epsilon is found per point. Used to find indice_info if it isn't passed.\n\n        indice_info: dicitonary, optional\n            dictionary mapping indice to optimal machines.\n\n        plot_machines: list, optional\n            list of machines to be plotted.\n\n        single: bool, optional\n            plots a single plot with each machine combination.\n\n        machine_colors: dictionary, optional\n            Depending on the kind of coloring, a dictionary mapping machines to colors.\n\n        \"\"\"", "\n", "\n", "if", "indice_info", "is", "None", ":", "\n", "            ", "indice_info", "=", "self", ".", "indice_info", "(", "line_points", ",", "epsilon", ")", "\n", "\n", "", "if", "X_test", "is", "None", ":", "\n", "            ", "X_test", "=", "self", ".", "X_test", "\n", "", "if", "y_test", "is", "None", ":", "\n", "            ", "y_test", "=", "self", ".", "y_test", "\n", "# we want to plot only two columns", "\n", "", "data_1", "=", "X_test", "[", ":", ",", "0", "]", "\n", "data_2", "=", "X_test", "[", ":", ",", "1", "]", "\n", "\n", "if", "single", ":", "\n", "            ", "if", "machine_colors", "is", "None", ":", "\n", "                ", "machine_colors", "=", "gen_machine_colors", "(", "indice_info", "=", "indice_info", ")", "\n", "", "plt", ".", "ion", "(", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plot", "=", "ax", ".", "scatter", "(", "[", "]", ",", "[", "]", ")", "\n", "for", "indice", "in", "indice_info", ":", "\n", "\n", "                ", "ax", ".", "set_title", "(", "\"All Machines\"", ")", "\n", "ax", ".", "scatter", "(", "data_1", "[", "indice", "]", ",", "data_2", "[", "indice", "]", ",", "color", "=", "machine_colors", "[", "indice_info", "[", "indice", "]", "]", ",", "label", "=", "create_labels", "(", "indice_info", "[", "indice", "]", ")", ")", "\n", "\n", "", "try", ":", "\n", "                ", "plt", ".", "legend", "(", "bbox_to_anchor", "=", "(", "1.05", ",", "1", ")", ",", "loc", "=", "2", ",", "borderaxespad", "=", "0.", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "return", "ax", "\n", "\n", "", "", "if", "not", "single", ":", "\n", "            ", "if", "machine_colors", "is", "None", ":", "\n", "                ", "machine_colors", "=", "{", "}", "\n", "colors", "=", "gen_machine_colors", "(", "only_colors", "=", "True", ",", "num_colors", "=", "len", "(", "plot_machines", ")", ")", "\n", "for", "machine", ",", "color", "in", "zip", "(", "plot_machines", ",", "colors", ")", ":", "\n", "                    ", "machine_colors", "[", "machine", "]", "=", "color", "\n", "\n", "", "", "for", "machine", "in", "plot_machines", ":", "\n", "                ", "plt", ".", "ion", "(", ")", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plot", "=", "ax", ".", "scatter", "(", "[", "]", ",", "[", "]", ")", "\n", "# set boundaries based on the data", "\n", "ax", ".", "set_xlim", "(", "-", "2", ",", "2", ")", "\n", "ax", ".", "set_ylim", "(", "-", "2", ",", "2", ")", "\n", "ax", ".", "set_title", "(", "machine", ")", "\n", "for", "indice", "in", "indice_info", ":", "\n", "                    ", "if", "machine", "in", "indice_info", "[", "indice", "]", ":", "\n", "                        ", "ax", ".", "scatter", "(", "data_1", "[", "indice", "]", ",", "data_2", "[", "indice", "]", ",", "color", "=", "machine_colors", "[", "machine", "]", ")", "\n", "\n", "", "", "", "", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.voronoi": [[670, 775], ["numpy.hstack", "scipy.spatial.Voronoi", "visualisation.voronoi_finite_polygons_2d", "visualisation.Visualisation.indice_info", "matplotlib.subplots", "matplotlib.subplots", "ax.scatter", "ax.set_title", "ax.axis", "matplotlib.xlim", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.ylim", "numpy.reshape", "numpy.reshape", "matplotlib.subplots", "matplotlib.subplots", "ax.scatter", "ax.set_title", "ax.axis", "matplotlib.xlim", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.ylim", "visualisation.gen_machine_colors", "ax.plot", "ax.fill", "matplotlib.legend", "matplotlib.legend", "ax.plot", "len", "len", "numpy.linspace", "min", "numpy.where", "zip", "visualisation.create_labels", "min", "max", "ax.fill", "ax.fill", "ax.fill", "MSE.values", "MSE.values", "abs", "zip", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.voronoi_finite_polygons_2d", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.Visualisation.indice_info", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.gen_machine_colors", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.create_labels"], ["", "def", "voronoi", "(", "self", ",", "X_test", "=", "None", ",", "y_test", "=", "None", ",", "line_points", "=", "200", ",", "epsilon", "=", "None", ",", "indice_info", "=", "None", ",", "MSE", "=", "None", ",", "plot_machines", "=", "[", "\"ridge\"", ",", "\"lasso\"", ",", "\"random_forest\"", ",", "\"tree\"", "]", ",", "machine_colors", "=", "None", ",", "gradient", "=", "False", ",", "single", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Plot the input space and color query points as a Voronoi Tesselation based on the optimal machine used for that point.\n\n        Parameters\n        ----------\n        epsilon: float, optional\n            Epsilon value to use for diagnostics. Used to find indice_info if it isn't passed.\n     \n        line_points: int, optional\n            if epsilon is not passed, optimal epsilon is found per point. Used to find indice_info if it isn't passed.\n\n        indice_info: dicitonary, optional\n            dictionary mapping indice to optimal machines.\n      \n        MSE: dictionary, optional\n            dictionary mapping indice to mean-squared error for optimal machines\n\n        plot_machines: list, optional\n            list of machines to be plotted.\n\n        single: bool, optional\n            plots a single plot with each machine combination.\n\n        gradient: bool, optional\n            instead of aggregating optimal machines, plots a colored plot for each machine,\n            shaded according to the mean-squared error of that \"region\"\n\n        machine_colors: dictionary, optional\n            Depending on the kind of coloring, a dictionary mapping machines to colors.\n        \"\"\"", "\n", "\n", "if", "X_test", "is", "None", ":", "\n", "            ", "X_test", "=", "self", ".", "X_test", "\n", "", "if", "y_test", "is", "None", ":", "\n", "            ", "y_test", "=", "self", ".", "y_test", "\n", "\n", "", "if", "indice_info", "is", "None", ":", "\n", "            ", "indice_info", ",", "MSE", "=", "self", ".", "indice_info", "(", "line_points", ",", "epsilon", ")", "\n", "\n", "# passing input space to set up voronoi regions.", "\n", "", "points", "=", "np", ".", "hstack", "(", "(", "np", ".", "reshape", "(", "X_test", "[", ":", ",", "0", "]", ",", "(", "len", "(", "X_test", "[", ":", ",", "0", "]", ")", ",", "1", ")", ")", ",", "np", ".", "reshape", "(", "X_test", "[", ":", ",", "1", "]", ",", "(", "len", "(", "X_test", "[", ":", ",", "1", "]", ")", ",", "1", ")", ")", ")", ")", "\n", "vor", "=", "Voronoi", "(", "points", ")", "\n", "# use helper Voronoi", "\n", "regions", ",", "vertices", "=", "voronoi_finite_polygons_2d", "(", "vor", ")", "\n", "\n", "# # colorize", "\n", "if", "not", "single", ":", "\n", "            ", "for", "machine", "in", "plot_machines", ":", "\n", "                ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plot", "=", "ax", ".", "scatter", "(", "[", "]", ",", "[", "]", ")", "\n", "ax", ".", "set_title", "(", "machine", ")", "\n", "indice", "=", "0", "\n", "for", "region", "in", "regions", ":", "\n", "                    ", "ax", ".", "plot", "(", "X_test", "[", ":", ",", "0", "]", "[", "indice", "]", ",", "X_test", "[", ":", ",", "1", "]", "[", "indice", "]", ",", "'ko'", ")", "\n", "polygon", "=", "vertices", "[", "region", "]", "\n", "if", "gradient", "is", "True", "and", "MSE", "is", "not", "None", ":", "\n", "# we find closest index from range to give gradient value", "\n", "                        ", "mse_range", "=", "np", ".", "linspace", "(", "min", "(", "MSE", ".", "values", "(", ")", ")", ",", "max", "(", "MSE", ".", "values", "(", ")", ")", ",", "10", ")", "\n", "num", "=", "min", "(", "mse_range", ",", "key", "=", "lambda", "x", ":", "abs", "(", "x", "-", "MSE", "[", "indice", "]", ")", ")", "\n", "index", "=", "np", ".", "where", "(", "mse_range", "==", "num", ")", "\n", "alpha", "=", "index", "[", "0", "]", "[", "0", "]", "/", "10.0", "+", "0.2", "\n", "if", "alpha", ">", "1.0", ":", "\n", "                            ", "alpha", "=", "1.0", "\n", "# we fill the polygon with the appropriate gradient", "\n", "", "if", "machine", "in", "indice_info", "[", "indice", "]", ":", "\n", "                            ", "ax", ".", "fill", "(", "*", "zip", "(", "*", "polygon", ")", ",", "alpha", "=", "alpha", ",", "color", "=", "'r'", ")", "\n", "", "", "else", ":", "\n", "# if it isn't gradient based we just color red or blue depending on whether that point uses the machine in question", "\n", "                        ", "if", "machine", "in", "indice_info", "[", "indice", "]", ":", "\n", "                            ", "ax", ".", "fill", "(", "*", "zip", "(", "*", "polygon", ")", ",", "alpha", "=", "0.4", ",", "color", "=", "'r'", ",", "label", "=", "\"\"", ")", "\n", "", "else", ":", "\n", "                            ", "ax", ".", "fill", "(", "*", "zip", "(", "*", "polygon", ")", ",", "alpha", "=", "0.4", ",", "color", "=", "'b'", ",", "label", "=", "\"\"", ")", "\n", "", "", "indice", "+=", "1", "\n", "\n", "", "ax", ".", "axis", "(", "'equal'", ")", "\n", "plt", ".", "xlim", "(", "vor", ".", "min_bound", "[", "0", "]", "-", "0.1", ",", "vor", ".", "max_bound", "[", "0", "]", "+", "0.1", ")", "\n", "plt", ".", "ylim", "(", "vor", ".", "min_bound", "[", "1", "]", "-", "0.1", ",", "vor", ".", "max_bound", "[", "1", "]", "+", "0.1", ")", "\n", "\n", "", "return", "vor", "\n", "\n", "", "if", "single", ":", "\n", "\n", "            ", "if", "machine_colors", "is", "None", ":", "\n", "                ", "machine_colors", "=", "gen_machine_colors", "(", "indice_info", "=", "indice_info", ")", "\n", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plot", "=", "ax", ".", "scatter", "(", "[", "]", ",", "[", "]", ")", "\n", "ax", ".", "set_title", "(", "\"All Machines\"", ")", "\n", "indice", "=", "0", "\n", "for", "region", "in", "regions", ":", "\n", "\n", "                ", "ax", ".", "plot", "(", "X_test", "[", ":", ",", "0", "]", "[", "indice", "]", ",", "X_test", "[", ":", ",", "1", "]", "[", "indice", "]", ",", "'ko'", ")", "\n", "polygon", "=", "vertices", "[", "region", "]", "\n", "ax", ".", "fill", "(", "*", "zip", "(", "*", "polygon", ")", ",", "alpha", "=", "0.2", ",", "color", "=", "machine_colors", "[", "indice_info", "[", "indice", "]", "]", ",", "label", "=", "create_labels", "(", "indice_info", "[", "indice", "]", ")", ")", "\n", "indice", "+=", "1", "\n", "\n", "", "ax", ".", "axis", "(", "'equal'", ")", "\n", "plt", ".", "xlim", "(", "vor", ".", "min_bound", "[", "0", "]", "-", "0.1", ",", "vor", ".", "max_bound", "[", "0", "]", "+", "0.1", ")", "\n", "plt", ".", "ylim", "(", "vor", ".", "min_bound", "[", "1", "]", "-", "0.1", ",", "vor", ".", "max_bound", "[", "1", "]", "+", "0.1", ")", "\n", "try", ":", "\n", "                ", "plt", ".", "legend", "(", "bbox_to_anchor", "=", "(", "1.05", ",", "1", ")", ",", "loc", "=", "2", ",", "borderaxespad", "=", "0.", ")", "\n", "", "except", "ValueError", ":", "\n", "                ", "return", "vor", "\n", "", "return", "vor", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.create_labels": [[30, 51], ["None"], "function", ["None"], ["def", "create_labels", "(", "indice_info", ")", ":", "\n", "    ", "\"\"\"\n    Helper method to create labels for plotting.\n\n    Parameters\n    ----------\n\n    indice_info: list of strings\n        List of machine names\n\n    Return\n    ------\n\n    label: string\n        Serves as a label during plotting.\n    \"\"\"", "\n", "\n", "label", "=", "\"\"", "\n", "for", "machine", "in", "indice_info", ":", "\n", "        ", "label", "=", "machine", "+", "\" + \"", "+", "label", "\n", "", "return", "label", "[", ":", "-", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.gen_machine_colors": [[53, 133], ["dict", "sorted", "list", "random.sample", "zip", "random.sample", "set", "zip", "len", "indice_info.values", "len", "len", "int", "tuple", "random.sample.items", "int", "mcolors.rgb_to_hsv", "len", "len", "len", "mcolors.to_rgba"], "function", ["None"], ["", "def", "gen_machine_colors", "(", "only_colors", "=", "False", ",", "num_colors", "=", "None", ",", "indice_info", "=", "None", ",", "rgb", "=", "False", ",", "plot_machines", "=", "None", ",", "colors", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Helper method to create a machine combinations to color dictionary, or a list of colors.\n\n    Parameters\n    ----------\n\n    indice_info: dictionary, optional\n        Dictionary which is a result of running pycobra.visualisation.indice_info. Maps indices to combinations of machines.\n\n    only_colors: bool, optional\n        Option to return only a list of colors\n\n    num_colors: int, optional\n        Number of colors to be returned if using only_colors\n\n    rgb : bool, optional\n        Creates dictionary based on machine used and r, g, b, a scheme.\n\n    plot_machines: list of strings, optional\n        List of machines to use in rgb coloring.\n\n    colors: list of strings, optional\n        List of colors to be used for pairing with machine_combinations\n\n    Return\n    ------\n\n    machine_colors: dictionary\n        Dictionary mapping machine combinations and color.\n    \"\"\"", "\n", "\n", "# note: for default colors to be assigned, the latest version of matplotlib is needed.", "\n", "# the code below is taken from the colors example:", "\n", "from", "matplotlib", "import", "colors", "as", "mcolors", "\n", "colors", "=", "dict", "(", "mcolors", ".", "BASE_COLORS", ",", "**", "mcolors", ".", "CSS4_COLORS", ")", "\n", "# Sort colors by hue, saturation, value and name.", "\n", "by_hsv", "=", "sorted", "(", "(", "tuple", "(", "mcolors", ".", "rgb_to_hsv", "(", "mcolors", ".", "to_rgba", "(", "color", ")", "[", ":", "3", "]", ")", ")", ",", "name", ")", "\n", "for", "name", ",", "color", "in", "colors", ".", "items", "(", ")", ")", "\n", "sorted_names", "=", "[", "name", "for", "hsv", ",", "name", "in", "by_hsv", "]", "\n", "\n", "# if we need only as many colors as individual machine", "\n", "if", "only_colors", ":", "\n", "# make the sorted names list equal to in size as the machine combinations", "\n", "# we do this by first picking up equally spaced out colors, then randonly picking out the right amount", "\n", "        ", "sorted_names", "=", "sorted_names", "[", "0", ":", ":", "int", "(", "len", "(", "sorted_names", ")", "/", "num_colors", ")", "]", "\n", "return", "random", ".", "sample", "(", "sorted_names", ",", "num_colors", ")", "\n", "\n", "", "machine_combinations", "=", "list", "(", "set", "(", "indice_info", ".", "values", "(", ")", ")", ")", "\n", "machine_colors", "=", "{", "}", "\n", "\n", "if", "rgb", ":", "\n", "        ", "for", "indice", "in", "indice_info", ":", "\n", "            ", "r", ",", "g", ",", "b", ",", "a", "=", "0", ",", "0", ",", "0", ",", "0.4", "\n", "if", "plot_machines", "[", "0", "]", "in", "indice_info", "[", "indice", "]", ":", "\n", "                ", "r", "=", "1", "\n", "", "if", "plot_machines", "[", "1", "]", "in", "indice_info", "[", "indice", "]", ":", "\n", "                ", "g", "=", "1", "\n", "", "if", "plot_machines", "[", "2", "]", "in", "indice_info", "[", "indice", "]", ":", "\n", "                ", "b", "=", "1", "\n", "", "if", "plot_machines", "[", "3", "]", "in", "indice_info", "[", "indice", "]", ":", "\n", "                ", "a", "=", "1", "\n", "", "if", "(", "r", ",", "g", ",", "b", ")", "==", "(", "1", ",", "1", ",", "1", ")", ":", "\n", "                ", "r", ",", "g", ",", "b", "=", "0", ",", "0", ",", "0", "\n", "", "machine_colors", "[", "indice_info", "[", "indice", "]", "]", "=", "(", "r", ",", "g", ",", "b", ",", "a", ")", "\n", "", "return", "machine_colors", "\n", "\n", "# if it isn't rgb, let's pair each unique machine with a color provided", "\n", "", "if", "colors", "is", "not", "None", "and", "len", "(", "machine_combinations", ")", "==", "len", "(", "colors", ")", ":", "\n", "        ", "for", "machine", ",", "color", "in", "zip", "(", "machine_combinations", ",", "colors", ")", ":", "\n", "            ", "machine_colors", "[", "machine", "]", "=", "color", "\n", "", "return", "machine_colors", "\n", "\n", "# if it's none of the above options, we create colors similar to the only colors option.", "\n", "", "sorted_names", "=", "sorted_names", "[", "0", ":", ":", "int", "(", "len", "(", "sorted_names", ")", "/", "len", "(", "machine_combinations", ")", ")", "]", "\n", "colors", "=", "random", ".", "sample", "(", "sorted_names", ",", "len", "(", "machine_combinations", ")", ")", "\n", "\n", "for", "machine", ",", "color", "in", "zip", "(", "machine_combinations", ",", "colors", ")", ":", "\n", "        ", "machine_colors", "[", "machine", "]", "=", "color", "\n", "", "return", "machine_colors", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.visualisation.voronoi_finite_polygons_2d": [[135, 218], ["vor.vertices.tolist", "vor.points.mean", "zip", "enumerate", "ValueError", "all_ridges.setdefault().append", "all_ridges.setdefault().append", "all", "numpy.asarray", "np.asarray.mean", "numpy.arctan2", "new_regions.append", "numpy.asarray", "vor.points.ptp().max", "new_regions.append", "numpy.linalg.norm", "numpy.array", "vor.points[].mean", "new_region.append", "vor.vertices.tolist.append", "numpy.array", "new_region.tolist", "all_ridges.setdefault", "all_ridges.setdefault", "numpy.sign", "len", "far_point.tolist", "numpy.argsort", "vor.points.ptp", "numpy.dot"], "function", ["None"], ["", "def", "voronoi_finite_polygons_2d", "(", "vor", ",", "radius", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Code originally written by pv: https://gist.github.com/pv/8036995.\n    Helper method for voronoi.\n    Reconstruct infinite voronoi regions in a 2D diagram to finite\n    regions.\n\n    Parameters\n    ----------\n    vor : Voronoi\n        Input diagram\n    radius : float, optional\n        Distance to 'points at infinity'.\n\n    Returns\n    -------\n    regions : list of tuples\n        Indices of vertices in each revised Voronoi regions.\n    vertices : list of tuples\n        Coordinates for revised Voronoi vertices. Same as coordinates\n        of input vertices, with 'points at infinity' appended to the\n        end.\n\n    \"\"\"", "\n", "\n", "if", "vor", ".", "points", ".", "shape", "[", "1", "]", "!=", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\"Requires 2D input\"", ")", "\n", "\n", "", "new_regions", "=", "[", "]", "\n", "new_vertices", "=", "vor", ".", "vertices", ".", "tolist", "(", ")", "\n", "\n", "center", "=", "vor", ".", "points", ".", "mean", "(", "axis", "=", "0", ")", "\n", "if", "radius", "is", "None", ":", "\n", "        ", "radius", "=", "vor", ".", "points", ".", "ptp", "(", ")", ".", "max", "(", ")", "*", "2", "\n", "\n", "# Construct a map containing all ridges for a given point", "\n", "", "all_ridges", "=", "{", "}", "\n", "for", "(", "p1", ",", "p2", ")", ",", "(", "v1", ",", "v2", ")", "in", "zip", "(", "vor", ".", "ridge_points", ",", "vor", ".", "ridge_vertices", ")", ":", "\n", "        ", "all_ridges", ".", "setdefault", "(", "p1", ",", "[", "]", ")", ".", "append", "(", "(", "p2", ",", "v1", ",", "v2", ")", ")", "\n", "all_ridges", ".", "setdefault", "(", "p2", ",", "[", "]", ")", ".", "append", "(", "(", "p1", ",", "v1", ",", "v2", ")", ")", "\n", "\n", "# Reconstruct infinite regions", "\n", "", "for", "p1", ",", "region", "in", "enumerate", "(", "vor", ".", "point_region", ")", ":", "\n", "        ", "vertices", "=", "vor", ".", "regions", "[", "region", "]", "\n", "\n", "if", "all", "(", "[", "v", ">=", "0", "for", "v", "in", "vertices", "]", ")", ":", "\n", "# finite region", "\n", "            ", "new_regions", ".", "append", "(", "vertices", ")", "\n", "continue", "\n", "\n", "# reconstruct a non-finite region", "\n", "", "ridges", "=", "all_ridges", "[", "p1", "]", "\n", "new_region", "=", "[", "v", "for", "v", "in", "vertices", "if", "v", ">=", "0", "]", "\n", "\n", "for", "p2", ",", "v1", ",", "v2", "in", "ridges", ":", "\n", "            ", "if", "v2", "<", "0", ":", "\n", "                ", "v1", ",", "v2", "=", "v2", ",", "v1", "\n", "", "if", "v1", ">=", "0", ":", "\n", "# finite ridge: already in the region", "\n", "                ", "continue", "\n", "\n", "# Compute the missing endpoint of an infinite ridge", "\n", "", "t", "=", "vor", ".", "points", "[", "p2", "]", "-", "vor", ".", "points", "[", "p1", "]", "# tangent", "\n", "t", "/=", "np", ".", "linalg", ".", "norm", "(", "t", ")", "\n", "n", "=", "np", ".", "array", "(", "[", "-", "t", "[", "1", "]", ",", "t", "[", "0", "]", "]", ")", "# normal", "\n", "\n", "midpoint", "=", "vor", ".", "points", "[", "[", "p1", ",", "p2", "]", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "direction", "=", "np", ".", "sign", "(", "np", ".", "dot", "(", "midpoint", "-", "center", ",", "n", ")", ")", "*", "n", "\n", "far_point", "=", "vor", ".", "vertices", "[", "v2", "]", "+", "direction", "*", "radius", "\n", "\n", "new_region", ".", "append", "(", "len", "(", "new_vertices", ")", ")", "\n", "new_vertices", ".", "append", "(", "far_point", ".", "tolist", "(", ")", ")", "\n", "\n", "# sort region counterclockwise", "\n", "", "vs", "=", "np", ".", "asarray", "(", "[", "new_vertices", "[", "v", "]", "for", "v", "in", "new_region", "]", ")", "\n", "c", "=", "vs", ".", "mean", "(", "axis", "=", "0", ")", "\n", "angles", "=", "np", ".", "arctan2", "(", "vs", "[", ":", ",", "1", "]", "-", "c", "[", "1", "]", ",", "vs", "[", ":", ",", "0", "]", "-", "c", "[", "0", "]", ")", "\n", "new_region", "=", "np", ".", "array", "(", "new_region", ")", "[", "np", ".", "argsort", "(", "angles", ")", "]", "\n", "\n", "# finish", "\n", "new_regions", ".", "append", "(", "new_region", ".", "tolist", "(", ")", ")", "\n", "\n", "", "return", "new_regions", ",", "np", ".", "asarray", "(", "new_vertices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.__init__": [[49, 52], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "random_state", "=", "None", ",", "machine_list", "=", "'basic'", ")", ":", "\n", "        ", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "machine_list", "=", "machine_list", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.fit": [[53, 96], ["sklearn.utils.validation.check_X_y", "kernelcobra.KernelCobra.split_data", "kernelcobra.KernelCobra.load_default", "kernelcobra.KernelCobra.load_machine_predictions"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "default", "=", "True", ",", "X_k", "=", "None", ",", "X_l", "=", "None", ",", "y_k", "=", "None", ",", "y_l", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        X: array-like, [n_samples, n_features]\n            Training data which will be used to create the COBRA aggregate.\n\n        y: array-like, shape = [n_samples]\n            Target values used to train the machines used in the aggregation.\n\n        default: bool, optional\n            If set as true then sets up COBRA with default machines and splitting.\n\n        X_k : shape = [n_samples, n_features]\n            Training data which is used to train the machines used in the aggregation.\n            Can be loaded directly into COBRA; if not, the split_data method is used as default.\n\n        y_k : array-like, shape = [n_samples]\n            Target values used to train the machines used in the aggregation.\n\n        X_l : shape = [n_samples, n_features]\n            Training data which is used to form the aggregate.\n            Can be loaded directly into COBRA; if not, the split_data method is used as default.\n\n        y_l : array-like, shape = [n_samples]\n            Target values which are actually used to form the aggregate.\n        \"\"\"", "\n", "\n", "X", ",", "y", "=", "check_X_y", "(", "X", ",", "y", ")", "\n", "self", ".", "X_", "=", "X", "\n", "self", ".", "y_", "=", "y", "\n", "self", ".", "X_k_", "=", "X_k", "\n", "self", ".", "X_l_", "=", "X_l", "\n", "self", ".", "y_k_", "=", "y_k", "\n", "self", ".", "y_l_", "=", "y_l", "\n", "self", ".", "estimators_", "=", "{", "}", "\n", "# set-up COBRA with default machines", "\n", "if", "default", ":", "\n", "            ", "self", ".", "split_data", "(", ")", "\n", "self", ".", "load_default", "(", "machine_list", "=", "self", ".", "machine_list", ")", "\n", "self", ".", "load_machine_predictions", "(", ")", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.pred": [[98, 147], ["numpy.zeros", "numpy.sum", "len", "kernelcobra.KernelCobra.estimators_[].predict", "numpy.ndenumerate", "numpy.nan_to_num", "numpy.nan_to_num", "numpy.multiply", "numpy.divide", "numpy.exp", "numpy.divide", "math.fabs", "kernel", "numpy.sum", "numpy.divide", "numpy.sum", "metric", "kernel", "kernel", "numpy.sum", "metric", "kernel"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "pred", "(", "self", ",", "X", ",", "kernel", "=", "None", ",", "metric", "=", "None", ",", "bandwidth", "=", "1", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Performs the Kernel-COBRA aggregation scheme, used in predict method.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        kernel: function, optional\n            kernel refers to the kernel method which we wish to use to perform the aggregation.\n\n        metric: function, optional\n            metric refers to the metric method which we wish to use to perform the aggregation.\n\n        bandwidth: float, optional\n            Bandwidth for the deafult kernel value (gaussian), and is set to 1.\n\n        kwargs requires you to pass arguments with \"kernel_params\" and \"metric_params\", if the custom kernel or metric\n        has more paramteres.        \n\n        Returns\n        -------\n        avg: prediction\n\n        \"\"\"", "\n", "\n", "a", "=", "np", ".", "zeros", "(", "len", "(", "self", ".", "X_l_", ")", ")", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "            ", "val", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "X", ")", "\n", "for", "index", ",", "value", "in", "np", ".", "ndenumerate", "(", "self", ".", "machine_predictions_", "[", "machine", "]", ")", ":", "\n", "                ", "if", "metric", "is", "not", "None", ":", "\n", "                    ", "try", ":", "\n", "                        ", "a", "[", "index", "]", "+=", "metric", "(", "value", ",", "val", ",", "kwargs", "[", "\"metric_params\"", "]", ")", "\n", "", "except", "KeyError", ":", "\n", "                        ", "a", "[", "index", "]", "+=", "metric", "(", "value", ",", "val", ")", "\n", "", "", "else", ":", "\n", "                    ", "a", "[", "index", "]", "+=", "math", ".", "fabs", "(", "value", "-", "val", ")", "\n", "\n", "# normalise the array", "\n", "", "", "", "if", "kernel", "is", "not", "None", ":", "\n", "            ", "try", ":", "\n", "                ", "a", "=", "np", ".", "divide", "(", "kernel", "(", "a", ",", "kwargs", "[", "\"kernel_params\"", "]", ")", ",", "np", ".", "sum", "(", "kernel", "(", "a", ",", "kwargs", "[", "\"kernel_params\"", "]", ")", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "a", "=", "np", ".", "divide", "(", "kernel", "(", "a", ")", ",", "np", ".", "sum", "(", "kernel", "(", "a", ")", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "exp", "=", "np", ".", "nan_to_num", "(", "np", ".", "exp", "(", "-", "bandwidth", "*", "a", ")", ")", "\n", "a", "=", "np", ".", "nan_to_num", "(", "np", ".", "divide", "(", "exp", ",", "np", ".", "sum", "(", "exp", ")", ")", ")", "\n", "\n", "", "return", "np", ".", "sum", "(", "np", ".", "multiply", "(", "self", ".", "y_l_", ",", "a", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.predict": [[149, 188], ["sklearn.utils.validation.check_array", "numpy.zeros", "kernelcobra.KernelCobra.pred", "len", "kernelcobra.KernelCobra.pred", "sklearn.utils.validation.check_array.reshape", "vector.reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred"], ["", "def", "predict", "(", "self", ",", "X", ",", "kernel", "=", "None", ",", "metric", "=", "None", ",", "bandwidth", "=", "1", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Performs the Kernel-COBRA aggregation scheme, calls pred.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        kernel: function, optional\n            kernel refers to the kernel method which we wish to use to perform the aggregation.\n\n        metric: function, optional\n            metric refers to the metric method which we wish to use to perform the aggregation.\n\n        bandwidth: float, optional\n            Bandwidth for the deafult kernel value (gaussian), and is set to 1.\n\n        kwargs requires you to pass arguments with \"kernel_params\" and \"metric_params\", if the custom kernel or metric\n        has more paramteres.        \n\n        Returns\n        -------\n        avg: prediction\n\n        \"\"\"", "\n", "\n", "X", "=", "check_array", "(", "X", ")", "\n", "\n", "if", "X", ".", "ndim", "==", "1", ":", "\n", "            ", "return", "self", ".", "pred", "(", "X", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "result", "=", "np", ".", "zeros", "(", "len", "(", "X", ")", ")", "\n", "avg_points", "=", "0", "\n", "index", "=", "0", "\n", "for", "vector", "in", "X", ":", "\n", "            ", "result", "[", "index", "]", "=", "self", ".", "pred", "(", "vector", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "kernel", "=", "kernel", ",", "metric", "=", "metric", ",", "bandwidth", "=", "bandwidth", ",", "**", "kwargs", ")", "\n", "index", "+=", "1", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.split_data": [[190, 230], ["sklearn.utils.shuffle", "int", "int", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "split_data", "(", "self", ",", "k", "=", "None", ",", "l", "=", "None", ",", "shuffle_data", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Split the data into different parts for training machines and for aggregation.\n\n        Parameters\n        ----------\n        k : int, optional\n            k is the number of points used to train the machines.\n            Those are the first k points of the data provided.\n\n        l: int, optional\n            l is the number of points used to form the COBRA aggregate.\n\n        shuffle: bool, optional\n            Boolean value to decide to shuffle the data before splitting.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "if", "shuffle_data", ":", "\n", "            ", "self", ".", "X_", ",", "self", ".", "y_", "=", "shuffle", "(", "self", ".", "X_", ",", "self", ".", "y_", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "", "if", "k", "is", "None", "and", "l", "is", "None", ":", "\n", "            ", "k", "=", "int", "(", "len", "(", "self", ".", "X_", ")", "/", "2", ")", "\n", "l", "=", "int", "(", "len", "(", "self", ".", "X_", ")", ")", "\n", "\n", "", "if", "k", "is", "not", "None", "and", "l", "is", "None", ":", "\n", "            ", "l", "=", "len", "(", "self", ".", "X_", ")", "-", "k", "\n", "\n", "", "if", "l", "is", "not", "None", "and", "k", "is", "None", ":", "\n", "            ", "k", "=", "len", "(", "self", ".", "X_", ")", "-", "l", "\n", "\n", "", "self", ".", "X_k_", "=", "self", ".", "X_", "[", ":", "k", "]", "\n", "self", ".", "X_l_", "=", "self", ".", "X_", "[", "k", ":", "l", "]", "\n", "self", ".", "y_k_", "=", "self", ".", "y_", "[", ":", "k", "]", "\n", "self", ".", "y_l_", "=", "self", ".", "y_", "[", "k", ":", "l", "]", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.load_default": [[232, 269], ["sklearn.linear_model.LassoCV().fit", "sklearn.tree.DecisionTreeRegressor().fit", "sklearn.linear_model.RidgeCV().fit", "sklearn.ensemble.RandomForestRegressor().fit", "sklearn.svm.SVR().fit", "sklearn.linear_model.SGDRegressor().fit", "sklearn.linear_model.BayesianRidge().fit", "sklearn.linear_model.LassoCV", "sklearn.tree.DecisionTreeRegressor", "sklearn.linear_model.RidgeCV", "sklearn.ensemble.RandomForestRegressor", "sklearn.svm.SVR", "sklearn.linear_model.SGDRegressor", "sklearn.linear_model.BayesianRidge"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["", "def", "load_default", "(", "self", ",", "machine_list", "=", "'basic'", ")", ":", "\n", "        ", "\"\"\"\n        Loads 4 different scikit-learn regressors by default. The advanced list adds more machines. \n        Parameters\n        ----------\n        machine_list: optional, list of strings\n            List of default machine names to be loaded. \n            Default is basic,\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "if", "machine_list", "==", "'basic'", ":", "\n", "            ", "machine_list", "=", "[", "'tree'", ",", "'ridge'", ",", "'random_forest'", ",", "'svm'", "]", "\n", "", "if", "machine_list", "==", "'advanced'", ":", "\n", "            ", "machine_list", "=", "[", "'lasso'", ",", "'tree'", ",", "'ridge'", ",", "'random_forest'", ",", "'svm'", ",", "'bayesian_ridge'", ",", "'sgd'", "]", "\n", "\n", "", "self", ".", "estimators_", "=", "{", "}", "\n", "for", "machine", "in", "machine_list", ":", "\n", "            ", "try", ":", "\n", "                ", "if", "machine", "==", "'lasso'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'lasso'", "]", "=", "linear_model", ".", "LassoCV", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'tree'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'tree'", "]", "=", "DecisionTreeRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'ridge'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'ridge'", "]", "=", "linear_model", ".", "RidgeCV", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'random_forest'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'random_forest'", "]", "=", "RandomForestRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'svm'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'svm'", "]", "=", "SVR", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'sgd'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'sgd'", "]", "=", "linear_model", ".", "SGDRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'bayesian_ridge'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'bayesian_ridge'", "]", "=", "linear_model", ".", "BayesianRidge", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "", "except", "ValueError", ":", "\n", "                ", "continue", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.load_machine": [[271, 293], ["None"], "methods", ["None"], ["", "def", "load_machine", "(", "self", ",", "machine_name", ",", "machine", ")", ":", "\n", "        ", "\"\"\"\n        Adds a machine to be used during the aggregation strategy.\n        The machine object must have been trained using X_k and y_k, and must have a 'predict()' method.\n        After the machine is loaded, for it to be used during aggregation, load_machine_predictions must be run.\n\n        Parameters\n        ----------\n        machine_name : string\n            Name of the machine you are loading\n\n        machine: machine/regressor object\n            The regressor machine object which is mapped to the machine_name\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "self", ".", "estimators_", "[", "machine_name", "]", "=", "machine", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.kernelcobra.KernelCobra.load_machine_predictions": [[295, 321], ["numpy.array", "kernelcobra.KernelCobra.estimators_[].predict", "numpy.append"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "load_machine_predictions", "(", "self", ",", "predictions", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Stores the trained machines' predicitons on training data in a dictionary, to be used for predictions.\n        Should be run after all the machines to be used for aggregation is loaded.\n\n        Parameters\n        ----------\n        predictions: dictionary, optional\n            A pre-existing machine:predictions dictionary can also be loaded.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "self", ".", "machine_predictions_", "=", "{", "}", "\n", "self", ".", "all_predictions_", "=", "np", ".", "array", "(", "[", "]", ")", "\n", "if", "predictions", "is", "None", ":", "\n", "            ", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "                ", "self", ".", "machine_predictions_", "[", "machine", "]", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_l_", ")", "\n", "# all_predictions_ is used in the diagnostics class, and for initialising epsilon", "\n", "self", ".", "all_predictions_", "=", "np", ".", "append", "(", "self", ".", "all_predictions_", ",", "self", ".", "machine_predictions_", "[", "machine", "]", ")", "\n", "\n", "", "", "if", "predictions", "is", "not", "None", ":", "\n", "            ", "self", ".", "machine_predictions_", "=", "predictions", "\n", "\n", "", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.__init__": [[47, 50], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "random_state", "=", "None", ",", "beta", "=", "None", ")", ":", "\n", "        ", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "beta", "=", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.fit": [[51, 105], ["sklearn.utils.validation.check_X_y", "ewa.Ewa.split_data", "ewa.Ewa.load_default", "ewa.Ewa.load_machine_weights"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.load_machine_weights"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "default", "=", "True", ",", "X_k", "=", "None", ",", "X_l", "=", "None", ",", "y_k", "=", "None", ",", "y_l", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        X: array-like, [n_features]\n            Training data which will be used to create the EWA aggregate.\n\n        y: array-like, shape = [n_samples]\n            Target values used to train the machines used in the EWA aggregate.\n\n        default: bool, optional\n            If set as true then sets up EWA with default machines and splitting.\n\n        X_k : shape = [n_samples, n_features], optional\n            Training data which is used to train the machines loaded into Ewa.\n            Can be loaded directly into EWA; if not, the split_data method is used as default.\n\n        y_k : array-like, shape = [n_samples], optional\n            Target values used to train the machines loaded into EWA.\n\n        X_l : shape = [n_samples, n_features], optional\n            Training data which is used during the aggregation of EWA.\n            Can be loaded directly into EWA; if not, the split_data method is used as default.\n\n        y_l : array-like, shape = [n_samples], optional\n            Target values which are actually used in the aggregation of EWA.\n\n        Returns\n        -------\n        self : returns an instance of self.\n\n        Notes\n        -----\n\n        We store the data used to train the machines because this information is used to make the prediction.\n\n        \"\"\"", "\n", "\n", "X", ",", "y", "=", "check_X_y", "(", "X", ",", "y", ")", "\n", "self", ".", "X_", "=", "X", "\n", "self", ".", "y_", "=", "y", "\n", "self", ".", "X_k_", "=", "X_k", "\n", "self", ".", "X_l_", "=", "X_l", "\n", "self", ".", "y_k_", "=", "y_k", "\n", "self", ".", "y_l_", "=", "y_l", "\n", "self", ".", "estimators_", "=", "{", "}", "\n", "\n", "# set-up Ewa with default machines", "\n", "if", "default", ":", "\n", "            ", "self", ".", "split_data", "(", ")", "\n", "self", ".", "load_default", "(", ")", "\n", "self", ".", "load_machine_weights", "(", "self", ".", "beta", ")", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.set_beta": [[107, 129], ["sklearn.model_selection.GridSearchCV", "sklearn.model_selection.GridSearchCV.fit"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["", "def", "set_beta", "(", "self", ",", "X_beta", "=", "None", ",", "y_beta", "=", "None", ",", "betas", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n\n        betas: list, optional\n            List of betas to find optimal beta for weights\n\n        X_beta : shape = [n_samples, n_features]\n            Used if no beta is passed to find the optimal beta for data passed.\n\n        y_beta : array-like, shape = [n_samples]\n            Used if no beta is passed to find the optimal beta for data passed.\n        \"\"\"", "\n", "\n", "if", "self", ".", "beta", "is", "None", "and", "X_beta", "is", "not", "None", ":", "\n", "            ", "if", "betas", "is", "None", ":", "\n", "                ", "betas", "=", "[", "0.001", ",", "0.01", ",", "0.1", ",", "1.0", ",", "10.0", ",", "100.0", "]", "\n", "", "tuned_parameters", "=", "[", "{", "'beta'", ":", "betas", "}", "]", "\n", "clf", "=", "GridSearchCV", "(", "self", ",", "tuned_parameters", ",", "cv", "=", "5", ",", "scoring", "=", "\"neg_mean_squared_error\"", ")", "\n", "clf", ".", "fit", "(", "X_beta", ",", "y_beta", ")", "\n", "self", ".", "beta", "=", "clf", ".", "best_params_", "[", "\"beta\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.split_data": [[131, 171], ["sklearn.utils.shuffle", "int", "int", "len", "len", "len", "len"], "methods", ["None"], ["", "", "def", "split_data", "(", "self", ",", "k", "=", "None", ",", "l", "=", "None", ",", "shuffle_data", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Split the data into different parts for training machines and for aggregation.\n\n        Parameters\n        ----------\n        k : int, optional\n            k is the number of points used to train the machines.\n            Those are the first k points of the data provided.\n\n        l: int, optional\n            l is the number of points used to form the EWA aggregate.\n\n        shuffle: bool, optional\n            Boolean value to decide to shuffle the data before splitting.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "if", "shuffle_data", ":", "\n", "            ", "self", ".", "X_", ",", "self", ".", "y_", "=", "shuffle", "(", "self", ".", "X_", ",", "self", ".", "y_", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "", "if", "k", "is", "None", "and", "l", "is", "None", ":", "\n", "            ", "k", "=", "int", "(", "len", "(", "self", ".", "X_", ")", "/", "2", ")", "\n", "l", "=", "int", "(", "len", "(", "self", ".", "X_", ")", ")", "\n", "\n", "", "if", "k", "is", "not", "None", "and", "l", "is", "None", ":", "\n", "            ", "l", "=", "len", "(", "self", ".", "X_", ")", "-", "k", "\n", "\n", "", "if", "l", "is", "not", "None", "and", "k", "is", "None", ":", "\n", "            ", "k", "=", "len", "(", "self", ".", "X_", ")", "-", "l", "\n", "\n", "", "self", ".", "X_k_", "=", "self", ".", "X_", "[", ":", "k", "]", "\n", "self", ".", "X_l_", "=", "self", ".", "X_", "[", "k", ":", "l", "]", "\n", "self", ".", "y_k_", "=", "self", ".", "y_", "[", ":", "k", "]", "\n", "self", ".", "y_l_", "=", "self", ".", "y_", "[", "k", ":", "l", "]", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.load_default": [[173, 197], ["sklearn.linear_model.LassoCV().fit", "sklearn.tree.DecisionTreeRegressor().fit", "sklearn.linear_model.RidgeCV().fit", "sklearn.ensemble.RandomForestRegressor().fit", "sklearn.svm.SVR().fit", "sklearn.linear_model.LassoCV", "sklearn.tree.DecisionTreeRegressor", "sklearn.linear_model.RidgeCV", "sklearn.ensemble.RandomForestRegressor", "sklearn.svm.SVR"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["", "def", "load_default", "(", "self", ",", "machine_list", "=", "[", "'lasso'", ",", "'tree'", ",", "'ridge'", ",", "'random_forest'", ",", "'svm'", "]", ")", ":", "\n", "        ", "\"\"\"\n        Loads 4 different scikit-learn regressors by default.\n\n        Parameters\n        ----------\n        machine_list: optional, list of strings\n            List of default machine names to be loaded.\n\n        \"\"\"", "\n", "for", "machine", "in", "machine_list", ":", "\n", "            ", "try", ":", "\n", "                ", "if", "machine", "==", "'lasso'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'lasso'", "]", "=", "linear_model", ".", "LassoCV", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'tree'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'tree'", "]", "=", "DecisionTreeRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'ridge'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'ridge'", "]", "=", "linear_model", ".", "RidgeCV", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'random_forest'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'random_forest'", "]", "=", "RandomForestRegressor", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'svm'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'svm'", "]", "=", "SVR", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "", "except", "ValueError", ":", "\n", "                ", "continue", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.load_machine": [[198, 219], ["None"], "methods", ["None"], ["", "", "", "def", "load_machine", "(", "self", ",", "machine_name", ",", "machine", ")", ":", "\n", "        ", "\"\"\"\n        Adds a machine to be used during the aggregation strategy.\n        The machine object must have been trained using X_k and y_k, and must have a 'predict()' method.\n        After the machine is loaded, for it to be used during aggregation, load_machine_predictions must be run.\n\n        Parameters\n        ----------\n        machine_name : string\n            Name of the machine you are loading\n\n        machine: machine/regressor object\n            The regressor machine object which is mapped to the machine_name\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "self", ".", "estimators_", "[", "machine_name", "]", "=", "machine", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.load_machine_weights": [[221, 256], ["sum", "sklearn.metrics.mean_squared_error", "numpy.exp", "ewa.Ewa.machine_weight_.values", "ewa.Ewa.estimators_[].predict", "logger.info", "ewa.Ewa.machine_weight_.items", "len"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "load_machine_weights", "(", "self", ",", "beta", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Loads the EWA weights for each machine based on the training data.\n        Should be run after all the machines to be used for aggregation is loaded.\n\n        Parameters\n        ----------\n        beta : float\n            Inverse temperature parameter to form the weights.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "if", "self", ".", "beta", "is", "None", "and", "beta", "is", "None", ":", "\n", "            ", "beta", "=", "1.0", "\n", "", "if", "self", ".", "beta", "is", "not", "None", "and", "beta", "is", "None", ":", "\n", "            ", "beta", "=", "self", ".", "beta", "\n", "\n", "", "self", ".", "machine_MSE_", "=", "{", "}", "\n", "self", ".", "machine_weight_", "=", "{", "}", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "            ", "self", ".", "machine_MSE_", "[", "machine", "]", "=", "mean_squared_error", "(", "self", ".", "y_l_", ",", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_l_", ")", ")", "\n", "self", ".", "machine_weight_", "[", "machine", "]", "=", "np", ".", "exp", "(", "beta", "*", "self", ".", "machine_MSE_", "[", "machine", "]", ")", "\n", "if", "self", ".", "machine_weight_", "[", "machine", "]", "==", "np", ".", "inf", ":", "\n", "                ", "logger", ".", "info", "(", "\"MSE too high, setting equal weights to all machines\"", ")", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "                    ", "self", ".", "machine_weight_", "[", "machine", "]", "=", "1", "/", "len", "(", "self", ".", "estimators_", ")", "\n", "", "return", "self", "\n", "\n", "", "", "normalise", "=", "sum", "(", "self", ".", "machine_weight_", ".", "values", "(", ")", ",", "0.0", ")", "\n", "self", ".", "machine_weight_", "=", "{", "k", ":", "v", "/", "normalise", "for", "k", ",", "v", "in", "self", ".", "machine_weight_", ".", "items", "(", ")", "}", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.predict": [[258, 275], ["sklearn.utils.validation.check_array", "ewa.Ewa.estimators_[].predict"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        Returns\n        -------\n        result: returns prediction\n        \"\"\"", "\n", "X", "=", "check_array", "(", "X", ")", "\n", "\n", "result", "=", "0.0", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "            ", "result", "+=", "self", ".", "machine_weight_", "[", "machine", "]", "*", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "X", ")", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.ewa.Ewa.plot_machine_weights": [[277, 291], ["matplotlib.bar", "matplotlib.xticks", "matplotlib.show", "range", "ewa.Ewa.machine_weight_.values", "range", "ewa.Ewa.machine_weight_.keys", "len", "len"], "methods", ["None"], ["", "def", "plot_machine_weights", "(", "self", ",", "figsize", "=", "8", ")", ":", "\n", "        ", "\"\"\"\n        Plot each machine weights\n\n        Parameteres\n        -----------\n        figsize: float, optional\n            Size of plot.\n        \"\"\"", "\n", "\n", "plt", ".", "bar", "(", "range", "(", "len", "(", "self", ".", "machine_weight_", ")", ")", ",", "self", ".", "machine_weight_", ".", "values", "(", ")", ",", "align", "=", "'center'", ")", "\n", "plt", ".", "xticks", "(", "range", "(", "len", "(", "self", ".", "machine_weight_", ")", ")", ",", "self", ".", "machine_weight_", ".", "keys", "(", ")", ")", "\n", "\n", "plt", ".", "show", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.__init__": [[42, 45], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "random_state", "=", "None", ",", "machine_list", "=", "'basic'", ")", ":", "\n", "        ", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "machine_list", "=", "machine_list", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit": [[46, 92], ["sklearn.utils.validation.check_X_y", "classifiercobra.ClassifierCobra.split_data", "classifiercobra.ClassifierCobra.load_default", "classifiercobra.ClassifierCobra.load_machine_predictions"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "default", "=", "True", ",", "X_k", "=", "None", ",", "X_l", "=", "None", ",", "y_k", "=", "None", ",", "y_l", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        X: array-like, [n_samples, n_features]\n            Training data which will be used to create ClassifierCobra.\n\n        y: array-like [n_samples]\n            Training labels for classification.\n\n        default: bool, optional\n            If set as true then sets up COBRA with default machines and splitting.\n\n        X_k : shape = [n_samples, n_features]\n            Training data which is used to train the machines loaded into COBRA.\n\n        y_k : array-like, shape = [n_samples]\n            Target values used to train the machines loaded into COBRA.\n\n        X_l : shape = [n_samples, n_features]\n            Training data which is used during the aggregation of COBRA.\n\n        y_l : array-like, shape = [n_samples]\n            Target values which are actually used in the aggregation of COBRA.\n        \"\"\"", "\n", "\n", "X", ",", "y", "=", "check_X_y", "(", "X", ",", "y", ")", "\n", "self", ".", "X_", "=", "X", "\n", "self", ".", "y_", "=", "y", "\n", "self", ".", "X_k_", "=", "X_k", "\n", "self", ".", "X_l_", "=", "X_l", "\n", "self", ".", "y_k_", "=", "y_k", "\n", "self", ".", "y_l_", "=", "y_l", "\n", "self", ".", "estimators_", "=", "{", "}", "\n", "\n", "# try block to pass scikit-learn estimator check.", "\n", "try", ":", "\n", "# set-up COBRA with default machines", "\n", "            ", "if", "default", ":", "\n", "                ", "self", ".", "split_data", "(", ")", "\n", "self", ".", "load_default", "(", "machine_list", "=", "self", ".", "machine_list", ")", "\n", "self", ".", "load_machine_predictions", "(", ")", "\n", "", "", "except", "ValueError", ":", "\n", "            ", "return", "self", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred": [[94, 157], ["range", "numpy.unique", "int", "classifiercobra.ClassifierCobra.estimators_[].predict", "set", "range", "len", "len", "logger.info", "max", "len", "points.append", "logger.info", "select[].add"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "pred", "(", "self", ",", "X", ",", "M", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Performs the CLassififerCobra aggregation scheme, used in predict method.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        M: int, optional\n            M refers to the number of machines the prediction must be close to to be considered during aggregation.\n\n        info: boolean, optional\n            If info is true the list of points selected in the aggregation is returned.\n\n        Returns\n        -------\n        result: prediction\n\n        \"\"\"", "\n", "\n", "# dictionary mapping machine to points selected", "\n", "select", "=", "{", "}", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "# machine prediction", "\n", "            ", "label", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "X", ")", "\n", "select", "[", "machine", "]", "=", "set", "(", ")", "\n", "# iterating from l to n", "\n", "# replace with numpy iteration", "\n", "for", "count", "in", "range", "(", "0", ",", "len", "(", "self", ".", "X_l_", ")", ")", ":", "\n", "                ", "if", "self", ".", "machine_predictions_", "[", "machine", "]", "[", "count", "]", "==", "label", ":", "\n", "                    ", "select", "[", "machine", "]", ".", "add", "(", "count", ")", "\n", "\n", "", "", "", "points", "=", "[", "]", "\n", "# count is the indice number.", "\n", "for", "count", "in", "range", "(", "0", ",", "len", "(", "self", ".", "X_l_", ")", ")", ":", "\n", "# row check is number of machines which picked up a particular point", "\n", "            ", "row_check", "=", "0", "\n", "for", "machine", "in", "select", ":", "\n", "                ", "if", "count", "in", "select", "[", "machine", "]", ":", "\n", "                    ", "row_check", "+=", "1", "\n", "", "", "if", "row_check", "==", "M", ":", "\n", "                ", "points", ".", "append", "(", "count", ")", "\n", "\n", "# if no points are selected, return 0", "\n", "", "", "if", "len", "(", "points", ")", "==", "0", ":", "\n", "            ", "if", "info", ":", "\n", "                ", "logger", ".", "info", "(", "\"No points were selected, prediction is 0\"", ")", "\n", "return", "(", "0", ",", "0", ")", "\n", "", "logger", ".", "info", "(", "\"No points were selected, prediction is 0\"", ")", "\n", "return", "0", "\n", "\n", "# aggregate", "\n", "", "classes", "=", "{", "}", "\n", "for", "label", "in", "np", ".", "unique", "(", "self", ".", "y_l_", ")", ":", "\n", "            ", "classes", "[", "label", "]", "=", "0", "\n", "\n", "", "for", "point", "in", "points", ":", "\n", "            ", "classes", "[", "self", ".", "y_l_", "[", "point", "]", "]", "+=", "1", "\n", "\n", "", "result", "=", "int", "(", "max", "(", "classes", ",", "key", "=", "classes", ".", "get", ")", ")", "\n", "if", "info", ":", "\n", "            ", "return", "result", ",", "points", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict": [[159, 202], ["sklearn.utils.validation.check_array", "numpy.zeros", "len", "classifiercobra.ClassifierCobra.pred", "len", "sklearn.utils.validation.check_array.reshape", "classifiercobra.ClassifierCobra.pred", "len", "classifiercobra.ClassifierCobra.pred", "len", "vector.reshape", "vector.reshape"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.pred"], ["", "def", "predict", "(", "self", ",", "X", ",", "M", "=", "None", ",", "info", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Performs the ClassifierCobra aggregation scheme, calls pred.\n        ClassifierCobra performs a majority vote among all points which are retained by the COBRA procedure.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n\n        M: int, optional\n            M refers to the number of machines the prediction must be close to to be considered during aggregation.\n\n        info: boolean, optional\n            If info is true the list of points selected in the aggregation is returned.\n\n        Returns\n        -------\n        result: prediction\n\n        \"\"\"", "\n", "X", "=", "check_array", "(", "X", ")", "\n", "\n", "if", "M", "is", "None", ":", "\n", "            ", "M", "=", "len", "(", "self", ".", "estimators_", ")", "\n", "", "if", "X", ".", "ndim", "==", "1", ":", "\n", "            ", "return", "self", ".", "pred", "(", "X", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "M", "=", "M", ")", "\n", "\n", "", "result", "=", "np", ".", "zeros", "(", "len", "(", "X", ")", ")", "\n", "avg_points", "=", "0", "\n", "index", "=", "0", "\n", "for", "vector", "in", "X", ":", "\n", "            ", "if", "info", ":", "\n", "                ", "result", "[", "index", "]", ",", "points", "=", "self", ".", "pred", "(", "vector", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "M", "=", "M", ",", "info", "=", "info", ")", "\n", "avg_points", "+=", "len", "(", "points", ")", "\n", "", "else", ":", "\n", "                ", "result", "[", "index", "]", "=", "self", ".", "pred", "(", "vector", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "M", "=", "M", ")", "\n", "", "index", "+=", "1", "\n", "\n", "", "if", "info", ":", "\n", "            ", "avg_points", "=", "avg_points", "/", "len", "(", "X_array", ")", "\n", "return", "result", ",", "avg_points", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict_proba": [[204, 226], ["numpy.mean", "probs.append", "classifiercobra.ClassifierCobra.estimators_[].predict_proba"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict_proba"], ["", "def", "predict_proba", "(", "self", ",", "X", ",", "kernel", "=", "None", ",", "metric", "=", "None", ",", "bandwidth", "=", "1", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Performs the ClassifierCobra aggregation scheme and calculates probability of a point being in a particular class.\n        ClassifierCobra performs a majority vote among all points which are retained by the COBRA procedure.\n        \n        NOTE: this method is to visualise boundaries.\n        The current method is just the mean of the consituent machines, as the concept of that kind of predicted probability\n        doesn't exist (yet) for classifier cobra.\n\n        Parameters\n        ----------\n        X: array-like, [n_features]\n        \"\"\"", "\n", "\n", "probs", "=", "[", "]", "\n", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "            ", "try", ":", "\n", "                ", "probs", ".", "append", "(", "self", ".", "estimators_", "[", "machine", "]", ".", "predict_proba", "(", "X", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "                ", "continue", "\n", "", "", "prob", "=", "np", ".", "mean", "(", "probs", ",", "axis", "=", "0", ")", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.split_data": [[228, 268], ["sklearn.utils.shuffle", "int", "int", "len", "len", "len", "len"], "methods", ["None"], ["", "def", "split_data", "(", "self", ",", "k", "=", "None", ",", "l", "=", "None", ",", "shuffle_data", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Split the data into different parts for training machines and for aggregation.\n\n        Parameters\n        ----------\n        k : int, optional\n            k is the number of points used to train the machines.\n            Those are the first k points of the data provided.\n\n        l: int, optional\n            l is the number of points used to form the ClassifierCobra aggregate.\n\n        shuffle: bool, optional\n            Boolean value to decide to shuffle the data before splitting.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "if", "shuffle_data", ":", "\n", "            ", "self", ".", "X_", ",", "self", ".", "y_", "=", "shuffle", "(", "self", ".", "X_", ",", "self", ".", "y_", ",", "random_state", "=", "self", ".", "random_state", ")", "\n", "\n", "", "if", "k", "is", "None", "and", "l", "is", "None", ":", "\n", "            ", "k", "=", "int", "(", "len", "(", "self", ".", "X_", ")", "/", "2", ")", "\n", "l", "=", "int", "(", "len", "(", "self", ".", "X_", ")", ")", "\n", "\n", "", "if", "k", "is", "not", "None", "and", "l", "is", "None", ":", "\n", "            ", "l", "=", "len", "(", "self", ".", "X_", ")", "-", "k", "\n", "\n", "", "if", "l", "is", "not", "None", "and", "k", "is", "None", ":", "\n", "            ", "k", "=", "len", "(", "self", ".", "X_", ")", "-", "l", "\n", "\n", "", "self", ".", "X_k_", "=", "self", ".", "X_", "[", ":", "k", "]", "\n", "self", ".", "X_l_", "=", "self", ".", "X_", "[", "k", ":", "l", "]", "\n", "self", ".", "y_k_", "=", "self", ".", "y_", "[", ":", "k", "]", "\n", "self", ".", "y_l_", "=", "self", ".", "y_", "[", "k", ":", "l", "]", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_default": [[270, 308], ["sklearn.svm.SVC().fit", "sklearn.neighbors.KNeighborsClassifier().fit", "sklearn.tree.DecisionTreeClassifier().fit", "sklearn.linear_model.LogisticRegression().fit", "sklearn.naive_bayes.GaussianNB().fit", "sklearn.discriminant_analysis.LinearDiscriminantAnalysis().fit", "sklearn.neural_network.MLPClassifier().fit", "sklearn.svm.SVC", "sklearn.neighbors.KNeighborsClassifier", "sklearn.tree.DecisionTreeClassifier", "sklearn.linear_model.LogisticRegression", "sklearn.naive_bayes.GaussianNB", "sklearn.discriminant_analysis.LinearDiscriminantAnalysis", "sklearn.neural_network.MLPClassifier"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit", "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.fit"], ["", "def", "load_default", "(", "self", ",", "machine_list", "=", "'basic'", ")", ":", "\n", "        ", "\"\"\"\n        Loads 4 different scikit-learn regressors by default. The advanced list adds more machines. \n        As of current release SGD algorithm is not included in the advanced list.\n\n        Parameters\n        ----------\n        machine_list: optional, list of strings\n            List of default machine names to be loaded.\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "if", "machine_list", "==", "'basic'", ":", "\n", "            ", "machine_list", "=", "[", "'sgd'", ",", "'tree'", ",", "'knn'", ",", "'svm'", "]", "\n", "", "if", "machine_list", "==", "'advanced'", ":", "\n", "            ", "machine_list", "=", "[", "'tree'", ",", "'knn'", ",", "'svm'", ",", "'logreg'", ",", "'naive_bayes'", ",", "'lda'", ",", "'neural_network'", "]", "\n", "\n", "", "for", "machine", "in", "machine_list", ":", "\n", "            ", "try", ":", "\n", "                ", "if", "machine", "==", "'svm'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'svm'", "]", "=", "svm", ".", "SVC", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'knn'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'knn'", "]", "=", "neighbors", ".", "KNeighborsClassifier", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'tree'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'tree'", "]", "=", "tree", ".", "DecisionTreeClassifier", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'logreg'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'logreg'", "]", "=", "LogisticRegression", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'naive_bayes'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'naive_bayes'", "]", "=", "GaussianNB", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'lda'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'lda'", "]", "=", "LinearDiscriminantAnalysis", "(", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "if", "machine", "==", "'neural_network'", ":", "\n", "                    ", "self", ".", "estimators_", "[", "'neural_network'", "]", "=", "MLPClassifier", "(", "random_state", "=", "self", ".", "random_state", ")", ".", "fit", "(", "self", ".", "X_k_", ",", "self", ".", "y_k_", ")", "\n", "", "", "except", "ValueError", ":", "\n", "                ", "continue", "\n", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine": [[310, 332], ["None"], "methods", ["None"], ["", "def", "load_machine", "(", "self", ",", "machine_name", ",", "machine", ")", ":", "\n", "        ", "\"\"\"\n        Adds a machine to be used during the aggregation strategy.\n        The machine object must have been trained using X_k and y_k, and must have a 'predict()' method.\n        After the machine is loaded, for it to be used during aggregation, load_machine_predictions must be run.\n\n        Parameters\n        ----------\n        machine_name : string\n            Name of the machine you are loading\n\n        machine: machine/regressor object\n            The regressor machine object which is mapped to the machine_name\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "\n", "self", ".", "estimators_", "[", "machine_name", "]", "=", "machine", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_predictions": [[334, 354], ["classifiercobra.ClassifierCobra.estimators_[].predict"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict"], ["", "def", "load_machine_predictions", "(", "self", ",", "predictions", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Stores the trained machines' predicitons on D_l in a dictionary, to be used for predictions.\n        Should be run after all the machines to be used for aggregation is loaded.\n\n        Parameters\n        ----------\n        predictions: dictionary, optional\n            A pre-existing machine:predictions dictionary can also be loaded.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "self", ".", "machine_predictions_", "=", "{", "}", "\n", "if", "predictions", "is", "None", ":", "\n", "            ", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "                ", "self", ".", "machine_predictions_", "[", "machine", "]", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict", "(", "self", ".", "X_l_", ")", "\n", "\n", "", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.load_machine_proba_predictions": [[356, 378], ["classifiercobra.ClassifierCobra.estimators_[].predict_proba", "classifiercobra.ClassifierCobra.estimators_[].decision_function"], "methods", ["home.repos.pwc.inspect_result.bhargavvader_pycobra.pycobra.classifiercobra.ClassifierCobra.predict_proba"], ["", "def", "load_machine_proba_predictions", "(", "self", ",", "predictions", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Stores the trained machines' predicitons on D_l in a dictionary, to be used for predictions.\n        Should be run after all the machines to be used for aggregation is loaded.\n\n        Parameters\n        ----------\n        predictions: dictionary, optional\n            A pre-existing machine:predictions dictionary can also be loaded.\n\n        Returns\n        -------\n        self : returns an instance of self.\n        \"\"\"", "\n", "self", ".", "machine_proba_predictions_", "=", "{", "}", "\n", "if", "predictions", "is", "None", ":", "\n", "            ", "for", "machine", "in", "self", ".", "estimators_", ":", "\n", "                ", "try", ":", "\n", "                    ", "self", ".", "machine_proba_predictions_", "[", "machine", "]", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "predict_proba", "(", "self", ".", "X_l_", ")", "\n", "", "except", "AttributeError", ":", "\n", "                    ", "self", ".", "machine_proba_predictions_", "[", "machine", "]", "=", "self", ".", "estimators_", "[", "machine", "]", ".", "decision_function", "(", "self", ".", "X_l_", ")", "\n", "", "", "", "return", "self", "\n", "\n"]]}