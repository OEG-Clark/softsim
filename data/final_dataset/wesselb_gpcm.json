{"home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__init__": [[76, 84], ["ValueError"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__init__", "(", "self", ",", "name", ":", "str", ",", "power", ":", "int", ")", ":", "\n", "        ", "if", "power", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f'Power for variable \"{name}\" is {power}, but must be at least 1.'", "\n", ")", "\n", "", "self", ".", "name", "=", "name", "\n", "self", ".", "power", "=", "power", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.eval": [[85, 95], ["None"], "methods", ["None"], ["", "def", "eval", "(", "self", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Evaluate factor.\n\n        Args:\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Evaluated factor.\n        \"\"\"", "\n", "return", "var_map", "[", "self", ".", "name", "]", "**", "self", ".", "power", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__str__": [[96, 98], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.name}^{self.power}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__repr__": [[99, 101], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__eq__": [[102, 105], ["None"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__eq__", "(", "self", ",", "other", ":", "\"Factor\"", ")", ":", "\n", "        ", "return", "self", ".", "name", "==", "other", ".", "name", "and", "self", ".", "power", "==", "other", ".", "power", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__mul__": [[113, 119], ["RuntimeError"], "methods", ["None"], ["", "", "@", "_dispatch", "\n", "def", "__mul__", "(", "self", ",", "other", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "if", "other", "is", "1", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Can only multiply factors by one identically.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__rmul__": [[120, 122], ["exppoly.Factor.__mul__"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__mul__"], ["", "", "def", "__rmul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "__mul__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Factor.__hash__": [[123, 125], ["hash", "hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "name", ")", "+", "hash", "(", "self", ".", "power", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__init__": [[147, 158], ["set", "isinstance", "exppoly._merge_common_factors"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._merge_common_factors"], ["", "@", "_dispatch", "\n", "def", "__init__", "(", "self", ",", "const", ":", "B", ".", "Numeric", ",", "*", "factors", ":", "Factor", ")", ":", "\n", "        ", "self", ".", "const", "=", "const", "\n", "\n", "# Discard factors if constant is equal to zero.", "\n", "if", "isinstance", "(", "const", ",", "B", ".", "Number", ")", "and", "const", "==", "0", ":", "\n", "            ", "factors", "=", "[", "]", "\n", "\n", "# Merge common factors. Store this as a set so that equality works as", "\n", "# expected.", "\n", "", "self", ".", "factors", "=", "set", "(", "_merge_common_factors", "(", "*", "factors", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.is_function_of": [[159, 170], ["any"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "is_function_of", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Check if this term is a function of some variable.\n\n        Args:\n            name (str): Variable name.\n\n        Returns:\n            bool: `True` if this term is a function of `var` and `False` otherwise.\n        \"\"\"", "\n", "return", "any", "(", "[", "x", ".", "name", "==", "name", "for", "x", "in", "self", ".", "factors", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.collect_for": [[171, 185], ["exppoly.Term", "RuntimeError"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "collect_for", "(", "self", ",", "factor", ":", "Factor", ")", ":", "\n", "        ", "\"\"\"Create a new term consisting of the same constant and all factors\n        except one.\n\n        Args:\n            factor (:class:`.exppoly.Factor`): Factor to exclude.\n\n        Returns:\n            :class:`.exppoly.Term`: Result.\n        \"\"\"", "\n", "if", "factor", "not", "in", "self", ".", "factors", ":", "\n", "            ", "raise", "RuntimeError", "(", "f\"Factor {factor} must be contained in term\"", "f\"{self}.\"", ")", "\n", "", "return", "Term", "(", "self", ".", "const", ",", "*", "(", "self", ".", "factors", "-", "{", "factor", "}", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.eval": [[186, 197], ["functools.reduce", "x.eval"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval"], ["", "def", "eval", "(", "self", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Evaluate term.\n\n        Args:\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Evaluated term.\n        \"\"\"", "\n", "return", "reduce", "(", "\n", "operator", ".", "mul", ",", "[", "x", ".", "eval", "(", "**", "var_map", ")", "for", "x", "in", "self", ".", "factors", "]", ",", "self", ".", "const", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.is_constant": [[199, 206], ["len"], "methods", ["None"], ["", "def", "is_constant", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check whether this term is constant.\n\n        Returns:\n            bool: `True` if the term is constant and `False` otherwise.\n        \"\"\"", "\n", "return", "len", "(", "self", ".", "factors", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.highest_power": [[207, 223], ["max"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "highest_power", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Find the highest power of a variable.\n\n        Args:\n            name (str): Name of variable.\n\n        Returns:\n            int: Highest power of variable `name`. Returns `0` if it does not depend\n                on `name`.\n        \"\"\"", "\n", "highest_power", "=", "0", "\n", "for", "factor", "in", "self", ".", "factors", ":", "\n", "            ", "if", "factor", ".", "name", "==", "name", ":", "\n", "                ", "highest_power", "=", "max", "(", "highest_power", ",", "factor", ".", "power", ")", "\n", "", "", "return", "highest_power", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.substitute": [[224, 246], ["exppoly.Poly", "factors.append", "exppoly.Term"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "substitute", "(", "self", ",", "name", ":", "str", ",", "poly", ":", "PromisedPoly", ")", ":", "\n", "        ", "\"\"\"Substitute a polynomial for a variable.\n\n        Args:\n            name (str): Name of variable.\n            poly (:class:`.exppoly.Poly`): Polynomial to substitute for variable.\n\n        Returns:\n            :class:`.exppoly.Poly`: Result of substitution.\n        \"\"\"", "\n", "factors", "=", "[", "]", "\n", "power", "=", "0", "\n", "for", "factor", "in", "self", ".", "factors", ":", "\n", "# Retain factor if its variable is different, otherwise save its power to", "\n", "# afterwards raise the polynomial to. This check is safe because there", "\n", "# are not factors with the same name.", "\n", "            ", "if", "factor", ".", "name", "==", "name", ":", "\n", "                ", "power", "=", "factor", ".", "power", "\n", "", "else", ":", "\n", "                ", "factors", ".", "append", "(", "factor", ")", "\n", "", "", "return", "Poly", "(", "Term", "(", "self", ".", "const", ",", "*", "factors", ")", ")", "*", "poly", "**", "power", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__str__": [[247, 253], ["len", "str", "sorted", "map"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "factors", ")", ">", "0", ":", "\n", "            ", "names", "=", "\" \"", ".", "join", "(", "sorted", "(", "map", "(", "str", ",", "self", ".", "factors", ")", ")", ")", "\n", "return", "f\"{self.const} * {names}\"", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "self", ".", "const", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__repr__": [[254, 256], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__eq__": [[257, 260], ["None"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__eq__", "(", "self", ",", "other", ":", "\"Term\"", ")", ":", "\n", "        ", "return", "self", ".", "const", "==", "other", ".", "const", "and", "self", ".", "factors", "==", "other", ".", "factors", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__add__": [[268, 274], ["RuntimeError"], "methods", ["None"], ["", "", "@", "_dispatch", "\n", "def", "__add__", "(", "self", ",", "other", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "if", "other", "is", "0", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Can only add to terms zero identically.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__radd__": [[275, 277], ["None"], "methods", ["None"], ["", "", "def", "__radd__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", "+", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__mul__": [[284, 290], ["RuntimeError"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__mul__", "(", "self", ",", "other", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "if", "other", "is", "1", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Can only multiply terms with one identically.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__rmul__": [[291, 293], ["None"], "methods", ["None"], ["", "", "def", "__rmul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", "*", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__neg__": [[294, 296], ["exppoly.Term"], "methods", ["None"], ["", "def", "__neg__", "(", "self", ")", ":", "\n", "        ", "return", "Term", "(", "-", "self", ".", "const", ",", "*", "self", ".", "factors", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Term.__hash__": [[297, 299], ["hash", "hash", "frozenset"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "const", ")", "+", "hash", "(", "frozenset", "(", "self", ".", "factors", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__init__": [[316, 322], ["exppoly._merge_common_terms"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._merge_common_terms"], ["@", "_dispatch", "\n", "def", "__init__", "(", "self", ",", "*", "terms", ":", "Term", ")", ":", "\n", "# Merge common terms. Do _not_ store this as a set, even though we would like", "\n", "# to, because in certain AD frameworks the hash of the constant of a term", "\n", "# cannot be computed.", "\n", "        ", "self", ".", "terms", "=", "_merge_common_terms", "(", "*", "terms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of": [[323, 334], ["any", "term.is_function_of"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of"], ["", "@", "_dispatch", "\n", "def", "is_function_of", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Check if this polynomial is a function of some variable.\n\n        Args:\n            name (str): Variable name.\n\n        Returns:\n            bool: `True` if this term is a function of `var` and `False` otherwise.\n        \"\"\"", "\n", "return", "any", "(", "[", "term", ".", "is_function_of", "(", "name", ")", "for", "term", "in", "self", ".", "terms", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for": [[335, 348], ["exppoly.Poly", "x.collect_for"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for"], ["", "@", "_dispatch", "\n", "def", "collect_for", "(", "self", ",", "factor", ":", "Factor", ")", ":", "\n", "        ", "\"\"\"Create a new polynomial consisting of terms whose factors contain `factor`\n        and subsequently collect `factor`, which means that it is excluded in those\n        terms.\n\n        Args:\n            factor (:class:`.exppoly.Factor`): Factor to collect for.\n\n        Returns:\n            :class:`.exppoly.Poly`: Result of collection.\n        \"\"\"", "\n", "return", "Poly", "(", "*", "[", "x", ".", "collect_for", "(", "factor", ")", "for", "x", "in", "self", ".", "terms", "if", "factor", "in", "x", ".", "factors", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject": [[349, 360], ["exppoly.Poly", "x.is_function_of"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of"], ["", "@", "_dispatch", "\n", "def", "reject", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Create a new polynomial excluding terms whose factors contain a variable.\n\n        Args:\n            name (str): Variable name.\n\n        Returns:\n            :class:`.exppoly.Poly`: Result of rejection.\n        \"\"\"", "\n", "return", "Poly", "(", "*", "[", "x", "for", "x", "in", "self", ".", "terms", "if", "not", "x", ".", "is_function_of", "(", "name", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.eval": [[361, 374], ["term.eval"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval"], ["", "def", "eval", "(", "self", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Evaluate polynomial.\n\n        Args:\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Evaluated polynomial.\n        \"\"\"", "\n", "result", "=", "0", "\n", "for", "term", "in", "self", ".", "terms", ":", "\n", "            ", "result", "=", "result", "+", "term", ".", "eval", "(", "**", "var_map", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_constant": [[375, 382], ["all", "x.is_constant"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_constant"], ["", "def", "is_constant", "(", "self", ")", ":", "\n", "        ", "\"\"\"Check whether this polynomial is constant.\n\n        Returns:\n            bool: `True` if the polynomial is constant and `False` otherwise.\n        \"\"\"", "\n", "return", "all", "(", "[", "x", ".", "is_constant", "(", ")", "for", "x", "in", "self", ".", "terms", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power": [[383, 395], ["max", "term.highest_power"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power"], ["", "@", "_dispatch", "\n", "def", "highest_power", "(", "self", ",", "name", ":", "str", ")", ":", "\n", "        ", "\"\"\"Find the highest power of a variable.\n\n        Args:\n            name (str): Name of variable.\n\n        Returns:\n            int: Highest power of variable `name`. Returns `0` if it does not depend\n                on `name`.\n        \"\"\"", "\n", "return", "max", "(", "[", "term", ".", "highest_power", "(", "name", ")", "for", "term", "in", "self", ".", "terms", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.substitute": [[396, 411], ["term.substitute"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.substitute"], ["", "@", "_dispatch", "\n", "def", "substitute", "(", "self", ",", "name", ":", "str", ",", "poly", ":", "\"Poly\"", ")", ":", "\n", "        ", "\"\"\"Substitute a polynomial for a variable.\n\n        Args:\n            name (str): Name of variable.\n            poly (:class:`.exppoly.Poly`): Polynomial to substitute for variable.\n\n        Returns:\n            :class:`.exppoly.Poly`: Result of substitution.\n        \"\"\"", "\n", "result", "=", "0", "\n", "for", "term", "in", "self", ".", "terms", ":", "\n", "            ", "result", "=", "result", "+", "term", ".", "substitute", "(", "name", ",", "poly", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__str__": [[412, 417], ["len", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "terms", ")", "==", "0", ":", "\n", "            ", "return", "\"0\"", "\n", "", "else", ":", "\n", "            ", "return", "\" + \"", ".", "join", "(", "[", "str", "(", "term", ")", "for", "term", "in", "self", ".", "terms", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__repr__": [[418, 420], ["str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__eq__": [[421, 424], ["set", "set"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__eq__", "(", "self", ",", "other", ":", "\"Poly\"", ")", ":", "\n", "        ", "return", "set", "(", "self", ".", "terms", ")", "==", "set", "(", "other", ".", "terms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__add__": [[429, 435], ["exppoly.const"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "@", "_dispatch", "\n", "def", "__add__", "(", "self", ",", "other", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "if", "other", "is", "0", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "return", "self", "+", "const", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__radd__": [[436, 438], ["None"], "methods", ["None"], ["", "", "def", "__radd__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", "+", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__neg__": [[439, 441], ["exppoly.Poly"], "methods", ["None"], ["", "def", "__neg__", "(", "self", ")", ":", "\n", "        ", "return", "Poly", "(", "*", "[", "-", "term", "for", "term", "in", "self", ".", "terms", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__sub__": [[442, 444], ["None"], "methods", ["None"], ["", "def", "__sub__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", "+", "(", "-", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__rsub__": [[445, 447], ["None"], "methods", ["None"], ["", "def", "__rsub__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "(", "-", "self", ")", "+", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__mul__": [[452, 458], ["exppoly.const"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "@", "_dispatch", "\n", "def", "__mul__", "(", "self", ",", "other", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "if", "other", "is", "1", ":", "\n", "            ", "return", "self", "\n", "", "else", ":", "\n", "            ", "return", "self", "*", "const", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__rmul__": [[459, 461], ["None"], "methods", ["None"], ["", "", "def", "__rmul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", "*", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.__pow__": [[462, 468], ["functools.reduce", "RuntimeError"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__pow__", "(", "self", ",", "power", ":", "int", ",", "modulo", "=", "None", ")", ":", "\n", "        ", "assert", "modulo", "is", "None", ",", "'Keyword \"modulo\" is not supported.'", "\n", "if", "power", "<", "0", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Can only raise polynomials to non-negative integers.\"", ")", "\n", "", "return", "reduce", "(", "operator", ".", "mul", ",", "[", "self", "]", "*", "power", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__init__": [[492, 496], ["None"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__init__", "(", "self", ",", "const", ":", "B", ".", "Numeric", ",", "poly", ":", "Poly", ")", ":", "\n", "        ", "self", ".", "const", "=", "const", "\n", "self", ".", "poly", "=", "poly", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.substitute": [[497, 509], ["exppoly.ExpPoly", "exppoly.ExpPoly.poly.substitute"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.substitute"], ["", "@", "_dispatch", "\n", "def", "substitute", "(", "self", ",", "name", ":", "str", ",", "poly", ":", "Poly", ")", ":", "\n", "        ", "\"\"\"Substitute a polynomial for a variable.\n\n        Args:\n            name (str): Name of variable.\n            poly (:class:`.exppoly.Poly`): Polynomial to substitute for variable.\n\n        Returns:\n            :class:`.exppoly.ExpPoly`: Result of substitution.\n        \"\"\"", "\n", "return", "ExpPoly", "(", "self", ".", "const", ",", "self", ".", "poly", ".", "substitute", "(", "name", ",", "poly", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval": [[510, 520], ["lab.exp", "exppoly.ExpPoly.poly.eval"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval"], ["", "def", "eval", "(", "self", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Evaluate the exponentiated polynomial.\n\n        Args:\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Evaluated exponentiated polynomial.\n        \"\"\"", "\n", "return", "self", ".", "const", "*", "B", ".", "exp", "(", "self", ".", "poly", ".", "eval", "(", "**", "var_map", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate": [[521, 536], ["eq._integrate._integrate.eval", "eq._integrate._integrate._integrate"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate"], ["", "def", "integrate", "(", "self", ",", "*", "names", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Integrate over a subset of the variables from :math:`-\\\\infty` to\n        :math:`\\\\infty` and evaluate the result.\n\n        Args:\n            *names (str): Variable names.\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Result.\n        \"\"\"", "\n", "eq", "=", "self", "\n", "for", "name", "in", "names", ":", "\n", "            ", "eq", "=", "eq", ".", "_integrate", "(", "name", ")", "\n", "", "return", "eq", ".", "eval", "(", "**", "var_map", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_half": [[537, 555], ["len", "exppoly.ExpPoly._integrate_half1", "len", "exppoly.ExpPoly._integrate_half2", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half1", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half2"], ["", "def", "integrate_half", "(", "self", ",", "*", "names", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Integrate over a subset of the variables from :math:`-\\\\infty` to\n        :math:`0` and evaluate the result.\n\n        Args:\n            *names (str): Variable names.\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Result.\n        \"\"\"", "\n", "if", "len", "(", "names", ")", "==", "1", ":", "\n", "            ", "return", "self", ".", "_integrate_half1", "(", "names", "[", "0", "]", ",", "**", "var_map", ")", "\n", "", "elif", "len", "(", "names", ")", "==", "2", ":", "\n", "            ", "return", "self", ".", "_integrate_half2", "(", "*", "names", ",", "**", "var_map", ")", "\n", "", "else", ":", "# pragma: no cover", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Cannot integrate from -inf to 0 over more than two variables.\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box": [[557, 604], ["len", "ep._integrate._integrate.eval", "exppoly.is_inf", "exppoly.is_inf", "ep._integrate._integrate._integrate", "filtered_vars_and_lims.append", "part.integrate_half", "exppoly.is_inf", "exppoly._as_poly", "parts_new.append", "exppoly.is_inf", "exppoly._as_poly", "parts_new.append", "part.translate_var", "part.translate_var"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_half", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._as_poly", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._as_poly", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.translate_var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.translate_var"], ["", "", "def", "integrate_box", "(", "self", ",", "*", "name_and_lims", ",", "**", "var_map", ")", ":", "\n", "        ", "\"\"\"Integrate over a subset of the variables from some lower limit to some\n        upper limit and evaluate the result. Infinity can be specified using\n        `np.inf`. Any infinite lower limit corresponds to negative infinity, and any\n        infinite upper limit corresponds to positive infinity.\n\n        Args:\n            *name_and_lims (tuple): Three-tuples containing the variable names,\n                lower limits, and upper limits.\n            **var_map (tensor): Variable mapping.\n\n        Returns:\n            tensor: Result.\n        \"\"\"", "\n", "# Filter doubly infinite limits.", "\n", "filtered_vars_and_lims", "=", "[", "]", "\n", "ep", "=", "self", "\n", "for", "name", ",", "lower", ",", "upper", "in", "name_and_lims", ":", "\n", "            ", "if", "is_inf", "(", "lower", ")", "and", "is_inf", "(", "upper", ")", ":", "\n", "                ", "ep", "=", "ep", ".", "_integrate", "(", "name", ")", "\n", "", "else", ":", "\n", "                ", "filtered_vars_and_lims", ".", "append", "(", "(", "name", ",", "lower", ",", "upper", ")", ")", "\n", "", "", "name_and_lims", "=", "filtered_vars_and_lims", "\n", "\n", "# Return if all integration is done.", "\n", "if", "len", "(", "name_and_lims", ")", "==", "0", ":", "\n", "            ", "return", "ep", ".", "eval", "(", "**", "var_map", ")", "\n", "\n", "# Integrate over box by breaking up the integrals.", "\n", "", "parts", "=", "[", "ep", "]", "\n", "for", "name", ",", "lower", ",", "upper", "in", "name_and_lims", ":", "\n", "            ", "parts_new", "=", "[", "]", "\n", "for", "part", "in", "parts", ":", "\n", "                ", "if", "not", "is_inf", "(", "upper", ")", ":", "\n", "                    ", "upper", "=", "_as_poly", "(", "upper", ")", "# Ensure that it is a polynomial.", "\n", "parts_new", ".", "append", "(", "part", ".", "translate_var", "(", "name", ",", "upper", ")", ")", "\n", "", "if", "not", "is_inf", "(", "lower", ")", ":", "\n", "                    ", "lower", "=", "_as_poly", "(", "lower", ")", "# Ensure that it is a polynomial.", "\n", "parts_new", ".", "append", "(", "-", "part", ".", "translate_var", "(", "name", ",", "lower", ")", ")", "\n", "", "", "parts", "=", "parts_new", "\n", "\n", "# Perform integration.", "\n", "", "result", "=", "0", "\n", "names", "=", "[", "name", "for", "name", ",", "_", ",", "_", "in", "name_and_lims", "]", "\n", "for", "part", "in", "parts", ":", "\n", "            ", "result", "=", "result", "+", "part", ".", "integrate_half", "(", "*", "names", ",", "**", "var_map", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.translate_var": [[605, 618], ["exppoly.ExpPoly", "exppoly.ExpPoly.poly.substitute", "exppoly.var"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.substitute", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "_dispatch", "\n", "def", "translate_var", "(", "self", ",", "name", ":", "str", ",", "poly", ":", "Poly", ")", ":", "\n", "        ", "\"\"\"Translate a variable by some polynomial; that is, substitute a variable\n        for itself plus some polynomial.\n\n        Args:\n            name (str): Name of variable.\n            poly (:class:`.exppoly.Poly`): Polynomial to shift by.\n\n        Returns:\n            :class:`.exppoly.ExpPoly`: Resulting exponentiated polynomial.\n        \"\"\"", "\n", "return", "ExpPoly", "(", "self", ".", "const", ",", "self", ".", "poly", ".", "substitute", "(", "name", ",", "var", "(", "name", ")", "+", "poly", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate": [[619, 634], ["exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.reject", "a.eval.eval.eval", "exppoly.ExpPoly", "exppoly.ExpPoly.poly.highest_power", "RuntimeError", "exppoly.Factor", "exppoly.Factor", "a.eval.eval.is_constant", "RuntimeError", "exppoly.safe_sqrt", "exppoly.Poly", "exppoly.Term"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_constant", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt"], ["", "def", "_integrate", "(", "self", ",", "name", ")", ":", "\n", "        ", "if", "self", ".", "poly", ".", "highest_power", "(", "name", ")", "!=", "2", ":", "\n", "            ", "raise", "RuntimeError", "(", "f'Dependency on \"{name}\" must be quadratic.'", ")", "\n", "\n", "", "a", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name", ",", "2", ")", ")", "\n", "b", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name", ",", "1", ")", ")", "\n", "c", "=", "self", ".", "poly", ".", "reject", "(", "name", ")", "\n", "\n", "if", "not", "a", ".", "is_constant", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "f'Quadratic coefficient for \"{name}\" must be constant.'", ")", "\n", "\n", "", "a", "=", "a", ".", "eval", "(", ")", "\n", "\n", "return", "ExpPoly", "(", "\n", "self", ".", "const", "*", "safe_sqrt", "(", "-", "B", ".", "pi", "/", "a", ")", ",", "Poly", "(", "Term", "(", "-", "0.25", "/", "a", ")", ")", "*", "b", "**", "2", "+", "c", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half1": [[636, 654], ["exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.reject", "a.eval.eval.eval", "b.eval.eval.eval", "c.eval.eval.eval", "exppoly.ExpPoly.poly.highest_power", "RuntimeError", "exppoly.Factor", "exppoly.Factor", "lab.exp", "lab.erf", "exppoly.safe_sqrt", "exppoly.safe_sqrt"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt"], ["", "def", "_integrate_half1", "(", "self", ",", "name", ",", "**", "var_map", ")", ":", "\n", "        ", "if", "self", ".", "poly", ".", "highest_power", "(", "name", ")", "!=", "2", ":", "\n", "            ", "raise", "RuntimeError", "(", "f'Dependency on \"{name}\" must be quadratic.'", ")", "\n", "\n", "", "a", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name", ",", "2", ")", ")", "\n", "b", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name", ",", "1", ")", ")", "\n", "c", "=", "self", ".", "poly", ".", "reject", "(", "name", ")", "\n", "\n", "a", "=", "a", ".", "eval", "(", "**", "var_map", ")", "\n", "b", "=", "b", ".", "eval", "(", "**", "var_map", ")", "\n", "c", "=", "c", ".", "eval", "(", "**", "var_map", ")", "\n", "\n", "return", "(", "\n", "0.5", "\n", "*", "self", ".", "const", "\n", "*", "safe_sqrt", "(", "-", "B", ".", "pi", "/", "a", ")", "\n", "*", "B", ".", "exp", "(", "-", "0.25", "*", "b", "**", "2", "/", "a", "+", "c", ")", "\n", "*", "(", "1", "-", "B", ".", "erf", "(", "0.5", "*", "b", "/", "safe_sqrt", "(", "-", "a", ")", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half2": [[656, 709], ["exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.collect_for().collect_for", "exppoly.ExpPoly.poly.collect_for().reject", "exppoly.ExpPoly.poly.collect_for().reject", "exppoly.ExpPoly.poly.reject().reject", "b1.eval.eval.eval", "b2.eval.eval.eval", "c.eval.eval.eval", "lab.shape", "functools.reduce", "lab.reshape", "lab.reshape", "lab.reshape", "RuntimeError", "exppoly.Factor", "exppoly.Factor", "exppoly.Factor", "exppoly.ExpPoly.eval", "exppoly.ExpPoly.eval", "exppoly.ExpPoly.eval", "exppoly.safe_sqrt", "exppoly.safe_sqrt", "exppoly.safe_sqrt", "lab.ones", "lab.bvn_cdf", "exppoly.safe_sqrt", "lab.exp", "exppoly.ExpPoly.poly.highest_power", "exppoly.ExpPoly.poly.highest_power", "exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.collect_for", "exppoly.ExpPoly.poly.reject", "exppoly.Factor", "exppoly.Factor", "exppoly.Factor"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.reject"], ["", "def", "_integrate_half2", "(", "self", ",", "name1", ",", "name2", ",", "**", "var_map", ")", ":", "\n", "        ", "if", "self", ".", "poly", ".", "highest_power", "(", "name1", ")", "!=", "2", "or", "self", ".", "poly", ".", "highest_power", "(", "name2", ")", "!=", "2", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "f'Dependency on \"{name1}\" and {name2}\" must '", "f\"be quadratic.\"", "\n", ")", "\n", "\n", "", "a11", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name1", ",", "2", ")", ")", "\n", "a22", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name2", ",", "2", ")", ")", "\n", "a12", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name1", ",", "1", ")", ")", ".", "collect_for", "(", "Factor", "(", "name2", ",", "1", ")", ")", "\n", "b1", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name1", ",", "1", ")", ")", ".", "reject", "(", "name2", ")", "\n", "b2", "=", "self", ".", "poly", ".", "collect_for", "(", "Factor", "(", "name2", ",", "1", ")", ")", ".", "reject", "(", "name1", ")", "\n", "c", "=", "self", ".", "poly", ".", "reject", "(", "name1", ")", ".", "reject", "(", "name2", ")", "\n", "\n", "# Evaluate and scale A.", "\n", "a11", "=", "-", "2", "*", "a11", ".", "eval", "(", "**", "var_map", ")", "\n", "a22", "=", "-", "2", "*", "a22", ".", "eval", "(", "**", "var_map", ")", "\n", "a12", "=", "-", "1", "*", "a12", ".", "eval", "(", "**", "var_map", ")", "\n", "b1", "=", "b1", ".", "eval", "(", "**", "var_map", ")", "\n", "b2", "=", "b2", ".", "eval", "(", "**", "var_map", ")", "\n", "c", "=", "c", ".", "eval", "(", "**", "var_map", ")", "\n", "\n", "# Determinant of A:", "\n", "a_det", "=", "a11", "*", "a22", "-", "a12", "**", "2", "\n", "\n", "# Inverse of A, which corresponds to variance of distribution after", "\n", "# completing the square:", "\n", "ia11", "=", "a22", "/", "a_det", "\n", "ia12", "=", "-", "a12", "/", "a_det", "\n", "ia22", "=", "a11", "/", "a_det", "\n", "\n", "# Mean of distribution after completing the square:", "\n", "mu1", "=", "ia11", "*", "b1", "+", "ia12", "*", "b2", "\n", "mu2", "=", "ia12", "*", "b1", "+", "ia22", "*", "b2", "\n", "\n", "# Normalise and compute CDF part.", "\n", "x1", "=", "-", "mu1", "/", "safe_sqrt", "(", "ia11", ")", "\n", "x2", "=", "-", "mu2", "/", "safe_sqrt", "(", "ia22", ")", "\n", "rho", "=", "ia12", "/", "safe_sqrt", "(", "ia11", "*", "ia22", ")", "\n", "\n", "# Evaluate CDF for all `x1` and `x2`.", "\n", "orig_shape", "=", "B", ".", "shape", "(", "mu1", ")", "\n", "num", "=", "reduce", "(", "operator", ".", "mul", ",", "orig_shape", ",", "1", ")", "\n", "x1", "=", "B", ".", "reshape", "(", "x1", ",", "num", ")", "\n", "x2", "=", "B", ".", "reshape", "(", "x2", ",", "num", ")", "\n", "rho", "=", "rho", "*", "B", ".", "ones", "(", "x1", ")", "\n", "cdf_part", "=", "B", ".", "reshape", "(", "B", ".", "bvn_cdf", "(", "x1", ",", "x2", ",", "rho", ")", ",", "*", "orig_shape", ")", "\n", "\n", "# Compute exponentiated part.", "\n", "quad_form", "=", "0.5", "*", "(", "ia11", "*", "b1", "**", "2", "+", "ia22", "*", "b2", "**", "2", "+", "2", "*", "ia12", "*", "b1", "*", "b2", ")", "\n", "det_part", "=", "2", "*", "B", ".", "pi", "/", "safe_sqrt", "(", "a_det", ")", "\n", "exp_part", "=", "det_part", "*", "B", ".", "exp", "(", "quad_form", "+", "c", ")", "\n", "\n", "return", "self", ".", "const", "*", "cdf_part", "*", "exp_part", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__str__": [[710, 712], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "f\"{self.const} * exp({self.poly})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__repr__": [[713, 715], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__eq__": [[716, 719], ["None"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__eq__", "(", "self", ",", "other", ":", "\"ExpPoly\"", ")", ":", "\n", "        ", "return", "self", ".", "const", "==", "other", ".", "const", "and", "self", ".", "poly", "==", "other", ".", "poly", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__mul__": [[724, 727], ["exppoly.ExpPoly"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "__mul__", "(", "self", ",", "other", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "return", "ExpPoly", "(", "self", ".", "const", "*", "other", ",", "self", ".", "poly", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__rmul__": [[728, 730], ["None"], "methods", ["None"], ["", "def", "__rmul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", "*", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.__neg__": [[731, 733], ["exppoly.ExpPoly"], "methods", ["None"], ["", "def", "__neg__", "(", "self", ")", ":", "\n", "        ", "return", "ExpPoly", "(", "-", "self", ".", "const", ",", "self", ".", "poly", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt": [[12, 22], ["lab.sqrt", "lab.maximum", "lab.cast", "lab.dtype"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.dtype"], ["def", "safe_sqrt", "(", "x", ")", ":", "\n", "    ", "\"\"\"Perform a square root that is safe to use in AD.\n\n    Args:\n        x (tensor): Tensor to take square root of.\n\n    Returns:\n        tensor: Square root of `x`.\n    \"\"\"", "\n", "return", "B", ".", "sqrt", "(", "B", ".", "maximum", "(", "x", ",", "B", ".", "cast", "(", "B", ".", "dtype", "(", "x", ")", ",", "1e-30", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf": [[24, 34], ["isinstance", "numpy.isinf"], "function", ["None"], ["", "def", "is_inf", "(", "x", ")", ":", "\n", "    ", "\"\"\"Check whether `x` is infinite.\n\n    Args:\n        x (object): Object to check.\n\n    Returns:\n        bool: `True` if `x` is infinite and `False` otherwise.\n    \"\"\"", "\n", "return", "isinstance", "(", "x", ",", "B", ".", "Number", ")", "and", "np", ".", "isinf", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const": [[36, 46], ["exppoly.Poly", "exppoly.Term"], "function", ["None"], ["", "def", "const", "(", "x", ")", ":", "\n", "    ", "\"\"\"Constant polynomial.\n\n    Args:\n        x (tensor): Constant.\n\n    Returns:\n        :class:`.exppoly.Poly`: Resulting polynomial.\n    \"\"\"", "\n", "return", "Poly", "(", "Term", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.var": [[48, 59], ["exppoly.Poly", "exppoly.Term", "exppoly.Factor"], "function", ["None"], ["", "def", "var", "(", "x", ",", "power", "=", "1", ")", ":", "\n", "    ", "\"\"\"Polynomial consisting of just a single variable.\n\n    Args:\n        x (tensor): Constant.\n        power (int, optional): Power. Defaults to one.\n\n    Returns:\n        :class:`.exppoly.Poly`: Resulting polynomial.\n    \"\"\"", "\n", "return", "Poly", "(", "Term", "(", "1", ",", "Factor", "(", "x", ",", "power", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._merge_common_factors": [[127, 133], ["set", "filter", "merged_factors.append", "functools.reduce"], "function", ["None"], ["", "", "def", "_merge_common_factors", "(", "*", "factors", ")", ":", "\n", "    ", "merged_factors", "=", "[", "]", "\n", "for", "name", "in", "set", "(", "x", ".", "name", "for", "x", "in", "factors", ")", ":", "\n", "        ", "associated_factors", "=", "filter", "(", "lambda", "x", ":", "x", ".", "name", "==", "name", ",", "factors", ")", "\n", "merged_factors", ".", "append", "(", "reduce", "(", "operator", ".", "mul", ",", "associated_factors", ",", "1", ")", ")", "\n", "", "return", "merged_factors", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._merge_common_terms": [[301, 307], ["set", "filter", "merged_terms.append", "frozenset", "functools.reduce"], "function", ["None"], ["", "", "def", "_merge_common_terms", "(", "*", "terms", ")", ":", "\n", "    ", "merged_terms", "=", "[", "]", "\n", "for", "factors", "in", "set", "(", "frozenset", "(", "x", ".", "factors", ")", "for", "x", "in", "terms", ")", ":", "\n", "        ", "associated_terms", "=", "filter", "(", "lambda", "x", ":", "x", ".", "factors", "==", "factors", ",", "terms", ")", "\n", "merged_terms", ".", "append", "(", "reduce", "(", "operator", ".", "add", ",", "associated_terms", ",", "0", ")", ")", "\n", "", "return", "merged_terms", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._as_poly": [[475, 478], ["exppoly.const"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "@", "_dispatch", "\n", "def", "_as_poly", "(", "x", ":", "B", ".", "Numeric", ")", ":", "\n", "    ", "return", "const", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS.__init__": [[28, 40], ["sample.ESS.move", "sample.ESS.move", "sample_prior"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS.move", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS.move"], ["def", "__init__", "(", "self", ",", "log_lik", ",", "sample_prior", ",", "x_init", "=", "None", ")", ":", "\n", "        ", "self", ".", "log_lik", "=", "log_lik", "\n", "self", ".", "sample_prior", "=", "sample_prior", "\n", "\n", "self", ".", "x", "=", "None", "\n", "self", ".", "log_lik_x", "=", "None", "\n", "\n", "# Initialise.", "\n", "if", "x_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "move", "(", "x_init", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "move", "(", "sample_prior", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS.move": [[41, 49], ["sample.ESS.log_lik"], "methods", ["None"], ["", "", "def", "move", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Move to a particular state.\n\n        Args:\n            x (tensor): State to move to.\n        \"\"\"", "\n", "self", ".", "x", "=", "x", "\n", "self", ".", "log_lik_x", "=", "self", ".", "log_lik", "(", "self", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._establish_ellipse": [[50, 53], ["sample.ESS.sample_prior"], "methods", ["None"], ["", "def", "_establish_ellipse", "(", "self", ")", ":", "\n", "        ", "\"\"\"Establish an ellipse, which is required to draw the new state.\"\"\"", "\n", "self", ".", "y", "=", "self", ".", "sample_prior", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw_proposal": [[54, 65], ["numpy.uniform", "numpy.uniform", "sample.ESS.log_lik", "lab.cos", "lab.sin"], "methods", ["None"], ["", "def", "_draw_proposal", "(", "self", ",", "lower", ",", "upper", ")", ":", "\n", "        ", "\"\"\"Draw a proposal for the next state given a bracket for\n        :math:`\\\\theta`.\n\n        Args:\n            lower (scalar): Lower bound of bracket.\n            upper (scalar): Upper bound of bracket.\n        \"\"\"", "\n", "self", ".", "theta", "=", "rng", ".", "uniform", "(", "lower", ",", "upper", ")", "\n", "self", ".", "x_proposed", "=", "B", ".", "cos", "(", "self", ".", "theta", ")", "*", "self", ".", "x", "+", "B", ".", "sin", "(", "self", ".", "theta", ")", "*", "self", ".", "y", "\n", "self", ".", "log_lik_x_proposed", "=", "self", ".", "log_lik", "(", "self", ".", "x_proposed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw_bracket": [[66, 74], ["numpy.uniform", "numpy.uniform"], "methods", ["None"], ["", "def", "_draw_bracket", "(", "self", ")", ":", "\n", "        ", "\"\"\"Draw a bracket for :math:`\\\\theta`.\n\n        Returns:\n            tuple[scalar]: Tuple contain\n        \"\"\"", "\n", "theta", "=", "rng", ".", "uniform", "(", "0", ",", "2", "*", "B", ".", "pi", ")", "\n", "return", "theta", "-", "2", "*", "B", ".", "pi", ",", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw": [[75, 104], ["sample.ESS._draw_proposal", "sample.SampleFailedException", "sample.ESS._draw", "sample.ESS._draw"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw_proposal", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw"], ["", "def", "_draw", "(", "self", ",", "lower", ",", "upper", ",", "u", ",", "attempts", "=", "1", ",", "max_attempts", "=", "100", ")", ":", "\n", "        ", "\"\"\"Draw new state given a bracket for :math:`\\\\theta`.\n\n        Args:\n            lower (scalar): Lower bound of bracket.\n            upper (scalar): Upper bound of bracket.\n            u (scalar): Slice height.\n            attempts (int, optional): Number of attempts so far. Defaults\n                to one.\n            max_attempts(int, optional): Maximum number of attempts. Defaults\n                to hundred.\n\n        Returns:\n            tuple[scalar]: Tuple containing the proposed state, the\n                corresponding log-likelihood, and the number of attempts.\n        \"\"\"", "\n", "if", "attempts", ">", "max_attempts", ":", "\n", "            ", "raise", "SampleFailedException", "(", "\"Exceeded maximum number of attempts.\"", ")", "\n", "\n", "", "self", ".", "_draw_proposal", "(", "lower", ",", "upper", ")", "\n", "if", "self", ".", "log_lik_x_proposed", ">", "u", ":", "\n", "# Proposal is accepted.", "\n", "            ", "return", "self", ".", "x_proposed", ",", "self", ".", "log_lik_x_proposed", ",", "attempts", "+", "1", "\n", "", "else", ":", "\n", "# Proposal rejected. Shrink bracket and try again.", "\n", "            ", "if", "self", ".", "theta", ">", "0", ":", "\n", "                ", "return", "self", ".", "_draw", "(", "lower", ",", "self", ".", "theta", ",", "u", ",", "attempts", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "_draw", "(", "self", ".", "theta", ",", "upper", ",", "u", ",", "attempts", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS.sample": [[105, 151], ["range", "wbml.out.Progress", "range", "sample.ESS._sample", "samples.append", "sample.ESS._sample", "samples.append", "progress", "len", "lab.stack", "util.autocorr", "numpy.mean.append", "numpy.mean", "numpy.mean", "len", "lab.flatten", "numpy.sum", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.autocorr", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean"], ["", "", "", "def", "sample", "(", "self", ",", "num", "=", "1", ",", "trace", "=", "False", ")", ":", "\n", "        ", "\"\"\"Generate samples from the target distribution.\n\n        Args:\n            num (int, optional): Number of samples. Defaults to one.\n            trace (bool, optional): Show progress. Defaults to `False`.\n\n        Returns:\n            list[tensor]: Samples.\n        \"\"\"", "\n", "samples", "=", "[", "]", "\n", "\n", "if", "trace", ":", "\n", "            ", "with", "wbml", ".", "out", ".", "Progress", "(", "\n", "name", "=", "\"Sampling (ESS)\"", ",", "total", "=", "num", ",", "filter", "=", "{", "\"Attempts\"", ":", "None", "}", "\n", ")", "as", "progress", ":", "\n", "                ", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "                    ", "attempts", ",", "ms_per_attempt", "=", "self", ".", "_sample", "(", ")", "\n", "samples", ".", "append", "(", "self", ".", "x", ")", "\n", "\n", "# Compute average effective sample size.", "\n", "m", "=", "20", "\n", "if", "len", "(", "samples", ")", ">", "m", ":", "\n", "                        ", "ess", "=", "[", "]", "\n", "chain", "=", "B", ".", "stack", "(", "*", "[", "B", ".", "flatten", "(", "x", ")", "[", "0", "]", "for", "x", "in", "samples", "[", "m", ":", "]", "]", ",", "axis", "=", "0", ")", "\n", "corrs", "=", "autocorr", "(", "chain", ",", "window", "=", "True", ",", "lags", "=", "5", ")", "\n", "ess", ".", "append", "(", "len", "(", "samples", ")", "/", "(", "1", "+", "2", "*", "np", ".", "sum", "(", "corrs", ")", ")", ")", "\n", "ess", "=", "np", ".", "mean", "(", "ess", ")", "\n", "", "else", ":", "\n", "                        ", "ess", "=", "np", ".", "nan", "\n", "\n", "", "progress", "(", "\n", "{", "\n", "\"Pseudo-log-likelihood\"", ":", "self", ".", "log_lik_x", ",", "\n", "\"Attempts\"", ":", "attempts", ",", "\n", "\"Milliseconds per attempt\"", ":", "ms_per_attempt", ",", "\n", "\"Effective sample size\"", ":", "ess", ",", "\n", "}", "\n", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "                ", "self", ".", "_sample", "(", ")", "\n", "samples", ".", "append", "(", "self", ".", "x", ")", "\n", "\n", "", "", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._sample": [[152, 183], ["sample.ESS._establish_ellipse", "sample.ESS._draw_bracket", "time.time", "sample.ESS._draw", "numpy.exponential", "numpy.exponential", "wbml.out.Section", "wbml.out.out", "time.time", "str"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._establish_ellipse", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw_bracket", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.sample.ESS._draw"], ["", "def", "_sample", "(", "self", ")", ":", "\n", "        ", "\"\"\"Perform one sample.\n\n        Returns:\n            tuple[int, float]: Number of attempts and milliseconds per attempt.\n        \"\"\"", "\n", "# Keep trying until a sample succeeds.", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "# Draw a slice height.", "\n", "                ", "u", "=", "self", ".", "log_lik_x", "-", "rng", ".", "exponential", "(", "1.0", ")", "\n", "\n", "# Establish ellipse.", "\n", "self", ".", "_establish_ellipse", "(", ")", "\n", "\n", "# Draw a bracket.", "\n", "lower", ",", "upper", "=", "self", ".", "_draw_bracket", "(", ")", "\n", "\n", "# Draw a sample.", "\n", "start", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "x", ",", "self", ".", "log_lik_x", ",", "attempts", "=", "self", ".", "_draw", "(", "lower", ",", "upper", ",", "u", ")", "\n", "\n", "# Record sample and time per attempt.", "\n", "ms_per_attempt", "=", "(", "time", ".", "time", "(", ")", "-", "start", ")", "/", "attempts", "*", "1000", "\n", "\n", "return", "attempts", ",", "ms_per_attempt", "\n", "\n", "", "except", "SampleFailedException", "as", "e", ":", "\n", "# Sample failed. Report failure and try again.", "\n", "                ", "with", "wbml", ".", "out", ".", "Section", "(", "\"Sample failed\"", ")", ":", "\n", "                    ", "wbml", ".", "out", ".", "out", "(", "str", "(", "e", ")", ")", "\n", "", "", "", "", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.__init__": [[40, 44], ["None"], "methods", ["None"], ["@", "_dispatch", "\n", "def", "__init__", "(", "self", ",", "model", ":", "Model", ")", ":", "\n", "        ", "self", ".", "model", "=", "model", "\n", "self", ".", "_q_i", "=", "0", "# Count at which variational posterior we are.", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.p_u": [[45, 54], ["normal.NaturalNormal", "approx._parametrise_natural"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._parametrise_natural"], ["", "@", "property", "\n", "def", "p_u", "(", "self", ")", ":", "\n", "        ", "\"\"\":class:`stheno.Normal`: Current prior for :math:`u`.\"\"\"", "\n", "if", "self", ".", "_q_i", "==", "0", ":", "\n", "            ", "return", "NaturalNormal", "(", "0", ",", "self", ".", "model", ".", "K_u", ")", "\n", "", "else", ":", "\n", "            ", "return", "_parametrise_natural", "(", "\n", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "-", "1", "]", ",", "\n", "self", ".", "model", ".", "n_u", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_u": [[61, 67], ["approx.Approximation.model.ps.q_u[].lam.assign", "approx.Approximation.model.ps.q_u[].prec.assign", "lab.dense", "lab.dense"], "methods", ["None"], ["", "@", "q_u", ".", "setter", "\n", "@", "_dispatch", "\n", "def", "q_u", "(", "self", ",", "dist", ":", "NaturalNormal", ")", ":", "\n", "        ", "self", ".", "q_u", "# Ensure that it is initialised.", "\n", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "]", ".", "lam", ".", "assign", "(", "B", ".", "dense", "(", "dist", ".", "lam", ")", ")", "\n", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "]", ".", "prec", ".", "assign", "(", "B", ".", "dense", "(", "dist", ".", "prec", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.p_z": [[68, 77], ["normal.NaturalNormal", "approx._parametrise_natural"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._parametrise_natural"], ["", "@", "property", "\n", "def", "p_z", "(", "self", ")", ":", "\n", "        ", "\"\"\":class:`stheno.Normal`: Current prior for :math:`z`.\"\"\"", "\n", "if", "self", ".", "_q_i", "==", "0", ":", "\n", "            ", "return", "NaturalNormal", "(", "0", ",", "self", ".", "model", ".", "K_z", ")", "\n", "", "else", ":", "\n", "            ", "return", "_parametrise_natural", "(", "\n", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "-", "1", "]", ",", "\n", "self", ".", "model", ".", "n_z", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z": [[84, 90], ["approx.Approximation.model.ps.q_z[].lam.assign", "approx.Approximation.model.ps.q_z[].prec.assign", "lab.dense", "lab.dense"], "methods", ["None"], ["", "@", "q_z", ".", "setter", "\n", "@", "_dispatch", "\n", "def", "q_z", "(", "self", ",", "dist", ":", "NaturalNormal", ")", ":", "\n", "        ", "self", ".", "q_z", "# Ensure that it is initialised.", "\n", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "]", ".", "lam", ".", "assign", "(", "B", ".", "dense", "(", "dist", ".", "lam", ")", ")", "\n", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "]", ".", "prec", ".", "assign", "(", "B", ".", "dense", "(", "dist", ".", "prec", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.ignore_qs": [[91, 119], ["range", "names.append", "names.append", "names.append", "names.append", "names.append", "approx.Approximation.model.ps.q_u[].all", "approx.Approximation.model.ps.q_z[].all", "names.append", "ValueError", "approx.Approximation.model.ps.q_u[].all", "approx.Approximation.model.ps.q_z[].all", "approx.Approximation.model.ps.q_u[].all", "approx.Approximation.model.ps.q_z[].all"], "methods", ["None"], ["", "def", "ignore_qs", "(", "self", ",", "previous", ",", "current", ")", ":", "\n", "        ", "\"\"\"Get a list of regexes that ignore variables corresponding to approximate\n        posteriors.\n\n        Args:\n            previous (bool): Ignore all previous approximate posteriors.\n            current (bool or str): Current approximate posteriors to ignore. Set to\n                `True` or `False` to ignore all or none or to `z` or `u` to ignore\n                a specific approximate posterior.\n\n        Returns:\n            list[str]: Appropriate list of regexes.\n        \"\"\"", "\n", "names", "=", "[", "]", "\n", "if", "previous", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "_q_i", ")", ":", "\n", "                ", "names", ".", "append", "(", "\"-\"", "+", "self", ".", "model", ".", "ps", ".", "q_u", "[", "i", "]", ".", "all", "(", ")", ")", "\n", "names", ".", "append", "(", "\"-\"", "+", "self", ".", "model", ".", "ps", ".", "q_z", "[", "i", "]", ".", "all", "(", ")", ")", "\n", "", "", "if", "current", "is", "True", ":", "\n", "            ", "names", ".", "append", "(", "\"-\"", "+", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "]", ".", "all", "(", ")", ")", "\n", "names", ".", "append", "(", "\"-\"", "+", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "]", ".", "all", "(", ")", ")", "\n", "", "elif", "current", "==", "\"u\"", ":", "\n", "            ", "names", ".", "append", "(", "\"-\"", "+", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "]", ".", "all", "(", ")", ")", "\n", "", "elif", "current", "==", "\"z\"", ":", "\n", "            ", "names", ".", "append", "(", "\"-\"", "+", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "]", ".", "all", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Invalid value \"{current}\" for `current`.'", ")", "\n", "", "return", "names", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.condition": [[120, 130], ["approx.Approximation.construct_terms"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms"], ["", "def", "condition", "(", "self", ",", "t", ",", "y", ")", ":", "\n", "        ", "\"\"\"Make the current variational approximation the prior and create a new\n        variational posterior for further observations.\n\n        Args:\n            t (vector): Locations of observations.\n            y (vector): Observations.\n        \"\"\"", "\n", "self", ".", "_q_i", "+=", "1", "\n", "self", ".", "ts", "=", "self", ".", "construct_terms", "(", "t", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms": [[131, 172], ["types.SimpleNamespace", "lab.length", "approx.Approximation.model.compute_i_hx", "approx.Approximation.model.compute_I_ux", "approx.Approximation.model.compute_I_hz", "approx.Approximation.model.compute_I_uz", "lab.sum", "lab.sum", "lab.mm", "lab.mm", "lab.sum", "lab.sum", "lab.sum", "lab.sum", "lab.sum", "lab.sum"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_i_hx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_ux", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_hz", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_uz"], ["", "def", "construct_terms", "(", "self", ",", "t", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"Construct commonly required quantities.\n\n        Args:\n            t (vector): Locations of observations.\n            y (vector, optional): Observations.\n        \"\"\"", "\n", "ts", "=", "SimpleNamespace", "(", ")", "\n", "\n", "ts", ".", "n", "=", "B", ".", "length", "(", "t", ")", "\n", "\n", "# Construct integrals.", "\n", "ts", ".", "I_hx", "=", "self", ".", "model", ".", "compute_i_hx", "(", "t", ",", "t", ")", "\n", "ts", ".", "I_ux", "=", "self", ".", "model", ".", "compute_I_ux", "(", ")", "\n", "ts", ".", "I_hz", "=", "self", ".", "model", ".", "compute_I_hz", "(", "t", ")", "\n", "ts", ".", "I_uz", "=", "self", ".", "model", ".", "compute_I_uz", "(", "t", ")", "\n", "\n", "# Do some precomputations.", "\n", "ts", ".", "I_hx_sum", "=", "B", ".", "sum", "(", "ts", ".", "I_hx", ",", "axis", "=", "0", ")", "\n", "ts", ".", "I_hz_sum", "=", "B", ".", "sum", "(", "ts", ".", "I_hz", ",", "axis", "=", "0", ")", "\n", "ts", ".", "I_ux_sum", "=", "ts", ".", "n", "*", "ts", ".", "I_ux", "\n", "\n", "ts", ".", "K_u_squeezed", "=", "B", ".", "mm", "(", "ts", ".", "I_uz", ",", "self", ".", "model", ".", "K_u_inv", ",", "ts", ".", "I_uz", ",", "tr_a", "=", "True", ")", "\n", "ts", ".", "K_z_squeezed", "=", "B", ".", "mm", "(", "ts", ".", "I_uz", ",", "self", ".", "model", ".", "K_z_inv", ",", "ts", ".", "I_uz", ",", "tr_c", "=", "True", ")", "\n", "ts", ".", "A_sum", "=", "ts", ".", "I_ux_sum", "-", "B", ".", "sum", "(", "ts", ".", "K_z_squeezed", ",", "axis", "=", "0", ")", "\n", "ts", ".", "B_sum", "=", "ts", ".", "I_hz_sum", "-", "B", ".", "sum", "(", "ts", ".", "K_u_squeezed", ",", "axis", "=", "0", ")", "\n", "ts", ".", "c_sum", "=", "(", "\n", "ts", ".", "I_hx_sum", "\n", "-", "B", ".", "sum", "(", "self", ".", "model", ".", "K_u_inv", "*", "ts", ".", "I_ux_sum", ")", "\n", "-", "B", ".", "sum", "(", "self", ".", "model", ".", "K_z_inv", "*", "ts", ".", "I_hz_sum", ")", "\n", "# It would be more efficient to first `B.sum(ts.K_z_squeezed, axis=0)`, but", "\n", "# for some reason that results in a segmentation fault when run on with the", "\n", "# JIT on the GPU. I'm not sure what's going on...", "\n", "+", "B", ".", "sum", "(", "self", ".", "model", ".", "K_u_inv", "*", "ts", ".", "K_z_squeezed", ")", "\n", ")", "\n", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "ts", ".", "y", "=", "y", "\n", "ts", ".", "I_uz_sum", "=", "B", ".", "sum", "(", "y", "[", ":", ",", "None", ",", "None", "]", "*", "ts", ".", "I_uz", ",", "axis", "=", "0", ")", "# Weight by data.", "\n", "\n", "", "return", "ts", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_u_optimal": [[173, 190], ["approx.Approximation._q_optimal"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._q_optimal"], ["", "@", "_dispatch", "\n", "def", "q_u_optimal", "(", "self", ",", "ts", ":", "SimpleNamespace", ",", "z", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "\"\"\"Compute the optimal :math:`q(u|z)`.\n\n        Args:\n            ts (:class:`types.SimpleNamespace`): Terms.\n            u (tensor): Sample for :math:`z`.\n\n        Returns:\n            tuple[tensor, tensor]: Natural parameters.\n        \"\"\"", "\n", "return", "self", ".", "_q_optimal", "(", "\n", "ts", ".", "A_sum", ",", "\n", "ts", ".", "I_uz", ",", "\n", "ts", ".", "I_uz_sum", ",", "\n", "self", ".", "model", ".", "K_u", ",", "\n", "z", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_u_optimal_mean_field": [[192, 210], ["approx.Approximation._q_optimal"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._q_optimal"], ["", "@", "_dispatch", "\n", "def", "q_u_optimal_mean_field", "(", "self", ",", "ts", ":", "SimpleNamespace", ",", "q_z", ":", "NaturalNormal", ")", ":", "\n", "        ", "\"\"\"Compute the optimal :math:`q(u)` in the mean-field approximation.\n\n        Args:\n            ts (:class:`types.SimpleNamespace`): Terms.\n            q_z (:class:`.normal.NaturalNormal`): Current estimate for :math:`q(z)`.\n\n        Returns:\n            tuple[tensor, tensor]: Natural parameters.\n        \"\"\"", "\n", "return", "self", ".", "_q_optimal", "(", "\n", "ts", ".", "A_sum", ",", "\n", "ts", ".", "I_uz", ",", "\n", "ts", ".", "I_uz_sum", ",", "\n", "self", ".", "model", ".", "K_u", ",", "\n", "q_z", ".", "mean", ",", "\n", "q_z", ".", "m2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal": [[212, 229], ["approx.Approximation._q_optimal", "lab.transpose", "lab.transpose"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._q_optimal"], ["", "@", "_dispatch", "\n", "def", "q_z_optimal", "(", "self", ",", "ts", ":", "SimpleNamespace", ",", "u", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "\"\"\"Compute the optimal :math:`q(z|u)`.\n\n        Args:\n            ts (:class:`types.SimpleNamespace`): Terms.\n            u (tensor): Sample for :math:`u`.\n\n        Returns:\n            tuple[tensor, tensor]: Natural parameters.\n        \"\"\"", "\n", "return", "self", ".", "_q_optimal", "(", "\n", "ts", ".", "B_sum", ",", "\n", "B", ".", "transpose", "(", "ts", ".", "I_uz", ")", ",", "\n", "B", ".", "transpose", "(", "ts", ".", "I_uz_sum", ")", ",", "\n", "self", ".", "model", ".", "K_z", ",", "\n", "u", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal_mean_field": [[231, 249], ["approx.Approximation._q_optimal", "lab.transpose", "lab.transpose"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._q_optimal"], ["", "@", "_dispatch", "\n", "def", "q_z_optimal_mean_field", "(", "self", ",", "ts", ":", "SimpleNamespace", ",", "q_u", ":", "NaturalNormal", ")", ":", "\n", "        ", "\"\"\"Compute the optimal :math:`q(z)` in the mean-field approximation.\n\n        Args:\n            ts (:class:`types.SimpleNamespace`): Terms.\n            q_u (:class:`.normal.NaturalNormal`): Current estimate for :math:`q(u)`.\n\n        Returns:\n            tuple[tensor, tensor]: Natural parameters.\n        \"\"\"", "\n", "return", "self", ".", "_q_optimal", "(", "\n", "ts", ".", "B_sum", ",", "\n", "B", ".", "transpose", "(", "ts", ".", "I_uz", ")", ",", "\n", "B", ".", "transpose", "(", "ts", ".", "I_uz_sum", ")", ",", "\n", "self", ".", "model", ".", "K_z", ",", "\n", "q_u", ".", "mean", ",", "\n", "q_u", ".", "m2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._q_optimal": [[251, 261], ["normal.NaturalNormal", "lab.mm", "lab.mm", "lab.mm", "lab.mm", "lab.sum"], "methods", ["None"], ["", "def", "_q_optimal", "(", "self", ",", "A", ",", "I", ",", "I_sum", ",", "K", ",", "x", ",", "x2", "=", "None", ")", ":", "\n", "        ", "if", "x2", "is", "not", "None", ":", "\n", "            ", "inner", "=", "B", ".", "mm", "(", "I", ",", "x2", ",", "I", ",", "tr_c", "=", "True", ")", "\n", "", "else", ":", "\n", "# This is _much_ more efficient!", "\n", "            ", "part", "=", "B", ".", "mm", "(", "I", ",", "x", ")", "\n", "inner", "=", "B", ".", "mm", "(", "part", ",", "part", ",", "tr_b", "=", "True", ")", "\n", "", "return", "NaturalNormal", "(", "\n", "B", ".", "mm", "(", "I_sum", ",", "x", ")", "/", "self", ".", "model", ".", "noise", ",", "\n", "K", "+", "(", "A", "+", "B", ".", "sum", "(", "inner", ",", "axis", "=", "0", ")", ")", "/", "self", ".", "model", ".", "noise", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._predict_moments": [[263, 284], ["lab.flatten", "lab.mm", "lab.sum", "lab.sum", "lab.sum", "lab.sum", "lab.sum", "lab.sum", "lab.mm"], "methods", ["None"], ["", "def", "_predict_moments", "(", "self", ",", "ts", ",", "u", ",", "u2", ",", "z", ",", "z2", ")", ":", "\n", "# Compute first moment.", "\n", "        ", "m1", "=", "B", ".", "flatten", "(", "B", ".", "mm", "(", "u", ",", "ts", ".", "I_uz", ",", "z", ",", "tr_a", "=", "True", ")", ")", "\n", "\n", "# Compute second moment.", "\n", "A", "=", "ts", ".", "I_ux", "-", "ts", ".", "K_z_squeezed", "\n", "B_", "=", "ts", ".", "I_hz", "-", "ts", ".", "K_u_squeezed", "\n", "c", "=", "(", "\n", "ts", ".", "I_hx", "\n", "-", "B", ".", "sum", "(", "self", ".", "model", ".", "K_u_inv", "*", "ts", ".", "I_ux", ")", "\n", "-", "B", ".", "sum", "(", "self", ".", "model", ".", "K_z_inv", "*", "ts", ".", "I_hz", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "+", "B", ".", "sum", "(", "self", ".", "model", ".", "K_u_inv", "*", "ts", ".", "K_z_squeezed", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", ")", "\n", "m2", "=", "(", "\n", "B", ".", "sum", "(", "A", "*", "u2", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "+", "B", ".", "sum", "(", "B_", "*", "z2", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", "+", "c", "\n", "+", "B", ".", "sum", "(", "u2", "*", "B", ".", "mm", "(", "ts", ".", "I_uz", ",", "z2", ",", "ts", ".", "I_uz", ",", "tr_c", "=", "True", ")", ",", "axis", "=", "(", "1", ",", "2", ")", ")", "\n", ")", "\n", "\n", "return", "m1", ",", "m2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._sample_kernel": [[285, 291], ["lab.flatten", "approx.Approximation.model.kernel_approx", "lab.flatten", "lab.zero", "lab.matmul"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.kernel_approx"], ["", "def", "_sample_kernel", "(", "self", ",", "t_k", ",", "u", ")", ":", "\n", "        ", "return", "B", ".", "flatten", "(", "\n", "self", ".", "model", ".", "kernel_approx", "(", "\n", "t_k", ",", "\n", "B", ".", "zero", "(", "u", ")", "[", "None", "]", ",", "\n", "B", ".", "flatten", "(", "B", ".", "matmul", "(", "self", ".", "model", ".", "K_u", ",", "u", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.p_u_samples": [[361, 365], ["approx.Structured.model.ps.q_u[].samples"], "methods", ["None"], ["@", "property", "\n", "def", "p_u_samples", "(", "self", ")", ":", "\n", "        ", "\"\"\"tensor: Samples for the current prior for :math:`u`.\"\"\"", "\n", "return", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "-", "1", "]", ".", "samples", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.q_u_samples": [[371, 378], ["approx.Structured.model.ps.q_u[].samples.delete", "lab.stack", "approx.Structured.model.ps.q_u[].samples.unbounded", "lab.flatten"], "methods", ["None"], ["", "@", "q_u_samples", ".", "setter", "\n", "@", "_dispatch", "\n", "def", "q_u_samples", "(", "self", ",", "samples", ":", "list", ")", ":", "\n", "# We need a setter, because these won't be trainable through gradients.", "\n", "        ", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "]", ".", "samples", ".", "delete", "(", ")", "\n", "samples", "=", "B", ".", "stack", "(", "*", "[", "B", ".", "flatten", "(", "x", ")", "for", "x", "in", "samples", "]", ",", "axis", "=", "1", ")", "\n", "self", ".", "model", ".", "ps", ".", "q_u", "[", "self", ".", "_q_i", "]", ".", "samples", ".", "unbounded", "(", "init", "=", "samples", ",", "visible", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.p_z_samples": [[379, 383], ["approx.Structured.model.ps.q_z[].samples"], "methods", ["None"], ["", "@", "property", "\n", "def", "p_z_samples", "(", "self", ")", ":", "\n", "        ", "\"\"\"tensor: Samples from the current prior for :math:`z`.\"\"\"", "\n", "return", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "-", "1", "]", ".", "samples", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.q_z_samples": [[389, 396], ["approx.Structured.model.ps.q_z[].samples.delete", "lab.stack", "approx.Structured.model.ps.q_z[].samples.unbounded", "lab.flatten"], "methods", ["None"], ["", "@", "q_z_samples", ".", "setter", "\n", "@", "_dispatch", "\n", "def", "q_z_samples", "(", "self", ",", "samples", ":", "list", ")", ":", "\n", "# We need a setter, because these won't be trainable through gradients.", "\n", "        ", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "]", ".", "samples", ".", "delete", "(", ")", "\n", "samples", "=", "B", ".", "stack", "(", "*", "[", "B", ".", "flatten", "(", "x", ")", "for", "x", "in", "samples", "]", ",", "axis", "=", "1", ")", "\n", "self", ".", "model", ".", "ps", ".", "q_z", "[", "self", ".", "_q_i", "]", ".", "samples", ".", "unbounded", "(", "init", "=", "samples", ",", "visible", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.elbo": [[420, 426], ["lab.global_random_state", "approx.Structured.elbo", "lab.set_global_random_state"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo"], ["", "@", "_dispatch", "\n", "def", "elbo", "(", "self", ",", "t", ":", "B", ".", "Numeric", ",", "y", ":", "B", ".", "Numeric", ",", "num_samples", ":", "B", ".", "Int", "=", "1000", ")", ":", "\n", "        ", "state", "=", "B", ".", "global_random_state", "(", "self", ".", "model", ".", "dtype", ")", "\n", "state", ",", "elbo", "=", "self", ".", "elbo", "(", "state", ",", "t", ",", "y", ",", "num_samples", "=", "num_samples", ")", "\n", "B", ".", "set_global_random_state", "(", "state", ")", "\n", "return", "elbo", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.elbo_gibbs": [[427, 458], ["approx.Structured.construct_terms", "range", "approx.Structured.q_u_optimal().sample", "approx.Structured.q_z_optimal().sample", "approx.Structured.log_Z_u", "approx.Structured.p_u.logpdf", "jax.lax.stop_gradient", "jax.lax.stop_gradient", "approx.Structured.q_u_optimal", "approx.Structured.q_z_optimal"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.log_Z_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.logpdf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_u_optimal", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal"], ["", "@", "_dispatch", "\n", "def", "elbo_gibbs", "(", "\n", "self", ",", "\n", "state", ":", "B", ".", "RandomState", ",", "\n", "t", ",", "\n", "y", ",", "\n", "u", ":", "B", ".", "Numeric", ",", "\n", "z", ":", "B", ".", "Numeric", ",", "\n", "num_samples", ":", "B", ".", "Int", "=", "5", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Compute an estimate of the structured ELBO ignoring the entropy of\n        the optimal :math:`q(u)`.\n\n        Args:\n            state (random state): Random state.\n            t (vector): Locations of observations.\n            y (vector): Observations.\n            u (matrix): Current sample for :math:`u`.\n            z (matrix): Current sample for :math:`z`.\n            num_samples (int, optional): Number of Gibbs samples. Defaults to `5`.\n\n        Returns:\n            tuple[random state, scalar, matrix, matrix]: Random state, ELBO, updated\n                sample for :math:`u`, and updated sample for :math:`z`.\n        \"\"\"", "\n", "ts", "=", "self", ".", "construct_terms", "(", "t", ",", "y", ")", "\n", "for", "_", "in", "range", "(", "num_samples", ")", ":", "\n", "            ", "state", ",", "u", "=", "self", ".", "q_u_optimal", "(", "ts", ",", "z", ")", ".", "sample", "(", "state", ")", "\n", "state", ",", "z", "=", "self", ".", "q_z_optimal", "(", "ts", ",", "u", ")", ".", "sample", "(", "state", ")", "\n", "", "elbo", "=", "self", ".", "log_Z_u", "(", "ts", ",", "stop_gradient", "(", "u", ")", ")", "+", "self", ".", "p_u", ".", "logpdf", "(", "stop_gradient", "(", "u", ")", ")", "\n", "return", "state", ",", "elbo", ",", "u", ",", "z", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.log_Z_u": [[459, 478], ["approx.Structured.q_z_optimal", "lab.sum", "lab.sum", "lab.squeeze", "lab.logdet", "lab.iqf", "lab.mm", "lab.logdet", "lab.log"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal"], ["", "@", "_dispatch", "\n", "def", "log_Z_u", "(", "self", ",", "ts", ":", "SimpleNamespace", ",", "u", ":", "B", ".", "Numeric", ")", ":", "\n", "        ", "\"\"\"Compute the normalising constant term of the optimal :math:`q(z|u)`.\n\n        Args:\n            ts (:class:`types.SimpleNamespace`): Terms.\n            u (tensor): Sample for :math:`u` to use.\n\n        Returns:\n            scalar: Normalising constant term.\n        \"\"\"", "\n", "q_z", "=", "self", ".", "q_z_optimal", "(", "ts", ",", "u", ")", "\n", "quadratic", "=", "B", ".", "sum", "(", "ts", ".", "y", "**", "2", ")", "+", "B", ".", "sum", "(", "u", "*", "B", ".", "mm", "(", "ts", ".", "A_sum", ",", "u", ")", ")", "+", "ts", ".", "c_sum", "\n", "return", "0.5", "*", "(", "\n", "-", "ts", ".", "n", "*", "B", ".", "log", "(", "2", "*", "B", ".", "pi", "*", "self", ".", "model", ".", "noise", ")", "\n", "-", "quadratic", "/", "self", ".", "model", ".", "noise", "\n", "+", "B", ".", "logdet", "(", "self", ".", "model", ".", "K_z", ")", "\n", "-", "B", ".", "logdet", "(", "q_z", ".", "prec", ")", "\n", "+", "B", ".", "squeeze", "(", "B", ".", "iqf", "(", "q_z", ".", "prec", ",", "q_z", ".", "lam", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.elbo_collapsed_z": [[480, 503], ["approx.Structured.construct_terms", "q_u.sample", "approx.Structured.log_Z_u", "approx.Structured.elbo_collapsed_z.rec"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.log_Z_u"], ["", "@", "_dispatch", "\n", "def", "elbo_collapsed_z", "(", "self", ",", "state", ":", "B", ".", "RandomState", ",", "t", ",", "y", ",", "num_samples", ":", "B", ".", "Int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Compute an estimate of the ELBO collapsed over :math:`q(z|u)`.\n\n        Args:\n            state (random state): Random state.\n            t (vector): Locations of observations.\n            y (vector): Observations.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tuple[random state, scalar] : Random state and ELBO.\n        \"\"\"", "\n", "ts", "=", "self", ".", "construct_terms", "(", "t", ",", "y", ")", "\n", "q_u", "=", "self", ".", "q_u", "\n", "state", ",", "us", "=", "q_u", ".", "sample", "(", "state", ",", "num_samples", ")", "\n", "\n", "@", "B", ".", "jit", "\n", "def", "rec", "(", "u", ")", ":", "\n", "            ", "return", "self", ".", "log_Z_u", "(", "ts", ",", "u", ")", "\n", "\n", "", "recs", "=", "[", "rec", "(", "u", ")", "for", "u", "in", "_columns", "(", "us", ")", "]", "\n", "return", "state", ",", "sum", "(", "recs", ")", "/", "len", "(", "recs", ")", "-", "q_u", ".", "kl", "(", "self", ".", "p_u", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured._sample_p_u": [[504, 509], ["approx._columns", "approx._columns", "approx.Structured.p_u.sample"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._columns", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._columns", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample"], ["", "def", "_sample_p_u", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "if", "self", ".", "_q_i", "==", "0", ":", "\n", "            ", "return", "_columns", "(", "self", ".", "p_u", ".", "sample", "(", "num_samples", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "_columns", "(", "self", ".", "p_u_samples", ",", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.predict": [[510, 534], ["approx.Structured.construct_terms", "zip", "lab.mean", "lab.mean", "approx.Structured.q_z_optimal", "approx.Structured._predict_moments", "lab.stack", "lab.stack", "lab.outer", "approx.Structured.predict.predict_moments"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._predict_moments"], ["", "", "@", "_dispatch", "\n", "def", "predict", "(", "self", ",", "t", ",", "num_samples", ":", "B", ".", "Int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Predict.\n\n        Args:\n            t (vector): Points to predict at.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tuple: Tuple containing the mean and standard deviation of the\n                predictions.\n        \"\"\"", "\n", "ts", "=", "self", ".", "construct_terms", "(", "t", ")", "\n", "\n", "@", "B", ".", "jit", "\n", "def", "predict_moments", "(", "u", ")", ":", "\n", "            ", "q_z", "=", "self", ".", "q_z_optimal", "(", "self", ".", "ts", ",", "u", ")", "\n", "return", "self", ".", "_predict_moments", "(", "ts", ",", "u", ",", "B", ".", "outer", "(", "u", ")", ",", "q_z", ".", "mean", ",", "q_z", ".", "m2", ")", "\n", "\n", "", "m1s", ",", "m2s", "=", "zip", "(", "*", "[", "predict_moments", "(", "u", ")", "for", "u", "in", "self", ".", "_sample_p_u", "(", "num_samples", ")", "]", ")", "\n", "m1", "=", "B", ".", "mean", "(", "B", ".", "stack", "(", "*", "m1s", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "m2", "=", "B", ".", "mean", "(", "B", ".", "stack", "(", "*", "m2s", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "# Don't forget to add in the observation noise!", "\n", "return", "m1", ",", "m2", "-", "m1", "**", "2", "+", "self", ".", "model", ".", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.sample_kernel": [[535, 549], ["approx.Structured._sample_p_u", "lab.jit", "lab.stack", "lab.jit."], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured._sample_p_u", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.jit"], ["", "@", "_dispatch", "\n", "def", "sample_kernel", "(", "self", ",", "t_k", ",", "num_samples", ":", "B", ".", "Int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Sample kernel.\n\n        Args:\n            t_k (vector): Time point to sample at.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tensor: Samples.\n        \"\"\"", "\n", "us", "=", "self", ".", "_sample_p_u", "(", "num_samples", ")", "\n", "sample_kernel", "=", "B", ".", "jit", "(", "self", ".", "_sample_kernel", ")", "\n", "return", "B", ".", "stack", "(", "*", "[", "sample_kernel", "(", "t_k", ",", "u", ")", "for", "u", "in", "us", "]", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured._sample_p_z": [[550, 555], ["approx._columns", "approx._columns", "approx.Structured.p_z.sample"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._columns", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._columns", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample"], ["", "def", "_sample_p_z", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "if", "self", ".", "_q_i", "==", "0", ":", "\n", "            ", "return", "_columns", "(", "self", ".", "p_z", ".", "sample", "(", "num_samples", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "_columns", "(", "self", ".", "p_z_samples", ",", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.predict_z": [[556, 570], ["lab.mean", "lab.mean", "lab.flatten", "lab.stack", "lab.stack", "approx.Structured._sample_p_z"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured._sample_p_z"], ["", "", "@", "_dispatch", "\n", "def", "predict_z", "(", "self", ",", "num_samples", ":", "B", ".", "Int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Predict Fourier features.\n\n        Args:\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tuple[vector, vector]: Marginals of the predictions.\n        \"\"\"", "\n", "zs", "=", "[", "B", ".", "flatten", "(", "x", ")", "for", "x", "in", "self", ".", "_sample_p_z", "(", "num_samples", ")", "]", "\n", "m1", "=", "B", ".", "mean", "(", "B", ".", "stack", "(", "*", "zs", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "m2", "=", "B", ".", "mean", "(", "B", ".", "stack", "(", "*", "[", "z", "**", "2", "for", "z", "in", "zs", "]", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "return", "m1", ",", "m2", "-", "m1", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.MeanField.__init__": [[580, 583], ["approx.Approximation.__init__"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "fit", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "model", ")", "\n", "self", ".", "fit", "=", "fit", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.MeanField.elbo": [[634, 640], ["lab.global_random_state", "approx.MeanField.elbo", "lab.set_global_random_state"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo"], ["", "@", "_dispatch", "\n", "def", "elbo", "(", "self", ",", "t", ":", "B", ".", "Numeric", ",", "y", ":", "B", ".", "Numeric", ",", "collapsed", ":", "Union", "[", "None", ",", "str", "]", "=", "None", ")", ":", "\n", "        ", "state", "=", "B", ".", "global_random_state", "(", "self", ".", "model", ".", "dtype", ")", "\n", "state", ",", "elbo", "=", "self", ".", "elbo", "(", "state", ",", "t", ",", "y", ",", "collapsed", "=", "collapsed", ")", "\n", "B", ".", "set_global_random_state", "(", "state", ")", "\n", "return", "elbo", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.MeanField.predict": [[641, 660], ["approx.MeanField._predict_moments", "approx.MeanField.construct_terms"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation._predict_moments", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms"], ["", "@", "_dispatch", "\n", "def", "predict", "(", "self", ",", "t", ")", ":", "\n", "        ", "\"\"\"Predict.\n\n        Args:\n            t (vector): Points to predict at.\n\n        Returns:\n            tuple[vector, vector]: Marginals of the predictions.\n        \"\"\"", "\n", "m1", ",", "m2", "=", "self", ".", "_predict_moments", "(", "\n", "self", ".", "construct_terms", "(", "t", ")", ",", "\n", "self", ".", "p_u", ".", "mean", ",", "\n", "self", ".", "p_u", ".", "m2", ",", "\n", "self", ".", "p_z", ".", "mean", ",", "\n", "self", ".", "p_z", ".", "m2", ",", "\n", ")", "\n", "# Don't forget to add in the observation noise!", "\n", "return", "m1", ",", "m2", "-", "m1", "**", "2", "+", "self", ".", "model", ".", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.MeanField.sample_kernel": [[661, 675], ["approx.MeanField.p_u.sample", "lab.jit", "lab.stack", "lab.jit.", "approx._columns"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.jit", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._columns"], ["", "@", "_dispatch", "\n", "def", "sample_kernel", "(", "self", ",", "t_k", ",", "num_samples", ":", "B", ".", "Int", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Sample kernel under the mean-field approximation.\n\n        Args:\n            t_k (vector): Time point to sample at.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tensor: Samples.\n        \"\"\"", "\n", "us", "=", "self", ".", "p_u", ".", "sample", "(", "num_samples", ")", "\n", "sample_kernel", "=", "B", ".", "jit", "(", "self", ".", "_sample_kernel", ")", "\n", "return", "B", ".", "stack", "(", "*", "[", "sample_kernel", "(", "t_k", ",", "u", ")", "for", "u", "in", "_columns", "(", "us", ")", "]", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.MeanField.predict_z": [[676, 684], ["lab.flatten", "lab.diag"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "predict_z", "(", "self", ")", ":", "\n", "        ", "\"\"\"Predict Fourier features under the mean-field approximation.\n\n        Returns:\n            tuple[vector, vector]: Marginals of the predictions.\n        \"\"\"", "\n", "return", "B", ".", "flatten", "(", "self", ".", "p_z", ".", "mean", ")", ",", "B", ".", "diag", "(", "self", ".", "p_z", ".", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._parametrise_natural": [[18, 23], ["normal.NaturalNormal", "params.lam.unbounded", "params.prec.positive_definite", "lab.randn", "lab.eye"], "function", ["None"], ["@", "_dispatch", "\n", "def", "_parametrise_natural", "(", "params", ":", "Struct", ",", "n", ":", "B", ".", "Int", ")", ":", "\n", "    ", "return", "NaturalNormal", "(", "\n", "params", ".", "lam", ".", "unbounded", "(", "B", ".", "randn", "(", "n", ",", "1", ")", ",", "shape", "=", "(", "n", ",", "1", ")", ")", ",", "\n", "params", ".", "prec", ".", "positive_definite", "(", "1e-1", "*", "B", ".", "eye", "(", "n", ")", ",", "shape", "=", "(", "n", ",", "n", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._columns": [[26, 31], ["lab.shape", "range", "min", "lab.shape"], "function", ["None"], ["", "@", "_dispatch", "\n", "def", "_columns", "(", "xs", ":", "B", ".", "Numeric", ",", "num", ":", "Union", "[", "None", ",", "B", ".", "Int", "]", "=", "None", ")", ":", "\n", "    ", "if", "num", "is", "None", ":", "\n", "        ", "num", "=", "B", ".", "shape", "(", "xs", ",", "1", ")", "\n", "", "return", "[", "xs", "[", ":", ",", "i", ":", "i", "+", "1", "]", "for", "i", "in", "range", "(", "min", "(", "B", ".", "shape", "(", "xs", ",", "1", ")", ",", "num", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._fit_mean_field_ca": [[295, 356], ["instance.approximation.construct_terms", "normal.NaturalNormal", "normal.NaturalNormal", "normal.NaturalNormal", "instance.approximation.q_u_optimal_mean_field", "normal.NaturalNormal", "instance.approximation.q_z_optimal_mean_field", "zip", "wbml.out.Progress", "range", "lab.dense", "lab.dense", "lab.dense", "lab.dense", "lab.sqrt", "lab.dense", "lab.dense", "lab.dense", "lab.dense", "approx._fit_mean_field_ca.compute_q_u"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_u_optimal_mean_field", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal_mean_field"], ["", "", "@", "_dispatch", "\n", "def", "_fit_mean_field_ca", "(", "instance", ":", "Model", ",", "t", ",", "y", ",", "iters", ":", "B", ".", "Int", "=", "5000", ",", "callback", "=", "None", ")", ":", "\n", "    ", "\"\"\"Train an instance with a mean-field approximation using coordinate ascent.\n\n    Args:\n        instance (:class:`.gpcm.AbstractGPCM`): Instantiated model.\n        t (vector): Locations of observations.\n        y (vector): Observations.\n        iters (int, optional): Fixed point iterations. Defaults to `5000`.\n        callback (function, optional): Callback to call after every fixed-point\n            iteration.\n    \"\"\"", "\n", "ts", "=", "instance", ".", "approximation", ".", "construct_terms", "(", "t", ",", "y", ")", "\n", "\n", "@", "B", ".", "jit", "\n", "def", "compute_q_u", "(", "lam", ",", "prec", ")", ":", "\n", "        ", "q_z", "=", "NaturalNormal", "(", "lam", ",", "prec", ")", "\n", "q_u", "=", "instance", ".", "approximation", ".", "q_u_optimal_mean_field", "(", "ts", ",", "q_z", ")", "\n", "return", "B", ".", "dense", "(", "q_u", ".", "lam", ")", ",", "B", ".", "dense", "(", "q_u", ".", "prec", ")", "\n", "\n", "", "@", "B", ".", "jit", "\n", "def", "compute_q_z", "(", "lam", ",", "prec", ")", ":", "\n", "        ", "q_u", "=", "NaturalNormal", "(", "lam", ",", "prec", ")", "\n", "q_z", "=", "instance", ".", "approximation", ".", "q_z_optimal_mean_field", "(", "ts", ",", "q_u", ")", "\n", "return", "B", ".", "dense", "(", "q_z", ".", "lam", ")", ",", "B", ".", "dense", "(", "q_z", ".", "prec", ")", "\n", "\n", "", "def", "diff", "(", "xs", ",", "ys", ")", ":", "\n", "        ", "total", "=", "0", "\n", "for", "x", ",", "y", "in", "zip", "(", "xs", ",", "ys", ")", ":", "\n", "            ", "total", "+=", "B", ".", "sqrt", "(", "B", ".", "mean", "(", "(", "x", "-", "y", ")", "**", "2", ")", ")", "\n", "", "return", "total", "\n", "\n", "# Perform fixed point iterations.", "\n", "", "with", "wbml", ".", "out", ".", "Progress", "(", "name", "=", "\"Fixed point iterations\"", ",", "total", "=", "iters", ")", "as", "progress", ":", "\n", "        ", "q_u", "=", "instance", ".", "approximation", ".", "q_u", "\n", "q_z", "=", "instance", ".", "approximation", ".", "q_z", "\n", "# To be able to use the JIT, we must pass around plain tensors.", "\n", "q_u", "=", "(", "B", ".", "dense", "(", "q_u", ".", "lam", ")", ",", "B", ".", "dense", "(", "q_u", ".", "prec", ")", ")", "\n", "q_z", "=", "(", "B", ".", "dense", "(", "q_z", ".", "lam", ")", ",", "B", ".", "dense", "(", "q_z", ".", "prec", ")", ")", "\n", "last_q_u", "=", "q_u", "\n", "last_q_z", "=", "q_z", "\n", "\n", "for", "_", "in", "range", "(", "iters", ")", ":", "\n", "            ", "q_u", "=", "compute_q_u", "(", "*", "q_z", ")", "\n", "q_z", "=", "compute_q_z", "(", "*", "q_u", ")", "\n", "current_diff", "=", "diff", "(", "q_u", "+", "q_z", ",", "last_q_u", "+", "last_q_z", ")", "\n", "progress", "(", "{", "\"Difference\"", ":", "current_diff", "}", ")", "\n", "last_q_u", "=", "q_u", "\n", "last_q_z", "=", "q_z", "\n", "\n", "# Perform callback, if given.", "\n", "if", "callback", ":", "\n", "                ", "callback", "(", "NaturalNormal", "(", "*", "q_u", ")", ",", "NaturalNormal", "(", "*", "q_z", ")", ")", "\n", "\n", "# Early stop if possible.", "\n", "", "if", "current_diff", "<", "1e-6", ":", "\n", "                ", "break", "\n", "\n", "# Store result of fixed point iterations.", "\n", "", "", "", "instance", ".", "approximation", ".", "q_u", "=", "NaturalNormal", "(", "*", "q_u", ")", "\n", "instance", ".", "approximation", ".", "q_z", "=", "NaturalNormal", "(", "*", "q_z", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.fit": [[785, 855], ["lab.create_random_state", "approx._fit_mean_field_ca", "model", "varz.minimise_l_bfgs_b", "approx._fit_mean_field_ca", "model().approximation.elbo", "approx._fit_mean_field_ca", "varz.minimise_l_bfgs_b", "model", "model.approximation.construct_terms", "model.approximation.q_z_optimal_mean_field", "ValueError", "model", "model().approximation.ignore_qs", "model", "approx._fit_mean_field_ca", "model().approximation.elbo", "approx._fit_mean_field_ca", "model", "model().approximation.ignore_qs", "model", "model", "model", "model", "model"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._fit_mean_field_ca", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._fit_mean_field_ca", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._fit_mean_field_ca", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.construct_terms", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.q_z_optimal_mean_field", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.ignore_qs", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._fit_mean_field_ca", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx._fit_mean_field_ca", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.ignore_qs", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model"], ["", "@", "fit", ".", "dispatch", "\n", "def", "fit", "(", "model", ",", "t", ",", "y", ",", "approximation", ":", "MeanField", ",", "iters", ":", "B", ".", "Int", "=", "5000", ")", ":", "\n", "    ", "\"\"\"Fit a mean-field approximation.\n\n    Args:\n        model (:class:`.gpcm.AbstractGPCM`): Model.\n        approximation (:class:`.MeanField`): Approximation.\n        t (vector): Locations of observations.\n        y (vector): Observations.\n        iters (int, optional): Fixed point iterations. Defaults to `5000`.\n            Will be divided by `5` to convert to BFGS iterations.\n    \"\"\"", "\n", "# Maintain a random state.", "\n", "state", "=", "B", ".", "create_random_state", "(", "model", ".", "dtype", ",", "seed", "=", "0", ")", "\n", "\n", "if", "approximation", ".", "fit", "==", "\"ca\"", ":", "\n", "        ", "_fit_mean_field_ca", "(", "model", "(", ")", ",", "t", ",", "y", ",", "iters", ")", "\n", "", "elif", "approximation", ".", "fit", "==", "\"bfgs\"", ":", "\n", "# Pre-fit a CA solution, if applicable.", "\n", "        ", "if", "approximation", ".", "fit", "==", "\"ca-bfgs\"", ":", "\n", "            ", "_fit_mean_field_ca", "(", "model", "(", ")", ",", "t", ",", "y", ",", "iters", ")", "\n", "\n", "", "def", "objective", "(", "vs_", ",", "state", ")", ":", "\n", "            ", "state", ",", "elbo", "=", "model", "(", "vs_", ")", ".", "approximation", ".", "elbo", "(", "state", ",", "t", ",", "y", ")", "\n", "return", "-", "elbo", ",", "state", "\n", "\n", "# Optimise hyperparameters.", "\n", "", "_", ",", "state", "=", "minimise_l_bfgs_b", "(", "\n", "objective", ",", "\n", "(", "model", ".", "vs", ",", "state", ")", ",", "\n", "iters", "=", "iters", "//", "5", ",", "\n", "trace", "=", "True", ",", "\n", "jit", "=", "True", ",", "\n", "names", "=", "model", "(", ")", ".", "approximation", ".", "ignore_qs", "(", "previous", "=", "True", ")", ",", "\n", ")", "\n", "\n", "# Post-fit a CA solution, if applicable.", "\n", "if", "approximation", ".", "fit", "==", "\"ca-bfgs\"", ":", "\n", "            ", "_fit_mean_field_ca", "(", "model", "(", ")", ",", "t", ",", "y", ",", "iters", ")", "\n", "", "", "elif", "approximation", ".", "fit", "in", "{", "\"ca-collapsed-bfgs\"", ",", "\"collapsed-bfgs\"", "}", ":", "\n", "# Pre-fit a CA solution, if applicable.", "\n", "        ", "if", "approximation", ".", "fit", "==", "\"ca-collapsed-bfgs\"", ":", "\n", "            ", "_fit_mean_field_ca", "(", "model", "(", ")", ",", "t", ",", "y", ",", "iters", ")", "\n", "\n", "", "def", "objective", "(", "vs_", ",", "state", ")", ":", "\n", "            ", "state", ",", "elbo", "=", "model", "(", "vs_", ")", ".", "approximation", ".", "elbo", "(", "state", ",", "t", ",", "y", ",", "collapsed", "=", "\"z\"", ")", "\n", "return", "-", "elbo", ",", "state", "\n", "\n", "# Optimise hyperparameters.", "\n", "", "_", ",", "state", "=", "minimise_l_bfgs_b", "(", "\n", "objective", ",", "\n", "(", "model", ".", "vs", ",", "state", ")", ",", "\n", "iters", "=", "iters", "//", "5", ",", "\n", "trace", "=", "True", ",", "\n", "jit", "=", "True", ",", "\n", "names", "=", "model", "(", ")", ".", "approximation", ".", "ignore_qs", "(", "previous", "=", "True", ",", "current", "=", "\"z\"", ")", ",", "\n", ")", "\n", "\n", "# Explicitly update :math:`q(z)`: it was collapsed in the ELBO.", "\n", "instance", "=", "model", "(", ")", "\n", "ts", "=", "instance", ".", "approximation", ".", "construct_terms", "(", "t", ",", "y", ")", "\n", "q_u", "=", "instance", ".", "approximation", ".", "q_u", "\n", "q_z", "=", "instance", ".", "approximation", ".", "q_z_optimal_mean_field", "(", "ts", ",", "q_u", ")", "\n", "instance", ".", "approximation", ".", "q_z", "=", "q_z", "\n", "\n", "# Post-fit a CA solution, if applicable.", "\n", "if", "approximation", ".", "fit", "==", "\"ca-collapsed-bfgs\"", ":", "\n", "            ", "_fit_mean_field_ca", "(", "model", "(", ")", ",", "t", ",", "y", ",", "iters", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Invalid value \"{approximation.fit}\" for `fit`.'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.__init__": [[35, 39], ["varz.Vars", "scheme.lower"], "methods", ["None"], ["@", "_dispatch", "\n", "def", "__init__", "(", "self", ",", "scheme", ":", "str", "=", "\"structured\"", ")", ":", "\n", "        ", "self", ".", "vs", "=", "Vars", "(", "jnp", ".", "float64", ")", "\n", "self", ".", "scheme", "=", "scheme", ".", "lower", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.__prior__": [[40, 70], ["model.AbstractGPCM.compute_K_z", "lab.pd_inv", "model.AbstractGPCM.compute_K_u", "lab.pd_inv", "stheno.jax.Normal", "stheno.jax.Normal", "approx.Structured", "approx.MeanField", "approx.MeanField", "approx.MeanField", "approx.MeanField", "approx.MeanField", "approx.MeanField", "ValueError"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_z", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u"], ["", "def", "__prior__", "(", "self", ")", ":", "\n", "# Construct kernel matrices.", "\n", "        ", "self", ".", "K_z", "=", "self", ".", "compute_K_z", "(", ")", "\n", "self", ".", "K_z_inv", "=", "B", ".", "pd_inv", "(", "self", ".", "K_z", ")", "\n", "self", ".", "K_u", "=", "self", ".", "compute_K_u", "(", ")", "\n", "self", ".", "K_u_inv", "=", "B", ".", "pd_inv", "(", "self", ".", "K_u", ")", "\n", "\n", "# Construct priors.", "\n", "self", ".", "p_u", "=", "Normal", "(", "self", ".", "K_u_inv", ")", "\n", "self", ".", "p_z", "=", "Normal", "(", "self", ".", "K_z_inv", ")", "\n", "\n", "# Construct approximation scheme.", "\n", "if", "self", ".", "scheme", "==", "\"structured\"", ":", "\n", "            ", "self", ".", "approximation", "=", "Structured", "(", "self", ")", "\n", "", "elif", "self", ".", "scheme", "==", "\"mean-field\"", ":", "\n", "# Use the best mean-field scheme.", "\n", "            ", "self", ".", "approximation", "=", "MeanField", "(", "self", ",", "fit", "=", "\"ca-collapsed-bfgs\"", ")", "\n", "", "elif", "self", ".", "scheme", "==", "\"mean-field-ca\"", ":", "\n", "            ", "self", ".", "approximation", "=", "MeanField", "(", "self", ",", "fit", "=", "\"ca\"", ")", "\n", "", "elif", "self", ".", "scheme", "==", "\"mean-field-gradient\"", ":", "\n", "            ", "self", ".", "approximation", "=", "MeanField", "(", "self", ",", "fit", "=", "\"bfgs\"", ")", "\n", "", "elif", "self", ".", "scheme", "==", "\"mean-field-collapsed-gradient\"", ":", "\n", "            ", "self", ".", "approximation", "=", "MeanField", "(", "self", ",", "fit", "=", "\"collapsed-bfgs\"", ")", "\n", "", "elif", "self", ".", "scheme", "==", "\"mean-field-ca-gradient\"", ":", "\n", "            ", "self", ".", "approximation", "=", "MeanField", "(", "self", ",", "fit", "=", "\"ca-bfgs\"", ")", "\n", "", "elif", "self", ".", "scheme", "==", "\"mean-field-ca-collapsed-gradient\"", ":", "\n", "            ", "self", ".", "approximation", "=", "MeanField", "(", "self", ",", "fit", "=", "\"ca-collapsed-bfgs\"", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f'Invalid value \"{self.scheme}\" for the approximation scheme.'", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.__condition__": [[72, 74], ["model.AbstractGPCM.approximation.condition"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.condition"], ["", "", "def", "__condition__", "(", "self", ",", "t", ",", "y", ")", ":", "\n", "        ", "self", ".", "approximation", ".", "condition", "(", "t", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo": [[75, 79], ["model.AbstractGPCM.approximation.elbo"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo"], ["", "@", "instancemethod", "\n", "@", "cast", "\n", "def", "elbo", "(", "self", ",", "*", "args", ",", "**", "kw_args", ")", ":", "\n", "        ", "return", "self", ".", "approximation", ".", "elbo", "(", "*", "args", ",", "**", "kw_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict": [[80, 84], ["model.AbstractGPCM.approximation.predict"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict"], ["", "@", "instancemethod", "\n", "@", "cast", "\n", "def", "predict", "(", "self", ",", "*", "args", ",", "**", "kw_args", ")", ":", "\n", "        ", "return", "self", ".", "approximation", ".", "predict", "(", "*", "args", ",", "**", "kw_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_kernel": [[85, 98], ["util.summarise_samples", "model.AbstractGPCM.sample_kernel"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.summarise_samples", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.sample_kernel"], ["", "@", "instancemethod", "\n", "def", "predict_kernel", "(", "self", ",", "t_k", "=", "None", ",", "num_samples", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Predict kernel and normalise prediction.\n\n        Args:\n            t_k (vector, optional): Inputs to sample kernel at. Will be automatically\n                determined if not given.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            :class:`collections.namedtuple`: The prediction.\n        \"\"\"", "\n", "return", "summarise_samples", "(", "*", "self", ".", "sample_kernel", "(", "t_k", "=", "t_k", ",", "num_samples", "=", "num_samples", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.sample_kernel": [[99, 122], ["model.AbstractGPCM.approximation.sample_kernel", "lab.mean", "wbml.out.kv", "lab.linspace"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.sample_kernel", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean"], ["", "@", "instancemethod", "\n", "def", "sample_kernel", "(", "self", ",", "t_k", "=", "None", ",", "num_samples", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Predict kernel and normalise prediction.\n\n        Args:\n            t_k (vector, optional): Inputs to sample kernel at. Will be automatically\n                determined if not given.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tuple[vector, tensor]: Tuple containing the inputs of the samples and the\n                samples.\n        \"\"\"", "\n", "if", "t_k", "is", "None", ":", "\n", "            ", "t_k", "=", "B", ".", "linspace", "(", "self", ".", "dtype", ",", "0", ",", "self", ".", "extent", ",", "300", ")", "\n", "\n", "", "ks", "=", "self", ".", "approximation", ".", "sample_kernel", "(", "t_k", ",", "num_samples", "=", "num_samples", ")", "\n", "\n", "# Normalise predicted kernel.", "\n", "var_mean", "=", "B", ".", "mean", "(", "ks", "[", ":", ",", "0", "]", ")", "\n", "wbml", ".", "out", ".", "kv", "(", "\"Mean variance of kernel samples\"", ",", "var_mean", ")", "\n", "\n", "return", "t_k", ",", "ks", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_psd": [[123, 145], ["model.AbstractGPCM.sample_kernel", "zip", "lab.stack", "util.summarise_samples", "lab.linspace", "util.estimate_psd"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.sample_kernel", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.summarise_samples", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.estimate_psd"], ["", "@", "instancemethod", "\n", "def", "predict_psd", "(", "self", ",", "t_k", "=", "None", ",", "num_samples", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Predict the PSD in dB.\n\n        Args:\n            t_k (vector, optional): Inputs to sample kernel at. Will be automatically\n                determined if not given.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            :class:`collections.namedtuple`: Predictions.\n        \"\"\"", "\n", "if", "t_k", "is", "None", ":", "\n", "            ", "t_k", "=", "B", ".", "linspace", "(", "self", ".", "dtype", ",", "0", ",", "2", "*", "self", ".", "extent", ",", "1000", ")", "\n", "", "t_k", ",", "ks", "=", "self", ".", "sample_kernel", "(", "t_k", ",", "num_samples", "=", "num_samples", ")", "\n", "\n", "# Estimate PSDs.", "\n", "freqs", ",", "psds", "=", "zip", "(", "*", "[", "estimate_psd", "(", "t_k", ",", "k", ",", "db", "=", "False", ")", "for", "k", "in", "ks", "]", ")", "\n", "freqs", "=", "freqs", "[", "0", "]", "\n", "psds", "=", "B", ".", "stack", "(", "*", "psds", ",", "axis", "=", "0", ")", "\n", "\n", "return", "summarise_samples", "(", "freqs", ",", "psds", ",", "db", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_fourier": [[146, 157], ["model.AbstractGPCM.approximation.predict_z"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.MeanField.predict_z"], ["", "@", "instancemethod", "\n", "def", "predict_fourier", "(", "self", ",", "num_samples", "=", "1000", ")", ":", "\n", "        ", "\"\"\"Predict Fourier features.\n\n        Args:\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n\n        Returns:\n            tuple: Marginals of the predictions.\n        \"\"\"", "\n", "return", "self", ".", "approximation", ".", "predict_z", "(", "num_samples", "=", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_filter": [[158, 200], ["lab.global_random_state", "range", "lab.set_global_random_state", "util.summarise_samples", "lab.linspace", "model.AbstractGPCM.approximation.p_u.sample", "lab.mm", "stheno.GP", "util.min_phase.sample", "model.AbstractGPCM.predict_filter.sample_h"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.summarise_samples", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample"], ["", "@", "instancemethod", "\n", "def", "predict_filter", "(", "self", ",", "t_h", "=", "None", ",", "num_samples", "=", "1000", ",", "min_phase", "=", "True", ")", ":", "\n", "        ", "\"\"\"Predict the learned filter.\n\n        Args:\n            t_h (vector, optional): Inputs to sample filter at.\n            num_samples (int, optional): Number of samples to use. Defaults to `1000`.\n            min_phase (bool, optional): Predict a minimum-phase version of the filter.\n                Defaults to `True`.\n\n        Returns:\n            :class:`collections.namedtuple`: Predictions.\n        \"\"\"", "\n", "if", "t_h", "is", "None", ":", "\n", "            ", "t_h", "=", "B", ".", "linspace", "(", "self", ".", "dtype", ",", "-", "self", ".", "extent", ",", "self", ".", "extent", ",", "601", ")", "\n", "\n", "", "@", "B", ".", "jit", "\n", "def", "sample_h", "(", "state", ")", ":", "\n", "            ", "state", ",", "u", "=", "self", ".", "approximation", ".", "p_u", ".", "sample", "(", "state", ")", "\n", "u", "=", "B", ".", "mm", "(", "self", ".", "K_u", ",", "u", ")", "# Transform :math:`\\hat u` into :math:`u`.", "\n", "h", "=", "GP", "(", "self", ".", "k_h", "(", ")", ")", "\n", "h", "=", "h", "|", "(", "h", "(", "self", ".", "t_u", ")", ",", "u", ")", "# Condition on sample.", "\n", "state", ",", "h", "=", "h", "(", "t_h", ")", ".", "sample", "(", "state", ")", "# Sample at desired points.", "\n", "return", "state", ",", "B", ".", "flatten", "(", "h", ")", "\n", "\n", "# Perform sampling.", "\n", "", "state", "=", "B", ".", "global_random_state", "(", "self", ".", "dtype", ")", "\n", "samples", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_samples", ")", ":", "\n", "            ", "state", ",", "h", "=", "sample_h", "(", "state", ")", "\n", "\n", "# Transform sample according to specification.", "\n", "if", "min_phase", ":", "\n", "                ", "h", "=", "transform_min_phase", "(", "h", ")", "\n", "\n", "", "samples", ".", "append", "(", "h", ")", "\n", "", "B", ".", "set_global_random_state", "(", "state", ")", "\n", "\n", "if", "min_phase", ":", "\n", "# Start at zero.", "\n", "            ", "t_h", "=", "t_h", "-", "t_h", "[", "0", "]", "\n", "", "return", "summarise_samples", "(", "t_h", ",", "B", ".", "stack", "(", "*", "samples", ",", "axis", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.kernel_approx": [[201, 227], ["model.AbstractGPCM.compute_i_hx", "lab.cholesky", "lab.trisolve", "lab.mm", "model.AbstractGPCM.compute_I_ux", "lab.mm", "lab.eye", "lab.uprank", "lab.trace", "lab.trace", "lab.mm"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_i_hx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_ux"], ["", "@", "instancemethod", "\n", "@", "cast", "\n", "def", "kernel_approx", "(", "self", ",", "t1", ",", "t2", ",", "u", ")", ":", "\n", "        ", "\"\"\"Kernel approximation using inducing variables :math:`u` for the\n        impulse response :math:`h`.\n\n        Args:\n            t1 (vector): First time input.\n            t2 (vector): Second time input.\n            u (vector): Values of the inducing variables.\n\n        Returns:\n            tensor: Approximation of the kernel matrix broadcasted over `t1` and `t2`.\n        \"\"\"", "\n", "# Construct the first part.", "\n", "part1", "=", "self", ".", "compute_i_hx", "(", "t1", "[", ":", ",", "None", "]", ",", "t2", "[", "None", ",", ":", "]", ")", "\n", "\n", "# Construct the second part.", "\n", "L_u", "=", "B", ".", "cholesky", "(", "self", ".", "K_u", ")", "\n", "inv_L_u", "=", "B", ".", "trisolve", "(", "L_u", ",", "B", ".", "eye", "(", "L_u", ")", ")", "\n", "prod", "=", "B", ".", "mm", "(", "inv_L_u", ",", "B", ".", "uprank", "(", "u", ",", "rank", "=", "2", ")", ")", "\n", "I_ux", "=", "self", ".", "compute_I_ux", "(", "t1", ",", "t2", ")", "\n", "trisolved", "=", "B", ".", "mm", "(", "inv_L_u", ",", "I_ux", ",", "inv_L_u", ",", "tr_c", "=", "True", ")", "\n", "part2", "=", "B", ".", "trace", "(", "trisolved", ")", "-", "B", ".", "trace", "(", "B", ".", "mm", "(", "prod", ",", "trisolved", ",", "prod", ",", "tr_a", "=", "True", ")", ")", "\n", "\n", "return", "part1", "-", "part2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.sample": [[228, 248], ["model.AbstractGPCM.kernel_approx", "lab.sample", "lab.sample", "model.AbstractGPCM.compute_K_u", "util.closest_psd", "lab.sqrt", "lab.randn"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.kernel_approx", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.closest_psd"], ["", "@", "priormethod", "\n", "@", "cast", "\n", "def", "sample", "(", "self", ",", "t", ",", "normalise", "=", "False", ")", ":", "\n", "        ", "\"\"\"Sample the kernel then the function.\n\n        Args:\n            t (vector): Time points to sample the function at.\n            normalise (bool, optional): Normalise the sample of the kernel.\n                Defaults to `False`.\n\n        Returns:\n            tuple: Tuple containing the kernel matrix and the function.\n        \"\"\"", "\n", "u", "=", "B", ".", "sample", "(", "self", ".", "compute_K_u", "(", ")", ")", "[", ":", ",", "0", "]", "\n", "K", "=", "self", ".", "kernel_approx", "(", "t", ",", "t", ",", "u", ")", "\n", "if", "normalise", ":", "\n", "            ", "K", "=", "K", "/", "K", "[", "0", ",", "0", "]", "\n", "", "f", "=", "B", ".", "sample", "(", "closest_psd", "(", "K", ")", ")", "[", ":", ",", "0", "]", "\n", "y", "=", "f", "+", "B", ".", "sqrt", "(", "self", ".", "noise", ")", "*", "B", ".", "randn", "(", "f", ")", "\n", "return", "K", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.save": [[249, 258], ["lab.to_numpy", "open", "pickle.dump", "lab.dense"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Save model and inference results to a file.\n\n        Args:\n            path (str): Path to save to.\n        \"\"\"", "\n", "data", "=", "{", "name", ":", "B", ".", "to_numpy", "(", "B", ".", "dense", "(", "self", ".", "vs", "[", "name", "]", ")", ")", "for", "name", "in", "self", ".", "vs", ".", "names", "}", "\n", "with", "open", "(", "path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "data", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load": [[259, 275], ["pickle.load.items", "open", "pickle.load", "model.AbstractGPCM.vs.assign", "model.AbstractGPCM.vs.unbounded"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load"], ["", "", "def", "load", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Load model from a file.\n\n        Args:\n            path (str): Path to load from.\n        \"\"\"", "\n", "with", "open", "(", "path", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "for", "name", ",", "value", "in", "data", ".", "items", "(", ")", ":", "\n", "            ", "if", "name", "in", "self", ".", "vs", ":", "\n", "# Overwrite existing values.", "\n", "                ", "self", ".", "vs", ".", "assign", "(", "name", ",", "value", ")", "\n", "", "else", ":", "\n", "# Assign an invisible bounded variable: we lost the information about", "\n", "# the constraints.", "\n", "                ", "self", ".", "vs", ".", "unbounded", "(", "init", "=", "value", ",", "visible", "=", "False", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.fit": [[277, 280], ["probmods.fit", "model"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.fit", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model"], ["", "", "", "", "@", "fit", ".", "dispatch", "\n", "def", "fit", "(", "model", ":", "AbstractGPCM", ",", "t", ",", "y", ",", "**", "kw_args", ")", ":", "\n", "    ", "fit", "(", "model", ",", "t", ",", "y", ",", "model", "(", ")", ".", "approximation", ",", "**", "kw_args", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.RGPCM.__init__": [[59, 179], ["model.AbstractGPCM.__init__", "len", "min", "numpy.array", "lab.sqrt", "lab.linspace", "lab.max", "int", "int", "lab.range", "lab.sqrt", "int", "lab.shape", "lab.min", "lab.max", "numpy.ceil", "numpy.ceil", "warnings.warn", "numpy.ceil", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "scheme", "=", "\"structured\"", ",", "\n", "noise", "=", "5e-2", ",", "\n", "fix_noise", "=", "False", ",", "\n", "alpha", "=", "None", ",", "\n", "alpha_t", "=", "None", ",", "\n", "window", "=", "None", ",", "\n", "fix_window", "=", "False", ",", "\n", "lam", "=", "None", ",", "\n", "gamma", "=", "None", ",", "\n", "gamma_t", "=", "None", ",", "\n", "a", "=", "None", ",", "\n", "b", "=", "None", ",", "\n", "m_max", "=", "None", ",", "\n", "m_max_cap", "=", "150", ",", "\n", "n_z", "=", "None", ",", "\n", "scale", "=", "None", ",", "\n", "fix_scale", "=", "False", ",", "\n", "ms", "=", "None", ",", "\n", "n_u", "=", "None", ",", "\n", "n_u_cap", "=", "300", ",", "\n", "t_u", "=", "None", ",", "\n", "extend_t_z", "=", "None", ",", "\n", "t", "=", "None", ",", "\n", ")", ":", "\n", "        ", "AbstractGPCM", ".", "__init__", "(", "self", ",", "scheme", ")", "\n", "\n", "# Ensure that `t` is a vector.", "\n", "if", "t", "is", "not", "None", ":", "\n", "            ", "t", "=", "np", ".", "array", "(", "t", ")", "\n", "\n", "# Store whether to fix the length scale, window length, and noise.", "\n", "", "self", ".", "fix_scale", "=", "fix_scale", "\n", "self", ".", "fix_window", "=", "fix_window", "\n", "self", ".", "fix_noise", "=", "fix_noise", "\n", "\n", "# First initialise optimisable model parameters.", "\n", "if", "alpha", "is", "None", ":", "\n", "            ", "alpha", "=", "1", "/", "window", "\n", "\n", "", "if", "alpha_t", "is", "None", ":", "\n", "            ", "alpha_t", "=", "B", ".", "sqrt", "(", "2", "*", "alpha", ")", "\n", "\n", "", "if", "lam", "is", "None", ":", "\n", "            ", "lam", "=", "1", "/", "scale", "\n", "\n", "", "self", ".", "noise", "=", "noise", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "alpha_t", "=", "alpha_t", "\n", "self", ".", "lam", "=", "lam", "\n", "\n", "# For convenience, also store the extent of the filter.", "\n", "self", ".", "extent", "=", "4", "/", "self", ".", "alpha", "\n", "\n", "# Then initialise fixed variables.", "\n", "if", "t_u", "is", "None", ":", "\n", "# Place inducing points until the filter is `exp(-pi) = 4.32%`.", "\n", "            ", "t_u_max", "=", "B", ".", "pi", "/", "self", ".", "alpha", "\n", "\n", "# `n_u` is required to initialise `t_u`.", "\n", "if", "n_u", "is", "None", ":", "\n", "# Set it to two inducing points per wiggle, multiplied by two to account", "\n", "# for the longer range.", "\n", "                ", "n_u", "=", "int", "(", "np", ".", "ceil", "(", "2", "*", "2", "*", "window", "/", "scale", ")", ")", "\n", "if", "n_u", ">", "n_u_cap", ":", "\n", "                    ", "warnings", ".", "warn", "(", "\n", "f\"Using {n_u} inducing points for the filter, which is too \"", "\n", "f\"many. It is capped to {n_u_cap}.\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", ")", "\n", "n_u", "=", "n_u_cap", "\n", "\n", "", "", "t_u", "=", "B", ".", "linspace", "(", "0", ",", "t_u_max", ",", "n_u", ")", "\n", "\n", "", "if", "n_u", "is", "None", ":", "\n", "            ", "n_u", "=", "B", ".", "shape", "(", "t_u", ")", "[", "0", "]", "\n", "\n", "", "if", "a", "is", "None", ":", "\n", "            ", "a", "=", "B", ".", "min", "(", "t", ")", "-", "B", ".", "max", "(", "t_u", ")", "\n", "\n", "", "if", "b", "is", "None", ":", "\n", "            ", "b", "=", "B", ".", "max", "(", "t", ")", "\n", "\n", "# First, try to determine `m_max` from `n_z`.", "\n", "", "if", "m_max", "is", "None", "and", "n_z", "is", "not", "None", ":", "\n", "            ", "m_max", "=", "int", "(", "np", ".", "ceil", "(", "n_z", "/", "2", ")", ")", "\n", "\n", "", "if", "m_max", "is", "None", ":", "\n", "            ", "freq", "=", "1", "/", "scale", "\n", "m_max", "=", "int", "(", "np", ".", "ceil", "(", "freq", "*", "(", "b", "-", "a", ")", ")", ")", "\n", "if", "m_max", ">", "m_max_cap", ":", "\n", "                ", "warnings", ".", "warn", "(", "\n", "f\"Using {m_max} inducing features, which is too \"", "\n", "f\"many. It is capped to {m_max_cap}.\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", ")", "\n", "m_max", "=", "m_max_cap", "\n", "\n", "", "", "if", "ms", "is", "None", ":", "\n", "            ", "ms", "=", "B", ".", "range", "(", "2", "*", "m_max", "+", "1", ")", "\n", "\n", "", "self", ".", "a", "=", "a", "\n", "self", ".", "b", "=", "b", "\n", "self", ".", "m_max", "=", "m_max", "\n", "self", ".", "ms", "=", "ms", "\n", "self", ".", "n_z", "=", "len", "(", "ms", ")", "\n", "self", ".", "n_u", "=", "n_u", "\n", "self", ".", "t_u", "=", "t_u", "\n", "\n", "# Initialise dependent model parameters.", "\n", "if", "gamma", "is", "None", ":", "\n", "            ", "gamma", "=", "1", "/", "(", "2", "*", "(", "self", ".", "t_u", "[", "1", "]", "-", "self", ".", "t_u", "[", "0", "]", ")", ")", "\n", "\n", "", "if", "gamma_t", "is", "None", ":", "\n", "            ", "gamma_t", "=", "B", ".", "sqrt", "(", "2", "*", "gamma", ")", "\n", "\n", "# Must ensure that `gamma < alpha`.", "\n", "", "self", ".", "gamma", "=", "min", "(", "gamma", ",", "self", ".", "alpha", "/", "1.5", ")", "\n", "self", ".", "gamma_t", "=", "gamma_t", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.RGPCM.k_h": [[180, 190], ["mlkernels.Exp().stretch", "lab.exp", "lab.cast", "mlkernels.Exp", "lab.abs"], "methods", ["None"], ["", "def", "k_h", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the kernel function of the filter.\n\n        Returns:\n            :class:`mlkernels.Kernel`: Kernel for :math:`h`.\n        \"\"\"", "\n", "k_h", "=", "Exp", "(", ")", ".", "stretch", "(", "1", "/", "self", ".", "lam", ")", "# Kernel of filter before window", "\n", "k_h", "*=", "lambda", "t", ":", "B", ".", "exp", "(", "-", "self", ".", "alpha", "*", "B", ".", "abs", "(", "t", ")", ")", "# Window", "\n", "k_h", "*=", "lambda", "t", ":", "B", ".", "cast", "(", "self", ".", "dtype", ",", "t", ">=", "0", ")", "# Causality constraint", "\n", "return", "k_h", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.RGPCM.__prior__": [[191, 220], ["rgpcm.RGPCM.ps.positive", "rgpcm.RGPCM.ps.bounded", "rgpcm.RGPCM.ps.bounded", "model.AbstractGPCM.__prior__", "rgpcm.RGPCM.ps.positive", "rgpcm.RGPCM.ps.positive", "rgpcm.RGPCM.ps.positive", "max"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.__prior__"], ["", "def", "__prior__", "(", "self", ")", ":", "\n", "        ", "gamma_factor_init", "=", "self", ".", "alpha", "/", "self", ".", "gamma", "\n", "\n", "# Make parameters learnable:", "\n", "if", "not", "self", ".", "fix_noise", ":", "\n", "            ", "self", ".", "noise", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "noise", ",", "name", "=", "\"noise\"", ")", "\n", "", "if", "not", "self", ".", "fix_window", ":", "\n", "            ", "self", ".", "alpha", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "alpha", ",", "name", "=", "\"alpha\"", ")", "\n", "", "self", ".", "alpha_t", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "alpha_t", ",", "name", "=", "\"alpha_t\"", ")", "\n", "if", "not", "self", ".", "fix_scale", ":", "\n", "            ", "self", ".", "lam", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "lam", ",", "name", "=", "\"lambda\"", ")", "\n", "# We must ensure that `gamma < alpha`.", "\n", "", "gamma_factor", "=", "self", ".", "ps", ".", "bounded", "(", "\n", "gamma_factor_init", ",", "\n", "lower", "=", "1", ",", "\n", "upper", "=", "1e4", ",", "\n", "name", "=", "\"gamma_factor\"", ",", "\n", ")", "\n", "self", ".", "gamma", "=", "self", ".", "alpha", "/", "gamma_factor", "\n", "self", ".", "gamma_t", "=", "self", ".", "gamma_t", "# Do not learn variable of inter-domain transform!", "\n", "# Bound the inducing points so they don't move away too far.", "\n", "self", ".", "t_u", "=", "self", ".", "ps", ".", "bounded", "(", "\n", "self", ".", "t_u", ",", "\n", "lower", "=", "-", "1e-4", ",", "# First inducing point is at the origin.", "\n", "upper", "=", "max", "(", "self", ".", "t_u", ")", "*", "1.5", ",", "\n", "name", "=", "\"t_u\"", ",", "\n", ")", "\n", "\n", "AbstractGPCM", ".", "__prior__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.compute_K_u": [[222, 236], ["util.method", "matrix.Dense", "lab.exp", "lab.abs"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method"], ["", "", "@", "method", "(", "RGPCM", ")", "\n", "def", "compute_K_u", "(", "model", ")", ":", "\n", "    ", "\"\"\"Covariance matrix of inducing variables :math:`u` associated with\n    :math:`h`.\n\n    Args:\n        model (:class:`.gprv.GPRV`): Model.\n\n    Returns:\n        tensor: :math:`K_u`.\n    \"\"\"", "\n", "return", "Dense", "(", "\n", "(", "model", ".", "gamma_t", "**", "2", "/", "(", "2", "*", "model", ".", "gamma", ")", ")", "\n", "*", "B", ".", "exp", "(", "-", "model", ".", "gamma", "*", "B", ".", "abs", "(", "model", ".", "t_u", "[", ":", ",", "None", "]", "-", "model", ".", "t_u", "[", "None", ",", ":", "]", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.psd_matern_12": [[239, 251], ["None"], "function", ["None"], ["", "def", "psd_matern_12", "(", "omega", ",", "lam", ",", "lam_t", ")", ":", "\n", "    ", "\"\"\"Spectral density of Matern-1/2 process.\n\n    Args:\n        omega (tensor): Frequency.\n        lam (tensor): Decay.\n        lam_t (tensor): Scale.\n\n    Returns:\n        tensor: Spectral density.\n    \"\"\"", "\n", "return", "2", "*", "lam_t", "*", "lam", "/", "(", "lam", "**", "2", "+", "omega", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.compute_K_z": [[253, 274], ["util.method", "rgpcm.psd_matern_12", "lab.cast", "matrix.Diagonal", "matrix.LowRank", "lab.cast", "lab.cast"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.psd_matern_12"], ["", "@", "method", "(", "RGPCM", ")", "\n", "def", "compute_K_z", "(", "model", ")", ":", "\n", "    ", "\"\"\"Covariance matrix :math:`K_z` of :math:`z_m` for :math:`m=0,\\\\ldots,2M`.\n\n    Args:\n        model (:class:`.gprv.GPRV`): Model.\n\n    Returns:\n        matrix: :math:`K_z`.\n    \"\"\"", "\n", "# Compute harmonic frequencies.", "\n", "m", "=", "model", ".", "ms", "-", "B", ".", "cast", "(", "model", ".", "dtype", ",", "model", ".", "ms", ">", "model", ".", "m_max", ")", "*", "model", ".", "m_max", "\n", "omega", "=", "2", "*", "B", ".", "pi", "*", "m", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "\n", "# Compute the parameters of the kernel matrix.", "\n", "lam_t", "=", "1", "\n", "alpha", "=", "0.5", "*", "(", "model", ".", "b", "-", "model", ".", "a", ")", "/", "psd_matern_12", "(", "omega", ",", "model", ".", "lam", ",", "lam_t", ")", "\n", "alpha", "=", "alpha", "+", "alpha", "*", "B", ".", "cast", "(", "model", ".", "dtype", ",", "model", ".", "ms", "==", "0", ")", "\n", "beta", "=", "1", "/", "(", "lam_t", "**", "0.5", ")", "*", "B", ".", "cast", "(", "model", ".", "dtype", ",", "model", ".", "ms", "<=", "model", ".", "m_max", ")", "\n", "\n", "return", "Diagonal", "(", "alpha", ")", "+", "LowRank", "(", "left", "=", "beta", "[", ":", ",", "None", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.compute_i_hx": [[276, 293], ["util.method", "lab.zero", "lab.zero", "lab.exp", "lab.abs"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method"], ["", "@", "method", "(", "RGPCM", ")", "\n", "def", "compute_i_hx", "(", "model", ",", "t1", "=", "None", ",", "t2", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{hx}` integral.\n\n    Args:\n        model (:class:`.gprv.GPRV`): Model.\n        t1 (tensor, optional): First time input. Defaults to zero.\n        t2 (tensor, optional): Second time input. Defaults to zero.\n\n    Returns:\n        tensor: Value of :math:`I_{hx}` for all `t1` and `t2`.\n    \"\"\"", "\n", "if", "t1", "is", "None", ":", "\n", "        ", "t1", "=", "B", ".", "zero", "(", "model", ".", "dtype", ")", "\n", "", "if", "t2", "is", "None", ":", "\n", "        ", "t2", "=", "B", ".", "zero", "(", "model", ".", "dtype", ")", "\n", "", "return", "model", ".", "alpha_t", "**", "2", "/", "2", "/", "model", ".", "alpha", "*", "B", ".", "exp", "(", "-", "model", ".", "lam", "*", "B", ".", "abs", "(", "t1", "-", "t2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.compute_I_ux": [[295, 339], ["util.method", "lab.zeros", "lab.zeros", "rgpcm.integral_abcd_lu", "lab.exp"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd_lu"], ["", "@", "method", "(", "RGPCM", ")", "\n", "def", "compute_I_ux", "(", "model", ",", "t1", "=", "None", ",", "t2", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{ux}` integral.\n\n    Args:\n        model (:class:`.gprv.GPRV`): Model.\n        t1 (tensor, optional): First time input. Defaults to zero.\n        t2 (tensor, optional): Second time input. Defaults to zero.\n\n    Returns:\n        tensor: Value of :math:`I_{ux}` for all `t1`, `t2`.\n    \"\"\"", "\n", "if", "t1", "is", "None", ":", "\n", "        ", "t1", "=", "B", ".", "zeros", "(", "model", ".", "dtype", ",", "1", ")", "\n", "squeeze_t1", "=", "True", "\n", "", "else", ":", "\n", "        ", "squeeze_t1", "=", "False", "\n", "\n", "", "if", "t2", "is", "None", ":", "\n", "        ", "t2", "=", "B", ".", "zeros", "(", "model", ".", "dtype", ",", "1", ")", "\n", "squeeze_t2", "=", "True", "\n", "", "else", ":", "\n", "        ", "squeeze_t2", "=", "False", "\n", "\n", "", "t1", "=", "t1", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "t2", "=", "t2", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "t_u_1", "=", "model", ".", "t_u", "[", "None", ",", "None", ",", ":", ",", "None", "]", "\n", "t_u_2", "=", "model", ".", "t_u", "[", "None", ",", "None", ",", "None", ",", ":", "]", "\n", "ga", "=", "model", ".", "gamma", "-", "model", ".", "alpha", "\n", "result", "=", "(", "\n", "model", ".", "alpha_t", "**", "2", "\n", "*", "model", ".", "gamma_t", "**", "2", "\n", "*", "B", ".", "exp", "(", "-", "model", ".", "gamma", "*", "(", "t_u_1", "+", "t_u_2", ")", "+", "ga", "*", "(", "t1", "+", "t2", ")", ")", "\n", "*", "integral_abcd_lu", "(", "-", "t1", ",", "t_u_2", "-", "t1", ",", "-", "t2", ",", "t_u_1", "-", "t2", ",", "ga", ",", "model", ".", "lam", ")", "\n", ")", "\n", "\n", "if", "squeeze_t1", "and", "squeeze_t2", ":", "\n", "        ", "return", "result", "[", "0", ",", "0", ",", ":", ",", ":", "]", "\n", "", "elif", "squeeze_t1", ":", "\n", "        ", "return", "result", "[", "0", ",", ":", ",", ":", ",", ":", "]", "\n", "", "elif", "squeeze_t2", ":", "\n", "        ", "return", "result", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd": [[341, 369], ["lab.sign", "lab.cast", "lab.exp", "lab.dtype", "lab.exp", "lab.exp", "lab.exp", "lab.minimum", "lab.abs", "lab.abs", "lab.abs", "lab.abs", "lab.abs"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.dtype"], ["", "", "def", "integral_abcd", "(", "a", ",", "b", ",", "c", ",", "d", ")", ":", "\n", "    ", "\"\"\"Compute the a-b-c-d integral from the paper.\n\n    Args:\n        a (tensor): First upper integration bound.\n        b (tensor): Second upper integration bound.\n        c (tensor): Decay for sum.\n        d (tensor): Decay for absolute difference.\n\n    Returns:\n        tensor: Value of the integral.\n    \"\"\"", "\n", "# Compute the conditional and signs.", "\n", "sign", "=", "B", ".", "sign", "(", "a", ")", "\n", "condition", "=", "a", "*", "b", ">=", "0", "\n", "\n", "# Compute the two parts.", "\n", "part1", "=", "sign", "*", "d", "/", "c", "*", "(", "1", "-", "B", ".", "exp", "(", "2", "*", "c", "*", "sign", "*", "B", ".", "minimum", "(", "B", ".", "abs", "(", "a", ")", ",", "B", ".", "abs", "(", "b", ")", ")", ")", ")", "\n", "part2", "=", "(", "\n", "1", "\n", "-", "B", ".", "exp", "(", "c", "*", "a", "-", "d", "*", "B", ".", "abs", "(", "a", ")", ")", "\n", "-", "B", ".", "exp", "(", "c", "*", "b", "-", "d", "*", "B", ".", "abs", "(", "b", ")", ")", "\n", "+", "B", ".", "exp", "(", "c", "*", "(", "a", "+", "b", ")", "-", "d", "*", "B", ".", "abs", "(", "a", "-", "b", ")", ")", "\n", ")", "\n", "\n", "# Combine and return.", "\n", "condition", "=", "B", ".", "cast", "(", "B", ".", "dtype", "(", "part1", ")", ",", "condition", ")", "\n", "return", "(", "condition", "*", "part1", "+", "part2", ")", "/", "(", "c", "**", "2", "-", "d", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd_lu": [[371, 390], ["rgpcm.integral_abcd", "rgpcm.integral_abcd", "rgpcm.integral_abcd", "rgpcm.integral_abcd"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd"], ["", "def", "integral_abcd_lu", "(", "a_lb", ",", "a_ub", ",", "b_lb", ",", "b_ub", ",", "c", ",", "d", ")", ":", "\n", "    ", "\"\"\"Compute the a-b-c-d integral with lower and upper bounds from the paper.\n\n    Args:\n        a_lb (tensor): First lower integration bound.\n        a_ub (tensor): First upper integration bound.\n        b_lb (tensor): Second lower integration bound.\n        b_ub (tensor): Second upper integration bound.\n        c (tensor): Decay for sum.\n        d (tensor): Decay for absolute difference.\n\n    Returns:\n        tensor: Value of the integral.\n    \"\"\"", "\n", "return", "(", "\n", "integral_abcd", "(", "a_ub", ",", "b_ub", ",", "c", ",", "d", ")", "\n", "+", "integral_abcd", "(", "a_lb", ",", "b_lb", ",", "c", ",", "d", ")", "\n", "+", "-", "integral_abcd", "(", "a_ub", ",", "b_lb", ",", "c", ",", "d", ")", "\n", "+", "-", "integral_abcd", "(", "a_lb", ",", "b_ub", ",", "c", ",", "d", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.compute_I_hz": [[393, 469], ["util.method", "numpy.argsort", "util.invert_perm", "rgpcm._I_hx_0_cos", "rgpcm._I_hx_0_cos", "rgpcm._I_hx_0_cos", "rgpcm._I_hx_0_cos", "rgpcm._I_hx_0_sin", "rgpcm._I_hx_0_sin", "rgpcm._I_hx_0_sin", "lab.concat", "lab.transpose", "lab.concat", "lab.take", "lab.take", "lab.concat", "lab.concat"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.invert_perm", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_cos", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_cos", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_cos", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_cos", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_sin", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_sin", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_sin"], ["", "@", "method", "(", "RGPCM", ")", "\n", "def", "compute_I_hz", "(", "model", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{hz,t_i}` matrix for :math:`t_i` in `t`.\n\n    Args:\n        model (:class:`.gprv.GPRV`): Model.\n        t (vector): Time points of data.\n\n    Returns:\n        tensor: Value of :math:`I_{hz,t_i}`, with shape\n            `(len(t), len(model.ms), len(model.ms))`.\n    \"\"\"", "\n", "# Compute sorting permutation.", "\n", "perm", "=", "np", ".", "argsort", "(", "model", ".", "ms", ")", "\n", "inverse_perm", "=", "invert_perm", "(", "perm", ")", "\n", "\n", "# Sort to allow for simple concatenation.", "\n", "m_max", "=", "model", ".", "m_max", "\n", "ms", "=", "model", ".", "ms", "[", "perm", "]", "\n", "\n", "# Construct I_hz for m,n <= M.", "\n", "ns", "=", "ms", "[", "ms", "<=", "m_max", "]", "\n", "I_0_cos_1", "=", "_I_hx_0_cos", "(", "\n", "model", ",", "-", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "I_0_cos_2", "=", "_I_hx_0_cos", "(", "\n", "model", ",", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "I_hz_mnleM", "=", "0.5", "*", "(", "I_0_cos_1", "+", "I_0_cos_2", ")", "\n", "\n", "# Construct I_hz for m,n > M.", "\n", "ns", "=", "ms", "[", "ms", ">", "m_max", "]", "-", "m_max", "\n", "I_0_cos_1", "=", "_I_hx_0_cos", "(", "\n", "model", ",", "-", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "I_0_cos_2", "=", "_I_hx_0_cos", "(", "\n", "model", ",", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "I_hz_mngtM", "=", "0.5", "*", "(", "I_0_cos_1", "-", "I_0_cos_2", ")", "\n", "\n", "# Construct I_hz for 0 < m <= M and n > M.", "\n", "ns", "=", "ms", "[", "(", "0", "<", "ms", ")", "*", "(", "ms", "<=", "m_max", ")", "]", "\n", "ns2", "=", "ms", "[", "ms", ">", "m_max", "]", "# Do not subtract M!", "\n", "I_0_sin_1", "=", "_I_hx_0_sin", "(", "\n", "model", ",", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns2", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "I_0_sin_2", "=", "_I_hx_0_sin", "(", "\n", "model", ",", "-", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns2", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "I_hz_mleM_ngtM", "=", "0.5", "*", "(", "I_0_sin_1", "+", "I_0_sin_2", ")", "\n", "\n", "# Construct I_hz for m = 0 and n > M.", "\n", "ns", "=", "ms", "[", "ms", "==", "0", "]", "\n", "ns2", "=", "ms", "[", "ms", ">", "m_max", "]", "# Do not subtract M!", "\n", "I_hz_0_gtM", "=", "_I_hx_0_sin", "(", "\n", "model", ",", "ns", "[", "None", ",", ":", ",", "None", "]", "+", "ns2", "[", "None", ",", "None", ",", ":", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "\n", "# Concatenate to form I_hz for m <= M and n > M.", "\n", "I_hz_mleM_ngtM", "=", "B", ".", "concat", "(", "I_hz_0_gtM", ",", "I_hz_mleM_ngtM", ",", "axis", "=", "1", ")", "\n", "\n", "# Compute the other half by transposing.", "\n", "I_hz_mgtM_nleM", "=", "B", ".", "transpose", "(", "I_hz_mleM_ngtM", ",", "perm", "=", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "\n", "# Construct result.", "\n", "result", "=", "B", ".", "concat", "(", "\n", "B", ".", "concat", "(", "I_hz_mnleM", ",", "I_hz_mleM_ngtM", ",", "axis", "=", "2", ")", ",", "\n", "B", ".", "concat", "(", "I_hz_mgtM_nleM", ",", "I_hz_mngtM", ",", "axis", "=", "2", ")", ",", "\n", "axis", "=", "1", ",", "\n", ")", "\n", "\n", "# Undo sorting.", "\n", "result", "=", "B", ".", "take", "(", "result", ",", "inverse_perm", ",", "axis", "=", "1", ")", "\n", "result", "=", "B", ".", "take", "(", "result", ",", "inverse_perm", ",", "axis", "=", "2", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_cos": [[471, 490], ["lab.exp", "lab.sin", "lab.cos", "lab.exp"], "function", ["None"], ["", "def", "_I_hx_0_cos", "(", "model", ",", "n", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{0,n:\\\\cos}` integral.\"\"\"", "\n", "omega_n", "=", "2", "*", "B", ".", "pi", "*", "n", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "t_less_a", "=", "t", "-", "model", ".", "a", "\n", "return", "(", "\n", "model", ".", "alpha_t", "**", "2", "\n", "/", "(", "4", "*", "model", ".", "alpha", "**", "2", "+", "omega_n", "**", "2", ")", "\n", "*", "(", "\n", "(", "\n", "2", "\n", "*", "model", ".", "alpha", "\n", "*", "(", "B", ".", "cos", "(", "omega_n", "*", "t_less_a", ")", "-", "B", ".", "exp", "(", "-", "2", "*", "model", ".", "alpha", "*", "t_less_a", ")", ")", "\n", ")", "\n", "+", "omega_n", "*", "B", ".", "sin", "(", "omega_n", "*", "t_less_a", ")", "\n", ")", "\n", ")", "+", "(", "\n", "model", ".", "alpha_t", "**", "2", "\n", "/", "(", "2", "*", "(", "model", ".", "alpha", "+", "model", ".", "lam", ")", ")", "\n", "*", "B", ".", "exp", "(", "-", "2", "*", "model", ".", "alpha", "*", "t_less_a", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._I_hx_0_sin": [[493, 503], ["lab.sin", "lab.exp", "lab.cos"], "function", ["None"], ["", "def", "_I_hx_0_sin", "(", "model", ",", "n", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{0,n:\\\\sin}`, :math:`n>M`, integral.\"\"\"", "\n", "omega", "=", "2", "*", "B", ".", "pi", "*", "(", "n", "-", "model", ".", "m_max", ")", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "t_less_a", "=", "t", "-", "model", ".", "a", "\n", "return", "(", "\n", "model", ".", "alpha_t", "**", "2", "\n", "/", "(", "4", "*", "model", ".", "alpha", "**", "2", "+", "omega", "**", "2", ")", "\n", "*", "(", "\n", "omega", "*", "(", "B", ".", "exp", "(", "-", "2", "*", "model", ".", "alpha", "*", "t_less_a", ")", "-", "B", ".", "cos", "(", "omega", "*", "t_less_a", ")", ")", "\n", "+", "2", "*", "model", ".", "alpha", "*", "B", ".", "sin", "(", "omega", "*", "t_less_a", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.compute_I_uz": [[507, 563], ["util.method", "numpy.argsort", "util.invert_perm", "rgpcm._integral_luk_leq_M", "rgpcm._integral_luk_g_M", "lab.concat", "lab.exp", "rgpcm._integral_lu0", "lab.take"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.invert_perm", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._integral_luk_leq_M", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._integral_luk_g_M", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._integral_lu0"], ["", "@", "method", "(", "RGPCM", ")", "\n", "def", "compute_I_uz", "(", "model", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{uz,t_i}` matrix for :math:`t_i` in `t`.\n\n    Args:\n        model (:class:`.gprv.GPRV`): Model.\n        t (vector): Time points :math:`t_i` of data.\n\n    Returns:\n        tensor: Value of :math:`I_{uz,t_i}`, with shape\n            `(len(t), len(model.t_u), len(model.ms))`.\n    \"\"\"", "\n", "# Compute sorting permutation.", "\n", "perm", "=", "np", ".", "argsort", "(", "model", ".", "ms", ")", "\n", "inverse_perm", "=", "invert_perm", "(", "perm", ")", "\n", "\n", "# Sort to allow for simple concatenation.", "\n", "ms", "=", "model", ".", "ms", "[", "perm", "]", "\n", "\n", "# Part of the factor is absorbed in the integrals.", "\n", "factor", "=", "(", "\n", "model", ".", "alpha_t", "*", "model", ".", "gamma_t", "*", "B", ".", "exp", "(", "-", "model", ".", "gamma", "*", "model", ".", "t_u", "[", "None", ",", ":", ",", "None", "]", ")", "\n", ")", "\n", "\n", "# Compute I(l, u, 0).", "\n", "k", "=", "ms", "[", "ms", "==", "0", "]", "\n", "I_uz0", "=", "(", "\n", "_integral_lu0", "(", "\n", "model", ",", "t", "[", ":", ",", "None", ",", "None", "]", "-", "model", ".", "t_u", "[", "None", ",", ":", ",", "None", "]", ",", "t", "[", ":", ",", "None", ",", "None", "]", "\n", ")", "\n", "+", "k", "[", "None", ",", "None", ",", ":", "]", "\n", ")", "# This is all zeros, but performs broadcasting.", "\n", "\n", "# Compute I(l, u, k) for 0 < k < M + 1.", "\n", "k", "=", "ms", "[", "(", "0", "<", "ms", ")", "*", "(", "ms", "<=", "model", ".", "m_max", ")", "]", "\n", "I_uz_leM", "=", "_integral_luk_leq_M", "(", "\n", "model", ",", "\n", "t", "[", ":", ",", "None", ",", "None", "]", "-", "model", ".", "t_u", "[", "None", ",", ":", ",", "None", "]", ",", "\n", "t", "[", ":", ",", "None", ",", "None", "]", ",", "\n", "k", "[", "None", ",", "None", ",", ":", "]", ",", "\n", ")", "\n", "\n", "# Compute I(l, u, k) for k > M.", "\n", "k", "=", "ms", "[", "ms", ">", "model", ".", "m_max", "]", "\n", "I_uz_gtM", "=", "_integral_luk_g_M", "(", "\n", "model", ",", "\n", "t", "[", ":", ",", "None", ",", "None", "]", "-", "model", ".", "t_u", "[", "None", ",", ":", ",", "None", "]", ",", "\n", "t", "[", ":", ",", "None", ",", "None", "]", ",", "\n", "k", "[", "None", ",", "None", ",", ":", "]", ",", "\n", ")", "\n", "\n", "# Construct result.", "\n", "result", "=", "B", ".", "concat", "(", "I_uz0", ",", "I_uz_leM", ",", "I_uz_gtM", ",", "axis", "=", "2", ")", "\n", "\n", "# Undo sorting and return.", "\n", "return", "factor", "*", "B", ".", "take", "(", "result", ",", "inverse_perm", ",", "axis", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._integral_lu0": [[565, 569], ["lab.exp"], "function", ["None"], ["", "def", "_integral_lu0", "(", "model", ",", "l", ",", "u", ")", ":", "\n", "    ", "\"\"\"Compute :math:`I(l,u,k)` for :math:`k=0`.\"\"\"", "\n", "ag", "=", "model", ".", "alpha", "-", "model", ".", "gamma", "\n", "return", "1", "/", "ag", "*", "(", "1", "-", "B", ".", "exp", "(", "ag", "*", "(", "l", "-", "u", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._integral_luk_leq_M": [[571, 580], ["lab.exp", "lab.cos", "lab.sin", "lab.cos", "lab.sin"], "function", ["None"], ["", "def", "_integral_luk_leq_M", "(", "model", ",", "l", ",", "u", ",", "k", ")", ":", "\n", "    ", "\"\"\"Compute :math:`I(l,u,k)` for :math:`0<k<M+1`. Assumes that :math:`a<l,u<b`.\"\"\"", "\n", "ag", "=", "model", ".", "alpha", "-", "model", ".", "gamma", "\n", "om", "=", "2", "*", "B", ".", "pi", "*", "k", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "return", "(", "1", "/", "(", "ag", "**", "2", "+", "om", "**", "2", ")", ")", "*", "(", "\n", "(", "ag", "*", "B", ".", "cos", "(", "om", "*", "(", "u", "-", "model", ".", "a", ")", ")", "+", "om", "*", "B", ".", "sin", "(", "om", "*", "(", "u", "-", "model", ".", "a", ")", ")", ")", "\n", "-", "(", "\n", "B", ".", "exp", "(", "ag", "*", "(", "l", "-", "u", ")", ")", "\n", "*", "(", "ag", "*", "B", ".", "cos", "(", "om", "*", "(", "l", "-", "model", ".", "a", ")", ")", "+", "om", "*", "B", ".", "sin", "(", "om", "*", "(", "l", "-", "model", ".", "a", ")", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm._integral_luk_g_M": [[584, 597], ["lab.exp", "lab.sin", "lab.cos", "lab.sin", "lab.cos"], "function", ["None"], ["", "def", "_integral_luk_g_M", "(", "model", ",", "l", ",", "u", ",", "k", ")", ":", "\n", "    ", "\"\"\"Internal function :math:`I(l,u,k)` for :math:`k>M`. Assumes that :math:`a<l,u<b`.\n\n    Note:\n        This function gives :math:`-I(l,u,k)`, i.e. *minus* the integral in the paper!\n    \"\"\"", "\n", "ag", "=", "model", ".", "alpha", "-", "model", ".", "gamma", "\n", "om", "=", "2", "*", "B", ".", "pi", "*", "(", "k", "-", "model", ".", "m_max", ")", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "return", "(", "-", "1", "/", "(", "ag", "**", "2", "+", "om", "**", "2", ")", ")", "*", "(", "\n", "(", "-", "ag", "*", "B", ".", "sin", "(", "om", "*", "(", "u", "-", "model", ".", "a", ")", ")", "+", "om", "*", "B", ".", "cos", "(", "om", "*", "(", "u", "-", "model", ".", "a", ")", ")", ")", "\n", "-", "(", "\n", "B", ".", "exp", "(", "ag", "*", "(", "l", "-", "u", ")", ")", "\n", "*", "(", "-", "ag", "*", "B", ".", "sin", "(", "om", "*", "(", "l", "-", "model", ".", "a", ")", ")", "+", "om", "*", "B", ".", "cos", "(", "om", "*", "(", "l", "-", "model", ".", "a", ")", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.min_phase": [[28, 41], ["lab.to_numpy", "numpy.fft.fft", "numpy.imag", "numpy.real", "numpy.fft.ifft", "scipy.signal.hilbert", "numpy.log", "numpy.abs", "numpy.exp", "numpy.abs"], "function", ["None"], ["def", "min_phase", "(", "h", ")", ":", "\n", "    ", "\"\"\"Minimum phase transform using the Hilbert transform.\n\n    Args:\n        h (vector): Filter to transform.\n\n    Returns:\n        vector: Minimum phase filter version of `h`.\n    \"\"\"", "\n", "h", "=", "B", ".", "to_numpy", "(", "h", ")", "\n", "spec", "=", "np", ".", "fft", ".", "fft", "(", "h", ")", "\n", "phase", "=", "np", ".", "imag", "(", "-", "hilbert", "(", "np", ".", "log", "(", "np", ".", "abs", "(", "spec", ")", ")", ")", ")", "\n", "return", "np", ".", "real", "(", "np", ".", "fft", ".", "ifft", "(", "np", ".", "abs", "(", "spec", ")", "*", "np", ".", "exp", "(", "1j", "*", "phase", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.summarise_samples": [[43, 78], ["lab.to_numpy", "tuple", "util.collect", "numpy.random.permutation", "reversed", "range", "lab.to_numpy", "util.summarise_samples.transform"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.collect"], ["", "def", "summarise_samples", "(", "x", ",", "samples", ",", "db", "=", "False", ")", ":", "\n", "    ", "\"\"\"Summarise samples.\n\n    Args:\n        x (vector): Inputs of samples.\n        samples (tensor): Samples, with the first dimension corresponding\n            to different samples.\n        db (bool, optional): Convert to decibels.\n\n    Returns:\n        :class:`collections.namedtuple`: Named tuple containing various\n            statistics of the samples.\n    \"\"\"", "\n", "x", ",", "samples", "=", "B", ".", "to_numpy", "(", "x", ",", "samples", ")", "\n", "random_inds", "=", "np", ".", "random", ".", "permutation", "(", "B", ".", "shape", "(", "samples", ")", "[", "0", "]", ")", "[", ":", "3", "]", "\n", "\n", "def", "transform", "(", "x", ")", ":", "\n", "        ", "if", "db", ":", "\n", "            ", "return", "10", "*", "np", ".", "log10", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "return", "x", "\n", "\n", "", "", "perm", "=", "tuple", "(", "reversed", "(", "range", "(", "B", ".", "rank", "(", "samples", ")", ")", ")", ")", "# Reverse all dimensions.", "\n", "return", "collect", "(", "\n", "x", "=", "B", ".", "to_numpy", "(", "x", ")", ",", "\n", "mean", "=", "transform", "(", "B", ".", "mean", "(", "samples", ",", "axis", "=", "0", ")", ")", ",", "\n", "var", "=", "transform", "(", "B", ".", "std", "(", "samples", ",", "axis", "=", "0", ")", ")", "**", "2", ",", "\n", "err_68_lower", "=", "transform", "(", "B", ".", "quantile", "(", "samples", ",", "0.32", ",", "axis", "=", "0", ")", ")", ",", "\n", "err_68_upper", "=", "transform", "(", "B", ".", "quantile", "(", "samples", ",", "1", "-", "0.32", ",", "axis", "=", "0", ")", ")", ",", "\n", "err_95_lower", "=", "transform", "(", "B", ".", "quantile", "(", "samples", ",", "0.025", ",", "axis", "=", "0", ")", ")", ",", "\n", "err_95_upper", "=", "transform", "(", "B", ".", "quantile", "(", "samples", ",", "1", "-", "0.025", ",", "axis", "=", "0", ")", ")", ",", "\n", "err_99_lower", "=", "transform", "(", "B", ".", "quantile", "(", "samples", ",", "0.0015", ",", "axis", "=", "0", ")", ")", ",", "\n", "err_99_upper", "=", "transform", "(", "B", ".", "quantile", "(", "samples", ",", "1", "-", "0.0015", ",", "axis", "=", "0", ")", ")", ",", "\n", "samples", "=", "transform", "(", "B", ".", "transpose", "(", "samples", ",", "perm", "=", "perm", ")", "[", "...", ",", "random_inds", "]", ")", ",", "\n", "all_samples", "=", "transform", "(", "B", ".", "transpose", "(", "samples", ",", "perm", "=", "perm", ")", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.estimate_psd": [[81, 125], ["lab.to_numpy", "lab.concat", "lab.concat", "numpy.fft.fft", "numpy.abs", "numpy.trapz", "ValueError", "lab.zeros", "numpy.fft.fftfreq", "numpy.real", "len", "numpy.log10"], "function", ["None"], ["", "def", "estimate_psd", "(", "t", ",", "k", ",", "n_zero", "=", "2_000", ",", "db", "=", "False", ")", ":", "\n", "    ", "\"\"\"Estimate the PSD from samples of the kernel.\n\n    Args:\n        t (vector): Time points of the kernel, which should be a linear space\n            starting from the origin.\n        k (vector): Kernel.\n        n_zero (int, optional): Zero padding. Defaults to `2_000`.\n        db (bool, optional): Convert to decibel. Defaults to `False`.\n\n    Returns:\n        vector: PSD, correctly scaled.\n    \"\"\"", "\n", "# Convert to NumPy for compatibility with frameworks.", "\n", "t", ",", "k", "=", "B", ".", "to_numpy", "(", "t", ",", "k", ")", "\n", "\n", "if", "t", "[", "0", "]", "!=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"Time points must start at zero.\"", ")", "\n", "\n", "# Perform zero padding.", "\n", "", "k", "=", "B", ".", "concat", "(", "k", ",", "B", ".", "zeros", "(", "n_zero", ")", ")", "\n", "\n", "# Symmetrise and Fourier transform.", "\n", "k_symmetric", "=", "B", ".", "concat", "(", "k", ",", "k", "[", "1", ":", "-", "1", "]", "[", ":", ":", "-", "1", "]", ")", "\n", "psd", "=", "np", ".", "fft", ".", "fft", "(", "k_symmetric", ")", "\n", "freqs", "=", "np", ".", "fft", ".", "fftfreq", "(", "len", "(", "psd", ")", ")", "/", "(", "t", "[", "1", "]", "-", "t", "[", "0", "]", ")", "\n", "\n", "# Should be real and positive, but the numerics may not be in our favour.", "\n", "psd", "=", "np", ".", "abs", "(", "np", ".", "real", "(", "psd", ")", ")", "\n", "\n", "# Now scale appropriately: the total power should equal `k[0]`.", "\n", "total_power", "=", "np", ".", "trapz", "(", "y", "=", "psd", ",", "x", "=", "freqs", ")", "\n", "psd", "/=", "total_power", "/", "k", "[", "0", "]", "\n", "\n", "# Convert to dB.", "\n", "if", "db", ":", "\n", "        ", "psd", "=", "10", "*", "np", ".", "log10", "(", "psd", ")", "\n", "\n", "# Only return non-negative frequencies.", "\n", "", "inds", "=", "freqs", ">=", "0", "\n", "freqs", "=", "freqs", "[", "inds", "]", "\n", "psd", "=", "psd", "[", "inds", "]", "\n", "\n", "return", "freqs", ",", "psd", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.invert_perm": [[127, 137], ["numpy.array", "enumerate", "len"], "function", ["None"], ["", "def", "invert_perm", "(", "perm", ")", ":", "\n", "    ", "\"\"\"Compute the inverse of a permutation.\n\n    Args:\n        perm (list): Permutation to invert.\n    \"\"\"", "\n", "inverse_perm", "=", "np", ".", "array", "(", "[", "-", "1", "]", "*", "len", "(", "perm", ")", ",", "dtype", "=", "int", ")", "\n", "for", "i", ",", "p", "in", "enumerate", "(", "perm", ")", ":", "\n", "        ", "inverse_perm", "[", "p", "]", "=", "i", "\n", "", "return", "inverse_perm", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.closest_psd": [[139, 157], ["lab.dense", "lab.svd", "lab.matmul", "lab.maximum", "lab.mm", "lab.where", "lab.transpose", "lab.diag", "lab.expand_dims"], "function", ["None"], ["", "def", "closest_psd", "(", "a", ",", "inv", "=", "False", ")", ":", "\n", "    ", "\"\"\"Map a matrix to the closest PSD matrix.\n\n    Args:\n        a (tensor): Matrix.\n        inv (bool, optional): Also invert `a`.\n\n    Returns:\n        tensor: PSD matrix closest to `a` or the inverse of `a`.\n    \"\"\"", "\n", "a", "=", "B", ".", "dense", "(", "a", ")", "\n", "a", "=", "(", "a", "+", "B", ".", "transpose", "(", "a", ")", ")", "/", "2", "\n", "u", ",", "s", ",", "v", "=", "B", ".", "svd", "(", "a", ")", "\n", "signs", "=", "B", ".", "matmul", "(", "u", ",", "v", ",", "tr_a", "=", "True", ")", "\n", "s", "=", "B", ".", "maximum", "(", "B", ".", "diag", "(", "signs", ")", "*", "s", ",", "0", ")", "\n", "if", "inv", ":", "\n", "        ", "s", "=", "B", ".", "where", "(", "s", "==", "0", ",", "0", ",", "1", "/", "s", ")", "\n", "", "return", "B", ".", "mm", "(", "u", "*", "B", ".", "expand_dims", "(", "s", ",", "axis", "=", "-", "2", ")", ",", "v", ",", "tr_b", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.collect": [[159, 171], ["collections.namedtuple"], "function", ["None"], ["", "def", "collect", "(", "name", "=", "\"Quantities\"", ",", "**", "kw_args", ")", ":", "\n", "    ", "\"\"\"Construct a named tuple with certain attributes.\n\n    Args:\n        **kw_args (object): Keyword argument specifying the attributes.\n        name (str): Name of the named tuple. Defaults to \"Quantities\".\n\n    Returns:\n        :class:`collections.namedtuple`: Named tuple of the model with the\n            specified attributes.\n    \"\"\"", "\n", "return", "namedtuple", "(", "name", ",", "kw_args", ")", "(", "**", "kw_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.autocorr": [[173, 212], ["lab.to_numpy", "numpy.reshape", "numpy.correlate", "numpy.mean", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean"], ["", "def", "autocorr", "(", "x", ",", "lags", "=", "None", ",", "cov", "=", "False", ",", "window", "=", "False", ")", ":", "\n", "    ", "\"\"\"Estimate the autocorrelation.\n\n    Args:\n        x (vector): Time series to estimate autocorrelation of.\n        lags (int, optional): Number of lags. Defaults to all lags.\n        cov (bool, optional): Compute covariances rather than correlations. Defaults to\n            `False`.\n        window (bool, optional): Apply a triangular window to the estimate. Defaults to\n            `False`.\n\n    Returns:\n        vector: Autocorrelation.\n    \"\"\"", "\n", "# Convert to NumPy for compatibility with frameworks.", "\n", "x", "=", "B", ".", "to_numpy", "(", "x", ")", "\n", "\n", "# Compute autocovariance.", "\n", "x", "=", "np", ".", "reshape", "(", "x", ",", "-", "1", ")", "# Flatten the input.", "\n", "x", "=", "x", "-", "np", ".", "mean", "(", "x", ")", "\n", "k", "=", "np", ".", "correlate", "(", "x", ",", "x", ",", "mode", "=", "\"full\"", ")", "\n", "k", "=", "k", "[", "k", ".", "size", "//", "2", ":", "]", "\n", "\n", "if", "window", ":", "\n", "# Do not undo the triangular window.", "\n", "        ", "k", "=", "k", "/", "x", ".", "size", "\n", "", "else", ":", "\n", "# Divide by the precise numbers of estimates.", "\n", "        ", "k", "=", "k", "/", "np", ".", "arange", "(", "x", ".", "size", ",", "0", ",", "-", "1", ")", "\n", "\n", "# Get the right number of lags.", "\n", "", "if", "lags", "is", "not", "None", ":", "\n", "        ", "k", "=", "k", "[", ":", "lags", "+", "1", "]", "\n", "\n", "# Divide by estimate of variance if computing correlations.", "\n", "", "if", "not", "cov", ":", "\n", "        ", "k", "=", "k", "/", "k", "[", "0", "]", "\n", "\n", "", "return", "k", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method": [[214, 226], ["setattr"], "function", ["None"], ["", "def", "method", "(", "cls", ")", ":", "\n", "    ", "\"\"\"Decorator to add the function as a method to a class.\n\n    Args:\n        cls (type): Class to add the function as a method to.\n    \"\"\"", "\n", "\n", "def", "decorator", "(", "f", ")", ":", "\n", "        ", "setattr", "(", "cls", ",", "f", ".", "__name__", ",", "f", ")", "\n", "return", "f", "\n", "\n", "", "return", "decorator", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.hessian": [[228, 245], ["ValueError", "jax.jacrev", "lab.rank", "jax.jacrev", "lab.transpose", "lab.shape", "f"], "function", ["None"], ["", "def", "hessian", "(", "f", ",", "x", ")", ":", "\n", "    ", "\"\"\"Compute the Hessian of a function at a certain input.\n\n    Args:\n        f (function): Function to compute Hessian of.\n        x (column vector): Input to compute Hessian at.\n        differentiable (bool, optional): Make the computation of the Hessian\n            differentiable. Defaults to `False`.\n\n    Returns:\n        matrix: Hessian.\n    \"\"\"", "\n", "if", "B", ".", "rank", "(", "x", ")", "!=", "2", "or", "B", ".", "shape", "(", "x", ")", "[", "1", "]", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Input must be a column vector.\"", ")", "\n", "# Use RMAD twice to preserve memory.", "\n", "", "hess", "=", "jax", ".", "jacrev", "(", "jax", ".", "jacrev", "(", "lambda", "x", ":", "f", "(", "x", "[", ":", ",", "None", "]", ")", ")", ")", "(", "x", "[", ":", ",", "0", "]", ")", "\n", "return", "(", "hess", "+", "B", ".", "transpose", "(", "hess", ")", ")", "/", "2", "# Symmetrise to counteract numerical errors.", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.maximum_a_posteriori": [[247, 266], ["varz.Vars", "varz.Vars.unbounded", "varz.minimise_l_bfgs_b", "lab.dtype", "f"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.dtype"], ["", "def", "maximum_a_posteriori", "(", "f", ",", "x_init", ",", "iters", "=", "2000", ")", ":", "\n", "    ", "\"\"\"Compute the MAP estimate.\n\n    Args:\n        f (function): Possibly unnormalised log-density.\n        x_init (column vector): Starting point to start the optimisation.\n        iters (int, optional): Number of optimisation iterations. Defaults to `2000`.\n\n    Returns:\n        tensor: MAP estimate.\n    \"\"\"", "\n", "\n", "def", "objective", "(", "vs_", ")", ":", "\n", "        ", "return", "-", "f", "(", "vs_", "[", "\"x\"", "]", ")", "\n", "\n", "", "vs", "=", "Vars", "(", "B", ".", "dtype", "(", "x_init", ")", ")", "\n", "vs", ".", "unbounded", "(", "init", "=", "x_init", ",", "name", "=", "\"x\"", ")", "\n", "minimise_l_bfgs_b", "(", "objective", ",", "vs", ",", "iters", "=", "iters", ",", "jit", "=", "True", ",", "trace", "=", "True", ")", "\n", "return", "vs", "[", "\"x\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.laplace_approximation": [[268, 282], ["util.maximum_a_posteriori", "stheno.Normal", "util.hessian", "util.closest_psd"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.maximum_a_posteriori", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.hessian", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.closest_psd"], ["", "def", "laplace_approximation", "(", "f", ",", "x_init", ",", "f_eval", "=", "None", ")", ":", "\n", "    ", "\"\"\"Perform a Laplace approximation of a density.\n\n    Args:\n        f (function): Possibly unnormalised log-density.\n        x_init (column vector): Starting point to start the optimisation.\n        f_eval (function): Use this log-density for the evaluation at the MAP estimate.\n\n    Returns:\n        tuple[:class:`stheno.Normal`]: Laplace approximation.\n    \"\"\"", "\n", "x", "=", "maximum_a_posteriori", "(", "f", ",", "x_init", ")", "\n", "precision", "=", "-", "hessian", "(", "f_eval", "if", "f_eval", "is", "not", "None", "else", "f", ",", "x", ")", "\n", "return", "Normal", "(", "x", ",", "closest_psd", "(", "precision", ",", "inv", "=", "True", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.__init__": [[19, 27], ["plum.convert"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lam", ",", "prec", ")", ":", "\n", "        ", "self", ".", "lam", "=", "lam", "\n", "# The Cholesky of `self.prec` will be cached.", "\n", "self", ".", "prec", "=", "convert", "(", "prec", ",", "AbstractMatrix", ")", "\n", "\n", "self", ".", "_mean", "=", "None", "\n", "self", ".", "_var", "=", "None", "\n", "self", ".", "_m2", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.from_normal": [[28, 40], ["cls", "lab.cholsolve", "lab.pd_inv", "lab.chol"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_normal", "(", "cls", ",", "dist", ")", ":", "\n", "        ", "\"\"\"Construct from a normal distribution.\n\n        Args:\n            dist (distribution): Normal distribution to construct from.\n\n        Returns:\n            :class:`.NaturalNormal`: Normal distribution parametrised by the natural\n                parameters of `dist`.\n        \"\"\"", "\n", "return", "cls", "(", "B", ".", "cholsolve", "(", "B", ".", "chol", "(", "dist", ".", "var", ")", ",", "dist", ".", "mean", ")", ",", "B", ".", "pd_inv", "(", "dist", ".", "var", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.to_normal": [[41, 49], ["stheno.Normal"], "methods", ["None"], ["", "def", "to_normal", "(", "self", ")", ":", "\n", "        ", "\"\"\"Convert to normal distribution parametrised by a mean and variance.\n\n        Returns:\n            :class:`stheno.Normal`: Normal distribution parametrised by the a mean\n                and variance.\n        \"\"\"", "\n", "return", "Normal", "(", "self", ".", "mean", ",", "self", ".", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.dtype": [[50, 54], ["lab.dtype"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.dtype"], ["", "@", "property", "\n", "def", "dtype", "(", "self", ")", ":", "\n", "        ", "\"\"\"dtype: Data type.\"\"\"", "\n", "return", "B", ".", "dtype", "(", "self", ".", "lam", ",", "self", ".", "prec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.dim": [[55, 59], ["lab.shape_matrix"], "methods", ["None"], ["", "@", "property", "\n", "def", "dim", "(", "self", ")", ":", "\n", "        ", "\"\"\"int: Dimensionality.\"\"\"", "\n", "return", "B", ".", "shape_matrix", "(", "self", ".", "prec", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean": [[60, 66], ["lab.cholsolve", "lab.chol"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"column vector: Mean.\"\"\"", "\n", "if", "self", ".", "_mean", "is", "None", ":", "\n", "            ", "self", ".", "_mean", "=", "B", ".", "cholsolve", "(", "B", ".", "chol", "(", "self", ".", "prec", ")", ",", "self", ".", "lam", ")", "\n", "", "return", "self", ".", "_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var": [[67, 73], ["lab.pd_inv"], "methods", ["None"], ["", "@", "property", "\n", "def", "var", "(", "self", ")", ":", "\n", "        ", "\"\"\"matrix: Variance.\"\"\"", "\n", "if", "self", ".", "_var", "is", "None", ":", "\n", "            ", "self", ".", "_var", "=", "B", ".", "pd_inv", "(", "self", ".", "prec", ")", "\n", "", "return", "self", ".", "_var", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.m2": [[74, 81], ["lab.cholsolve", "lab.cholsolve", "lab.chol", "lab.chol", "lab.transpose", "lab.outer"], "methods", ["None"], ["", "@", "property", "\n", "def", "m2", "(", "self", ")", ":", "\n", "        ", "\"\"\"matrix: Second moment.\"\"\"", "\n", "if", "self", ".", "_m2", "is", "None", ":", "\n", "            ", "self", ".", "_m2", "=", "B", ".", "cholsolve", "(", "B", ".", "chol", "(", "self", ".", "prec", ")", ",", "self", ".", "prec", "+", "B", ".", "outer", "(", "self", ".", "lam", ")", ")", "\n", "self", ".", "_m2", "=", "B", ".", "cholsolve", "(", "B", ".", "chol", "(", "self", ".", "prec", ")", ",", "B", ".", "transpose", "(", "self", ".", "_m2", ")", ")", "\n", "", "return", "self", ".", "_m2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.sample": [[101, 107], ["lab.global_random_state", "normal.NaturalNormal.sample", "lab.set_global_random_state"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample"], ["", "@", "_dispatch", "\n", "def", "sample", "(", "self", ",", "num", ":", "int", "=", "1", ")", ":", "\n", "        ", "state", "=", "B", ".", "global_random_state", "(", "self", ".", "dtype", ")", "\n", "state", ",", "samples", "=", "self", ".", "sample", "(", "state", ",", "num", "=", "num", ")", "\n", "B", ".", "set_global_random_state", "(", "state", ")", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.kl": [[108, 126], ["lab.solve", "lab.chol", "lab.chol", "lab.cast", "lab.sum", "lab.sum", "lab.logdet", "lab.mm", "lab.mm"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "kl", "(", "self", ",", "other", ":", "\"NaturalNormal\"", ")", ":", "\n", "        ", "\"\"\"Compute the Kullback-Leibler divergence with respect to another normal\n        parametrised by its natural parameters.\n\n        Args:\n            other (:class:`.NaturalNormal`): Other.\n\n        Returns:\n            scalar: KL divergence with respect to `other`.\n        \"\"\"", "\n", "ratio", "=", "B", ".", "solve", "(", "B", ".", "chol", "(", "self", ".", "prec", ")", ",", "B", ".", "chol", "(", "other", ".", "prec", ")", ")", "\n", "diff", "=", "self", ".", "mean", "-", "other", ".", "mean", "\n", "return", "0.5", "*", "(", "\n", "B", ".", "sum", "(", "ratio", "**", "2", ")", "\n", "-", "B", ".", "logdet", "(", "B", ".", "mm", "(", "ratio", ",", "ratio", ",", "tr_a", "=", "True", ")", ")", "\n", "+", "B", ".", "sum", "(", "B", ".", "mm", "(", "other", ".", "prec", ",", "diff", ")", "*", "diff", ")", "\n", "-", "B", ".", "cast", "(", "self", ".", "dtype", ",", "self", ".", "dim", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.logpdf": [[128, 142], ["lab.subtract", "lab.sum", "lab.logdet", "lab.cast", "lab.cast", "lab.mm"], "methods", ["None"], ["", "def", "logpdf", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Compute the log-pdf of some data.\n\n        Args:\n            x (column vector): Data to compute log-pdf of.\n\n        Returns:\n            scalar: Log-pdf of `x`.\n        \"\"\"", "\n", "diff", "=", "B", ".", "subtract", "(", "x", ",", "self", ".", "mean", ")", "\n", "return", "-", "0.5", "*", "(", "\n", "-", "B", ".", "logdet", "(", "self", ".", "prec", ")", "\n", "+", "B", ".", "cast", "(", "self", ".", "dtype", ",", "self", ".", "dim", ")", "*", "B", ".", "cast", "(", "self", ".", "dtype", ",", "B", ".", "log_2_pi", ")", "\n", "+", "B", ".", "sum", "(", "B", ".", "mm", "(", "self", ".", "prec", ",", "diff", ")", "*", "diff", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.__init__": [[84, 220], ["model.AbstractGPCM.__init__", "numpy.array", "gpcm.scale_to_factor", "gpcm.factor_to_scale", "lab.linspace", "int", "gpcm.scale_to_factor", "gpcm.scale_to_factor", "gpcm.factor_to_scale", "int", "lab.linspace", "lab.linspace", "lab.shape", "int", "min", "max", "lab.shape", "gpcm.factor_to_scale", "numpy.ceil", "lab.linspace", "lab.linspace", "numpy.ceil", "warnings.warn", "numpy.ceil", "warnings.warn", "max", "min", "max", "min", "min", "max", "max", "min"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.__init__", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.scale_to_factor", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.factor_to_scale", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.scale_to_factor", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.scale_to_factor", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.factor_to_scale", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.factor_to_scale"], ["def", "__init__", "(", "\n", "self", ",", "\n", "scheme", "=", "\"structured\"", ",", "\n", "causal", "=", "False", ",", "\n", "noise", "=", "5e-2", ",", "\n", "fix_noise", "=", "False", ",", "\n", "alpha", "=", "None", ",", "\n", "alpha_t", "=", "None", ",", "\n", "window", "=", "None", ",", "\n", "fix_window", "=", "False", ",", "\n", "gamma", "=", "None", ",", "\n", "scale", "=", "None", ",", "\n", "fix_scale", "=", "False", ",", "\n", "omega", "=", "None", ",", "\n", "n_u", "=", "None", ",", "\n", "n_u_cap", "=", "300", ",", "\n", "t_u", "=", "None", ",", "\n", "n_z", "=", "None", ",", "\n", "n_z_cap", "=", "300", ",", "\n", "t_z", "=", "None", ",", "\n", "extend_t_z", "=", "False", ",", "\n", "t", "=", "None", ",", "\n", ")", ":", "\n", "        ", "AbstractGPCM", ".", "__init__", "(", "self", ",", "scheme", ")", "\n", "\n", "# Store whether this is the CGPCM instead of the GPCM.", "\n", "self", ".", "causal", "=", "causal", "\n", "\n", "# Store whether to fix the length scale, window length, and noise.", "\n", "self", ".", "fix_scale", "=", "fix_scale", "\n", "self", ".", "fix_window", "=", "fix_window", "\n", "self", ".", "fix_noise", "=", "fix_noise", "\n", "\n", "# Ensure that `t` is a vector.", "\n", "if", "t", "is", "not", "None", ":", "\n", "            ", "t", "=", "np", ".", "array", "(", "t", ")", "\n", "\n", "# First initialise optimisable model parameters.", "\n", "", "if", "alpha", "is", "None", ":", "\n", "            ", "alpha", "=", "scale_to_factor", "(", "window", ")", "\n", "\n", "", "if", "alpha_t", "is", "None", ":", "\n", "            ", "if", "causal", ":", "\n", "                ", "alpha_t", "=", "(", "8", "*", "alpha", "/", "B", ".", "pi", ")", "**", "0.25", "\n", "", "else", ":", "\n", "                ", "alpha_t", "=", "(", "2", "*", "alpha", "/", "B", ".", "pi", ")", "**", "0.25", "\n", "\n", "", "", "if", "gamma", "is", "None", ":", "\n", "            ", "gamma", "=", "scale_to_factor", "(", "scale", ")", "-", "0.5", "*", "alpha", "\n", "\n", "", "self", ".", "noise", "=", "noise", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "alpha_t", "=", "alpha_t", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n", "# For convenience, also store the extent of the filter.", "\n", "self", ".", "extent", "=", "4", "*", "factor_to_scale", "(", "self", ".", "alpha", ")", "\n", "\n", "# Then initialise fixed variables.", "\n", "if", "t_u", "is", "None", ":", "\n", "# Place inducing points until the filter is `exp(-pi) = 4.32%`.", "\n", "            ", "t_u_max", "=", "2", "*", "factor_to_scale", "(", "self", ".", "alpha", ")", "\n", "\n", "# `n_u` is required to initialise `t_u`.", "\n", "if", "n_u", "is", "None", ":", "\n", "# Set it to two inducing points per wiggle, multiplied by two to account", "\n", "# for both sides (acausal model) or the longer range (causal model).", "\n", "                ", "n_u", "=", "int", "(", "np", ".", "ceil", "(", "2", "*", "2", "*", "window", "/", "scale", ")", ")", "\n", "if", "n_u", ">", "n_u_cap", ":", "\n", "                    ", "warnings", ".", "warn", "(", "\n", "f\"Using {n_u} inducing points for the filter, which is too \"", "\n", "f\"many. It is capped to {n_u_cap}.\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", ")", "\n", "n_u", "=", "n_u_cap", "\n", "\n", "# For the causal case, only need inducing points on the right side.", "\n", "", "", "if", "causal", ":", "\n", "                ", "d_t_u", "=", "t_u_max", "/", "(", "n_u", "-", "1", ")", "\n", "n_u", "+=", "2", "\n", "t_u", "=", "B", ".", "linspace", "(", "-", "2", "*", "d_t_u", ",", "t_u_max", ",", "n_u", ")", "\n", "", "else", ":", "\n", "                ", "if", "n_u", "%", "2", "==", "0", ":", "\n", "                    ", "n_u", "+=", "1", "\n", "", "t_u", "=", "B", ".", "linspace", "(", "-", "t_u_max", ",", "t_u_max", ",", "n_u", ")", "\n", "\n", "", "", "if", "n_u", "is", "None", ":", "\n", "            ", "n_u", "=", "B", ".", "shape", "(", "t_u", ")", "[", "0", "]", "\n", "\n", "", "if", "t_z", "is", "None", ":", "\n", "            ", "if", "n_z", "is", "None", ":", "\n", "# Use two inducing points per wiggle.", "\n", "                ", "n_z", "=", "int", "(", "np", ".", "ceil", "(", "2", "*", "(", "max", "(", "t", ")", "-", "min", "(", "t", ")", ")", "/", "scale", ")", ")", "\n", "if", "n_z", ">", "n_z_cap", ":", "\n", "                    ", "warnings", ".", "warn", "(", "\n", "f\"Using {n_z} inducing points, which is too \"", "\n", "f\"many. It is capped to {n_z_cap}.\"", ",", "\n", "category", "=", "UserWarning", ",", "\n", ")", "\n", "n_z", "=", "n_z_cap", "\n", "\n", "", "", "t_z", "=", "B", ".", "linspace", "(", "min", "(", "t", ")", ",", "max", "(", "t", ")", ",", "n_z", ")", "\n", "\n", "", "if", "n_z", "is", "None", ":", "\n", "            ", "n_z", "=", "B", ".", "shape", "(", "t_z", ")", "[", "0", "]", "\n", "\n", "", "if", "extend_t_z", ":", "\n", "# See above.", "\n", "            ", "t_z_extra", "=", "2", "*", "factor_to_scale", "(", "self", ".", "alpha", ")", "\n", "\n", "d_t_u", "=", "(", "max", "(", "t", ")", "-", "min", "(", "t", ")", ")", "/", "(", "n_z", "-", "1", ")", "\n", "n_z_extra", "=", "int", "(", "np", ".", "ceil", "(", "t_z_extra", "/", "d_t_u", ")", ")", "\n", "t_z_extra", "=", "n_z_extra", "*", "d_t_u", "# Make it align exactly.", "\n", "\n", "# For the causal case, only need inducing points on the left side.", "\n", "if", "causal", ":", "\n", "                ", "n_z", "+=", "n_z_extra", "\n", "t_z", "=", "B", ".", "linspace", "(", "min", "(", "t", ")", "-", "t_z_extra", ",", "max", "(", "t", ")", ",", "n_z", ")", "\n", "", "else", ":", "\n", "                ", "n_z", "+=", "2", "*", "n_z_extra", "\n", "t_z", "=", "B", ".", "linspace", "(", "min", "(", "t", ")", "-", "t_z_extra", ",", "max", "(", "t", ")", "+", "t_z_extra", ",", "n_z", ")", "\n", "\n", "", "", "self", ".", "n_u", "=", "n_u", "\n", "self", ".", "t_u", "=", "t_u", "\n", "self", ".", "n_z", "=", "n_z", "\n", "self", ".", "t_z", "=", "t_z", "\n", "\n", "# Initialise dependent optimisable model parameters.", "\n", "if", "omega", "is", "None", ":", "\n", "            ", "omega", "=", "scale_to_factor", "(", "0.5", "*", "(", "self", ".", "t_z", "[", "1", "]", "-", "self", ".", "t_z", "[", "0", "]", ")", ")", "\n", "\n", "# Fix variance of inter-domain process to one.", "\n", "", "omega_t", "=", "(", "2", "*", "omega", "/", "B", ".", "pi", ")", "**", "0.25", "\n", "\n", "self", ".", "omega", "=", "omega", "\n", "self", ".", "omega_t", "=", "omega_t", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h": [[240, 254], ["lab.sqrt", "mlkernels.EQ().stretch", "lab.exp", "mlkernels.EQ", "lab.cast"], "methods", ["None"], ["", "@", "_dispatch", "\n", "def", "k_h", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the kernel function of the filter.\n\n        Returns:\n            :class:`mlkernels.Kernel`: Kernel for :math:`h`.\n        \"\"\"", "\n", "# Convert `self.gamma` to a regular length scale.", "\n", "gamma_scale", "=", "B", ".", "sqrt", "(", "1", "/", "(", "2", "*", "self", ".", "gamma", ")", ")", "\n", "k_h", "=", "EQ", "(", ")", ".", "stretch", "(", "gamma_scale", ")", "# Kernel of filter before window", "\n", "k_h", "*=", "lambda", "t", ":", "B", ".", "exp", "(", "-", "self", ".", "alpha", "*", "t", "**", "2", ")", "# Window", "\n", "if", "self", ".", "causal", ":", "\n", "            ", "k_h", "*=", "lambda", "t", ":", "B", ".", "cast", "(", "self", ".", "dtype", ",", "t", ">=", "0", ")", "# Causality constraint", "\n", "", "return", "k_h", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_xs": [[255, 267], ["exppoly.ExpPoly", "exppoly.const"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "def", "k_xs", "(", "self", ",", "t1", ",", "t2", ")", ":", "\n", "        ", "\"\"\"Covariance function between to the white noise :math:`x` and its interdomain\n        transform :math:`s`.\n\n        Args:\n            t1 (tensor): First input :math:`t_1`.\n            t2 (tensor): Second input :math:`t_2`.\n\n        Returns:\n            :class:`.exppoly.ExpPoly`: Expression for :math:`k_{xs}(t_1, t_2)`.\n        \"\"\"", "\n", "return", "ExpPoly", "(", "self", ".", "omega_t", ",", "-", "const", "(", "self", ".", "omega", ")", "*", "(", "t1", "-", "t2", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.__prior__": [[268, 289], ["gpcm.GPCM.ps.positive", "gpcm.GPCM.ps.positive", "gpcm.GPCM.ps.bounded", "gpcm.GPCM.ps.unbounded", "model.AbstractGPCM.__prior__", "gpcm.GPCM.ps.positive", "gpcm.GPCM.ps.positive", "gpcm.GPCM.ps.positive", "min", "max"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.__prior__"], ["", "def", "__prior__", "(", "self", ")", ":", "\n", "# Make parameters learnable:", "\n", "        ", "if", "not", "self", ".", "fix_noise", ":", "\n", "            ", "self", ".", "noise", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "noise", ",", "name", "=", "\"noise\"", ")", "\n", "", "if", "not", "self", ".", "fix_window", ":", "\n", "            ", "self", ".", "alpha", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "alpha", ",", "name", "=", "\"alpha\"", ")", "\n", "", "self", ".", "alpha_t", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "alpha_t", ",", "name", "=", "\"alpha_t\"", ")", "\n", "if", "not", "self", ".", "fix_scale", ":", "\n", "            ", "self", ".", "gamma", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "gamma", ",", "name", "=", "\"gamma\"", ")", "\n", "", "self", ".", "omega", "=", "self", ".", "ps", ".", "positive", "(", "self", ".", "omega", ",", "name", "=", "\"omega\"", ")", "\n", "self", ".", "omega_t", "=", "self", ".", "omega_t", "# Do not learn variance of inter-domain transform!", "\n", "# Bound the inducing points so they don't move away too far.", "\n", "self", ".", "t_u", "=", "self", ".", "ps", ".", "bounded", "(", "\n", "self", ".", "t_u", ",", "\n", "lower", "=", "min", "(", "self", ".", "t_u", ")", "*", "1.5", ",", "\n", "upper", "=", "max", "(", "self", ".", "t_u", ")", "*", "1.5", ",", "\n", "name", "=", "\"t_u\"", ",", "\n", ")", "\n", "self", ".", "t_z", "=", "self", ".", "ps", ".", "unbounded", "(", "self", ".", "t_z", ",", "name", "=", "\"t_z\"", ")", "\n", "\n", "AbstractGPCM", ".", "__prior__", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.CGPCM.__init__": [[301, 303], ["gpcm.GPCM.__init__"], "methods", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.__init__"], ["def", "__init__", "(", "self", ",", "causal", "=", "True", ",", "**", "kw_args", ")", ":", "\n", "        ", "GPCM", ".", "__init__", "(", "self", ",", "causal", "=", "causal", ",", "**", "kw_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.scale_to_factor": [[18, 28], ["None"], "function", ["None"], ["def", "scale_to_factor", "(", "scale", ")", ":", "\n", "    ", "\"\"\"Convert a length scale to a factor.\n\n    Args:\n        scale (tensor): Length scale to convert to a factor.\n\n    Returns:\n        tensor: Equivalent factor.\n    \"\"\"", "\n", "return", "(", "B", ".", "pi", "/", "2", ")", "/", "(", "2", "*", "scale", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.factor_to_scale": [[30, 40], ["lab.sqrt"], "function", ["None"], ["", "def", "factor_to_scale", "(", "factor", ")", ":", "\n", "    ", "\"\"\"Convert a factor to a length scale.\n\n    Args:\n        factor (tensor): Factor to convert to a length scale.\n\n    Returns:\n        tensor: Equivalent length scale.\n    \"\"\"", "\n", "return", "1", "/", "B", ".", "sqrt", "(", "4", "*", "factor", "/", "B", ".", "pi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u": [[305, 319], ["util.method", "matrix.Dense", "model.k_h().eval", "model.k_h", "exppoly.var", "exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "", "@", "method", "(", "GPCM", ")", "\n", "def", "compute_K_u", "(", "model", ")", ":", "\n", "    ", "\"\"\"Covariance matrix of inducing variables :math:`u` associated with\n    :math:`h`.\n\n    Args:\n        model (:class:`.gpcm.GPCM`): Model.\n\n    Returns:\n        tensor: :math:`K_u`.\n    \"\"\"", "\n", "return", "Dense", "(", "\n", "model", ".", "k_h", "(", "var", "(", "\"t1\"", ")", ",", "var", "(", "\"t2\"", ")", ")", ".", "eval", "(", "\n", "t1", "=", "model", ".", "t_u", "[", ":", ",", "None", "]", ",", "t2", "=", "model", ".", "t_u", "[", "None", ",", ":", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_z": [[323, 335], ["util.method", "matrix.Dense", "model.k_xs", "model.k_xs", "exppoly.integrate", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_xs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_xs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "method", "(", "GPCM", ")", "\n", "def", "compute_K_z", "(", "model", ")", ":", "\n", "    ", "\"\"\"Covariance matrix :math:`K_z`.\n\n    Args:\n        model (:class:`.gpcm.GPCM`): Model.\n\n    Returns:\n        matrix: :math:`K_z`.\n    \"\"\"", "\n", "exppoly", "=", "model", ".", "k_xs", "(", "var", "(", "\"t1\"", ")", ",", "var", "(", "\"tau\"", ")", ")", "*", "model", ".", "k_xs", "(", "var", "(", "\"tau\"", ")", ",", "var", "(", "\"t2\"", ")", ")", "\n", "return", "Dense", "(", "exppoly", ".", "integrate", "(", "\"tau\"", ",", "t1", "=", "model", ".", "t_z", "[", ":", ",", "None", "]", ",", "t2", "=", "model", ".", "t_z", "[", "None", ",", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_i_hx": [[337, 363], ["util.method", "model.k_h", "model.k_h.integrate_box", "lab.zero", "lab.zero", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "lab.minimum"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "method", "(", "GPCM", ")", "\n", "def", "compute_i_hx", "(", "model", ",", "t1", "=", "None", ",", "t2", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{hx}` integral.\n\n    Args:\n        model (:class:`.gpcm.GPCM`): Model.\n        t1 (tensor, optional): First time input. Defaults to zero.\n        t2 (tensor, optional): Second time input. Defaults to zero.\n\n    Returns:\n        tensor: Value of :math:`I_{hx}` for all `t1` and `t2`.\n    \"\"\"", "\n", "if", "t1", "is", "None", ":", "\n", "        ", "t1", "=", "B", ".", "zero", "(", "model", ".", "dtype", ")", "\n", "", "if", "t2", "is", "None", ":", "\n", "        ", "t2", "=", "B", ".", "zero", "(", "model", ".", "dtype", ")", "\n", "\n", "", "exppoly", "=", "model", ".", "k_h", "(", "var", "(", "\"t1\"", ")", "-", "var", "(", "\"tau\"", ")", ",", "var", "(", "\"t2\"", ")", "-", "var", "(", "\"tau\"", ")", ")", "\n", "\n", "if", "model", ".", "causal", ":", "\n", "        ", "upper", "=", "var", "(", "\"min_t1_t2\"", ")", "\n", "", "else", ":", "\n", "        ", "upper", "=", "np", ".", "inf", "\n", "\n", "", "return", "exppoly", ".", "integrate_box", "(", "\n", "(", "\"tau\"", ",", "-", "np", ".", "inf", ",", "upper", ")", ",", "t1", "=", "t1", ",", "t2", "=", "t2", ",", "min_t1_t2", "=", "B", ".", "minimum", "(", "t1", ",", "t2", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_ux": [[366, 420], ["util.method", "model.k_h", "model.k_h.integrate_box", "lab.zeros", "lab.zeros", "exppoly.var", "model.k_h", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "lab.minimum", "exppoly.var", "exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "method", "(", "GPCM", ")", "\n", "def", "compute_I_ux", "(", "model", ",", "t1", "=", "None", ",", "t2", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{ux}` integral.\n\n    Args:\n        model (:class:`.gpcm.GPCM`): Model.\n        t1 (tensor, optional): First time input. Defaults to zero.\n        t2 (tensor, optional): Second time input. Defaults to zero.\n\n    Returns:\n        tensor: Value of :math:`I_{ux}` for all `t1`, `t2`.\n    \"\"\"", "\n", "if", "t1", "is", "None", ":", "\n", "        ", "t1", "=", "B", ".", "zeros", "(", "model", ".", "dtype", ",", "1", ")", "\n", "squeeze_t1", "=", "True", "\n", "", "else", ":", "\n", "        ", "squeeze_t1", "=", "False", "\n", "\n", "", "if", "t2", "is", "None", ":", "\n", "        ", "t2", "=", "B", ".", "zeros", "(", "model", ".", "dtype", ",", "1", ")", "\n", "squeeze_t2", "=", "True", "\n", "", "else", ":", "\n", "        ", "squeeze_t2", "=", "False", "\n", "\n", "", "t1", "=", "t1", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "t2", "=", "t2", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "t_u_1", "=", "model", ".", "t_u", "[", "None", ",", "None", ",", ":", ",", "None", "]", "\n", "t_u_2", "=", "model", ".", "t_u", "[", "None", ",", "None", ",", "None", ",", ":", "]", "\n", "\n", "exppoly", "=", "model", ".", "k_h", "(", "var", "(", "\"t1\"", ")", "-", "var", "(", "\"tau\"", ")", ",", "var", "(", "\"t_u_1\"", ")", ")", "\n", "exppoly", "=", "exppoly", "*", "model", ".", "k_h", "(", "var", "(", "\"t_u_2\"", ")", ",", "var", "(", "\"t2\"", ")", "-", "var", "(", "\"tau\"", ")", ")", "\n", "\n", "if", "model", ".", "causal", ":", "\n", "        ", "upper", "=", "var", "(", "\"min_t1_t2\"", ")", "\n", "", "else", ":", "\n", "        ", "upper", "=", "np", ".", "inf", "\n", "\n", "", "result", "=", "exppoly", ".", "integrate_box", "(", "\n", "(", "\"tau\"", ",", "-", "np", ".", "inf", ",", "upper", ")", ",", "\n", "t1", "=", "t1", ",", "\n", "t2", "=", "t2", ",", "\n", "t_u_1", "=", "t_u_1", ",", "\n", "t_u_2", "=", "t_u_2", ",", "\n", "min_t1_t2", "=", "B", ".", "minimum", "(", "t1", ",", "t2", ")", ",", "\n", ")", "\n", "\n", "if", "squeeze_t1", "and", "squeeze_t2", ":", "\n", "        ", "return", "result", "[", "0", ",", "0", ",", ":", ",", ":", "]", "\n", "", "elif", "squeeze_t1", ":", "\n", "        ", "return", "result", "[", "0", ",", ":", ",", ":", ",", ":", "]", "\n", "", "elif", "squeeze_t2", ":", "\n", "        ", "return", "result", "[", ":", ",", "0", ",", ":", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_hz": [[422, 457], ["util.method", "expq.integrate_box", "model.k_xs", "exppoly.var", "exppoly.var", "model.k_h", "model.k_xs", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_xs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_xs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "", "@", "method", "(", "GPCM", ")", "\n", "def", "compute_I_hz", "(", "model", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{hz,t_i}` matrix for :math:`t_i` in `t`.\n\n    Args:\n        model (:class:`.gpcm.GPCM`): Model.\n        t (vector): Time points of data.\n\n    Returns:\n        tensor: Value of :math:`I_{hz,t_i}`, with shape\n            `(len(t), len(model.t_z), len(model.t_z))`.\n    \"\"\"", "\n", "t", "=", "t", "[", ":", ",", "None", ",", "None", "]", "\n", "t_z_1", "=", "model", ".", "t_z", "[", "None", ",", ":", ",", "None", "]", "\n", "t_z_2", "=", "model", ".", "t_z", "[", "None", ",", "None", ",", ":", "]", "\n", "\n", "expq", "=", "(", "\n", "model", ".", "k_h", "(", "var", "(", "\"t\"", ")", "-", "var", "(", "\"tau1\"", ")", ",", "var", "(", "\"t\"", ")", "-", "var", "(", "\"tau2\"", ")", ")", "\n", "*", "model", ".", "k_xs", "(", "var", "(", "\"tau1\"", ")", ",", "var", "(", "\"t_z_1\"", ")", ")", "\n", "*", "model", ".", "k_xs", "(", "var", "(", "\"t_z_2\"", ")", ",", "var", "(", "\"tau2\"", ")", ")", "\n", ")", "\n", "\n", "if", "model", ".", "causal", ":", "\n", "        ", "upper1", "=", "var", "(", "\"t\"", ")", "\n", "upper2", "=", "var", "(", "\"t\"", ")", "\n", "", "else", ":", "\n", "        ", "upper1", "=", "np", ".", "inf", "\n", "upper2", "=", "np", ".", "inf", "\n", "\n", "", "return", "expq", ".", "integrate_box", "(", "\n", "(", "\"tau1\"", ",", "-", "np", ".", "inf", ",", "upper1", ")", ",", "\n", "(", "\"tau2\"", ",", "-", "np", ".", "inf", ",", "upper2", ")", ",", "\n", "t", "=", "t", ",", "\n", "t_z_1", "=", "t_z_1", ",", "\n", "t_z_2", "=", "t_z_2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_uz": [[460, 485], ["util.method", "model.k_h", "model.k_h.integrate_box", "exppoly.var", "model.k_xs", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var", "exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.method", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_xs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "method", "(", "GPCM", ")", "\n", "def", "compute_I_uz", "(", "model", ",", "t", ")", ":", "\n", "    ", "\"\"\"Compute the :math:`I_{uz,t_i}` matrix for :math:`t_i` in `t`.\n\n    Args:\n        model (:class:`.gpcm.GPCM`): Model.\n        t (vector): Time points :math:`t_i` of data.\n\n    Returns:\n        tensor: Value of :math:`I_{uz,t_i}`, with shape\n            `(len(t), len(model.t_u), len(model.t_z))`.\n    \"\"\"", "\n", "t", "=", "t", "[", ":", ",", "None", ",", "None", "]", "\n", "t_u", "=", "model", ".", "t_u", "[", "None", ",", ":", ",", "None", "]", "\n", "t_z", "=", "model", ".", "t_z", "[", "None", ",", "None", ",", ":", "]", "\n", "\n", "exppoly", "=", "model", ".", "k_h", "(", "var", "(", "\"t\"", ")", "-", "var", "(", "\"tau\"", ")", ",", "var", "(", "\"t_u\"", ")", ")", "\n", "exppoly", "=", "exppoly", "*", "model", ".", "k_xs", "(", "var", "(", "\"tau\"", ")", ",", "var", "(", "\"t_z\"", ")", ")", "\n", "\n", "if", "model", ".", "causal", ":", "\n", "        ", "upper", "=", "var", "(", "\"t\"", ")", "\n", "", "else", ":", "\n", "        ", "upper", "=", "np", ".", "inf", "\n", "\n", "", "return", "exppoly", ".", "integrate_box", "(", "(", "\"tau\"", ",", "-", "np", ".", "inf", ",", "upper", ")", ",", "t", "=", "t", ",", "t_u", "=", "t_u", ",", "t_z", "=", "t_z", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.eq.comparative_kernel": [[33, 35], ["vs_.pos", "kernel.stretch", "vs_.pos", "stheno.Delta", "vs_.pos"], "function", ["None"], ["def", "comparative_kernel", "(", "vs_", ")", ":", "\n", "    ", "return", "vs_", ".", "pos", "(", "1", ")", "*", "kernel", ".", "stretch", "(", "vs_", ".", "pos", "(", "1.0", ")", ")", "+", "vs_", ".", "pos", "(", "noise", ")", "*", "Delta", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.smk.comparative_kernel": [[34, 36], ["vs_.pos", "stheno.EQ().stretch", "vs_.pos", "stheno.Delta", "vs_.pos", "stheno.EQ"], "function", ["None"], ["def", "comparative_kernel", "(", "vs_", ")", ":", "\n", "    ", "return", "vs_", ".", "pos", "(", "1", ")", "*", "EQ", "(", ")", ".", "stretch", "(", "vs_", ".", "pos", "(", "1.0", ")", ")", "+", "vs_", ".", "pos", "(", "noise", ")", "*", "Delta", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.setup": [[28, 60], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "wbml.experiment.WorkingDirectory"], "function", ["None"], ["def", "setup", "(", "name", ")", ":", "\n", "    ", "\"\"\"Setup an experiment.\n\n    Args:\n        name (str): Name of the experiment.\n\n    Returns:\n        tuple[:class:`argparse.Namespace`,\n              :class:`wbml.experiment.WorkingDirectory`]: Tuple containing\n            the parsed arguments and the working directory.\n    \"\"\"", "\n", "# Parse arguments.", "\n", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"path\"", ",", "nargs", "=", "\"*\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--seed\"", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\"--iters\"", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "\"--scheme\"", ",", "type", "=", "str", ",", "default", "=", "\"structured\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--load\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--fix-hypers\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--model\"", ",", "\n", "choices", "=", "[", "\"gpcm\"", ",", "\"gprv\"", ",", "\"cgpcm\"", "]", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "[", "\"gpcm\"", ",", "\"gprv\"", ",", "\"cgpcm\"", "]", ",", "\n", "nargs", "=", "\"+\"", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "# Setup working directory.", "\n", "wd", "=", "WorkingDirectory", "(", "\"_experiments\"", ",", "name", ",", "*", "args", ".", "path", ",", "seed", "=", "args", ".", "seed", ")", "\n", "\n", "return", "args", ",", "wd", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.run": [[62, 125], ["experiment.build_models", "experiment.train_models", "experiment.analyse_models", "getattr", "getattr"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.build_models", "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.train_models", "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.analyse_models"], ["", "def", "run", "(", "\n", "args", ",", "\n", "wd", ",", "\n", "noise", ",", "\n", "window", ",", "\n", "scale", ",", "\n", "t", ",", "\n", "y", ",", "\n", "fix_window_scale", "=", "False", ",", "\n", "n_u", "=", "None", ",", "\n", "n_z", "=", "None", ",", "\n", "extend_t_z", "=", "False", ",", "\n", "**", "kw_args", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Run an experiment.\n\n    Further takes in keyword arguments for :func:`.experiment.analyse_models`.\n\n    Args:\n        args (:class:`.argparse.Namespace`): Parser arguments.\n        wd (:class:`wbml.experiment.WorkingDirectory`): Working directory.\n        noise (scalar): Noise variance.\n        window (scalar): Window length.\n        scale (scalar): Length scale of the function.\n        t (vector): Time points of data.\n        y (vector): Observations.\n        fix_window_scale (bool, optional): Do not learn the window length and length\n            scale. Defaults to `False`.\n        n_u (int, optional): Number of inducing points for :math:`h`.\n        n_z (int, optional): Number of inducing points for :math:`s` or equivalent.\n        extend_t_z (bool, optional): Extend `t_z` to account for the white noise process\n            outside of the data range.\n    \"\"\"", "\n", "models", "=", "build_models", "(", "\n", "args", ".", "model", ",", "\n", "scheme", "=", "args", ".", "scheme", ",", "\n", "noise", "=", "noise", ",", "\n", "window", "=", "window", ",", "\n", "scale", "=", "scale", ",", "\n", "t", "=", "t", ",", "\n", "y", "=", "y", ",", "\n", "fix_window_scale", "=", "fix_window_scale", ",", "\n", "n_u", "=", "n_u", ",", "\n", "n_z", "=", "n_z", ",", "\n", "extend_t_z", "=", "extend_t_z", ",", "\n", ")", "\n", "\n", "# Setup training.", "\n", "train_config", "=", "{", "}", "\n", "for", "name", "in", "[", "\"iters\"", ",", "\"fix_hypers\"", "]", ":", "\n", "        ", "if", "getattr", "(", "args", ",", "name", ")", ":", "\n", "            ", "train_config", "[", "name", "]", "=", "getattr", "(", "args", ",", "name", ")", "\n", "\n", "# Negate some parameters.", "\n", "", "", "if", "\"fix_hypers\"", "in", "train_config", ":", "\n", "        ", "train_config", "[", "\"optimise_hypers\"", "]", "=", "not", "train_config", "[", "\"fix_hypers\"", "]", "\n", "del", "train_config", "[", "\"fix_hypers\"", "]", "\n", "\n", "# Perform training.", "\n", "", "train_models", "(", "models", ",", "t", ",", "y", ",", "train_config", ",", "args", ".", "load", ",", "wd", "=", "wd", ")", "\n", "\n", "# Perform analysis.", "\n", "analyse_models", "(", "models", ",", "t", ",", "y", ",", "wd", "=", "wd", ",", "**", "kw_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.build_models": [[127, 211], ["models.append", "models.append", "models.append", "len", "ValueError", "set", "gpcm.gpcm.GPCM", "set", "gpcm.gpcm.CGPCM", "set", "gpcm.rgpcm.RGPCM", "int", "numpy.ceil"], "function", ["None"], ["", "def", "build_models", "(", "\n", "names", ",", "\n", "scheme", ",", "\n", "window", ",", "\n", "scale", ",", "\n", "noise", ",", "\n", "t", ",", "\n", "y", ",", "\n", "fix_window_scale", ",", "\n", "n_u", ",", "\n", "n_z", ",", "\n", "extend_t_z", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Construct the GPCM, CGPCM, and GP-RV.\n\n    Args:\n        names (list[str]): Names of models to build.\n        scheme (str): Approximation scheme.\n        window (scalar): Window length.\n        scale (scalar): Length scale of the function.\n        t (vector): Time points of data.\n        y (vector): Observations.\n        fix_window_scale (bool): Do not learn the window length and length scale.\n        n_u (int, optional): Number of inducing points for :math:`h`.\n        n_z (int, optional): Number of inducing points for :math:`s` or equivalent.\n        extend_t_z (bool, optional): Extend `t_z` to account for the white noise process\n            outside of the data range.\n    \"\"\"", "\n", "models", "=", "[", "]", "\n", "\n", "if", "\"gpcm\"", "in", "names", ":", "\n", "        ", "names", "=", "set", "(", "names", ")", "-", "{", "\"gpcm\"", "}", "\n", "models", ".", "append", "(", "\n", "GPCM", "(", "\n", "scheme", "=", "scheme", ",", "\n", "noise", "=", "noise", ",", "\n", "window", "=", "window", ",", "\n", "fix_window", "=", "fix_window_scale", ",", "\n", "scale", "=", "scale", ",", "\n", "fix_scale", "=", "fix_window_scale", ",", "\n", "t", "=", "t", ",", "\n", "n_u", "=", "n_u", ",", "\n", "n_z", "=", "n_z", ",", "\n", "extend_t_z", "=", "extend_t_z", ",", "\n", ")", ",", "\n", ")", "\n", "\n", "", "if", "\"cgpcm\"", "in", "names", ":", "\n", "        ", "names", "=", "set", "(", "names", ")", "-", "{", "\"cgpcm\"", "}", "\n", "models", ".", "append", "(", "\n", "CGPCM", "(", "\n", "scheme", "=", "scheme", ",", "\n", "noise", "=", "noise", ",", "\n", "window", "=", "window", ",", "\n", "fix_window", "=", "fix_window_scale", ",", "\n", "scale", "=", "scale", ",", "\n", "fix_scale", "=", "fix_window_scale", ",", "\n", "t", "=", "t", ",", "\n", "n_u", "=", "n_u", ",", "\n", "n_z", "=", "n_z", ",", "\n", "extend_t_z", "=", "extend_t_z", ",", "\n", ")", "\n", ")", "\n", "", "if", "\"gprv\"", "in", "names", ":", "\n", "        ", "names", "=", "set", "(", "names", ")", "-", "{", "\"gprv\"", "}", "\n", "models", ".", "append", "(", "\n", "RGPCM", "(", "\n", "scheme", "=", "scheme", ",", "\n", "noise", "=", "noise", ",", "\n", "window", "=", "window", ",", "\n", "fix_window", "=", "fix_window_scale", ",", "\n", "scale", "=", "scale", ",", "\n", "fix_scale", "=", "fix_window_scale", ",", "\n", "t", "=", "t", ",", "\n", "n_u", "=", "n_u", ",", "\n", "m_max", "=", "int", "(", "np", ".", "ceil", "(", "n_z", "/", "2", ")", ")", "if", "n_z", "else", "None", ",", "\n", ")", "\n", ")", "\n", "\n", "", "if", "len", "(", "names", ")", ">", "0", ":", "\n", "        ", "names_str", "=", "\", \"", ".", "join", "(", "f'\"{name}\"'", "for", "name", "in", "names", ")", "\n", "raise", "ValueError", "(", "f\"Unknown names {names_str}.\"", ")", "\n", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.train_models": [[213, 244], ["model.load", "wbml.out.Section", "wbml.out.Section", "wd.file", "wbml.out.Section", "wbml.out.Section", "model.fit", "wbml.out.Section", "wbml.out.Section", "model", "model.vs.print", "model.save", "wd.file"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.fit", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.save"], ["", "def", "train_models", "(", "models", ",", "t", ",", "y", ",", "train_config", ",", "load", ",", "wd", "=", "None", ")", ":", "\n", "    ", "\"\"\"Train models.\n\n    Args:\n        models (list): Models to train.\n        t (vector): Time points of data.\n        y (vector): Observations.\n        train_train (dict): Training configuration.\n        load (bool): Load the models rather than training them.\n        wd (:class:`wbml.experiment.WorkingDirectory`, optional): Working\n            directory to save samples to.\n\n    Returns:\n        list[:class:`stheno.Normal`]: Approximate posteriors.\n    \"\"\"", "\n", "if", "load", ":", "\n", "        ", "for", "model", "in", "models", ":", "\n", "            ", "model", ".", "load", "(", "wd", ".", "file", "(", "\"models\"", ",", "model", ".", "name", "+", "\".pickle\"", ")", ")", "\n", "", "", "else", ":", "\n", "# Print the initial variables to keep track of them.", "\n", "        ", "with", "wbml", ".", "out", ".", "Section", "(", "\"Variables before optimisation\"", ")", ":", "\n", "            ", "for", "model", "in", "models", ":", "\n", "                ", "with", "wbml", ".", "out", ".", "Section", "(", "model", ".", "name", ")", ":", "\n", "                    ", "model", "(", ")", "\n", "model", ".", "vs", ".", "print", "(", ")", "\n", "\n", "", "", "", "for", "model", "in", "models", ":", "\n", "            ", "with", "wbml", ".", "out", ".", "Section", "(", "f\"Training {model.name}\"", ")", ":", "\n", "                ", "model", ".", "fit", "(", "t", ",", "y", ",", "**", "train_config", ")", "\n", "if", "wd", ":", "\n", "                    ", "model", ".", "save", "(", "wd", ".", "file", "(", "\"models\"", ",", "model", ".", "name", "+", "\".pickle\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.analyse_models": [[246, 307], ["experiment.analyse_elbos", "experiment.analyse_plots", "wbml.out.Section", "wbml.out.Section", "wbml.out.Section", "wbml.out.Section", "model.vs.print"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.analyse_elbos", "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.analyse_plots"], ["", "", "", "", "", "def", "analyse_models", "(", "\n", "models", ",", "\n", "t", ",", "\n", "y", ",", "\n", "wd", "=", "None", ",", "\n", "t_plot", "=", "None", ",", "\n", "truth", "=", "None", ",", "\n", "true_kernel", "=", "None", ",", "\n", "true_noisy_kernel", "=", "None", ",", "\n", "comparative_kernel", "=", "None", ",", "\n", "x_range", "=", "None", ",", "\n", "y_range", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Analyse models.\n\n    Args:\n        models (list): Models.\n        t (vector): Time points of data.\n        y (vector): Observations.\n        wd (:class:`wbml.experiment.WorkingDirectory`, optional): Working directory\n            to save results to.\n        t_plot (vector, optional): Time points to generate plots at. Defaults to `t`.\n        truth (tuple[vector], optional): Tuple containing inputs and outputs\n            associated to a truth.\n        true_kernel (:class:`stheno.Kernel`, optional): True kernel that generated\n            the data, not including noise.\n        true_noisy_kernel (:class:`stheno.Kernel`, optional): True kernel that\n            generated the data, including noise.\n        comparative_kernel (function, optional): A function that takes in a\n            variable container and gives back a kernel. A GP with this\n            kernel will be trained on the data to compute a likelihood that\n            will be compared to the ELBOs.\n        x_range (dict, optional): Fix the x-range for plotting. Defaults to an empty\n            dictionary.\n        y_range (dict, optional): Fix the y-range for plotting. Defaults to an empty\n            dictionary.\n    \"\"\"", "\n", "\n", "# Print the learned variables.", "\n", "with", "wbml", ".", "out", ".", "Section", "(", "\"Variables after optimisation\"", ")", ":", "\n", "        ", "for", "model", "in", "models", ":", "\n", "            ", "with", "wbml", ".", "out", ".", "Section", "(", "model", ".", "name", ")", ":", "\n", "                ", "model", ".", "vs", ".", "print", "(", ")", "\n", "\n", "", "", "", "analyse_elbos", "(", "\n", "models", ",", "\n", "t", "=", "t", ",", "\n", "y", "=", "y", ",", "\n", "true_noisy_kernel", "=", "true_noisy_kernel", ",", "\n", "comparative_kernel", "=", "comparative_kernel", ",", "\n", ")", "\n", "analyse_plots", "(", "\n", "models", ",", "\n", "t", "=", "t", ",", "\n", "y", "=", "y", ",", "\n", "wd", "=", "wd", ",", "\n", "true_kernel", "=", "true_kernel", ",", "\n", "t_plot", "=", "t_plot", ",", "\n", "truth", "=", "truth", ",", "\n", "x_range", "=", "x_range", ",", "\n", "y_range", "=", "y_range", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.analyse_elbos": [[310, 349], ["wbml.out.kv", "wbml.out.kv", "varz.Vars", "wbml.out.kv", "wbml.out.kv", "wbml.out.Section", "wbml.out.Section", "stheno.jax.GP", "varz.minimise_l_bfgs_b", "model.elbo", "lab.set_global_random_state", "wbml.out.kv", "wbml.out.kv", "stheno.jax.GP.logpdf", "lab.global_random_state", "varz.sequential", "stheno.jax.GP", "stheno.jax.GP."], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.logpdf"], ["", "def", "analyse_elbos", "(", "models", ",", "t", ",", "y", ",", "true_noisy_kernel", "=", "None", ",", "comparative_kernel", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compare ELBOs of models.\n\n    Args:\n        models (list): Models to analyse.\n        t (vector): Time points of data.\n        y (vector): Observations.\n        true_noisy_kernel (:class:`stheno.Kernel`, optional): True kernel that\n            generated the data, including noise.\n        comparative_kernel (function, optional): A function that takes in a\n            variable container and gives back a kernel. A GP with this\n            kernel will be trained on the data to compute a likelihood that\n            will be compared to the ELBOs.\n    \"\"\"", "\n", "\n", "# Print LML under true GP if the true kernel is given.", "\n", "if", "true_noisy_kernel", ":", "\n", "        ", "wbml", ".", "out", ".", "kv", "(", "\"LML under true GP\"", ",", "GP", "(", "true_noisy_kernel", ")", "(", "t", ")", ".", "logpdf", "(", "y", ")", ")", "\n", "\n", "# Print LML under a trained GP if a comparative kernel is given.", "\n", "", "if", "comparative_kernel", ":", "\n", "\n", "        ", "def", "objective", "(", "vs_", ")", ":", "\n", "            ", "gp", "=", "GP", "(", "sequential", "(", "comparative_kernel", ")", "(", "vs_", ")", ")", "\n", "return", "-", "gp", "(", "t", ")", ".", "logpdf", "(", "y", ")", "\n", "\n", "# Fit the GP.", "\n", "", "vs", "=", "Vars", "(", "jnp", ".", "float64", ")", "\n", "lml_gp_opt", "=", "-", "minimise_l_bfgs_b", "(", "objective", ",", "vs", ",", "jit", "=", "True", ",", "iters", "=", "1000", ")", "\n", "\n", "# Print likelihood.", "\n", "wbml", ".", "out", ".", "kv", "(", "\"LML under optimised GP\"", ",", "lml_gp_opt", ")", "\n", "\n", "# Estimate ELBOs.", "\n", "", "with", "wbml", ".", "out", ".", "Section", "(", "\"ELBOs\"", ")", ":", "\n", "        ", "for", "model", "in", "models", ":", "\n", "            ", "state", ",", "elbo", "=", "model", ".", "elbo", "(", "B", ".", "global_random_state", "(", "model", ".", "dtype", ")", ",", "t", ",", "y", ")", "\n", "B", ".", "set_global_random_state", "(", "state", ")", "\n", "wbml", ".", "out", ".", "kv", "(", "model", ".", "name", ",", "elbo", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.experiments.experiment.analyse_plots": [[351, 622], ["matplotlib.figure", "enumerate", "matplotlib.tight_layout", "matplotlib.figure", "enumerate", "matplotlib.tight_layout", "matplotlib.figure", "enumerate", "matplotlib.tight_layout", "matplotlib.figure", "enumerate", "matplotlib.tight_layout", "model.predict", "lab.sqrt", "matplotlib.subplot", "matplotlib.title", "matplotlib.scatter", "hasattr", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.plot", "matplotlib.plot", "matplotlib.gca().xaxis.set_major_formatter", "wbml.plot.tweak", "wbml.plot.tweak", "matplotlib.savefig", "matplotlib.subplot", "matplotlib.title", "matplotlib.scatter", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.plot", "wbml.plot.tweak", "wbml.plot.tweak", "matplotlib.savefig", "matplotlib.subplot", "matplotlib.title", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.fill_between", "matplotlib.plot", "wbml.plot.tweak", "wbml.plot.tweak", "matplotlib.savefig", "isinstance", "matplotlib.subplot", "matplotlib.title", "numpy.concatenate", "matplotlib.errorbar", "matplotlib.xlabel", "wbml.plot.tweak", "wbml.plot.tweak", "matplotlib.subplot", "matplotlib.title", "numpy.concatenate", "matplotlib.errorbar", "matplotlib.xlabel", "wbml.plot.tweak", "wbml.plot.tweak", "matplotlib.savefig", "max", "max", "model.condition", "matplotlib.scatter", "lab.sqrt", "matplotlib.plot", "matplotlib.xlim", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.ticker.FormatStrFormatter", "wd.file", "wbml.out.Section", "wbml.out.Section", "model.predict_kernel", "gpcm.util.autocorr", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.xlim", "matplotlib.ylim", "wd.file", "wbml.out.Section", "wbml.out.Section", "model.predict_psd", "gpcm.util.estimate_psd", "gpcm.util.autocorr", "gpcm.util.estimate_psd", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "wd.file", "model.predict_fourier", "numpy.maximum", "wd.file", "numpy.abs", "numpy.abs", "min", "max", "max", "matplotlib.xlim", "matplotlib.xlim", "lab.sqrt", "lab.sqrt", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.diff", "model.ps.noise", "matplotlib.gca", "true_kernel", "max", "max", "numpy.diff", "true_kernel"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Approximation.condition", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_kernel", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.autocorr", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_psd", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.estimate_psd", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.autocorr", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.estimate_psd", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.predict_fourier"], ["", "", "", "def", "analyse_plots", "(", "\n", "models", ",", "\n", "t", ",", "\n", "y", ",", "\n", "wd", "=", "None", ",", "\n", "true_kernel", "=", "None", ",", "\n", "t_plot", "=", "None", ",", "\n", "truth", "=", "None", ",", "\n", "x_range", "=", "None", ",", "\n", "y_range", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Analyse models in plots.\n\n    Args:\n        models (list): Models to train.\n        t (vector): Time points of data.\n        y (vector): Observations.\n        wd (:class:`wbml.experiment.WorkingDirectory`, optional): Working directory\n            to save the plots to.\n        true_kernel (:class:`stheno.Kernel`, optional): True kernel that\n            generates the data for comparison.\n        t_plot (vector, optional): Time points to generate plots at. Defaults to `t`.\n        truth (tuple[vector], optional): Tuple containing inputs and outputs\n            associated to a truth.\n        x_range (dict, optional): Fix the x-range for plotting. Defaults to an empty\n            dictionary.\n        y_range (dict, optional): Fix the y-range for plotting. Defaults to an empty\n            dictionary.\n    \"\"\"", "\n", "# Set defaults.", "\n", "if", "t_plot", "is", "None", ":", "\n", "        ", "t_plot", "=", "t", "\n", "", "if", "x_range", "is", "None", ":", "\n", "        ", "x_range", "=", "{", "}", "\n", "", "if", "y_range", "is", "None", ":", "\n", "        ", "y_range", "=", "{", "}", "\n", "\n", "# Check whether `t` is roughly equally spaced. We allow small deviations.", "\n", "", "t_is_equally_spaced", "=", "max", "(", "np", ".", "abs", "(", "np", ".", "diff", "(", "np", ".", "diff", "(", "t", ")", ")", ")", ")", "/", "max", "(", "np", ".", "abs", "(", "t", ")", ")", "<", "5e-2", "\n", "\n", "# Perform instantiation of posteriors.", "\n", "models", "=", "[", "model", ".", "condition", "(", "t", ",", "y", ")", "(", ")", "for", "model", "in", "models", "]", "\n", "\n", "# Plot predictions.", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", ")", ":", "\n", "# Construct model and make predictions.", "\n", "        ", "mu", ",", "var", "=", "model", ".", "predict", "(", "t_plot", ")", "\n", "std", "=", "B", ".", "sqrt", "(", "var", ")", "\n", "\n", "plt", ".", "subplot", "(", "3", ",", "1", ",", "1", "+", "i", ")", "\n", "plt", ".", "title", "(", "f\"Function ({model.name})\"", ")", "\n", "\n", "# Plot data.", "\n", "plt", ".", "scatter", "(", "t", ",", "y", ",", "c", "=", "\"black\"", ",", "label", "=", "\"Data\"", ")", "\n", "\n", "# Plot inducing models, if the model has them.", "\n", "if", "hasattr", "(", "model", ",", "\"t_z\"", ")", ":", "\n", "            ", "plt", ".", "scatter", "(", "model", ".", "t_z", ",", "model", ".", "t_z", "*", "0", ",", "s", "=", "5", ",", "marker", "=", "\"o\"", ",", "c", "=", "\"black\"", ")", "\n", "\n", "# Plot the predictions.", "\n", "", "plt", ".", "plot", "(", "t_plot", ",", "mu", ",", "c", "=", "\"tab:green\"", ",", "label", "=", "\"Prediction\"", ")", "\n", "plt", ".", "fill_between", "(", "t_plot", ",", "mu", "-", "std", ",", "mu", "+", "std", ",", "facecolor", "=", "\"tab:green\"", ",", "alpha", "=", "0.2", ")", "\n", "plt", ".", "fill_between", "(", "\n", "t_plot", ",", "mu", "-", "2", "*", "std", ",", "mu", "+", "2", "*", "std", ",", "facecolor", "=", "\"tab:green\"", ",", "alpha", "=", "0.2", "\n", ")", "\n", "error", "=", "2", "*", "B", ".", "sqrt", "(", "model", ".", "ps", ".", "noise", "(", ")", "+", "std", "**", "2", ")", "# Model and noise error", "\n", "plt", ".", "plot", "(", "t_plot", ",", "mu", "+", "error", ",", "c", "=", "\"tab:green\"", ",", "ls", "=", "\"--\"", ")", "\n", "plt", ".", "plot", "(", "t_plot", ",", "mu", "-", "error", ",", "c", "=", "\"tab:green\"", ",", "ls", "=", "\"--\"", ")", "\n", "\n", "# Plot true function.", "\n", "if", "truth", ":", "\n", "            ", "plt", ".", "plot", "(", "*", "truth", ",", "c", "=", "\"tab:red\"", ",", "label", "=", "\"Truth\"", ")", "\n", "\n", "# Set limit and format.", "\n", "", "if", "\"function\"", "in", "x_range", ":", "\n", "            ", "plt", ".", "xlim", "(", "*", "x_range", "[", "\"function\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "plt", ".", "xlim", "(", "min", "(", "t_plot", ")", ",", "max", "(", "t_plot", ")", ")", "\n", "", "if", "\"function\"", "in", "y_range", ":", "\n", "            ", "plt", ".", "ylim", "(", "*", "y_range", "[", "\"function\"", "]", ")", "\n", "", "plt", ".", "gca", "(", ")", ".", "xaxis", ".", "set_major_formatter", "(", "FormatStrFormatter", "(", "\"$%.1f$\"", ")", ")", "\n", "wbml", ".", "plot", ".", "tweak", "(", "legend", "=", "True", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "if", "wd", ":", "\n", "        ", "plt", ".", "savefig", "(", "wd", ".", "file", "(", "\"prediction_function.pdf\"", ")", ")", "\n", "\n", "# Plot kernels.", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", ")", ":", "\n", "# Construct model and predict the kernel.", "\n", "        ", "with", "wbml", ".", "out", ".", "Section", "(", "f\"Predicting kernel for {model.name}\"", ")", ":", "\n", "            ", "pred", "=", "model", ".", "predict_kernel", "(", ")", "\n", "\n", "# Compute true kernel.", "\n", "", "if", "true_kernel", ":", "\n", "            ", "k_true", "=", "true_kernel", "(", "pred", ".", "x", ")", ".", "mat", "[", "0", ",", ":", "]", "\n", "\n", "# Estimate autocorrelation.", "\n", "", "if", "t_is_equally_spaced", ":", "\n", "            ", "t_ac", "=", "t", "-", "t", "[", "0", "]", "\n", "k_ac", "=", "autocorr", "(", "y", ",", "cov", "=", "True", ")", "\n", "\n", "", "plt", ".", "subplot", "(", "3", ",", "1", ",", "1", "+", "i", ")", "\n", "plt", ".", "title", "(", "f\"Kernel ({model.name})\"", ")", "\n", "\n", "# Plot inducing points, if the model has them.", "\n", "plt", ".", "scatter", "(", "model", ".", "t_u", ",", "0", "*", "model", ".", "t_u", ",", "s", "=", "5", ",", "c", "=", "\"black\"", ")", "\n", "\n", "# Plot predictions.", "\n", "plt", ".", "plot", "(", "pred", ".", "x", ",", "pred", ".", "mean", ",", "c", "=", "\"tab:green\"", ",", "label", "=", "\"Prediction\"", ")", "\n", "plt", ".", "fill_between", "(", "\n", "pred", ".", "x", ",", "\n", "pred", ".", "err_68_lower", ",", "\n", "pred", ".", "err_68_upper", ",", "\n", "facecolor", "=", "\"tab:green\"", ",", "\n", "alpha", "=", "0.2", ",", "\n", ")", "\n", "plt", ".", "fill_between", "(", "\n", "pred", ".", "x", ",", "\n", "pred", ".", "err_95_lower", ",", "\n", "pred", ".", "err_95_upper", ",", "\n", "facecolor", "=", "\"tab:green\"", ",", "\n", "alpha", "=", "0.2", ",", "\n", ")", "\n", "plt", ".", "plot", "(", "pred", ".", "x", ",", "pred", ".", "samples", ",", "c", "=", "\"tab:red\"", ",", "lw", "=", "1", ")", "\n", "\n", "# Plot the true kernel.", "\n", "if", "true_kernel", ":", "\n", "            ", "plt", ".", "plot", "(", "pred", ".", "x", ",", "k_true", ",", "c", "=", "\"black\"", ",", "label", "=", "\"True\"", ",", "scaley", "=", "False", ")", "\n", "\n", "# Plot the autocorrelation of the data.", "\n", "", "if", "t_is_equally_spaced", ":", "\n", "            ", "plt", ".", "plot", "(", "t_ac", ",", "k_ac", ",", "c", "=", "\"tab:blue\"", ",", "label", "=", "\"Autocorrelation\"", ",", "scaley", "=", "False", ")", "\n", "\n", "# Set limits and format.", "\n", "", "if", "\"kernel\"", "in", "x_range", ":", "\n", "            ", "plt", ".", "xlim", "(", "*", "x_range", "[", "\"kernel\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "plt", ".", "xlim", "(", "0", ",", "max", "(", "pred", ".", "x", ")", ")", "\n", "", "if", "\"kernel\"", "in", "y_range", ":", "\n", "            ", "plt", ".", "ylim", "(", "*", "y_range", "[", "\"kernel\"", "]", ")", "\n", "", "wbml", ".", "plot", ".", "tweak", "(", "legend", "=", "True", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "if", "wd", ":", "\n", "        ", "plt", ".", "savefig", "(", "wd", ".", "file", "(", "\"prediction_kernel.pdf\"", ")", ")", "\n", "\n", "# Plot PSDs.", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", ")", ":", "\n", "# Construct compute and predict PSD.", "\n", "        ", "with", "wbml", ".", "out", ".", "Section", "(", "f\"Predicting PSD for {model.name}\"", ")", ":", "\n", "            ", "pred", "=", "model", ".", "predict_psd", "(", ")", "\n", "\n", "# Compute true PSD.", "\n", "", "if", "true_kernel", ":", "\n", "# TODO: Is `pred.x` okay, or should it be longer?", "\n", "            ", "freqs_true", ",", "psd_true", "=", "estimate_psd", "(", "\n", "pred", ".", "x", ",", "true_kernel", "(", "pred", ".", "x", ")", ".", "mat", "[", "0", ",", ":", "]", ",", "db", "=", "True", "\n", ")", "\n", "\n", "# Estimate PSD.", "\n", "", "if", "t_is_equally_spaced", ":", "\n", "            ", "t_ac", "=", "t", "-", "t", "[", "0", "]", "\n", "k_ac", "=", "autocorr", "(", "y", ",", "cov", "=", "True", ")", "\n", "freqs_ac", ",", "psd_ac", "=", "estimate_psd", "(", "t_ac", ",", "k_ac", ",", "db", "=", "True", ")", "\n", "\n", "", "plt", ".", "subplot", "(", "3", ",", "1", ",", "1", "+", "i", ")", "\n", "plt", ".", "title", "(", "f\"PSD ({model.name})\"", ")", "\n", "\n", "# Plot predictions.", "\n", "plt", ".", "plot", "(", "pred", ".", "x", ",", "pred", ".", "mean", ",", "c", "=", "\"tab:green\"", ",", "label", "=", "\"Prediction\"", ")", "\n", "# TODO: `scalex` doesn't work with `fill_between`. Fix?", "\n", "plt", ".", "fill_between", "(", "\n", "pred", ".", "x", ",", "\n", "pred", ".", "err_68_lower", ",", "\n", "pred", ".", "err_68_upper", ",", "\n", "facecolor", "=", "\"tab:green\"", ",", "\n", "alpha", "=", "0.2", ",", "\n", ")", "\n", "plt", ".", "fill_between", "(", "\n", "pred", ".", "x", ",", "\n", "pred", ".", "err_95_lower", ",", "\n", "pred", ".", "err_95_upper", ",", "\n", "facecolor", "=", "\"tab:green\"", ",", "\n", "alpha", "=", "0.2", ",", "\n", ")", "\n", "plt", ".", "plot", "(", "pred", ".", "x", ",", "pred", ".", "samples", ",", "c", "=", "\"tab:red\"", ",", "lw", "=", "1", ")", "\n", "\n", "# Plot true PSD.", "\n", "if", "true_kernel", ":", "\n", "            ", "plt", ".", "plot", "(", "freqs_true", ",", "psd_true", ",", "c", "=", "\"black\"", ",", "label", "=", "\"True\"", ",", "scaley", "=", "False", ")", "\n", "\n", "# Plot PSD derived from the autocorrelation.", "\n", "", "if", "t_is_equally_spaced", ":", "\n", "            ", "plt", ".", "plot", "(", "\n", "freqs_ac", ",", "psd_ac", ",", "c", "=", "\"tab:blue\"", ",", "label", "=", "\"Autocorrelation\"", ",", "scaley", "=", "False", "\n", ")", "\n", "\n", "# Set limits and format.", "\n", "", "if", "\"psd\"", "in", "x_range", ":", "\n", "            ", "plt", ".", "xlim", "(", "*", "x_range", "[", "\"psd\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "if", "t_is_equally_spaced", ":", "\n", "                ", "plt", ".", "xlim", "(", "0", ",", "max", "(", "freqs_ac", ")", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "xlim", "(", "0", ",", "max", "(", "pred", ".", "x", ")", ")", "\n", "", "", "if", "\"psd\"", "in", "y_range", ":", "\n", "            ", "plt", ".", "ylim", "(", "*", "y_range", "[", "\"psd\"", "]", ")", "\n", "", "wbml", ".", "plot", ".", "tweak", "(", "legend", "=", "True", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "if", "wd", ":", "\n", "        ", "plt", ".", "savefig", "(", "wd", ".", "file", "(", "\"prediction_psd.pdf\"", ")", ")", "\n", "\n", "# Plot Fourier features for GP-RV.", "\n", "", "plt", ".", "figure", "(", "figsize", "=", "(", "12", ",", "8", ")", ")", "\n", "\n", "for", "i", ",", "model", "in", "enumerate", "(", "models", ")", ":", "\n", "# Predict Fourier features if it is a GP-RV.", "\n", "        ", "if", "isinstance", "(", "model", ",", "RGPCM", ")", ":", "\n", "            ", "mean", ",", "var", "=", "model", ".", "predict_fourier", "(", ")", "\n", "", "else", ":", "\n", "            ", "continue", "\n", "\n", "# Compute upper and lower error bounds.", "\n", "", "lower", "=", "mean", "-", "1.96", "*", "B", ".", "sqrt", "(", "var", ")", "\n", "upper", "=", "mean", "+", "1.96", "*", "B", ".", "sqrt", "(", "var", ")", "\n", "\n", "plt", ".", "subplot", "(", "3", ",", "2", ",", "1", "+", "2", "*", "i", ")", "\n", "plt", ".", "title", "(", "f\"Cosine Features ({model.name})\"", ")", "\n", "freqs", "=", "model", ".", "ms", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "inds", "=", "np", ".", "concatenate", "(", "\n", "np", ".", "where", "(", "model", ".", "ms", "==", "0", ")", "+", "np", ".", "where", "(", "model", ".", "ms", "<=", "model", ".", "m_max", ")", "\n", ")", "\n", "plt", ".", "errorbar", "(", "\n", "freqs", "[", "inds", "]", ",", "\n", "mean", "[", "inds", "]", ",", "\n", "(", "mean", "[", "inds", "]", "-", "lower", "[", "inds", "]", ",", "upper", "[", "inds", "]", "-", "mean", "[", "inds", "]", ")", ",", "\n", "ls", "=", "\"none\"", ",", "\n", "marker", "=", "\"o\"", ",", "\n", "capsize", "=", "3", ",", "\n", ")", "\n", "plt", ".", "xlabel", "(", "\"Frequency (Hz)\"", ")", "\n", "wbml", ".", "plot", ".", "tweak", "(", "legend", "=", "False", ")", "\n", "\n", "plt", ".", "subplot", "(", "3", ",", "2", ",", "2", "+", "2", "*", "i", ")", "\n", "plt", ".", "title", "(", "f\"Sine Features ({model.name})\"", ")", "\n", "freqs", "=", "np", ".", "maximum", "(", "model", ".", "ms", "-", "model", ".", "m_max", ",", "0", ")", "/", "(", "model", ".", "b", "-", "model", ".", "a", ")", "\n", "inds", "=", "np", ".", "concatenate", "(", "\n", "np", ".", "where", "(", "model", ".", "ms", "==", "0", ")", "+", "np", ".", "where", "(", "model", ".", "ms", ">", "model", ".", "m_max", ")", "\n", ")", "\n", "plt", ".", "errorbar", "(", "\n", "freqs", "[", "inds", "]", ",", "\n", "mean", "[", "inds", "]", ",", "\n", "(", "mean", "[", "inds", "]", "-", "lower", "[", "inds", "]", ",", "upper", "[", "inds", "]", "-", "mean", "[", "inds", "]", ")", ",", "\n", "ls", "=", "\"none\"", ",", "\n", "marker", "=", "\"o\"", ",", "\n", "capsize", "=", "3", ",", "\n", ")", "\n", "plt", ".", "xlabel", "(", "\"Frequency (Hz)\"", ")", "\n", "wbml", ".", "plot", ".", "tweak", "(", "legend", "=", "False", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "if", "wd", ":", "\n", "        ", "plt", ".", "savefig", "(", "wd", ".", "file", "(", "\"prediction_fourier.pdf\"", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.vix_forecast.first_monday": [[21, 27], ["datetime.datetime", "datetime.datetime.weekday", "datetime.timedelta"], "function", ["None"], ["def", "first_monday", "(", "year", ")", ":", "\n", "    ", "\"\"\"Get the first Monday of a year.\"\"\"", "\n", "dt", "=", "datetime", "(", "year", ",", "1", ",", "1", ")", "\n", "while", "dt", ".", "weekday", "(", ")", "!=", "0", ":", "\n", "        ", "dt", "+=", "timedelta", "(", "days", "=", "1", ")", "\n", "", "return", "dt", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.vix_forecast.get_data": [[29, 37], ["datetime.datetime", "numpy.array", "numpy.log", "numpy.array"], "function", ["None"], ["", "def", "get_data", "(", "lower", ",", "upper", ")", ":", "\n", "    ", "\"\"\"Get data for a certain time range.\"\"\"", "\n", "df", "=", "data", "[", "(", "data", ".", "index", ">=", "lower", ")", "&", "(", "data", ".", "index", "<", "upper", ")", "]", "\n", "# Convert index to days since reference.", "\n", "ref", "=", "datetime", "(", "2000", ",", "1", ",", "1", ")", "\n", "t", "=", "np", ".", "array", "(", "[", "(", "ti", "-", "ref", ")", ".", "days", "for", "ti", "in", "df", ".", "index", "]", ",", "dtype", "=", "float", ")", "\n", "y", "=", "np", ".", "log", "(", "np", ".", "array", "(", "df", ".", "open", ")", ")", "\n", "return", "t", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.smk.extract": [[42, 45], ["None"], "function", ["None"], ["window", "=", "window", ",", "\n", "scale", "=", "scale", ",", "\n", "t", "=", "t", ",", "\n", "y", "=", "y", ",", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample.sample": [[24, 54], ["wbml.out.Progress", "range", "model.kernel_approx", "wbml.out.kv", "ks.append", "lab.matmul", "fs.append", "progress", "lab.sample", "lab.chol", "model.compute_K_u", "gpcm.util.closest_psd"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.kernel_approx", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.closest_psd"], ["\n", "\n", "def", "__init__", "(", "self", ",", "log_lik", ",", "sample_prior", ",", "x_init", "=", "None", ")", ":", "\n", "        ", "self", ".", "log_lik", "=", "log_lik", "\n", "self", ".", "sample_prior", "=", "sample_prior", "\n", "\n", "self", ".", "x", "=", "None", "\n", "self", ".", "log_lik_x", "=", "None", "\n", "\n", "# Initialise.", "\n", "if", "x_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "move", "(", "x_init", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "move", "(", "sample_prior", "(", ")", ")", "\n", "\n", "", "", "def", "move", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Move to a particular state.\n\n        Args:\n            x (tensor): State to move to.\n        \"\"\"", "\n", "self", ".", "x", "=", "x", "\n", "self", ".", "log_lik_x", "=", "self", ".", "log_lik", "(", "self", ".", "x", ")", "\n", "\n", "", "def", "_establish_ellipse", "(", "self", ")", ":", "\n", "        ", "\"\"\"Establish an ellipse, which is required to draw the new state.\"\"\"", "\n", "self", ".", "y", "=", "self", ".", "sample_prior", "(", ")", "\n", "\n", "", "def", "_draw_proposal", "(", "self", ",", "lower", ",", "upper", ")", ":", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample": [[25, 78], ["lab.ones", "stheno.GP", "stheno.GP.mean.flatten", "lab.zeros", "stheno.GP", "stheno.GP.mean.flatten", "lab.abs", "model.k_h", "model.k_h", "wbml.out.Progress", "lab.sample", "stheno.GP.", "lab.sample", "stheno.GP.", "model.kernel_approx", "wbml.out.kv", "ks.append", "us.append", "lab.matmul", "fs.append", "progress", "model.compute_K_u", "stheno.GP.", "model.compute_K_u", "stheno.GP.", "lab.chol", "gpcm.util.closest_psd"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.GPCM.k_h", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.kernel_approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.util.closest_psd"], ["def", "sample", "(", "model", ",", "t", ",", "noise_f", ")", ":", "\n", "    ", "\"\"\"Sample from a model.\n\n    Args:\n        model (:class:`gpcm.model.AbstractGPCM`): Model to sample from.\n        t (vector): Time points to sample at.\n        noise_f (vector): Noise for the sample of the function. Should have the\n            same size as `t`.\n\n    Returns:\n        tuple[vector, ...]: Tuple containing kernel samples, filter samples, and\n            function samples.\n    \"\"\"", "\n", "ks", ",", "us", ",", "fs", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "# In the below, we look at the third inducing point, because that is the one", "\n", "# determining the value of the filter at zero: the CGPCM adds two extra inducing", "\n", "# points to the left.", "\n", "\n", "# Get a smooth sample.", "\n", "u1", "=", "B", ".", "ones", "(", "model", ".", "n_u", ")", "\n", "while", "B", ".", "abs", "(", "u1", "[", "2", "]", ")", ">", "1e-2", ":", "\n", "        ", "u1", "=", "B", ".", "sample", "(", "model", ".", "compute_K_u", "(", ")", ")", "[", ":", ",", "0", "]", "\n", "", "u", "=", "GP", "(", "model", ".", "k_h", "(", ")", ")", "\n", "u", "=", "u", "|", "(", "u", "(", "model", ".", "t_u", ")", ",", "u1", ")", "\n", "u1_full", "=", "u", "(", "t", ")", ".", "mean", ".", "flatten", "(", ")", "\n", "\n", "# Get a rough sample.", "\n", "u2", "=", "B", ".", "zeros", "(", "model", ".", "n_u", ")", "\n", "while", "u2", "[", "2", "]", "<", "0.5", ":", "\n", "        ", "u2", "=", "B", ".", "sample", "(", "model", ".", "compute_K_u", "(", ")", ")", "[", ":", ",", "0", "]", "\n", "", "u", "=", "GP", "(", "model", ".", "k_h", "(", ")", ")", "\n", "u", "=", "u", "|", "(", "u", "(", "model", ".", "t_u", ")", ",", "u2", ")", "\n", "u2_full", "=", "u", "(", "t", ")", ".", "mean", ".", "flatten", "(", ")", "\n", "\n", "with", "wbml", ".", "out", ".", "Progress", "(", "name", "=", "\"Sampling\"", ",", "total", "=", "5", ")", "as", "progress", ":", "\n", "        ", "for", "c", "in", "[", "0", ",", "0.1", ",", "0.23", ",", "0.33", ",", "0.5", "]", ":", "\n", "# Sample kernel.", "\n", "            ", "K", "=", "model", ".", "kernel_approx", "(", "t", ",", "t", ",", "c", "*", "u2", "+", "(", "1", "-", "c", ")", "*", "u1", ")", "\n", "wbml", ".", "out", ".", "kv", "(", "\"Sampled variance\"", ",", "K", "[", "0", ",", "0", "]", ")", "\n", "K", "=", "K", "/", "K", "[", "0", ",", "0", "]", "\n", "ks", ".", "append", "(", "K", "[", "0", ",", ":", "]", ")", "\n", "\n", "# Store filter.", "\n", "us", ".", "append", "(", "c", "*", "u2_full", "+", "(", "1", "-", "c", ")", "*", "u1_full", ")", "\n", "\n", "# Sample function.", "\n", "f", "=", "B", ".", "matmul", "(", "B", ".", "chol", "(", "closest_psd", "(", "K", ")", ")", ",", "noise_f", ")", "\n", "fs", ".", "append", "(", "f", ")", "\n", "\n", "progress", "(", ")", "\n", "\n", "", "", "return", "ks", ",", "us", ",", "fs", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.vix_forecast_process.compute_metrics": [[12, 37], ["wd_results.load", "rmses.append", "mlls.append", "wbml.rmse", "wbml.mll", "wbml.Section", "model.upper", "wbml.Section", "wbml.kv", "wbml.kv", "numpy.mean", "numpy.std", "len"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean"], ["def", "compute_metrics", "(", "model", ",", "summarise", "=", "True", ")", ":", "\n", "    ", "\"\"\"Compute metrics.\n\n    Args:\n        model (str): Name of the model folder.\n        summarise (bool, optional): Summarise the metrics rather than given the data\n            back. Defaults to `True`.\n\n    Returns:\n        union[None, tuple[:class:`np.array`, :class:`np.array`]]: The metrics if\n            `summarise` is `False`. Otherwise nothing.\n    \"\"\"", "\n", "rmses", ",", "mlls", "=", "[", "]", ",", "[", "]", "\n", "preds", "=", "wd_results", ".", "load", "(", "model", ",", "\"preds.pickle\"", ")", "\n", "for", "(", "y", ",", "mean", ",", "var", ")", "in", "preds", ":", "\n", "        ", "rmses", ".", "append", "(", "metric", ".", "rmse", "(", "mean", ",", "y", ")", ")", "\n", "mlls", ".", "append", "(", "metric", ".", "mll", "(", "mean", ",", "var", ",", "y", ")", ")", "\n", "", "if", "summarise", ":", "\n", "        ", "with", "out", ".", "Section", "(", "model", ".", "upper", "(", ")", ")", ":", "\n", "            ", "for", "name", ",", "values", "in", "[", "(", "\"MLL\"", ",", "mlls", ")", ",", "(", "\"RMSE\"", ",", "rmses", ")", "]", ":", "\n", "                ", "with", "out", ".", "Section", "(", "name", ")", ":", "\n", "                    ", "out", ".", "kv", "(", "\"Mean\"", ",", "np", ".", "mean", "(", "values", ")", ")", "\n", "out", ".", "kv", "(", "\"Std\"", ",", "np", ".", "std", "(", "values", ")", "/", "len", "(", "values", ")", "**", "0.5", ")", "\n", "", "", "", "", "else", ":", "\n", "        ", "return", "mlls", ",", "rmses", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.vix_forecast_process.compare": [[39, 57], ["vix_forecast_process.compute_metrics", "vix_forecast_process.compute_metrics", "wbml.Section", "wbml.Section", "numpy.mean", "wbml.kv", "wbml.kv", "wbml.kv", "model1.upper", "model2.upper", "zip", "numpy.std", "scipy.norm.cdf", "len", "abs"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.vix_forecast_process.compute_metrics", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.vix_forecast_process.compute_metrics", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean"], ["", "", "def", "compare", "(", "model1", ",", "model2", ")", ":", "\n", "    ", "\"\"\"Compare two models.\n\n    Args:\n        model1 (str): Model folder of the first model to compare.\n        model2 (str): Model folder of the second model to compare.\n    \"\"\"", "\n", "mlls1", ",", "rmses1", "=", "compute_metrics", "(", "model1", ",", "summarise", "=", "False", ")", "\n", "mlls2", ",", "rmses2", "=", "compute_metrics", "(", "model2", ",", "summarise", "=", "False", ")", "\n", "with", "out", ".", "Section", "(", "f\"{model1.upper()} - {model2.upper()}\"", ")", ":", "\n", "        ", "for", "name", ",", "values1", ",", "values2", "in", "[", "(", "\"MLL\"", ",", "mlls1", ",", "mlls2", ")", ",", "(", "\"RMSE\"", ",", "rmses1", ",", "rmses2", ")", "]", ":", "\n", "            ", "diff", "=", "[", "x", "-", "y", "for", "x", ",", "y", "in", "zip", "(", "values1", ",", "values2", ")", "]", "\n", "with", "out", ".", "Section", "(", "name", ")", ":", "\n", "                ", "mean", "=", "np", ".", "mean", "(", "diff", ")", "\n", "std", "=", "np", ".", "std", "(", "diff", ")", "/", "len", "(", "diff", ")", "**", "0.5", "\n", "out", ".", "kv", "(", "\"Mean\"", ",", "mean", ")", "\n", "out", ".", "kv", "(", "\"Std\"", ",", "std", ")", "\n", "out", ".", "kv", "(", "\"p-value\"", ",", "st", ".", "norm", ".", "cdf", "(", "-", "abs", "(", "mean", ")", "/", "std", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.crude_oil.plot_psd": [[144, 167], ["matplotlib.plot", "matplotlib.fill_between", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "wbml.plot.tweak"], "function", ["None"], ["", "", "def", "plot_psd", "(", "name", ",", "y_label", "=", "True", ",", "style", "=", "\"pred\"", ",", "finish", "=", "True", ")", ":", "\n", "    ", "\"\"\"Plot prediction for the PSD.\"\"\"", "\n", "freqs", ",", "mean", ",", "lower", ",", "upper", "=", "preds_psd", "[", "name", "]", "\n", "freqs", "-=", "freqs", "[", "0", "]", "\n", "\n", "inds", "=", "freqs", "<=", "0.2", "\n", "freqs", "=", "freqs", "[", "inds", "]", "\n", "mean", "=", "mean", "[", "inds", "]", "\n", "lower", "=", "lower", "[", "inds", "]", "\n", "upper", "=", "upper", "[", "inds", "]", "\n", "\n", "if", "y_label", ":", "\n", "        ", "plt", ".", "ylabel", "(", "\"PSD (dB)\"", ")", "\n", "\n", "", "plt", ".", "plot", "(", "freqs", ",", "mean", ",", "style", "=", "style", ",", "label", "=", "name", ")", "\n", "plt", ".", "fill_between", "(", "freqs", ",", "lower", ",", "upper", ",", "style", "=", "style", ")", "\n", "plt", ".", "plot", "(", "freqs", ",", "lower", ",", "style", "=", "style", ",", "lw", "=", "0.5", ")", "\n", "plt", ".", "plot", "(", "freqs", ",", "upper", ",", "style", "=", "style", ",", "lw", "=", "0.5", ")", "\n", "plt", ".", "xlim", "(", "0", ",", "0.2", ")", "\n", "plt", ".", "ylim", "(", "0", ",", "60", ")", "\n", "plt", ".", "xlabel", "(", "\"Frequency (day${}^{-1}$)\"", ")", "\n", "if", "finish", ":", "\n", "        ", "tweak", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.crude_oil.plot_compare": [[169, 221], ["matplotlib.plot", "matplotlib.fill_between", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.plot", "matplotlib.plot", "matplotlib.scatter", "matplotlib.scatter", "matplotlib.xlim", "matplotlib.xlabel", "wbml.plot.tweak", "normaliser.untransform", "matplotlib.ylabel", "matplotlib.gca().set_yticklabels", "name1.upper", "name2.upper", "lab.sqrt", "lab.sqrt", "lab.sqrt", "lab.sqrt", "lab.sqrt", "lab.sqrt", "lab.sqrt", "lab.sqrt", "matplotlib.gca"], "function", ["None"], ["", "", "def", "plot_compare", "(", "name1", ",", "name2", ",", "y_label", "=", "True", ",", "y_ticks", "=", "True", ",", "style2", "=", "None", ")", ":", "\n", "    ", "\"\"\"Compare prediction for the function for two models.\"\"\"", "\n", "_", ",", "mean1", ",", "var1", "=", "preds_f", "[", "name1", "]", "\n", "_", ",", "mean2", ",", "var2", "=", "preds_f", "[", "name2", "]", "\n", "\n", "inds", "=", "t_pred", ">=", "150", "\n", "mean1", "=", "mean1", "[", "inds", "]", "\n", "mean2", "=", "mean2", "[", "inds", "]", "\n", "var1", "=", "var1", "[", "inds", "]", "\n", "var2", "=", "var2", "[", "inds", "]", "\n", "t", "=", "t_pred", "[", "inds", "]", "\n", "\n", "plt", ".", "plot", "(", "t", ",", "mean1", ",", "style", "=", "\"pred\"", ",", "label", "=", "name1", ".", "upper", "(", ")", ")", "\n", "plt", ".", "fill_between", "(", "\n", "t", ",", "\n", "mean1", "-", "1.96", "*", "B", ".", "sqrt", "(", "var1", ")", ",", "\n", "mean1", "+", "1.96", "*", "B", ".", "sqrt", "(", "var1", ")", ",", "\n", "style", "=", "\"pred\"", ",", "\n", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean1", "-", "1.96", "*", "B", ".", "sqrt", "(", "var1", ")", ",", "style", "=", "\"pred\"", ",", "lw", "=", "0.5", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean1", "+", "1.96", "*", "B", ".", "sqrt", "(", "var1", ")", ",", "style", "=", "\"pred\"", ",", "lw", "=", "0.5", ")", "\n", "\n", "if", "style2", "is", "None", ":", "\n", "        ", "style2", "=", "\"pred2\"", "\n", "\n", "", "plt", ".", "plot", "(", "t", ",", "mean2", ",", "style", "=", "style2", ",", "label", "=", "name2", ".", "upper", "(", ")", ")", "\n", "plt", ".", "fill_between", "(", "\n", "t", ",", "\n", "mean2", "-", "1.96", "*", "B", ".", "sqrt", "(", "var2", ")", ",", "\n", "mean2", "+", "1.96", "*", "B", ".", "sqrt", "(", "var2", ")", ",", "\n", "style", "=", "style2", ",", "\n", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean2", "-", "1.96", "*", "B", ".", "sqrt", "(", "var2", ")", ",", "style", "=", "style2", ",", "lw", "=", "0.5", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean2", "+", "1.96", "*", "B", ".", "sqrt", "(", "var2", ")", ",", "style", "=", "style2", ",", "lw", "=", "0.5", ")", "\n", "\n", "inds", "=", "t_train", ">=", "150", "\n", "plt", ".", "scatter", "(", "\n", "t_train", "[", "inds", "]", ",", "\n", "normaliser", ".", "untransform", "(", "y_train", "[", "inds", "]", ")", ",", "\n", "style", "=", "\"train\"", ",", "\n", "label", "=", "\"Train\"", ",", "\n", ")", "\n", "inds", "=", "t_test", ">=", "150", "\n", "plt", ".", "scatter", "(", "t_test", "[", "inds", "]", ",", "y_test", "[", "inds", "]", ",", "style", "=", "\"test\"", ",", "label", "=", "\"Test\"", ")", "\n", "\n", "plt", ".", "xlim", "(", "t", "[", "0", "]", ",", "t", "[", "-", "1", "]", ")", "\n", "plt", ".", "xlabel", "(", "f\"Day of {args.year}\"", ")", "\n", "if", "y_label", ":", "\n", "        ", "plt", ".", "ylabel", "(", "\"Crude Oil (USD)\"", ")", "\n", "", "if", "not", "y_ticks", ":", "\n", "        ", "plt", ".", "gca", "(", ")", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "", "tweak", "(", "legend_loc", "=", "\"upper right\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.priors._extract_samples": [[31, 37], ["lab.concat", "lab.concat"], "function", ["None"], ["def", "_extract_samples", "(", "quantities", ")", ":", "\n", "    ", "x", "=", "quantities", ".", "x", "\n", "samples", "=", "quantities", ".", "all_samples", "\n", "return", "(", "\n", "B", ".", "concat", "(", "-", "x", "[", ":", ":", "-", "1", "]", "[", ":", "-", "1", "]", ",", "x", ")", ",", "\n", "B", ".", "concat", "(", "samples", "[", ":", ":", "-", "1", ",", ":", "]", "[", ":", "-", "1", ",", ":", "]", ",", "samples", ",", "axis", "=", "0", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.__init__": [[18, 22], ["time.time"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "ref", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "times", "=", "[", "]", "\n", "self", ".", "values", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.track": [[23, 28], ["hasattr", "compare_inference.Tracker.times.append", "compare_inference.Tracker.values.append", "time.time"], "methods", ["None"], ["", "def", "track", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "hasattr", "(", "value", ",", "\"primal\"", ")", ":", "\n", "            ", "value", "=", "value", ".", "primal", "\n", "", "self", ".", "times", ".", "append", "(", "time", ".", "time", "(", ")", "-", "self", ".", "ref", ")", "\n", "self", ".", "values", ".", "append", "(", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.pause": [[29, 39], ["Context", "time.time", "time.time"], "methods", ["None"], ["", "def", "pause", "(", "self", ")", ":", "\n", "        ", "class", "Context", ":", "\n", "            ", "def", "__enter__", "(", "ctx", ")", ":", "\n", "                ", "ctx", ".", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "", "def", "__exit__", "(", "ctx", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "\n", "                ", "elapsed", "=", "time", ".", "time", "(", ")", "-", "ctx", ".", "start", "\n", "self", ".", "ref", "+=", "elapsed", "\n", "\n", "", "", "return", "Context", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.get_xy": [[40, 44], ["numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "get_xy", "(", "self", ",", "start", "=", "2", ")", ":", "\n", "        ", "x", "=", "np", ".", "array", "(", "self", ".", "times", "[", "start", ":", "]", ")", "-", "self", ".", "times", "[", "start", "]", "\n", "y", "=", "np", ".", "array", "(", "self", ".", "values", "[", "start", ":", "]", ")", "\n", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.jit": [[46, 61], ["compare_inference.objective", "vs.copy", "vs.copy.set_latent_vector", "compare_inference.objective", "compare_inference.jit.objective_vectorised", "compare_inference.objective_raw", "compare_inference.objective_raw"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.objective", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.objective", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.objective_raw", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.objective_raw"], ["", "", "def", "jit", "(", "vs", ",", "objective", ")", ":", "\n", "    ", "\"\"\"JIT a function which takes in a Varz variable container.\"\"\"", "\n", "# Run once to ensure that all parameters exist.", "\n", "objective", "(", "vs", ")", "\n", "\n", "@", "B", ".", "jit", "\n", "def", "objective_vectorised", "(", "params", ",", "*", "args", ")", ":", "\n", "        ", "vs_copy", "=", "vs", ".", "copy", "(", ")", "\n", "vs_copy", ".", "set_latent_vector", "(", "params", ")", "\n", "return", "objective", "(", "vs_copy", ",", "*", "args", ")", "\n", "\n", "", "def", "objective_wrapped", "(", "vs_", ",", "*", "args", ")", ":", "\n", "        ", "return", "objective_vectorised", "(", "vs_", ".", "get_latent_vector", "(", ")", ",", "*", "args", ")", "\n", "\n", "", "return", "objective_wrapped", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.objective_raw": [[142, 150], ["model().approximation.elbo", "lab.global_random_state", "model"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.elbo", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model"], ["def", "objective_raw", "(", "vs_", ")", ":", "\n", "    ", "_", ",", "elbo", "=", "model", "(", "vs_", ")", ".", "approximation", ".", "elbo", "(", "\n", "B", ".", "global_random_state", "(", "vs_", ".", "dtype", ")", ",", "\n", "t", ",", "\n", "y", ",", "\n", "collapsed", "=", "\"z\"", ",", "\n", ")", "\n", "return", "-", "elbo", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.objective": [[156, 160], ["objective_jitted", "tracker_cmf.track"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.track"], ["def", "objective", "(", "vs_", ")", ":", "\n", "    ", "nelbo", "=", "objective_jitted", "(", "vs_", ")", "\n", "tracker_cmf", ".", "track", "(", "-", "nelbo", ")", "\n", "return", "nelbo", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.callback": [[226, 243], ["tracker_s.track", "tracker_s.pause", "model", "lab.global_random_state", "model.approximation.elbo_collapsed_z", "lab.set_global_random_state"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.track", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.compare_inference.Tracker.pause", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.approx.Structured.elbo_collapsed_z"], ["def", "callback", "(", "q_u", ",", "q_z", ")", ":", "\n", "    ", "global", "count", "\n", "count", "+=", "1", "\n", "if", "count", "<", "20", "or", "count", "%", "5", "==", "0", ":", "\n", "        ", "with", "tracker_s", ".", "pause", "(", ")", ":", "\n", "            ", "instance", "=", "model", "(", ")", "\n", "instance", ".", "approximation", ".", "q_u", "=", "q_u", "\n", "\n", "state", "=", "B", ".", "global_random_state", "(", "instance", ".", "dtype", ")", "\n", "state", ",", "elbo_s", "=", "instance", ".", "approximation", ".", "elbo_collapsed_z", "(", "\n", "state", ",", "\n", "t", ",", "\n", "y", ",", "\n", "num_samples", "=", "100", ",", "\n", ")", "\n", "B", ".", "set_global_random_state", "(", "state", ")", "\n", "", "tracker_s", ".", "track", "(", "elbo_s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.comparison_process.kernel_analysis": [[14, 25], ["wd_results.load", "wd_results.load", "wbml.metric.smll", "wbml.metric.rmse", "ValueError"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load"], ["def", "kernel_analysis", "(", "data", ",", "scheme", ",", "model", ",", "metric", ",", "until", "=", "4", ")", ":", "\n", "    ", "\"\"\"Analyse the prediction for a kernel.\"\"\"", "\n", "k", "=", "wd_results", ".", "load", "(", "data", ",", "\"data.pickle\"", ")", "[", "\"k\"", "]", "\n", "t", ",", "mean", ",", "var", "=", "wd_results", ".", "load", "(", "data", ",", "scheme", ",", "model", ",", "\"k_pred.pickle\"", ")", "\n", "inds", "=", "t", "<=", "until", "\n", "if", "metric", "==", "\"smll\"", ":", "\n", "        ", "return", "smll", "(", "mean", "[", "inds", "]", ",", "var", "[", "inds", "]", ",", "k", "[", "inds", "]", ")", "\n", "", "elif", "metric", "==", "\"rmse\"", ":", "\n", "        ", "return", "rmse", "(", "mean", "[", "inds", "]", ",", "k", "[", "inds", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Bad metric \"{metric}\".'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.paper.comparison_process.plot_kernel_predictions": [[37, 68], ["wd_results.load", "wd_results.load", "matplotlib.plot", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.fill_between", "matplotlib.plot", "matplotlib.plot", "matplotlib.yticks", "matplotlib.xticks", "matplotlib.xlim", "matplotlib.ylim", "wbml.plot.tweak", "wd_results.load", "matplotlib.gca().set_yticklabels", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "matplotlib.gca"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.load"], ["", "", "", "def", "plot_kernel_predictions", "(", "model", ",", "data_name", ",", "legend", "=", "True", ",", "first", "=", "False", ")", ":", "\n", "    ", "\"\"\"Plot the prediction for a kernel.\"\"\"", "\n", "k", "=", "wd_results", ".", "load", "(", "data_name", ",", "\"data.pickle\"", ")", "[", "\"k\"", "]", "\n", "t", ",", "mean1", ",", "var1", "=", "wd_results", ".", "load", "(", "data_name", ",", "\"structured\"", ",", "model", ",", "\"k_pred.pickle\"", ")", "\n", "t", ",", "mean2", ",", "var2", "=", "wd_results", ".", "load", "(", "data_name", ",", "\"mean-field\"", ",", "model", ",", "\"k_pred.pickle\"", ")", "\n", "plt", ".", "plot", "(", "t", ",", "k", ",", "label", "=", "\"Truth\"", ",", "style", "=", "\"train\"", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean1", ",", "label", "=", "\"Structured\"", ",", "style", "=", "\"pred\"", ")", "\n", "plt", ".", "fill_between", "(", "\n", "t", ",", "\n", "mean1", "-", "1.96", "*", "np", ".", "sqrt", "(", "var1", ")", ",", "\n", "mean1", "+", "1.96", "*", "np", ".", "sqrt", "(", "var1", ")", ",", "\n", "style", "=", "\"pred\"", ",", "\n", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean1", "+", "1.96", "*", "np", ".", "sqrt", "(", "var1", ")", ",", "style", "=", "\"pred\"", ",", "lw", "=", "1", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean1", "-", "1.96", "*", "np", ".", "sqrt", "(", "var1", ")", ",", "style", "=", "\"pred\"", ",", "lw", "=", "1", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean2", ",", "label", "=", "\"Mean-field\"", ",", "style", "=", "\"pred2\"", ")", "\n", "plt", ".", "fill_between", "(", "\n", "t", ",", "\n", "mean2", "-", "1.96", "*", "np", ".", "sqrt", "(", "var2", ")", ",", "\n", "mean2", "+", "1.96", "*", "np", ".", "sqrt", "(", "var2", ")", ",", "\n", "style", "=", "\"pred2\"", ",", "\n", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean2", "+", "1.96", "*", "np", ".", "sqrt", "(", "var2", ")", ",", "style", "=", "\"pred2\"", ",", "lw", "=", "1", ")", "\n", "plt", ".", "plot", "(", "t", ",", "mean2", "-", "1.96", "*", "np", ".", "sqrt", "(", "var2", ")", ",", "style", "=", "\"pred2\"", ",", "lw", "=", "1", ")", "\n", "plt", ".", "yticks", "(", "[", "0", ",", "0.5", ",", "1", "]", ")", "\n", "plt", ".", "xticks", "(", "[", "0", ",", "2", ",", "4", "]", ")", "\n", "plt", ".", "xlim", "(", "0", ",", "4", ")", "\n", "plt", ".", "ylim", "(", "-", "0.25", ",", "1.25", ")", "\n", "if", "not", "first", ":", "\n", "        ", "plt", ".", "gca", "(", ")", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "", "tweak", "(", "legend", "=", "legend", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.t1": [[20, 23], ["pytest.fixture", "gpcm.exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "t1", "(", ")", ":", "\n", "    ", "return", "var", "(", "\"t1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.t2": [[25, 28], ["pytest.fixture", "gpcm.exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "t2", "(", ")", ":", "\n", "    ", "return", "var", "(", "\"t2\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.t3": [[30, 33], ["pytest.fixture", "gpcm.exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "t3", "(", ")", ":", "\n", "    ", "return", "var", "(", "\"t3\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_safe_sqrt": [[35, 39], ["gpcm.exppoly.safe_sqrt", "gpcm.exppoly.safe_sqrt", "gpcm.exppoly.safe_sqrt"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.safe_sqrt"], ["", "def", "test_safe_sqrt", "(", ")", ":", "\n", "    ", "assert", "safe_sqrt", "(", "4.0", ")", "==", "2", "\n", "assert", "safe_sqrt", "(", "0.0", ")", "==", "1e-15", "\n", "assert", "safe_sqrt", "(", "0", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_is_inf": [[41, 46], ["gpcm.exppoly.is_inf", "gpcm.exppoly.is_inf", "gpcm.exppoly.is_inf", "gpcm.exppoly.is_inf"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.is_inf"], ["", "def", "test_is_inf", "(", ")", ":", "\n", "    ", "assert", "not", "is_inf", "(", "None", ")", "\n", "assert", "not", "is_inf", "(", "1", ")", "\n", "assert", "is_inf", "(", "np", ".", "inf", ")", "\n", "assert", "is_inf", "(", "-", "np", ".", "inf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_const": [[48, 50], ["isinstance", "gpcm.exppoly.const"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "def", "test_const", "(", ")", ":", "\n", "    ", "assert", "isinstance", "(", "const", "(", "1", ")", ",", "Poly", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_var": [[52, 54], ["isinstance", "gpcm.exppoly.var"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.var"], ["", "def", "test_var", "(", ")", ":", "\n", "    ", "assert", "isinstance", "(", "var", "(", "\"t\"", ")", ",", "Poly", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_factor_constructor": [[56, 61], ["gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "pytest.raises", "gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_factor_constructor", "(", ")", ":", "\n", "    ", "assert", "Factor", "(", "\"t\"", ")", "==", "Factor", "(", "\"t\"", ",", "1", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", ":", "\n", "        ", "Factor", "(", "\"t\"", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_factor_str": [[63, 67], ["gpcm.exppoly.Factor", "str", "str", "repr"], "function", ["None"], ["", "", "def", "test_factor_str", "(", ")", ":", "\n", "    ", "f", "=", "Factor", "(", "\"t\"", ",", "2", ")", "\n", "assert", "str", "(", "f", ")", "==", "\"t^2\"", "\n", "assert", "str", "(", "f", ")", "==", "repr", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_factor_eval": [[69, 71], ["gpcm.exppoly.Factor().eval", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval"], ["", "def", "test_factor_eval", "(", ")", ":", "\n", "    ", "assert", "Factor", "(", "\"t\"", ",", "2", ")", ".", "eval", "(", "t", "=", "2", ")", "==", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_factor_equality": [[73, 78], ["pytest.mark.parametrize", "f", "f", "f", "f", "f", "f", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"f\"", ",", "[", "lambda", "x", ":", "x", ",", "hash", "]", ")", "\n", "def", "test_factor_equality", "(", "f", ")", ":", "\n", "    ", "assert", "f", "(", "Factor", "(", "\"t\"", ",", "2", ")", ")", "==", "f", "(", "Factor", "(", "\"t\"", ",", "2", ")", ")", "\n", "assert", "f", "(", "Factor", "(", "\"t\"", ",", "2", ")", ")", "!=", "f", "(", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "assert", "f", "(", "Factor", "(", "\"t\"", ",", "1", ")", ")", "!=", "f", "(", "Factor", "(", "\"t\"", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_factor_multiply": [[80, 91], ["gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "pytest.raises", "pytest.raises", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_factor_multiply", "(", ")", ":", "\n", "    ", "assert", "Factor", "(", "\"t\"", ",", "1", ")", "*", "Factor", "(", "\"t\"", ",", "2", ")", "==", "Factor", "(", "\"t\"", ",", "3", ")", "\n", "\n", "f", "=", "Factor", "(", "\"t\"", ",", "1", ")", "\n", "assert", "1", "*", "f", "is", "f", "\n", "assert", "f", "*", "1", "is", "f", "\n", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "Factor", "(", "\"t1\"", ",", "1", ")", "*", "Factor", "(", "\"t2\"", ",", "1", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "Factor", "(", "\"t\"", ",", "1", ")", "*", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_merge_common_factors": [[93, 105], ["set", "gpcm.exppoly._merge_common_factors", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._merge_common_factors"], ["", "", "def", "test_merge_common_factors", "(", ")", ":", "\n", "    ", "result", "=", "set", "(", "\n", "_merge_common_factors", "(", "\n", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "\n", "Factor", "(", "\"t2\"", ",", "2", ")", ",", "\n", "Factor", "(", "\"t3\"", ",", "3", ")", ",", "\n", "Factor", "(", "\"t2\"", ",", "4", ")", ",", "\n", "Factor", "(", "\"t1\"", ",", "5", ")", ",", "\n", ")", "\n", ")", "\n", "expected", "=", "{", "Factor", "(", "\"t1\"", ",", "6", ")", ",", "Factor", "(", "\"t2\"", ",", "6", ")", ",", "Factor", "(", "\"t3\"", ",", "3", ")", "}", "\n", "assert", "result", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_constructor": [[107, 111], ["gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_term_constructor", "(", ")", ":", "\n", "    ", "assert", "Term", "(", "Factor", "(", "\"t\"", ",", "2", ")", ")", "==", "Term", "(", "1", ",", "Factor", "(", "\"t\"", ",", "2", ")", ")", "\n", "assert", "Term", "(", "Factor", "(", "\"t\"", ",", "2", ")", ",", "Factor", "(", "\"t\"", ",", "3", ")", ")", "==", "Term", "(", "Factor", "(", "\"t\"", ",", "5", ")", ")", "\n", "assert", "Term", "(", "0", ",", "Factor", "(", "\"t\"", ",", "2", ")", ")", "==", "Term", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_is_function_of": [[113, 118], ["gpcm.exppoly.Term", "gpcm.exppoly.Term.is_function_of", "gpcm.exppoly.Term.is_function_of", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Term.is_function_of"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of"], ["", "def", "test_term_is_function_of", "(", ")", ":", "\n", "    ", "t", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", "\n", "assert", "t", ".", "is_function_of", "(", "\"t1\"", ")", "\n", "assert", "t", ".", "is_function_of", "(", "\"t2\"", ")", "\n", "assert", "not", "t", ".", "is_function_of", "(", "\"t3\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_collect_for": [[120, 126], ["gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Term.collect_for", "gpcm.exppoly.Term", "gpcm.exppoly.Term.collect_for", "gpcm.exppoly.Term", "pytest.raises", "gpcm.exppoly.Term.collect_for", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.collect_for"], ["", "def", "test_term_collect_for", "(", ")", ":", "\n", "    ", "t", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "assert", "t", ".", "collect_for", "(", "Factor", "(", "\"t1\"", ",", "1", ")", ")", "==", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "assert", "t", ".", "collect_for", "(", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "==", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "t", ".", "collect_for", "(", "Factor", "(", "\"t3\"", ",", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_eval": [[128, 130], ["gpcm.exppoly.Term().eval", "gpcm.exppoly.Term", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval"], ["", "", "def", "test_term_eval", "(", ")", ":", "\n", "    ", "assert", "Term", "(", "2", ",", "Factor", "(", "\"t\"", ",", "3", ")", ")", ".", "eval", "(", "t", "=", "4", ")", "==", "2", "*", "4", "**", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_is_constant": [[132, 135], ["gpcm.exppoly.Term().is_constant", "gpcm.exppoly.Term().is_constant", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_constant", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_constant"], ["", "def", "test_term_is_constant", "(", ")", ":", "\n", "    ", "assert", "Term", "(", "2", ")", ".", "is_constant", "(", ")", "\n", "assert", "not", "Term", "(", "2", ",", "Factor", "(", "\"t\"", ",", "1", ")", ")", ".", "is_constant", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_highest_power": [[137, 142], ["gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Term.highest_power", "gpcm.exppoly.Term.highest_power", "gpcm.exppoly.Term.highest_power"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power"], ["", "def", "test_term_highest_power", "(", ")", ":", "\n", "    ", "t", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "2", ")", ",", "Factor", "(", "\"t2\"", ",", "3", ")", ")", "\n", "assert", "t", ".", "highest_power", "(", "\"t1\"", ")", "==", "2", "\n", "assert", "t", ".", "highest_power", "(", "\"t2\"", ")", "==", "3", "\n", "assert", "t", ".", "highest_power", "(", "\"t3\"", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_substitute": [[144, 148], ["gpcm.exppoly.Term().substitute", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.substitute"], ["", "def", "test_term_substitute", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "result", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", ".", "substitute", "(", "\"t2\"", ",", "t1", "-", "t2", ")", "\n", "expected", "=", "2", "*", "t1", "**", "3", "-", "4", "*", "t1", "**", "2", "*", "t2", "+", "2", "*", "t1", "*", "t2", "**", "2", "\n", "assert", "result", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_str": [[150, 156], ["gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "str", "str", "repr", "str", "gpcm.exppoly.Term"], "function", ["None"], ["", "def", "test_term_str", "(", ")", ":", "\n", "    ", "t", "=", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", "\n", "assert", "str", "(", "t", ")", "==", "\"2 * t1^1 t2^2\"", "\n", "assert", "str", "(", "t", ")", "==", "repr", "(", "t", ")", "\n", "\n", "assert", "str", "(", "Term", "(", "1", ")", ")", "==", "\"1\"", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_equality": [[158, 171], ["pytest.mark.parametrize", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "f", "f", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "f", "f", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "f", "f"], "function", ["None"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"f\"", ",", "[", "lambda", "x", ":", "x", ",", "hash", "]", ")", "\n", "def", "test_term_equality", "(", "f", ")", ":", "\n", "    ", "x", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "y", "=", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", "\n", "assert", "f", "(", "x", ")", "==", "f", "(", "y", ")", "\n", "\n", "x", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "y", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "2", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "assert", "f", "(", "x", ")", "!=", "f", "(", "y", ")", "\n", "\n", "x", "=", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "y", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "assert", "f", "(", "x", ")", "!=", "f", "(", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_addition": [[173, 184], ["gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "pytest.raises", "pytest.raises", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_term_addition", "(", ")", ":", "\n", "    ", "assert", "Term", "(", "1", ",", "Factor", "(", "\"t\"", ",", "2", ")", ")", "+", "Term", "(", "2", ",", "Factor", "(", "\"t\"", ",", "2", ")", ")", "==", "Term", "(", "3", ",", "Factor", "(", "\"t\"", ",", "2", ")", ")", "\n", "\n", "t", "=", "Term", "(", "1", ",", "Factor", "(", "\"t\"", ",", "1", ")", ")", "\n", "assert", "t", "+", "0", "is", "t", "\n", "assert", "0", "+", "t", "is", "t", "\n", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", "+", "Term", "(", "1", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "t", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_term_multiplication": [[186, 197], ["gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "pytest.raises", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "", "def", "test_term_multiplication", "(", ")", ":", "\n", "    ", "result", "=", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", "*", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "expected", "=", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", "assert", "result", "==", "expected", "\n", "\n", "t", "=", "Term", "(", "1", ",", "Factor", "(", "\"t\"", ",", "1", ")", ")", "\n", "assert", "t", "*", "1", "is", "t", "\n", "assert", "1", "*", "t", "is", "t", "\n", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "t", "*", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_merge_common_terms": [[199, 213], ["set", "gpcm.exppoly._merge_common_terms", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._merge_common_terms"], ["", "", "def", "test_merge_common_terms", "(", ")", ":", "\n", "    ", "result", "=", "set", "(", "\n", "_merge_common_terms", "(", "\n", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "\n", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", ",", "\n", "Term", "(", "3", ",", "Factor", "(", "\"t3\"", ",", "1", ")", ")", ",", "\n", "Term", "(", "4", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", ",", "\n", "Term", "(", "5", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "\n", ")", "\n", ")", "\n", "assert", "result", "==", "{", "\n", "Term", "(", "6", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "\n", "Term", "(", "6", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", ",", "\n", "Term", "(", "3", ",", "Factor", "(", "\"t3\"", ",", "1", ")", ")", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_is_function_of": [[216, 221], ["p.is_function_of", "p.is_function_of", "p.is_function_of"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_function_of"], ["", "def", "test_poly_is_function_of", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "p", "=", "t1", "**", "2", "*", "t2", "+", "1", "\n", "assert", "p", ".", "is_function_of", "(", "\"t1\"", ")", "\n", "assert", "p", ".", "is_function_of", "(", "\"t2\"", ")", "\n", "assert", "not", "p", ".", "is_function_of", "(", "\"t3\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_collect_for": [[223, 227], ["gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_poly_collect_for", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "result", "=", "(", "t1", "**", "2", "*", "t2", "*", "t3", "**", "3", "+", "2", "*", "t1", "**", "2", ")", ".", "collect_for", "(", "Factor", "(", "\"t1\"", ",", "2", ")", ")", "\n", "expected", "=", "2", "+", "t2", "*", "t3", "**", "3", "\n", "assert", "result", "==", "expected", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_reject": [[229, 231], ["None"], "function", ["None"], ["", "def", "test_poly_reject", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "(", "t1", "**", "2", "*", "t2", "*", "t3", "**", "3", "+", "2", "*", "t1", "+", "3", "*", "t2", "**", "2", ")", ".", "reject", "(", "\"t1\"", ")", "==", "3", "*", "t2", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_eval": [[233, 235], ["None"], "function", ["None"], ["", "def", "test_poly_eval", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "assert", "(", "2", "*", "t1", "**", "2", "+", "3", "*", "t2", ")", ".", "eval", "(", "t1", "=", "4", ",", "t2", "=", "5", ")", "==", "2", "*", "4", "**", "2", "+", "3", "*", "5", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_is_constant": [[237, 240], ["gpcm.exppoly.const().is_constant", "gpcm.exppoly.const", "gpcm.exppoly.const"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.is_constant", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "def", "test_poly_is_constant", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "assert", "const", "(", "1", ")", ".", "is_constant", "(", ")", "\n", "assert", "not", "(", "t1", "+", "const", "(", "1", ")", ")", ".", "is_constant", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_highest_power": [[242, 247], ["p.highest_power", "p.highest_power", "p.highest_power"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.Poly.highest_power"], ["", "def", "test_poly_highest_power", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "p", "=", "t1", "**", "2", "*", "t2", "+", "t2", "**", "3", "+", "2", "\n", "assert", "p", ".", "highest_power", "(", "\"t1\"", ")", "==", "2", "\n", "assert", "p", ".", "highest_power", "(", "\"t2\"", ")", "==", "3", "\n", "assert", "p", ".", "highest_power", "(", "\"t3\"", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_substitute": [[249, 253], ["None"], "function", ["None"], ["", "def", "test_poly_substitute", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "(", "2", "*", "t3", "**", "2", ")", ".", "substitute", "(", "\n", "\"t3\"", ",", "t1", "-", "t2", "\n", ")", "==", "2", "*", "t1", "**", "2", "-", "4", "*", "t1", "*", "t2", "+", "2", "*", "t2", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_str": [[255, 261], ["str", "str", "repr", "str", "gpcm.exppoly.Poly"], "function", ["None"], ["", "def", "test_poly_str", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "p", "=", "2", "+", "t1", "*", "t2", "\n", "assert", "str", "(", "p", ")", "in", "{", "\"2 + 1 * t1^1 t2^1\"", ",", "\"1 * t1^1 t2^1 + 2\"", "}", "\n", "assert", "str", "(", "p", ")", "==", "repr", "(", "p", ")", "\n", "\n", "assert", "str", "(", "Poly", "(", ")", ")", "==", "\"0\"", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_constructor": [[263, 267], ["gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_poly_constructor", "(", ")", ":", "\n", "    ", "assert", "Poly", "(", "\n", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", "\n", ")", "==", "Poly", "(", "Term", "(", "3", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "2", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_equality": [[269, 274], ["None"], "function", ["None"], ["", "def", "test_poly_equality", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "t1", "+", "t2", "==", "t2", "+", "t1", "\n", "assert", "t1", "+", "t2", "!=", "t1", "+", "t3", "\n", "assert", "2", "*", "(", "t1", "+", "t2", ")", "==", "2", "*", "t1", "+", "2", "*", "t2", "\n", "assert", "(", "t1", "+", "t2", ")", "**", "2", "==", "t1", "**", "2", "+", "2", "*", "t1", "*", "t2", "+", "t2", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_addition": [[276, 285], ["gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.const", "gpcm.exppoly.const", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "def", "test_poly_addition", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "Poly", "(", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ")", "+", "Poly", "(", "Term", "(", "1", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", ")", "==", "Poly", "(", "\n", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ",", "Term", "(", "1", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", "\n", ")", "\n", "assert", "t1", "+", "0", "is", "t1", "\n", "assert", "0", "+", "t1", "is", "t1", "\n", "assert", "t1", "+", "1", "==", "t1", "+", "const", "(", "1", ")", "\n", "assert", "1", "+", "t1", "==", "t1", "+", "const", "(", "1", ")", "\n", "assert", "-", "t1", "==", "Poly", "(", "Term", "(", "-", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_subtraction": [[287, 291], ["gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["None"], ["", "def", "test_poly_subtraction", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "assert", "t1", "-", "t1", "==", "Poly", "(", "Term", "(", "0", ")", ")", "\n", "assert", "1", "-", "t1", "==", "Poly", "(", "Term", "(", "1", ")", ",", "Term", "(", "-", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ")", "\n", "assert", "t1", "-", "1", "==", "Poly", "(", "Term", "(", "-", "1", ")", ",", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_multiplication": [[293, 301], ["gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Poly", "gpcm.exppoly.Term", "gpcm.exppoly.const", "gpcm.exppoly.const", "gpcm.exppoly.Term", "gpcm.exppoly.Term", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor", "gpcm.exppoly.Factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const"], ["", "def", "test_poly_multiplication", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "Poly", "(", "Term", "(", "1", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ")", ")", "*", "Poly", "(", "Term", "(", "2", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", ")", "==", "Poly", "(", "\n", "Term", "(", "2", ",", "Factor", "(", "\"t1\"", ",", "1", ")", ",", "Factor", "(", "\"t2\"", ",", "1", ")", ")", "\n", ")", "\n", "assert", "t1", "*", "1", "is", "t1", "\n", "assert", "1", "*", "t1", "is", "t1", "\n", "assert", "t1", "*", "2", "==", "t1", "*", "const", "(", "2", ")", "\n", "assert", "2", "*", "t1", "==", "t1", "*", "const", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_poly_pow": [[303, 308], ["pytest.raises"], "function", ["None"], ["", "def", "test_poly_pow", "(", "t1", ")", ":", "\n", "    ", "assert", "t1", "**", "3", "==", "t1", "*", "t1", "*", "t1", "\n", "\n", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "t1", "**", "-", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_as_poly": [[310, 313], ["gpcm.exppoly._as_poly", "gpcm.exppoly.const", "gpcm.exppoly._as_poly"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._as_poly", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.const", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly._as_poly"], ["", "", "def", "test_as_poly", "(", "t1", ")", ":", "\n", "    ", "assert", "_as_poly", "(", "2", ")", "==", "const", "(", "2", ")", "\n", "assert", "_as_poly", "(", "t1", ")", "is", "t1", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_constructor": [[315, 317], ["gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly"], "function", ["None"], ["", "def", "test_exppoly_constructor", "(", "t1", ")", ":", "\n", "    ", "assert", "ExpPoly", "(", "t1", ")", "==", "ExpPoly", "(", "1", ",", "t1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_substitute": [[319, 322], ["gpcm.exppoly.ExpPoly().substitute", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.substitute"], ["", "def", "test_exppoly_substitute", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "ExpPoly", "(", "2", ",", "-", "(", "t3", "**", "2", ")", ")", ".", "substitute", "(", "\"t3\"", ",", "t1", "-", "t2", ")", "==", "ExpPoly", "(", "\n", "2", ",", "-", "(", "t1", "**", "2", ")", "+", "2", "*", "t1", "*", "t2", "-", "t2", "**", "2", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_eval": [[325, 327], ["gpcm.exppoly.ExpPoly().eval", "numpy.exp", "gpcm.exppoly.ExpPoly"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.eval"], ["", "def", "test_exppoly_eval", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "assert", "ExpPoly", "(", "2", ",", "-", "(", "(", "t1", "-", "t2", ")", "**", "3", ")", ")", ".", "eval", "(", "t1", "=", "2", ",", "t2", "=", "4", ")", "==", "2", "*", "np", ".", "exp", "(", "-", "(", "(", "-", "2", ")", "**", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_str": [[329, 333], ["gpcm.exppoly.ExpPoly", "str", "str", "repr"], "function", ["None"], ["", "def", "test_exppoly_str", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "ep", "=", "ExpPoly", "(", "2", ",", "t1", "+", "t2", ")", "\n", "assert", "str", "(", "ep", ")", "in", "{", "\"2 * exp(1 * t1^1 + 1 * t2^1)\"", ",", "\"2 * exp(1 * t2^1 + 1 * t1^1)\"", "}", "\n", "assert", "str", "(", "ep", ")", "==", "repr", "(", "ep", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_equality": [[335, 339], ["gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly"], "function", ["None"], ["", "def", "test_exppoly_equality", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "assert", "ExpPoly", "(", "2", ",", "t1", ")", "==", "ExpPoly", "(", "2", ",", "t1", ")", "\n", "assert", "ExpPoly", "(", "2", ",", "t1", ")", "!=", "ExpPoly", "(", "2", ",", "t2", ")", "\n", "assert", "ExpPoly", "(", "1", ",", "t1", ")", "!=", "ExpPoly", "(", "2", ",", "t1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_multiplication": [[341, 346], ["gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly"], "function", ["None"], ["", "def", "test_exppoly_multiplication", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "assert", "ExpPoly", "(", "2", ",", "t1", ")", "*", "ExpPoly", "(", "3", ",", "t2", ")", "==", "ExpPoly", "(", "6", ",", "t1", "+", "t2", ")", "\n", "assert", "ExpPoly", "(", "2", ",", "t1", ")", "*", "2", "==", "ExpPoly", "(", "4", ",", "t1", ")", "\n", "assert", "2", "*", "ExpPoly", "(", "2", ",", "t1", ")", "==", "ExpPoly", "(", "4", ",", "t1", ")", "\n", "assert", "-", "ExpPoly", "(", "2", ",", "t1", ")", "==", "ExpPoly", "(", "-", "2", ",", "t1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_integrate_quadratic_coefficient_check": [[348, 351], ["pytest.raises", "gpcm.exppoly.ExpPoly().integrate", "gpcm.exppoly.ExpPoly"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate"], ["", "def", "test_exppoly_integrate_quadratic_coefficient_check", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t2", "*", "t1", "**", "2", ")", ".", "integrate", "(", "\"t1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_integrate_quadratic_dependency_check": [[353, 372], ["pytest.raises", "gpcm.exppoly.ExpPoly()._integrate", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate_half1", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate_half1", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate_half2", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate_half2", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate_half2", "pytest.raises", "gpcm.exppoly.ExpPoly()._integrate_half2", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly", "gpcm.exppoly.ExpPoly"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half1", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half1", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half2", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half2", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half2", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly._integrate_half2"], ["", "", "def", "test_exppoly_integrate_quadratic_dependency_check", "(", "t1", ",", "t2", ")", ":", "\n", "    ", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", ")", ".", "_integrate", "(", "\"t1\"", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", "**", "3", ")", ".", "_integrate", "(", "\"t1\"", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", ")", ".", "_integrate_half1", "(", "\"t1\"", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", "**", "3", ")", ".", "_integrate_half1", "(", "\"t1\"", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", "+", "t2", "**", "2", ")", ".", "_integrate_half2", "(", "\"t1\"", ",", "\"t2\"", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", "**", "3", "+", "t2", "**", "2", ")", ".", "_integrate_half2", "(", "\"t1\"", ",", "\"t2\"", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", "**", "2", "+", "t2", ")", ".", "_integrate_half2", "(", "\"t1\"", ",", "\"t2\"", ")", "\n", "", "with", "pytest", ".", "raises", "(", "RuntimeError", ")", ":", "\n", "        ", "ExpPoly", "(", "t1", "**", "2", "+", "t2", "**", "3", ")", ".", "_integrate_half2", "(", "\"t1\"", ",", "\"t2\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.ep1": [[374, 377], ["pytest.fixture", "gpcm.exppoly.ExpPoly"], "function", ["None"], ["", "", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "ep1", "(", "t1", ")", ":", "\n", "    ", "return", "ExpPoly", "(", "4", "-", "t1", "**", "2", "-", "0.5", "*", "t1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.ep2": [[379, 382], ["pytest.fixture", "gpcm.exppoly.ExpPoly"], "function", ["None"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "ep2", "(", "t1", ",", "t2", ",", "t3", ")", ":", "\n", "    ", "return", "ExpPoly", "(", "4", "-", "t1", "**", "2", "-", "2", "*", "t2", "**", "2", "-", "0.5", "*", "t1", "*", "t2", "-", "2", "*", "t1", "*", "t3", "+", "3", "*", "t2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_case1": [[384, 388], ["ep1.integrate", "util.approx"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "def", "test_exppoly_case1", "(", "ep1", ")", ":", "\n", "    ", "ref", "=", "103.0140042", "\n", "res", "=", "ep1", ".", "integrate", "(", "\"t1\"", ")", "\n", "approx", "(", "res", ",", "ref", ",", "atol", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_case2": [[390, 394], ["ep1.integrate_half", "util.approx"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_half", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "def", "test_exppoly_case2", "(", "ep1", ")", ":", "\n", "    ", "ref", "=", "65.73974603", "\n", "res", "=", "ep1", ".", "integrate_half", "(", "\"t1\"", ")", "\n", "approx", "(", "res", ",", "ref", ",", "atol", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_case3": [[396, 402], ["numpy.array", "ep2.integrate_box", "util.approx", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "def", "test_exppoly_case3", "(", "ep2", ")", ":", "\n", "    ", "ref", "=", "np", ".", "array", "(", "[", "[", "1627.297351", ",", "393.5943995", "]", ",", "[", "393.5943995", ",", "1627.297351", "]", "]", ")", "\n", "res", "=", "ep2", ".", "integrate_box", "(", "\n", "(", "\"t1\"", ",", "-", "np", ".", "inf", ",", "np", ".", "inf", ")", ",", "(", "\"t2\"", ",", "-", "np", ".", "inf", ",", "np", ".", "inf", ")", ",", "t3", "=", "np", ".", "eye", "(", "2", ")", "\n", ")", "\n", "approx", "(", "res", ",", "ref", ",", "atol", "=", "1e-4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_case4": [[404, 408], ["numpy.array", "ep2.integrate_box", "util.approx", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "def", "test_exppoly_case4", "(", "ep2", ")", ":", "\n", "    ", "ref", "=", "np", ".", "array", "(", "[", "[", "55.81808295", ",", "11.76773162", "]", ",", "[", "11.76773162", ",", "55.81808295", "]", "]", ")", "\n", "res", "=", "ep2", ".", "integrate_box", "(", "(", "\"t1\"", ",", "-", "np", ".", "inf", ",", "0", ")", ",", "(", "\"t2\"", ",", "-", "np", ".", "inf", ",", "0", ")", ",", "t3", "=", "np", ".", "eye", "(", "2", ")", ")", "\n", "approx", "(", "res", ",", "ref", ",", "atol", "=", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_exppoly.test_exppoly_case5": [[410, 414], ["numpy.array", "ep2.integrate_box", "util.approx", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.exppoly.ExpPoly.integrate_box", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "def", "test_exppoly_case5", "(", "ep2", ",", "t3", ")", ":", "\n", "    ", "ref", "=", "np", ".", "array", "(", "[", "[", "217.3921457", ",", "318.3540954", "]", ",", "[", "318.3540954", ",", "217.3921457", "]", "]", ")", "\n", "res", "=", "ep2", ".", "integrate_box", "(", "(", "\"t1\"", ",", "-", "1", ",", "2", ")", ",", "(", "\"t2\"", ",", "t3", ",", "3", ")", ",", "t3", "=", "np", ".", "eye", "(", "2", ")", ")", "\n", "approx", "(", "res", ",", "ref", ",", "atol", "=", "1e-5", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_gpcm.test_scale_factor_conversion": [[6, 9], ["util.approx", "util.approx", "gpcm.scale_to_factor", "gpcm.factor_to_scale", "gpcm.factor_to_scale", "gpcm.scale_to_factor"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.scale_to_factor", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.factor_to_scale", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.factor_to_scale", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.scale_to_factor"], ["def", "test_scale_factor_conversion", "(", ")", ":", "\n", "    ", "approx", "(", "gpcm", ".", "scale_to_factor", "(", "gpcm", ".", "factor_to_scale", "(", "1", ")", ")", ",", "1", ")", "\n", "approx", "(", "gpcm", ".", "factor_to_scale", "(", "gpcm", ".", "scale_to_factor", "(", "1", ")", ")", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_normal.test_natural_normal": [[8, 35], ["lab.randn", "stheno.Normal", "gpcm.normal.NaturalNormal.from_normal", "lab.create_random_state", "NaturalNormal.from_normal.sample", "lab.mean", "util.approx", "util.approx", "lab.randn", "stheno.Normal", "gpcm.normal.NaturalNormal.from_normal", "util.approx", "lab.randn", "util.approx", "lab.randn", "lab.reg", "util.approx", "lab.dense", "lab.randn", "lab.reg", "stheno.Normal.kl", "NaturalNormal.from_normal.kl", "stheno.Normal.logpdf", "NaturalNormal.from_normal.logpdf", "getattr", "getattr"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.from_normal", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.from_normal", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.kl", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.kl", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.logpdf", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.logpdf"], ["def", "test_natural_normal", "(", ")", ":", "\n", "    ", "chol", "=", "B", ".", "randn", "(", "2", ",", "2", ")", "\n", "dist", "=", "Normal", "(", "B", ".", "randn", "(", "2", ",", "1", ")", ",", "B", ".", "reg", "(", "chol", "@", "chol", ".", "T", ",", "diag", "=", "1e-1", ")", ")", "\n", "nat", "=", "NaturalNormal", ".", "from_normal", "(", "dist", ")", "\n", "\n", "# Test properties.", "\n", "assert", "dist", ".", "dtype", "==", "nat", ".", "dtype", "\n", "for", "name", "in", "[", "\"dim\"", ",", "\"mean\"", ",", "\"var\"", ",", "\"m2\"", "]", ":", "\n", "        ", "approx", "(", "getattr", "(", "dist", ",", "name", ")", ",", "getattr", "(", "nat", ",", "name", ")", ")", "\n", "\n", "# Test sampling.", "\n", "", "state", "=", "B", ".", "create_random_state", "(", "dist", ".", "dtype", ",", "seed", "=", "0", ")", "\n", "state", ",", "sample", "=", "nat", ".", "sample", "(", "state", ",", "num", "=", "1_000_000", ")", "\n", "emp_mean", "=", "B", ".", "mean", "(", "B", ".", "dense", "(", "sample", ")", ",", "axis", "=", "1", ",", "squeeze", "=", "False", ")", "\n", "emp_var", "=", "(", "sample", "-", "emp_mean", ")", "@", "(", "sample", "-", "emp_mean", ")", ".", "T", "/", "1_000_000", "\n", "approx", "(", "dist", ".", "mean", ",", "emp_mean", ",", "rtol", "=", "5e-2", ")", "\n", "approx", "(", "dist", ".", "var", ",", "emp_var", ",", "rtol", "=", "5e-2", ")", "\n", "\n", "# Test KL.", "\n", "chol", "=", "B", ".", "randn", "(", "2", ",", "2", ")", "\n", "other_dist", "=", "Normal", "(", "B", ".", "randn", "(", "2", ",", "1", ")", ",", "B", ".", "reg", "(", "chol", "@", "chol", ".", "T", ",", "diag", "=", "1e-2", ")", ")", "\n", "other_nat", "=", "NaturalNormal", ".", "from_normal", "(", "other_dist", ")", "\n", "approx", "(", "dist", ".", "kl", "(", "other_dist", ")", ",", "nat", ".", "kl", "(", "other_nat", ")", ")", "\n", "\n", "# Test log-pdf.", "\n", "x", "=", "B", ".", "randn", "(", "2", ",", "1", ")", "\n", "approx", "(", "dist", ".", "logpdf", "(", "x", ")", ",", "nat", ".", "logpdf", "(", "x", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_model.test_prior_power": [[9, 23], ["pytest.mark.parametrize", "lab.zeros", "Model", "Model.compute_K_u", "range", "numpy.mean", "util.approx", "powers.append", "lab.sample", "Model.kernel_approx"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.model.AbstractGPCM.kernel_approx"], ["@", "pytest", ".", "mark", ".", "parametrize", "(", "\"Model\"", ",", "[", "GPCM", ",", "CGPCM", ",", "RGPCM", "]", ")", "\n", "def", "test_prior_power", "(", "Model", ")", ":", "\n", "    ", "t_u", "=", "B", ".", "zeros", "(", "1", ")", "\n", "model", "=", "Model", "(", "window", "=", "2", ",", "scale", "=", "1", ",", "n_u", "=", "10", ",", "t", "=", "(", "0", ",", "10", ")", ")", "\n", "K_u", "=", "model", ".", "compute_K_u", "(", ")", "\n", "\n", "# Estimate power with Monte Carlo.", "\n", "powers", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "2_000", ")", ":", "\n", "        ", "u", "=", "B", ".", "sample", "(", "K_u", ")", "[", ":", ",", "0", "]", "\n", "powers", ".", "append", "(", "model", ".", "kernel_approx", "(", "t_u", ",", "t_u", ",", "u", ")", "[", "0", ",", "0", "]", ")", "\n", "", "power", "=", "np", ".", "mean", "(", "powers", ")", "\n", "\n", "approx", "(", "power", ",", "1", ",", "atol", "=", "5e-2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_model.test_inducing_points_extent_gpcm": [[25, 29], ["pytest.mark.parametrize", "Model", "util.approx", "lab.exp", "lab.exp", "max"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "@", "pytest", ".", "mark", ".", "parametrize", "(", "\"Model\"", ",", "[", "GPCM", ",", "CGPCM", "]", ")", "\n", "def", "test_inducing_points_extent_gpcm", "(", "Model", ")", ":", "\n", "    ", "model", "=", "Model", "(", "window", "=", "2", ",", "scale", "=", "1", ",", "n_u", "=", "10", ",", "t", "=", "(", "0", ",", "10", ")", ")", "\n", "approx", "(", "B", ".", "exp", "(", "-", "model", ".", "alpha", "*", "max", "(", "model", ".", "t_u", ")", "**", "2", ")", ",", "B", ".", "exp", "(", "-", "B", ".", "pi", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_model.test_inducing_points_extent_gprv": [[31, 35], ["gpcm.RGPCM", "max", "util.approx", "lab.exp", "lab.exp"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "def", "test_inducing_points_extent_gprv", "(", ")", ":", "\n", "    ", "model", "=", "RGPCM", "(", "window", "=", "2", ",", "scale", "=", "1", ",", "n_u", "=", "10", ",", "t", "=", "(", "0", ",", "10", ")", ")", "\n", "t_u_max", "=", "max", "(", "model", ".", "t_u", ")", "\n", "approx", "(", "B", ".", "exp", "(", "-", "model", ".", "alpha", "*", "t_u_max", ")", ",", "B", ".", "exp", "(", "-", "B", ".", "pi", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.t": [[12, 15], ["pytest.fixture", "lab.linspace"], "function", ["None"], ["@", "pytest", ".", "fixture", "(", ")", "\n", "def", "t", "(", ")", ":", "\n", "    ", "return", "B", ".", "linspace", "(", "0", ",", "2", ",", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model": [[17, 20], ["pytest.fixture", "gpcm.RGPCM", "test_rgpcm.t", "test_rgpcm.t", "test_rgpcm.t", "test_rgpcm.t"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.t", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.t", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.t", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.t"], ["", "@", "pytest", ".", "fixture", "(", ")", "\n", "def", "model", "(", "t", ")", ":", "\n", "    ", "return", "rgpcm", ".", "RGPCM", "(", "window", "=", "0.5", ",", "scale", "=", "0.2", ",", "t", "=", "t", ",", "n_u", "=", "3", ",", "m_max", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.signed_pairs": [[22, 24], ["numpy.abs", "range", "numpy.random.randn", "numpy.abs", "numpy.random.randn"], "function", ["None"], ["", "def", "signed_pairs", "(", "num", ")", ":", "\n", "    ", "return", "[", "(", "np", ".", "abs", "(", "np", ".", "random", ".", "randn", "(", ")", ")", ",", "-", "np", ".", "abs", "(", "np", ".", "random", ".", "randn", "(", ")", ")", ")", "for", "_", "in", "range", "(", "num", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_K_u": [[26, 29], ["util.assert_positive_definite", "util.approx", "model.compute_K_u", "gpcm.compute_K_u"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.assert_positive_definite", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_u"], ["", "def", "test_K_u", "(", "model", ")", ":", "\n", "    ", "assert_positive_definite", "(", "model", ".", "compute_K_u", "(", ")", ")", "\n", "approx", "(", "rgpcm", ".", "compute_K_u", "(", "model", ")", "[", "0", ",", "0", "]", ",", "1", ")", "# Test default of `gamma_t`.", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_K_z": [[31, 33], ["util.assert_positive_definite", "model.compute_K_z"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.assert_positive_definite", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_K_z"], ["", "def", "test_K_z", "(", "model", ")", ":", "\n", "    ", "assert_positive_definite", "(", "model", ".", "compute_K_z", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_i_hx": [[35, 38], ["util.assert_positive_definite", "util.approx", "model.compute_i_hx", "model.compute_i_hx"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.assert_positive_definite", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_i_hx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_i_hx"], ["", "def", "test_i_hx", "(", "model", ",", "t", ")", ":", "\n", "    ", "assert_positive_definite", "(", "model", ".", "compute_i_hx", "(", "t", "[", ":", ",", "None", "]", ",", "t", "[", "None", ",", ":", "]", ")", ")", "\n", "approx", "(", "model", ".", "compute_i_hx", "(", "1", ",", "1", ")", ",", "1", ")", "# Test default for `alpha_t`.", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_integral_abcd": [[40, 53], ["itertools.product", "util.approx", "scipy.integrate.dblquad", "test_rgpcm.signed_pairs", "gpcm.integral_abcd", "test_rgpcm.test_integral_abcd.integral_quadrature"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.signed_pairs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd"], ["", "def", "test_integral_abcd", "(", ")", ":", "\n", "    ", "def", "integral_quadrature", "(", "a", ",", "b", ",", "c", ",", "d", ")", ":", "\n", "        ", "return", "dblquad", "(", "\n", "lambda", "tau", ",", "tau2", ":", "np", ".", "exp", "(", "c", "*", "(", "tau", "+", "tau2", ")", "-", "d", "*", "np", ".", "abs", "(", "tau", "-", "tau2", ")", ")", ",", "\n", "0", ",", "\n", "a", ",", "\n", "lambda", "tau", ":", "0", ",", "\n", "lambda", "tau", ":", "b", ",", "\n", ")", "[", "0", "]", "\n", "\n", "", "for", "a", ",", "b", ",", "c", ",", "d", "in", "product", "(", "*", "signed_pairs", "(", "4", ")", ")", ":", "\n", "        ", "approx", "(", "\n", "rgpcm", ".", "integral_abcd", "(", "a", ",", "b", ",", "c", ",", "d", ")", ",", "integral_quadrature", "(", "a", ",", "b", ",", "c", ",", "d", ")", ",", "atol", "=", "1e-5", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_integral_abcd_lu": [[56, 71], ["itertools.product", "util.approx", "scipy.integrate.dblquad", "test_rgpcm.signed_pairs", "gpcm.integral_abcd_lu", "test_rgpcm.test_integral_abcd.integral_quadrature"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.signed_pairs", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.rgpcm.integral_abcd_lu"], ["", "", "def", "test_integral_abcd_lu", "(", ")", ":", "\n", "    ", "def", "integral_quadrature", "(", "a_lb", ",", "a_ub", ",", "b_lb", ",", "b_ub", ",", "c", ",", "d", ")", ":", "\n", "        ", "return", "dblquad", "(", "\n", "lambda", "tau", ",", "tau2", ":", "np", ".", "exp", "(", "c", "*", "(", "tau", "+", "tau2", ")", "-", "d", "*", "np", ".", "abs", "(", "tau", "-", "tau2", ")", ")", ",", "\n", "a_lb", ",", "\n", "a_ub", ",", "\n", "lambda", "tau", ":", "b_lb", ",", "\n", "lambda", "tau", ":", "b_ub", ",", "\n", ")", "[", "0", "]", "\n", "\n", "", "for", "a_lb", ",", "a_ub", ",", "b_lb", ",", "b_ub", ",", "c", ",", "d", "in", "product", "(", "*", "signed_pairs", "(", "6", ")", ")", ":", "\n", "        ", "approx", "(", "\n", "rgpcm", ".", "integral_abcd_lu", "(", "a_lb", ",", "a_ub", ",", "b_lb", ",", "b_ub", ",", "c", ",", "d", ")", ",", "\n", "integral_quadrature", "(", "a_lb", ",", "a_ub", ",", "b_lb", ",", "b_ub", ",", "c", ",", "d", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_I_ux": [[74, 100], ["model.compute_I_ux", "range", "len", "range", "scipy.integrate.dblquad", "len", "range", "lab.exp", "len", "range", "len", "util.approx", "test_rgpcm.test_integral_abcd.integral_quadrature"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_ux", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "", "def", "test_I_ux", "(", "model", ",", "t", ")", ":", "\n", "    ", "def", "integral_quadrature", "(", "t1", ",", "t2", ",", "t_u_1", ",", "t_u_2", ")", ":", "\n", "        ", "def", "integral", "(", "tau1", ",", "tau2", ")", ":", "\n", "            ", "return", "(", "\n", "model", ".", "alpha_t", "**", "2", "\n", "*", "model", ".", "gamma_t", "**", "2", "\n", "*", "B", ".", "exp", "(", "\n", "-", "model", ".", "alpha", "*", "(", "tau1", "+", "tau2", ")", "\n", "+", "-", "model", ".", "gamma", "*", "(", "t_u_1", "-", "tau1", ")", "\n", "+", "-", "model", ".", "gamma", "*", "(", "t_u_2", "-", "tau2", ")", "\n", "+", "-", "model", ".", "lam", "*", "B", ".", "abs", "(", "(", "t1", "-", "tau1", ")", "-", "(", "t2", "-", "tau2", ")", ")", "\n", ")", "\n", ")", "\n", "\n", "", "return", "dblquad", "(", "integral", ",", "0", ",", "t_u_1", ",", "lambda", "tau", ":", "0", ",", "lambda", "tau", ":", "t_u_2", ")", "[", "0", "]", "\n", "\n", "", "I_ux", "=", "model", ".", "compute_I_ux", "(", "t", ",", "t", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "t", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "t", ")", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "len", "(", "model", ".", "t_u", ")", ")", ":", "\n", "                ", "for", "l", "in", "range", "(", "len", "(", "model", ".", "t_u", ")", ")", ":", "\n", "                    ", "approx", "(", "\n", "integral_quadrature", "(", "t", "[", "i", "]", ",", "t", "[", "j", "]", ",", "model", ".", "t_u", "[", "k", "]", ",", "model", ".", "t_u", "[", "l", "]", ")", ",", "\n", "I_ux", "[", "i", ",", "j", ",", "k", ",", "l", "]", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.beta": [[103, 123], ["lab.cos", "lab.sin", "lab.exp", "lab.exp", "test_rgpcm.model", "test_rgpcm.model", "test_rgpcm.model"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.model"], ["", "", "", "", "", "def", "beta", "(", "model", ",", "m", ",", "tau", ")", ":", "\n", "    ", "a", "=", "model", ".", "a", "\n", "b", "=", "model", ".", "b", "\n", "m_max", "=", "model", ".", "m_max", "\n", "\n", "if", "a", "<", "tau", "<", "b", ":", "\n", "        ", "if", "m", "<=", "m_max", ":", "\n", "            ", "return", "B", ".", "cos", "(", "2", "*", "B", ".", "pi", "*", "m", "/", "(", "b", "-", "a", ")", "*", "(", "tau", "-", "a", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "B", ".", "sin", "(", "2", "*", "B", ".", "pi", "*", "(", "m", "-", "m_max", ")", "/", "(", "b", "-", "a", ")", "*", "(", "tau", "-", "a", ")", ")", "\n", "", "", "elif", "tau", "<=", "a", ":", "\n", "        ", "if", "m", "<=", "m_max", ":", "\n", "            ", "return", "B", ".", "exp", "(", "-", "model", ".", "lam", "*", "(", "a", "-", "tau", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "0", "\n", "", "", "else", ":", "\n", "        ", "if", "m", "<=", "m_max", ":", "\n", "            ", "return", "B", ".", "exp", "(", "-", "model", ".", "lam", "*", "(", "tau", "-", "b", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_I_hz": [[125, 146], ["model.compute_I_hz", "range", "len", "range", "scipy.integrate.quad", "len", "range", "test_rgpcm.beta", "len", "util.approx", "test_rgpcm.beta", "test_rgpcm.test_integral_abcd.integral_quadrature"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_hz", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.beta", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.beta"], ["", "", "", "def", "test_I_hz", "(", "model", ",", "t", ")", ":", "\n", "    ", "def", "integral_quadrature", "(", "t", ",", "m", ",", "n", ")", ":", "\n", "        ", "def", "integral", "(", "tau", ")", ":", "\n", "            ", "return", "(", "\n", "model", ".", "alpha_t", "**", "2", "\n", "*", "B", ".", "exp", "(", "-", "2", "*", "model", ".", "alpha", "*", "B", ".", "abs", "(", "t", "-", "tau", ")", ")", "\n", "*", "beta", "(", "model", ",", "m", ",", "tau", ")", "\n", "*", "beta", "(", "model", ",", "n", ",", "tau", ")", "\n", ")", "\n", "\n", "", "return", "quad", "(", "integral", ",", "-", "np", ".", "inf", ",", "t", ")", "[", "0", "]", "\n", "\n", "", "I_hz", "=", "model", ".", "compute_I_hz", "(", "t", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "t", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "model", ".", "ms", ")", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "len", "(", "model", ".", "ms", ")", ")", ":", "\n", "                ", "approx", "(", "\n", "I_hz", "[", "i", ",", "j", ",", "k", "]", ",", "\n", "integral_quadrature", "(", "t", "[", "i", "]", ",", "model", ".", "ms", "[", "j", "]", ",", "model", ".", "ms", "[", "k", "]", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.test_I_uz": [[149, 170], ["model.compute_I_uz", "range", "len", "range", "scipy.integrate.quad", "len", "range", "test_rgpcm.beta", "len", "util.approx", "lab.exp", "test_rgpcm.test_integral_abcd.integral_quadrature"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.gpcm.compute_I_uz", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_rgpcm.beta", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx"], ["", "", "", "", "def", "test_I_uz", "(", "model", ",", "t", ")", ":", "\n", "    ", "def", "integral_quadrature", "(", "t", ",", "t_u", ",", "m", ")", ":", "\n", "        ", "def", "integral", "(", "tau", ")", ":", "\n", "            ", "return", "(", "\n", "model", ".", "alpha_t", "\n", "*", "model", ".", "gamma_t", "\n", "*", "B", ".", "exp", "(", "-", "model", ".", "alpha", "*", "B", ".", "abs", "(", "tau", ")", "+", "-", "model", ".", "gamma", "*", "B", ".", "abs", "(", "t_u", "-", "tau", ")", ")", "\n", "*", "beta", "(", "model", ",", "m", ",", "t", "-", "tau", ")", "\n", ")", "\n", "\n", "", "return", "quad", "(", "integral", ",", "0", ",", "t_u", ")", "[", "0", "]", "\n", "\n", "", "I_uz", "=", "model", ".", "compute_I_uz", "(", "t", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "t", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "model", ".", "t_u", ")", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "len", "(", "model", ".", "ms", ")", ")", ":", "\n", "                ", "approx", "(", "\n", "I_uz", "[", "i", ",", "j", ",", "k", "]", ",", "\n", "integral_quadrature", "(", "t", "[", "i", "]", ",", "model", ".", "t_u", "[", "j", "]", ",", "model", ".", "ms", "[", "k", "]", ")", ",", "\n", "atol", "=", "1e-5", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx": [[8, 19], ["numpy.testing.assert_allclose", "lab.dense", "lab.dense"], "function", ["None"], ["from", "stheno", "import", "Normal", "\n", "from", "scipy", ".", "signal", "import", "hilbert", "\n", "\n", "__all__", "=", "[", "\n", "\"min_phase\"", ",", "\n", "\"summarise_samples\"", ",", "\n", "\"estimate_psd\"", ",", "\n", "\"invert_perm\"", ",", "\n", "\"closest_psd\"", ",", "\n", "\"collect\"", ",", "\n", "\"autocorr\"", ",", "\n", "\"method\"", ",", "\n"]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.assert_positive_definite": [[21, 30], ["numpy.linalg.cholesky", "lab.to_numpy"], "function", ["None"], ["\"maximum_a_posteriori\"", ",", "\n", "\"laplace_approximation\"", ",", "\n", "]", "\n", "\n", "_dispatch", "=", "Dispatcher", "(", ")", "\n", "\n", "\n", "def", "min_phase", "(", "h", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.wesselb_gpcm.tests.test_sample.test_ess": [[9, 36], ["stheno.Normal", "stheno.Normal", "gpcm.sample.ESS", "lab.concat", "lab.inv", "lab.inv", "lab.inv", "util.approx", "util.approx", "numpy.array", "numpy.array", "numpy.array", "lab.mean", "lab.matmul", "gpcm.sample.ESS.sample"], "function", ["home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.tests.util.approx", "home.repos.pwc.inspect_result.wesselb_gpcm.gpcm.normal.NaturalNormal.mean", "home.repos.pwc.inspect_result.wesselb_gpcm.paper.sample_interpolation.sample"], ["def", "test_ess", "(", ")", ":", "\n", "# Construct a prior and a likelihood.", "\n", "    ", "prior", "=", "Normal", "(", "np", ".", "array", "(", "[", "[", "0.6", ",", "0.3", "]", ",", "[", "0.3", ",", "0.6", "]", "]", ")", ")", "\n", "lik", "=", "Normal", "(", "\n", "np", ".", "array", "(", "[", "[", "0.2", "]", ",", "[", "0.3", "]", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "1", ",", "0.2", "]", ",", "[", "0.2", ",", "1", "]", "]", ")", ",", "\n", ")", "\n", "\n", "# Perform sampling.", "\n", "sampler", "=", "ESS", "(", "lik", ".", "logpdf", ",", "prior", ".", "sample", ")", "\n", "num_samples", "=", "30_000", "\n", "samples", "=", "B", ".", "concat", "(", "*", "sampler", ".", "sample", "(", "num", "=", "num_samples", ")", ",", "axis", "=", "1", ")", "\n", "\n", "samples_mean", "=", "B", ".", "mean", "(", "samples", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", "\n", "samples_cov", "=", "(", "\n", "B", ".", "matmul", "(", "samples", "-", "samples_mean", ",", "samples", "-", "samples_mean", ",", "tr_b", "=", "True", ")", "\n", "/", "num_samples", "\n", ")", "\n", "\n", "# Compute posterior statistics.", "\n", "prec_prior", "=", "B", ".", "inv", "(", "prior", ".", "var", ")", "\n", "prec_lik", "=", "B", ".", "inv", "(", "lik", ".", "var", ")", "\n", "cov", "=", "B", ".", "inv", "(", "prec_prior", "+", "prec_lik", ")", "\n", "mean", "=", "cov", "@", "(", "prec_prior", "@", "prior", ".", "mean", "+", "prec_lik", "@", "lik", ".", "mean", ")", "\n", "\n", "approx", "(", "samples_cov", ",", "cov", ",", "atol", "=", "5e-2", ")", "\n", "approx", "(", "samples_mean", ",", "mean", ",", "atol", "=", "5e-2", ")", "\n", "", ""]]}