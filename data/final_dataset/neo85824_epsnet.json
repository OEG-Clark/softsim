{"home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.CustomDataParallel.gather": [[633, 636], ["sum"], "methods", ["None"], ["def", "gather", "(", "self", ",", "outputs", ",", "output_device", ")", ":", "\n", "# Note that I don't actually want to convert everything to the output_device", "\n", "        ", "return", "sum", "(", "outputs", ",", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.str2bool": [[41, 48], ["v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "if", "v", ".", "lower", "(", ")", "in", "(", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.parse_args": [[49, 148], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.set_defaults", "argparse.ArgumentParser.parse_args", "random.seed"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.parse_args"], ["", "", "def", "parse_args", "(", "argv", "=", "None", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'EPSNet COCO Evaluation'", ")", "\n", "parser", ".", "add_argument", "(", "'--trained_model'", ",", "\n", "default", "=", "'weights/ssd300_mAP_77.43_v2.pth'", ",", "type", "=", "str", ",", "\n", "help", "=", "'Trained state_dict file path to open. If \"interrupt\", this will open the interrupt file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--top_k'", ",", "default", "=", "5", ",", "type", "=", "int", ",", "\n", "help", "=", "'Further restrict the number of predictions to parse'", ")", "\n", "parser", ".", "add_argument", "(", "'--cuda'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Use cuda to evaulate model'", ")", "\n", "parser", ".", "add_argument", "(", "'--fast_nms'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether to use a faster, but not entirely correct version of NMS.'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_masks'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display masks over bounding boxes'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_bboxes'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display bboxes around masks'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_text'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display text (class [score])'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_instance'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display instance'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_stuff'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display stuff segm'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_scores'", ",", "default", "=", "True", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether or not to display scores in addition to classes'", ")", "\n", "parser", ".", "add_argument", "(", "'--display'", ",", "dest", "=", "'display'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Display qualitative results instead of quantitative ones.'", ")", "\n", "parser", ".", "add_argument", "(", "'--shuffle'", ",", "dest", "=", "'shuffle'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Shuffles the images when displaying them. Doesn\\'t have much of an effect when display is off though.'", ")", "\n", "parser", ".", "add_argument", "(", "'--ap_data_file'", ",", "default", "=", "'results/ap_data.pkl'", ",", "type", "=", "str", ",", "\n", "help", "=", "'In quantitative mode, the file to save detections before calculating mAP.'", ")", "\n", "parser", ".", "add_argument", "(", "'--resume'", ",", "dest", "=", "'resume'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If display not set, this resumes mAP calculations from the ap_data_file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_images'", ",", "default", "=", "-", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "'The maximum number of images from the dataset to consider. Use -1 for all.'", ")", "\n", "parser", ".", "add_argument", "(", "'--output_coco_json'", ",", "dest", "=", "'output_coco_json'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If display is not set, instead of processing IoU values, this just dumps detections into the coco json file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--bbox_det_file'", ",", "default", "=", "'results/bbox_detections.json'", ",", "type", "=", "str", ",", "\n", "help", "=", "'The output file for coco bbox results if --coco_results is set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--mask_det_file'", ",", "default", "=", "'results/mask_detections.json'", ",", "type", "=", "str", ",", "\n", "help", "=", "'The output file for coco mask results if --coco_results is set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--stuff_det_file'", ",", "default", "=", "'results/stuff_detections.json'", ",", "type", "=", "str", ",", "\n", "help", "=", "'The output file for coco stuff results if --coco_results is set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--panoptic_det_file'", ",", "default", "=", "'results/panoptic_detections.json'", ",", "type", "=", "str", ",", "\n", "help", "=", "'The output file for coco panoptic results if --coco_results is set.'", ")", "\n", "parser", ".", "add_argument", "(", "'--config'", ",", "default", "=", "None", ",", "\n", "help", "=", "'The config object to use.'", ")", "\n", "parser", ".", "add_argument", "(", "'--output_web_json'", ",", "dest", "=", "'output_web_json'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'If display is not set, instead of processing IoU values, this dumps detections for usage with the detections viewer web thingy.'", ")", "\n", "parser", ".", "add_argument", "(", "'--web_det_path'", ",", "default", "=", "'web/dets/'", ",", "type", "=", "str", ",", "\n", "help", "=", "'If output_web_json is set, this is the path to dump detections into.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_bar'", ",", "dest", "=", "'no_bar'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not output the status bar. This is useful for when piping to a file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--display_lincomb'", ",", "default", "=", "False", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'If the config uses lincomb masks, output a visualization of how those masks are created.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_sort'", ",", "default", "=", "False", ",", "dest", "=", "'no_sort'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Do not sort images by hashed image ID.'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "default", "=", "None", ",", "type", "=", "int", ",", "\n", "help", "=", "'The seed to pass into random.seed. Note: this is only really for the shuffle and does not (I think) affect cuda stuff.'", ")", "\n", "parser", ".", "add_argument", "(", "'--mask_proto_debug'", ",", "default", "=", "False", ",", "dest", "=", "'mask_proto_debug'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Outputs stuff for scripts/compute_mask.py.'", ")", "\n", "parser", ".", "add_argument", "(", "'--no_crop'", ",", "default", "=", "False", ",", "dest", "=", "'crop'", ",", "action", "=", "'store_false'", ",", "\n", "help", "=", "'Do not crop output masks with the predicted bounding box.'", ")", "\n", "parser", ".", "add_argument", "(", "'--image'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'A path to an image to use for display.'", ")", "\n", "parser", ".", "add_argument", "(", "'--images'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'An input folder of images and output folder to save detected images. Should be in the format input->output.'", ")", "\n", "parser", ".", "add_argument", "(", "'--video'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'A path to a video to evaluate on. Passing in a number will use that index webcam.'", ")", "\n", "parser", ".", "add_argument", "(", "'--video_multiframe'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "\n", "help", "=", "'The number of frames to evaluate in parallel to make videos play at higher fps.'", ")", "\n", "parser", ".", "add_argument", "(", "'--score_threshold'", ",", "default", "=", "0", ",", "type", "=", "float", ",", "\n", "help", "=", "'Detections with a score under this threshold will not be considered. This currently only works in display mode.'", ")", "\n", "parser", ".", "add_argument", "(", "'--overlap_threshold'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "\n", "help", "=", "'overlap threshold for generating panoptic result'", ")", "\n", "parser", ".", "add_argument", "(", "'--stuff_area_limit'", ",", "default", "=", "64", "*", "64", ",", "type", "=", "float", ",", "\n", "help", "=", "'stuff segm area under this limit will be ignored'", ")", "\n", "parser", ".", "add_argument", "(", "'--multiscale_test'", ",", "default", "=", "False", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Multi-scale testing'", ")", "\n", "parser", ".", "add_argument", "(", "'--flip_test'", ",", "default", "=", "False", ",", "type", "=", "str2bool", ",", "\n", "help", "=", "'Horizontal flipping testing'", ")", "\n", "parser", ".", "add_argument", "(", "'--alpha'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "\n", "help", "=", "'The opacity value of displaying the panoptic segmentation and image'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--dataset'", ",", "default", "=", "None", ",", "type", "=", "str", ",", "\n", "help", "=", "'If specified, override the dataset specified in the config with this one (example: coco2017_dataset).'", ")", "\n", "parser", ".", "add_argument", "(", "'--detect'", ",", "default", "=", "False", ",", "dest", "=", "'detect'", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'Don\\'t evauluate the mask branch at all and only do object detection. This only works for --display'", ")", "\n", "\n", "parser", ".", "set_defaults", "(", "no_bar", "=", "False", ",", "display", "=", "False", ",", "resume", "=", "False", ",", "output_coco_json", "=", "False", ",", "output_web_json", "=", "False", ",", "shuffle", "=", "False", ",", "\n", "no_sort", "=", "False", ",", "no_hash", "=", "False", ",", "mask_proto_debug", "=", "False", ",", "crop", "=", "True", ",", "detect", "=", "False", ")", "\n", "\n", "global", "args", "\n", "args", "=", "parser", ".", "parse_args", "(", "argv", ")", "\n", "\n", "if", "args", ".", "output_web_json", ":", "\n", "        ", "args", ".", "output_coco_json", "=", "True", "\n", "\n", "", "if", "args", ".", "seed", "is", "not", "None", ":", "\n", "        ", "random", ".", "seed", "(", "args", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff": [[157, 180], ["proto_out.size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.interpolate().squeeze", "torch.log_softmax", "torch.interpolate", "F.log_softmax.unsqueeze"], "function", ["None"], ["def", "postprocess_stuff", "(", "dets_out", ",", "h", ",", "w", ",", "batch_idx", "=", "0", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "    ", "dets", "=", "dets_out", "[", "batch_idx", "]", "\n", "segment_data", "=", "dets", "[", "'segm'", "]", "\n", "\n", "proto_out", "=", "dets", "[", "'proto'", "]", "\n", "proto_h", ",", "proto_w", ",", "mask_dim", "=", "proto_out", ".", "size", "(", ")", "\n", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "segment_data", "=", "F", ".", "interpolate", "(", "segment_data", ".", "unsqueeze", "(", "0", ")", ",", "(", "h", ",", "w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "segment_data", "=", "F", ".", "log_softmax", "(", "segment_data", ",", "dim", "=", "0", ")", "\n", "# max_idx = torch.max(segment_data, dim=0)[1].unique()", "\n", "# print(max_idx)", "\n", "# for i in range(55):", "\n", "#     plt.imsave('visual_test/{}.png'.format(i), segment_data[i].detach().cpu())", "\n", "# plt.imsave('visual_test/output.png'.format(i), torch.argmax(segment_data, dim=0).detach().cpu())", "\n", "# max_value = torch.max(segment_data, dim=0)[0].repeat(segment_data.size(0), 1, 1)", "\n", "# segment_data = (segment_data-max_value).gt(-1e-8).float()", "\n", "\n", "\n", "\n", "", "return", "segment_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff_lincomb": [[182, 189], ["layers.output_utils.semantic_logit"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.semantic_logit"], ["", "def", "postprocess_stuff_lincomb", "(", "dets_out", ",", "h", ",", "w", ",", "batch_idx", "=", "0", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "    ", "dets", "=", "dets_out", "[", "batch_idx", "]", "\n", "upsampled_mask", "=", "semantic_logit", "(", "dets", ",", "h", ",", "w", ")", "\n", "# max_value = torch.max(upsampled_mask, dim=0)[0].repeat(upsampled_mask.size(0), 1, 1)", "\n", "# upsampled_mask = (upsampled_mask-max_value).gt(-1e-8).float()", "\n", "\n", "return", "upsampled_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_coco_cats": [[192, 204], ["data.get_label_map().items", "data.get_label_map().items", "data.get_label_map", "data.get_label_map"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.get_label_map", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.get_label_map"], ["", "def", "prep_coco_cats", "(", ")", ":", "\n", "    ", "\"\"\" Prepare inverted table for category id lookup given a coco cats object. \"\"\"", "\n", "#things catogories", "\n", "for", "coco_cat_id", ",", "transformed_cat_id_p1", "in", "get_label_map", "(", ")", ".", "items", "(", ")", ":", "\n", "        ", "transformed_cat_id", "=", "transformed_cat_id_p1", "-", "1", "\n", "coco_cats", "[", "transformed_cat_id", "]", "=", "coco_cat_id", "\n", "coco_cats_inv", "[", "coco_cat_id", "]", "=", "transformed_cat_id", "\n", "\n", "", "for", "coco_cat_id", ",", "transformed_cat_id_p1", "in", "get_label_map", "(", "is_stuff", "=", "True", ")", ".", "items", "(", ")", ":", "#id 0 = background ", "\n", "# transformed_cat_id = transformed_cat_id_p1 - 1", "\n", "        ", "coco_stuff_cats", "[", "transformed_cat_id_p1", "]", "=", "coco_cat_id", "\n", "coco_stuff_cats_inv", "[", "coco_cat_id", "]", "=", "transformed_cat_id", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat": [[206, 212], ["None"], "function", ["None"], ["", "", "def", "get_coco_cat", "(", "transformed_cat_id", ",", "is_stuff", "=", "False", ")", ":", "\n", "    ", "\"\"\" transformed_cat_id is [0,80) as indices in cfg.dataset.class_names \"\"\"", "\n", "if", "is_stuff", "is", "not", "True", ":", "\n", "        ", "return", "coco_cats", "[", "transformed_cat_id", "]", "\n", "", "else", ":", "\n", "        ", "return", "coco_stuff_cats", "[", "transformed_cat_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_transformed_cat": [[215, 221], ["None"], "function", ["None"], ["", "", "def", "get_transformed_cat", "(", "coco_cat_id", ")", ":", "\n", "    ", "\"\"\" transformed_cat_id is [0,80) as indices in cfg.dataset.class_names \"\"\"", "\n", "if", "is_stuff", "is", "not", "True", ":", "\n", "        ", "return", "coco_cats_inv", "[", "transformed_cat_id", "]", "\n", "", "else", ":", "\n", "        ", "return", "coco_stuff_cats_inv", "[", "transformed_cat_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_ins_sem": [[225, 246], ["utils.timer.env", "panoptic_eval.postprocess_stuff_lincomb", "panoptic_eval.postprocess_stuff", "dets[].keys", "torch.zeros", "torch.zeros", "torch.zeros", "layers.output_utils.postprocess", "list", "list", "boxes.cuda.cuda", "list.cpu().numpy().astype", "list.cpu().numpy().astype", "torch.zeros.size", "list.cpu().numpy", "list.cpu().numpy", "torch.max", "torch.max", "torch.max", "list.cpu", "list.cpu"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff_lincomb", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.postprocess"], ["", "", "def", "postprocess_ins_sem", "(", "dets", ",", "file_name", ",", "h", ",", "w", ")", ":", "\n", "    ", "with", "timer", ".", "env", "(", "'Postprocess'", ")", ":", "\n", "        ", "if", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "            ", "stuff_mask", "=", "postprocess_stuff_lincomb", "(", "dets", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "stuff_mask", "=", "postprocess_stuff", "(", "dets", ",", "h", ",", "w", ")", "\n", "\n", "", "if", "'mask'", "not", "in", "dets", "[", "0", "]", ".", "keys", "(", ")", ":", "# handle cases of no remaining instance masks ", "\n", "            ", "masks", "=", "torch", ".", "zeros", "(", "0", ",", "h", ",", "w", ")", "\n", "return", "[", "[", "]", ",", "[", "]", ",", "None", ",", "None", ",", "stuff_mask", "[", ":", "-", "1", ",", ":", ",", ":", "]", "]", "\n", "", "else", ":", "\n", "            ", "classes", ",", "scores", ",", "boxes", ",", "masks", "=", "postprocess", "(", "dets", ",", "w", ",", "h", ",", "crop_masks", "=", "args", ".", "crop", ",", "score_threshold", "=", "args", ".", "score_threshold", ")", "\n", "classes", "=", "list", "(", "classes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "int", ")", ")", "\n", "scores", "=", "list", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", ")", "\n", "boxes", "=", "boxes", ".", "cuda", "(", ")", "\n", "if", "masks", ".", "size", "(", "0", ")", ">", "0", ":", "\n", "                ", "stuff_mask", "[", "0", ",", ":", ",", ":", "]", "=", "stuff_mask", "[", "-", "1", ",", ":", ",", ":", "]", "-", "torch", ".", "max", "(", "masks", ",", "dim", "=", "0", ")", "[", "0", "]", "# unknown prediction", "\n", "stuff_mask", "=", "stuff_mask", "[", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "return", "[", "classes", ",", "scores", ",", "boxes", ",", "masks", ",", "stuff_mask", "]", "\n", "", "else", ":", "\n", "                ", "return", "[", "[", "]", ",", "[", "]", ",", "None", ",", "None", ",", "stuff_mask", "[", ":", "-", "1", ",", ":", ",", ":", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.merge_segmentation": [[248, 320], ["utils.timer.env", "masks.view().cpu().numpy().astype.view().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "panopticapi.utils.IdGenerator", "numpy.zeros", "file_name.replace", "utils.timer.env", "range", "utils.timer.env", "numpy.unique", "PIL.fromarray().save", "int", "mask.sum", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "segments_info.append", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "segments_info.append", "os.path.join", "masks.view().cpu().numpy().astype.view().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "mask.copy", "int", "mask_left.sum", "PIL.fromarray", "mask.astype", "panopticapi.utils.id2rgb", "masks.view().cpu().numpy().astype.view().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "masks.view().cpu().numpy().astype.view", "torch.argmax", "torch.argmax", "torch.argmax"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "", "", "", "def", "merge_segmentation", "(", "classes", ",", "scores", ",", "boxes", ",", "masks", ",", "stuff_mask", ",", "file_name", ",", "h", ",", "w", ",", "image_id", ",", "segm_folder", ",", "overlap_thr", "=", "0.5", ",", "stuff_area_limit", "=", "64", "*", "64", ")", ":", "\n", "    ", "with", "timer", ".", "env", "(", "'JSON Output'", ")", ":", "\n", "        ", "masks", "=", "masks", ".", "view", "(", "-", "1", ",", "h", ",", "w", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "stuff_mask", "=", "torch", ".", "argmax", "(", "stuff_mask", ",", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "id_generator", "=", "IdGenerator", "(", "pan_categories", ")", "\n", "pan_segm_id", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "used", "=", "None", "\n", "annotation", "=", "{", "}", "\n", "try", ":", "\n", "            ", "annotation", "[", "'image_id'", "]", "=", "int", "(", "image_id", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "annotation", "[", "'image_id'", "]", "=", "image_id", "\n", "\n", "", "annotation", "[", "'file_name'", "]", "=", "file_name", ".", "replace", "(", "'.jpg'", ",", "'.png'", ")", "\n", "\n", "segments_info", "=", "[", "]", "\n", "", "with", "timer", ".", "env", "(", "'thing process'", ")", ":", "\n", "\n", "        ", "for", "i", "in", "range", "(", "masks", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "(", "boxes", "[", "i", ",", "3", "]", "-", "boxes", "[", "i", ",", "1", "]", ")", "*", "(", "boxes", "[", "i", ",", "2", "]", "-", "boxes", "[", "i", ",", "0", "]", ")", "<=", "0", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "masks", "[", "i", ",", ":", ",", ":", "]", "\n", "area", "=", "mask", ".", "sum", "(", ")", "\n", "if", "area", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "used", "is", "None", ":", "\n", "                ", "intersect", "=", "0", "\n", "used", "=", "mask", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "                ", "intersect", "=", "(", "used", "&", "mask", ")", ".", "sum", "(", ")", "\n", "", "if", "intersect", "/", "area", ">", "overlap_thr", ":", "\n", "                ", "continue", "\n", "", "used", "=", "used", "|", "mask", "\n", "\n", "if", "intersect", "!=", "0", ":", "\n", "                ", "mask", "=", "(", "pan_segm_id", "==", "0", ")", "&", "mask", "\n", "", "cat_id", "=", "get_coco_cat", "(", "int", "(", "classes", "[", "i", "]", ")", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "cat_id", "\n", "pan_segm_id", "[", "mask", ".", "astype", "(", "np", ".", "bool_", ")", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "\n", "", "pan_left", "=", "(", "pan_segm_id", "==", "0", ")", "\n", "", "with", "timer", ".", "env", "(", "'stuff process'", ")", ":", "\n", "\n", "# for c in range(1, cfg.stuff_num_classes-cfg.num_classes+1): # skip background and things", "\n", "\n", "        ", "stuff_idx", "=", "np", ".", "unique", "(", "stuff_mask", ")", "#all predicted segment with their panoptic idx", "\n", "\n", "for", "c", "in", "stuff_idx", ":", "# skip background and things ", "\n", "            ", "if", "c", "==", "0", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "(", "stuff_mask", "==", "c", ")", ".", "astype", "(", "np", ".", "bool_", ")", "\n", "mask_left", "=", "pan_left", "&", "mask", "\n", "if", "mask_left", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                ", "continue", "\n", "", "cat_id", "=", "get_coco_cat", "(", "c", ",", "is_stuff", "=", "True", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "cat_id", "\n", "pan_segm_id", "[", "mask_left", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "", "annotation", "[", "'segments_info'", "]", "=", "segments_info", "\n", "\n", "Image", ".", "fromarray", "(", "id2rgb", "(", "pan_segm_id", ")", ")", ".", "save", "(", "\n", "os", ".", "path", ".", "join", "(", "segm_folder", ",", "annotation", "[", "'file_name'", "]", ")", "\n", ")", "\n", "return", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_panoptic_result": [[322, 412], ["utils.timer.env", "utils.timer.env", "torch.zeros.view().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "panopticapi.utils.IdGenerator", "numpy.zeros", "file_name.replace", "utils.timer.env", "range", "utils.timer.env", "numpy.unique", "PIL.fromarray().save", "panoptic_eval.postprocess_stuff_lincomb", "panoptic_eval.postprocess_stuff", "dets[].keys", "torch.zeros", "torch.zeros", "torch.zeros", "layers.output_utils.postprocess", "list", "list", "boxes.cuda.cuda", "int", "mask.sum", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "segments_info.append", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "segments_info.append", "os.path.join", "list.cpu().numpy().astype", "list.cpu().numpy().astype", "torch.zeros.size", "torch.zeros.view().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "mask.copy", "int", "mask_left.sum", "PIL.fromarray", "mask.astype", "panopticapi.utils.id2rgb", "list.cpu().numpy", "list.cpu().numpy", "torch.max", "torch.max", "torch.max", "torch.zeros.view().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "list.cpu", "list.cpu", "torch.zeros.view", "torch.argmax", "torch.argmax", "torch.argmax"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff_lincomb", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.postprocess", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "", "def", "prep_panoptic_result", "(", "dets", ",", "img", ",", "file_name", ",", "h", ",", "w", ",", "image_id", ",", "segm_folder", ",", "overlap_thr", "=", "0.5", ",", "stuff_area_limit", "=", "64", "*", "64", ")", ":", "\n", "    ", "with", "timer", ".", "env", "(", "'Postprocess'", ")", ":", "\n", "        ", "if", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "            ", "stuff_mask", "=", "postprocess_stuff_lincomb", "(", "dets", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "stuff_mask", "=", "postprocess_stuff", "(", "dets", ",", "h", ",", "w", ")", "\n", "\n", "", "if", "'mask'", "not", "in", "dets", "[", "0", "]", ".", "keys", "(", ")", ":", "# handle cases of no remaining instance masks ", "\n", "            ", "masks", "=", "torch", ".", "zeros", "(", "0", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "classes", ",", "scores", ",", "boxes", ",", "masks", "=", "postprocess", "(", "dets", ",", "w", ",", "h", ",", "crop_masks", "=", "args", ".", "crop", ",", "score_threshold", "=", "args", ".", "score_threshold", ")", "\n", "classes", "=", "list", "(", "classes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "int", ")", ")", "\n", "scores", "=", "list", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", ")", "\n", "boxes", "=", "boxes", ".", "cuda", "(", ")", "\n", "if", "masks", ".", "size", "(", "0", ")", ">", "0", ":", "\n", "                ", "stuff_mask", "[", "0", ",", ":", ",", ":", "]", "=", "stuff_mask", "[", "-", "1", ",", ":", ",", ":", "]", "-", "torch", ".", "max", "(", "masks", ",", "dim", "=", "0", ")", "[", "0", "]", "# unknown prediction", "\n", "", "", "stuff_mask", "=", "stuff_mask", "[", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "\n", "# if classes.size(0) == 0:", "\n", "#     return", "\n", "\n", "\n", "", "with", "timer", ".", "env", "(", "'JSON Output'", ")", ":", "\n", "        ", "masks", "=", "masks", ".", "view", "(", "-", "1", ",", "h", ",", "w", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "stuff_mask", "=", "torch", ".", "argmax", "(", "stuff_mask", ",", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "id_generator", "=", "IdGenerator", "(", "pan_categories", ")", "\n", "pan_segm_id", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "used", "=", "None", "\n", "annotation", "=", "{", "}", "\n", "try", ":", "\n", "            ", "annotation", "[", "'image_id'", "]", "=", "int", "(", "image_id", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "annotation", "[", "'image_id'", "]", "=", "image_id", "\n", "\n", "", "annotation", "[", "'file_name'", "]", "=", "file_name", ".", "replace", "(", "'.jpg'", ",", "'.png'", ")", "\n", "\n", "segments_info", "=", "[", "]", "\n", "\n", "", "with", "timer", ".", "env", "(", "'thing process'", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "masks", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "(", "boxes", "[", "i", ",", "3", "]", "-", "boxes", "[", "i", ",", "1", "]", ")", "*", "(", "boxes", "[", "i", ",", "2", "]", "-", "boxes", "[", "i", ",", "0", "]", ")", "<=", "0", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "masks", "[", "i", ",", ":", ",", ":", "]", "\n", "area", "=", "mask", ".", "sum", "(", ")", "\n", "if", "area", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "used", "is", "None", ":", "\n", "                ", "intersect", "=", "0", "\n", "used", "=", "mask", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "                ", "intersect", "=", "(", "used", "&", "mask", ")", ".", "sum", "(", ")", "\n", "", "if", "intersect", "/", "area", ">", "overlap_thr", ":", "\n", "                ", "continue", "\n", "", "used", "=", "used", "|", "mask", "\n", "\n", "if", "intersect", "!=", "0", ":", "\n", "                ", "mask", "=", "(", "pan_segm_id", "==", "0", ")", "&", "mask", "\n", "", "cat_id", "=", "get_coco_cat", "(", "int", "(", "classes", "[", "i", "]", ")", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "cat_id", "\n", "pan_segm_id", "[", "mask", ".", "astype", "(", "np", ".", "bool_", ")", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "\n", "", "pan_left", "=", "(", "pan_segm_id", "==", "0", ")", "\n", "", "with", "timer", ".", "env", "(", "'stuff process'", ")", ":", "\n", "        ", "stuff_idx", "=", "np", ".", "unique", "(", "stuff_mask", ")", "#all predicted segment with their panoptic idx", "\n", "\n", "for", "c", "in", "stuff_idx", ":", "# skip background and things ", "\n", "            ", "if", "c", "==", "0", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "(", "stuff_mask", "==", "c", ")", ".", "astype", "(", "np", ".", "bool_", ")", "\n", "mask_left", "=", "pan_left", "&", "mask", "\n", "if", "mask_left", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                ", "continue", "\n", "", "cat_id", "=", "get_coco_cat", "(", "c", ",", "is_stuff", "=", "True", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "cat_id", "\n", "pan_segm_id", "[", "mask_left", "]", "=", "segment_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "", "annotation", "[", "'segments_info'", "]", "=", "segments_info", "\n", "\n", "Image", ".", "fromarray", "(", "id2rgb", "(", "pan_segm_id", ")", ")", ".", "save", "(", "\n", "os", ".", "path", ".", "join", "(", "segm_folder", ",", "annotation", "[", "'file_name'", "]", ")", "\n", ")", "\n", "return", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_panoptic_display": [[414, 489], ["torch.zeros.view().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "torch.argmax().cpu().numpy().astype", "panopticapi.utils.IdGenerator", "numpy.zeros", "img.cpu().numpy().astype.cpu().numpy().astype", "img.cpu().numpy().astype.copy", "cv2.cvtColor", "cv2.addWeighted", "layers.output_utils.undo_image_transformation", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "utils.timer.env", "utils.timer.env", "range", "utils.timer.env", "numpy.unique", "panopticapi.utils.id2rgb", "panoptic_eval.postprocess_stuff_lincomb", "panoptic_eval.postprocess_stuff", "dets[].keys", "torch.zeros", "torch.zeros", "torch.zeros", "layers.output_utils.postprocess", "list", "list", "boxes.cuda.cuda", "torch.zeros.view().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "mask.sum", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "img.cpu().numpy().astype.cpu().numpy", "torch.Tensor", "torch.Tensor", "torch.Tensor", "list.cpu().numpy().astype", "list.cpu().numpy().astype", "torch.zeros.size", "mask.copy", "int", "mask_left.sum", "torch.zeros.view().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "mask.astype", "img.cpu().numpy().astype.cpu", "list.cpu().numpy", "list.cpu().numpy", "torch.max", "torch.max", "torch.max", "torch.zeros.view", "torch.argmax", "torch.argmax", "torch.argmax", "list.cpu", "list.cpu"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.undo_image_transformation", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff_lincomb", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_stuff", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.postprocess", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "", "def", "prep_panoptic_display", "(", "dets", ",", "img", ",", "h", ",", "w", ",", "undo_transform", "=", "True", ",", "overlap_thr", "=", "0.5", ",", "stuff_area_limit", "=", "64", "*", "64", ",", "alpha", "=", "0.5", ")", ":", "\n", "    ", "if", "undo_transform", ":", "\n", "        ", "img_numpy", "=", "undo_image_transformation", "(", "img", ",", "w", ",", "h", ")", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "        ", "img_gpu", "=", "img", "/", "255.0", "\n", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "\n", "", "with", "timer", ".", "env", "(", "'Postprocess'", ")", ":", "\n", "        ", "if", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "            ", "stuff_mask", "=", "postprocess_stuff_lincomb", "(", "dets", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "stuff_mask", "=", "postprocess_stuff", "(", "dets", ",", "h", ",", "w", ")", "\n", "", "if", "'mask'", "not", "in", "dets", "[", "0", "]", ".", "keys", "(", ")", ":", "# handle cases of no remaining instance masks ", "\n", "            ", "masks", "=", "torch", ".", "zeros", "(", "0", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "            ", "classes", ",", "scores", ",", "boxes", ",", "masks", "=", "postprocess", "(", "dets", ",", "w", ",", "h", ",", "crop_masks", "=", "args", ".", "crop", ",", "score_threshold", "=", "args", ".", "score_threshold", ")", "\n", "classes", "=", "list", "(", "classes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "int", ")", ")", "\n", "scores", "=", "list", "(", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", ")", "\n", "boxes", "=", "boxes", ".", "cuda", "(", ")", "\n", "if", "masks", ".", "size", "(", "0", ")", ">", "0", ":", "\n", "                ", "stuff_mask", "[", "0", ",", ":", ",", ":", "]", "=", "stuff_mask", "[", "-", "1", ",", ":", ",", ":", "]", "-", "torch", ".", "max", "(", "masks", ",", "dim", "=", "0", ")", "[", "0", "]", "# unknown prediction", "\n", "\n", "", "", "", "stuff_mask", "=", "stuff_mask", "[", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "masks", "=", "masks", ".", "view", "(", "-", "1", ",", "h", ",", "w", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "stuff_mask", "=", "torch", ".", "argmax", "(", "stuff_mask", ",", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "id_generator", "=", "IdGenerator", "(", "pan_categories", ")", "\n", "pan_segm_id", "=", "np", ".", "zeros", "(", "(", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "used", "=", "None", "\n", "with", "timer", ".", "env", "(", "'panoptic display thing'", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "masks", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "(", "boxes", "[", "i", ",", "3", "]", "-", "boxes", "[", "i", ",", "1", "]", ")", "*", "(", "boxes", "[", "i", ",", "2", "]", "-", "boxes", "[", "i", ",", "0", "]", ")", "<=", "0", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "masks", "[", "i", ",", ":", ",", ":", "]", "\n", "area", "=", "mask", ".", "sum", "(", ")", "\n", "if", "area", "==", "0", ":", "\n", "                ", "continue", "\n", "", "if", "used", "is", "None", ":", "\n", "                ", "intersect", "=", "0", "\n", "used", "=", "mask", ".", "copy", "(", ")", "\n", "", "else", ":", "\n", "                ", "intersect", "=", "(", "used", "&", "mask", ")", ".", "sum", "(", ")", "\n", "", "if", "intersect", "/", "area", ">", "overlap_thr", ":", "\n", "                ", "continue", "\n", "", "used", "=", "used", "|", "mask", "\n", "if", "intersect", "!=", "0", ":", "\n", "                ", "mask", "=", "(", "pan_segm_id", "==", "0", ")", "&", "mask", "\n", "", "cat_id", "=", "get_coco_cat", "(", "int", "(", "classes", "[", "i", "]", ")", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "pan_segm_id", "[", "mask", ".", "astype", "(", "np", ".", "bool_", ")", "]", "=", "segment_id", "\n", "\n", "", "pan_left", "=", "(", "pan_segm_id", "==", "0", ")", "\n", "", "with", "timer", ".", "env", "(", "'panoptic display stuff'", ")", ":", "\n", "        ", "stuff_idx", "=", "np", ".", "unique", "(", "stuff_mask", ")", "#all predicted segment with their panoptic idx", "\n", "\n", "for", "c", "in", "stuff_idx", ":", "# skip background and things ", "\n", "            ", "if", "c", "==", "0", ":", "\n", "                ", "continue", "\n", "", "mask", "=", "(", "stuff_mask", "==", "c", ")", ".", "astype", "(", "np", ".", "bool_", ")", "\n", "mask_left", "=", "pan_left", "&", "mask", "\n", "if", "mask_left", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                ", "continue", "\n", "", "cat_id", "=", "get_coco_cat", "(", "c", ",", "is_stuff", "=", "True", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "pan_segm_id", "[", "mask_left", "]", "=", "segment_id", "\n", "# pan_left = pan_left + mask_left", "\n", "\n", "", "", "img", "=", "img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "img_pan_segm", "=", "img", ".", "copy", "(", ")", "\n", "img_pan_segm", "[", "pan_segm_id", "!=", "0", "]", "=", "0", "\n", "img_pan_segm", "+=", "cv2", ".", "cvtColor", "(", "id2rgb", "(", "pan_segm_id", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "img_out", "=", "cv2", ".", "addWeighted", "(", "img", ",", "alpha", ",", "img_pan_segm", ",", "1", "-", "alpha", ",", "0", ")", "\n", "\n", "return", "img_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_unified_result": [[492, 542], ["utils.timer.env", "layers.output_utils.panoptic_logit", "utils.timer.env", "panopticapi.utils.IdGenerator", "file_name.replace", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "pan_logit.size", "numpy.unique", "PIL.fromarray().save", "int", "os.path.join", "torch.argmax().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "enumerate", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "segments_info.append", "PIL.fromarray", "range", "int", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "segments_info.append", "panopticapi.utils.id2rgb", "torch.argmax", "torch.argmax", "torch.argmax", "int"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.panoptic_logit", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "prep_unified_result", "(", "dets", ",", "img", ",", "file_name", ",", "h", ",", "w", ",", "image_id", ",", "segm_folder", ",", "overlap_thr", "=", "0.5", ",", "stuff_area_limit", "=", "64", "*", "64", ")", ":", "\n", "\n", "    ", "with", "timer", ".", "env", "(", "'panoptic logit'", ")", ":", "\n", "        ", "pan_logit", ",", "classes", "=", "panoptic_logit", "(", "dets", ",", "w", ",", "h", ",", "score_threshold", "=", "args", ".", "score_threshold", ",", "overlap_thr", "=", "overlap_thr", ")", "\n", "\n", "", "with", "timer", ".", "env", "(", "'JSON Output'", ")", ":", "\n", "\n", "        ", "id_generator", "=", "IdGenerator", "(", "pan_categories", ")", "\n", "annotation", "=", "{", "}", "\n", "try", ":", "\n", "            ", "annotation", "[", "'image_id'", "]", "=", "int", "(", "image_id", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "annotation", "[", "'image_id'", "]", "=", "image_id", "\n", "", "annotation", "[", "'file_name'", "]", "=", "file_name", ".", "replace", "(", "'.jpg'", ",", "'.png'", ")", "\n", "segments_info", "=", "[", "]", "\n", "\n", "pan_result", "=", "torch", ".", "argmax", "(", "pan_logit", ",", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# bg + n_stuff + n_thing", "\n", "n_thing", "=", "0", "if", "classes", "is", "None", "else", "classes", ".", "shape", "[", "0", "]", "\n", "n_pan", "=", "pan_logit", ".", "size", "(", "0", ")", "\n", "n_stuff", "=", "n_pan", "-", "n_thing", "\n", "pan_idx", "=", "np", ".", "unique", "(", "pan_result", ")", "# all predicted segment with their panoptic idx", "\n", "thing_cls_map", "=", "{", "idx", ":", "classes", "[", "i", "]", "for", "i", ",", "idx", "in", "enumerate", "(", "range", "(", "n_pan", "-", "n_thing", ",", "n_pan", ")", ")", "}", "\n", "\n", "for", "idx", "in", "pan_idx", ":", "\n", "            ", "if", "idx", "<", "n_stuff", "and", "idx", "!=", "0", ":", "#stuff", "\n", "                ", "if", "(", "pan_result", "==", "idx", ")", ".", "sum", "(", ")", "<", "stuff_area_limit", ":", "\n", "                    ", "pan_result", "[", "pan_result", "==", "idx", "]", "=", "0", "\n", "continue", "\n", "", "cat_id", "=", "get_coco_cat", "(", "int", "(", "idx", ")", ",", "is_stuff", "=", "True", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "pan_result", "[", "pan_result", "==", "idx", "]", "=", "segment_id", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "cat_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "", "elif", "idx", ">=", "n_stuff", ":", "#things", "\n", "                ", "cat_id", "=", "get_coco_cat", "(", "thing_cls_map", "[", "int", "(", "idx", ")", "]", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "pan_result", "[", "pan_result", "==", "idx", "]", "=", "segment_id", "\n", "panoptic_ann", "=", "{", "}", "\n", "panoptic_ann", "[", "'id'", "]", "=", "segment_id", "\n", "panoptic_ann", "[", "'category_id'", "]", "=", "cat_id", "\n", "segments_info", ".", "append", "(", "panoptic_ann", ")", "\n", "\n", "", "", "annotation", "[", "'segments_info'", "]", "=", "segments_info", "\n", "\n", "Image", ".", "fromarray", "(", "id2rgb", "(", "pan_result", ")", ")", ".", "save", "(", "\n", "os", ".", "path", ".", "join", "(", "segm_folder", ",", "annotation", "[", "'file_name'", "]", ")", "\n", ")", "\n", "return", "annotation", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_unified_display": [[544, 579], ["layers.output_utils.undo_image_transformation", "torch.Tensor().cuda", "torch.Tensor().cuda", "torch.Tensor().cuda", "utils.timer.env", "layers.output_utils.panoptic_logit", "utils.timer.env", "panopticapi.utils.IdGenerator", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "torch.argmax().cpu().numpy", "pan_logit.size", "numpy.unique", "img.cpu().numpy().astype.cpu().numpy().astype", "img.cpu().numpy().astype.copy", "panopticapi.utils.id2rgb", "cv2.addWeighted", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.argmax().cpu", "torch.argmax().cpu", "torch.argmax().cpu", "enumerate", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "img.cpu().numpy().astype.cpu().numpy", "range", "int", "panoptic_eval.get_coco_cat", "panopticapi.utils.IdGenerator.get_id", "torch.argmax", "torch.argmax", "torch.argmax", "img.cpu().numpy().astype.cpu", "int"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.undo_image_transformation", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.panoptic_logit", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.get_coco_cat"], ["", "", "def", "prep_unified_display", "(", "dets", ",", "img", ",", "h", ",", "w", ",", "undo_transform", "=", "True", ",", "overlap_thr", "=", "0.5", ",", "alpha", "=", "0.5", ")", ":", "\n", "    ", "if", "undo_transform", ":", "\n", "        ", "img_numpy", "=", "undo_image_transformation", "(", "img", ",", "w", ",", "h", ")", "\n", "img_gpu", "=", "torch", ".", "Tensor", "(", "img_numpy", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "        ", "img_gpu", "=", "img", "/", "255.0", "\n", "h", ",", "w", ",", "_", "=", "img", ".", "shape", "\n", "", "with", "timer", ".", "env", "(", "'panoptic logit'", ")", ":", "\n", "        ", "pan_logit", ",", "classes", "=", "panoptic_logit", "(", "dets", ",", "w", ",", "h", ",", "score_threshold", "=", "args", ".", "score_threshold", ",", "overlap_thr", "=", "overlap_thr", ")", "\n", "\n", "", "with", "timer", ".", "env", "(", "'unified  postprocess'", ")", ":", "\n", "        ", "id_generator", "=", "IdGenerator", "(", "pan_categories", ")", "\n", "pan_result", "=", "torch", ".", "argmax", "(", "pan_logit", ",", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "#bg + n_stuff + n_thing", "\n", "n_thing", "=", "0", "if", "classes", "is", "None", "else", "classes", ".", "shape", "[", "0", "]", "\n", "n_pan", "=", "pan_logit", ".", "size", "(", "0", ")", "\n", "n_stuff", "=", "n_pan", "-", "n_thing", "\n", "pan_idx", "=", "np", ".", "unique", "(", "pan_result", ")", "#all predicted segment with their panoptic idx", "\n", "thing_cls_map", "=", "{", "idx", ":", "classes", "[", "i", "]", "for", "i", ",", "idx", "in", "enumerate", "(", "range", "(", "n_pan", "-", "n_thing", ",", "n_pan", ")", ")", "}", "\n", "for", "idx", "in", "pan_idx", ":", "\n", "            ", "if", "idx", "<", "n_stuff", "and", "idx", "!=", "0", ":", "\n", "                ", "cat_id", "=", "get_coco_cat", "(", "int", "(", "idx", ")", ",", "is_stuff", "=", "True", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "pan_result", "[", "pan_result", "==", "idx", "]", "=", "segment_id", "\n", "", "elif", "idx", ">=", "n_stuff", ":", "\n", "                ", "cat_id", "=", "get_coco_cat", "(", "thing_cls_map", "[", "int", "(", "idx", ")", "]", ")", "\n", "segment_id", "=", "id_generator", ".", "get_id", "(", "cat_id", ")", "\n", "pan_result", "[", "pan_result", "==", "idx", "]", "=", "segment_id", "\n", "\n", "", "", "img", "=", "img", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "img_pan_segm", "=", "img", ".", "copy", "(", ")", "\n", "img_pan_segm", "[", "pan_result", "!=", "0", "]", "=", "0", "\n", "img_pan_segm", "+=", "id2rgb", "(", "pan_result", ")", "\n", "img_out", "=", "cv2", ".", "addWeighted", "(", "img", ",", "alpha", ",", "img_pan_segm", ",", "1", "-", "alpha", ",", "0", ")", "\n", "\n", "return", "img_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.badhash": [[580, 590], ["None"], "function", ["None"], ["", "", "def", "badhash", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Just a quick and dirty hash function for doing a deterministic shuffle based on image_id.\n    Source:\n    https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key\n    \"\"\"", "\n", "x", "=", "(", "(", "(", "x", ">>", "16", ")", "^", "x", ")", "*", "0x045d9f3b", ")", "&", "0xFFFFFFFF", "\n", "x", "=", "(", "(", "(", "x", ">>", "16", ")", "^", "x", ")", "*", "0x045d9f3b", ")", "&", "0xFFFFFFFF", "\n", "x", "=", "(", "(", "x", ">>", "16", ")", "^", "x", ")", "&", "0xFFFFFFFF", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalimage": [[591, 611], ["torch.from_numpy().cuda().float", "torch.from_numpy().cuda().float", "torch.from_numpy().cuda().float", "utils.timer.reset", "net", "utils.augmentations.FastBaseTransform", "torch.from_numpy().cuda().float.unsqueeze", "panoptic_eval.prep_unified_display", "panoptic_eval.prep_panoptic_display", "cv2.imwrite", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "cv2.imread"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_unified_display", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_panoptic_display"], ["", "def", "evalimage", "(", "net", ":", "EPSNet", ",", "path", ":", "str", ",", "save_path", ":", "str", "=", "None", ")", ":", "\n", "    ", "frame", "=", "torch", ".", "from_numpy", "(", "cv2", ".", "imread", "(", "path", ")", ")", ".", "cuda", "(", ")", ".", "float", "(", ")", "\n", "batch", "=", "FastBaseTransform", "(", ")", "(", "frame", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "timer", ".", "reset", "(", ")", "\n", "preds", "=", "net", "(", "batch", ")", "\n", "\n", "# img_numpy = prep_display(preds, frame, None, None, undo_transform=False)", "\n", "if", "cfg", ".", "use_panoptic_head", ":", "\n", "        ", "img_numpy", "=", "prep_unified_display", "(", "preds", ",", "frame", ",", "None", ",", "None", ",", "undo_transform", "=", "False", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ")", "\n", "", "else", ":", "\n", "        ", "img_numpy", "=", "prep_panoptic_display", "(", "preds", ",", "frame", ",", "None", ",", "None", ",", "undo_transform", "=", "False", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ",", "alpha", "=", "args", ".", "alpha", ")", "\n", "\n", "# timer.print_stats()", "\n", "\n", "", "if", "save_path", "is", "None", ":", "\n", "        ", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "\n", "\n", "", "else", ":", "\n", "        ", "cv2", ".", "imwrite", "(", "save_path", ",", "img_numpy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalimages": [[612, 627], ["print", "pathlib.Path().glob", "print", "os.path.exists", "os.mkdir", "str", "os.path.basename", "os.path.join", "panoptic_eval.evalimage", "print", "pathlib.Path", "os.path.basename.split"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalimage", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "", "def", "evalimages", "(", "net", ":", "EPSNet", ",", "input_folder", ":", "str", ",", "output_folder", ":", "str", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "output_folder", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output_folder", ")", "\n", "\n", "", "print", "(", ")", "\n", "\n", "for", "p", "in", "Path", "(", "input_folder", ")", ".", "glob", "(", "'*'", ")", ":", "\n", "        ", "path", "=", "str", "(", "p", ")", "\n", "name", "=", "os", ".", "path", ".", "basename", "(", "path", ")", "\n", "name", "=", "'.'", ".", "join", "(", "name", ".", "split", "(", "'.'", ")", "[", ":", "-", "1", "]", ")", "+", "'.png'", "\n", "out_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "name", ")", "\n", "\n", "evalimage", "(", "net", ",", "path", ",", "out_path", ")", "\n", "print", "(", "path", "+", "' -> '", "+", "out_path", ")", "\n", "", "print", "(", "'Done.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalvideo": [[637, 780], ["path.isdigit", "CustomDataParallel().cuda", "torch.nn.DataParallel().cuda", "torch.nn.DataParallel().cuda", "torch.nn.DataParallel().cuda", "utils.functions.MovingAverage", "queue.Queue", "print", "panoptic_eval.evalvideo.eval_network"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "", "def", "evalvideo", "(", "net", ":", "EPSNet", ",", "path", ":", "str", ")", ":", "\n", "# If the path is a digit, parse it as a webcam index", "\n", "    ", "is_webcam", "=", "path", ".", "isdigit", "(", ")", "\n", "\n", "if", "is_webcam", ":", "\n", "        ", "vid", "=", "cv2", ".", "VideoCapture", "(", "int", "(", "path", ")", ")", "\n", "", "else", ":", "\n", "        ", "vid", "=", "cv2", ".", "VideoCapture", "(", "path", ")", "\n", "\n", "", "if", "not", "vid", ".", "isOpened", "(", ")", ":", "\n", "        ", "print", "(", "'Could not open video \"%s\"'", "%", "path", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "net", "=", "CustomDataParallel", "(", "net", ")", ".", "cuda", "(", ")", "\n", "transform", "=", "torch", ".", "nn", ".", "DataParallel", "(", "FastBaseTransform", "(", ")", ")", ".", "cuda", "(", ")", "\n", "frame_times", "=", "MovingAverage", "(", "100", ")", "\n", "fps", "=", "0", "\n", "# The 0.8 is to account for the overhead of time.sleep", "\n", "frame_time_target", "=", "1", "/", "vid", ".", "get", "(", "cv2", ".", "CAP_PROP_FPS", ")", "\n", "running", "=", "True", "\n", "\n", "def", "cleanup_and_exit", "(", ")", ":", "\n", "        ", "print", "(", ")", "\n", "pool", ".", "terminate", "(", ")", "\n", "vid", ".", "release", "(", ")", "\n", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "exit", "(", ")", "\n", "\n", "", "def", "get_next_frame", "(", "vid", ")", ":", "\n", "        ", "return", "[", "vid", ".", "read", "(", ")", "[", "1", "]", "for", "_", "in", "range", "(", "args", ".", "video_multiframe", ")", "]", "\n", "\n", "", "def", "transform_frame", "(", "frames", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "frames", "=", "[", "torch", ".", "from_numpy", "(", "frame", ")", ".", "cuda", "(", ")", ".", "float", "(", ")", "for", "frame", "in", "frames", "]", "\n", "return", "frames", ",", "transform", "(", "torch", ".", "stack", "(", "frames", ",", "0", ")", ")", "\n", "\n", "", "", "def", "eval_network", "(", "inp", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "frames", ",", "imgs", "=", "inp", "\n", "return", "frames", ",", "net", "(", "imgs", ")", "\n", "\n", "", "", "def", "prep_frame", "(", "inp", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "frame", ",", "preds", "=", "inp", "\n", "return", "prep_panoptic_display", "(", "preds", ",", "frame", ",", "None", ",", "None", ",", "undo_transform", "=", "False", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ",", "alpha", "=", "args", ".", "alpha", ")", "\n", "", "", "frame_buffer", "=", "Queue", "(", ")", "\n", "video_fps", "=", "0", "\n", "\n", "# All this timing code to make sure that ", "\n", "def", "play_video", "(", ")", ":", "\n", "        ", "nonlocal", "frame_buffer", ",", "running", ",", "video_fps", ",", "is_webcam", "\n", "\n", "video_frame_times", "=", "MovingAverage", "(", "100", ")", "\n", "frame_time_stabilizer", "=", "frame_time_target", "\n", "last_time", "=", "None", "\n", "stabilizer_step", "=", "0.0005", "\n", "\n", "while", "running", ":", "\n", "            ", "frame_time_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "not", "frame_buffer", ".", "empty", "(", ")", ":", "\n", "                ", "next_time", "=", "time", ".", "time", "(", ")", "\n", "if", "last_time", "is", "not", "None", ":", "\n", "                    ", "video_frame_times", ".", "add", "(", "next_time", "-", "last_time", ")", "\n", "video_fps", "=", "1", "/", "video_frame_times", ".", "get_avg", "(", ")", "\n", "", "cv2", ".", "imshow", "(", "path", ",", "frame_buffer", ".", "get", "(", ")", ")", "\n", "last_time", "=", "next_time", "\n", "\n", "", "if", "cv2", ".", "waitKey", "(", "1", ")", "==", "27", ":", "# Press Escape to close", "\n", "                ", "running", "=", "False", "\n", "\n", "", "buffer_size", "=", "frame_buffer", ".", "qsize", "(", ")", "\n", "if", "buffer_size", "<", "args", ".", "video_multiframe", ":", "\n", "                ", "frame_time_stabilizer", "+=", "stabilizer_step", "\n", "", "elif", "buffer_size", ">", "args", ".", "video_multiframe", ":", "\n", "                ", "frame_time_stabilizer", "-=", "stabilizer_step", "\n", "if", "frame_time_stabilizer", "<", "0", ":", "\n", "                    ", "frame_time_stabilizer", "=", "0", "\n", "\n", "", "", "new_target", "=", "frame_time_stabilizer", "if", "is_webcam", "else", "max", "(", "frame_time_stabilizer", ",", "frame_time_target", ")", "\n", "\n", "next_frame_target", "=", "max", "(", "2", "*", "new_target", "-", "video_frame_times", ".", "get_avg", "(", ")", ",", "0", ")", "\n", "target_time", "=", "frame_time_start", "+", "next_frame_target", "-", "0.001", "# Let's just subtract a millisecond to be safe", "\n", "# This gives more accurate timing than if sleeping the whole amount at once", "\n", "while", "time", ".", "time", "(", ")", "<", "target_time", ":", "\n", "                ", "time", ".", "sleep", "(", "0.001", ")", "\n", "\n", "\n", "", "", "", "extract_frame", "=", "lambda", "x", ",", "i", ":", "(", "x", "[", "0", "]", "[", "i", "]", "if", "'mask'", "not", "in", "x", "[", "1", "]", "[", "i", "]", ".", "keys", "(", ")", "else", "x", "[", "0", "]", "[", "i", "]", ".", "to", "(", "x", "[", "1", "]", "[", "i", "]", "[", "'box'", "]", ".", "device", ")", ",", "[", "x", "[", "1", "]", "[", "i", "]", "]", ")", "\n", "\n", "# Prime the network on the first frame because I do some thread unsafe things otherwise", "\n", "print", "(", "'Initializing model... '", ",", "end", "=", "''", ")", "\n", "eval_network", "(", "transform_frame", "(", "get_next_frame", "(", "vid", ")", ")", ")", "\n", "print", "(", "'Done.'", ")", "\n", "\n", "# For each frame the sequence of functions it needs to go through to be processed (in reversed order)", "\n", "sequence", "=", "[", "prep_frame", ",", "eval_network", ",", "transform_frame", "]", "\n", "pool", "=", "ThreadPool", "(", "processes", "=", "len", "(", "sequence", ")", "+", "args", ".", "video_multiframe", "+", "2", ")", "\n", "pool", ".", "apply_async", "(", "play_video", ")", "\n", "\n", "active_frames", "=", "[", "]", "\n", "\n", "print", "(", ")", "\n", "while", "vid", ".", "isOpened", "(", ")", "and", "running", ":", "\n", "        ", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Start loading the next frames from the disk", "\n", "next_frames", "=", "pool", ".", "apply_async", "(", "get_next_frame", ",", "args", "=", "(", "vid", ",", ")", ")", "\n", "\n", "# For each frame in our active processing queue, dispatch a job", "\n", "# for that frame using the current function in the sequence", "\n", "for", "frame", "in", "active_frames", ":", "\n", "            ", "frame", "[", "'value'", "]", "=", "pool", ".", "apply_async", "(", "sequence", "[", "frame", "[", "'idx'", "]", "]", ",", "args", "=", "(", "frame", "[", "'value'", "]", ",", ")", ")", "\n", "\n", "# For each frame whose job was the last in the sequence (i.e. for all final outputs)", "\n", "", "for", "frame", "in", "active_frames", ":", "\n", "            ", "if", "frame", "[", "'idx'", "]", "==", "0", ":", "\n", "                ", "frame_buffer", ".", "put", "(", "frame", "[", "'value'", "]", ".", "get", "(", ")", ")", "\n", "\n", "# Remove the finished frames from the processing queue", "\n", "", "", "active_frames", "=", "[", "x", "for", "x", "in", "active_frames", "if", "x", "[", "'idx'", "]", ">", "0", "]", "\n", "\n", "# Finish evaluating every frame in the processing queue and advanced their position in the sequence", "\n", "for", "frame", "in", "list", "(", "reversed", "(", "active_frames", ")", ")", ":", "\n", "            ", "frame", "[", "'value'", "]", "=", "frame", "[", "'value'", "]", ".", "get", "(", ")", "\n", "frame", "[", "'idx'", "]", "-=", "1", "\n", "\n", "if", "frame", "[", "'idx'", "]", "==", "0", ":", "\n", "# Split this up into individual threads for prep_frame since it doesn't support batch size", "\n", "                ", "active_frames", "+=", "[", "{", "'value'", ":", "extract_frame", "(", "frame", "[", "'value'", "]", ",", "i", ")", ",", "'idx'", ":", "0", "}", "for", "i", "in", "range", "(", "1", ",", "args", ".", "video_multiframe", ")", "]", "\n", "frame", "[", "'value'", "]", "=", "extract_frame", "(", "frame", "[", "'value'", "]", ",", "0", ")", "\n", "\n", "\n", "# Finish loading in the next frames and add them to the processing queue", "\n", "", "", "active_frames", ".", "append", "(", "{", "'value'", ":", "next_frames", ".", "get", "(", ")", ",", "'idx'", ":", "len", "(", "sequence", ")", "-", "1", "}", ")", "\n", "\n", "# Compute FPS", "\n", "frame_times", ".", "add", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", "\n", "fps", "=", "args", ".", "video_multiframe", "/", "frame_times", ".", "get_avg", "(", ")", "\n", "\n", "print", "(", "'\\rProcessing FPS: %.2f | Video Playback FPS: %.2f | Frames in Buffer: %d    '", "%", "(", "fps", ",", "video_fps", ",", "frame_buffer", ".", "qsize", "(", ")", ")", ",", "end", "=", "''", ")", "\n", "\n", "", "cleanup_and_exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.savevideo": [[781, 821], ["cv2.VideoCapture", "round", "round", "round", "round", "cv2.VideoWriter", "utils.augmentations.FastBaseTransform", "utils.functions.MovingAverage", "utils.functions.ProgressBar", "cv2.VideoCapture.release", "cv2.VideoWriter.release", "print", "cv2.VideoCapture.get", "cv2.VideoCapture.get", "cv2.VideoCapture.get", "cv2.VideoCapture.get", "cv2.VideoWriter_fourcc", "range", "utils.timer.reset", "print", "utils.timer.env", "torch.from_numpy().cuda().float", "torch.from_numpy().cuda().float", "torch.from_numpy().cuda().float", "utils.augmentations.FastBaseTransform.", "net", "panoptic_eval.prep_panoptic_display", "cv2.VideoWriter.write", "utils.functions.MovingAverage.add", "utils.functions.ProgressBar.set_val", "print", "torch.from_numpy().cuda().float.unsqueeze", "utils.timer.total_time", "utils.functions.MovingAverage.get_avg", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "repr", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "cv2.VideoCapture.read"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_panoptic_display", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.total_time", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg"], ["", "def", "savevideo", "(", "net", ":", "EPSNet", ",", "in_path", ":", "str", ",", "out_path", ":", "str", ")", ":", "\n", "\n", "    ", "vid", "=", "cv2", ".", "VideoCapture", "(", "in_path", ")", "\n", "\n", "target_fps", "=", "round", "(", "vid", ".", "get", "(", "cv2", ".", "CAP_PROP_FPS", ")", ")", "\n", "frame_width", "=", "round", "(", "vid", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_WIDTH", ")", ")", "\n", "frame_height", "=", "round", "(", "vid", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_HEIGHT", ")", ")", "\n", "num_frames", "=", "round", "(", "vid", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_COUNT", ")", ")", "\n", "\n", "out", "=", "cv2", ".", "VideoWriter", "(", "out_path", ",", "cv2", ".", "VideoWriter_fourcc", "(", "*", "\"mp4v\"", ")", ",", "target_fps", ",", "(", "frame_width", ",", "frame_height", ")", ")", "\n", "\n", "transform", "=", "FastBaseTransform", "(", ")", "\n", "frame_times", "=", "MovingAverage", "(", ")", "\n", "progress_bar", "=", "ProgressBar", "(", "30", ",", "num_frames", ")", "\n", "\n", "try", ":", "\n", "        ", "for", "i", "in", "range", "(", "num_frames", ")", ":", "\n", "            ", "timer", ".", "reset", "(", ")", "\n", "with", "timer", ".", "env", "(", "'Video'", ")", ":", "\n", "                ", "frame", "=", "torch", ".", "from_numpy", "(", "vid", ".", "read", "(", ")", "[", "1", "]", ")", ".", "cuda", "(", ")", ".", "float", "(", ")", "\n", "batch", "=", "transform", "(", "frame", ".", "unsqueeze", "(", "0", ")", ")", "\n", "preds", "=", "net", "(", "batch", ")", "\n", "processed", "=", "prep_panoptic_display", "(", "preds", ",", "frame", ",", "None", ",", "None", ",", "undo_transform", "=", "False", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ",", "alpha", "=", "args", ".", "alpha", ")", "\n", "\n", "out", ".", "write", "(", "processed", ")", "\n", "\n", "", "if", "i", ">", "1", ":", "\n", "                ", "frame_times", ".", "add", "(", "timer", ".", "total_time", "(", ")", ")", "\n", "fps", "=", "1", "/", "frame_times", ".", "get_avg", "(", ")", "\n", "progress", "=", "(", "i", "+", "1", ")", "/", "num_frames", "*", "100", "\n", "progress_bar", ".", "set_val", "(", "i", "+", "1", ")", "\n", "\n", "print", "(", "'\\rProcessing Frames  %s %6d / %6d (%5.2f%%)    %5.2f fps        '", "\n", "%", "(", "repr", "(", "progress_bar", ")", ",", "i", "+", "1", ",", "num_frames", ",", "progress", ",", "fps", ")", ",", "end", "=", "''", ")", "\n", "", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'Stopping early.'", ")", "\n", "\n", "", "vid", ".", "release", "(", ")", "\n", "out", ".", "release", "(", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evaluate": [[825, 1048], ["utils.functions.MovingAverage", "utils.functions.ProgressBar", "print", "list", "open", "json.load", "len", "min", "utils.timer.disable", "range", "random.shuffle", "enumerate", "args.image.split", "panoptic_eval.evalimage", "panoptic_eval.evalimage", "args.images.split", "panoptic_eval.evalimages", "len", "args.panoptic_det_file.split", "os.path.exists", "os.makedirs", "len", "list.sort", "utils.timer.reset", "dataset.pull_item", "torch.autograd.Variable", "print", "print", "list", "print", "panoptic_eval.badhash", "numpy.save", "img.unsqueeze", "batch.cuda.cuda", "utils.timer.env", "panoptic_eval.prep_panoptic_display", "panoptic_json.append", "utils.functions.MovingAverage.add", "matplotlib.imsave", "open", "json.load", "pan_categories.values", "open", "json.dump", "args.video.split", "panoptic_eval.savevideo", "panoptic_eval.evalvideo", "open", "f.write", "net", "panoptic_eval.prep_unified_result", "print", "print", "exit", "utils.timer.total_time", "print", "utils.functions.ProgressBar.set_val", "print", "str", "dataset.pull_image_name", "torch.zeros", "torch.zeros", "torch.zeros", "img.numpy().transpose", "panoptic_eval.merge_segmentation", "len", "dataset.pull_image_name", "str", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.autograd.Variable", "net", "panoptic_eval.postprocess_ins_sem", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "dataset.pull_image_name", "torch.zeros", "torch.zeros", "torch.zeros", "panoptic_eval.merge_segmentation", "panoptic_eval.prep_panoptic_result", "utils.functions.MovingAverage.get_avg", "img.numpy", "cv2.resize().transpose", "torch.from_numpy.unsqueeze", "batch.cuda.cuda", "dataset.pull_image_name", "torch.cat.append", "torch.cat.append", "torch.autograd.Variable", "net", "panoptic_eval.postprocess_ins_sem", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "dataset.pull_image_name", "dataset.pull_image_name", "utils.functions.MovingAverage.get_avg", "repr", "img.flip", "img.flip.unsqueeze", "batch.cuda.cuda", "dataset.pull_image_name", "cv2.resize", "post_results[].clone", "post_results[].flip", "torch.cat.append", "torch.cat.append", "post_results[].flip", "torch.cat.append", "torch.cat.append"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.disable", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalimage", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalimage", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalimages", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_item", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.badhash", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_panoptic_display", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.savevideo", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evalvideo", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_unified_result", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.total_time", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.merge_segmentation", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_ins_sem", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.merge_segmentation", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.prep_panoptic_result", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.postprocess_ins_sem", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "evaluate", "(", "net", ":", "EPSNet", ",", "dataset", ",", "train_mode", "=", "False", ")", ":", "\n", "    ", "net", ".", "detect", ".", "use_fast_nms", "=", "args", ".", "fast_nms", "\n", "cfg", ".", "mask_proto_debug", "=", "args", ".", "mask_proto_debug", "\n", "global", "pan_categories", "\n", "with", "open", "(", "cfg", ".", "dataset", ".", "categories_json_file", ",", "'r'", ")", "as", "f", ":", "#load panoptic catefories info (color , id....)", "\n", "        ", "cat_json", "=", "json", ".", "load", "(", "f", ")", "\n", "", "pan_categories", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "cat_json", "}", "\n", "\n", "if", "args", ".", "image", "is", "not", "None", ":", "\n", "        ", "if", "':'", "in", "args", ".", "image", ":", "\n", "            ", "inp", ",", "out", "=", "args", ".", "image", ".", "split", "(", "':'", ")", "\n", "evalimage", "(", "net", ",", "inp", ",", "out", ")", "\n", "", "else", ":", "\n", "            ", "evalimage", "(", "net", ",", "args", ".", "image", ")", "\n", "", "return", "\n", "", "elif", "args", ".", "images", "is", "not", "None", ":", "\n", "        ", "inp", ",", "out", "=", "args", ".", "images", ".", "split", "(", "':'", ")", "\n", "evalimages", "(", "net", ",", "inp", ",", "out", ")", "\n", "return", "\n", "", "elif", "args", ".", "video", "is", "not", "None", ":", "\n", "        ", "if", "':'", "in", "args", ".", "video", ":", "\n", "            ", "inp", ",", "out", "=", "args", ".", "video", ".", "split", "(", "':'", ")", "\n", "savevideo", "(", "net", ",", "inp", ",", "out", ")", "\n", "", "else", ":", "\n", "            ", "evalvideo", "(", "net", ",", "args", ".", "video", ")", "\n", "", "return", "\n", "\n", "", "frame_times", "=", "MovingAverage", "(", ")", "\n", "dataset_size", "=", "len", "(", "dataset", ")", "if", "args", ".", "max_images", "<", "0", "else", "min", "(", "args", ".", "max_images", ",", "len", "(", "dataset", ")", ")", "\n", "progress_bar", "=", "ProgressBar", "(", "30", ",", "dataset_size", ")", "\n", "\n", "print", "(", ")", "\n", "\n", "if", "not", "args", ".", "display", ":", "\n", "#prepare for panoptic segm annotaion (json)", "\n", "        ", "panoptic_json", "=", "[", "]", "#annotaion json", "\n", "pan_segm_folder", "=", "args", ".", "panoptic_det_file", ".", "split", "(", "'.'", ")", "[", "0", "]", "#segm files", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "pan_segm_folder", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "pan_segm_folder", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "timer", ".", "disable", "(", "'Load Data'", ")", "\n", "\n", "", "dataset_indices", "=", "list", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "\n", "\n", "if", "args", ".", "shuffle", ":", "\n", "        ", "random", ".", "shuffle", "(", "dataset_indices", ")", "\n", "", "elif", "not", "args", ".", "no_sort", ":", "\n", "# Do a deterministic shuffle based on the image ids", "\n", "#", "\n", "# I do this because on python 3.5 dictionary key order is *random*, while in 3.6 it's", "\n", "# the order of insertion. That means on python 3.6, the images come in the order they are in", "\n", "# in the annotations file. For some reason, the first images in the annotations file are", "\n", "# the hardest. To combat this, I use a hard-coded hash function based on the image ids", "\n", "# to shuffle the indices we use. That way, no matter what python version or how pycocotools", "\n", "# handles the data, we get the same result every time.", "\n", "        ", "hashed", "=", "[", "badhash", "(", "x", ")", "for", "x", "in", "dataset", ".", "ids", "]", "\n", "dataset_indices", ".", "sort", "(", "key", "=", "lambda", "x", ":", "hashed", "[", "x", "]", ")", "\n", "\n", "", "dataset_indices", "=", "dataset_indices", "[", ":", "dataset_size", "]", "\n", "\n", "try", ":", "\n", "# Main eval loop", "\n", "        ", "for", "it", ",", "image_idx", "in", "enumerate", "(", "dataset_indices", ")", ":", "\n", "            ", "timer", ".", "reset", "(", ")", "\n", "\n", "img", ",", "gt", ",", "gt_masks", ",", "gt_stuff_masks", ",", "h", ",", "w", ",", "num_crowd", "=", "dataset", ".", "pull_item", "(", "image_idx", ")", "\n", "\n", "\n", "# Test flag, do not upvote", "\n", "if", "cfg", ".", "mask_proto_debug", ":", "\n", "                ", "with", "open", "(", "'scripts/info.txt'", ",", "'w'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "str", "(", "dataset", ".", "ids", "[", "image_idx", "]", ")", ")", "\n", "", "np", ".", "save", "(", "'scripts/gt.npy'", ",", "gt_masks", ")", "\n", "\n", "", "batch", "=", "Variable", "(", "img", ".", "unsqueeze", "(", "0", ")", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "                ", "batch", "=", "batch", ".", "cuda", "(", ")", "\n", "\n", "", "with", "timer", ".", "env", "(", "'Network Extra'", ")", ":", "\n", "                ", "if", "not", "args", ".", "multiscale_test", "and", "not", "args", ".", "flip_test", ":", "\n", "                    ", "preds", "=", "net", "(", "batch", ")", "\n", "\n", "# Perform the meat of the operation here depending on our mode.", "\n", "", "", "if", "args", ".", "display", ":", "\n", "                ", "img_numpy", "=", "prep_panoptic_display", "(", "preds", ",", "frame", ",", "None", ",", "None", ",", "undo_transform", "=", "False", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ",", "alpha", "=", "args", ".", "alpha", ")", "\n", "\n", "", "else", ":", "\n", "                ", "if", "cfg", ".", "use_panoptic_head", ":", "\n", "                    ", "annotaion", "=", "prep_unified_result", "(", "preds", ",", "img", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ",", "h", ",", "w", ",", "dataset", ".", "ids", "[", "image_idx", "]", ",", "pan_segm_folder", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ")", "\n", "\n", "\n", "", "elif", "args", ".", "multiscale_test", ":", "\n", "                    ", "scales_x", "=", "[", "550", ",", "605", ",", "660", ",", "715", ",", "770", ",", "825", "]", "\n", "\n", "classes", "=", "[", "]", "\n", "scores", "=", "[", "]", "\n", "boxes", "=", "[", "]", "\n", "masks", "=", "[", "]", "\n", "stuff_masks", "=", "torch", ".", "zeros", "(", "cfg", ".", "stuff_num_classes", "-", "1", ",", "h", ",", "w", ")", "\n", "\n", "img_np", "=", "img", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "for", "s", "in", "scales_x", ":", "\n", "                        ", "img_resize", "=", "torch", ".", "from_numpy", "(", "cv2", ".", "resize", "(", "img_np", ",", "(", "s", ",", "s", ")", ")", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "batch", "=", "Variable", "(", "img_resize", ".", "unsqueeze", "(", "0", ")", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "                            ", "batch", "=", "batch", ".", "cuda", "(", ")", "\n", "\n", "", "preds", "=", "net", "(", "batch", ")", "\n", "\n", "post_results", "=", "postprocess_ins_sem", "(", "preds", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ",", "h", ",", "w", ")", "\n", "classes", "+=", "post_results", "[", "0", "]", "\n", "scores", "+=", "post_results", "[", "1", "]", "\n", "if", "post_results", "[", "2", "]", "is", "not", "None", ":", "\n", "                            ", "boxes", ".", "append", "(", "post_results", "[", "2", "]", ")", "\n", "masks", ".", "append", "(", "post_results", "[", "3", "]", ")", "\n", "", "stuff_masks", "+=", "post_results", "[", "4", "]", "\n", "\n", "", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "                        ", "masks", "=", "torch", ".", "zeros", "(", "0", ",", "h", ",", "w", ")", "\n", "boxes", "=", "torch", ".", "zeros", "(", "0", ",", "4", ")", "\n", "", "else", ":", "\n", "                        ", "masks", "=", "torch", ".", "cat", "(", "masks", ",", "dim", "=", "0", ")", "\n", "boxes", "=", "torch", ".", "cat", "(", "boxes", ",", "dim", "=", "0", ")", "\n", "\n", "", "stuff_masks", "=", "stuff_masks", "/", "len", "(", "scales_x", ")", "\n", "annotaion", "=", "merge_segmentation", "(", "classes", ",", "scores", ",", "boxes", ",", "masks", ",", "stuff_masks", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ",", "h", ",", "w", ",", "dataset", ".", "ids", "[", "image_idx", "]", ",", "pan_segm_folder", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ")", "\n", "\n", "", "elif", "args", ".", "flip_test", ":", "\n", "                    ", "classes", "=", "[", "]", "\n", "scores", "=", "[", "]", "\n", "boxes", "=", "[", "]", "\n", "masks", "=", "[", "]", "\n", "stuff_masks", "=", "torch", ".", "zeros", "(", "cfg", ".", "stuff_num_classes", "-", "1", ",", "h", ",", "w", ")", "\n", "\n", "flip", "=", "[", "0", ",", "1", "]", "\n", "for", "f", "in", "flip", ":", "\n", "                        ", "if", "f", ">", "0", ":", "\n", "                            ", "img_f", "=", "img", ".", "flip", "(", "dims", "=", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                            ", "img_f", "=", "img", "\n", "\n", "", "batch", "=", "Variable", "(", "img_f", ".", "unsqueeze", "(", "0", ")", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "                            ", "batch", "=", "batch", ".", "cuda", "(", ")", "\n", "\n", "", "preds", "=", "net", "(", "batch", ")", "\n", "\n", "post_results", "=", "postprocess_ins_sem", "(", "preds", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ",", "h", ",", "w", ")", "\n", "classes", "+=", "post_results", "[", "0", "]", "\n", "scores", "+=", "post_results", "[", "1", "]", "\n", "if", "post_results", "[", "2", "]", "is", "not", "None", ":", "\n", "                            ", "if", "f", ">", "0", ":", "\n", "                                ", "boxes_f", "=", "post_results", "[", "2", "]", ".", "clone", "(", ")", "\n", "boxes_f", "[", ":", ",", "0", "]", "=", "w", "-", "post_results", "[", "2", "]", "[", ":", ",", "2", "]", "\n", "boxes_f", "[", ":", ",", "2", "]", "=", "w", "-", "post_results", "[", "2", "]", "[", ":", ",", "0", "]", "\n", "masks_f", "=", "post_results", "[", "3", "]", ".", "flip", "(", "dims", "=", "[", "2", "]", ")", "\n", "boxes", ".", "append", "(", "boxes_f", ")", "\n", "masks", ".", "append", "(", "masks_f", ")", "\n", "stuff_masks", "+=", "post_results", "[", "4", "]", ".", "flip", "(", "dims", "=", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                                ", "boxes", ".", "append", "(", "post_results", "[", "2", "]", ")", "\n", "masks", ".", "append", "(", "post_results", "[", "3", "]", ")", "\n", "stuff_masks", "+=", "post_results", "[", "4", "]", "\n", "\n", "", "", "", "if", "len", "(", "masks", ")", "==", "0", ":", "\n", "                        ", "masks", "=", "torch", ".", "zeros", "(", "0", ",", "h", ",", "w", ")", "\n", "boxes", "=", "torch", ".", "zeros", "(", "0", ",", "4", ")", "\n", "", "else", ":", "\n", "                        ", "masks", "=", "torch", ".", "cat", "(", "masks", ",", "dim", "=", "0", ")", "\n", "boxes", "=", "torch", ".", "cat", "(", "boxes", ",", "dim", "=", "0", ")", "\n", "\n", "", "stuff_masks", "=", "stuff_masks", "/", "len", "(", "flip", ")", "\n", "annotaion", "=", "merge_segmentation", "(", "classes", ",", "scores", ",", "boxes", ",", "masks", ",", "stuff_masks", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ",", "h", ",", "w", ",", "dataset", ".", "ids", "[", "image_idx", "]", ",", "pan_segm_folder", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "annotaion", "=", "prep_panoptic_result", "(", "preds", ",", "img", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ",", "h", ",", "w", ",", "dataset", ".", "ids", "[", "image_idx", "]", ",", "pan_segm_folder", ",", "overlap_thr", "=", "args", ".", "overlap_threshold", ",", "stuff_area_limit", "=", "args", ".", "stuff_area_limit", ")", "\n", "\n", "\n", "", "if", "annotaion", "is", "None", "or", "len", "(", "annotaion", ")", "==", "0", ":", "\n", "                    ", "print", "(", "annotaion", ")", "\n", "print", "(", "'error!!'", ",", "dataset", ".", "pull_image_name", "(", "image_idx", ")", ")", "\n", "exit", "(", ")", "\n", "", "panoptic_json", ".", "append", "(", "annotaion", ")", "\n", "\n", "# First couple of images take longer because we're constructing the graph.", "\n", "# Since that's technically initialization, don't include those in the FPS calculations.", "\n", "", "if", "it", ">", "1", ":", "\n", "                ", "frame_times", ".", "add", "(", "timer", ".", "total_time", "(", ")", ")", "\n", "\n", "", "if", "args", ".", "display", ":", "\n", "                ", "if", "it", ">", "1", ":", "\n", "                    ", "print", "(", "'Avg FPS: %.4f'", "%", "(", "1", "/", "frame_times", ".", "get_avg", "(", ")", ")", ")", "\n", "", "plt", ".", "imsave", "(", "'results/{}.png'", ".", "format", "(", "str", "(", "dataset", ".", "ids", "[", "image_idx", "]", ")", ")", ",", "img_numpy", ")", "\n", "# plt.imshow(img_numpy)", "\n", "# plt.title(str(dataset.ids[image_idx]))", "\n", "# plt.show()", "\n", "", "elif", "not", "args", ".", "no_bar", ":", "\n", "                ", "if", "it", ">", "1", ":", "fps", "=", "1", "/", "frame_times", ".", "get_avg", "(", ")", "\n", "else", ":", "fps", "=", "0", "\n", "progress", "=", "(", "it", "+", "1", ")", "/", "dataset_size", "*", "100", "\n", "progress_bar", ".", "set_val", "(", "it", "+", "1", ")", "\n", "print", "(", "'\\rProcessing Images  %s %6d / %6d (%5.2f%%)    %5.2f fps        '", "\n", "%", "(", "repr", "(", "progress_bar", ")", ",", "it", "+", "1", ",", "dataset_size", ",", "progress", ",", "fps", ")", ",", "end", "=", "''", ")", "\n", "\n", "\n", "\n", "", "", "if", "not", "args", ".", "display", ":", "\n", "            ", "print", "(", ")", "\n", "print", "(", "'Dumping detections...'", ")", "\n", "with", "open", "(", "cfg", ".", "dataset", ".", "valid_info", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "coco_d", "=", "json", ".", "load", "(", "f", ")", "\n", "", "coco_d", "[", "'annotations'", "]", "=", "panoptic_json", "\n", "coco_d", "[", "'categories'", "]", "=", "list", "(", "pan_categories", ".", "values", "(", ")", ")", "\n", "with", "open", "(", "args", ".", "panoptic_det_file", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "coco_d", ",", "f", ")", "\n", "\n", "\n", "\n", "", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'Stopping...'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.calc_map": [[1050, 1074], ["print", "range", "panoptic_eval.print_maps", "len", "range", "collections.OrderedDict", "collections.OrderedDict", "enumerate", "len", "sum", "all_maps[].values", "len", "ap_obj.is_empty", "[].append", "len", "int", "all_maps[].values", "ap_obj.get_ap", "sum", "len"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.print_maps", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "", "def", "calc_map", "(", "ap_data", ")", ":", "\n", "    ", "print", "(", "'Calculating mAP...'", ")", "\n", "aps", "=", "[", "{", "'box'", ":", "[", "]", ",", "'mask'", ":", "[", "]", "}", "for", "_", "in", "iou_thresholds", "]", "\n", "\n", "for", "_class", "in", "range", "(", "len", "(", "cfg", ".", "dataset", ".", "class_names", ")", ")", ":", "\n", "        ", "for", "iou_idx", "in", "range", "(", "len", "(", "iou_thresholds", ")", ")", ":", "\n", "            ", "for", "iou_type", "in", "(", "'box'", ",", "'mask'", ")", ":", "\n", "                ", "ap_obj", "=", "ap_data", "[", "iou_type", "]", "[", "iou_idx", "]", "[", "_class", "]", "\n", "\n", "if", "not", "ap_obj", ".", "is_empty", "(", ")", ":", "\n", "                    ", "aps", "[", "iou_idx", "]", "[", "iou_type", "]", ".", "append", "(", "ap_obj", ".", "get_ap", "(", ")", ")", "\n", "\n", "", "", "", "", "all_maps", "=", "{", "'box'", ":", "OrderedDict", "(", ")", ",", "'mask'", ":", "OrderedDict", "(", ")", "}", "\n", "\n", "# Looking back at it, this code is really hard to read :/", "\n", "for", "iou_type", "in", "(", "'box'", ",", "'mask'", ")", ":", "\n", "        ", "all_maps", "[", "iou_type", "]", "[", "'all'", "]", "=", "0", "# Make this first in the ordereddict", "\n", "for", "i", ",", "threshold", "in", "enumerate", "(", "iou_thresholds", ")", ":", "\n", "            ", "mAP", "=", "sum", "(", "aps", "[", "i", "]", "[", "iou_type", "]", ")", "/", "len", "(", "aps", "[", "i", "]", "[", "iou_type", "]", ")", "*", "100", "if", "len", "(", "aps", "[", "i", "]", "[", "iou_type", "]", ")", ">", "0", "else", "0", "\n", "all_maps", "[", "iou_type", "]", "[", "int", "(", "threshold", "*", "100", ")", "]", "=", "mAP", "\n", "", "all_maps", "[", "iou_type", "]", "[", "'all'", "]", "=", "(", "sum", "(", "all_maps", "[", "iou_type", "]", ".", "values", "(", ")", ")", "/", "(", "len", "(", "all_maps", "[", "iou_type", "]", ".", "values", "(", ")", ")", "-", "1", ")", ")", "\n", "\n", "", "print_maps", "(", "all_maps", ")", "\n", "return", "all_maps", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.print_maps": [[1075, 1087], ["print", "print", "print", "print", "print", "make_row", "make_sep", "print", "make_sep", "tuple", "make_row", "len", "len", "len", "isinstance", "all_maps[].keys", "all_maps[].values"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "def", "print_maps", "(", "all_maps", ")", ":", "\n", "# Warning: hacky ", "\n", "    ", "make_row", "=", "lambda", "vals", ":", "(", "' %5s |'", "*", "len", "(", "vals", ")", ")", "%", "tuple", "(", "vals", ")", "\n", "make_sep", "=", "lambda", "n", ":", "(", "'-------+'", "*", "n", ")", "\n", "\n", "print", "(", ")", "\n", "print", "(", "make_row", "(", "[", "''", "]", "+", "[", "(", "'.%d '", "%", "x", "if", "isinstance", "(", "x", ",", "int", ")", "else", "x", "+", "' '", ")", "for", "x", "in", "all_maps", "[", "'box'", "]", ".", "keys", "(", ")", "]", ")", ")", "\n", "print", "(", "make_sep", "(", "len", "(", "all_maps", "[", "'box'", "]", ")", "+", "1", ")", ")", "\n", "for", "iou_type", "in", "(", "'box'", ",", "'mask'", ")", ":", "\n", "        ", "print", "(", "make_row", "(", "[", "iou_type", "]", "+", "[", "'%.2f'", "%", "x", "for", "x", "in", "all_maps", "[", "iou_type", "]", ".", "values", "(", ")", "]", ")", ")", "\n", "", "print", "(", "make_sep", "(", "len", "(", "all_maps", "[", "'box'", "]", ")", "+", "1", ")", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.ScatterWrapper.__init__": [[104, 110], ["len", "isinstance", "print"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["def", "__init__", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "for", "arg", "in", "args", ":", "\n", "            ", "if", "not", "isinstance", "(", "arg", ",", "list", ")", ":", "\n", "                ", "print", "(", "'Warning: ScatterWrapper got input of non-list type.'", ")", "\n", "", "", "self", ".", "args", "=", "args", "\n", "self", ".", "batch_size", "=", "len", "(", "args", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.ScatterWrapper.make_mask": [[111, 115], ["torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long.cuda", "torch.Tensor().long.cuda", "torch.Tensor().long.cuda", "torch.Tensor().long.cuda", "torch.Tensor().long.cuda", "torch.Tensor().long.cuda", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "list", "range"], "methods", ["None"], ["", "def", "make_mask", "(", "self", ")", ":", "\n", "        ", "out", "=", "torch", ".", "Tensor", "(", "list", "(", "range", "(", "self", ".", "batch_size", ")", ")", ")", ".", "long", "(", ")", "\n", "if", "args", ".", "cuda", ":", "return", "out", ".", "cuda", "(", ")", "\n", "else", ":", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.ScatterWrapper.get_args": [[116, 129], ["zip", "int", "isinstance", "out.append", "x.to.to.to"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "get_args", "(", "self", ",", "mask", ")", ":", "\n", "        ", "device", "=", "mask", ".", "device", "\n", "mask", "=", "[", "int", "(", "x", ")", "for", "x", "in", "mask", "]", "\n", "out_args", "=", "[", "[", "]", "for", "_", "in", "self", ".", "args", "]", "\n", "\n", "for", "out", ",", "arg", "in", "zip", "(", "out_args", ",", "self", ".", "args", ")", ":", "\n", "            ", "for", "idx", "in", "mask", ":", "\n", "                ", "x", "=", "arg", "[", "idx", "]", "\n", "if", "isinstance", "(", "x", ",", "torch", ".", "Tensor", ")", ":", "\n", "                    ", "x", "=", "x", ".", "to", "(", "device", ")", "\n", "", "out", ".", "append", "(", "x", ")", "\n", "\n", "", "", "return", "out_args", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.str2bool": [[27, 29], ["v.lower"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "    ", "return", "v", ".", "lower", "(", ")", "in", "(", "\"yes\"", ",", "\"true\"", ",", "\"t\"", ",", "\"1\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.replace": [[83, 85], ["getattr", "setattr", "getattr"], "function", ["None"], ["", "def", "replace", "(", "name", ")", ":", "\n", "    ", "if", "getattr", "(", "args", ",", "name", ")", "==", "None", ":", "setattr", "(", "args", ",", "name", ",", "getattr", "(", "cfg", ",", "name", ")", ")", "\n", "", "replace", "(", "'lr'", ")", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.train": [[132, 330], ["data.coco.COCOPanoptic", "epsnet.EPSNet", "nn.DataParallel().cuda.train", "utils.timer.disable_all", "torch.SGD", "layers.modules.MultiBoxLoss", "max", "time.time", "math.ceil", "torch.DataLoader", "utils.functions.MovingAverage", "print", "print", "epsnet.EPSNet.save_weights", "os.path.exists", "os.mkdir", "train.setup_eval", "data.coco.COCOPanoptic", "utils.functions.SavePath.get_interrupt", "print", "epsnet.EPSNet.load_weights", "print", "epsnet.EPSNet.init_weights", "nn.DataParallel().cuda.parameters", "torch.DataParallel().cuda", "torch.DataParallel().cuda", "len", "utils.functions.SavePath().get_path", "utils.functions.MovingAverage", "range", "save_path", "utils.augmentations.SSDAugmentation", "utils.functions.SavePath.get_latest", "print", "utils.functions.SavePath.remove_interrupt", "epsnet.EPSNet.save_weights", "exit", "utils.augmentations.BaseTransform", "utils.functions.SavePath.from_str", "torch.DataParallel", "torch.DataParallel", "utils.functions.SavePath", "train.prepare_data", "nn.DataParallel().cuda.", "optim.SGD.zero_grad", "train.ScatterWrapper", "nn.DataParallel().cuda.", "sum", "sum.backward", "torch.isfinite().item", "torch.isfinite().item", "torch.isfinite().item", "torch.isfinite().item", "torch.isfinite().item", "torch.isfinite().item", "time.time", "save_path", "train.set_lr", "train.set_lr", "train.ScatterWrapper.make_mask", "v.mean", "optim.SGD.step", "loss_avgs[].add", "utils.functions.MovingAverage.add", "sum", "sum", "print", "print", "epsnet.EPSNet.save_weights", "train.compute_validation_map", "cfg.replace", "len", "criterion.items", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "torch.isfinite", "losses[].item", "str().split", "open", "f.write", "utils.functions.SavePath.get_latest", "save_path", "repr", "avg.reset", "loss_avgs[].get_avg", "tuple", "print", "os.remove", "str", "loss_avgs[].get_avg", "tuple", "datetime.timedelta", "len", "len", "utils.functions.MovingAverage.get_avg"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.train", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.disable_all", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.save_weights", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.setup_eval", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_interrupt", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.load_weights", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.init_weights", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_path", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_latest", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.remove_interrupt", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.save_weights", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.from_str", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.prepare_data", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.set_lr", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.set_lr", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.ScatterWrapper.make_mask", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.step", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.save_weights", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.compute_validation_map", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_latest", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.reset", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg"], ["", "", "def", "train", "(", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "save_folder", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "args", ".", "save_folder", ")", "\n", "", "dataset", "=", "COCOPanoptic", "(", "image_path", "=", "cfg", ".", "dataset", ".", "train_images", ",", "\n", "info_file", "=", "cfg", ".", "dataset", ".", "train_info", ",", "\n", "pan_folder", "=", "None", ",", "\n", "transform", "=", "SSDAugmentation", "(", "MEANS", ")", ")", "\n", "\n", "\n", "if", "args", ".", "validation_epoch", ">", "0", ":", "\n", "        ", "setup_eval", "(", ")", "\n", "val_dataset", "=", "COCOPanoptic", "(", "image_path", "=", "cfg", ".", "dataset", ".", "valid_images", ",", "\n", "info_file", "=", "cfg", ".", "dataset", ".", "valid_info", ",", "\n", "pan_folder", "=", "None", ",", "\n", "transform", "=", "BaseTransform", "(", "MEANS", ")", ")", "\n", "\n", "# Parallel wraps the underlying module, but when saving and loading we don't want that", "\n", "", "epsnet", "=", "EPSNet", "(", ")", "\n", "net", "=", "epsnet", "\n", "net", ".", "train", "(", ")", "\n", "\n", "# I don't use the timer during training (I use a different timing method).", "\n", "# Apparently there's a race condition with multiple GPUs.", "\n", "timer", ".", "disable_all", "(", ")", "\n", "\n", "# Both of these can set args.resume to None, so do them before the check    ", "\n", "if", "args", ".", "resume", "==", "'interrupt'", ":", "\n", "        ", "args", ".", "resume", "=", "SavePath", ".", "get_interrupt", "(", "args", ".", "save_folder", ")", "\n", "", "elif", "args", ".", "resume", "==", "'latest'", ":", "\n", "        ", "args", ".", "resume", "=", "SavePath", ".", "get_latest", "(", "args", ".", "save_folder", ",", "cfg", ".", "name", ")", "\n", "\n", "", "if", "args", ".", "resume", "is", "not", "None", ":", "\n", "        ", "print", "(", "'Resuming training, loading {}...'", ".", "format", "(", "args", ".", "resume", ")", ")", "\n", "epsnet", ".", "load_weights", "(", "args", ".", "resume", ")", "\n", "\n", "if", "args", ".", "start_iter", "==", "-", "1", ":", "\n", "            ", "args", ".", "start_iter", "=", "SavePath", ".", "from_str", "(", "args", ".", "resume", ")", ".", "iteration", "\n", "", "", "else", ":", "\n", "        ", "print", "(", "'Initializing weights...'", ")", "\n", "epsnet", ".", "init_weights", "(", "backbone_path", "=", "args", ".", "save_folder", "+", "cfg", ".", "backbone", ".", "path", ")", "\n", "\n", "", "optimizer", "=", "optim", ".", "SGD", "(", "net", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ",", "momentum", "=", "args", ".", "momentum", ",", "\n", "weight_decay", "=", "args", ".", "decay", ")", "\n", "criterion", "=", "MultiBoxLoss", "(", "num_classes", "=", "cfg", ".", "num_classes", ",", "\n", "pos_threshold", "=", "cfg", ".", "positive_iou_threshold", ",", "\n", "neg_threshold", "=", "cfg", ".", "negative_iou_threshold", ",", "\n", "negpos_ratio", "=", "3", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "cudnn", ".", "benchmark", "=", "True", "\n", "net", "=", "nn", ".", "DataParallel", "(", "net", ")", ".", "cuda", "(", ")", "\n", "criterion", "=", "nn", ".", "DataParallel", "(", "criterion", ")", ".", "cuda", "(", ")", "\n", "\n", "# loss counters", "\n", "", "loc_loss", "=", "0", "\n", "conf_loss", "=", "0", "\n", "iteration", "=", "max", "(", "args", ".", "start_iter", ",", "0", ")", "\n", "last_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "epoch_size", "=", "len", "(", "dataset", ")", "//", "args", ".", "batch_size", "\n", "num_epochs", "=", "math", ".", "ceil", "(", "cfg", ".", "max_iter", "/", "epoch_size", ")", "\n", "\n", "# Which learning rate adjustment step are we on? lr' = lr * gamma ^ step_index", "\n", "step_index", "=", "0", "\n", "\n", "data_loader", "=", "data", ".", "DataLoader", "(", "dataset", ",", "args", ".", "batch_size", ",", "\n", "num_workers", "=", "0", ",", "\n", "shuffle", "=", "True", ",", "collate_fn", "=", "detection_collate", ",", "\n", "pin_memory", "=", "True", ")", "\n", "\n", "\n", "save_path", "=", "lambda", "epoch", ",", "iteration", ":", "SavePath", "(", "cfg", ".", "name", ",", "epoch", ",", "iteration", ")", ".", "get_path", "(", "root", "=", "args", ".", "save_folder", ")", "\n", "time_avg", "=", "MovingAverage", "(", ")", "\n", "\n", "global", "loss_types", "# Forms the print order", "\n", "loss_avgs", "=", "{", "k", ":", "MovingAverage", "(", "100", ")", "for", "k", "in", "loss_types", "}", "\n", "\n", "print", "(", "'Begin training!'", ")", "\n", "print", "(", ")", "\n", "# try-except so you can use ctrl+c to save early and stop training", "\n", "try", ":", "\n", "        ", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "# Resume from start_iter", "\n", "            ", "if", "(", "epoch", "+", "1", ")", "*", "epoch_size", "<", "iteration", ":", "\n", "                ", "continue", "\n", "\n", "\n", "", "for", "datum", "in", "data_loader", ":", "\n", "# Stop if we've reached an epoch if we're resuming from start_iter", "\n", "                ", "if", "datum", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "if", "iteration", "==", "(", "epoch", "+", "1", ")", "*", "epoch_size", ":", "\n", "                    ", "break", "\n", "\n", "# Stop at the configured number of iterations even if mid-epoch", "\n", "", "if", "iteration", "==", "cfg", ".", "max_iter", ":", "\n", "                    ", "break", "\n", "\n", "# Change a config setting if we've reached the specified iteration", "\n", "", "changed", "=", "False", "\n", "for", "change", "in", "cfg", ".", "delayed_settings", ":", "\n", "                    ", "if", "iteration", ">=", "change", "[", "0", "]", ":", "\n", "                        ", "changed", "=", "True", "\n", "cfg", ".", "replace", "(", "change", "[", "1", "]", ")", "\n", "\n", "# Reset the loss averages because things might have changed", "\n", "for", "avg", "in", "loss_avgs", ":", "\n", "                            ", "avg", ".", "reset", "(", ")", "\n", "\n", "# If a config setting was changed, remove it from the list so we don't keep checking", "\n", "", "", "", "if", "changed", ":", "\n", "                    ", "cfg", ".", "delayed_settings", "=", "[", "x", "for", "x", "in", "cfg", ".", "delayed_settings", "if", "x", "[", "0", "]", ">", "iteration", "]", "\n", "\n", "# Warm up by linearly interpolating the learning rate from some smaller value", "\n", "", "if", "cfg", ".", "lr_warmup_until", ">", "0", "and", "iteration", "<=", "cfg", ".", "lr_warmup_until", ":", "\n", "                    ", "set_lr", "(", "optimizer", ",", "(", "args", ".", "lr", "-", "cfg", ".", "lr_warmup_init", ")", "*", "(", "iteration", "/", "cfg", ".", "lr_warmup_until", ")", "+", "cfg", ".", "lr_warmup_init", ")", "\n", "\n", "# Adjust the learning rate at the given iterations, but also if we resume from past that iteration", "\n", "", "while", "step_index", "<", "len", "(", "cfg", ".", "lr_steps", ")", "and", "iteration", ">=", "cfg", ".", "lr_steps", "[", "step_index", "]", ":", "\n", "                    ", "step_index", "+=", "1", "\n", "set_lr", "(", "optimizer", ",", "args", ".", "lr", "*", "(", "args", ".", "gamma", "**", "step_index", ")", ")", "\n", "\n", "# Load training data", "\n", "# Note, for training on multiple gpus this will use the custom replicate and gather I wrote up there", "\n", "", "images", ",", "targets", ",", "masks_thing", ",", "masks_stuff", ",", "num_crowds", "=", "prepare_data", "(", "datum", ")", "\n", "# Forward Pass", "\n", "out", "=", "net", "(", "images", ")", "\n", "\n", "# Compute Loss", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "wrapper", "=", "ScatterWrapper", "(", "targets", ",", "masks_thing", ",", "masks_stuff", ",", "num_crowds", ")", "\n", "\n", "losses", "=", "criterion", "(", "out", ",", "wrapper", ",", "wrapper", ".", "make_mask", "(", ")", ")", "\n", "\n", "if", "losses", "is", "None", ":", "\n", "                    ", "continue", "\n", "\n", "", "losses", "=", "{", "k", ":", "v", ".", "mean", "(", ")", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", "}", "# Mean here because Dataparallel", "\n", "loss", "=", "sum", "(", "[", "losses", "[", "k", "]", "for", "k", "in", "losses", "]", ")", "\n", "\n", "# Backprop", "\n", "loss", ".", "backward", "(", ")", "# Do this to free up vram even if loss is not finite", "\n", "if", "torch", ".", "isfinite", "(", "loss", ")", ".", "item", "(", ")", ":", "\n", "                    ", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Add the loss to the moving average for bookkeeping", "\n", "", "for", "k", "in", "losses", ":", "\n", "                    ", "loss_avgs", "[", "k", "]", ".", "add", "(", "losses", "[", "k", "]", ".", "item", "(", ")", ")", "\n", "\n", "", "cur_time", "=", "time", ".", "time", "(", ")", "\n", "elapsed", "=", "cur_time", "-", "last_time", "\n", "last_time", "=", "cur_time", "\n", "\n", "# Exclude graph setup from the timing information", "\n", "if", "iteration", "!=", "args", ".", "start_iter", ":", "\n", "                    ", "time_avg", ".", "add", "(", "elapsed", ")", "\n", "\n", "", "if", "iteration", "%", "10", "==", "0", ":", "\n", "                    ", "eta_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "(", "cfg", ".", "max_iter", "-", "iteration", ")", "*", "time_avg", ".", "get_avg", "(", ")", ")", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "\n", "total", "=", "sum", "(", "[", "loss_avgs", "[", "k", "]", ".", "get_avg", "(", ")", "for", "k", "in", "losses", "]", ")", "\n", "loss_labels", "=", "sum", "(", "[", "[", "k", ",", "loss_avgs", "[", "k", "]", ".", "get_avg", "(", ")", "]", "for", "k", "in", "loss_types", "if", "k", "in", "losses", "]", ",", "[", "]", ")", "\n", "with", "open", "(", "args", ".", "log_path", ",", "'a+'", ")", "as", "f", ":", "\n", "                        ", "f", ".", "write", "(", "(", "'[%3d] %7d ||'", "+", "(", "' %s: %.3f |'", "*", "len", "(", "losses", ")", ")", "+", "' T: %.3f || ETA: %s || timer: %.3f\\n'", ")", "\n", "%", "tuple", "(", "[", "epoch", ",", "iteration", "]", "+", "loss_labels", "+", "[", "total", ",", "eta_str", ",", "elapsed", "]", ")", ")", "\n", "", "print", "(", "(", "'[%3d] %7d ||'", "+", "(", "' %s: %.3f |'", "*", "len", "(", "losses", ")", ")", "+", "' T: %.3f || ETA: %s || timer: %.3f'", ")", "\n", "%", "tuple", "(", "[", "epoch", ",", "iteration", "]", "+", "loss_labels", "+", "[", "total", ",", "eta_str", ",", "elapsed", "]", ")", ",", "flush", "=", "True", ")", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "if", "iteration", "%", "args", ".", "save_interval", "==", "0", "and", "iteration", "!=", "args", ".", "start_iter", ":", "\n", "                    ", "if", "args", ".", "keep_latest", ":", "\n", "                        ", "latest", "=", "SavePath", ".", "get_latest", "(", "args", ".", "save_folder", ",", "cfg", ".", "name", ")", "\n", "\n", "", "print", "(", "'Saving state, iter:'", ",", "iteration", ")", "\n", "epsnet", ".", "save_weights", "(", "save_path", "(", "epoch", ",", "iteration", ")", ")", "\n", "\n", "if", "args", ".", "keep_latest", "and", "latest", "is", "not", "None", ":", "\n", "                        ", "if", "args", ".", "keep_latest_interval", "<=", "0", "or", "iteration", "%", "args", ".", "keep_latest_interval", "!=", "args", ".", "save_interval", ":", "\n", "                            ", "print", "(", "'Deleting old save...'", ")", "\n", "os", ".", "remove", "(", "latest", ")", "\n", "\n", "# This is done per epoch", "\n", "", "", "", "", "if", "args", ".", "validation_epoch", ">", "0", ":", "\n", "                ", "if", "epoch", "%", "args", ".", "validation_epoch", "==", "0", "and", "epoch", ">", "0", ":", "\n", "                    ", "compute_validation_map", "(", "epsnet", ",", "val_dataset", ")", "\n", "", "", "", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "print", "(", "'Stopping early. Saving network...'", ")", "\n", "\n", "# Delete previous copy of the interrupted network so we don't spam the weights folder", "\n", "SavePath", ".", "remove_interrupt", "(", "args", ".", "save_folder", ")", "\n", "\n", "epsnet", ".", "save_weights", "(", "save_path", "(", "epoch", ",", "repr", "(", "iteration", ")", "+", "'_interrupt'", ")", ")", "\n", "exit", "(", ")", "\n", "\n", "", "epsnet", ".", "save_weights", "(", "save_path", "(", "epoch", ",", "iteration", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.set_lr": [[332, 335], ["None"], "function", ["None"], ["", "def", "set_lr", "(", "optimizer", ",", "new_lr", ")", ":", "\n", "    ", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "param_group", "[", "'lr'", "]", "=", "new_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.prepare_data": [[337, 353], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable.cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "ann.cuda", "mask.cuda", "mask.cuda"], "function", ["None"], ["", "", "def", "prepare_data", "(", "datum", ")", ":", "\n", "    ", "images", ",", "(", "targets", ",", "masks_thing", ",", "masks_stuff", ",", "num_crowds", ")", "=", "datum", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "images", "=", "Variable", "(", "images", ".", "cuda", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "targets", "=", "[", "Variable", "(", "ann", ".", "cuda", "(", ")", ",", "requires_grad", "=", "False", ")", "for", "ann", "in", "targets", "]", "\n", "masks_thing", "=", "[", "Variable", "(", "mask", ".", "cuda", "(", ")", ",", "requires_grad", "=", "False", ")", "for", "mask", "in", "masks_thing", "]", "\n", "masks_stuff", "=", "[", "Variable", "(", "mask", ".", "cuda", "(", ")", ",", "requires_grad", "=", "False", ")", "for", "mask", "in", "masks_stuff", "]", "\n", "", "else", ":", "\n", "        ", "images", "=", "Variable", "(", "images", ",", "requires_grad", "=", "False", ")", "\n", "targets", "=", "[", "Variable", "(", "ann", ",", "requires_grad", "=", "False", ")", "for", "ann", "in", "targets", "]", "\n", "masks_thing", "=", "[", "Variable", "(", "mask", ",", "requires_grad", "=", "False", ")", "for", "mask", "in", "masks_thing", "]", "\n", "masks_stuff", "=", "[", "Variable", "(", "mask", ",", "requires_grad", "=", "False", ")", "for", "mask", "in", "masks_stuff", "]", "\n", "\n", "\n", "", "return", "images", ",", "targets", ",", "masks_thing", ",", "masks_stuff", ",", "num_crowds", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.compute_validation_loss": [[354, 386], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "sum", "print", "train.prepare_data", "net", "train.ScatterWrapper", "criterion", "criterion.items", "train.ScatterWrapper.make_mask", "v.mean().item.mean().item", "tuple", "v.mean().item.mean", "len"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.prepare_data", "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.ScatterWrapper.make_mask"], ["", "def", "compute_validation_loss", "(", "net", ",", "data_loader", ",", "criterion", ")", ":", "\n", "    ", "global", "loss_types", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "losses", "=", "{", "}", "\n", "\n", "# Don't switch to eval mode because we want to get losses", "\n", "iterations", "=", "0", "\n", "for", "datum", "in", "data_loader", ":", "\n", "            ", "images", ",", "targets", ",", "masks", ",", "num_crowds", "=", "prepare_data", "(", "datum", ")", "\n", "out", "=", "net", "(", "images", ")", "\n", "\n", "wrapper", "=", "ScatterWrapper", "(", "targets", ",", "masks", ",", "num_crowds", ")", "\n", "_losses", "=", "criterion", "(", "out", ",", "wrapper", ",", "wrapper", ".", "make_mask", "(", ")", ")", "\n", "\n", "for", "k", ",", "v", "in", "_losses", ".", "items", "(", ")", ":", "\n", "                ", "v", "=", "v", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "if", "k", "in", "losses", ":", "\n", "                    ", "losses", "[", "k", "]", "+=", "v", "\n", "", "else", ":", "\n", "                    ", "losses", "[", "k", "]", "=", "v", "\n", "\n", "", "", "iterations", "+=", "1", "\n", "if", "args", ".", "validation_size", "<=", "iterations", "*", "args", ".", "batch_size", ":", "\n", "                ", "break", "\n", "\n", "", "", "for", "k", "in", "losses", ":", "\n", "            ", "losses", "[", "k", "]", "/=", "iterations", "\n", "\n", "\n", "", "loss_labels", "=", "sum", "(", "[", "[", "k", ",", "losses", "[", "k", "]", "]", "for", "k", "in", "loss_types", "if", "k", "in", "losses", "]", ",", "[", "]", ")", "\n", "print", "(", "(", "'Validation ||'", "+", "(", "' %s: %.3f |'", "*", "len", "(", "losses", ")", ")", "+", "')'", ")", "%", "tuple", "(", "loss_labels", ")", ",", "flush", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.compute_validation_map": [[387, 394], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "epsnet.eval", "print", "print", "eval_script.evaluate", "epsnet.train"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.evaluate", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.train"], ["", "", "def", "compute_validation_map", "(", "epsnet", ",", "dataset", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "epsnet", ".", "eval", "(", ")", "\n", "print", "(", ")", "\n", "print", "(", "\"Computing validation mAP (this may take a while)...\"", ",", "flush", "=", "True", ")", "\n", "eval_script", ".", "evaluate", "(", "epsnet", ",", "dataset", ",", "train_mode", "=", "True", ")", "\n", "epsnet", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.train.setup_eval": [[395, 397], ["eval_script.parse_args", "str"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.parse_args"], ["", "", "def", "setup_eval", "(", ")", ":", "\n", "    ", "eval_script", ".", "parse_args", "(", "[", "'--no_bar'", ",", "'--max_images='", "+", "str", "(", "args", ".", "validation_size", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.Bottleneck.__init__": [[17, 36], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "norm_layer", "norm_layer", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "DCN", "backbone.Bottleneck.conv2.bias.data.zero_", "backbone.Bottleneck.conv2.conv_offset_mask.weight.data.zero_", "backbone.Bottleneck.conv2.conv_offset_mask.bias.data.zero_", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ",", "dilation", "=", "1", ",", "use_dcn", "=", "False", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ",", "dilation", "=", "dilation", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "planes", ")", "\n", "if", "use_dcn", ":", "\n", "            ", "self", ".", "conv2", "=", "DCN", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ",", "deformable_groups", "=", "1", ")", "\n", "self", ".", "conv2", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv2", ".", "conv_offset_mask", ".", "weight", ".", "data", ".", "zero_", "(", ")", "\n", "self", ".", "conv2", ".", "conv_offset_mask", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", ",", "bias", "=", "False", ",", "dilation", "=", "dilation", ")", "\n", "", "self", ".", "bn2", "=", "norm_layer", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ",", "dilation", "=", "dilation", ")", "\n", "self", ".", "bn3", "=", "norm_layer", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.Bottleneck.forward": [[37, 58], ["backbone.Bottleneck.conv1", "backbone.Bottleneck.bn1", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv2", "backbone.Bottleneck.bn2", "backbone.Bottleneck.relu", "backbone.Bottleneck.conv3", "backbone.Bottleneck.bn3", "backbone.Bottleneck.relu", "backbone.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackbone.__init__": [[63, 92], ["torch.Module.__init__", "len", "torch.ModuleList", "torch.ModuleList", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone._make_layer", "backbone.ResNetBackbone.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer"], ["def", "__init__", "(", "self", ",", "layers", ",", "dcn_layers", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", ",", "dcn_interval", "=", "1", ",", "atrous_layers", "=", "[", "]", ",", "block", "=", "Bottleneck", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# These will be populated by _make_layer", "\n", "self", ".", "num_base_layers", "=", "len", "(", "layers", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "channels", "=", "[", "]", "\n", "self", ".", "norm_layer", "=", "norm_layer", "\n", "self", ".", "dilation", "=", "1", "\n", "self", ".", "atrous_layers", "=", "atrous_layers", "\n", "\n", "# From torchvision.models.resnet.Resnet", "\n", "self", ".", "inplanes", "=", "64", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "norm_layer", "(", "64", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "\n", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ",", "dcn_layers", "=", "dcn_layers", "[", "0", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ",", "dcn_layers", "=", "dcn_layers", "[", "1", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ",", "dcn_layers", "=", "dcn_layers", "[", "2", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ",", "dcn_layers", "=", "dcn_layers", "[", "3", "]", ",", "dcn_interval", "=", "dcn_interval", ")", "\n", "\n", "# This contains every module that should be initialized by loading in pretrained weights.", "\n", "# Any extra layers added onto this that won't be initialized by init_backbone will not be", "\n", "# in this list. That way, Yolact::init_weights knows which backbone weights to initialize", "\n", "# with xavier, and which ones to leave alone.", "\n", "self", ".", "backbone_modules", "=", "[", "m", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackbone._make_layer": [[94, 125], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "backbone.ResNetBackbone.channels.append", "backbone.ResNetBackbone.layers.append", "torch.Sequential", "torch.Sequential", "block", "layers.append", "len", "torch.Conv2d", "torch.Conv2d", "backbone.ResNetBackbone.norm_layer", "block"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ",", "dcn_layers", "=", "0", ",", "dcn_interval", "=", "1", ")", ":", "\n", "        ", "\"\"\" Here one layer means a string of n Bottleneck blocks. \"\"\"", "\n", "downsample", "=", "None", "\n", "\n", "# This is actually just to create the connection between layers, and not necessarily to", "\n", "# downsample. Even if the second condition is met, it only downsamples when stride != 1", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "if", "len", "(", "self", ".", "layers", ")", "in", "self", ".", "atrous_layers", ":", "\n", "                ", "self", ".", "dilation", "+=", "1", "\n", "stride", "=", "1", "\n", "\n", "", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ",", "\n", "dilation", "=", "self", ".", "dilation", ")", ",", "\n", "self", ".", "norm_layer", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "use_dcn", "=", "(", "dcn_layers", ">=", "blocks", ")", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ",", "self", ".", "norm_layer", ",", "self", ".", "dilation", ",", "use_dcn", "=", "use_dcn", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "use_dcn", "=", "(", "(", "i", "+", "dcn_layers", ")", ">=", "blocks", ")", "and", "(", "i", "%", "dcn_interval", "==", "0", ")", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "norm_layer", "=", "self", ".", "norm_layer", ",", "use_dcn", "=", "use_dcn", ")", ")", "\n", "", "layer", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "self", ".", "channels", ".", "append", "(", "planes", "*", "block", ".", "expansion", ")", "\n", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "\n", "return", "layer", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackbone.forward": [[126, 140], ["backbone.ResNetBackbone.conv1", "backbone.ResNetBackbone.bn1", "backbone.ResNetBackbone.relu", "backbone.ResNetBackbone.maxpool", "tuple", "layer", "outs.append"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Returns a list of convouts for each layer. \"\"\"", "\n", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackbone.init_backbone": [[141, 155], ["torch.load", "torch.load", "torch.load", "torch.load", "list", "backbone.ResNetBackbone.load_state_dict", "key.startswith", "int", "torch.load.pop", "torch.load.pop", "str"], "methods", ["None"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Initializes the backbone weights for training. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "\n", "\n", "# Replace layer1 -> layers.0 etc.", "\n", "keys", "=", "list", "(", "state_dict", ")", "\n", "for", "key", "in", "keys", ":", "\n", "            ", "if", "key", ".", "startswith", "(", "'layer'", ")", ":", "\n", "                ", "idx", "=", "int", "(", "key", "[", "5", "]", ")", "\n", "new_key", "=", "'layers.'", "+", "str", "(", "idx", "-", "1", ")", "+", "key", "[", "6", ":", "]", "\n", "state_dict", "[", "new_key", "]", "=", "state_dict", ".", "pop", "(", "key", ")", "\n", "\n", "# Note: Using strict=False is berry scary. Triple check this.", "\n", "", "", "self", ".", "load_state_dict", "(", "state_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackbone.add_layer": [[156, 159], ["backbone.ResNetBackbone._make_layer"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer"], ["", "def", "add_layer", "(", "self", ",", "conv_channels", "=", "1024", ",", "downsample", "=", "2", ",", "depth", "=", "1", ",", "block", "=", "Bottleneck", ")", ":", "\n", "        ", "\"\"\" Add a downsample layer to the backbone as per what SSD does. \"\"\"", "\n", "self", ".", "_make_layer", "(", "block", ",", "conv_channels", "//", "block", ".", "expansion", ",", "blocks", "=", "depth", ",", "stride", "=", "downsample", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackboneGN.__init__": [[165, 167], ["backbone.ResNetBackbone.__init__", "torch.GroupNorm", "torch.GroupNorm"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["    ", "def", "__init__", "(", "self", ",", "layers", ",", "num_groups", "=", "32", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "layers", ",", "norm_layer", "=", "lambda", "x", ":", "nn", ".", "GroupNorm", "(", "num_groups", ",", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.ResNetBackboneGN.init_backbone": [[168, 215], ["list", "backbone.ResNetBackboneGN.load_state_dict", "open", "pickle.load", "backbone.ResNetBackboneGN.state_dict().keys", "key.split", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "str", "backbone.ResNetBackboneGN.state_dict", "int", "gn_trans", "layeridx2res", "int", "int", "gn_trans", "block2branch", "gn_trans"], "methods", ["None"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" The path here comes from detectron. So we load it differently. \"\"\"", "\n", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "state_dict", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "'latin1'", ")", "# From the detectron source", "\n", "state_dict", "=", "state_dict", "[", "'blobs'", "]", "\n", "\n", "", "our_state_dict_keys", "=", "list", "(", "self", ".", "state_dict", "(", ")", ".", "keys", "(", ")", ")", "\n", "new_state_dict", "=", "{", "}", "\n", "\n", "gn_trans", "=", "lambda", "x", ":", "(", "'gn_s'", "if", "x", "==", "'weight'", "else", "'gn_b'", ")", "\n", "layeridx2res", "=", "lambda", "x", ":", "'res'", "+", "str", "(", "int", "(", "x", ")", "+", "2", ")", "\n", "block2branch", "=", "lambda", "x", ":", "'branch2'", "+", "(", "'a'", ",", "'b'", ",", "'c'", ")", "[", "int", "(", "x", "[", "-", "1", ":", "]", ")", "-", "1", "]", "\n", "\n", "# Transcribe each Detectron weights name to a Yolact weights name", "\n", "for", "key", "in", "our_state_dict_keys", ":", "\n", "            ", "parts", "=", "key", ".", "split", "(", "'.'", ")", "\n", "transcribed_key", "=", "''", "\n", "\n", "if", "(", "parts", "[", "0", "]", "==", "'conv1'", ")", ":", "\n", "                ", "transcribed_key", "=", "'conv1_w'", "\n", "", "elif", "(", "parts", "[", "0", "]", "==", "'bn1'", ")", ":", "\n", "                ", "transcribed_key", "=", "'conv1_'", "+", "gn_trans", "(", "parts", "[", "1", "]", ")", "\n", "", "elif", "(", "parts", "[", "0", "]", "==", "'layers'", ")", ":", "\n", "                ", "if", "int", "(", "parts", "[", "1", "]", ")", ">=", "self", ".", "num_base_layers", ":", "continue", "\n", "\n", "transcribed_key", "=", "layeridx2res", "(", "parts", "[", "1", "]", ")", "\n", "transcribed_key", "+=", "'_'", "+", "parts", "[", "2", "]", "+", "'_'", "\n", "\n", "if", "parts", "[", "3", "]", "==", "'downsample'", ":", "\n", "                    ", "transcribed_key", "+=", "'branch1_'", "\n", "\n", "if", "parts", "[", "4", "]", "==", "'0'", ":", "\n", "                        ", "transcribed_key", "+=", "'w'", "\n", "", "else", ":", "\n", "                        ", "transcribed_key", "+=", "gn_trans", "(", "parts", "[", "5", "]", ")", "\n", "", "", "else", ":", "\n", "                    ", "transcribed_key", "+=", "block2branch", "(", "parts", "[", "3", "]", ")", "+", "'_'", "\n", "\n", "if", "'conv'", "in", "parts", "[", "3", "]", ":", "\n", "                        ", "transcribed_key", "+=", "'w'", "\n", "", "else", ":", "\n", "                        ", "transcribed_key", "+=", "gn_trans", "(", "parts", "[", "4", "]", ")", "\n", "\n", "", "", "", "new_state_dict", "[", "key", "]", "=", "torch", ".", "Tensor", "(", "state_dict", "[", "transcribed_key", "]", ")", "\n", "\n", "# strict=False because we may have extra unitialized layers at this point", "\n", "", "self", ".", "load_state_dict", "(", "new_state_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBlock.__init__": [[240, 245], ["torch.Module.__init__", "backbone.darknetconvlayer", "backbone.darknetconvlayer"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.darknetconvlayer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.darknetconvlayer"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "darknetconvlayer", "(", "in_channels", ",", "channels", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "conv2", "=", "darknetconvlayer", "(", "channels", ",", "channels", "*", "self", ".", "expansion", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBlock.forward": [[246, 248], ["backbone.DarkNetBlock.conv2", "backbone.DarkNetBlock.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "conv2", "(", "self", ".", "conv1", "(", "x", ")", ")", "+", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBackbone.__init__": [[259, 281], ["torch.Module.__init__", "len", "torch.ModuleList", "torch.ModuleList", "backbone.darknetconvlayer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone._make_layer", "backbone.DarkNetBackbone.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.darknetconvlayer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer"], ["def", "__init__", "(", "self", ",", "layers", "=", "[", "1", ",", "2", ",", "8", ",", "8", ",", "4", "]", ",", "block", "=", "DarkNetBlock", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# These will be populated by _make_layer", "\n", "self", ".", "num_base_layers", "=", "len", "(", "layers", ")", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "channels", "=", "[", "]", "\n", "\n", "self", ".", "_preconv", "=", "darknetconvlayer", "(", "3", ",", "32", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "in_channels", "=", "32", "\n", "\n", "self", ".", "_make_layer", "(", "block", ",", "32", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "1", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "2", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "3", "]", ")", "\n", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "4", "]", ")", "\n", "\n", "# This contains every module that should be initialized by loading in pretrained weights.", "\n", "# Any extra layers added onto this that won't be initialized by init_backbone will not be", "\n", "# in this list. That way, Yolact::init_weights knows which backbone weights to initialize", "\n", "# with xavier, and which ones to leave alone.", "\n", "self", ".", "backbone_modules", "=", "[", "m", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBackbone._make_layer": [[282, 297], ["layer_list.append", "backbone.DarkNetBackbone.channels.append", "backbone.DarkNetBackbone.layers.append", "backbone.darknetconvlayer", "block", "torch.Sequential", "torch.Sequential", "range"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.darknetconvlayer"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "channels", ",", "num_blocks", ",", "stride", "=", "2", ")", ":", "\n", "        ", "\"\"\" Here one layer means a string of n blocks. \"\"\"", "\n", "layer_list", "=", "[", "]", "\n", "\n", "# The downsample layer", "\n", "layer_list", ".", "append", "(", "\n", "darknetconvlayer", "(", "self", ".", "in_channels", ",", "channels", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "stride", "=", "stride", ")", ")", "\n", "\n", "# Each block inputs channels and outputs channels * expansion", "\n", "self", ".", "in_channels", "=", "channels", "*", "block", ".", "expansion", "\n", "layer_list", "+=", "[", "block", "(", "self", ".", "in_channels", ",", "channels", ")", "for", "_", "in", "range", "(", "num_blocks", ")", "]", "\n", "\n", "self", ".", "channels", ".", "append", "(", "self", ".", "in_channels", ")", "\n", "self", ".", "layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "layer_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBackbone.forward": [[298, 309], ["backbone.DarkNetBackbone._preconv", "tuple", "layer", "outs.append"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Returns a list of convouts for each layer. \"\"\"", "\n", "\n", "x", "=", "self", ".", "_preconv", "(", "x", ")", "\n", "\n", "outs", "=", "[", "]", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBackbone.add_layer": [[310, 313], ["backbone.DarkNetBackbone._make_layer"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer"], ["", "def", "add_layer", "(", "self", ",", "conv_channels", "=", "1024", ",", "stride", "=", "2", ",", "depth", "=", "1", ",", "block", "=", "DarkNetBlock", ")", ":", "\n", "        ", "\"\"\" Add a downsample layer to the backbone as per what SSD does. \"\"\"", "\n", "self", ".", "_make_layer", "(", "block", ",", "conv_channels", "//", "block", ".", "expansion", ",", "num_blocks", "=", "depth", ",", "stride", "=", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.DarkNetBackbone.init_backbone": [[314, 318], ["backbone.DarkNetBackbone.load_state_dict", "torch.load", "torch.load", "torch.load", "torch.load"], "methods", ["None"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Initializes the backbone weights for training. \"\"\"", "\n", "# Note: Using strict=False is berry scary. Triple check this.", "\n", "self", ".", "load_state_dict", "(", "torch", ".", "load", "(", "path", ")", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.__init__": [[334, 357], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "list", "enumerate", "torch.ModuleList", "torch.ModuleList", "reversed", "backbone.VGGBackbone._make_layer", "torch.BatchNorm2d", "torch.BatchNorm2d", "enumerate", "backbone.VGGBackbone.modules", "isinstance"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer"], ["def", "__init__", "(", "self", ",", "cfg", ",", "extra_args", "=", "[", "]", ",", "norm_layers", "=", "[", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "channels", "=", "[", "]", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "in_channels", "=", "3", "\n", "self", ".", "extra_args", "=", "list", "(", "reversed", "(", "extra_args", ")", ")", "# So I can use it as a stack", "\n", "\n", "# Keeps track of what the corresponding key will be in the state dict of the", "\n", "# pretrained model. For instance, layers.0.2 for us is 2 for the pretrained", "\n", "# model but layers.1.1 is 5.", "\n", "self", ".", "total_layer_count", "=", "0", "\n", "self", ".", "state_dict_lookup", "=", "{", "}", "\n", "\n", "for", "idx", ",", "layer_cfg", "in", "enumerate", "(", "cfg", ")", ":", "\n", "            ", "self", ".", "_make_layer", "(", "layer_cfg", ")", "\n", "\n", "", "self", ".", "norms", "=", "nn", ".", "ModuleList", "(", "[", "nn", ".", "BatchNorm2d", "(", "self", ".", "channels", "[", "l", "]", ")", "for", "l", "in", "norm_layers", "]", ")", "\n", "self", ".", "norm_lookup", "=", "{", "l", ":", "idx", "for", "idx", ",", "l", "in", "enumerate", "(", "norm_layers", ")", "}", "\n", "\n", "# These modules will be initialized by init_backbone,", "\n", "# so don't overwrite their initialization later.", "\n", "self", ".", "backbone_modules", "=", "[", "m", "for", "m", "in", "self", ".", "modules", "(", ")", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone._make_layer": [[358, 398], ["len", "backbone.VGGBackbone.channels.append", "backbone.VGGBackbone.layers.append", "isinstance", "torch.Sequential", "torch.Sequential", "layers.append", "layers.append", "layers.append", "torch.MaxPool2d", "torch.MaxPool2d", "len", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "_make_layer", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Each layer is a sequence of conv layers usually preceded by a max pooling.\n        Adapted from torchvision.models.vgg.make_layers.\n        \"\"\"", "\n", "\n", "layers", "=", "[", "]", "\n", "\n", "for", "v", "in", "cfg", ":", "\n", "# VGG in SSD requires some special layers, so allow layers to be tuples of", "\n", "# (<M or num_features>, kwdargs dict)", "\n", "            ", "args", "=", "None", "\n", "if", "isinstance", "(", "v", ",", "tuple", ")", ":", "\n", "                ", "args", "=", "v", "[", "1", "]", "\n", "v", "=", "v", "[", "0", "]", "\n", "\n", "# v should be either M or a number", "\n", "", "if", "v", "==", "'M'", ":", "\n", "# Set default arguments", "\n", "                ", "if", "args", "is", "None", ":", "\n", "                    ", "args", "=", "{", "'kernel_size'", ":", "2", ",", "'stride'", ":", "2", "}", "\n", "\n", "", "layers", ".", "append", "(", "nn", ".", "MaxPool2d", "(", "**", "args", ")", ")", "\n", "", "else", ":", "\n", "# See the comment in __init__ for an explanation of this", "\n", "                ", "cur_layer_idx", "=", "self", ".", "total_layer_count", "+", "len", "(", "layers", ")", "\n", "self", ".", "state_dict_lookup", "[", "cur_layer_idx", "]", "=", "'%d.%d'", "%", "(", "len", "(", "self", ".", "layers", ")", ",", "len", "(", "layers", ")", ")", "\n", "\n", "# Set default arguments", "\n", "if", "args", "is", "None", ":", "\n", "                    ", "args", "=", "{", "'kernel_size'", ":", "3", ",", "'padding'", ":", "1", "}", "\n", "\n", "# Add the layers", "\n", "", "layers", ".", "append", "(", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "v", ",", "**", "args", ")", ")", "\n", "layers", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "in_channels", "=", "v", "\n", "\n", "", "", "self", ".", "total_layer_count", "+=", "len", "(", "layers", ")", "\n", "self", ".", "channels", ".", "append", "(", "self", ".", "in_channels", ")", "\n", "self", ".", "layers", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "layers", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.forward": [[399, 413], ["enumerate", "tuple", "layer", "outs.append"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" Returns a list of convouts for each layer. \"\"\"", "\n", "outs", "=", "[", "]", "\n", "\n", "for", "idx", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "\n", "# Apply an l2norm module to the selected layers", "\n", "# Note that this differs from the original implemenetation", "\n", "if", "idx", "in", "self", ".", "norm_lookup", ":", "\n", "                ", "x", "=", "self", ".", "norms", "[", "self", ".", "norm_lookup", "[", "idx", "]", "]", "(", "x", ")", "\n", "", "outs", ".", "append", "(", "x", ")", "\n", "\n", "", "return", "tuple", "(", "outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.transform_key": [[414, 419], ["k.split", "int"], "methods", ["None"], ["", "def", "transform_key", "(", "self", ",", "k", ")", ":", "\n", "        ", "\"\"\" Transform e.g. features.24.bias to layers.4.1.bias \"\"\"", "\n", "vals", "=", "k", ".", "split", "(", "'.'", ")", "\n", "layerIdx", "=", "self", ".", "state_dict_lookup", "[", "int", "(", "vals", "[", "0", "]", ")", "]", "\n", "return", "'layers.%s.%s'", "%", "(", "layerIdx", ",", "vals", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.init_backbone": [[420, 426], ["torch.load", "torch.load", "torch.load", "torch.load", "collections.OrderedDict", "backbone.VGGBackbone.load_state_dict", "backbone.VGGBackbone.transform_key", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.transform_key"], ["", "def", "init_backbone", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Initializes the backbone weights for training. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "\n", "state_dict", "=", "OrderedDict", "(", "[", "(", "self", ".", "transform_key", "(", "k", ")", ",", "v", ")", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", "]", ")", "\n", "\n", "self", ".", "load_state_dict", "(", "state_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.add_layer": [[427, 444], ["torch.Sequential", "torch.Sequential", "backbone.VGGBackbone.channels.append", "backbone.VGGBackbone.layers.append", "len", "backbone.VGGBackbone.extra_args.pop", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "add_layer", "(", "self", ",", "conv_channels", "=", "128", ",", "downsample", "=", "2", ")", ":", "\n", "        ", "\"\"\" Add a downsample layer to the backbone as per what SSD does. \"\"\"", "\n", "if", "len", "(", "self", ".", "extra_args", ")", ">", "0", ":", "\n", "            ", "conv_channels", ",", "downsample", "=", "self", ".", "extra_args", ".", "pop", "(", ")", "\n", "\n", "", "padding", "=", "1", "if", "downsample", ">", "1", "else", "0", "\n", "\n", "layer", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "in_channels", ",", "conv_channels", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "conv_channels", ",", "conv_channels", "*", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "downsample", ",", "padding", "=", "padding", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", ")", "\n", "\n", "self", ".", "in_channels", "=", "conv_channels", "*", "2", "\n", "self", ".", "channels", ".", "append", "(", "self", ".", "in_channels", ")", "\n", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.darknetconvlayer": [[222, 233], ["torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.LeakyReLU"], "function", ["None"], ["", "", "def", "darknetconvlayer", "(", "in_channels", ",", "out_channels", ",", "*", "args", ",", "**", "kwdargs", ")", ":", "\n", "    ", "\"\"\"\n    Implements a conv, activation, then batch norm.\n    Arguments are passed into the conv layer.\n    \"\"\"", "\n", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "*", "args", ",", "**", "kwdargs", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ",", "\n", "# Darknet uses 0.1 here.", "\n", "# See https://github.com/pjreddie/darknet/blob/680d3bde1924c8ee2d1c1dea54d3e56a05ca9a26/src/activations.h#L39", "\n", "nn", ".", "LeakyReLU", "(", "0.1", ",", "inplace", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.construct_backbone": [[448, 459], ["cfg.type", "max", "len", "cfg.type.add_layer"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.add_layer"], ["", "", "def", "construct_backbone", "(", "cfg", ")", ":", "\n", "    ", "\"\"\" Constructs a backbone given a backbone config object (see config.py). \"\"\"", "\n", "backbone", "=", "cfg", ".", "type", "(", "*", "cfg", ".", "args", ")", "\n", "\n", "# Add downsampling layers until we reach the number we need", "\n", "num_layers", "=", "max", "(", "cfg", ".", "selected_layers", ")", "+", "1", "\n", "\n", "while", "len", "(", "backbone", ".", "layers", ")", "<", "num_layers", ":", "\n", "        ", "backbone", ".", "add_layer", "(", ")", "\n", "\n", "", "return", "backbone", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.Concat.__init__": [[37, 42], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nets", ",", "extra_params", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "nets", "=", "nn", ".", "ModuleList", "(", "nets", ")", "\n", "self", ".", "extra_params", "=", "extra_params", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.Concat.forward": [[43, 46], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Concat each along the channel dimension", "\n", "        ", "return", "torch", ".", "cat", "(", "[", "net", "(", "x", ")", "for", "net", "in", "self", ".", "nets", "]", ",", "dim", "=", "1", ",", "**", "self", ".", "extra_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.PredictionModule.__init__": [[133, 184], ["torch.Module.__init__", "sum", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "len", "epsnet.make_net", "torchvision.models.resnet.Bottleneck", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "epsnet.PredictionModule.__init__.make_extra"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.make_net"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", "=", "1024", ",", "aspect_ratios", "=", "[", "[", "1", "]", "]", ",", "scales", "=", "[", "1", "]", ",", "parent", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_classes", "=", "cfg", ".", "num_classes", "\n", "self", ".", "mask_dim", "=", "cfg", ".", "mask_dim", "\n", "self", ".", "num_priors", "=", "sum", "(", "len", "(", "x", ")", "for", "x", "in", "aspect_ratios", ")", "\n", "self", ".", "parent", "=", "[", "parent", "]", "# Don't include this in the state dict", "\n", "\n", "if", "cfg", ".", "mask_proto_prototypes_as_features", ":", "\n", "            ", "in_channels", "+=", "self", ".", "mask_dim", "\n", "\n", "", "if", "parent", "is", "None", ":", "\n", "            ", "if", "cfg", ".", "extra_head_net", "is", "None", ":", "\n", "                ", "out_channels", "=", "in_channels", "\n", "", "else", ":", "\n", "                ", "self", ".", "upfeature", ",", "out_channels", "=", "make_net", "(", "in_channels", ",", "cfg", ".", "extra_head_net", ")", "\n", "\n", "", "if", "cfg", ".", "use_prediction_module", ":", "\n", "                ", "self", ".", "block", "=", "Bottleneck", "(", "out_channels", ",", "out_channels", "//", "4", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ",", "bias", "=", "True", ")", "\n", "# self.bn = nn.BatchNorm2d(out_channels)", "\n", "self", ".", "bn", "=", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", "\n", "\n", "", "self", ".", "bbox_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "4", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "self", ".", "conf_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "num_classes", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "self", ".", "mask_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "                ", "self", ".", "inst_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "cfg", ".", "num_instance_coeffs", ",", "**", "cfg", ".", "head_layer_params", ")", "\n", "\n", "# What is this ugly lambda doing in the middle of all this clean prediction module code?", "\n", "", "def", "make_extra", "(", "num_layers", ")", ":", "\n", "                ", "if", "num_layers", "==", "0", ":", "\n", "                    ", "return", "lambda", "x", ":", "x", "\n", "", "else", ":", "\n", "# Looks more complicated than it is. This just creates an array of num_layers alternating conv-relu", "\n", "                    ", "return", "nn", ".", "Sequential", "(", "*", "sum", "(", "[", "[", "\n", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "]", "for", "_", "in", "range", "(", "num_layers", ")", "]", ",", "[", "]", ")", ")", "\n", "\n", "", "", "self", ".", "bbox_extra", ",", "self", ".", "conf_extra", ",", "self", ".", "mask_extra", "=", "[", "make_extra", "(", "x", ")", "for", "x", "in", "cfg", ".", "extra_layers", "]", "\n", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", "and", "cfg", ".", "mask_proto_coeff_gate", ":", "\n", "                ", "self", ".", "gate_layer", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "self", ".", "num_priors", "*", "self", ".", "mask_dim", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "\n", "", "", "self", ".", "aspect_ratios", "=", "aspect_ratios", "\n", "self", ".", "scales", "=", "scales", "\n", "\n", "self", ".", "priors", "=", "None", "\n", "self", ".", "last_conv_size", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.PredictionModule.forward": [[185, 255], ["src.upfeature.size", "src.upfeature.size", "src.bbox_extra", "src.conf_extra", "src.mask_extra", "src.bbox_layer().permute().contiguous().view", "src.conf_layer().permute().contiguous().view", "epsnet.PredictionModule.make_priors", "src.upfeature", "src.block", "src.conv", "src.bn", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "src.upfeature.size", "src.upfeature.size", "src.mask_layer().permute().contiguous().view", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "src.inst_layer().permute().contiguous().view", "src.bbox_layer().permute().contiguous", "src.conf_layer().permute().contiguous", "src.upfeature.size", "src.upfeature.size", "src.bbox_layer().permute().contiguous().view.size", "src.upfeature.size", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "src.mask_layer().permute().contiguous", "src.inst_layer().permute().contiguous", "data.config.cfg.mask_proto_coeff_activation", "src.bbox_layer().permute", "src.conf_layer().permute", "src.gate_layer().permute().contiguous().view", "src.mask_layer().permute", "src.inst_layer().permute", "src.upfeature.size", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "src.bbox_layer", "src.conf_layer", "src.gate_layer().permute().contiguous", "src.mask_layer", "src.inst_layer", "src.gate_layer().permute", "src.gate_layer"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.make_priors", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            - x: The convOut from a layer in the backbone network\n                 Size: [batch_size, in_channels, conv_h, conv_w])\n\n        Returns a tuple (bbox_coords, class_confs, mask_output, prior_boxes) with sizes\n            - bbox_coords: [batch_size, conv_h*conv_w*num_priors, 4]\n            - class_confs: [batch_size, conv_h*conv_w*num_priors, num_classes]\n            - mask_output: [batch_size, conv_h*conv_w*num_priors, mask_dim]\n            - prior_boxes: [conv_h*conv_w*num_priors, 4]\n        \"\"\"", "\n", "# In case we want to use another module's layers", "\n", "src", "=", "self", "if", "self", ".", "parent", "[", "0", "]", "is", "None", "else", "self", ".", "parent", "[", "0", "]", "\n", "\n", "conv_h", "=", "x", ".", "size", "(", "2", ")", "\n", "conv_w", "=", "x", ".", "size", "(", "3", ")", "\n", "\n", "if", "cfg", ".", "extra_head_net", "is", "not", "None", ":", "\n", "            ", "x", "=", "src", ".", "upfeature", "(", "x", ")", "\n", "\n", "", "if", "cfg", ".", "use_prediction_module", ":", "\n", "# The two branches of PM design (c)", "\n", "            ", "a", "=", "src", ".", "block", "(", "x", ")", "\n", "\n", "b", "=", "src", ".", "conv", "(", "x", ")", "\n", "b", "=", "src", ".", "bn", "(", "b", ")", "\n", "b", "=", "F", ".", "relu", "(", "b", ")", "\n", "\n", "# TODO: Possibly switch this out for a product", "\n", "x", "=", "a", "+", "b", "\n", "\n", "", "bbox_x", "=", "src", ".", "bbox_extra", "(", "x", ")", "\n", "conf_x", "=", "src", ".", "conf_extra", "(", "x", ")", "\n", "mask_x", "=", "src", ".", "mask_extra", "(", "x", ")", "\n", "\n", "bbox", "=", "src", ".", "bbox_layer", "(", "bbox_x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "4", ")", "\n", "conf", "=", "src", ".", "conf_layer", "(", "conf_x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "if", "cfg", ".", "eval_mask_branch", ":", "\n", "            ", "mask", "=", "src", ".", "mask_layer", "(", "mask_x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "mask_dim", ")", "\n", "", "else", ":", "\n", "            ", "mask", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", "0", ")", ",", "bbox", ".", "size", "(", "1", ")", ",", "self", ".", "mask_dim", ",", "device", "=", "bbox", ".", "device", ")", "\n", "\n", "", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "            ", "inst", "=", "src", ".", "inst_layer", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "cfg", ".", "num_instance_coeffs", ")", "\n", "\n", "# See box_utils.decode for an explanation of this", "\n", "", "if", "cfg", ".", "use_yolo_regressors", ":", "\n", "            ", "bbox", "[", ":", ",", ":", ",", ":", "2", "]", "=", "torch", ".", "sigmoid", "(", "bbox", "[", ":", ",", ":", ",", ":", "2", "]", ")", "-", "0.5", "\n", "bbox", "[", ":", ",", ":", ",", "0", "]", "/=", "conv_w", "\n", "bbox", "[", ":", ",", ":", ",", "1", "]", "/=", "conv_h", "\n", "\n", "", "if", "cfg", ".", "eval_mask_branch", ":", "\n", "            ", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "direct", ":", "\n", "                ", "mask", "=", "torch", ".", "sigmoid", "(", "mask", ")", "\n", "", "elif", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "                ", "mask", "=", "cfg", ".", "mask_proto_coeff_activation", "(", "mask", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_coeff_gate", ":", "\n", "                    ", "gate", "=", "src", ".", "gate_layer", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ",", "self", ".", "mask_dim", ")", "\n", "mask", "=", "mask", "*", "torch", ".", "sigmoid", "(", "gate", ")", "\n", "\n", "", "", "", "priors", "=", "self", ".", "make_priors", "(", "conv_h", ",", "conv_w", ")", "\n", "\n", "preds", "=", "{", "'loc'", ":", "bbox", ",", "'conf'", ":", "conf", ",", "'mask'", ":", "mask", ",", "'priors'", ":", "priors", "}", "\n", "\n", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "            ", "preds", "[", "'inst'", "]", "=", "inst", "\n", "\n", "", "return", "preds", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.PredictionModule.make_priors": [[256, 291], ["utils.timer.env", "itertools.product", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "range", "range", "zip", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "math.sqrt"], "methods", ["None"], ["", "def", "make_priors", "(", "self", ",", "conv_h", ",", "conv_w", ")", ":", "\n", "        ", "\"\"\" Note that priors are [x,y,width,height] where (x,y) is the center of the box. \"\"\"", "\n", "\n", "with", "timer", ".", "env", "(", "'makepriors'", ")", ":", "\n", "            ", "if", "self", ".", "last_conv_size", "!=", "(", "conv_w", ",", "conv_h", ")", ":", "\n", "                ", "prior_data", "=", "[", "]", "\n", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "# +0.5 because priors are in center-size notation", "\n", "                    ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "scale", ",", "ars", "in", "zip", "(", "self", ".", "scales", ",", "self", ".", "aspect_ratios", ")", ":", "\n", "                        ", "for", "ar", "in", "ars", ":", "\n", "                            ", "if", "not", "cfg", ".", "backbone", ".", "preapply_sqrt", ":", "\n", "                                ", "ar", "=", "sqrt", "(", "ar", ")", "\n", "\n", "", "if", "cfg", ".", "backbone", ".", "use_pixel_scales", ":", "\n", "                                ", "w", "=", "scale", "*", "ar", "/", "cfg", ".", "input_w", "\n", "h", "=", "scale", "/", "ar", "/", "cfg", ".", "input_h", "\n", "", "else", ":", "\n", "                                ", "w", "=", "scale", "*", "ar", "/", "conv_w", "\n", "h", "=", "scale", "/", "ar", "/", "conv_h", "\n", "\n", "# This is for backward compatability with a bug where I made everything square by accident", "\n", "", "if", "cfg", ".", "backbone", ".", "use_square_anchors", ":", "\n", "                                ", "h", "=", "w", "\n", "\n", "", "prior_data", "+=", "[", "x", ",", "y", ",", "w", ",", "h", "]", "\n", "\n", "", "", "", "self", ".", "priors", "=", "torch", ".", "Tensor", "(", "prior_data", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "self", ".", "last_conv_size", "=", "(", "conv_w", ",", "conv_h", ")", "\n", "\n", "", "", "return", "self", ".", "priors", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.FPN.__init__": [[310, 334], ["ScriptModuleWrapper.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "reversed", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "range"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "lat_layers", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "x", ",", "cfg", ".", "fpn", ".", "num_features", ",", "kernel_size", "=", "1", ")", "\n", "for", "x", "in", "reversed", "(", "in_channels", ")", "\n", "]", ")", "\n", "\n", "# This is here for backwards compatability", "\n", "padding", "=", "1", "if", "cfg", ".", "fpn", ".", "pad", "else", "0", "\n", "self", ".", "pred_layers", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "cfg", ".", "fpn", ".", "num_features", ",", "cfg", ".", "fpn", ".", "num_features", ",", "kernel_size", "=", "3", ",", "padding", "=", "padding", ")", "\n", "for", "_", "in", "in_channels", "\n", "]", ")", "\n", "\n", "if", "cfg", ".", "fpn", ".", "use_conv_downsample", ":", "\n", "            ", "self", ".", "downsample_layers", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Conv2d", "(", "cfg", ".", "fpn", ".", "num_features", ",", "cfg", ".", "fpn", ".", "num_features", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "stride", "=", "2", ")", "\n", "for", "_", "in", "range", "(", "cfg", ".", "fpn", ".", "num_downsample", ")", "\n", "]", ")", "\n", "\n", "", "self", ".", "interpolation_mode", "=", "cfg", ".", "fpn", ".", "interpolation_mode", "\n", "self", ".", "num_downsample", "=", "cfg", ".", "fpn", ".", "num_downsample", "\n", "self", ".", "use_conv_downsample", "=", "cfg", ".", "fpn", ".", "use_conv_downsample", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.FPN.forward": [[335, 378], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "len", "len", "len", "out.append", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "range", "convouts[].size", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "lat_layer", "pred_layer", "out.append", "out.append", "len", "downsample_layer", "torch.functional.max_pool2d", "torch.functional.max_pool2d", "torch.functional.max_pool2d", "torch.functional.max_pool2d"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "@", "script_method_wrapper", "\n", "def", "forward", "(", "self", ",", "convouts", ":", "List", "[", "torch", ".", "Tensor", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            - convouts (list): A list of convouts for the corresponding layers in in_channels.\n        Returns:\n            - A list of FPN convouts in the same order as x with extra downsample layers if requested.\n        \"\"\"", "\n", "\n", "out", "=", "[", "]", "\n", "x", "=", "torch", ".", "zeros", "(", "1", ",", "device", "=", "convouts", "[", "0", "]", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "convouts", ")", ")", ":", "\n", "            ", "out", ".", "append", "(", "x", ")", "\n", "\n", "# For backward compatability, the conv layers are stored in reverse but the input and output is", "\n", "# given in the correct order. Thus, use j=-i-1 for the input and output and i for the conv layers.", "\n", "", "j", "=", "len", "(", "convouts", ")", "\n", "for", "lat_layer", "in", "self", ".", "lat_layers", ":", "\n", "            ", "j", "-=", "1", "\n", "\n", "if", "j", "<", "len", "(", "convouts", ")", "-", "1", ":", "\n", "                ", "_", ",", "_", ",", "h", ",", "w", "=", "convouts", "[", "j", "]", ".", "size", "(", ")", "\n", "x", "=", "F", ".", "interpolate", "(", "x", ",", "size", "=", "(", "h", ",", "w", ")", ",", "mode", "=", "self", ".", "interpolation_mode", ",", "align_corners", "=", "False", ")", "\n", "\n", "", "x", "=", "x", "+", "lat_layer", "(", "convouts", "[", "j", "]", ")", "\n", "out", "[", "j", "]", "=", "x", "\n", "\n", "# This janky second loop is here because TorchScript.", "\n", "", "j", "=", "len", "(", "convouts", ")", "\n", "for", "pred_layer", "in", "self", ".", "pred_layers", ":", "\n", "            ", "j", "-=", "1", "\n", "out", "[", "j", "]", "=", "F", ".", "relu", "(", "pred_layer", "(", "out", "[", "j", "]", ")", ")", "\n", "\n", "# In the original paper, this takes care of P6", "\n", "", "if", "self", ".", "use_conv_downsample", ":", "\n", "            ", "for", "downsample_layer", "in", "self", ".", "downsample_layers", ":", "\n", "                ", "out", ".", "append", "(", "downsample_layer", "(", "out", "[", "-", "1", "]", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "idx", "in", "range", "(", "self", ".", "num_downsample", ")", ":", "\n", "# Note: this is an untested alternative to out.append(out[-1][:, :, ::2, ::2]). Thanks TorchScript.", "\n", "                ", "out", ".", "append", "(", "nn", ".", "functional", ".", "max_pool2d", "(", "out", "[", "-", "1", "]", ",", "1", ",", "stride", "=", "2", ")", ")", "\n", "\n", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.FusionModule.__init__": [[382, 394], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "epsnet.make_net", "epsnet.make_net", "epsnet.FusionModule.layer_modules.append"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.make_net", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.make_net", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "fpn_levels", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# ---Panoptic FPN---", "\n", "self", ".", "layer_modules", "=", "nn", ".", "ModuleList", "(", "[", "]", ")", "\n", "for", "i", "in", "range", "(", "fpn_levels", ")", ":", "\n", "            ", "layer_module", ",", "_", "=", "make_net", "(", "in_channels", ",", "[", "(", "out_dim", ",", "3", ",", "{", "'padding'", ":", "1", "}", ")", ",", "(", "None", ",", "-", "2", ",", "{", "}", ")", "]", "*", "i", "+", "[", "(", "out_dim", ",", "3", ",", "{", "'padding'", ":", "1", "}", ")", "]", ")", "\n", "self", ".", "layer_modules", ".", "append", "(", "layer_module", ")", "\n", "\n", "", "self", ".", "fusion_subnet", ",", "_", "=", "make_net", "(", "in_channels", ",", "[", "(", "out_dim", "*", "2", ",", "3", ",", "{", "'padding'", ":", "1", "}", ")", "]", "+", "[", "(", "out_dim", ",", "3", ",", "{", "'padding'", ":", "1", "}", ")", "]", "*", "2", ")", "\n", "\n", "self", ".", "upsample_layer", "=", "None", "\n", "", "def", "forward", "(", "self", ",", "fpn_outs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.FusionModule.forward": [[394, 410], ["range", "sum", "layers.interpolate.InterpolateModule", "len", "epsnet.FusionModule.upsample_layer", "fusion_maps.append", "fpn_outs[].size", "fpn_outs[].size"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "forward", "(", "self", ",", "fpn_outs", ")", ":", "\n", "        ", "if", "self", ".", "upsample_layer", "is", "None", ":", "\n", "            ", "final_size", "=", "(", "fpn_outs", "[", "0", "]", ".", "size", "(", "2", ")", ",", "fpn_outs", "[", "0", "]", ".", "size", "(", "3", ")", ")", "\n", "self", ".", "upsample_layer", "=", "InterpolateModule", "(", "size", "=", "final_size", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "\n", "", "fusion_maps", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "fpn_outs", ")", ")", ":", "\n", "            ", "out", "=", "self", ".", "layer_modules", "[", "i", "]", "(", "fpn_outs", "[", "i", "]", ")", "\n", "out", "=", "self", ".", "upsample_layer", "(", "out", ")", "\n", "\n", "\n", "fusion_maps", ".", "append", "(", "out", ")", "\n", "\n", "", "fusion_out", "=", "sum", "(", "fusion_maps", ")", "\n", "\n", "return", "fusion_out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.AddCoords.__init__": [[412, 416], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["    ", "def", "__init__", "(", "self", ",", "with_r", "=", "False", ",", "use_cuda", "=", "True", ")", ":", "\n", "        ", "super", "(", "AddCoords", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "with_r", "=", "with_r", "\n", "self", ".", "use_cuda", "=", "use_cuda", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.AddCoords.forward": [[417, 457], ["torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "yy_channel.cuda.cuda.permute", "xx_channel.cuda.cuda.repeat", "yy_channel.cuda.cuda.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.arange.float", "torch.arange.float", "torch.arange.float", "torch.arange.float", "torch.ones.float", "torch.ones.float", "torch.ones.float", "torch.ones.float", "torch.arange.float", "torch.arange.float", "torch.arange.float", "torch.arange.float", "torch.ones.float", "torch.ones.float", "torch.ones.float", "torch.ones.float", "xx_channel.cuda.cuda.float", "yy_channel.cuda.cuda.float", "input_tensor.cuda.cuda.cuda", "xx_channel.cuda.cuda.cuda", "yy_channel.cuda.cuda.cuda", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_tensor", ")", ":", "\n", "        ", "\"\"\"\n        :param input_tensor: shape (N, C_in, H, W)\n        :return:\n        \"\"\"", "\n", "batch_size_shape", ",", "channel_in_shape", ",", "dim_y", ",", "dim_x", "=", "input_tensor", ".", "shape", "\n", "xx_ones", "=", "torch", ".", "ones", "(", "[", "1", ",", "1", ",", "1", ",", "dim_x", "]", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "yy_ones", "=", "torch", ".", "ones", "(", "[", "1", ",", "1", ",", "1", ",", "dim_y", "]", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "\n", "xx_range", "=", "torch", ".", "arange", "(", "dim_y", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "yy_range", "=", "torch", ".", "arange", "(", "dim_x", ",", "dtype", "=", "torch", ".", "int32", ")", "\n", "xx_range", "=", "xx_range", "[", "None", ",", "None", ",", ":", ",", "None", "]", "\n", "yy_range", "=", "yy_range", "[", "None", ",", "None", ",", ":", ",", "None", "]", "\n", "\n", "xx_channel", "=", "torch", ".", "matmul", "(", "xx_range", ".", "float", "(", ")", ",", "xx_ones", ".", "float", "(", ")", ")", "\n", "yy_channel", "=", "torch", ".", "matmul", "(", "yy_range", ".", "float", "(", ")", ",", "yy_ones", ".", "float", "(", ")", ")", "\n", "\n", "# transpose y", "\n", "yy_channel", "=", "yy_channel", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ")", "\n", "\n", "xx_channel", "=", "xx_channel", ".", "float", "(", ")", "/", "(", "dim_y", "-", "1", ")", "\n", "yy_channel", "=", "yy_channel", ".", "float", "(", ")", "/", "(", "dim_x", "-", "1", ")", "\n", "\n", "xx_channel", "=", "xx_channel", "*", "2", "-", "1", "\n", "yy_channel", "=", "yy_channel", "*", "2", "-", "1", "\n", "\n", "xx_channel", "=", "xx_channel", ".", "repeat", "(", "batch_size_shape", ",", "1", ",", "1", ",", "1", ")", "\n", "yy_channel", "=", "yy_channel", ".", "repeat", "(", "batch_size_shape", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "and", "self", ".", "use_cuda", ":", "\n", "            ", "input_tensor", "=", "input_tensor", ".", "cuda", "(", ")", "\n", "xx_channel", "=", "xx_channel", ".", "cuda", "(", ")", "\n", "yy_channel", "=", "yy_channel", ".", "cuda", "(", ")", "\n", "", "out", "=", "torch", ".", "cat", "(", "[", "input_tensor", ",", "xx_channel", ",", "yy_channel", "]", ",", "dim", "=", "1", ")", "\n", "\n", "if", "self", ".", "with_r", ":", "\n", "            ", "rr", "=", "torch", ".", "sqrt", "(", "torch", ".", "pow", "(", "xx_channel", "-", "0.5", ",", "2", ")", "+", "torch", ".", "pow", "(", "yy_channel", "-", "0.5", ",", "2", ")", ")", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "rr", "]", ",", "dim", "=", "1", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.CAModule.__init__": [[460, 473], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "share_conv", "=", "False", ")", ":", "\n", "        ", "super", "(", "CAModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "chanel_in", "=", "in_dim", "\n", "self", ".", "share_conv", "=", "share_conv", "\n", "self", ".", "query_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_dim", ",", "out_channels", "=", "in_dim", "//", "2", ",", "kernel_size", "=", "1", ")", "\n", "if", "share_conv", "is", "True", ":", "\n", "            ", "self", ".", "key_conv", "=", "self", ".", "query_conv", "\n", "", "else", ":", "\n", "            ", "self", ".", "key_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_dim", ",", "out_channels", "=", "in_dim", "//", "2", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "value_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_dim", ",", "out_channels", "=", "in_dim", "//", "2", ",", "kernel_size", "=", "1", ")", "\n", "self", ".", "out_conv", "=", "nn", ".", "Conv2d", "(", "in_channels", "=", "in_dim", "//", "2", ",", "out_channels", "=", "in_dim", ",", "kernel_size", "=", "1", ")", "\n", "\n", "", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "", "def", "forward", "(", "self", ",", "x_query", ",", "x_key", ",", "query_type", "=", "None", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.CAModule.forward": [[473, 496], ["x_query.size", "x_key.size", "epsnet.CAModule.query_conv().view().permute", "epsnet.CAModule.key_conv().view", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "epsnet.CAModule.softmax", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "epsnet.CAModule.view", "epsnet.CAModule.out_conv", "epsnet.CAModule.value_conv().view", "x_key.view", "epsnet.CAModule.permute", "epsnet.CAModule.query_conv().view", "epsnet.CAModule.key_conv", "epsnet.CAModule.value_conv", "epsnet.CAModule.query_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x_query", ",", "x_key", ",", "query_type", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n            inputs :\n                x : input feature maps( B X C X H X W)\n            returns :\n                out : attention value + input feature\n                attention: B X (HxW) X (HxW)\n        \"\"\"", "\n", "m_batchsize", ",", "C", ",", "h_query", ",", "w_query", "=", "x_query", ".", "size", "(", ")", "\n", "m_batchsize", ",", "C", ",", "h_key", ",", "w_key", "=", "x_key", ".", "size", "(", ")", "\n", "\n", "proj_query", "=", "self", ".", "query_conv", "(", "x_query", ")", ".", "view", "(", "m_batchsize", ",", "-", "1", ",", "w_query", "*", "h_query", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "proj_key", "=", "self", ".", "key_conv", "(", "x_key", ")", ".", "view", "(", "m_batchsize", ",", "-", "1", ",", "w_key", "*", "h_key", ")", "\n", "energy", "=", "torch", ".", "bmm", "(", "proj_query", ",", "proj_key", ")", "\n", "attention", "=", "self", ".", "softmax", "(", "energy", ")", "\n", "proj_value", "=", "self", ".", "value_conv", "(", "x_key", ")", ".", "view", "(", "m_batchsize", ",", "-", "1", ",", "w_key", "*", "h_key", ")", "if", "self", ".", "share_conv", "is", "not", "True", "else", "x_key", ".", "view", "(", "m_batchsize", ",", "-", "1", ",", "w_key", "*", "h_key", ")", "\n", "\n", "out", "=", "torch", ".", "bmm", "(", "proj_value", ",", "attention", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "out", "=", "out", ".", "view", "(", "m_batchsize", ",", "-", "1", ",", "h_query", ",", "w_query", ")", "\n", "out", "=", "self", ".", "out_conv", "(", "out", ")", "\n", "out", "=", "out", "+", "x_query", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.__init__": [[508, 627], ["torch.Module.__init__", "backbone.construct_backbone", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "enumerate", "layers.Detect", "epsnet.EPSNet.freeze_bn", "epsnet.FPN", "list", "epsnet.FusionModule", "epsnet.AddCoords", "epsnet.PredictionModule", "epsnet.EPSNet.prediction_layers.append", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "epsnet.CAModule", "epsnet.make_net", "range", "len", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "epsnet.EPSNet.grid.size", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "numpy.load", "len", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__", "home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.construct_backbone", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.freeze_bn", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.make_net"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "backbone", "=", "construct_backbone", "(", "cfg", ".", "backbone", ")", "\n", "\n", "if", "cfg", ".", "freeze_bn", ":", "\n", "            ", "self", ".", "freeze_bn", "(", ")", "\n", "\n", "\n", "#Fusion FPN", "\n", "", "self", ".", "fusion_layers", "=", "cfg", ".", "fusion_layers", "\n", "self", ".", "fusion_dim", "=", "cfg", ".", "fusion_dim", "\n", "\n", "\n", "# Compute mask_dim here and add it back to the config. ", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "direct", ":", "\n", "            ", "cfg", ".", "mask_dim", "=", "cfg", ".", "mask_size", "**", "2", "\n", "", "elif", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "            ", "if", "cfg", ".", "mask_proto_use_grid", ":", "\n", "                ", "self", ".", "grid", "=", "torch", ".", "Tensor", "(", "np", ".", "load", "(", "cfg", ".", "mask_proto_grid_file", ")", ")", "\n", "self", ".", "num_grids", "=", "self", ".", "grid", ".", "size", "(", "0", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "num_grids", "=", "0", "\n", "\n", "", "self", ".", "proto_src", "=", "cfg", ".", "mask_proto_src", "\n", "\n", "if", "self", ".", "proto_src", "is", "None", ":", "in_channels", "=", "3", "\n", "elif", "cfg", ".", "fpn", "is", "not", "None", ":", "in_channels", "=", "cfg", ".", "fpn", ".", "num_features", "\n", "else", ":", "in_channels", "=", "self", ".", "backbone", ".", "channels", "[", "self", ".", "proto_src", "]", "\n", "in_channels", "+=", "self", ".", "num_grids", "\n", "\n", "# The include_last_relu=false here is because we might want to change it to another function", "\n", "\n", "if", "cfg", ".", "proto_coordconv", ":", "\n", "                ", "in_channels", "+=", "2", "\n", "", "elif", "cfg", ".", "fpn_fusion", ":", "\n", "                ", "in_channels", "=", "self", ".", "fusion_dim", "\n", "\n", "", "self", ".", "proto_net", ",", "cfg", ".", "mask_dim", "=", "make_net", "(", "in_channels", ",", "cfg", ".", "mask_proto_net", ",", "include_last_relu", "=", "False", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_bias", ":", "\n", "                ", "cfg", ".", "mask_dim", "+=", "1", "\n", "\n", "\n", "", "", "self", ".", "selected_layers", "=", "cfg", ".", "backbone", ".", "selected_layers", "\n", "src_channels", "=", "self", ".", "backbone", ".", "channels", "\n", "if", "cfg", ".", "fpn", "is", "not", "None", ":", "\n", "# Some hacky rewiring to accomodate the FPN", "\n", "            ", "self", ".", "fpn", "=", "FPN", "(", "[", "src_channels", "[", "i", "]", "for", "i", "in", "self", ".", "selected_layers", "]", ")", "\n", "self", ".", "selected_layers", "=", "list", "(", "range", "(", "len", "(", "self", ".", "selected_layers", ")", "+", "cfg", ".", "fpn", ".", "num_downsample", ")", ")", "\n", "src_channels", "=", "[", "cfg", ".", "fpn", ".", "num_features", "]", "*", "len", "(", "self", ".", "selected_layers", ")", "\n", "\n", "\n", "", "if", "cfg", ".", "fpn_fusion", "is", "True", ":", "\n", "            ", "self", ".", "fusion_module", "=", "FusionModule", "(", "src_channels", "[", "0", "]", ",", "self", ".", "fusion_layers", ",", "out_dim", "=", "self", ".", "fusion_dim", ")", "\n", "\n", "\n", "", "if", "cfg", ".", "ins_coordconv", "or", "cfg", ".", "sem_coordconv", "or", "cfg", ".", "proto_coordconv", ":", "\n", "            ", "self", ".", "addcoords", "=", "AddCoords", "(", ")", "\n", "\n", "", "self", ".", "prediction_layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "idx", ",", "layer_idx", "in", "enumerate", "(", "self", ".", "selected_layers", ")", ":", "\n", "# If we're sharing prediction module weights, have every module's parent be the first one", "\n", "            ", "parent", "=", "None", "\n", "if", "cfg", ".", "share_prediction_module", "and", "idx", ">", "0", ":", "\n", "                ", "parent", "=", "self", ".", "prediction_layers", "[", "0", "]", "\n", "\n", "", "pred_in_ch", "=", "src_channels", "[", "layer_idx", "]", "+", "2", "if", "cfg", ".", "ins_coordconv", "else", "src_channels", "[", "layer_idx", "]", "\n", "pred", "=", "PredictionModule", "(", "pred_in_ch", ",", "src_channels", "[", "layer_idx", "]", ",", "\n", "aspect_ratios", "=", "cfg", ".", "backbone", ".", "pred_aspect_ratios", "[", "idx", "]", ",", "\n", "scales", "=", "cfg", ".", "backbone", ".", "pred_scales", "[", "idx", "]", ",", "\n", "parent", "=", "parent", ")", "\n", "self", ".", "prediction_layers", ".", "append", "(", "pred", ")", "\n", "\n", "# Extra parameters for the extra losses", "\n", "", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "# This comes from the smallest layer selected", "\n", "# Also note that cfg.num_classes includes background", "\n", "            ", "self", ".", "class_existence_fc", "=", "nn", ".", "Linear", "(", "src_channels", "[", "-", "1", "]", ",", "cfg", ".", "num_classes", "-", "1", ")", "\n", "\n", "", "if", "cfg", ".", "cross_attention_fusion", ":", "\n", "            ", "self", ".", "CALayer", "=", "CAModule", "(", "src_channels", "[", "0", "]", ",", "share_conv", "=", "False", ")", "\n", "\n", "\n", "", "if", "cfg", ".", "use_semantic_segmentation_loss", ":", "\n", "            ", "sem_in_ch", "=", "None", "\n", "if", "cfg", ".", "sem_src_fusion", "is", "True", ":", "\n", "                ", "sem_in_ch", "=", "self", ".", "fusion_dim", "\n", "", "elif", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "                ", "sem_in_ch", "=", "src_channels", "[", "0", "]", "\n", "", "else", ":", "# normal semantic segmentation head", "\n", "                ", "sem_in_ch", "=", "src_channels", "[", "-", "1", "]", "\n", "\n", "", "if", "cfg", ".", "sem_coordconv", ":", "\n", "                ", "sem_in_ch", "+=", "2", "\n", "\n", "# Panoptic FPN Fusion Version", "\n", "", "if", "cfg", ".", "sem_src_fusion", "is", "True", ":", "\n", "                ", "self", ".", "semantic_seg_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "sem_in_ch", ",", "cfg", ".", "stuff_num_classes", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ")", "\n", ")", "\n", "\n", "", "elif", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "                ", "self", ".", "semantic_seg_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "sem_in_ch", ",", "256", ",", "kernel_size", "=", "3", ")", ",", "\n", "# nn.BatchNorm2d(256),", "\n", "nn", ".", "GroupNorm", "(", "32", ",", "256", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "256", ",", "(", "cfg", ".", "stuff_num_classes", ")", "*", "cfg", ".", "mask_dim", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "semantic_seg_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "sem_in_ch", ",", "cfg", ".", "stuff_num_classes", ",", "kernel_size", "=", "(", "1", ",", "1", ")", ")", "\n", ")", "\n", "\n", "# For use in evaluation", "\n", "", "", "self", ".", "detect", "=", "Detect", "(", "cfg", ".", "num_classes", ",", "bkg_label", "=", "0", ",", "top_k", "=", "200", ",", "conf_thresh", "=", "0.05", ",", "nms_thresh", "=", "0.5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.save_weights": [[629, 632], ["torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "epsnet.EPSNet.state_dict"], "methods", ["None"], ["", "def", "save_weights", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Saves the model's weights using compression because the file sizes were getting too big. \"\"\"", "\n", "torch", ".", "save", "(", "self", ".", "state_dict", "(", ")", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.load_weights": [[633, 648], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "list", "epsnet.EPSNet.load_state_dict", "torch.load.keys", "torch.load.keys", "torch.load.keys", "torch.load.keys", "key.startswith", "key.startswith", "key.startswith", "int", "key.split"], "methods", ["None"], ["", "def", "load_weights", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\" Loads weights from a compressed save file. \"\"\"", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ")", "\n", "\n", "# For backward compatability, remove these (the new variable is called layers)", "\n", "for", "key", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "key", ".", "startswith", "(", "'backbone.layer'", ")", "and", "not", "key", ".", "startswith", "(", "'backbone.layers'", ")", ":", "\n", "                ", "del", "state_dict", "[", "key", "]", "\n", "\n", "# Also for backward compatibility with v1.0 weights, do this check", "\n", "", "if", "key", ".", "startswith", "(", "'fpn.downsample_layers.'", ")", ":", "\n", "                ", "if", "cfg", ".", "fpn", "is", "not", "None", "and", "int", "(", "key", ".", "split", "(", "'.'", ")", "[", "2", "]", ")", ">=", "cfg", ".", "fpn", ".", "num_downsample", ":", "\n", "                    ", "del", "state_dict", "[", "key", "]", "\n", "\n", "", "", "", "self", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.init_weights": [[649, 679], ["epsnet.EPSNet.backbone.init_backbone", "epsnet.EPSNet.named_modules", "isinstance", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "module.bias.data.zero_", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "module.bias.size"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.backbone.VGGBackbone.init_backbone"], ["", "def", "init_weights", "(", "self", ",", "backbone_path", ")", ":", "\n", "        ", "\"\"\" Initialize weights for training. \"\"\"", "\n", "# Initialize the backbone with the pretrained weights.", "\n", "self", ".", "backbone", ".", "init_backbone", "(", "backbone_path", ")", "\n", "\n", "# Initialize the rest of the conv layers with xavier", "\n", "for", "name", ",", "module", "in", "self", ".", "named_modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "Conv2d", ")", "and", "module", "not", "in", "self", ".", "backbone", ".", "backbone_modules", ":", "\n", "                ", "nn", ".", "init", ".", "xavier_uniform_", "(", "module", ".", "weight", ".", "data", ")", "\n", "\n", "if", "module", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "if", "cfg", ".", "use_focal_loss", "and", "'conf_layer'", "in", "name", ":", "\n", "                        ", "if", "not", "cfg", ".", "use_sigmoid_focal_loss", ":", "\n", "# Initialize the last layer as in the focal loss paper.", "\n", "# Because we use softmax and not sigmoid, I had to derive an alternate expression", "\n", "# on a notecard. Define pi to be the probability of outputting a foreground detection.", "\n", "# Then let z = sum(exp(x)) - exp(x_0). Finally let c be the number of foreground classes.", "\n", "# Chugging through the math, this gives us", "\n", "#   x_0 = log(z * (1 - pi) / pi)    where 0 is the background class", "\n", "#   x_i = log(z / c)                for all i > 0", "\n", "# For simplicity (and because we have a degree of freedom here), set z = 1. Then we have", "\n", "#   x_0 =  log((1 - pi) / pi)       note: don't split up the log for numerical stability", "\n", "#   x_i = -log(c)                   for all i > 0", "\n", "                            ", "module", ".", "bias", ".", "data", "[", "0", "]", "=", "np", ".", "log", "(", "(", "1", "-", "cfg", ".", "focal_loss_init_pi", ")", "/", "cfg", ".", "focal_loss_init_pi", ")", "\n", "module", ".", "bias", ".", "data", "[", "1", ":", "]", "=", "-", "np", ".", "log", "(", "module", ".", "bias", ".", "size", "(", "0", ")", "-", "1", ")", "\n", "", "else", ":", "\n", "                            ", "module", ".", "bias", ".", "data", "[", "0", "]", "=", "-", "np", ".", "log", "(", "cfg", ".", "focal_loss_init_pi", "/", "(", "1", "-", "cfg", ".", "focal_loss_init_pi", ")", ")", "\n", "module", ".", "bias", ".", "data", "[", "1", ":", "]", "=", "-", "np", ".", "log", "(", "(", "1", "-", "cfg", ".", "focal_loss_init_pi", ")", "/", "cfg", ".", "focal_loss_init_pi", ")", "\n", "", "", "else", ":", "\n", "                        ", "module", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.train": [[680, 685], ["super().train", "epsnet.EPSNet.freeze_bn"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.train", "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.freeze_bn"], ["", "", "", "", "", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "train", "(", "mode", ")", "\n", "\n", "if", "cfg", ".", "freeze_bn", ":", "\n", "            ", "self", ".", "freeze_bn", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.freeze_bn": [[686, 694], ["epsnet.EPSNet.modules", "isinstance", "module.eval"], "methods", ["None"], ["", "", "def", "freeze_bn", "(", "self", ")", ":", "\n", "        ", "\"\"\" Adapted from https://discuss.pytorch.org/t/how-to-train-with-frozen-batchnorm/12106/8 \"\"\"", "\n", "for", "module", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "module", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "module", ".", "eval", "(", ")", "\n", "\n", "module", ".", "weight", ".", "requires_grad", "=", "False", "\n", "module", ".", "bias", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.EPSNet.forward": [[695, 844], ["pred_outs.items", "utils.timer.env", "epsnet.EPSNet.backbone", "epsnet.EPSNet.fusion_module", "utils.timer.env", "zip", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "epsnet.EPSNet.detect", "utils.timer.env", "epsnet.EPSNet.fpn", "utils.timer.env", "epsnet.EPSNet.proto_net", "data.config.cfg.mask_proto_prototype_activation", "torch.cat.permute().contiguous", "torch.cat.permute().contiguous", "torch.cat.permute().contiguous", "torch.cat.permute().contiguous", "pred_layer", "pred_layer.items", "epsnet.EPSNet.class_existence_fc", "utils.timer.env", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "epsnet.EPSNet.semantic_seg_conv", "range", "epsnet.EPSNet.grid.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "epsnet.EPSNet.addcoords", "torch.cat.clone", "torch.cat.clone", "torch.cat.clone", "torch.cat.clone", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "epsnet.EPSNet.addcoords", "pred_outs[].append", "num_priors.append", "outs[].mean", "epsnet.EPSNet.semantic_seg_conv", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "epsnet.EPSNet.addcoords", "epsnet.EPSNet.size", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "torch.cat.detach", "torch.cat.permute", "torch.cat.permute", "torch.cat.permute", "torch.cat.permute", "_v.size", "epsnet.EPSNet.addcoords", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "epsnet.EPSNet.CALayer", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "outs[].size"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.detect", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" The input should be of size [batch_size, 3, img_h, img_w] \"\"\"", "\n", "\n", "\n", "# plt.imshow(x.permute(0,2,3,1)[0,:,:,:].detach().cpu().numpy())", "\n", "# plt.savefig('visual_test/input.png')", "\n", "# plt.cla()", "\n", "\n", "\n", "with", "timer", ".", "env", "(", "'backbone'", ")", ":", "\n", "            ", "outs", "=", "self", ".", "backbone", "(", "x", ")", "\n", "\n", "", "if", "cfg", ".", "fpn", "is", "not", "None", ":", "\n", "            ", "with", "timer", ".", "env", "(", "'fpn'", ")", ":", "\n", "# Use backbone.selected_layers because we overwrote self.selected_layers", "\n", "                ", "outs", "=", "[", "outs", "[", "i", "]", "for", "i", "in", "cfg", ".", "backbone", ".", "selected_layers", "]", "\n", "outs", "=", "self", ".", "fpn", "(", "outs", ")", "\n", "\n", "", "", "proto_out", "=", "None", "\n", "if", "cfg", ".", "fpn_fusion", "is", "True", ":", "\n", "            ", "fusion_maps", "=", "self", ".", "fusion_module", "(", "outs", "[", ":", "self", ".", "fusion_layers", "]", ")", "# fusion all levels feature map from map into single one  ", "\n", "\n", "", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", "and", "cfg", ".", "eval_mask_branch", ":", "\n", "            ", "with", "timer", ".", "env", "(", "'proto'", ")", ":", "\n", "                ", "proto_x", "=", "x", "if", "self", ".", "proto_src", "is", "None", "else", "outs", "[", "self", ".", "proto_src", "]", "\n", "\n", "# FPN Fusion", "\n", "if", "cfg", ".", "proto_src_fusion", "is", "True", ":", "\n", "                    ", "proto_x", "=", "fusion_maps", "\n", "\n", "", "if", "cfg", ".", "cross_attention_fusion", "is", "True", ":", "\n", "                    ", "P_query", "=", "outs", "[", "0", "]", "\n", "proto_x", "=", "P_query", "\n", "\n", "for", "layer", "in", "range", "(", "self", ".", "fusion_layers", ")", ":", "\n", "                        ", "z", "=", "self", ".", "CALayer", "(", "x_query", "=", "P_query", ",", "x_key", "=", "outs", "[", "layer", "]", ")", "-", "P_query", "\n", "proto_x", "=", "proto_x", "+", "z", "\n", "\n", "", "", "if", "self", ".", "num_grids", ">", "0", ":", "\n", "                    ", "grids", "=", "self", ".", "grid", ".", "repeat", "(", "proto_x", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", "\n", "proto_x", "=", "torch", ".", "cat", "(", "[", "proto_x", ",", "grids", "]", ",", "dim", "=", "1", ")", "\n", "\n", "", "if", "cfg", ".", "proto_coordconv", ":", "\n", "                    ", "proto_x", "=", "self", ".", "addcoords", "(", "proto_x", ")", "\n", "\n", "", "proto_out", "=", "self", ".", "proto_net", "(", "proto_x", ")", "\n", "proto_out", "=", "cfg", ".", "mask_proto_prototype_activation", "(", "proto_out", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_prototypes_as_features", ":", "\n", "# Clone here because we don't want to permute this, though idk if contiguous makes this unnecessary", "\n", "                    ", "proto_downsampled", "=", "proto_out", ".", "clone", "(", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_prototypes_as_features_no_grad", ":", "\n", "                        ", "proto_downsampled", "=", "proto_out", ".", "detach", "(", ")", "\n", "\n", "# Move the features last so the multiplication is easy", "\n", "", "", "proto_out", "=", "proto_out", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_bias", ":", "\n", "                    ", "bias_shape", "=", "[", "x", "for", "x", "in", "proto_out", ".", "size", "(", ")", "]", "\n", "bias_shape", "[", "-", "1", "]", "=", "1", "\n", "proto_out", "=", "torch", ".", "cat", "(", "[", "proto_out", ",", "torch", ".", "ones", "(", "*", "bias_shape", ")", "]", ",", "-", "1", ")", "\n", "\n", "\n", "", "", "", "with", "timer", ".", "env", "(", "'pred_heads'", ")", ":", "\n", "            ", "pred_outs", "=", "{", "'loc'", ":", "[", "]", ",", "'conf'", ":", "[", "]", ",", "'mask'", ":", "[", "]", ",", "'priors'", ":", "[", "]", "}", "\n", "\n", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "                ", "pred_outs", "[", "'inst'", "]", "=", "[", "]", "\n", "\n", "", "for", "idx", ",", "pred_layer", "in", "zip", "(", "self", ".", "selected_layers", ",", "self", ".", "prediction_layers", ")", ":", "\n", "                ", "pred_x", "=", "outs", "[", "idx", "]", "\n", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", "and", "cfg", ".", "mask_proto_prototypes_as_features", ":", "\n", "# Scale the prototypes down to the current prediction layer's size and add it as inputs", "\n", "                    ", "proto_downsampled", "=", "F", ".", "interpolate", "(", "proto_downsampled", ",", "size", "=", "outs", "[", "idx", "]", ".", "size", "(", ")", "[", "2", ":", "]", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "pred_x", "=", "torch", ".", "cat", "(", "[", "pred_x", ",", "proto_downsampled", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# A hack for the way dataparallel works", "\n", "", "if", "cfg", ".", "share_prediction_module", "and", "pred_layer", "is", "not", "self", ".", "prediction_layers", "[", "0", "]", ":", "\n", "                    ", "pred_layer", ".", "parent", "=", "[", "self", ".", "prediction_layers", "[", "0", "]", "]", "\n", "\n", "", "if", "cfg", ".", "ins_coordconv", ":", "\n", "                    ", "pred_x", "=", "self", ".", "addcoords", "(", "pred_x", ")", "\n", "\n", "", "p", "=", "pred_layer", "(", "pred_x", ")", "\n", "\n", "for", "k", ",", "v", "in", "p", ".", "items", "(", ")", ":", "\n", "                    ", "pred_outs", "[", "k", "]", ".", "append", "(", "v", ")", "\n", "\n", "# ===revised=== ", "\n", "", "", "", "num_priors", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "pred_outs", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "==", "'loc'", ":", "\n", "                ", "for", "_v", "in", "v", ":", "\n", "                    ", "num_priors", ".", "append", "(", "_v", ".", "size", "(", "1", ")", ")", "\n", "", "", "pred_outs", "[", "k", "]", "=", "torch", ".", "cat", "(", "v", ",", "-", "2", ")", "\n", "", "pred_outs", "[", "'layer'", "]", "=", "num_priors", "\n", "\n", "\n", "if", "proto_out", "is", "not", "None", ":", "\n", "            ", "pred_outs", "[", "'proto'", "]", "=", "proto_out", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "\n", "# For the extra loss functions", "\n", "            ", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "                ", "pred_outs", "[", "'classes'", "]", "=", "self", ".", "class_existence_fc", "(", "outs", "[", "-", "1", "]", ".", "mean", "(", "dim", "=", "(", "2", ",", "3", ")", ")", ")", "\n", "\n", "", "with", "timer", ".", "env", "(", "'segm'", ")", ":", "\n", "                ", "if", "cfg", ".", "use_semantic_segmentation_loss", ":", "\n", "                    ", "sem_in", "=", "None", "\n", "if", "cfg", ".", "sem_src_fusion", "is", "True", ":", "\n", "                        ", "sem_in", "=", "fusion_maps", "\n", "", "elif", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "                        ", "sem_in", "=", "outs", "[", "-", "1", "]", "\n", "\n", "", "if", "cfg", ".", "sem_coordconv", ":", "\n", "                        ", "sem_in", "=", "self", ".", "addcoords", "(", "sem_in", ")", "\n", "\n", "", "pred_outs", "[", "'segm'", "]", "=", "self", ".", "semantic_seg_conv", "(", "sem_in", ")", "\n", "# pred_outs['segm'] = self.semantic_seg_conv(outs[-1]) #lincomb version", "\n", "\n", "", "", "return", "pred_outs", "\n", "", "else", ":", "\n", "            ", "if", "cfg", ".", "use_sigmoid_focal_loss", ":", "\n", "# Note: even though conf[0] exists, this mode doesn't train it so don't use it", "\n", "                ", "pred_outs", "[", "'conf'", "]", "=", "torch", ".", "sigmoid", "(", "pred_outs", "[", "'conf'", "]", ")", "\n", "", "elif", "cfg", ".", "use_objectness_score", ":", "\n", "# See focal_loss_sigmoid in multibox_loss.py for details", "\n", "                ", "objectness", "=", "torch", ".", "sigmoid", "(", "pred_outs", "[", "'conf'", "]", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "pred_outs", "[", "'conf'", "]", "[", ":", ",", ":", ",", "1", ":", "]", "=", "objectness", "[", ":", ",", ":", ",", "None", "]", "*", "F", ".", "softmax", "(", "pred_outs", "[", "'conf'", "]", "[", ":", ",", ":", ",", "1", ":", "]", ",", "-", "1", ")", "\n", "pred_outs", "[", "'conf'", "]", "[", ":", ",", ":", ",", "0", "]", "=", "1", "-", "objectness", "\n", "", "else", ":", "\n", "                ", "pred_outs", "[", "'conf'", "]", "=", "F", ".", "softmax", "(", "pred_outs", "[", "'conf'", "]", ",", "-", "1", ")", "\n", "\n", "", "if", "cfg", ".", "use_sem_output", "is", "True", ":", "\n", "                ", "sem_in", "=", "None", "\n", "if", "cfg", ".", "sem_src_fusion", "is", "True", ":", "\n", "                    ", "sem_in", "=", "fusion_maps", "\n", "", "elif", "cfg", ".", "sem_lincomb", "is", "True", ":", "\n", "                    ", "sem_in", "=", "outs", "[", "-", "1", "]", "\n", "\n", "", "if", "cfg", ".", "sem_coordconv", ":", "\n", "                    ", "sem_in", "=", "self", ".", "addcoords", "(", "sem_in", ")", "\n", "\n", "", "pred_outs", "[", "'segm'", "]", "=", "self", ".", "semantic_seg_conv", "(", "sem_in", ")", "\n", "\n", "", "return", "self", ".", "detect", "(", "pred_outs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.None.epsnet.make_net": [[48, 104], ["sum", "isinstance", "epsnet.make_net.make_layer", "data.config.cfg.extra_head_net", "data.config.cfg.mask_proto_net"], "function", ["None"], ["", "", "def", "make_net", "(", "in_channels", ",", "conf", ",", "include_last_relu", "=", "True", ",", "list_only", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    A helper function to take a config setting and turn it into a network.\n    Used by protonet and extrahead. Returns (network, out_channels)\n    \"\"\"", "\n", "def", "make_layer", "(", "layer_cfg", ")", ":", "\n", "        ", "nonlocal", "in_channels", "\n", "\n", "# Possible patterns:", "\n", "# ( 256, 3, {}) -> conv", "\n", "# ( 256,-2, {}) -> deconv", "\n", "# (None,-2, {}) -> bilinear interpolate", "\n", "# ('cat',[],{}) -> concat the subnetworks in the list", "\n", "#", "\n", "# You know it would have probably been simpler just to adopt a 'c' 'd' 'u' naming scheme.", "\n", "# Whatever, it's too late now.", "\n", "if", "isinstance", "(", "layer_cfg", "[", "0", "]", ",", "str", ")", ":", "\n", "            ", "layer_name", "=", "layer_cfg", "[", "0", "]", "\n", "\n", "if", "layer_name", "==", "'cat'", ":", "\n", "                ", "nets", "=", "[", "make_net", "(", "in_channels", ",", "x", ")", "for", "x", "in", "layer_cfg", "[", "1", "]", "]", "\n", "layer", "=", "Concat", "(", "[", "net", "[", "0", "]", "for", "net", "in", "nets", "]", ",", "layer_cfg", "[", "2", "]", ")", "\n", "num_channels", "=", "sum", "(", "[", "net", "[", "1", "]", "for", "net", "in", "nets", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "num_channels", "=", "layer_cfg", "[", "0", "]", "\n", "kernel_size", "=", "layer_cfg", "[", "1", "]", "\n", "\n", "if", "kernel_size", ">", "0", ":", "\n", "                ", "layer", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "num_channels", ",", "kernel_size", ",", "**", "layer_cfg", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                ", "if", "num_channels", "is", "None", ":", "\n", "                    ", "layer", "=", "InterpolateModule", "(", "scale_factor", "=", "-", "kernel_size", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ",", "**", "layer_cfg", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                    ", "layer", "=", "nn", ".", "ConvTranspose2d", "(", "in_channels", ",", "num_channels", ",", "-", "kernel_size", ",", "**", "layer_cfg", "[", "2", "]", ")", "\n", "\n", "", "", "", "in_channels", "=", "num_channels", "if", "num_channels", "is", "not", "None", "else", "in_channels", "\n", "\n", "# Don't return a ReLU layer if we're doing an upsample. This probably doesn't affect anything", "\n", "# output-wise, but there's no need to go through a ReLU here.", "\n", "# Commented out for backwards compatibility with previous models", "\n", "if", "num_channels", "is", "None", ":", "\n", "            ", "return", "[", "layer", "]", "\n", "", "else", ":", "\n", "# return [layer, nn.BatchNorm2d(in_channels) ,nn.ReLU(inplace=True)]", "\n", "            ", "return", "[", "layer", ",", "nn", ".", "GroupNorm", "(", "32", ",", "in_channels", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", "\n", "\n", "\n", "# Use sum to concat together all the component layer lists", "\n", "", "", "net", "=", "sum", "(", "[", "make_layer", "(", "x", ")", "for", "x", "in", "conf", "]", ",", "[", "]", ")", "\n", "if", "not", "include_last_relu", ":", "\n", "        ", "net", "=", "net", "[", ":", "-", "1", "]", "\n", "\n", "", "if", "list_only", "is", "True", ":", "\n", "        ", "return", "net", "\n", "", "else", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "*", "(", "net", ")", ")", ",", "in_channels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.env.__init__": [[122, 125], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "fn_name", ",", "use_stack", "=", "True", ")", ":", "\n", "\t\t", "self", ".", "fn_name", "=", "fn_name", "\n", "self", ".", "use_stack", "=", "use_stack", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.env.__enter__": [[126, 128], ["timer.start"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.start"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "\t\t", "start", "(", "self", ".", "fn_name", ",", "use_stack", "=", "self", ".", "use_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.env.__exit__": [[129, 131], ["timer.stop"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.stop"], ["", "def", "__exit__", "(", "self", ",", "e", ",", "ev", ",", "t", ")", ":", "\n", "\t\t", "stop", "(", "self", ".", "fn_name", ",", "use_stack", "=", "self", ".", "use_stack", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.disable_all": [[11, 14], ["None"], "function", ["None"], ["def", "disable_all", "(", ")", ":", "\n", "\t", "global", "_disable_all", "\n", "_disable_all", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.enable_all": [[15, 18], ["None"], "function", ["None"], ["", "def", "enable_all", "(", ")", ":", "\n", "\t", "global", "_disable_all", "\n", "_disable_all", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.disable": [[19, 22], ["_disabled_names.add"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add"], ["", "def", "disable", "(", "fn_name", ")", ":", "\n", "\t", "\"\"\" Disables the given function name fom being considered for the average or outputted in print_stats. \"\"\"", "\n", "_disabled_names", ".", "add", "(", "fn_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.enable": [[23, 26], ["_disabled_names.remove"], "function", ["None"], ["", "def", "enable", "(", "fn_name", ")", ":", "\n", "\t", "\"\"\" Enables function names disabled by disable. \"\"\"", "\n", "_disabled_names", ".", "remove", "(", "fn_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.reset": [[27, 34], ["_total_times.clear", "_start_times.clear", "_timer_stack.clear"], "function", ["None"], ["", "def", "reset", "(", ")", ":", "\n", "\t", "\"\"\" Resets the current timer. Call this at the start of an iteration. \"\"\"", "\n", "global", "_running_timer", "\n", "_total_times", ".", "clear", "(", ")", "\n", "_start_times", ".", "clear", "(", ")", "\n", "_timer_stack", ".", "clear", "(", ")", "\n", "_running_timer", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.start": [[35, 54], ["timer.start", "time.perf_counter", "timer.stop", "_timer_stack.append"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.start", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.stop", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "start", "(", "fn_name", ",", "use_stack", "=", "True", ")", ":", "\n", "\t", "\"\"\"\n\tStart timing the specific function.\n\tNote: If use_stack is True, only one timer can be active at a time.\n\t      Once you stop this timer, the previous one will start again.\n\t\"\"\"", "\n", "global", "_running_timer", ",", "_disable_all", "\n", "\n", "if", "_disable_all", ":", "\n", "\t\t", "return", "\n", "\n", "", "if", "use_stack", ":", "\n", "\t\t", "if", "_running_timer", "is", "not", "None", ":", "\n", "\t\t\t", "stop", "(", "_running_timer", ",", "use_stack", "=", "False", ")", "\n", "_timer_stack", ".", "append", "(", "_running_timer", ")", "\n", "", "start", "(", "fn_name", ",", "use_stack", "=", "False", ")", "\n", "_running_timer", "=", "fn_name", "\n", "", "else", ":", "\n", "\t\t", "_start_times", "[", "fn_name", "]", "=", "time", ".", "perf_counter", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.stop": [[55, 83], ["timer.stop", "print", "print", "len", "_timer_stack.pop", "timer.start", "time.perf_counter"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.stop", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.start"], ["", "", "def", "stop", "(", "fn_name", "=", "None", ",", "use_stack", "=", "True", ")", ":", "\n", "\t", "\"\"\"\n\tIf use_stack is True, this will stop the currently running timer and restore\n\tthe previous timer on the stack if that exists. Note if use_stack is True,\n\tfn_name will be ignored.\n\n\tIf use_stack is False, this will just stop timing the timer fn_name.\n\t\"\"\"", "\n", "global", "_running_timer", ",", "_disable_all", "\n", "\n", "if", "_disable_all", ":", "\n", "\t\t", "return", "\n", "\n", "", "if", "use_stack", ":", "\n", "\t\t", "if", "_running_timer", "is", "not", "None", ":", "\n", "\t\t\t", "stop", "(", "_running_timer", ",", "use_stack", "=", "False", ")", "\n", "if", "len", "(", "_timer_stack", ")", ">", "0", ":", "\n", "\t\t\t\t", "_running_timer", "=", "_timer_stack", ".", "pop", "(", ")", "\n", "start", "(", "_running_timer", ",", "use_stack", "=", "False", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "_running_timer", "=", "None", "\n", "", "", "else", ":", "\n", "\t\t\t", "print", "(", "'Warning: timer stopped with no timer running!'", ")", "\n", "", "", "else", ":", "\n", "\t\t", "if", "_start_times", "[", "fn_name", "]", ">", "-", "1", ":", "\n", "\t\t\t", "_total_times", "[", "fn_name", "]", "+=", "time", ".", "perf_counter", "(", ")", "-", "_start_times", "[", "fn_name", "]", "\n", "", "else", ":", "\n", "\t\t\t", "print", "(", "'Warning: timer for %s stopped before starting!'", "%", "fn_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.print_stats": [[85, 108], ["print", "max", "print", "header.find", "print", "print", "print", "print", "print", "format_str.format", "_total_times.keys", "format_str.format", "len", "timer.total_time", "len"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.total_time"], ["", "", "", "def", "print_stats", "(", ")", ":", "\n", "\t", "\"\"\" Prints the current timing information into a table. \"\"\"", "\n", "print", "(", ")", "\n", "\n", "all_fn_names", "=", "[", "k", "for", "k", "in", "_total_times", ".", "keys", "(", ")", "if", "k", "not", "in", "_disabled_names", "]", "\n", "\n", "max_name_width", "=", "max", "(", "[", "len", "(", "k", ")", "for", "k", "in", "all_fn_names", "]", "+", "[", "4", "]", ")", "\n", "if", "max_name_width", "%", "2", "==", "1", ":", "max_name_width", "+=", "1", "\n", "format_str", "=", "' {:>%d} | {:>10.4f} '", "%", "max_name_width", "\n", "\n", "header", "=", "(", "' {:^%d} | {:^10} '", "%", "max_name_width", ")", ".", "format", "(", "'Name'", ",", "'Time (ms)'", ")", "\n", "print", "(", "header", ")", "\n", "\n", "sep_idx", "=", "header", ".", "find", "(", "'|'", ")", "\n", "sep_text", "=", "(", "'-'", "*", "sep_idx", ")", "+", "'+'", "+", "'-'", "*", "(", "len", "(", "header", ")", "-", "sep_idx", "-", "1", ")", "\n", "print", "(", "sep_text", ")", "\n", "\n", "for", "name", "in", "all_fn_names", ":", "\n", "\t\t", "print", "(", "format_str", ".", "format", "(", "name", ",", "_total_times", "[", "name", "]", "*", "1000", ")", ")", "\n", "\n", "", "print", "(", "sep_text", ")", "\n", "print", "(", "format_str", ".", "format", "(", "'Total'", ",", "total_time", "(", ")", "*", "1000", ")", ")", "\n", "print", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.timer.total_time": [[109, 112], ["sum", "_total_times.items"], "function", ["None"], ["", "def", "total_time", "(", ")", ":", "\n", "\t", "\"\"\" Returns the total amount accumulated across all functions in seconds. \"\"\"", "\n", "return", "sum", "(", "[", "elapsed_time", "for", "name", ",", "elapsed_time", "in", "_total_times", ".", "items", "(", ")", "if", "name", "not", "in", "_disabled_names", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.__init__": [[11, 14], ["functions.MovingAverage.reset"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.reset"], ["def", "__init__", "(", "self", ",", "max_window_size", "=", "1000", ")", ":", "\n", "        ", "self", ".", "max_window_size", "=", "max_window_size", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.add": [[15, 26], ["functions.MovingAverage.window.append", "math.isfinite", "print", "len", "functions.MovingAverage.window.popleft"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "def", "add", "(", "self", ",", "elem", ")", ":", "\n", "        ", "\"\"\" Adds an element to the window, removing the earliest element if necessary. \"\"\"", "\n", "if", "not", "math", ".", "isfinite", "(", "elem", ")", ":", "\n", "            ", "print", "(", "'Warning: Moving average ignored a value of %f'", "%", "elem", ")", "\n", "return", "\n", "\n", "", "self", ".", "window", ".", "append", "(", "elem", ")", "\n", "self", ".", "sum", "+=", "elem", "\n", "\n", "if", "len", "(", "self", ".", "window", ")", ">", "self", ".", "max_window_size", ":", "\n", "            ", "self", ".", "sum", "-=", "self", ".", "window", ".", "popleft", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append": [[27, 30], ["functions.MovingAverage.add"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add"], ["", "", "def", "append", "(", "self", ",", "elem", ")", ":", "\n", "        ", "\"\"\" Same as add just more pythonic. \"\"\"", "\n", "self", ".", "add", "(", "elem", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.reset": [[31, 35], ["collections.deque"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "\"\"\" Resets the MovingAverage to its initial state. \"\"\"", "\n", "self", ".", "window", "=", "deque", "(", ")", "\n", "self", ".", "sum", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg": [[36, 39], ["max", "len"], "methods", ["None"], ["", "def", "get_avg", "(", "self", ")", ":", "\n", "        ", "\"\"\" Returns the average of the elements in the window. \"\"\"", "\n", "return", "self", ".", "sum", "/", "max", "(", "len", "(", "self", ".", "window", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.__str__": [[40, 42], ["str", "functions.MovingAverage.get_avg"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "get_avg", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.__repr__": [[43, 45], ["repr", "functions.MovingAverage.get_avg"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "get_avg", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.__init__": [[50, 57], ["functions.ProgressBar._update_str"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar._update_str"], ["def", "__init__", "(", "self", ",", "length", ",", "max_val", ")", ":", "\n", "        ", "self", ".", "max_val", "=", "max_val", "\n", "self", ".", "length", "=", "length", "\n", "self", ".", "cur_val", "=", "0", "\n", "\n", "self", ".", "cur_num_bars", "=", "-", "1", "\n", "self", ".", "_update_str", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val": [[58, 67], ["functions.ProgressBar._update_str"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar._update_str"], ["", "def", "set_val", "(", "self", ",", "new_val", ")", ":", "\n", "        ", "self", ".", "cur_val", "=", "new_val", "\n", "\n", "if", "self", ".", "cur_val", ">", "self", ".", "max_val", ":", "\n", "            ", "self", ".", "cur_val", "=", "self", ".", "max_val", "\n", "", "if", "self", ".", "cur_val", "<", "0", ":", "\n", "            ", "self", ".", "cur_val", "=", "0", "\n", "\n", "", "self", ".", "_update_str", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.is_finished": [[68, 70], ["None"], "methods", ["None"], ["", "def", "is_finished", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "cur_val", "==", "self", ".", "max_val", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar._update_str": [[71, 77], ["int"], "methods", ["None"], ["", "def", "_update_str", "(", "self", ")", ":", "\n", "        ", "num_bars", "=", "int", "(", "self", ".", "length", "*", "(", "self", ".", "cur_val", "/", "self", ".", "max_val", ")", ")", "\n", "\n", "if", "num_bars", "!=", "self", ".", "cur_num_bars", ":", "\n", "            ", "self", ".", "cur_num_bars", "=", "num_bars", "\n", "self", ".", "string", "=", "'\u2588'", "*", "num_bars", "+", "'\u2591'", "*", "(", "self", ".", "length", "-", "num_bars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.__repr__": [[78, 80], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.__str__": [[81, 83], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "string", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.__init__": [[101, 105], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model_name", ":", "str", ",", "epoch", ":", "int", ",", "iteration", ":", "int", ")", ":", "\n", "        ", "self", ".", "model_name", "=", "model_name", "\n", "self", ".", "epoch", "=", "epoch", "\n", "self", ".", "iteration", "=", "iteration", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_path": [[106, 109], ["os.path.join", "str", "str"], "methods", ["None"], ["", "def", "get_path", "(", "self", ",", "root", ":", "str", "=", "''", ")", ":", "\n", "        ", "file_name", "=", "self", ".", "model_name", "+", "'_'", "+", "str", "(", "self", ".", "epoch", ")", "+", "'_'", "+", "str", "(", "self", ".", "iteration", ")", "+", "'.pth'", "\n", "return", "os", ".", "path", ".", "join", "(", "root", ",", "file_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.from_str": [[110, 127], ["os.path.basename", "os.path.basename.endswith", "os.path.basename.split", "os.path.basename.endswith", "functions.SavePath", "int", "int"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "from_str", "(", "path", ":", "str", ")", ":", "\n", "        ", "file_name", "=", "os", ".", "path", ".", "basename", "(", "path", ")", "\n", "\n", "if", "file_name", ".", "endswith", "(", "'.pth'", ")", ":", "\n", "            ", "file_name", "=", "file_name", "[", ":", "-", "4", "]", "\n", "\n", "", "params", "=", "file_name", ".", "split", "(", "'_'", ")", "\n", "\n", "if", "file_name", ".", "endswith", "(", "'interrupt'", ")", ":", "\n", "            ", "params", "=", "params", "[", ":", "-", "1", "]", "\n", "\n", "", "model_name", "=", "'_'", ".", "join", "(", "params", "[", ":", "-", "2", "]", ")", "\n", "epoch", "=", "params", "[", "-", "2", "]", "\n", "iteration", "=", "params", "[", "-", "1", "]", "\n", "\n", "return", "SavePath", "(", "model_name", ",", "int", "(", "epoch", ")", ",", "int", "(", "iteration", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.remove_interrupt": [[128, 132], ["pathlib.Path().glob", "p.unlink", "pathlib.Path"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "remove_interrupt", "(", "save_folder", ")", ":", "\n", "        ", "for", "p", "in", "Path", "(", "save_folder", ")", ".", "glob", "(", "'*_interrupt.pth'", ")", ":", "\n", "            ", "p", ".", "unlink", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_interrupt": [[133, 138], ["pathlib.Path().glob", "str", "pathlib.Path"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "get_interrupt", "(", "save_folder", ")", ":", "\n", "        ", "for", "p", "in", "Path", "(", "save_folder", ")", ".", "glob", "(", "'*_interrupt.pth'", ")", ":", "\n", "            ", "return", "str", "(", "p", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.get_latest": [[139, 158], ["pathlib.Path().glob", "str", "pathlib.Path", "functions.SavePath.from_str"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.SavePath.from_str"], ["", "@", "staticmethod", "\n", "def", "get_latest", "(", "save_folder", ",", "config", ")", ":", "\n", "        ", "\"\"\" Note: config should be config.name. \"\"\"", "\n", "max_iter", "=", "-", "1", "\n", "max_name", "=", "None", "\n", "\n", "for", "p", "in", "Path", "(", "save_folder", ")", ".", "glob", "(", "config", "+", "'_*'", ")", ":", "\n", "            ", "path_name", "=", "str", "(", "p", ")", "\n", "\n", "try", ":", "\n", "                ", "save", "=", "SavePath", ".", "from_str", "(", "path_name", ")", "\n", "", "except", ":", "\n", "                ", "continue", "\n", "\n", "", "if", "save", ".", "model_name", "==", "config", "and", "save", ".", "iteration", ">", "max_iter", ":", "\n", "                ", "max_iter", "=", "save", ".", "iteration", "\n", "max_name", "=", "path_name", "\n", "\n", "", "", "return", "max_name", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.init_console": [[85, 92], ["init"], "function", ["None"], ["", "", "def", "init_console", "(", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the console to be able to use ANSI escape characters on Windows.\n    \"\"\"", "\n", "if", "os", ".", "name", "==", "'nt'", ":", "\n", "        ", "from", "colorama", "import", "init", "\n", "init", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Compose.__init__": [[49, 51], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transforms", ")", ":", "\n", "        ", "self", ".", "transforms", "=", "transforms", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Compose.__call__": [[52, 56], ["t"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "for", "t", "in", "self", ".", "transforms", ":", "\n", "            ", "img", ",", "masks", ",", "boxes", ",", "labels", "=", "t", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "", "return", "img", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Lambda.__init__": [[61, 64], ["isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lambd", ")", ":", "\n", "        ", "assert", "isinstance", "(", "lambd", ",", "types", ".", "LambdaType", ")", "\n", "self", ".", "lambd", "=", "lambd", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Lambda.__call__": [[65, 67], ["augmentations.Lambda.lambd"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "lambd", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ConvertFromInts.__call__": [[70, 72], ["image.astype"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "image", ".", "astype", "(", "np", ".", "float32", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ToAbsoluteCoords.__call__": [[76, 84], ["None"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "channels", "=", "image", ".", "shape", "\n", "boxes", "[", ":", ",", "0", "]", "*=", "width", "\n", "boxes", "[", ":", ",", "2", "]", "*=", "width", "\n", "boxes", "[", ":", ",", "1", "]", "*=", "height", "\n", "boxes", "[", ":", ",", "3", "]", "*=", "height", "\n", "\n", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ToPercentCoords.__call__": [[87, 95], ["None"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "channels", "=", "image", ".", "shape", "\n", "boxes", "[", ":", ",", "0", "]", "=", "boxes", "[", ":", ",", "0", "]", "/", "width", "\n", "boxes", "[", ":", ",", "2", "]", "=", "boxes", "[", ":", ",", "2", "]", "/", "width", "\n", "boxes", "[", ":", ",", "1", "]", "=", "boxes", "[", ":", ",", "1", "]", "/", "height", "\n", "boxes", "[", ":", ",", "3", "]", "=", "boxes", "[", ":", ",", "3", "]", "/", "height", "\n", "\n", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Pad.__init__": [[104, 109], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "width", ",", "height", ",", "mean", "=", "MEANS", ",", "pad_gt", "=", "True", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "pad_gt", "=", "pad_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Pad.__call__": [[110, 126], ["numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "im_h", ",", "im_w", ",", "depth", "=", "image", ".", "shape", "\n", "expand_image", "=", "np", ".", "zeros", "(", "\n", "(", "self", ".", "height", ",", "self", ".", "width", ",", "depth", ")", ",", "\n", "dtype", "=", "image", ".", "dtype", ")", "\n", "expand_image", "[", ":", ",", ":", ",", ":", "]", "=", "self", ".", "mean", "\n", "expand_image", "[", ":", "im_h", ",", ":", "im_w", "]", "=", "image", "\n", "\n", "if", "self", ".", "pad_gt", ":", "\n", "            ", "expand_masks", "=", "np", ".", "zeros", "(", "\n", "(", "masks", ".", "shape", "[", "0", "]", ",", "self", ".", "height", ",", "self", ".", "width", ")", ",", "\n", "dtype", "=", "masks", ".", "dtype", ")", "\n", "expand_masks", "[", ":", ",", ":", "im_h", ",", ":", "im_w", "]", "=", "masks", "\n", "masks", "=", "expand_masks", "\n", "\n", "", "return", "expand_image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Resize.faster_rcnn_scale": [[137, 148], ["min", "max", "int", "int"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "faster_rcnn_scale", "(", "width", ",", "height", ",", "min_size", ",", "max_size", ")", ":", "\n", "        ", "min_scale", "=", "min_size", "/", "min", "(", "width", ",", "height", ")", "\n", "width", "*=", "min_scale", "\n", "height", "*=", "min_scale", "\n", "\n", "max_scale", "=", "max_size", "/", "max", "(", "width", ",", "height", ")", "\n", "if", "max_scale", "<", "1", ":", "# If a size is greater than max_size", "\n", "            ", "width", "*=", "max_scale", "\n", "height", "*=", "max_scale", "\n", "", "return", "int", "(", "width", ")", ",", "int", "(", "height", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Resize.__init__": [[149, 154], ["None"], "methods", ["None"], ["", "def", "__init__", "(", "self", ",", "resize_gt", "=", "True", ")", ":", "\n", "        ", "self", ".", "resize_gt", "=", "resize_gt", "\n", "self", ".", "min_size", "=", "cfg", ".", "min_size", "\n", "self", ".", "max_size", "=", "cfg", ".", "max_size", "\n", "self", ".", "preserve_aspect_ratio", "=", "cfg", ".", "preserve_aspect_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Resize.__call__": [[155, 182], ["cv2.resize", "augmentations.Resize.faster_rcnn_scale", "masks.transpose.transpose.transpose", "cv2.resize", "len", "numpy.expand_dims", "masks.transpose.transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Resize.faster_rcnn_scale"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", "=", "None", ")", ":", "\n", "        ", "img_h", ",", "img_w", ",", "_", "=", "image", ".", "shape", "\n", "\n", "if", "self", ".", "preserve_aspect_ratio", ":", "\n", "            ", "width", ",", "height", "=", "Resize", ".", "faster_rcnn_scale", "(", "img_w", ",", "img_h", ",", "self", ".", "min_size", ",", "self", ".", "max_size", ")", "\n", "", "else", ":", "\n", "            ", "width", ",", "height", "=", "cfg", ".", "input_w", ",", "cfg", ".", "input_h", "\n", "\n", "", "image", "=", "cv2", ".", "resize", "(", "image", ",", "(", "width", ",", "height", ")", ")", "\n", "\n", "if", "self", ".", "resize_gt", ":", "\n", "# Act like each object is a color channel", "\n", "            ", "masks", "=", "masks", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "masks", "=", "cv2", ".", "resize", "(", "masks", ",", "(", "width", ",", "height", ")", ")", "\n", "\n", "# OpenCV resizes a (w,h,1) array to (s,s), so fix that", "\n", "if", "len", "(", "masks", ".", "shape", ")", "==", "2", ":", "\n", "                ", "masks", "=", "np", ".", "expand_dims", "(", "masks", ",", "0", ")", "\n", "", "else", ":", "\n", "                ", "masks", "=", "masks", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "# Scale bounding boxes (which are currently absolute coordinates)", "\n", "", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "=", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "*", "(", "width", "/", "img_w", ")", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "=", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "*", "(", "height", "/", "img_h", ")", "\n", "\n", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomScale.__init__": [[184, 195], ["int", "numpy.random.uniform", "int", "int", "numpy.random.uniform"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "resize_gt", "=", "True", ")", ":", "\n", "        ", "self", ".", "resize_gt", "=", "resize_gt", "\n", "if", "cfg", ".", "input_w", "==", "cfg", ".", "input_h", ":", "\n", "            ", "scale_min", ",", "scale_max", "=", "cfg", ".", "augment_random_scale_range", "\n", "self", ".", "scale_size_w", "=", "int", "(", "np", ".", "random", ".", "uniform", "(", "scale_min", ",", "scale_max", ")", ")", "\n", "self", ".", "scale_size_h", "=", "self", ".", "scale_size_w", "\n", "", "else", ":", "\n", "            ", "scale_min", ",", "scale_max", "=", "cfg", ".", "augment_random_scale_ratio", "\n", "scale_ratio", "=", "np", ".", "random", ".", "uniform", "(", "scale_min", ",", "scale_max", ")", "\n", "self", ".", "scale_size_w", "=", "int", "(", "cfg", ".", "origin_w", "*", "scale_ratio", ")", "\n", "self", ".", "scale_size_h", "=", "int", "(", "cfg", ".", "origin_h", "*", "scale_ratio", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomScale.__call__": [[196, 218], ["cv2.resize", "masks.transpose.transpose.transpose", "cv2.resize", "len", "numpy.expand_dims", "masks.transpose.transpose.transpose"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", "=", "None", ")", ":", "\n", "        ", "img_h", ",", "img_w", ",", "_", "=", "image", ".", "shape", "\n", "\n", "width", ",", "height", "=", "self", ".", "scale_size_w", ",", "self", ".", "scale_size_h", "\n", "image", "=", "cv2", ".", "resize", "(", "image", ",", "(", "width", ",", "height", ")", ")", "\n", "\n", "if", "self", ".", "resize_gt", ":", "\n", "# Act like each object is a color channel", "\n", "            ", "masks", "=", "masks", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "masks", "=", "cv2", ".", "resize", "(", "masks", ",", "(", "width", ",", "height", ")", ")", "\n", "\n", "# OpenCV resizes a (w,h,1) array to (s,s), so fix that", "\n", "if", "len", "(", "masks", ".", "shape", ")", "==", "2", ":", "\n", "                ", "masks", "=", "np", ".", "expand_dims", "(", "masks", ",", "0", ")", "\n", "", "else", ":", "\n", "                ", "masks", "=", "masks", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "# Scale bounding boxes (which are currently absolute coordinates)", "\n", "", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "=", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "*", "(", "width", "/", "img_w", ")", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "=", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "*", "(", "height", "/", "img_h", ")", "\n", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomSaturation.__init__": [[221, 226], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lower", "=", "0.5", ",", "upper", "=", "1.5", ")", ":", "\n", "        ", "self", ".", "lower", "=", "lower", "\n", "self", ".", "upper", "=", "upper", "\n", "assert", "self", ".", "upper", ">=", "self", ".", "lower", ",", "\"contrast upper must be >= lower.\"", "\n", "assert", "self", ".", "lower", ">=", "0", ",", "\"contrast lower must be non-negative.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomSaturation.__call__": [[227, 232], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "[", ":", ",", ":", ",", "1", "]", "*=", "random", ".", "uniform", "(", "self", ".", "lower", ",", "self", ".", "upper", ")", "\n", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomHue.__init__": [[235, 238], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "delta", "=", "18.0", ")", ":", "\n", "        ", "assert", "delta", ">=", "0.0", "and", "delta", "<=", "360.0", "\n", "self", ".", "delta", "=", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomHue.__call__": [[239, 245], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "[", ":", ",", ":", ",", "0", "]", "+=", "random", ".", "uniform", "(", "-", "self", ".", "delta", ",", "self", ".", "delta", ")", "\n", "image", "[", ":", ",", ":", ",", "0", "]", "[", "image", "[", ":", ",", ":", ",", "0", "]", ">", "360.0", "]", "-=", "360.0", "\n", "image", "[", ":", ",", ":", ",", "0", "]", "[", "image", "[", ":", ",", ":", ",", "0", "]", "<", "0.0", "]", "+=", "360.0", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomLightingNoise.__init__": [[248, 252], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "perms", "=", "(", "(", "0", ",", "1", ",", "2", ")", ",", "(", "0", ",", "2", ",", "1", ")", ",", "\n", "(", "1", ",", "0", ",", "2", ")", ",", "(", "1", ",", "2", ",", "0", ")", ",", "\n", "(", "2", ",", "0", ",", "1", ")", ",", "(", "2", ",", "1", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomLightingNoise.__call__": [[253, 261], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "# Don't shuffle the channels please, why would you do this", "\n", "\n", "# if random.randint(2):", "\n", "#     swap = self.perms[random.randint(len(self.perms))]", "\n", "#     shuffle = SwapChannels(swap)  # shuffle channels", "\n", "#     image = shuffle(image)", "\n", "        ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ConvertColor.__init__": [[264, 267], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "current", "=", "'BGR'", ",", "transform", "=", "'HSV'", ")", ":", "\n", "        ", "self", ".", "transform", "=", "transform", "\n", "self", ".", "current", "=", "current", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ConvertColor.__call__": [[268, 276], ["cv2.cvtColor", "cv2.cvtColor"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "current", "==", "'BGR'", "and", "self", ".", "transform", "==", "'HSV'", ":", "\n", "            ", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "", "elif", "self", ".", "current", "==", "'HSV'", "and", "self", ".", "transform", "==", "'BGR'", ":", "\n", "            ", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomContrast.__init__": [[279, 284], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "lower", "=", "0.5", ",", "upper", "=", "1.5", ")", ":", "\n", "        ", "self", ".", "lower", "=", "lower", "\n", "self", ".", "upper", "=", "upper", "\n", "assert", "self", ".", "upper", ">=", "self", ".", "lower", ",", "\"contrast upper must be >= lower.\"", "\n", "assert", "self", ".", "lower", ">=", "0", ",", "\"contrast lower must be non-negative.\"", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomContrast.__call__": [[286, 291], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "alpha", "=", "random", ".", "uniform", "(", "self", ".", "lower", ",", "self", ".", "upper", ")", "\n", "image", "*=", "alpha", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomBrightness.__init__": [[294, 298], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "delta", "=", "32", ")", ":", "\n", "        ", "assert", "delta", ">=", "0.0", "\n", "assert", "delta", "<=", "255.0", "\n", "self", ".", "delta", "=", "delta", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomBrightness.__call__": [[299, 304], ["numpy.random.randint", "numpy.random.uniform"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "delta", "=", "random", ".", "uniform", "(", "-", "self", ".", "delta", ",", "self", ".", "delta", ")", "\n", "image", "+=", "delta", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ToCV2Image.__call__": [[307, 309], ["tensor.cpu().numpy().astype().transpose", "tensor.cpu().numpy().astype", "tensor.cpu().numpy", "tensor.cpu"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "tensor", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "tensor", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.ToTensor.__call__": [[312, 314], ["torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "cvimage.astype"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "cvimage", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "torch", ".", "from_numpy", "(", "cvimage", ".", "astype", "(", "np", ".", "float32", ")", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomSampleCrop.__init__": [[329, 340], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "sample_options", "=", "(", "\n", "# using entire original input image", "\n", "None", ",", "\n", "# sample a patch s.t. MIN jaccard w/ obj in .1,.3,.4,.7,.9", "\n", "(", "0.1", ",", "None", ")", ",", "\n", "(", "0.3", ",", "None", ")", ",", "\n", "(", "0.7", ",", "None", ")", ",", "\n", "(", "0.9", ",", "None", ")", ",", "\n", "# randomly sample a patch", "\n", "(", "None", ",", "None", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomSampleCrop.__call__": [[342, 442], ["numpy.random.choice", "range", "float", "float", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "augmentations.jaccard_numpy", "numpy.zeros", "masks[].copy", "boxes[].copy", "numpy.maximum", "numpy.minimum", "numpy.sum", "int", "int", "int", "int", "jaccard_numpy.min", "jaccard_numpy.max", "mask.any", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.jaccard_numpy", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "while", "True", ":", "\n", "# randomly choose a mode", "\n", "            ", "mode", "=", "random", ".", "choice", "(", "self", ".", "sample_options", ")", "\n", "if", "mode", "is", "None", ":", "\n", "                ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "min_iou", ",", "max_iou", "=", "mode", "\n", "if", "min_iou", "is", "None", ":", "\n", "                ", "min_iou", "=", "float", "(", "'-inf'", ")", "\n", "", "if", "max_iou", "is", "None", ":", "\n", "                ", "max_iou", "=", "float", "(", "'inf'", ")", "\n", "\n", "# max trails (50)", "\n", "", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "                ", "current_image", "=", "image", "\n", "\n", "w", "=", "random", ".", "uniform", "(", "0.3", "*", "width", ",", "width", ")", "\n", "h", "=", "random", ".", "uniform", "(", "0.3", "*", "height", ",", "height", ")", "\n", "\n", "# aspect ratio constraint b/t .5 & 2", "\n", "if", "h", "/", "w", "<", "0.5", "or", "h", "/", "w", ">", "2", ":", "\n", "                    ", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "width", "-", "w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "height", "-", "h", ")", "\n", "\n", "# convert to integer rect x1,y1,x2,y2", "\n", "rect", "=", "np", ".", "array", "(", "[", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "w", ")", ",", "int", "(", "top", "+", "h", ")", "]", ")", "\n", "\n", "# calculate IoU (jaccard overlap) b/t the cropped and gt boxes", "\n", "overlap", "=", "jaccard_numpy", "(", "boxes", ",", "rect", ")", "\n", "\n", "# This piece of code is bugged and does nothing:", "\n", "# https://github.com/amdegroot/ssd.pytorch/issues/68", "\n", "#", "\n", "# However, when I fixed it with overlap.max() < min_iou,", "\n", "# it cut the mAP in half (after 8k iterations). So it stays.", "\n", "#", "\n", "# is min and max overlap constraint satisfied? if not try again", "\n", "if", "overlap", ".", "min", "(", ")", "<", "min_iou", "and", "max_iou", "<", "overlap", ".", "max", "(", ")", ":", "\n", "                    ", "continue", "\n", "\n", "# cut the crop from the image", "\n", "", "current_image", "=", "current_image", "[", "rect", "[", "1", "]", ":", "rect", "[", "3", "]", ",", "rect", "[", "0", "]", ":", "rect", "[", "2", "]", ",", "\n", ":", "]", "\n", "\n", "# keep overlap with gt box IF center in sampled patch", "\n", "centers", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2.0", "\n", "\n", "# mask in all gt boxes that above and to the left of centers", "\n", "m1", "=", "(", "rect", "[", "0", "]", "<", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "1", "]", "<", "centers", "[", ":", ",", "1", "]", ")", "\n", "\n", "# mask in all gt boxes that under and to the right of centers", "\n", "m2", "=", "(", "rect", "[", "2", "]", ">", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "3", "]", ">", "centers", "[", ":", ",", "1", "]", ")", "\n", "\n", "# mask in that both m1 and m2 are true", "\n", "mask", "=", "m1", "*", "m2", "\n", "\n", "# [0 ... 0 for num_gt and then 1 ... 1 for num_crowds]", "\n", "num_crowds", "=", "labels", "[", "'num_crowds'", "]", "\n", "crowd_mask", "=", "np", ".", "zeros", "(", "mask", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "if", "num_crowds", ">", "0", ":", "\n", "                    ", "crowd_mask", "[", "-", "num_crowds", ":", "]", "=", "1", "\n", "\n", "# have any valid boxes? try again if not", "\n", "# Also make sure you have at least one regular gt", "\n", "", "if", "not", "mask", ".", "any", "(", ")", "or", "np", ".", "sum", "(", "1", "-", "crowd_mask", "[", "mask", "]", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "# take only the matching gt masks", "\n", "", "current_masks", "=", "masks", "[", "mask", ",", ":", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "# take only matching gt boxes", "\n", "current_boxes", "=", "boxes", "[", "mask", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "# take only matching gt labels", "\n", "labels", "[", "'labels'", "]", "=", "labels", "[", "'labels'", "]", "[", "mask", "]", "\n", "current_labels", "=", "labels", "\n", "\n", "# We now might have fewer crowd annotations", "\n", "if", "num_crowds", ">", "0", ":", "\n", "                    ", "labels", "[", "'num_crowds'", "]", "=", "np", ".", "sum", "(", "crowd_mask", "[", "mask", "]", ")", "\n", "\n", "# should we use the box left and top corner or the crop's", "\n", "", "current_boxes", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "current_boxes", "[", ":", ",", ":", "2", "]", ",", "\n", "rect", "[", ":", "2", "]", ")", "\n", "# adjust to crop (by substracting crop's left,top)", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "current_boxes", "[", ":", ",", "2", ":", "]", ",", "\n", "rect", "[", "2", ":", "]", ")", "\n", "# adjust to crop (by substracting crop's left,top)", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "# crop the current masks to the same dimensions as the image", "\n", "current_masks", "=", "current_masks", "[", ":", ",", "rect", "[", "1", "]", ":", "rect", "[", "3", "]", ",", "rect", "[", "0", "]", ":", "rect", "[", "2", "]", "]", "\n", "\n", "return", "current_image", ",", "current_masks", ",", "current_boxes", ",", "current_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomCrop.__init__": [[457, 468], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "sample_options", "=", "(", "\n", "# using entire original input image", "\n", "# None,", "\n", "# sample a patch s.t. MIN jaccard w/ obj in .1,.3,.4,.7,.9", "\n", "(", "0.1", ",", "None", ")", ",", "\n", "(", "0.3", ",", "None", ")", ",", "\n", "(", "0.7", ",", "None", ")", ",", "\n", "(", "0.9", ",", "None", ")", ",", "\n", "# randomly sample a patch", "\n", "(", "None", ",", "None", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomCrop.__call__": [[470, 571], ["numpy.random.choice", "range", "len", "float", "float", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "augmentations.jaccard_numpy", "numpy.zeros", "masks[].copy", "boxes[].copy", "numpy.maximum", "numpy.minimum", "numpy.sum", "int", "int", "int", "int", "jaccard_numpy.min", "jaccard_numpy.max", "mask.any", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.jaccard_numpy", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "height", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "while", "True", ":", "\n", "# randomly choose a mode", "\n", "            ", "mode_idx", "=", "random", ".", "choice", "(", "len", "(", "self", ".", "sample_options", ")", ",", "1", ")", "\n", "mode", "=", "self", ".", "sample_options", "[", "mode_idx", "[", "0", "]", "]", "\n", "if", "mode", "is", "None", ":", "\n", "                ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "min_iou", ",", "max_iou", "=", "mode", "\n", "if", "min_iou", "is", "None", ":", "\n", "                ", "min_iou", "=", "float", "(", "'-inf'", ")", "\n", "", "if", "max_iou", "is", "None", ":", "\n", "                ", "max_iou", "=", "float", "(", "'inf'", ")", "\n", "\n", "# max trails (50)", "\n", "", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "                ", "current_image", "=", "image", "\n", "\n", "w", "=", "cfg", ".", "input_w", "\n", "h", "=", "cfg", ".", "input_h", "\n", "\n", "# aspect ratio constraint b/t .5 & 2", "\n", "if", "h", "/", "w", "<", "0.5", "or", "h", "/", "w", ">", "2", ":", "\n", "                    ", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "width", "-", "w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "height", "-", "h", ")", "\n", "\n", "# convert to integer rect x1,y1,x2,y2", "\n", "rect", "=", "np", ".", "array", "(", "[", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "w", ")", ",", "int", "(", "top", "+", "h", ")", "]", ")", "\n", "\n", "# calculate IoU (jaccard overlap) b/t the cropped and gt boxes", "\n", "overlap", "=", "jaccard_numpy", "(", "boxes", ",", "rect", ")", "\n", "\n", "# This piece of code is bugged and does nothing:", "\n", "# https://github.com/amdegroot/ssd.pytorch/issues/68", "\n", "#", "\n", "# However, when I fixed it with overlap.max() < min_iou,", "\n", "# it cut the mAP in half (after 8k iterations). So it stays.", "\n", "#", "\n", "# is min and max overlap constraint satisfied? if not try again", "\n", "if", "overlap", ".", "min", "(", ")", "<", "min_iou", "and", "max_iou", "<", "overlap", ".", "max", "(", ")", ":", "\n", "                    ", "continue", "\n", "\n", "# cut the crop from the image", "\n", "", "current_image", "=", "current_image", "[", "rect", "[", "1", "]", ":", "rect", "[", "3", "]", ",", "rect", "[", "0", "]", ":", "rect", "[", "2", "]", ",", "\n", ":", "]", "\n", "\n", "# keep overlap with gt box IF center in sampled patch", "\n", "centers", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2.0", "\n", "\n", "# mask in all gt boxes that above and to the left of centers", "\n", "m1", "=", "(", "rect", "[", "0", "]", "<", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "1", "]", "<", "centers", "[", ":", ",", "1", "]", ")", "\n", "\n", "# mask in all gt boxes that under and to the right of centers", "\n", "m2", "=", "(", "rect", "[", "2", "]", ">", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "3", "]", ">", "centers", "[", ":", ",", "1", "]", ")", "\n", "\n", "# mask in that both m1 and m2 are true", "\n", "mask", "=", "m1", "*", "m2", "\n", "\n", "# [0 ... 0 for num_gt and then 1 ... 1 for num_crowds]", "\n", "num_crowds", "=", "labels", "[", "'num_crowds'", "]", "\n", "crowd_mask", "=", "np", ".", "zeros", "(", "mask", ".", "shape", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "if", "num_crowds", ">", "0", ":", "\n", "                    ", "crowd_mask", "[", "-", "num_crowds", ":", "]", "=", "1", "\n", "\n", "# have any valid boxes? try again if not", "\n", "# Also make sure you have at least one regular gt", "\n", "", "if", "not", "mask", ".", "any", "(", ")", "or", "np", ".", "sum", "(", "1", "-", "crowd_mask", "[", "mask", "]", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "# take only the matching gt masks", "\n", "", "current_masks", "=", "masks", "[", "mask", ",", ":", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "# take only matching gt boxes", "\n", "current_boxes", "=", "boxes", "[", "mask", ",", ":", "]", ".", "copy", "(", ")", "\n", "\n", "# take only matching gt labels", "\n", "labels", "[", "'labels'", "]", "=", "labels", "[", "'labels'", "]", "[", "mask", "]", "\n", "current_labels", "=", "labels", "\n", "\n", "# We now might have fewer crowd annotations", "\n", "if", "num_crowds", ">", "0", ":", "\n", "                    ", "labels", "[", "'num_crowds'", "]", "=", "np", ".", "sum", "(", "crowd_mask", "[", "mask", "]", ")", "\n", "\n", "# should we use the box left and top corner or the crop's", "\n", "", "current_boxes", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "current_boxes", "[", ":", ",", ":", "2", "]", ",", "\n", "rect", "[", ":", "2", "]", ")", "\n", "# adjust to crop (by substracting crop's left,top)", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "current_boxes", "[", ":", ",", "2", ":", "]", ",", "\n", "rect", "[", "2", ":", "]", ")", "\n", "# adjust to crop (by substracting crop's left,top)", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "# crop the current masks to the same dimensions as the image", "\n", "current_masks", "=", "current_masks", "[", ":", ",", "rect", "[", "1", "]", ":", "rect", "[", "3", "]", ",", "rect", "[", "0", "]", ":", "rect", "[", "2", "]", "]", "\n", "\n", "return", "current_image", ",", "current_masks", ",", "current_boxes", ",", "current_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Expand.__init__": [[573, 575], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Expand.__call__": [[576, 605], ["numpy.random.randint", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.zeros", "numpy.zeros", "boxes.copy.copy.copy", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "height", ",", "width", ",", "depth", "=", "image", ".", "shape", "\n", "ratio", "=", "random", ".", "uniform", "(", "1", ",", "4", ")", "\n", "left", "=", "random", ".", "uniform", "(", "0", ",", "width", "*", "ratio", "-", "width", ")", "\n", "top", "=", "random", ".", "uniform", "(", "0", ",", "height", "*", "ratio", "-", "height", ")", "\n", "\n", "expand_image", "=", "np", ".", "zeros", "(", "\n", "(", "int", "(", "height", "*", "ratio", ")", ",", "int", "(", "width", "*", "ratio", ")", ",", "depth", ")", ",", "\n", "dtype", "=", "image", ".", "dtype", ")", "\n", "expand_image", "[", ":", ",", ":", ",", ":", "]", "=", "self", ".", "mean", "\n", "expand_image", "[", "int", "(", "top", ")", ":", "int", "(", "top", "+", "height", ")", ",", "\n", "int", "(", "left", ")", ":", "int", "(", "left", "+", "width", ")", "]", "=", "image", "\n", "image", "=", "expand_image", "\n", "\n", "expand_masks", "=", "np", ".", "zeros", "(", "\n", "(", "masks", ".", "shape", "[", "0", "]", ",", "int", "(", "height", "*", "ratio", ")", ",", "int", "(", "width", "*", "ratio", ")", ")", ",", "\n", "dtype", "=", "masks", ".", "dtype", ")", "\n", "expand_masks", "[", ":", ",", "int", "(", "top", ")", ":", "int", "(", "top", "+", "height", ")", ",", "\n", "int", "(", "left", ")", ":", "int", "(", "left", "+", "width", ")", "]", "=", "masks", "\n", "masks", "=", "expand_masks", "\n", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "\n", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomMirror.__call__": [[608, 616], ["numpy.random.randint", "boxes.copy.copy.copy"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "_", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "=", "image", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "masks", "=", "masks", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "width", "-", "boxes", "[", ":", ",", "2", ":", ":", "-", "2", "]", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.RandomFlip.__call__": [[618, 626], ["numpy.random.randint", "boxes.copy.copy.copy"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["    ", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "height", ",", "_", ",", "_", "=", "image", ".", "shape", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "image", "=", "image", "[", ":", ":", "-", "1", ",", ":", "]", "\n", "masks", "=", "masks", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", "=", "height", "-", "boxes", "[", ":", ",", "3", ":", ":", "-", "2", "]", "\n", "", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.SwapChannels.__init__": [[635, 637], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "swaps", ")", ":", "\n", "        ", "self", ".", "swaps", "=", "swaps", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.SwapChannels.__call__": [[638, 651], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (Tensor): image tensor to be transformed\n        Return:\n            a tensor with channels swapped according to swap\n        \"\"\"", "\n", "# if torch.is_tensor(image):", "\n", "#     image = image.data.cpu().numpy()", "\n", "# else:", "\n", "#     image = np.array(image)", "\n", "image", "=", "image", "[", ":", ",", ":", ",", "self", ".", "swaps", "]", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.PhotometricDistort.__init__": [[654, 665], ["augmentations.RandomBrightness", "augmentations.RandomLightingNoise", "augmentations.RandomContrast", "augmentations.ConvertColor", "augmentations.RandomSaturation", "augmentations.RandomHue", "augmentations.ConvertColor", "augmentations.RandomContrast"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "pd", "=", "[", "\n", "RandomContrast", "(", ")", ",", "\n", "ConvertColor", "(", "transform", "=", "'HSV'", ")", ",", "\n", "RandomSaturation", "(", ")", ",", "\n", "RandomHue", "(", ")", ",", "\n", "ConvertColor", "(", "current", "=", "'HSV'", ",", "transform", "=", "'BGR'", ")", ",", "\n", "RandomContrast", "(", ")", "\n", "]", "\n", "self", ".", "rand_brightness", "=", "RandomBrightness", "(", ")", "\n", "self", ".", "rand_light_noise", "=", "RandomLightingNoise", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.PhotometricDistort.__call__": [[666, 675], ["image.copy", "augmentations.PhotometricDistort.rand_brightness", "numpy.random.randint", "Compose.", "augmentations.PhotometricDistort.rand_light_noise", "augmentations.Compose", "augmentations.Compose"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "im", "=", "image", ".", "copy", "(", ")", "\n", "im", ",", "masks", ",", "boxes", ",", "labels", "=", "self", ".", "rand_brightness", "(", "im", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "if", "random", ".", "randint", "(", "2", ")", ":", "\n", "            ", "distort", "=", "Compose", "(", "self", ".", "pd", "[", ":", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "            ", "distort", "=", "Compose", "(", "self", ".", "pd", "[", "1", ":", "]", ")", "\n", "", "im", ",", "masks", ",", "boxes", ",", "labels", "=", "distort", "(", "im", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "return", "self", ".", "rand_light_noise", "(", "im", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.PrepareMasks.__init__": [[683, 686], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mask_size", ",", "use_gt_bboxes", ")", ":", "\n", "        ", "self", ".", "mask_size", "=", "mask_size", "\n", "self", ".", "use_gt_bboxes", "=", "use_gt_bboxes", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.PrepareMasks.__call__": [[687, 714], ["numpy.zeros", "range", "len", "cv2.resize", "cv2.resize.reshape", "int", "int", "int", "int"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ",", "masks", ",", "boxes", ",", "labels", "=", "None", ")", ":", "\n", "        ", "if", "not", "self", ".", "use_gt_bboxes", ":", "\n", "            ", "return", "image", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n", "", "height", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "\n", "new_masks", "=", "np", ".", "zeros", "(", "(", "masks", ".", "shape", "[", "0", "]", ",", "self", ".", "mask_size", "**", "2", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "masks", ")", ")", ":", "\n", "            ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "boxes", "[", "i", ",", ":", "]", "\n", "x1", "*=", "width", "\n", "x2", "*=", "width", "\n", "y1", "*=", "height", "\n", "y2", "*=", "height", "\n", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "(", "int", "(", "x1", ")", ",", "int", "(", "y1", ")", ",", "int", "(", "x2", ")", ",", "int", "(", "y2", ")", ")", "\n", "\n", "# +1 So that if y1=10.6 and y2=10.9 we still have a bounding box", "\n", "cropped_mask", "=", "masks", "[", "i", ",", "y1", ":", "(", "y2", "+", "1", ")", ",", "x1", ":", "(", "x2", "+", "1", ")", "]", "\n", "scaled_mask", "=", "cv2", ".", "resize", "(", "cropped_mask", ",", "(", "self", ".", "mask_size", ",", "self", ".", "mask_size", ")", ")", "\n", "\n", "new_masks", "[", "i", ",", ":", "]", "=", "scaled_mask", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "\n", "# Binarize", "\n", "", "new_masks", "[", "new_masks", ">", "0.5", "]", "=", "1", "\n", "new_masks", "[", "new_masks", "<=", "0.5", "]", "=", "0", "\n", "\n", "return", "image", ",", "new_masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.BackboneTransform.__init__": [[723, 731], ["numpy.array", "numpy.array", "enumerate"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "transform", ",", "mean", ",", "std", ",", "in_channel_order", ")", ":", "\n", "        ", "self", ".", "mean", "=", "np", ".", "array", "(", "mean", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "std", "=", "np", ".", "array", "(", "std", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "\n", "# Here I use \"Algorithms and Coding\" to convert string permutations to numbers", "\n", "self", ".", "channel_map", "=", "{", "c", ":", "idx", "for", "idx", ",", "c", "in", "enumerate", "(", "in_channel_order", ")", "}", "\n", "self", ".", "channel_permutation", "=", "[", "self", ".", "channel_map", "[", "c", "]", "for", "c", "in", "transform", ".", "channel_order", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.BackboneTransform.__call__": [[732, 746], ["img.astype.astype.astype", "img.astype.astype.astype"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "\n", "        ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "if", "self", ".", "transform", ".", "normalize", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "", "elif", "self", ".", "transform", ".", "subtract_means", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "\n", "", "elif", "self", ".", "transform", ".", "to_float", ":", "\n", "            ", "img", "=", "img", "/", "255", "\n", "\n", "", "img", "=", "img", "[", ":", ",", ":", ",", "self", ".", "channel_permutation", "]", "\n", "\n", "return", "img", ".", "astype", "(", "np", ".", "float32", ")", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.BaseTransform.__init__": [[753, 759], ["augmentations.Compose", "augmentations.ConvertFromInts", "augmentations.Resize", "augmentations.Pad", "augmentations.BackboneTransform"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", "=", "MEANS", ",", "std", "=", "STD", ")", ":", "\n", "        ", "self", ".", "augment", "=", "Compose", "(", "[", "\n", "ConvertFromInts", "(", ")", ",", "\n", "Resize", "(", "resize_gt", "=", "False", ")", ",", "\n", "Pad", "(", "cfg", ".", "input_w", ",", "cfg", ".", "input_h", ",", "mean", ",", "pad_gt", "=", "False", ")", ",", "\n", "BackboneTransform", "(", "cfg", ".", "backbone", ".", "transform", ",", "mean", ",", "std", ",", "'BGR'", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.BaseTransform.__call__": [[761, 763], ["augmentations.BaseTransform.augment"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "        ", "return", "self", ".", "augment", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.FastBaseTransform.__init__": [[773, 779], ["super().__init__", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float().cuda", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor().float", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "mean", "=", "torch", ".", "Tensor", "(", "MEANS", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "self", ".", "std", "=", "torch", ".", "Tensor", "(", "STD", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", "\n", "self", ".", "transform", "=", "cfg", ".", "backbone", ".", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.FastBaseTransform.forward": [[780, 805], ["augmentations.FastBaseTransform.mean.to", "augmentations.FastBaseTransform.std.to", "img[].contiguous.permute().contiguous", "torch.interpolate", "torch.interpolate", "img[].contiguous", "img[].contiguous.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "self", ".", "mean", "=", "self", ".", "mean", ".", "to", "(", "img", ".", "device", ")", "\n", "self", ".", "std", "=", "self", ".", "std", ".", "to", "(", "img", ".", "device", ")", "\n", "\n", "# img assumed to be a pytorch BGR image with channel order [n, h, w, c]", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "img", "=", "img", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "img", "=", "F", ".", "interpolate", "(", "img", ",", "(", "cfg", ".", "max_size", ",", "cfg", ".", "max_size", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "\n", "if", "self", ".", "transform", ".", "normalize", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "", "elif", "self", ".", "transform", ".", "subtract_means", ":", "\n", "            ", "img", "=", "(", "img", "-", "self", ".", "mean", ")", "\n", "", "elif", "self", ".", "transform", ".", "to_float", ":", "\n", "            ", "img", "=", "img", "/", "255", "\n", "\n", "", "if", "self", ".", "transform", ".", "channel_order", "!=", "'RGB'", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "img", "=", "img", "[", ":", ",", "(", "2", ",", "1", ",", "0", ")", ",", ":", ",", ":", "]", ".", "contiguous", "(", ")", "\n", "\n", "# Return value is in channel order [n, c, h, w] and RGB", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.SSDAugmentation.__init__": [[816, 832], ["augmentations.Compose", "augmentations.ConvertFromInts", "augmentations.ToAbsoluteCoords", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.enable_if", "augmentations.ToPercentCoords", "augmentations.PrepareMasks", "augmentations.BackboneTransform", "augmentations.PhotometricDistort", "augmentations.Expand", "augmentations.RandomSampleCrop", "augmentations.RandomFlip", "augmentations.RandomMirror", "augmentations.RandomScale", "augmentations.RandomCrop", "augmentations.Resize"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if"], ["def", "__init__", "(", "self", ",", "mean", "=", "MEANS", ",", "std", "=", "STD", ")", ":", "\n", "        ", "self", ".", "augment", "=", "Compose", "(", "[", "\n", "ConvertFromInts", "(", ")", ",", "\n", "ToAbsoluteCoords", "(", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_photometric_distort", ",", "PhotometricDistort", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_expand", ",", "Expand", "(", "mean", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_sample_crop", ",", "RandomSampleCrop", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_flip", ",", "RandomFlip", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_mirror", ",", "RandomMirror", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_scale", ",", "RandomScale", "(", ")", ")", ",", "\n", "enable_if", "(", "cfg", ".", "augment_random_crop", ",", "RandomCrop", "(", ")", ")", ",", "\n", "enable_if", "(", "not", "cfg", ".", "augment_random_crop", ",", "Resize", "(", ")", ")", ",", "\n", "# Pad(cfg.max_size, cfg.max_size, mean),", "\n", "ToPercentCoords", "(", ")", ",", "\n", "PrepareMasks", "(", "cfg", ".", "mask_size", ",", "cfg", ".", "use_gt_bboxes", ")", ",", "\n", "BackboneTransform", "(", "cfg", ".", "backbone", ".", "transform", ",", "mean", ",", "std", ",", "'BGR'", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.SSDAugmentation.__call__": [[834, 836], ["augmentations.SSDAugmentation.augment"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "masks", ",", "boxes", ",", "labels", ")", ":", "\n", "        ", "return", "self", ".", "augment", "(", "img", ",", "masks", ",", "boxes", ",", "labels", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.intersect": [[11, 16], ["numpy.minimum", "numpy.maximum", "numpy.clip"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "max_xy", "=", "np", ".", "minimum", "(", "box_a", "[", ":", ",", "2", ":", "]", ",", "box_b", "[", "2", ":", "]", ")", "\n", "min_xy", "=", "np", ".", "maximum", "(", "box_a", "[", ":", ",", ":", "2", "]", ",", "box_b", "[", ":", "2", "]", ")", "\n", "inter", "=", "np", ".", "clip", "(", "(", "max_xy", "-", "min_xy", ")", ",", "a_min", "=", "0", ",", "a_max", "=", "np", ".", "inf", ")", "\n", "return", "inter", "[", ":", ",", "0", "]", "*", "inter", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.jaccard_numpy": [[18, 36], ["augmentations.intersect"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.intersect"], ["", "def", "jaccard_numpy", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: Multiple bounding boxes, Shape: [num_boxes,4]\n        box_b: Single bounding box, Shape: [4]\n    Return:\n        jaccard overlap: Shape: [box_a.shape[0], box_a.shape[1]]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", "2", "]", "-", "box_b", "[", "0", "]", ")", "*", "\n", "(", "box_b", "[", "3", "]", "-", "box_b", "[", "1", "]", ")", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.do_nothing": [[806, 808], ["None"], "function", ["None"], ["", "", "def", "do_nothing", "(", "img", "=", "None", ",", "masks", "=", "None", ",", "boxes", "=", "None", ",", "labels", "=", "None", ")", ":", "\n", "    ", "return", "img", ",", "masks", ",", "boxes", ",", "labels", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.enable_if": [[810, 812], ["data.cfg.augment_photometric_distort", "data.cfg.augment_expand", "data.cfg.augment_random_sample_crop", "data.cfg.augment_random_flip", "data.cfg.augment_random_mirror", "data.cfg.augment_random_scale", "data.cfg.augment_random_crop"], "function", ["None"], ["", "def", "enable_if", "(", "condition", ",", "obj", ")", ":", "\n", "    ", "return", "obj", "if", "condition", "else", "do_nothing", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.interpolate.InterpolateModule.__init__": [[10, 15], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwdargs", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "kwdargs", "=", "kwdargs", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.interpolate.InterpolateModule.forward": [[16, 18], ["torch.interpolate", "torch.interpolate"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\t\t", "return", "F", ".", "interpolate", "(", "x", ",", "*", "self", ".", "args", ",", "**", "self", ".", "kwdargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.point_form": [[7, 18], ["torch.cat"], "function", ["None"], ["@", "torch", ".", "jit", ".", "script", "\n", "def", "point_form", "(", "boxes", ")", ":", "\n", "    ", "\"\"\" Convert prior_boxes to (xmin, ymin, xmax, ymax)\n    representation for comparison to point form ground truth data.\n    Args:\n        boxes: (tensor) center-size default boxes from priorbox layers.\n    Return:\n        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.\n    \"\"\"", "\n", "return", "torch", ".", "cat", "(", "(", "boxes", "[", ":", ",", ":", "2", "]", "-", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", ",", "# xmin, ymin", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", ")", ",", "1", ")", "# xmax, ymax", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.center_size": [[20, 31], ["torch.cat"], "function", ["None"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "center_size", "(", "boxes", ")", ":", "\n", "    ", "\"\"\" Convert prior_boxes to (cx, cy, w, h)\n    representation for comparison to center-size form ground truth data.\n    Args:\n        boxes: (tensor) point_form boxes\n    Return:\n        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.\n    \"\"\"", "\n", "return", "torch", ".", "cat", "(", "(", "(", "boxes", "[", ":", ",", "2", ":", "]", "+", "boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", ",", "# cx, cy", "\n", "boxes", "[", ":", ",", "2", ":", "]", "-", "boxes", "[", ":", ",", ":", "2", "]", ")", ",", "1", ")", "# w, h", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.intersect": [[32, 53], ["box_a.size", "box_a.size", "box_b.size", "torch.min", "torch.max", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [n,A,4].\n      box_b: (tensor) bounding boxes, Shape: [n,B,4].\n    Return:\n      (tensor) intersection area, Shape: [n,A,B].\n    \"\"\"", "\n", "n", "=", "box_a", ".", "size", "(", "0", ")", "\n", "A", "=", "box_a", ".", "size", "(", "1", ")", "\n", "B", "=", "box_b", ".", "size", "(", "1", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "box_a", "[", ":", ",", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "2", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "n", ",", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.jaccard": [[55, 82], ["box_utils.intersect", "box_a.dim", "out.squeeze"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ",", "iscrowd", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes. If iscrowd=True, put the crowd in box_b.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "use_batch", "=", "True", "\n", "if", "box_a", ".", "dim", "(", ")", "==", "2", ":", "\n", "        ", "use_batch", "=", "False", "\n", "box_a", "=", "box_a", "[", "None", ",", "...", "]", "\n", "box_b", "=", "box_b", "[", "None", ",", "...", "]", "\n", "\n", "", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", ":", ",", "0", "]", ")", "*", "\n", "(", "box_b", "[", ":", ",", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "\n", "out", "=", "inter", "/", "area_a", "if", "iscrowd", "else", "inter", "/", "union", "\n", "return", "out", "if", "use_batch", "else", "out", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.change": [[85, 111], ["priors.size", "gt.size", "[].expand", "[].expand", "gt[].expand", "priors[].expand", "torch.sqrt"], "function", ["None"], ["", "def", "change", "(", "gt", ",", "priors", ")", ":", "\n", "    ", "\"\"\"\n    Compute the d_change metric proposed in Box2Pix:\n    https://lmb.informatik.uni-freiburg.de/Publications/2018/UB18/paper-box2pix.pdf\n    \n    Input should be in point form (xmin, ymin, xmax, ymax).\n\n    Output is of shape [num_gt, num_priors]\n    Note this returns -change so it can be a drop in replacement for \n    \"\"\"", "\n", "num_priors", "=", "priors", ".", "size", "(", "0", ")", "\n", "num_gt", "=", "gt", ".", "size", "(", "0", ")", "\n", "\n", "gt_w", "=", "(", "gt", "[", ":", ",", "2", "]", "-", "gt", "[", ":", ",", "0", "]", ")", "[", ":", ",", "None", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ")", "\n", "gt_h", "=", "(", "gt", "[", ":", ",", "3", "]", "-", "gt", "[", ":", ",", "1", "]", ")", "[", ":", ",", "None", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ")", "\n", "\n", "gt_mat", "=", "gt", "[", ":", ",", "None", ",", ":", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ",", "4", ")", "\n", "pr_mat", "=", "priors", "[", "None", ",", ":", ",", ":", "]", ".", "expand", "(", "num_gt", ",", "num_priors", ",", "4", ")", "\n", "\n", "diff", "=", "gt_mat", "-", "pr_mat", "\n", "diff", "[", ":", ",", ":", ",", "0", "]", "/=", "gt_w", "\n", "diff", "[", ":", ",", ":", ",", "2", "]", "/=", "gt_w", "\n", "diff", "[", ":", ",", ":", ",", "1", "]", "/=", "gt_h", "\n", "diff", "[", ":", ",", ":", ",", "3", "]", "/=", "gt_h", "\n", "\n", "return", "-", "torch", ".", "sqrt", "(", "(", "diff", "**", "2", ")", ".", "sum", "(", "dim", "=", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.center_distance": [[112, 128], ["torch.mm", "torch.transpose"], "function", ["None"], ["", "def", "center_distance", "(", "box_a", ",", "box_b", ")", ":", "\n", "# computer the l2 distance between box_a & box_b", "\n", "# box_a, box_b : (xmin, ymin, xmax, ymax) Shape[num, 4]", "\n", "\n", "# compute center : Shape[num, 2]", "\n", "    ", "box_a_cen", "=", "(", "box_a", "[", ":", ",", ":", "2", "]", "+", "box_a", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "box_b_cen", "=", "(", "box_b", "[", ":", ",", ":", "2", "]", "+", "box_b", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "\n", "# L2 Distance", "\n", "a_norm", "=", "(", "box_a_cen", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "b_norm", "=", "(", "box_b_cen", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "\n", "dist", "=", "a_norm", "+", "b_norm", "-", "2.0", "*", "torch", ".", "mm", "(", "box_a_cen", ",", "torch", ".", "transpose", "(", "box_b_cen", ",", "0", ",", "1", ")", ")", "\n", "\n", "# Shape[num_a, num_b]", "\n", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.is_in_box": [[129, 144], ["None"], "function", ["None"], ["", "def", "is_in_box", "(", "box_a", ",", "box_b", ")", ":", "\n", "# cheack if box_a's center is in box_b", "\n", "# box_a : (xmin, ymin, xmax, ymax) Shape[num_a, 4]", "\n", "# box_b : (xmin, ymin, xmax, ymax) Shape[4]", "\n", "\n", "    ", "box_a_cen", "=", "(", "box_a", "[", ":", ",", ":", "2", "]", "+", "box_a", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "\n", "x_min_c", "=", "(", "box_a_cen", "[", ":", ",", "0", "]", "-", "box_b", "[", "0", "]", ")", ">=", "0", "\n", "y_min_c", "=", "(", "box_a_cen", "[", ":", ",", "1", "]", "-", "box_b", "[", "1", "]", ")", ">=", "0", "\n", "x_max_c", "=", "(", "box_a_cen", "[", ":", ",", "0", "]", "-", "box_b", "[", "2", "]", ")", "<=", "0", "\n", "y_max_c", "=", "(", "box_a_cen", "[", ":", ",", "1", "]", "-", "box_b", "[", "3", "]", ")", "<=", "0", "\n", "\n", "res", "=", "x_min_c", "*", "y_min_c", "*", "x_max_c", "*", "y_max_c", "\n", "# Shape[num_a] , 1 represents box_a in box_b", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.atss_match": [[145, 240], ["overlaps.max", "overlaps.max", "box_utils.center_distance", "enumerate", "torch.cat", "torch.cat", "torch.zeros_like", "box_utils.encode", "box_utils.decode", "box_utils.point_form", "box_utils.jaccard", "box_utils.change", "range", "torch.cat().reshape", "D_g.mean", "D_g.std", "box_utils.is_in_box", "torch.tensor().long", "torch.cat.append", "torch.cat.append", "box_utils.jaccard", "jaccard.max", "overlaps.size", "torch.topk", "torch.cat().reshape.append", "len", "best_prior_idx[].reshape", "torch.cat", "torch.tensor", "list", "set", "set", "torch.cat().reshape.tolist", "best_prior_idx[].reshape.tolist"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.center_distance", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.encode", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.point_form", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.change", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.is_in_box", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "atss_match", "(", "pos_thresh", ",", "neg_thresh", ",", "truths", ",", "priors", ",", "labels", ",", "crowd_boxes", ",", "loc_t", ",", "conf_t", ",", "idx_t", ",", "idx_t_pan", ",", "idx", ",", "loc_data", ",", "num_priors", ",", "k", "=", "9", ")", ":", "\n", "    ", "\"\"\"Match each prior box with the ground truth box of the highest jaccard\n    overlap, encode the bounding boxes, then return the matched indices\n    corresponding to both confidence and location preds.\n    Args:\n        pos_thresh: (float) IoU > pos_thresh ==> positive.\n        neg_thresh: (float) IoU < neg_thresh ==> negative.\n        truths: (tensor) Ground truth boxes, Shape: [num_obj, num_priors].\n        priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4].\n        labels: (tensor) All the class labels for the image, Shape: [num_obj].\n        crowd_boxes: (tensor) All the crowd box annotations or None if there are none.\n        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.\n        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds. Note: -1 means neutral.\n        idx_t: (tensor) Tensor to be filled w/ the index of the matched gt box for each prior.\n        idx: (int) current batch index.\n        loc_data: (tensor) The predicted bbox regression coordinates for this batch.\n    Return:\n        The matched indices corresponding to 1)location and 2)confidence preds.\n    \"\"\"", "\n", "decoded_priors", "=", "decode", "(", "loc_data", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "if", "cfg", ".", "use_prediction_matching", "else", "point_form", "(", "priors", ")", "\n", "\n", "# Size [num_objects, num_priors]", "\n", "overlaps", "=", "jaccard", "(", "truths", ",", "decoded_priors", ")", "if", "not", "cfg", ".", "use_change_matching", "else", "change", "(", "truths", ",", "decoded_priors", ")", "\n", "\n", "# Size [num_objects] best prior for each ground truth", "\n", "best_prior_overlap", ",", "best_prior_idx", "=", "overlaps", ".", "max", "(", "1", ")", "\n", "# Size [num_priors] best ground truth for each prior", "\n", "best_truth_overlap", ",", "best_truth_idx", "=", "overlaps", ".", "max", "(", "0", ")", "\n", "\n", "# # SIze [num_objects, num_priors]", "\n", "dist", "=", "center_distance", "(", "truths", ",", "priors", ")", "\n", "\n", "pos_idx", "=", "[", "]", "\n", "neg_idx", "=", "[", "]", "\n", "# for each gt box , find out top-k close(center) pred boxes for each layer", "\n", "for", "g_i", ",", "_", "in", "enumerate", "(", "range", "(", "overlaps", ".", "size", "(", "0", ")", ")", ")", ":", "\n", "        ", "start_idx", "=", "0", "\n", "C_g", "=", "[", "]", "\n", "for", "n_i", "in", "num_priors", ":", "\n", "# top k close pred boxes at level_i", "\n", "# topk_val , topk_idx = torch.topk(dist[g_i, start_idx:start_idx+n_i], k, largest=False)", "\n", "\n", "# use iou threshold choose top k", "\n", "            ", "topk_val", ",", "topk_idx", "=", "torch", ".", "topk", "(", "overlaps", "[", "g_i", ",", "start_idx", ":", "start_idx", "+", "n_i", "]", ",", "k", ",", "largest", "=", "True", ")", "\n", "\n", "C_g", ".", "append", "(", "topk_idx", "+", "start_idx", ")", "\n", "start_idx", "=", "start_idx", "+", "n_i", "\n", "", "C_g", "=", "torch", ".", "cat", "(", "(", "C_g", ")", ",", "dim", "=", "-", "1", ")", ".", "reshape", "(", "-", "1", ")", "\n", "D_g", "=", "overlaps", "[", "g_i", ",", "C_g", "]", "\n", "m_g", "=", "D_g", ".", "mean", "(", ")", "\n", "v_g", "=", "D_g", ".", "std", "(", ")", "\n", "t_g", "=", "m_g", "+", "v_g", "\n", "\n", "pos_idx_i", "=", "C_g", "[", "D_g", ">=", "t_g", "]", "\n", "\n", "in_gt_idx", "=", "is_in_box", "(", "decoded_priors", "[", "pos_idx_i", ",", ":", "]", ",", "truths", "[", "g_i", ",", ":", "]", ")", "\n", "pos_idx_i", "=", "pos_idx_i", "[", "in_gt_idx", "]", "\n", "if", "len", "(", "pos_idx_i", ")", "==", "0", ":", "\n", "# pos_idx_i = C_g[D_g.max(0)[1]].reshape(-1)  ", "\n", "            ", "pos_idx_i", "=", "best_prior_idx", "[", "g_i", "]", ".", "reshape", "(", "-", "1", ")", "\n", "", "dist", "[", ":", ",", "C_g", "]", "=", "10000", "# prevent pred box get considered by other gt box", "\n", "neg_idx_i", "=", "torch", ".", "tensor", "(", "list", "(", "set", "(", "C_g", ".", "tolist", "(", ")", ")", "-", "set", "(", "pos_idx_i", ".", "tolist", "(", ")", ")", ")", ")", ".", "long", "(", ")", "\n", "pos_idx", ".", "append", "(", "pos_idx_i", ")", "\n", "neg_idx", ".", "append", "(", "neg_idx_i", ")", "\n", "\n", "best_truth_idx", "[", "pos_idx_i", "]", "=", "g_i", "# match the pred box to current gt box", "\n", "\n", "overlaps", "[", ":", ",", "pos_idx_i", "]", "=", "-", "1", "# prevent pred box get considered by other gt box", "\n", "\n", "\n", "", "pos_idx", "=", "torch", ".", "cat", "(", "pos_idx", ",", "dim", "=", "0", ")", "\n", "neg_idx", "=", "torch", ".", "cat", "(", "neg_idx", ",", "dim", "=", "0", ")", "\n", "\n", "\n", "matches", "=", "truths", "[", "best_truth_idx", "]", "# Shape: [num_priors,4]", "\n", "conf", "=", "torch", ".", "zeros_like", "(", "best_truth_idx", ")", "# Shape: [num_priors]", "\n", "conf", "[", ":", "]", "=", "-", "1", "# Default: neutral", "\n", "conf", "[", "pos_idx", "]", "=", "labels", "[", "best_truth_idx", "[", "pos_idx", "]", "]", "+", "1", "\n", "conf", "[", "neg_idx", "]", "=", "0", "\n", "\n", "\n", "# Deal with crowd annotations for COCO", "\n", "if", "crowd_boxes", "is", "not", "None", "and", "cfg", ".", "crowd_iou_threshold", "<", "1", ":", "\n", "# Size [num_priors, num_crowds]", "\n", "        ", "crowd_overlaps", "=", "jaccard", "(", "decoded_priors", ",", "crowd_boxes", ",", "iscrowd", "=", "True", ")", "\n", "# Size [num_priors]", "\n", "best_crowd_overlap", ",", "best_crowd_idx", "=", "crowd_overlaps", ".", "max", "(", "1", ")", "\n", "# Set non-positives with crowd iou of over the threshold to be neutral.", "\n", "conf", "[", "(", "conf", "<=", "0", ")", "&", "(", "best_crowd_overlap", ">", "cfg", ".", "crowd_iou_threshold", ")", "]", "=", "-", "1", "\n", "\n", "", "loc", "=", "encode", "(", "matches", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "\n", "loc_t", "[", "idx", "]", "=", "loc", "# [num_priors,4] encoded offsets to learn", "\n", "conf_t", "[", "idx", "]", "=", "conf", "# [num_priors] top class label for each prior", "\n", "idx_t", "[", "idx", "]", "=", "best_truth_idx", "# [num_priors] indices for lookup", "\n", "idx_t_pan", "[", "idx", "]", "=", "idx_t", "[", "idx", "]", "#only the prior that match gt will be 1 ", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.match": [[241, 311], ["overlaps.max", "overlaps.max", "best_truth_overlap.index_fill_", "range", "torch.zeros_like().fill_", "enumerate", "box_utils.encode", "box_utils.decode", "box_utils.point_form", "box_utils.jaccard", "box_utils.change", "best_prior_idx.size", "box_utils.jaccard", "jaccard.max", "torch.zeros_like"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.encode", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.point_form", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.change", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard"], ["", "def", "match", "(", "pos_thresh", ",", "neg_thresh", ",", "truths", ",", "priors", ",", "labels", ",", "crowd_boxes", ",", "loc_t", ",", "conf_t", ",", "idx_t", ",", "idx_t_pan", ",", "idx", ",", "loc_data", ")", ":", "\n", "    ", "\"\"\"Match each prior box with the ground truth box of the highest jaccard\n    overlap, encode the bounding boxes, then return the matched indices\n    corresponding to both confidence and location preds.\n    Args:\n        pos_thresh: (float) IoU > pos_thresh ==> positive.\n        neg_thresh: (float) IoU < neg_thresh ==> negative.\n        truths: (tensor) Ground truth boxes, Shape: [num_obj, num_priors].\n        priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4].\n        labels: (tensor) All the class labels for the image, Shape: [num_obj].\n        crowd_boxes: (tensor) All the crowd box annotations or None if there are none.\n        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.\n        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds. Note: -1 means neutral.\n        idx_t: (tensor) Tensor to be filled w/ the index of the matched gt box for each prior.\n        idx: (int) current batch index.\n        loc_data: (tensor) The predicted bbox regression coordinates for this batch.\n    Return:\n        The matched indices corresponding to 1)location and 2)confidence preds.\n    \"\"\"", "\n", "decoded_priors", "=", "decode", "(", "loc_data", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "if", "cfg", ".", "use_prediction_matching", "else", "point_form", "(", "priors", ")", "\n", "\n", "# Size [num_objects, num_priors]", "\n", "overlaps", "=", "jaccard", "(", "truths", ",", "decoded_priors", ")", "if", "not", "cfg", ".", "use_change_matching", "else", "change", "(", "truths", ",", "decoded_priors", ")", "\n", "\n", "# Size [num_objects] best prior for each ground truth", "\n", "best_prior_overlap", ",", "best_prior_idx", "=", "overlaps", ".", "max", "(", "1", ")", "\n", "# Size [num_priors] best ground truth for each prior", "\n", "best_truth_overlap", ",", "best_truth_idx", "=", "overlaps", ".", "max", "(", "0", ")", "\n", "\n", "# For the best prior for each gt object, set its overlap to 2. This ensures", "\n", "# that it won't get thresholded out in the threshold step even if the IoU is", "\n", "# under the negative threshold. This is because we want at least one anchor", "\n", "# to match with each ground truth or else we'd be wasting training data.", "\n", "best_truth_overlap", ".", "index_fill_", "(", "0", ",", "best_prior_idx", ",", "2", ")", "\n", "\n", "# Set the index of the pair (prior, gt) we set the overlap for above.", "\n", "for", "j", "in", "range", "(", "best_prior_idx", ".", "size", "(", "0", ")", ")", ":", "#ensure that every gt bbox have corresponding prior", "\n", "        ", "best_truth_idx", "[", "best_prior_idx", "[", "j", "]", "]", "=", "j", "\n", "\n", "\n", "", "best_gt_idx", "=", "torch", ".", "zeros_like", "(", "best_truth_idx", ")", ".", "fill_", "(", "-", "1", ")", "\n", "best_prior_idx", "[", "best_prior_overlap", "<", "pos_thresh", "]", "=", "-", "1", "\n", "gt_select", "=", "best_prior_overlap", ">=", "pos_thresh", "#choose the set of matched gt bboxes", "\n", "gt_idx", "=", "0", "\n", "for", "i", ",", "prior", "in", "enumerate", "(", "best_prior_idx", ")", ":", "\n", "        ", "if", "best_gt_idx", "[", "prior", "]", "==", "-", "1", "and", "prior", "!=", "-", "1", ":", "\n", "            ", "best_gt_idx", "[", "prior", "]", "=", "gt_idx", "\n", "gt_idx", "+=", "1", "\n", "\n", "", "", "idx_t_pan", "[", "idx", "]", "=", "best_gt_idx", "# only the prior that match gt will be 1 ", "\n", "\n", "matches", "=", "truths", "[", "best_truth_idx", "]", "# Shape: [num_priors,4]", "\n", "conf", "=", "labels", "[", "best_truth_idx", "]", "+", "1", "# Shape: [num_priors]", "\n", "\n", "conf", "[", "best_truth_overlap", "<", "pos_thresh", "]", "=", "-", "1", "# label as neutral", "\n", "conf", "[", "best_truth_overlap", "<", "neg_thresh", "]", "=", "0", "# label as background", "\n", "\n", "# Deal with crowd annotations for COCO", "\n", "if", "crowd_boxes", "is", "not", "None", "and", "cfg", ".", "crowd_iou_threshold", "<", "1", ":", "\n", "# Size [num_priors, num_crowds]", "\n", "        ", "crowd_overlaps", "=", "jaccard", "(", "decoded_priors", ",", "crowd_boxes", ",", "iscrowd", "=", "True", ")", "\n", "# Size [num_priors]", "\n", "best_crowd_overlap", ",", "best_crowd_idx", "=", "crowd_overlaps", ".", "max", "(", "1", ")", "\n", "# Set non-positives with crowd iou of over the threshold to be neutral.", "\n", "conf", "[", "(", "conf", "<=", "0", ")", "&", "(", "best_crowd_overlap", ">", "cfg", ".", "crowd_iou_threshold", ")", "]", "=", "-", "1", "\n", "\n", "", "loc", "=", "encode", "(", "matches", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "\n", "loc_t", "[", "idx", "]", "=", "loc", "# [num_priors,4] encoded offsets to learn", "\n", "conf_t", "[", "idx", "]", "=", "conf", "# [num_priors] top class label for each prior", "\n", "idx_t", "[", "idx", "]", "=", "best_truth_idx", "# [num_priors] indices for lookup", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.encode": [[313, 350], ["box_utils.center_size", "torch.cat", "torch.cat", "torch.log", "torch.log", "data.cfg.use_yolo_regressors", "data.cfg.use_yolo_regressors"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.center_size"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "encode", "(", "matched", ",", "priors", ",", "use_yolo_regressors", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Encode bboxes matched with each prior into the format\n    produced by the network. See decode for more details on\n    this format. Note that encode(decode(x, p), p) = x.\n    \n    Args:\n        - matched: A tensor of bboxes in point form with shape [num_priors, 4]\n        - priors:  The tensor of all priors with shape [num_priors, 4]\n    Return: A tensor with encoded relative coordinates in the format\n            outputted by the network (see decode). Size: [num_priors, 4]\n    \"\"\"", "\n", "\n", "if", "use_yolo_regressors", ":", "\n", "# Exactly the reverse of what we did in decode", "\n", "# In fact encode(decode(x, p), p) should be x", "\n", "        ", "boxes", "=", "center_size", "(", "matched", ")", "\n", "\n", "loc", "=", "torch", ".", "cat", "(", "(", "\n", "boxes", "[", ":", ",", ":", "2", "]", "-", "priors", "[", ":", ",", ":", "2", "]", ",", "\n", "torch", ".", "log", "(", "boxes", "[", ":", ",", "2", ":", "]", "/", "priors", "[", ":", ",", "2", ":", "]", ")", "\n", ")", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "variances", "=", "[", "0.1", ",", "0.2", "]", "\n", "\n", "# dist b/t match center and prior's center", "\n", "g_cxcy", "=", "(", "matched", "[", ":", ",", ":", "2", "]", "+", "matched", "[", ":", ",", "2", ":", "]", ")", "/", "2", "-", "priors", "[", ":", ",", ":", "2", "]", "\n", "# encode variance", "\n", "g_cxcy", "/=", "(", "variances", "[", "0", "]", "*", "priors", "[", ":", ",", "2", ":", "]", ")", "\n", "# match wh / prior wh", "\n", "g_wh", "=", "(", "matched", "[", ":", ",", "2", ":", "]", "-", "matched", "[", ":", ",", ":", "2", "]", ")", "/", "priors", "[", ":", ",", "2", ":", "]", "\n", "g_wh", "=", "torch", ".", "log", "(", "g_wh", ")", "/", "variances", "[", "1", "]", "\n", "# return target for smooth_l1_loss", "\n", "loc", "=", "torch", ".", "cat", "(", "[", "g_cxcy", ",", "g_wh", "]", ",", "1", ")", "# [num_priors,4]", "\n", "\n", "", "return", "loc", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode": [[351, 397], ["torch.cat", "box_utils.point_form", "torch.cat", "torch.exp", "torch.exp", "data.cfg.use_yolo_regressors", "data.cfg.use_yolo_regressors"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.point_form"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "decode", "(", "loc", ",", "priors", ",", "use_yolo_regressors", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Decode predicted bbox coordinates using the same scheme\n    employed by Yolov2: https://arxiv.org/pdf/1612.08242.pdf\n\n        b_x = (sigmoid(pred_x) - .5) / conv_w + prior_x\n        b_y = (sigmoid(pred_y) - .5) / conv_h + prior_y\n        b_w = prior_w * exp(loc_w)\n        b_h = prior_h * exp(loc_h)\n    \n    Note that loc is inputed as [(s(x)-.5)/conv_w, (s(y)-.5)/conv_h, w, h]\n    while priors are inputed as [x, y, w, h] where each coordinate\n    is relative to size of the image (even sigmoid(x)). We do this\n    in the network by dividing by the 'cell size', which is just\n    the size of the convouts.\n    \n    Also note that prior_x and prior_y are center coordinates which\n    is why we have to subtract .5 from sigmoid(pred_x and pred_y).\n    \n    Args:\n        - loc:    The predicted bounding boxes of size [num_priors, 4]\n        - priors: The priorbox coords with size [num_priors, 4]\n    \n    Returns: A tensor of decoded relative coordinates in point form \n             form with size [num_priors, 4]\n    \"\"\"", "\n", "\n", "if", "use_yolo_regressors", ":", "\n", "# Decoded boxes in center-size notation", "\n", "        ", "boxes", "=", "torch", ".", "cat", "(", "(", "\n", "loc", "[", ":", ",", ":", "2", "]", "+", "priors", "[", ":", ",", ":", "2", "]", ",", "\n", "priors", "[", ":", ",", "2", ":", "]", "*", "torch", ".", "exp", "(", "loc", "[", ":", ",", "2", ":", "]", ")", "\n", ")", ",", "1", ")", "\n", "\n", "boxes", "=", "point_form", "(", "boxes", ")", "\n", "", "else", ":", "\n", "        ", "variances", "=", "[", "0.1", ",", "0.2", "]", "\n", "\n", "boxes", "=", "torch", ".", "cat", "(", "(", "\n", "priors", "[", ":", ",", ":", "2", "]", "+", "loc", "[", ":", ",", ":", "2", "]", "*", "variances", "[", "0", "]", "*", "priors", "[", ":", ",", "2", ":", "]", ",", "\n", "priors", "[", ":", ",", "2", ":", "]", "*", "torch", ".", "exp", "(", "loc", "[", ":", ",", "2", ":", "]", "*", "variances", "[", "1", "]", ")", ")", ",", "1", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "-=", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "\n", "", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.log_sum_exp": [[400, 409], ["x.data.max", "torch.log", "torch.sum", "torch.exp"], "function", ["None"], ["", "def", "log_sum_exp", "(", "x", ")", ":", "\n", "    ", "\"\"\"Utility function for computing log_sum_exp while determining\n    This will be used to determine unaveraged confidence loss across\n    all examples in a batch.\n    Args:\n        x (Variable(tensor)): conf_preds from conf layers\n    \"\"\"", "\n", "x_max", "=", "x", ".", "data", ".", "max", "(", ")", "\n", "return", "torch", ".", "log", "(", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "x", "-", "x_max", ")", ",", "1", ")", ")", "+", "x_max", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates": [[411, 431], ["torch.min", "torch.max", "torch.clamp", "torch.clamp", "_x1.long.long", "_x2.long.long"], "function", ["None"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "sanitize_coordinates", "(", "_x1", ",", "_x2", ",", "img_size", ":", "int", ",", "padding", ":", "int", "=", "0", ",", "cast", ":", "bool", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Sanitizes the input coordinates so that x1 < x2, x1 != x2, x1 >= 0, and x2 <= image_size.\n    Also converts from relative to absolute coordinates and casts the results to long tensors.\n\n    If cast is false, the result won't be cast to longs.\n    Warning: this does things in-place behind the scenes so copy if necessary.\n    \"\"\"", "\n", "_x1", "=", "_x1", "*", "img_size", "\n", "_x2", "=", "_x2", "*", "img_size", "\n", "if", "cast", ":", "\n", "        ", "_x1", "=", "_x1", ".", "long", "(", ")", "\n", "_x2", "=", "_x2", ".", "long", "(", ")", "\n", "", "x1", "=", "torch", ".", "min", "(", "_x1", ",", "_x2", ")", "\n", "x2", "=", "torch", ".", "max", "(", "_x1", ",", "_x2", ")", "\n", "x1", "=", "torch", ".", "clamp", "(", "x1", "-", "padding", ",", "min", "=", "0", ")", "\n", "x2", "=", "torch", ".", "clamp", "(", "x2", "+", "padding", ",", "max", "=", "img_size", ")", "\n", "\n", "return", "x1", ",", "x2", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.crop": [[433, 458], ["masks.size", "box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "torch.arange().view().expand", "torch.arange().view().expand", "x1.view", "x2.view", "y1.view", "y2.view", "crop_mask.float", "torch.arange().view", "torch.arange().view", "torch.arange", "torch.arange"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates"], ["", "@", "torch", ".", "jit", ".", "script", "\n", "def", "crop", "(", "masks", ",", "boxes", ",", "padding", ":", "int", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox.\n    Vectorized by Chong (thanks Chong).\n\n    Args:\n        - masks should be a size [h, w, n] tensor of masks\n        - boxes should be a size [n, 4] tensor of bbox coords in relative point form\n    \"\"\"", "\n", "h", ",", "w", ",", "n", "=", "masks", ".", "size", "(", ")", "\n", "x1", ",", "x2", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", ",", "w", ",", "padding", ",", "cast", "=", "False", ")", "\n", "y1", ",", "y2", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", ",", "h", ",", "padding", ",", "cast", "=", "False", ")", "\n", "\n", "rows", "=", "torch", ".", "arange", "(", "w", ",", "device", "=", "masks", ".", "device", ",", "dtype", "=", "x1", ".", "dtype", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ")", ".", "expand", "(", "h", ",", "w", ",", "n", ")", "\n", "cols", "=", "torch", ".", "arange", "(", "h", ",", "device", "=", "masks", ".", "device", ",", "dtype", "=", "x1", ".", "dtype", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", ".", "expand", "(", "h", ",", "w", ",", "n", ")", "\n", "\n", "masks_left", "=", "rows", ">=", "x1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "masks_right", "=", "rows", "<", "x2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "masks_up", "=", "cols", ">=", "y1", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "masks_down", "=", "cols", "<", "y2", ".", "view", "(", "1", ",", "1", ",", "-", "1", ")", "\n", "\n", "crop_mask", "=", "masks_left", "*", "masks_right", "*", "masks_up", "*", "masks_down", "\n", "\n", "return", "masks", "*", "crop_mask", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.index2d": [[461, 475], ["[].expand_as", "[].view", "idx.size", "idx.size", "torch.arange", "src.view", "idx.size", "idx.view"], "function", ["None"], ["", "def", "index2d", "(", "src", ",", "idx", ")", ":", "\n", "    ", "\"\"\"\n    Indexes a tensor by a 2d index.\n\n    In effect, this does\n        out[i, j] = src[i, idx[i, j]]\n    \n    Both src and idx should have the same size.\n    \"\"\"", "\n", "\n", "offs", "=", "torch", ".", "arange", "(", "idx", ".", "size", "(", "0", ")", ",", "device", "=", "idx", ".", "device", ")", "[", ":", ",", "None", "]", ".", "expand_as", "(", "idx", ")", "\n", "idx", "=", "idx", "+", "offs", "*", "idx", ".", "size", "(", "1", ")", "\n", "\n", "return", "src", ".", "view", "(", "-", "1", ")", "[", "idx", ".", "view", "(", "-", "1", ")", "]", ".", "view", "(", "idx", ".", "size", "(", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.postprocess": [[16, 138], ["utils.augmentations.Resize.faster_rcnn_scale", "center_size", "torch.matmul", "torch.matmul", "torch.matmul", "box_utils.crop.permute().contiguous", "torch.interpolate().squeeze", "box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "boxes.long.long", "torch.zeros", "torch.zeros", "torch.zeros", "range", "dets[].size", "numpy.save", "output_utils.display_lincomb", "box_utils.crop.t", "data.cfg.mask_proto_mask_activation", "box_utils.crop", "box_utils.crop.gt_", "box_utils.crop.size", "box_utils.crop.size", "masks[].view", "torch.interpolate", "torch.Tensor", "torch.Tensor", "torch.Tensor", "proto_data.cpu().numpy", "box_utils.crop.permute", "torch.interpolate", "mask.gt().float.gt().float", "torch.Tensor", "torch.Tensor", "torch.Tensor", "box_utils.crop.unsqueeze", "proto_data.cpu", "int", "int", "mask.gt().float.gt", "proto_data.size", "proto_data.size"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Resize.faster_rcnn_scale", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.center_size", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.display_lincomb", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.crop"], ["def", "postprocess", "(", "det_output", ",", "w", ",", "h", ",", "batch_idx", "=", "0", ",", "interpolation_mode", "=", "'bilinear'", ",", "\n", "visualize_lincomb", "=", "False", ",", "crop_masks", "=", "True", ",", "score_threshold", "=", "0", ",", "mask_score", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Postprocesses the output of EPSNet on testing mode into a format that makes sense,\n    accounting for all the possible configuration settings.\n\n    Args:\n        - det_output: The lost of dicts that Detect outputs.\n        - w: The real with of the image.\n        - h: The real height of the image.\n        - batch_idx: If you have multiple images for this batch, the image's index in the batch.\n        - interpolation_mode: Can be 'nearest' | 'area' | 'bilinear' (see torch.nn.functional.interpolate)\n\n    Returns 4 torch Tensors (in the following order):\n        - classes [num_det]: The class idx for each detection.\n        - scores  [num_det]: The confidence score for each detection.\n        - boxes   [num_det, 4]: The bounding box for each detection in absolute point form.\n        - masks   [num_det, h, w]: Full image masks for each detection.\n    \"\"\"", "\n", "\n", "dets", "=", "det_output", "[", "batch_idx", "]", "\n", "\n", "if", "not", "'score'", "in", "dets", ":", "\n", "        ", "return", "[", "torch", ".", "Tensor", "(", ")", "]", "*", "4", "# Warning, this is 4 copies of the same thing", "\n", "\n", "", "if", "score_threshold", ">", "0", ":", "\n", "        ", "keep", "=", "dets", "[", "'score'", "]", ">", "score_threshold", "\n", "\n", "for", "k", "in", "dets", ":", "\n", "            ", "if", "k", "!=", "'proto'", "and", "k", "!=", "'segm'", ":", "\n", "                ", "dets", "[", "k", "]", "=", "dets", "[", "k", "]", "[", "keep", "]", "\n", "\n", "", "", "if", "dets", "[", "'score'", "]", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "            ", "return", "[", "torch", ".", "Tensor", "(", ")", "]", "*", "4", "\n", "\n", "# im_w and im_h when it concerns bboxes. This is a workaround hack for preserve_aspect_ratio", "\n", "", "", "b_w", ",", "b_h", "=", "(", "w", ",", "h", ")", "\n", "\n", "# Undo the padding introduced with preserve_aspect_ratio", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "        ", "r_w", ",", "r_h", "=", "Resize", ".", "faster_rcnn_scale", "(", "w", ",", "h", ",", "cfg", ".", "min_size", ",", "cfg", ".", "max_size", ")", "\n", "\n", "# Get rid of any detections whose centers are outside the image", "\n", "boxes", "=", "dets", "[", "'box'", "]", "\n", "boxes", "=", "center_size", "(", "boxes", ")", "\n", "s_w", ",", "s_h", "=", "(", "r_w", "/", "cfg", ".", "max_size", ",", "r_h", "/", "cfg", ".", "max_size", ")", "\n", "\n", "not_outside", "=", "(", "(", "boxes", "[", ":", ",", "0", "]", ">", "s_w", ")", "+", "(", "boxes", "[", ":", ",", "1", "]", ">", "s_h", ")", ")", "<", "1", "# not (a or b)", "\n", "for", "k", "in", "dets", ":", "\n", "            ", "if", "k", "!=", "'proto'", ":", "\n", "                ", "dets", "[", "k", "]", "=", "dets", "[", "k", "]", "[", "not_outside", "]", "\n", "\n", "# A hack to scale the bboxes to the right size", "\n", "", "", "b_w", ",", "b_h", "=", "(", "cfg", ".", "max_size", "/", "r_w", "*", "w", ",", "cfg", ".", "max_size", "/", "r_h", "*", "h", ")", "\n", "\n", "# Actually extract everything from dets now", "\n", "", "classes", "=", "dets", "[", "'class'", "]", "\n", "boxes", "=", "dets", "[", "'box'", "]", "\n", "scores", "=", "dets", "[", "'score'", "]", "\n", "masks", "=", "dets", "[", "'mask'", "]", "\n", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", "and", "cfg", ".", "eval_mask_branch", ":", "\n", "# At this points masks is only the coefficients", "\n", "        ", "proto_data", "=", "dets", "[", "'proto'", "]", "\n", "\n", "# Test flag, do not upvote", "\n", "if", "cfg", ".", "mask_proto_debug", ":", "\n", "            ", "np", ".", "save", "(", "'scripts/proto.npy'", ",", "proto_data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "\n", "", "if", "visualize_lincomb", ":", "\n", "            ", "display_lincomb", "(", "proto_data", ",", "masks", ")", "\n", "", "masks", "=", "torch", ".", "matmul", "(", "proto_data", ",", "masks", ".", "t", "(", ")", ")", "\n", "if", "mask_score", ":", "\n", "            ", "masks", "=", "cfg", ".", "mask_proto_mask_activation", "(", "masks", ")", "\n", "\n", "# Crop masks before upsampling because you know why", "\n", "", "if", "crop_masks", ":", "\n", "            ", "masks", "=", "crop", "(", "masks", ",", "boxes", ")", "\n", "\n", "# Permute into the correct output shape [num_dets, proto_h, proto_w]", "\n", "", "masks", "=", "masks", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "# Scale masks up to the full image", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "# Undo padding", "\n", "            ", "masks", "=", "masks", "[", ":", ",", ":", "int", "(", "r_h", "/", "cfg", ".", "max_size", "*", "proto_data", ".", "size", "(", "1", ")", ")", ",", ":", "int", "(", "r_w", "/", "cfg", ".", "max_size", "*", "proto_data", ".", "size", "(", "2", ")", ")", "]", "\n", "\n", "", "masks", "=", "F", ".", "interpolate", "(", "masks", ".", "unsqueeze", "(", "0", ")", ",", "(", "h", ",", "w", ")", ",", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "# Binarize the masks", "\n", "if", "mask_score", ":", "\n", "            ", "masks", ".", "gt_", "(", "0.5", ")", "\n", "\n", "", "", "if", "mask_score", "is", "True", ":", "\n", "        ", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", ",", "b_w", ",", "cast", "=", "False", ")", "\n", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", ",", "b_h", ",", "cast", "=", "False", ")", "\n", "boxes", "=", "boxes", ".", "long", "(", ")", "\n", "\n", "", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "direct", "and", "cfg", ".", "eval_mask_branch", ":", "\n", "# Upscale masks", "\n", "        ", "full_masks", "=", "torch", ".", "zeros", "(", "masks", ".", "size", "(", "0", ")", ",", "h", ",", "w", ")", "\n", "\n", "for", "jdx", "in", "range", "(", "masks", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "x1", ",", "y1", ",", "x2", ",", "y2", "=", "boxes", "[", "jdx", ",", ":", "]", "\n", "\n", "mask_w", "=", "x2", "-", "x1", "\n", "mask_h", "=", "y2", "-", "y1", "\n", "\n", "# Just in case", "\n", "if", "mask_w", "*", "mask_h", "<=", "0", "or", "mask_w", "<", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "mask", "=", "masks", "[", "jdx", ",", ":", "]", ".", "view", "(", "1", ",", "1", ",", "cfg", ".", "mask_size", ",", "cfg", ".", "mask_size", ")", "\n", "mask", "=", "F", ".", "interpolate", "(", "mask", ",", "(", "mask_h", ",", "mask_w", ")", ",", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", "\n", "if", "mask_score", ":", "\n", "                ", "mask", "=", "mask", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "", "full_masks", "[", "jdx", ",", "y1", ":", "y2", ",", "x1", ":", "x2", "]", "=", "mask", "\n", "\n", "", "masks", "=", "full_masks", "\n", "\n", "\n", "", "return", "classes", ",", "scores", ",", "boxes", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.instance_logit": [[142, 197], ["classes.cpu().numpy().astype.cpu().numpy().astype", "scores.cpu().numpy().astype.cpu().numpy().astype", "masks.view().cuda.view().cuda", "numpy.zeros", "utils.timer.env", "output_utils.postprocess", "classes.cpu().numpy().astype.size", "utils.timer.env", "boxes.cpu().long().numpy.clone", "box_utils.sanitize_coordinates", "box_utils.sanitize_coordinates", "boxes.cpu().long().numpy.cpu().long().numpy", "range", "classes.cpu().numpy().astype.cpu().numpy", "scores.cpu().numpy().astype.cpu().numpy", "masks.view().cuda.view", "masks.view().cuda.size", "masks[].cpu().numpy", "numpy.array", "np.array.sum", "keep_masks.append", "torch.stack.append", "keep_classes.append", "len", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "numpy.max", "boxes.cpu().long().numpy.cpu().long", "numpy.array", "classes.cpu().numpy().astype.cpu", "scores.cpu().numpy().astype.cpu", "masks[].cpu", "boxes.cpu().long().numpy.cpu", "numpy.logical_and().sum", "numpy.logical_and"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.postprocess", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["def", "instance_logit", "(", "dets", ",", "w", ",", "h", ",", "interpolation_mode", "=", "'bilinear'", ",", "\n", "visualize_lincomb", "=", "False", ",", "crop_masks", "=", "True", ",", "score_threshold", "=", "0", ",", "overlap_thr", "=", "0.5", ",", "mask_prune", "=", "False", ")", ":", "\n", "    ", "with", "timer", ".", "env", "(", "'Postprocess'", ")", ":", "\n", "        ", "classes", ",", "scores", ",", "boxes", ",", "masks", "=", "postprocess", "(", "dets", ",", "w", ",", "h", ",", "score_threshold", "=", "score_threshold", ",", "mask_score", "=", "False", ")", "\n", "\n", "", "if", "classes", ".", "size", "(", "0", ")", "==", "0", ":", "#no predicted mask", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "\n", "", "classes", "=", "classes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "int", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "float", ")", "\n", "masks", "=", "masks", ".", "view", "(", "-", "1", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "boxes", "=", "boxes", "\n", "\n", "used", "=", "np", ".", "zeros", "(", "(", "np", ".", "max", "(", "classes", ")", "+", "1", ",", "h", ",", "w", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "# used = np.zeros((h,w), dtype=np.uint8)", "\n", "\n", "keep_masks", "=", "[", "]", "\n", "keep_boxes", "=", "[", "]", "\n", "keep_classes", "=", "[", "]", "\n", "# mask_prune = True", "\n", "# if mask_prune is False:", "\n", "#     return masks, boxes, classes", "\n", "# else:", "\n", "with", "timer", ".", "env", "(", "'things mask pruning'", ")", ":", "\n", "        ", "org_boxes", "=", "boxes", ".", "clone", "(", ")", "#after sanitization, the bbox became absolute coord, but we want to keep it relative to apply in crop function", "\n", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "0", "]", ",", "boxes", "[", ":", ",", "2", "]", ",", "w", ",", "cast", "=", "False", ")", "\n", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", "=", "sanitize_coordinates", "(", "boxes", "[", ":", ",", "1", "]", ",", "boxes", "[", ":", ",", "3", "]", ",", "h", ",", "cast", "=", "False", ")", "\n", "boxes", "=", "boxes", ".", "cpu", "(", ")", ".", "long", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "masks", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "            ", "if", "(", "boxes", "[", "i", ",", "3", "]", "-", "boxes", "[", "i", ",", "1", "]", ")", "*", "(", "boxes", "[", "i", ",", "2", "]", "-", "boxes", "[", "i", ",", "0", "]", ")", "<=", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "mask_crop", "=", "masks", "[", "i", ",", "boxes", "[", "i", ",", "1", "]", ":", "boxes", "[", "i", ",", "3", "]", ",", "boxes", "[", "i", ",", "0", "]", ":", "boxes", "[", "i", ",", "2", "]", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "#mask logit , before activation", "\n", "mask_crop", "=", "np", ".", "array", "(", "mask_crop", ">", "0", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "used_crop", "=", "used", "[", "classes", "[", "i", "]", ",", "boxes", "[", "i", ",", "1", "]", ":", "boxes", "[", "i", ",", "3", "]", ",", "boxes", "[", "i", ",", "0", "]", ":", "boxes", "[", "i", ",", "2", "]", "]", "\n", "\n", "\n", "area", "=", "mask_crop", ".", "sum", "(", ")", "\n", "if", "area", "==", "0", "or", "(", "np", ".", "logical_and", "(", "used_crop", ">=", "1", ",", "mask_crop", "==", "1", ")", ".", "sum", "(", ")", "/", "area", ">", "overlap_thr", ")", ":", "\n", "                ", "continue", "\n", "\n", "\n", "", "used", "[", "classes", "[", "i", "]", ",", "boxes", "[", "i", ",", "1", "]", ":", "boxes", "[", "i", ",", "3", "]", ",", "boxes", "[", "i", ",", "0", "]", ":", "boxes", "[", "i", ",", "2", "]", "]", "+=", "mask_crop", "\n", "keep_masks", ".", "append", "(", "masks", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "keep_boxes", ".", "append", "(", "org_boxes", "[", "i", ",", ":", "]", ")", "\n", "keep_classes", ".", "append", "(", "classes", "[", "i", "]", ")", "\n", "\n", "", "if", "len", "(", "keep_masks", ")", ">", "0", ":", "\n", "            ", "ins_logits", "=", "torch", ".", "stack", "(", "keep_masks", ",", "dim", "=", "0", ")", "\n", "keep_boxes", "=", "torch", ".", "stack", "(", "keep_boxes", ",", "dim", "=", "0", ")", "\n", "return", "ins_logits", ",", "keep_boxes", ",", "np", ".", "array", "(", "keep_classes", ")", "\n", "", "else", ":", "\n", "            ", "return", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.panoptic_logit": [[198, 210], ["output_utils.instance_logit", "output_utils.semantic_logit", "output_utils.semantic_logit", "torch.cat", "torch.cat", "torch.cat", "torch.max", "torch.max", "torch.max"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.instance_logit", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.semantic_logit", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.semantic_logit"], ["", "", "", "def", "panoptic_logit", "(", "dets", ",", "w", ",", "h", ",", "batch_idx", "=", "0", ",", "interpolation_mode", "=", "'bilinear'", ",", "\n", "visualize_lincomb", "=", "False", ",", "crop_masks", "=", "True", ",", "score_threshold", "=", "0", ",", "overlap_thr", "=", "0.5", ")", ":", "\n", "    ", "ins_logit", ",", "keep_boxes", ",", "keep_classes", "=", "instance_logit", "(", "dets", ",", "w", ",", "h", ",", "score_threshold", "=", "score_threshold", ",", "overlap_thr", "=", "overlap_thr", ")", "\n", "n_thing", "=", "cfg", ".", "num_classes", "-", "1", "\n", "\n", "if", "ins_logit", "is", "not", "None", ":", "\n", "        ", "sem_logit", "=", "semantic_logit", "(", "dets", "[", "batch_idx", "]", ",", "h", ",", "w", ")", "\n", "sem_logit", "[", "0", "]", "=", "sem_logit", "[", "-", "1", "]", "-", "torch", ".", "max", "(", "ins_logit", ",", "dim", "=", "0", ")", "[", "0", "]", "# unknown prediction", "\n", "return", "torch", ".", "cat", "(", "(", "sem_logit", "[", ":", "-", "1", "]", ",", "cfg", ".", "panoptic_loss_k", "*", "ins_logit", ")", ",", "dim", "=", "0", ")", ",", "keep_classes", "\n", "", "else", ":", "\n", "        ", "sem_logit", "=", "semantic_logit", "(", "dets", "[", "batch_idx", "]", ",", "h", ",", "w", ")", "\n", "return", "sem_logit", "[", ":", "-", "1", "]", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.semantic_logit": [[212, 234], ["proto_out.size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "segment_coef.reshape().mean.reshape().mean", "torch.matmul", "torch.matmul", "torch.matmul", "segment_data.permute().contiguous.permute().contiguous", "torch.interpolate().squeeze", "torch.tensor().long().cuda", "torch.tensor().long().cuda", "torch.tensor().long().cuda", "box_utils.crop().permute", "segment_coef.reshape().mean.reshape", "segment_coef.reshape().mean.reshape", "segment_data.permute().contiguous.permute", "torch.interpolate", "torch.tensor().long", "torch.tensor().long", "torch.tensor().long", "box_utils.crop", "segment_coef.reshape().mean.size", "segment_data.permute().contiguous.unsqueeze", "things_logit.permute", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.crop"], ["", "", "def", "semantic_logit", "(", "dets", ",", "h", ",", "w", ",", "interpolation_mode", "=", "'bilinear'", ",", "crop_boxes", "=", "None", ",", "class_idx", "=", "None", ")", ":", "\n", "    ", "proto_out", "=", "dets", "[", "'proto'", "]", "# (h, w , mask_dim)", "\n", "segment_coef", "=", "dets", "[", "'segm'", "]", "# (channels ,h ,w)", "\n", "proto_h", ",", "proto_w", ",", "mask_dim", "=", "proto_out", ".", "size", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "segment_coef", "=", "segment_coef", ".", "reshape", "(", "segment_coef", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "segment_data", "=", "torch", ".", "matmul", "(", "proto_out", ",", "segment_coef", ".", "reshape", "(", "mask_dim", ",", "-", "1", ")", ")", "\n", "segment_data", "=", "segment_data", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "upsampled_mask", "=", "F", ".", "interpolate", "(", "segment_data", ".", "unsqueeze", "(", "0", ")", ",", "(", "h", ",", "w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", ")", "\n", "\n", "", "if", "crop_boxes", "is", "not", "None", ":", "\n", "        ", "things_to_stuff", "=", "cfg", ".", "dataset", ".", "things_to_stuff_map", "\n", "things_conf", "=", "torch", ".", "tensor", "(", "[", "things_to_stuff", "[", "label", "]", "for", "label", "in", "class_idx", "]", ")", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "\n", "things_logit", "=", "upsampled_mask", "[", "things_conf", ",", ":", ",", ":", "]", "\n", "things_logit_crop", "=", "crop", "(", "things_logit", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ",", "crop_boxes", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "\n", "return", "upsampled_mask", ",", "things_logit_crop", "\n", "", "else", ":", "\n", "        ", "return", "upsampled_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.undo_image_transformation": [[236, 262], ["img.permute().cpu().numpy", "numpy.clip", "utils.augmentations.Resize.faster_rcnn_scale", "cv2.resize", "cv2.resize", "img.permute().cpu", "numpy.array", "img.permute", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.augmentations.Resize.faster_rcnn_scale"], ["", "", "def", "undo_image_transformation", "(", "img", ",", "w", ",", "h", ")", ":", "\n", "    ", "\"\"\"\n    Takes a transformed image tensor and returns a numpy ndarray that is untransformed.\n    Arguments w and h are the original height and width of the image.\n    \"\"\"", "\n", "img_numpy", "=", "img", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "# To BRG", "\n", "\n", "if", "cfg", ".", "backbone", ".", "transform", ".", "normalize", ":", "\n", "        ", "img_numpy", "=", "(", "img_numpy", "*", "np", ".", "array", "(", "STD", ")", "+", "np", ".", "array", "(", "MEANS", ")", ")", "/", "255.0", "\n", "", "elif", "cfg", ".", "backbone", ".", "transform", ".", "subtract_means", ":", "\n", "        ", "img_numpy", "=", "(", "img_numpy", "/", "255.0", "+", "np", ".", "array", "(", "MEANS", ")", "/", "255.0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "", "img_numpy", "=", "img_numpy", "[", ":", ",", ":", ",", "(", "2", ",", "1", ",", "0", ")", "]", "# To RGB", "\n", "img_numpy", "=", "np", ".", "clip", "(", "img_numpy", ",", "0", ",", "1", ")", "\n", "\n", "if", "cfg", ".", "preserve_aspect_ratio", ":", "\n", "# Undo padding", "\n", "        ", "r_w", ",", "r_h", "=", "Resize", ".", "faster_rcnn_scale", "(", "w", ",", "h", ",", "cfg", ".", "min_size", ",", "cfg", ".", "max_size", ")", "\n", "img_numpy", "=", "img_numpy", "[", ":", "r_h", ",", ":", "r_w", "]", "\n", "\n", "# Undo resizing", "\n", "img_numpy", "=", "cv2", ".", "resize", "(", "img_numpy", ",", "(", "w", ",", "h", ")", ")", "\n", "\n", "", "else", ":", "\n", "        ", "return", "cv2", ".", "resize", "(", "img_numpy", ",", "(", "w", ",", "h", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.layers.output_utils.display_lincomb": [[264, 306], ["torch.matmul", "torch.matmul", "torch.matmul", "range", "masks.t", "masks[].cpu().numpy", "numpy.argsort", "proto_data.size", "numpy.zeros", "numpy.zeros", "torch.sum().cpu().numpy", "torch.sum().cpu().numpy", "torch.sum().cpu().numpy", "range", "matplotlib.imshow", "matplotlib.show", "matplotlib.imshow", "matplotlib.show", "range", "out_masks[].cpu().numpy", "masks[].cpu", "numpy.abs", "torch.sum().cpu", "torch.sum().cpu", "torch.sum().cpu", "out_masks[].cpu", "torch.sum", "torch.sum", "torch.sum", "proto_data[].cpu().numpy", "proto_data[].cpu().numpy", "numpy.exp", "proto_data[].cpu", "proto_data[].cpu", "torch.max", "torch.max", "torch.max"], "function", ["None"], ["", "", "def", "display_lincomb", "(", "proto_data", ",", "masks", ")", ":", "\n", "    ", "out_masks", "=", "torch", ".", "matmul", "(", "proto_data", ",", "masks", ".", "t", "(", ")", ")", "\n", "# out_masks = cfg.mask_proto_mask_activation(out_masks)", "\n", "\n", "for", "kdx", "in", "range", "(", "1", ")", ":", "\n", "        ", "jdx", "=", "kdx", "+", "0", "\n", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "coeffs", "=", "masks", "[", "jdx", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "idx", "=", "np", ".", "argsort", "(", "-", "np", ".", "abs", "(", "coeffs", ")", ")", "\n", "# plt.bar(list(range(idx.shape[0])), coeffs[idx])", "\n", "# plt.show()", "\n", "\n", "coeffs_sort", "=", "coeffs", "[", "idx", "]", "\n", "arr_h", ",", "arr_w", "=", "(", "4", ",", "8", ")", "\n", "proto_h", ",", "proto_w", ",", "_", "=", "proto_data", ".", "size", "(", ")", "\n", "arr_img", "=", "np", ".", "zeros", "(", "[", "proto_h", "*", "arr_h", ",", "proto_w", "*", "arr_w", "]", ")", "\n", "arr_run", "=", "np", ".", "zeros", "(", "[", "proto_h", "*", "arr_h", ",", "proto_w", "*", "arr_w", "]", ")", "\n", "test", "=", "torch", ".", "sum", "(", "proto_data", ",", "-", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "y", "in", "range", "(", "arr_h", ")", ":", "\n", "            ", "for", "x", "in", "range", "(", "arr_w", ")", ":", "\n", "                ", "i", "=", "arr_w", "*", "y", "+", "x", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                    ", "running_total", "=", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "coeffs_sort", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "running_total", "+=", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "coeffs_sort", "[", "i", "]", "\n", "\n", "", "running_total_nonlin", "=", "running_total", "\n", "if", "cfg", ".", "mask_proto_mask_activation", "==", "activation_func", ".", "sigmoid", ":", "\n", "                    ", "running_total_nonlin", "=", "(", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "running_total_nonlin", ")", ")", ")", "\n", "\n", "", "arr_img", "[", "y", "*", "proto_h", ":", "(", "y", "+", "1", ")", "*", "proto_h", ",", "x", "*", "proto_w", ":", "(", "x", "+", "1", ")", "*", "proto_w", "]", "=", "(", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", "/", "torch", ".", "max", "(", "proto_data", "[", ":", ",", ":", ",", "idx", "[", "i", "]", "]", ")", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "coeffs_sort", "[", "i", "]", "\n", "arr_run", "[", "y", "*", "proto_h", ":", "(", "y", "+", "1", ")", "*", "proto_h", ",", "x", "*", "proto_w", ":", "(", "x", "+", "1", ")", "*", "proto_w", "]", "=", "(", "running_total_nonlin", ">", "0.5", ")", ".", "astype", "(", "np", ".", "float", ")", "\n", "", "", "plt", ".", "imshow", "(", "arr_img", ")", "\n", "plt", ".", "show", "(", ")", "\n", "# plt.imshow(arr_run)", "\n", "# plt.show()", "\n", "# plt.imshow(test)", "\n", "# plt.show()", "\n", "plt", ".", "imshow", "(", "out_masks", "[", ":", ",", ":", ",", "jdx", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "plt", ".", "show", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.__init__": [[24, 36], ["ValueError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "bkg_label", ",", "top_k", ",", "conf_thresh", ",", "nms_thresh", ")", ":", "\n", "        ", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "background_label", "=", "bkg_label", "\n", "self", ".", "top_k", "=", "top_k", "\n", "# Parameters used in nms.", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "if", "nms_thresh", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'nms_threshold must be non negative.'", ")", "\n", "", "self", ".", "conf_thresh", "=", "conf_thresh", "\n", "\n", "self", ".", "cross_class_nms", "=", "False", "\n", "self", ".", "use_fast_nms", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.__call__": [[37, 95], ["utils.timer.env", "loc_data.size", "prior_data.size", "conf_data.view().transpose().contiguous", "range", "box_utils.decode", "detection.Detect.detect", "out.append", "conf_data.view().transpose", "conf_data.view"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode", "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.detect", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "__call__", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n             loc_data: (tensor) Loc preds from loc layers\n                Shape: [batch, num_priors, 4]\n            conf_data: (tensor) Shape: Conf preds from conf layers\n                Shape: [batch, num_priors, num_classes]\n            mask_data: (tensor) Mask preds from mask layers\n                Shape: [batch, num_priors, mask_dim]\n            prior_data: (tensor) Prior boxes and variances from priorbox layers\n                Shape: [num_priors, 4]\n            proto_data: (tensor) If using mask_type.lincomb, the prototype masks\n                Shape: [batch, mask_h, mask_w, mask_dim]\n        \n        Returns:\n            output of shape (batch_size, top_k, 1 + 1 + 4 + mask_dim)\n            These outputs are in the order: class idx, confidence, bbox coords, and mask.\n\n            Note that the outputs are sorted only if cross_class_nms is False\n        \"\"\"", "\n", "\n", "loc_data", "=", "predictions", "[", "'loc'", "]", "\n", "conf_data", "=", "predictions", "[", "'conf'", "]", "\n", "mask_data", "=", "predictions", "[", "'mask'", "]", "\n", "prior_data", "=", "predictions", "[", "'priors'", "]", "\n", "\n", "proto_data", "=", "predictions", "[", "'proto'", "]", "if", "'proto'", "in", "predictions", "else", "None", "\n", "inst_data", "=", "predictions", "[", "'inst'", "]", "if", "'inst'", "in", "predictions", "else", "None", "\n", "segm_data", "=", "predictions", "[", "'segm'", "]", "if", "'segm'", "in", "predictions", "else", "None", "\n", "\n", "out", "=", "[", "]", "\n", "\n", "\n", "with", "timer", ".", "env", "(", "'Detect'", ")", ":", "\n", "            ", "batch_size", "=", "loc_data", ".", "size", "(", "0", ")", "\n", "num_priors", "=", "prior_data", ".", "size", "(", "0", ")", "\n", "\n", "conf_preds", "=", "conf_data", ".", "view", "(", "batch_size", ",", "num_priors", ",", "self", ".", "num_classes", ")", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "\n", "for", "batch_idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "decoded_boxes", "=", "decode", "(", "loc_data", "[", "batch_idx", "]", ",", "prior_data", ")", "\n", "result", "=", "self", ".", "detect", "(", "batch_idx", ",", "conf_preds", ",", "decoded_boxes", ",", "mask_data", ",", "inst_data", ")", "\n", "\n", "# if result is not None and proto_data is not None:", "\n", "#     result['proto'] = proto_data[batch_idx]", "\n", "# if result is not None and segm_data is not None:", "\n", "#     result['segm'] = segm_data[batch_idx]", "\n", "\n", "if", "result", "is", "None", ":", "\n", "                    ", "result", "=", "{", "}", "\n", "", "if", "proto_data", "is", "not", "None", ":", "\n", "                    ", "result", "[", "'proto'", "]", "=", "proto_data", "[", "batch_idx", "]", "\n", "", "if", "segm_data", "is", "not", "None", ":", "\n", "                    ", "result", "[", "'segm'", "]", "=", "segm_data", "[", "batch_idx", "]", "\n", "\n", "", "out", ".", "append", "(", "result", ")", "\n", "\n", "", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.detect": [[97, 118], ["torch.max", "torch.max", "torch.max", "torch.max", "scores.size", "detection.Detect.fast_nms", "detection.Detect.traditional_nms"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.fast_nms", "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.traditional_nms"], ["", "def", "detect", "(", "self", ",", "batch_idx", ",", "conf_preds", ",", "decoded_boxes", ",", "mask_data", ",", "inst_data", ")", ":", "\n", "        ", "\"\"\" Perform nms for only the max scoring class that isn't background (class 0) \"\"\"", "\n", "cur_scores", "=", "conf_preds", "[", "batch_idx", ",", "1", ":", ",", ":", "]", "\n", "conf_scores", ",", "_", "=", "torch", ".", "max", "(", "cur_scores", ",", "dim", "=", "0", ")", "\n", "keep", "=", "(", "conf_scores", ">", "self", ".", "conf_thresh", ")", "\n", "scores", "=", "cur_scores", "[", ":", ",", "keep", "]", "\n", "boxes", "=", "decoded_boxes", "[", "keep", ",", ":", "]", "\n", "masks", "=", "mask_data", "[", "batch_idx", ",", "keep", ",", ":", "]", "\n", "\n", "if", "inst_data", "is", "not", "None", ":", "\n", "            ", "inst", "=", "inst_data", "[", "batch_idx", ",", "keep", ",", ":", "]", "\n", "\n", "", "if", "scores", ".", "size", "(", "1", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "if", "self", ".", "use_fast_nms", ":", "\n", "            ", "boxes", ",", "masks", ",", "classes", ",", "scores", "=", "self", ".", "fast_nms", "(", "boxes", ",", "masks", ",", "scores", ",", "self", ".", "nms_thresh", ",", "self", ".", "top_k", ")", "\n", "", "else", ":", "\n", "            ", "boxes", ",", "masks", ",", "classes", ",", "scores", "=", "self", ".", "traditional_nms", "(", "boxes", ",", "masks", ",", "scores", ",", "self", ".", "nms_thresh", ",", "self", ".", "conf_thresh", ")", "\n", "\n", "", "return", "{", "'box'", ":", "boxes", ",", "'mask'", ":", "masks", ",", "'class'", ":", "classes", ",", "'score'", ":", "scores", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.coefficient_nms": [[120, 145], ["scores.sort", "torch.normalize", "torch.normalize", "cos_similarity.triu_", "torch.max", "torch.max", "torch.max", "torch.max", "torch.normalize.t", "idx_out.size"], "methods", ["None"], ["", "def", "coefficient_nms", "(", "self", ",", "coeffs", ",", "scores", ",", "cos_threshold", "=", "0.9", ",", "top_k", "=", "400", ")", ":", "\n", "        ", "_", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "top_k", "]", "\n", "coeffs_norm", "=", "F", ".", "normalize", "(", "coeffs", "[", "idx", "]", ",", "dim", "=", "1", ")", "\n", "\n", "# Compute the pairwise cosine similarity between the coefficients", "\n", "cos_similarity", "=", "coeffs_norm", "@", "coeffs_norm", ".", "t", "(", ")", "\n", "\n", "# Zero out the lower triangle of the cosine similarity matrix and diagonal", "\n", "cos_similarity", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "\n", "# Now that everything in the diagonal and below is zeroed out, if we take the max", "\n", "# of the cos similarity matrix along the columns, each column will represent the", "\n", "# maximum cosine similarity between this element and every element with a higher", "\n", "# score than this element.", "\n", "cos_max", ",", "_", "=", "torch", ".", "max", "(", "cos_similarity", ",", "dim", "=", "0", ")", "\n", "\n", "# Now just filter out the ones higher than the threshold", "\n", "idx_out", "=", "idx", "[", "cos_max", "<=", "cos_threshold", "]", "\n", "\n", "\n", "# new_mask_norm = F.normalize(masks[idx_out], dim=1)", "\n", "# print(new_mask_norm[:5] @ new_mask_norm[:5].t())", "\n", "\n", "return", "idx_out", ",", "idx_out", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.fast_nms": [[146, 190], ["scores.sort", "idx[].contiguous", "idx[].contiguous.size", "boxes[].view", "masks[].view", "box_utils.jaccard", "box_utils.jaccard.triu_", "box_utils.jaccard.max", "[].expand_as", "scores.sort", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "idx[].contiguous.view", "idx[].contiguous.view"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard"], ["", "def", "fast_nms", "(", "self", ",", "boxes", ",", "masks", ",", "scores", ",", "iou_threshold", ":", "float", "=", "0.5", ",", "top_k", ":", "int", "=", "200", ",", "second_threshold", ":", "bool", "=", "False", ")", ":", "\n", "        ", "scores", ",", "idx", "=", "scores", ".", "sort", "(", "1", ",", "descending", "=", "True", ")", "\n", "\n", "idx", "=", "idx", "[", ":", ",", ":", "top_k", "]", ".", "contiguous", "(", ")", "\n", "scores", "=", "scores", "[", ":", ",", ":", "top_k", "]", "\n", "\n", "num_classes", ",", "num_dets", "=", "idx", ".", "size", "(", ")", "\n", "\n", "boxes", "=", "boxes", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "4", ")", "\n", "masks", "=", "masks", "[", "idx", ".", "view", "(", "-", "1", ")", ",", ":", "]", ".", "view", "(", "num_classes", ",", "num_dets", ",", "-", "1", ")", "\n", "\n", "iou", "=", "jaccard", "(", "boxes", ",", "boxes", ")", "\n", "iou", ".", "triu_", "(", "diagonal", "=", "1", ")", "\n", "iou_max", ",", "_", "=", "iou", ".", "max", "(", "dim", "=", "1", ")", "\n", "\n", "# Now just filter out the ones higher than the threshold", "\n", "keep", "=", "(", "iou_max", "<=", "iou_threshold", ")", "\n", "\n", "# We should also only keep detections over the confidence threshold, but at the cost of", "\n", "# maxing out your detection count for every image, you can just not do that. Because we", "\n", "# have such a minimal amount of computation per detection (matrix mulitplication only),", "\n", "# this increase doesn't affect us much (+0.2 mAP for 34 -> 33 fps), so we leave it out.", "\n", "# However, when you implement this in your method, you should do this second threshold.", "\n", "if", "second_threshold", ":", "\n", "            ", "keep", "*=", "(", "scores", ">", "self", ".", "conf_thresh", ")", "\n", "\n", "# Assign each kept detection to its corresponding class", "\n", "", "classes", "=", "torch", ".", "arange", "(", "num_classes", ",", "device", "=", "boxes", ".", "device", ")", "[", ":", ",", "None", "]", ".", "expand_as", "(", "keep", ")", "\n", "classes", "=", "classes", "[", "keep", "]", "\n", "\n", "boxes", "=", "boxes", "[", "keep", "]", "\n", "masks", "=", "masks", "[", "keep", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "\n", "# Only keep the top cfg.max_num_detections highest scores across all classes", "\n", "scores", ",", "idx", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx", "=", "idx", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "scores", "=", "scores", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "\n", "classes", "=", "classes", "[", "idx", "]", "\n", "boxes", "=", "boxes", "[", "idx", "]", "\n", "masks", "=", "masks", "[", "idx", "]", "\n", "\n", "return", "boxes", ",", "masks", ",", "classes", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.functions.detection.Detect.traditional_nms": [[191, 233], ["torch.cat.size", "torch.cat.size", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.sort", "torch.cat.sort", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "utils.cython_nms.nms", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "torch.Tensor().long", "idx_lst.append", "cls_lst.append", "scr_lst.append", "cls_scores.size", "cls_scores.size", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.cat().cpu", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "traditional_nms", "(", "self", ",", "boxes", ",", "masks", ",", "scores", ",", "iou_threshold", "=", "0.5", ",", "conf_thresh", "=", "0.05", ")", ":", "\n", "        ", "num_classes", "=", "scores", ".", "size", "(", "0", ")", "\n", "\n", "idx_lst", "=", "[", "]", "\n", "cls_lst", "=", "[", "]", "\n", "scr_lst", "=", "[", "]", "\n", "\n", "# Multiplying by max_size is necessary because of how cnms computes its area and intersections", "\n", "boxes", "=", "boxes", "*", "cfg", ".", "max_size", "\n", "\n", "for", "_cls", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "cls_scores", "=", "scores", "[", "_cls", ",", ":", "]", "\n", "conf_mask", "=", "cls_scores", ">", "conf_thresh", "\n", "idx", "=", "torch", ".", "arange", "(", "cls_scores", ".", "size", "(", "0", ")", ",", "device", "=", "boxes", ".", "device", ")", "\n", "\n", "cls_scores", "=", "cls_scores", "[", "conf_mask", "]", "\n", "idx", "=", "idx", "[", "conf_mask", "]", "\n", "\n", "if", "cls_scores", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "preds", "=", "torch", ".", "cat", "(", "[", "boxes", "[", "conf_mask", "]", ",", "cls_scores", "[", ":", ",", "None", "]", "]", ",", "dim", "=", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "keep", "=", "cnms", "(", "preds", ",", "iou_threshold", ")", "\n", "keep", "=", "torch", ".", "Tensor", "(", "keep", ",", "device", "=", "boxes", ".", "device", ")", ".", "long", "(", ")", "\n", "\n", "idx_lst", ".", "append", "(", "idx", "[", "keep", "]", ")", "\n", "cls_lst", ".", "append", "(", "keep", "*", "0", "+", "_cls", ")", "\n", "scr_lst", ".", "append", "(", "cls_scores", "[", "keep", "]", ")", "\n", "\n", "", "idx", "=", "torch", ".", "cat", "(", "idx_lst", ",", "dim", "=", "0", ")", "\n", "classes", "=", "torch", ".", "cat", "(", "cls_lst", ",", "dim", "=", "0", ")", "\n", "scores", "=", "torch", ".", "cat", "(", "scr_lst", ",", "dim", "=", "0", ")", "\n", "\n", "scores", ",", "idx2", "=", "scores", ".", "sort", "(", "0", ",", "descending", "=", "True", ")", "\n", "idx2", "=", "idx2", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "scores", "=", "scores", "[", ":", "cfg", ".", "max_num_detections", "]", "\n", "\n", "idx", "=", "idx", "[", "idx2", "]", "\n", "classes", "=", "classes", "[", "idx2", "]", "\n", "\n", "# Undo the multiplication above", "\n", "return", "boxes", "[", "idx", "]", "/", "cfg", ".", "max_size", ",", "masks", "[", "idx", "]", ",", "classes", ",", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.__init__": [[34, 46], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "pos_threshold", ",", "neg_threshold", ",", "negpos_ratio", ")", ":", "\n", "        ", "super", "(", "MultiBoxLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "self", ".", "pos_threshold", "=", "pos_threshold", "\n", "self", ".", "neg_threshold", "=", "neg_threshold", "\n", "self", ".", "negpos_ratio", "=", "negpos_ratio", "\n", "\n", "# If you output a proto mask with this area, your l1 loss will be l1_alpha", "\n", "# Note that the area is relative (so 1 would be the entire image)", "\n", "self", ".", "l1_expected_area", "=", "20", "*", "20", "/", "70", "/", "70", "\n", "self", ".", "l1_alpha", "=", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.forward": [[47, 241], ["wrapper.get_args", "loc_data.size", "priors.size", "loc_data.new", "loc_data.new", "loc_data.new", "loc_data.new().long", "loc_data.new().long", "loc_data.new().long", "range", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "pos.sum", "pos_pan.sum", "pos.unsqueeze().expand_as", "pos.sum.data.sum().float", "len", "loc_data.new", "[].data.long", "loc_data[].view", "loc_t[].view", "multibox_loss.MultiBoxLoss.ohem_conf_loss", "multibox_loss.MultiBoxLoss.class_existence_loss", "multibox_loss.MultiBoxLoss.panoptic_loss", "loc_data.new", "loc_data.new", "loc_data.new", "split", "split", "split", "truths.nelement", "pos.unsqueeze", "multibox_loss.MultiBoxLoss.GIoU_loss", "multibox_loss.MultiBoxLoss.focal_conf_sigmoid_loss", "multibox_loss.MultiBoxLoss.lincomb_semantic_segmentation_loss", "multibox_loss.MultiBoxLoss._semantic_segmentation_loss", "pos.sum.data.sum", "loc_data.size", "[].max", "box_utils.atss_match", "box_utils.match", "pos.dim", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "range", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask_data[].view", "multibox_loss.MultiBoxLoss.direct_mask_loss", "multibox_loss.MultiBoxLoss.lincomb_mask_loss", "losses.update", "multibox_loss.MultiBoxLoss.focal_conf_objectness_loss", "pos_masks.append", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "multibox_loss.MultiBoxLoss.focal_loss_v2", "multibox_loss.MultiBoxLoss.focal_conf_loss", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.autograd.Variable.get_device", "torch.autograd.Variable.get_device", "torch.autograd.Variable.get_device", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.train.ScatterWrapper.get_args", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.ohem_conf_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.class_existence_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.panoptic_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.GIoU_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_conf_sigmoid_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.lincomb_semantic_segmentation_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss._semantic_segmentation_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.atss_match", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.match", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.direct_mask_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.lincomb_mask_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_conf_objectness_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_loss_v2", "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_conf_loss"], ["", "def", "forward", "(", "self", ",", "predictions", ",", "wrapper", ",", "wrapper_mask", ")", ":", "\n", "        ", "\"\"\"Multibox Loss\n        Args:\n            predictions (tuple): A tuple containing loc preds, conf preds,\n            mask preds, and prior boxes from SSD net.\n                loc shape: torch.size(batch_size,num_priors,4)\n                conf shape: torch.size(batch_size,num_priors,num_classes)\n                masks shape: torch.size(batch_size,num_priors,mask_dim)\n                priors shape: torch.size(num_priors,4)\n                proto* shape: torch.size(batch_size,mask_h,mask_w,mask_dim)\n\n            targets (list<tensor>): Ground truth boxes and labels for a batch,\n                shape: [batch_size][num_objs,5] (last idx is the label).\n\n            masks (list<tensor>): Ground truth masks for each object in each image,\n                shape: [batch_size][num_objs,im_height,im_width]\n\n            num_crowds (list<int>): Number of crowd annotations per batch. The crowd\n                annotations should be the last num_crowds elements of targets and masks.\n            \n            * Only if mask_type == lincomb\n        \"\"\"", "\n", "\n", "loc_data", "=", "predictions", "[", "'loc'", "]", "\n", "conf_data", "=", "predictions", "[", "'conf'", "]", "\n", "mask_data", "=", "predictions", "[", "'mask'", "]", "\n", "priors", "=", "predictions", "[", "'priors'", "]", "\n", "\n", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "            ", "proto_data", "=", "predictions", "[", "'proto'", "]", "\n", "\n", "", "if", "cfg", ".", "use_instance_coeff", ":", "\n", "            ", "inst_data", "=", "predictions", "[", "'inst'", "]", "\n", "", "else", ":", "\n", "            ", "inst_data", "=", "None", "\n", "\n", "", "targets", ",", "masks", ",", "masks_stuff", ",", "num_crowds", "=", "wrapper", ".", "get_args", "(", "wrapper_mask", ")", "\n", "\n", "labels", "=", "[", "None", "]", "*", "len", "(", "targets", ")", "# Used in sem segm loss", "\n", "\n", "batch_size", "=", "loc_data", ".", "size", "(", "0", ")", "\n", "# This is necessary for training on multiple GPUs because", "\n", "# DataParallel will cat the priors from each GPU together", "\n", "priors", "=", "priors", "[", ":", "loc_data", ".", "size", "(", "1", ")", ",", ":", "]", "\n", "num_priors", "=", "(", "priors", ".", "size", "(", "0", ")", ")", "\n", "num_classes", "=", "self", ".", "num_classes", "\n", "\n", "# Match priors (default boxes) and ground truth boxes", "\n", "# These tensors will be created with the same device as loc_data", "\n", "loc_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ",", "4", ")", "\n", "gt_box_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ",", "4", ")", "\n", "gt_box_t_pan", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ",", "4", ")", "\n", "conf_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ")", ".", "long", "(", ")", "\n", "idx_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ")", ".", "long", "(", ")", "\n", "idx_t_pan", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_priors", ")", ".", "long", "(", ")", "\n", "\n", "defaults", "=", "priors", ".", "data", "\n", "\n", "\n", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "            ", "class_existence_t", "=", "loc_data", ".", "new", "(", "batch_size", ",", "num_classes", "-", "1", ")", "\n", "\n", "", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "truths", "=", "targets", "[", "idx", "]", "[", ":", ",", ":", "-", "1", "]", ".", "data", "\n", "labels", "[", "idx", "]", "=", "targets", "[", "idx", "]", "[", ":", ",", "-", "1", "]", ".", "data", ".", "long", "(", ")", "\n", "\n", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "# Construct a one-hot vector for each object and collapse it into an existence vector with max", "\n", "# Also it's fine to include the crowd annotations here", "\n", "                ", "class_existence_t", "[", "idx", ",", ":", "]", "=", "torch", ".", "eye", "(", "num_classes", "-", "1", ",", "device", "=", "conf_t", ".", "get_device", "(", ")", ")", "[", "labels", "[", "idx", "]", "]", ".", "max", "(", "dim", "=", "0", ")", "[", "0", "]", "\n", "\n", "# Split the crowd annotations because they come bundled in", "\n", "", "cur_crowds", "=", "num_crowds", "[", "idx", "]", "\n", "if", "cur_crowds", ">", "0", ":", "\n", "                ", "split", "=", "lambda", "x", ":", "(", "x", "[", "-", "cur_crowds", ":", "]", ",", "x", "[", ":", "-", "cur_crowds", "]", ")", "\n", "crowd_boxes", ",", "truths", "=", "split", "(", "truths", ")", "\n", "\n", "# We don't use the crowd labels or masks", "\n", "_", ",", "labels", "[", "idx", "]", "=", "split", "(", "labels", "[", "idx", "]", ")", "\n", "_", ",", "masks", "[", "idx", "]", "=", "split", "(", "masks", "[", "idx", "]", ")", "\n", "if", "masks", "[", "idx", "]", ".", "shape", "[", "0", "]", "==", "0", ":", "#no bbox which is not crowd", "\n", "                    ", "return", "None", "\n", "", "", "else", ":", "\n", "                ", "crowd_boxes", "=", "None", "\n", "\n", "\n", "", "if", "truths", ".", "nelement", "(", ")", "!=", "0", ":", "#if len of target > 0 ", "\n", "                ", "if", "cfg", ".", "use_atss", ":", "\n", "                    ", "atss_match", "(", "self", ".", "pos_threshold", ",", "self", ".", "neg_threshold", ",", "#matching the pred and gt and return the remaining gt mask", "\n", "truths", ",", "defaults", ",", "labels", "[", "idx", "]", ",", "crowd_boxes", ",", "\n", "loc_t", ",", "conf_t", ",", "idx_t", ",", "idx_t_pan", ",", "idx", ",", "loc_data", "[", "idx", "]", ",", "predictions", "[", "'layer'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "match", "(", "self", ".", "pos_threshold", ",", "self", ".", "neg_threshold", ",", "#matching the pred and gt and return the remaining gt mask", "\n", "truths", ",", "defaults", ",", "labels", "[", "idx", "]", ",", "crowd_boxes", ",", "\n", "loc_t", ",", "conf_t", ",", "idx_t", ",", "idx_t_pan", ",", "idx", ",", "loc_data", "[", "idx", "]", ")", "\n", "\n", "", "gt_box_t", "[", "idx", ",", ":", ",", ":", "]", "=", "truths", "[", "idx_t", "[", "idx", "]", "]", "#gt bbox for every prior", "\n", "gt_box_t_pan", "[", "idx", ",", ":", ",", ":", "]", "=", "truths", "[", "idx_t_pan", "[", "idx", "]", "]", "\n", "\n", "\n", "\n", "\n", "# wrap targets", "\n", "", "", "loc_t", "=", "Variable", "(", "loc_t", ",", "requires_grad", "=", "False", ")", "\n", "conf_t", "=", "Variable", "(", "conf_t", ",", "requires_grad", "=", "False", ")", "\n", "idx_t", "=", "Variable", "(", "idx_t", ",", "requires_grad", "=", "False", ")", "\n", "\n", "pos", "=", "conf_t", ">", "0", "\n", "pos_pan", "=", "idx_t_pan", ">", "0", "# get the priors that match best for each gt", "\n", "num_pos", "=", "pos", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "num_pos_pan", "=", "pos_pan", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "\n", "# Shape: [batch,num_priors,4]", "\n", "pos_idx", "=", "pos", ".", "unsqueeze", "(", "pos", ".", "dim", "(", ")", ")", ".", "expand_as", "(", "loc_data", ")", "\n", "losses", "=", "{", "}", "\n", "\n", "# Localization Loss (Smooth L1)", "\n", "if", "cfg", ".", "train_boxes", ":", "\n", "            ", "loc_p", "=", "loc_data", "[", "pos_idx", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "loc_t_pos", "=", "loc_t", "[", "pos_idx", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "\n", "if", "cfg", ".", "use_giou_loss", ":", "\n", "                ", "losses", "[", "'B'", "]", "=", "self", ".", "GIoU_loss", "(", "loc_data", ",", "loc_t", ",", "priors", ",", "pos_idx", ")", "\n", "", "else", ":", "\n", "                ", "losses", "[", "'B'", "]", "=", "F", ".", "smooth_l1_loss", "(", "loc_p", ",", "loc_t_pos", ",", "reduction", "=", "'sum'", ")", "*", "cfg", ".", "bbox_alpha", "\n", "\n", "", "", "if", "cfg", ".", "train_masks", ":", "\n", "            ", "if", "cfg", ".", "mask_type", "==", "mask_type", ".", "direct", ":", "\n", "                ", "if", "cfg", ".", "use_gt_bboxes", ":", "\n", "                    ", "pos_masks", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "                        ", "pos_masks", ".", "append", "(", "masks", "[", "idx", "]", "[", "idx_t", "[", "idx", ",", "pos", "[", "idx", "]", "]", "]", ")", "\n", "", "masks_t", "=", "torch", ".", "cat", "(", "pos_masks", ",", "0", ")", "\n", "masks_p", "=", "mask_data", "[", "pos", ",", ":", "]", ".", "view", "(", "-", "1", ",", "cfg", ".", "mask_dim", ")", "\n", "losses", "[", "'M'", "]", "=", "F", ".", "binary_cross_entropy", "(", "torch", ".", "clamp", "(", "masks_p", ",", "0", ",", "1", ")", ",", "masks_t", ",", "reduction", "=", "'sum'", ")", "*", "cfg", ".", "mask_alpha", "\n", "", "else", ":", "\n", "                    ", "losses", "[", "'M'", "]", "=", "self", ".", "direct_mask_loss", "(", "pos_idx", ",", "idx_t", ",", "loc_data", ",", "mask_data", ",", "priors", ",", "masks", ")", "\n", "", "", "elif", "cfg", ".", "mask_type", "==", "mask_type", ".", "lincomb", ":", "\n", "                ", "mask_loss", ",", "pred_masks", ",", "mask_t", ",", "pos_gt_boxes", "=", "self", ".", "lincomb_mask_loss", "(", "pos", ",", "pos_pan", ",", "idx_t", ",", "idx_t_pan", ",", "loc_data", ",", "mask_data", ",", "priors", ",", "proto_data", ",", "masks", ",", "gt_box_t", ",", "gt_box_t_pan", ",", "inst_data", ")", "\n", "losses", ".", "update", "(", "mask_loss", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_loss", "is", "not", "None", ":", "\n", "                    ", "if", "cfg", ".", "mask_proto_loss", "==", "'l1'", ":", "\n", "                        ", "losses", "[", "'P'", "]", "=", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "proto_data", ")", ")", "/", "self", ".", "l1_expected_area", "*", "self", ".", "l1_alpha", "\n", "", "elif", "cfg", ".", "mask_proto_loss", "==", "'disj'", ":", "\n", "                        ", "losses", "[", "'P'", "]", "=", "-", "torch", ".", "mean", "(", "torch", ".", "max", "(", "F", ".", "log_softmax", "(", "proto_data", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "\n", "\n", "# Confidence loss", "\n", "# if cfg.train_class:", "\n", "", "", "", "", "if", "cfg", ".", "use_focal_loss", ":", "\n", "            ", "if", "cfg", ".", "use_sigmoid_focal_loss", ":", "\n", "                ", "losses", "[", "'C'", "]", "=", "self", ".", "focal_conf_sigmoid_loss", "(", "conf_data", ",", "conf_t", ")", "\n", "", "elif", "cfg", ".", "use_objectness_score", ":", "\n", "                ", "losses", "[", "'C'", "]", "=", "self", ".", "focal_conf_objectness_loss", "(", "conf_data", ",", "conf_t", ")", "\n", "", "elif", "cfg", ".", "use_focal_loss_v2", ":", "\n", "                ", "losses", "[", "'C'", "]", "=", "self", ".", "focal_loss_v2", "(", "conf_data", ",", "conf_t", ")", "\n", "", "else", ":", "\n", "                ", "losses", "[", "'C'", "]", "=", "self", ".", "focal_conf_loss", "(", "conf_data", ",", "conf_t", ")", "\n", "", "", "else", ":", "\n", "            ", "losses", "[", "'C'", "]", "=", "self", ".", "ohem_conf_loss", "(", "conf_data", ",", "conf_t", ",", "pos", ",", "batch_size", ")", "\n", "\n", "# These losses also don't depend on anchors", "\n", "", "if", "cfg", ".", "use_class_existence_loss", ":", "\n", "            ", "losses", "[", "'E'", "]", "=", "self", ".", "class_existence_loss", "(", "predictions", "[", "'classes'", "]", ",", "class_existence_t", ")", "\n", "", "if", "cfg", ".", "use_semantic_segmentation_loss", ":", "\n", "            ", "if", "cfg", ".", "sem_lincomb", ":", "\n", "                ", "segm_loss", ",", "sem_masks", ",", "sem_mask_t", "=", "self", ".", "lincomb_semantic_segmentation_loss", "(", "predictions", "[", "'proto'", "]", ",", "predictions", "[", "'segm'", "]", ",", "masks_stuff", ")", "\n", "", "else", ":", "\n", "                ", "segm_loss", "=", "self", ".", "_semantic_segmentation_loss", "(", "predictions", "[", "'segm'", "]", ",", "masks_stuff", ")", "\n", "", "losses", "[", "'S'", "]", "=", "segm_loss", "\n", "\n", "", "if", "cfg", ".", "use_panoptic_head", ":", "\n", "# pos_gt_conf = [ torch.argmax(conf_data[i, pos_pan[i], :], dim=-1) for i in range(batch_size) ]", "\n", "            ", "pos_gt_conf", "=", "None", "\n", "losses", "[", "'PAN'", "]", "=", "self", ".", "panoptic_loss", "(", "pred_masks", ",", "mask_t", ",", "sem_masks", ",", "sem_mask_t", ",", "pos_gt_boxes", ",", "pos_gt_conf", ")", "\n", "# Divide all losses by the number of positives.", "\n", "# Don't do it for loss[P] because that doesn't depend on the anchors.", "\n", "", "total_num_pos", "=", "num_pos", ".", "data", ".", "sum", "(", ")", ".", "float", "(", ")", "\n", "for", "k", "in", "losses", ":", "\n", "            ", "if", "k", "not", "in", "(", "'P'", ",", "'E'", ",", "'S'", ",", "'PAN'", ")", ":", "\n", "                ", "losses", "[", "k", "]", "/=", "total_num_pos", "\n", "", "else", ":", "\n", "                ", "losses", "[", "k", "]", "/=", "batch_size", "\n", "# Loss Key:", "\n", "#  - B: Box Localization Loss", "\n", "#  - C: Class Confidence Loss", "\n", "#  - M: Mask Loss", "\n", "#  - P: Prototype Loss", "\n", "#  - D: Coefficient Diversity Loss", "\n", "#  - E: Class Existence Loss", "\n", "#  - S: Semantic Segmentation Loss", "\n", "#  - PAN: Panoptic Segmentation Loss", "\n", "", "", "return", "losses", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.GIoU_loss": [[276, 306], ["loc_data.size", "range", "[].view", "[].view", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "loss_giou.sum", "box_utils.decode", "box_utils.decode"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode"], ["", "def", "GIoU_loss", "(", "self", ",", "loc_data", ",", "loc_t", ",", "priors", ",", "pos_idx", ")", ":", "\n", "        ", "batch_size", "=", "loc_data", ".", "size", "(", "0", ")", "\n", "\n", "loss_b", "=", "0", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "pos_idx_i", "=", "pos_idx", "[", "i", "]", "\n", "box_p", "=", "decode", "(", "loc_data", "[", "i", "]", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "[", "pos_idx_i", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "box_t", "=", "decode", "(", "loc_t", "[", "i", "]", ",", "priors", ",", "cfg", ".", "use_yolo_regressors", ")", "[", "pos_idx_i", "]", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "\n", "I_max_xy", "=", "torch", ".", "min", "(", "box_p", "[", ":", ",", "2", ":", "]", ",", "box_t", "[", ":", ",", "2", ":", "]", ")", "\n", "I_min_xy", "=", "torch", ".", "max", "(", "box_p", "[", ":", ",", ":", "2", "]", ",", "box_t", "[", ":", ",", ":", "2", "]", ")", "\n", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "I_max_xy", "-", "I_min_xy", ")", ",", "min", "=", "0", ")", "\n", "inter", "=", "inter", "[", ":", ",", "0", "]", "*", "inter", "[", ":", ",", "1", "]", "\n", "\n", "area_p", "=", "(", "(", "box_p", "[", ":", ",", "2", "]", "-", "box_p", "[", ":", ",", "0", "]", ")", "*", "(", "box_p", "[", ":", ",", "3", "]", "-", "box_p", "[", ":", ",", "1", "]", ")", ")", "\n", "area_t", "=", "(", "(", "box_t", "[", ":", ",", "2", "]", "-", "box_t", "[", ":", ",", "0", "]", ")", "*", "(", "box_t", "[", ":", ",", "3", "]", "-", "box_t", "[", ":", ",", "1", "]", ")", ")", "\n", "union", "=", "area_p", "+", "area_t", "-", "inter", "\n", "\n", "C_max_xy", "=", "torch", ".", "max", "(", "box_p", "[", ":", ",", "2", ":", "]", ",", "box_t", "[", ":", ",", "2", ":", "]", ")", "\n", "C_min_xy", "=", "torch", ".", "min", "(", "box_p", "[", ":", ",", ":", "2", "]", ",", "box_t", "[", ":", ",", ":", "2", "]", ")", "\n", "area_c", "=", "torch", ".", "clamp", "(", "(", "C_max_xy", "-", "C_min_xy", ")", ",", "min", "=", "0", ")", "\n", "area_c", "=", "area_c", "[", ":", ",", "0", "]", "*", "area_c", "[", ":", ",", "1", "]", "\n", "\n", "iou", "=", "inter", "/", "(", "union", "+", "1e-10", ")", "\n", "giou", "=", "iou", "-", "(", "area_c", "-", "union", ")", "/", "(", "area_c", "+", "1e-10", ")", "\n", "loss_giou", "=", "1", "-", "giou", "\n", "\n", "loss_b", "+=", "loss_giou", ".", "sum", "(", ")", "\n", "", "return", "loss_b", "*", "cfg", ".", "bbox_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.class_existence_loss": [[273, 275], ["None"], "methods", ["None"], ["", "def", "class_existence_loss", "(", "self", ",", "class_data", ",", "class_existence_t", ")", ":", "\n", "        ", "return", "cfg", ".", "cl", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.panoptic_loss": [[307, 354], ["sem_masks.size", "multibox_loss.CrossEntropyLoss2d", "range", "pred_masks[].size", "CrossEntropyLoss2d.", "pred_masks[].permute().unsqueeze", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "sem_masks[].clone().unsqueeze", "[].reshape().unsqueeze", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "pred_masks[].permute", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "sem_masks[].unsqueeze", "sem_mask_t[].unsqueeze", "cur_mask_t.long", "sem_masks[].clone", "[].reshape", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["None"], ["", "def", "panoptic_loss", "(", "self", ",", "pred_masks", ",", "mask_t", ",", "sem_masks", ",", "sem_mask_t", ",", "pos_gt_boxes", ",", "pos_gt_conf", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "# sem_masks : (batch_size, stuff_classes, h, w)", "\n", "# sem_mask_t : (batch_size, h, w)", "\n", "# pred_masks : list of (h, w, num_instances)", "\n", "# mask_t : list of (num_instance, h, w)", "\n", "\n", "        ", "batch_size", ",", "n_all", ",", "mask_h", ",", "mask_w", "=", "sem_masks", ".", "size", "(", ")", "\n", "# n_stuff = n_all - cfg.num_classes + 1 # (stuff+thing class): _exclude things , but include background", "\n", "n_stuff", "=", "n_all", "-", "1", "# (stuff+other):exclude thing(other) class", "\n", "# things_to_stuff = cfg.dataset.things_to_stuff_map", "\n", "sem_mask_t", "[", "sem_mask_t", ">=", "n_stuff", "]", "=", "0", "#set all things pixel to zero", "\n", "citerion", "=", "CrossEntropyLoss2d", "(", "reduction", "=", "'sum'", ",", "ignore_index", "=", "0", ")", "\n", "\n", "loss_p", "=", "0", "\n", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "n_thing", "=", "pred_masks", "[", "idx", "]", ".", "size", "(", "-", "1", ")", "\n", "if", "n_thing", "!=", "0", ":", "\n", "                ", "cur_pred_mask", "=", "pred_masks", "[", "idx", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "cur_mask_t", "=", "mask_t", "[", "idx", "]", "# shpae: (n_thing , h , w)", "\n", "\n", "#unsample n_thing masks", "\n", "cur_pred_mask", "=", "F", ".", "interpolate", "(", "cur_pred_mask", ",", "(", "mask_h", ",", "mask_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", "\n", "\n", "\n", "\n", "# ====(stuff + other(thing) class)====", "\n", "sem_masks", "[", "idx", ",", "0", ",", ":", ",", ":", "]", "=", "sem_masks", "[", "idx", ",", "-", "1", ",", ":", ",", ":", "]", "-", "torch", ".", "max", "(", "cur_pred_mask", "[", "0", ",", ":", ",", ":", ",", ":", "]", ",", "dim", "=", "0", ")", "[", "0", "]", "# unknown prediction", "\n", "panoptic_logit", "=", "torch", ".", "cat", "(", "(", "sem_masks", "[", "idx", ",", ":", "n_stuff", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ",", "cur_pred_mask", "*", "cfg", ".", "panoptic_loss_k", ")", ",", "dim", "=", "1", ")", "\n", "\n", "#multiply each mask with its panoptic index", "\n", "thing_idx", "=", "(", "torch", ".", "arange", "(", "n_thing", ")", "+", "n_stuff", ")", ".", "float", "(", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "repeat", "(", "1", ",", "mask_h", "*", "mask_w", ")", ".", "reshape", "(", "-", "1", ",", "mask_h", ",", "mask_w", ")", "\n", "cur_mask_t", "=", "cur_mask_t", "*", "thing_idx", "\n", "\n", "\n", "panoptic_gt_logit", "=", "torch", ".", "cat", "(", "(", "sem_mask_t", "[", "idx", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ",", "cur_mask_t", ".", "long", "(", ")", ")", ",", "dim", "=", "0", ")", "\n", "panoptic_gt_logit", "=", "torch", ".", "max", "(", "panoptic_gt_logit", ",", "dim", "=", "0", ",", "keepdim", "=", "True", ")", "[", "0", "]", "#panoptic_logit:  (batch_size, n_stuff(include bg, exclude things)+ n_things, h , w)", "\n", "\n", "", "else", ":", "# handle if no matched positive masks", "\n", "# only train stuff classes", "\n", "                ", "panoptic_logit", "=", "sem_masks", "[", "idx", ",", ":", "n_stuff", ",", ":", ",", ":", "]", ".", "clone", "(", ")", ".", "unsqueeze", "(", "0", ")", "\n", "panoptic_gt_logit", "=", "sem_mask_t", "[", "idx", ",", ":", ",", ":", "]", "[", "sem_mask_t", "[", "idx", ",", ":", ",", ":", "]", "<", "n_stuff", "]", ".", "reshape", "(", "mask_h", ",", "mask_w", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "loss_p", "+=", "citerion", "(", "panoptic_logit", ",", "panoptic_gt_logit", ")", "#(batch_size, ch, w, h) , (batch_size, h, w)", "\n", "\n", "", "return", "loss_p", "/", "mask_h", "/", "mask_w", "*", "cfg", ".", "panoptic_segmentation_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss._semantic_segmentation_loss": [[355, 372], ["len", "mask_t[].size", "multibox_loss.CrossEntropyLoss2d", "range", "segment_data[].unsqueeze", "torch.interpolate", "torch.interpolate", "torch.interpolate", "CrossEntropyLoss2d.", "cur_mask_t.unsqueeze"], "methods", ["None"], ["", "def", "_semantic_segmentation_loss", "(", "self", ",", "segment_data", ",", "mask_t", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "# Note num_classes here is without the background class so cfg.num_classes-1", "\n", "#proto_dat : (batch_size, h , w, mask_dim)", "\n", "#mask_t : list of target mask(h, w)", "\n", "        ", "batch_size", "=", "len", "(", "mask_t", ")", "\n", "mask_h", ",", "mask_w", "=", "mask_t", "[", "0", "]", ".", "size", "(", ")", "\n", "loss_s", "=", "0", "\n", "citerion", "=", "CrossEntropyLoss2d", "(", "reduction", "=", "'sum'", ",", "ignore_index", "=", "0", ")", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "cur_seg", "=", "segment_data", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", "\n", "cur_mask_t", "=", "mask_t", "[", "idx", "]", "\n", "upsampled_mask", "=", "F", ".", "interpolate", "(", "cur_seg", ",", "(", "mask_h", ",", "mask_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", "\n", "loss_s", "+=", "citerion", "(", "upsampled_mask", ",", "cur_mask_t", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n", "\n", "", "return", "loss_s", "/", "mask_h", "/", "mask_w", "*", "cfg", ".", "semantic_segmentation_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_loss_v2": [[373, 388], ["conf_data[].unsqueeze().permute.size", "conf_t[].reshape.size", "conf_t[].reshape", "conf_data[].unsqueeze().permute", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "multibox_loss.FocalLoss2d", "FocalLoss2d.", "conf_data[].unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "focal_loss_v2", "(", "self", ",", "conf_data", ",", "conf_t", ",", "alpha", "=", "0.25", ")", ":", "\n", "# conf_t: [batch_size, num_priors]", "\n", "# conf_data:  [batch_size, num_priors, num_classes]", "\n", "        ", "n_cls", "=", "conf_data", ".", "size", "(", "-", "1", ")", "\n", "n_batch", "=", "conf_t", ".", "size", "(", "0", ")", "\n", "keep", "=", "conf_t", ">=", "0", "\n", "conf_t", "=", "conf_t", "[", "keep", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", "# [1 , keep_priors]", "\n", "conf_data", "=", "conf_data", "[", "keep", "]", ".", "unsqueeze", "(", "0", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "#  [1 , num_classes , keep_priors]", "\n", "\n", "loss_weight", "=", "torch", ".", "zeros", "(", "n_cls", ")", ".", "fill_", "(", "0.25", ")", "\n", "loss_weight", "[", "0", "]", "=", "1", "-", "alpha", "\n", "criterion", "=", "FocalLoss2d", "(", "reduction", "=", "'sum'", ",", "gamma", "=", "cfg", ".", "focal_loss_gamma", ",", "weight", "=", "loss_weight", ")", "\n", "loss", "=", "criterion", "(", "conf_data", ",", "conf_t", ")", "\n", "\n", "return", "cfg", ".", "conf_alpha", "*", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.lincomb_semantic_segmentation_loss": [[389, 414], ["proto_data.size", "mask_t[].size", "multibox_loss.CrossEntropyLoss2d", "range", "cur_seg_coef.reshape().mean.reshape().mean.reshape().mean", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "segment_data.permute().contiguous.permute().contiguous.permute().contiguous", "torch.interpolate", "torch.interpolate", "torch.interpolate", "CrossEntropyLoss2d.", "sem_masks.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "cur_seg_coef.reshape().mean.reshape().mean.reshape", "segment_data.permute().contiguous.permute().contiguous.unsqueeze", "mask_t[].unsqueeze", "cur_seg_coef.reshape().mean.reshape().mean.reshape", "segment_data.permute().contiguous.permute().contiguous.permute", "cur_seg_coef.reshape().mean.reshape().mean.size"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "lincomb_semantic_segmentation_loss", "(", "self", ",", "proto_data", ",", "segment_coef", ",", "mask_t", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "# Note num_classes here is without the background class so cfg.num_classes-1", "\n", "#proto_dat : (batch_size, h , w, mask_dim)", "\n", "#mask_t : list of target mask(h, w)", "\n", "#seg_coef : (batch_size, mask_dim * num_stuff_class+ num_things_class+ 1 , h, w)", "\n", "        ", "batch_size", ",", "proto_h", ",", "proto_w", ",", "mask_dim", "=", "proto_data", ".", "size", "(", ")", "\n", "mask_h", ",", "mask_w", "=", "mask_t", "[", "0", "]", ".", "size", "(", ")", "\n", "loss_s", "=", "0", "\n", "citerion", "=", "CrossEntropyLoss2d", "(", "reduction", "=", "'sum'", ",", "ignore_index", "=", "0", ")", "\n", "\n", "sem_masks", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "cur_seg_coef", "=", "segment_coef", "[", "idx", "]", "\n", "cur_seg_coef", "=", "cur_seg_coef", ".", "reshape", "(", "cur_seg_coef", ".", "size", "(", "0", ")", ",", "-", "1", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "cur_proto", "=", "proto_data", "[", "idx", ",", ":", ",", ":", ",", ":", "]", "\n", "segment_data", "=", "torch", ".", "matmul", "(", "cur_proto", ",", "cur_seg_coef", ".", "reshape", "(", "mask_dim", ",", "-", "1", ")", ")", "\n", "segment_data", "=", "segment_data", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "upsampled_mask", "=", "F", ".", "interpolate", "(", "segment_data", ".", "unsqueeze", "(", "0", ")", ",", "(", "mask_h", ",", "mask_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", "#(batch_size, ch, h, w)", "\n", "loss_s", "+=", "citerion", "(", "upsampled_mask", ",", "mask_t", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", ")", "#(batch_size, ch, w, h) , (batch_size, h, w)", "\n", "\n", "sem_masks", ".", "append", "(", "upsampled_mask", ")", "\n", "\n", "\n", "", "return", "loss_s", "/", "mask_h", "/", "mask_w", "*", "cfg", ".", "semantic_segmentation_alpha", ",", "torch", ".", "cat", "(", "sem_masks", ",", "dim", "=", "0", ")", ",", "torch", ".", "stack", "(", "mask_t", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.semantic_segmentation_loss": [[416, 438], ["segment_data.size", "range", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.binary_cross_entropy_with_logits", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "downsampled_masks.gt().float.gt().float.gt().float", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "range", "downsampled_masks.gt().float.gt().float.size", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.interpolate", "torch.interpolate", "torch.interpolate", "downsampled_masks.gt().float.gt().float.gt", "mask_t[].unsqueeze"], "methods", ["None"], ["", "def", "semantic_segmentation_loss", "(", "self", ",", "segment_data", ",", "mask_t", ",", "class_t", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "# Note num_classes here is without the background class so cfg.num_classes-1", "\n", "        ", "batch_size", ",", "num_classes", ",", "mask_h", ",", "mask_w", "=", "segment_data", ".", "size", "(", ")", "\n", "loss_s", "=", "0", "\n", "\n", "for", "idx", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "cur_segment", "=", "segment_data", "[", "idx", "]", "\n", "cur_class_t", "=", "class_t", "[", "idx", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "downsampled_masks", "=", "F", ".", "interpolate", "(", "mask_t", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", ",", "(", "mask_h", ",", "mask_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "downsampled_masks", "=", "downsampled_masks", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "\n", "# Construct Semantic Segmentation", "\n", "segment_t", "=", "torch", ".", "zeros_like", "(", "cur_segment", ",", "requires_grad", "=", "False", ")", "\n", "for", "obj_idx", "in", "range", "(", "downsampled_masks", ".", "size", "(", "0", ")", ")", ":", "\n", "                    ", "segment_t", "[", "cur_class_t", "[", "obj_idx", "]", "]", "=", "torch", ".", "max", "(", "segment_t", "[", "cur_class_t", "[", "obj_idx", "]", "]", ",", "downsampled_masks", "[", "obj_idx", "]", ")", "\n", "\n", "", "", "loss_s", "+=", "F", ".", "binary_cross_entropy_with_logits", "(", "cur_segment", ",", "segment_t", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "", "return", "loss_s", "/", "mask_h", "/", "mask_w", "*", "cfg", ".", "semantic_segmentation_alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.ohem_conf_loss": [[440, 477], ["conf_data.view", "torch.cross_entropy.view", "torch.cross_entropy.sort", "loss_idx.sort", "pos.long().sum", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "pos.unsqueeze().expand_as", "neg.unsqueeze().expand_as", "conf_data[].view", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.softmax", "torch.softmax", "torch.softmax", "batch_conf[].max", "torch.clamp.expand_as", "torch.clamp.expand_as", "torch.clamp.expand_as", "box_utils.log_sum_exp", "pos.long", "pos.unsqueeze", "neg.unsqueeze", "pos.size"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.log_sum_exp"], ["", "def", "ohem_conf_loss", "(", "self", ",", "conf_data", ",", "conf_t", ",", "pos", ",", "num", ")", ":", "\n", "# Compute max conf across batch for hard negative mining", "\n", "        ", "batch_conf", "=", "conf_data", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "if", "cfg", ".", "ohem_use_most_confident", ":", "\n", "# i.e. max(softmax) along classes > 0 ", "\n", "            ", "batch_conf", "=", "F", ".", "softmax", "(", "batch_conf", ",", "dim", "=", "1", ")", "\n", "loss_c", ",", "_", "=", "batch_conf", "[", ":", ",", "1", ":", "]", ".", "max", "(", "dim", "=", "1", ")", "\n", "", "else", ":", "\n", "# i.e. -softmax(class 0 confidence)", "\n", "            ", "loss_c", "=", "log_sum_exp", "(", "batch_conf", ")", "-", "batch_conf", "[", ":", ",", "0", "]", "\n", "\n", "# Hard Negative Mining", "\n", "", "loss_c", "=", "loss_c", ".", "view", "(", "num", ",", "-", "1", ")", "\n", "loss_c", "[", "pos", "]", "=", "0", "# filter out pos boxes", "\n", "loss_c", "[", "conf_t", "<", "0", "]", "=", "0", "# filter out neutrals (conf_t = -1)", "\n", "_", ",", "loss_idx", "=", "loss_c", ".", "sort", "(", "1", ",", "descending", "=", "True", ")", "\n", "_", ",", "idx_rank", "=", "loss_idx", ".", "sort", "(", "1", ")", "\n", "num_pos", "=", "pos", ".", "long", "(", ")", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "num_neg", "=", "torch", ".", "clamp", "(", "self", ".", "negpos_ratio", "*", "num_pos", ",", "max", "=", "pos", ".", "size", "(", "1", ")", "-", "1", ")", "\n", "neg", "=", "idx_rank", "<", "num_neg", ".", "expand_as", "(", "idx_rank", ")", "\n", "\n", "# Just in case there aren't enough negatives, don't start using positives as negatives", "\n", "neg", "[", "pos", "]", "=", "0", "\n", "neg", "[", "conf_t", "<", "0", "]", "=", "0", "# Filter out neutrals", "\n", "\n", "# Confidence Loss Including Positive and Negative Examples", "\n", "pos_idx", "=", "pos", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "conf_data", ")", "\n", "neg_idx", "=", "neg", ".", "unsqueeze", "(", "2", ")", ".", "expand_as", "(", "conf_data", ")", "\n", "conf_p", "=", "conf_data", "[", "(", "pos_idx", "+", "neg_idx", ")", ".", "gt", "(", "0", ")", "]", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "targets_weighted", "=", "conf_t", "[", "(", "pos", "+", "neg", ")", ".", "gt", "(", "0", ")", "]", "\n", "\n", "\n", "loss_c", "=", "F", ".", "cross_entropy", "(", "conf_p", ",", "targets_weighted", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "\n", "return", "cfg", ".", "conf_alpha", "*", "loss_c", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_conf_loss": [[478, 507], ["conf_t.view.view.view", "conf_data.view.view.view", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "logpt.view.view.gather", "logpt.view.view.view", "logpt.view.view.exp", "conf_data.view.view.size", "conf_t.view.view.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.None.panoptic_eval.CustomDataParallel.gather"], ["", "def", "focal_conf_loss", "(", "self", ",", "conf_data", ",", "conf_t", ")", ":", "\n", "        ", "\"\"\"\n        Focal loss as described in https://arxiv.org/pdf/1708.02002.pdf\n        Adapted from https://github.com/clcarwin/focal_loss_pytorch/blob/master/focalloss.py\n        Note that this uses softmax and not the original sigmoid from the paper.\n        \"\"\"", "\n", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "# [batch_size*num_priors]", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "conf_data", ".", "size", "(", "-", "1", ")", ")", "# [batch_size*num_priors, num_classes]", "\n", "\n", "# Ignore neutral samples (class < 0)", "\n", "keep", "=", "(", "conf_t", ">=", "0", ")", ".", "float", "(", ")", "\n", "conf_t", "[", "conf_t", "<", "0", "]", "=", "0", "# so that gather doesn't drum up a fuss", "\n", "\n", "logpt", "=", "F", ".", "log_softmax", "(", "conf_data", ",", "dim", "=", "-", "1", ")", "\n", "logpt", "=", "logpt", ".", "gather", "(", "1", ",", "conf_t", ".", "unsqueeze", "(", "-", "1", ")", ")", "\n", "logpt", "=", "logpt", ".", "view", "(", "-", "1", ")", "\n", "pt", "=", "logpt", ".", "exp", "(", ")", "\n", "\n", "# I adapted the alpha_t calculation here from", "\n", "# https://github.com/pytorch/pytorch/blob/master/modules/detectron/softmax_focal_loss_op.cu", "\n", "# You'd think you want all the alphas to sum to one, but in the original implementation they", "\n", "# just give background an alpha of 1-alpha and each forground an alpha of alpha.", "\n", "background", "=", "(", "conf_t", "==", "0", ")", ".", "float", "(", ")", "\n", "at", "=", "(", "1", "-", "cfg", ".", "focal_loss_alpha", ")", "*", "background", "+", "cfg", ".", "focal_loss_alpha", "*", "(", "1", "-", "background", ")", "\n", "\n", "loss", "=", "-", "at", "*", "(", "1", "-", "pt", ")", "**", "cfg", ".", "focal_loss_gamma", "*", "logpt", "\n", "\n", "# See comment above for keep", "\n", "return", "cfg", ".", "conf_alpha", "*", "(", "loss", "*", "keep", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_conf_sigmoid_loss": [[508, 538], ["conf_data.view.view.size", "conf_t.view.view.view", "conf_data.view.view.view", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid.exp", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "loss.sum", "loss.sum", "conf_t.view.view.get_device"], "methods", ["None"], ["", "def", "focal_conf_sigmoid_loss", "(", "self", ",", "conf_data", ",", "conf_t", ")", ":", "\n", "        ", "\"\"\"\n        Focal loss but using sigmoid like the original paper.\n        Note: To make things mesh easier, the network still predicts 81 class confidences in this mode.\n              Because retinanet originally only predicts 80, we simply just don't use conf_data[..., 0]\n        \"\"\"", "\n", "num_classes", "=", "conf_data", ".", "size", "(", "-", "1", ")", "\n", "\n", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "# [batch_size*num_priors]", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "num_classes", ")", "# [batch_size*num_priors, num_classes]", "\n", "\n", "# Ignore neutral samples (class < 0)", "\n", "keep", "=", "(", "conf_t", ">=", "0", ")", ".", "float", "(", ")", "\n", "conf_t", "[", "conf_t", "<", "0", "]", "=", "0", "# can't mask with -1, so filter that out", "\n", "\n", "# Compute a one-hot embedding of conf_t", "\n", "# From https://github.com/kuangliu/pytorch-retinanet/blob/master/utils.py", "\n", "conf_one_t", "=", "torch", ".", "eye", "(", "num_classes", ",", "device", "=", "conf_t", ".", "get_device", "(", ")", ")", "[", "conf_t", "]", "\n", "conf_pm_t", "=", "conf_one_t", "*", "2", "-", "1", "# -1 if background, +1 if forground for specific class", "\n", "\n", "logpt", "=", "F", ".", "logsigmoid", "(", "conf_data", "*", "conf_pm_t", ")", "# note: 1 - sigmoid(x) = sigmoid(-x)", "\n", "pt", "=", "logpt", ".", "exp", "(", ")", "\n", "\n", "at", "=", "cfg", ".", "focal_loss_alpha", "*", "conf_one_t", "+", "(", "1", "-", "cfg", ".", "focal_loss_alpha", ")", "*", "(", "1", "-", "conf_one_t", ")", "\n", "at", "[", "...", ",", "0", "]", "=", "0", "# Set alpha for the background class to 0 because sigmoid focal loss doesn't use it", "\n", "\n", "loss", "=", "-", "at", "*", "(", "1", "-", "pt", ")", "**", "cfg", ".", "focal_loss_gamma", "*", "logpt", "\n", "loss", "=", "keep", "*", "loss", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "return", "cfg", ".", "conf_alpha", "*", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.focal_conf_objectness_loss": [[539, 571], ["conf_t.view.view.view", "conf_data.view.view.view", "logpt.exp", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "conf_data.view.view.size", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid", "torch.logsigmoid"], "methods", ["None"], ["", "def", "focal_conf_objectness_loss", "(", "self", ",", "conf_data", ",", "conf_t", ")", ":", "\n", "        ", "\"\"\"\n        Instead of using softmax, use class[0] to be the objectness score and do sigmoid focal loss on that.\n        Then for the rest of the classes, softmax them and apply CE for only the positive examples.\n\n        If class[0] = 1 implies forground and class[0] = 0 implies background then you achieve something\n        similar during test-time to softmax by setting class[1:] = softmax(class[1:]) * class[0] and invert class[0].\n        \"\"\"", "\n", "\n", "conf_t", "=", "conf_t", ".", "view", "(", "-", "1", ")", "# [batch_size*num_priors]", "\n", "conf_data", "=", "conf_data", ".", "view", "(", "-", "1", ",", "conf_data", ".", "size", "(", "-", "1", ")", ")", "# [batch_size*num_priors, num_classes]", "\n", "\n", "# Ignore neutral samples (class < 0)", "\n", "keep", "=", "(", "conf_t", ">=", "0", ")", ".", "float", "(", ")", "\n", "conf_t", "[", "conf_t", "<", "0", "]", "=", "0", "# so that gather doesn't drum up a fuss", "\n", "\n", "background", "=", "(", "conf_t", "==", "0", ")", ".", "float", "(", ")", "\n", "at", "=", "(", "1", "-", "cfg", ".", "focal_loss_alpha", ")", "*", "background", "+", "cfg", ".", "focal_loss_alpha", "*", "(", "1", "-", "background", ")", "\n", "\n", "logpt", "=", "F", ".", "logsigmoid", "(", "conf_data", "[", ":", ",", "0", "]", ")", "*", "(", "1", "-", "background", ")", "+", "F", ".", "logsigmoid", "(", "-", "conf_data", "[", ":", ",", "0", "]", ")", "*", "background", "\n", "pt", "=", "logpt", ".", "exp", "(", ")", "\n", "\n", "obj_loss", "=", "-", "at", "*", "(", "1", "-", "pt", ")", "**", "cfg", ".", "focal_loss_gamma", "*", "logpt", "\n", "\n", "# All that was the objectiveness loss--now time for the class confidence loss", "\n", "pos_mask", "=", "conf_t", ">", "0", "\n", "conf_data_pos", "=", "(", "conf_data", "[", ":", ",", "1", ":", "]", ")", "[", "pos_mask", "]", "# Now this has just 80 classes", "\n", "conf_t_pos", "=", "conf_t", "[", "pos_mask", "]", "-", "1", "# So subtract 1 here", "\n", "\n", "class_loss", "=", "F", ".", "cross_entropy", "(", "conf_data_pos", ",", "conf_t_pos", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "return", "cfg", ".", "conf_alpha", "*", "(", "class_loss", "+", "(", "obj_loss", "*", "keep", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.direct_mask_loss": [[573, 615], ["range", "mask_data.size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "box_utils.decode", "pos_bboxes[].view().clamp", "pos_masks.size", "sanitize_coordinates", "sanitize_coordinates", "range", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.cat().gt().float", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "torch.adaptive_avg_pool2d", "scaled_masks.append", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "pos_bboxes[].view", "tmp_mask.unsqueeze.unsqueeze.dim", "tmp_mask.unsqueeze.unsqueeze.unsqueeze", "tmp_mask.unsqueeze.unsqueeze.unsqueeze", "torch.adaptive_avg_pool2d.view", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat().gt", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.decode", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.sanitize_coordinates", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "direct_mask_loss", "(", "self", ",", "pos_idx", ",", "idx_t", ",", "loc_data", ",", "mask_data", ",", "priors", ",", "masks", ")", ":", "\n", "        ", "\"\"\" Crops the gt masks using the predicted bboxes, scales them down, and outputs the BCE loss. \"\"\"", "\n", "loss_m", "=", "0", "\n", "for", "idx", "in", "range", "(", "mask_data", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "cur_pos_idx", "=", "pos_idx", "[", "idx", ",", ":", ",", ":", "]", "\n", "cur_pos_idx_squeezed", "=", "cur_pos_idx", "[", ":", ",", "1", "]", "\n", "\n", "# Shape: [num_priors, 4], decoded predicted bboxes", "\n", "pos_bboxes", "=", "decode", "(", "loc_data", "[", "idx", ",", ":", ",", ":", "]", ",", "priors", ".", "data", ",", "cfg", ".", "use_yolo_regressors", ")", "\n", "pos_bboxes", "=", "pos_bboxes", "[", "cur_pos_idx", "]", ".", "view", "(", "-", "1", ",", "4", ")", ".", "clamp", "(", "0", ",", "1", ")", "\n", "pos_lookup", "=", "idx_t", "[", "idx", ",", "cur_pos_idx_squeezed", "]", "\n", "\n", "cur_masks", "=", "masks", "[", "idx", "]", "\n", "pos_masks", "=", "cur_masks", "[", "pos_lookup", ",", ":", ",", ":", "]", "\n", "\n", "# Convert bboxes to absolute coordinates", "\n", "num_pos", ",", "img_height", ",", "img_width", "=", "pos_masks", ".", "size", "(", ")", "\n", "\n", "# Take care of all the bad behavior that can be caused by out of bounds coordinates", "\n", "x1", ",", "x2", "=", "sanitize_coordinates", "(", "pos_bboxes", "[", ":", ",", "0", "]", ",", "pos_bboxes", "[", ":", ",", "2", "]", ",", "img_width", ")", "\n", "y1", ",", "y2", "=", "sanitize_coordinates", "(", "pos_bboxes", "[", ":", ",", "1", "]", ",", "pos_bboxes", "[", ":", ",", "3", "]", ",", "img_height", ")", "\n", "\n", "# Crop each gt mask with the predicted bbox and rescale to the predicted mask size", "\n", "# Note that each bounding box crop is a different size so I don't think we can vectorize this", "\n", "scaled_masks", "=", "[", "]", "\n", "for", "jdx", "in", "range", "(", "num_pos", ")", ":", "\n", "                    ", "tmp_mask", "=", "pos_masks", "[", "jdx", ",", "y1", "[", "jdx", "]", ":", "y2", "[", "jdx", "]", ",", "x1", "[", "jdx", "]", ":", "x2", "[", "jdx", "]", "]", "\n", "\n", "# Restore any dimensions we've left out because our bbox was 1px wide", "\n", "while", "tmp_mask", ".", "dim", "(", ")", "<", "2", ":", "\n", "                        ", "tmp_mask", "=", "tmp_mask", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "new_mask", "=", "F", ".", "adaptive_avg_pool2d", "(", "tmp_mask", ".", "unsqueeze", "(", "0", ")", ",", "cfg", ".", "mask_size", ")", "\n", "scaled_masks", ".", "append", "(", "new_mask", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "mask_t", "=", "torch", ".", "cat", "(", "scaled_masks", ",", "0", ")", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "# Threshold downsampled mask", "\n", "\n", "", "pos_mask_data", "=", "mask_data", "[", "idx", ",", "cur_pos_idx_squeezed", ",", ":", "]", "\n", "loss_m", "+=", "F", ".", "binary_cross_entropy", "(", "torch", ".", "clamp", "(", "pos_mask_data", ",", "0", ",", "1", ")", ",", "mask_t", ",", "reduction", "=", "'sum'", ")", "*", "cfg", ".", "mask_alpha", "\n", "\n", "", "return", "loss_m", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.coeff_diversity_loss": [[617, 639], ["coeffs.size", "instance_t.view.view.view", "torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize.t", "loss.sum", "instance_t[].expand_as", "instance_t[].expand_as"], "methods", ["None"], ["", "def", "coeff_diversity_loss", "(", "self", ",", "coeffs", ",", "instance_t", ")", ":", "\n", "        ", "\"\"\"\n        coeffs     should be size [num_pos, num_coeffs]\n        instance_t should be size [num_pos] and be values from 0 to num_instances-1\n        \"\"\"", "\n", "num_pos", "=", "coeffs", ".", "size", "(", "0", ")", "\n", "instance_t", "=", "instance_t", ".", "view", "(", "-", "1", ")", "# juuuust to make sure", "\n", "\n", "coeffs_norm", "=", "F", ".", "normalize", "(", "coeffs", ",", "dim", "=", "1", ")", "\n", "cos_sim", "=", "coeffs_norm", "@", "coeffs_norm", ".", "t", "(", ")", "\n", "\n", "inst_eq", "=", "(", "instance_t", "[", ":", ",", "None", "]", ".", "expand_as", "(", "cos_sim", ")", "==", "instance_t", "[", "None", ",", ":", "]", ".", "expand_as", "(", "cos_sim", ")", ")", ".", "float", "(", ")", "\n", "\n", "# Rescale to be between 0 and 1", "\n", "cos_sim", "=", "(", "cos_sim", "+", "1", ")", "/", "2", "\n", "\n", "# If they're the same instance, use cosine distance, else use cosine similarity", "\n", "loss", "=", "(", "1", "-", "cos_sim", ")", "*", "inst_eq", "+", "cos_sim", "*", "(", "1", "-", "inst_eq", ")", "\n", "\n", "# Only divide by num_pos once because we're summing over a num_pos x num_pos tensor", "\n", "# and all the losses will be divided by num_pos at the end, so just one extra time.", "\n", "return", "cfg", ".", "mask_proto_coeff_diversity_alpha", "*", "loss", ".", "sum", "(", ")", "/", "num_pos", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.lincomb_mask_loss": [[641, 800], ["proto_data.size", "proto_data.size", "range", "pos.clone.clone.clone", "mask_data.size", "proto_coef.size", "proto_coef.size", "data.cfg.mask_proto_mask_activation", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "torch.interpolate().squeeze", "downsampled_masks.gt().float.gt().float.permute().contiguous", "pos_idx_t.size", "multibox_loss.MultiBoxLoss.coeff_diversity_loss", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "proto_coef.t", "box_utils.crop", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "box_utils.center_size", "downsampled_masks.gt().float.gt().float.gt().float", "range", "proto_coef.size", "pos_pan[].sum", "box_utils.crop", "pred_masks_list.append", "pos_gt_box_list.append", "mask_t_list.append", "pred_masks_list.append", "pos_gt_box_list.append", "mask_t_list.append", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.interpolate", "torch.interpolate", "torch.interpolate", "downsampled_masks.gt().float.gt().float.permute", "downsampled_masks.gt().float.gt().float.sum", "very_small_masks.size", "downsampled_masks.gt().float.gt().float.gt().float", "proto_coef_pan.t", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "masks[].unsqueeze", "downsampled_masks.gt().float.gt().float.gt", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.binary_cross_entropy.sum", "downsampled_masks.gt().float.gt().float.gt"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.MultiBoxLoss.coeff_diversity_loss", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.crop", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.center_size", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.crop", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], ["", "def", "lincomb_mask_loss", "(", "self", ",", "pos", ",", "pos_pan", ",", "idx_t", ",", "idx_t_pan", ",", "loc_data", ",", "mask_data", ",", "priors", ",", "proto_data", ",", "masks", ",", "gt_box_t", ",", "gt_box_t_pan", ",", "inst_data", ",", "interpolation_mode", "=", "'bilinear'", ")", ":", "\n", "        ", "mask_h", "=", "proto_data", ".", "size", "(", "1", ")", "\n", "mask_w", "=", "proto_data", ".", "size", "(", "2", ")", "\n", "\n", "process_gt_bboxes", "=", "cfg", ".", "mask_proto_normalize_emulate_roi_pooling", "or", "cfg", ".", "mask_proto_crop", "#Default: mask_proto_crop = ture", "\n", "\n", "if", "cfg", ".", "mask_proto_remove_empty_masks", ":", "\n", "# Make sure to store a copy of this because we edit it to get rid of all-zero masks", "\n", "            ", "pos", "=", "pos", ".", "clone", "(", ")", "\n", "\n", "", "loss_m", "=", "0", "\n", "loss_d", "=", "0", "# Coefficient diversity loss", "\n", "\n", "pred_masks_list", "=", "[", "]", "\n", "pos_gt_box_list", "=", "[", "]", "\n", "mask_t_list", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "mask_data", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "downsampled_masks", "=", "F", ".", "interpolate", "(", "masks", "[", "idx", "]", ".", "unsqueeze", "(", "0", ")", ",", "(", "mask_h", ",", "mask_w", ")", ",", "\n", "mode", "=", "interpolation_mode", ",", "align_corners", "=", "False", ")", ".", "squeeze", "(", "0", ")", "\n", "downsampled_masks", "=", "downsampled_masks", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "contiguous", "(", ")", "\n", "\n", "if", "cfg", ".", "mask_proto_binarize_downsampled_gt", ":", "# Default: True", "\n", "                    ", "downsampled_masks", "=", "downsampled_masks", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "\n", "", "if", "cfg", ".", "mask_proto_remove_empty_masks", ":", "# Default: False", "\n", "# Get rid of gt masks that are so small they get downsampled away", "\n", "                    ", "very_small_masks", "=", "(", "downsampled_masks", ".", "sum", "(", "dim", "=", "(", "0", ",", "1", ")", ")", "<=", "0.0001", ")", "\n", "for", "i", "in", "range", "(", "very_small_masks", ".", "size", "(", "0", ")", ")", ":", "\n", "                        ", "if", "very_small_masks", "[", "i", "]", ":", "\n", "                            ", "pos", "[", "idx", ",", "idx_t", "[", "idx", "]", "==", "i", "]", "=", "0", "\n", "\n", "", "", "", "if", "cfg", ".", "mask_proto_reweight_mask_loss", ":", "# Default: False", "\n", "# Ensure that the gt is binary", "\n", "                    ", "if", "not", "cfg", ".", "mask_proto_binarize_downsampled_gt", ":", "\n", "                        ", "bin_gt", "=", "downsampled_masks", ".", "gt", "(", "0.5", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "                        ", "bin_gt", "=", "downsampled_masks", "\n", "\n", "", "gt_foreground_norm", "=", "bin_gt", "/", "(", "torch", ".", "sum", "(", "bin_gt", ",", "dim", "=", "(", "0", ",", "1", ")", ",", "keepdim", "=", "True", ")", "+", "0.0001", ")", "\n", "gt_background_norm", "=", "(", "1", "-", "bin_gt", ")", "/", "(", "torch", ".", "sum", "(", "1", "-", "bin_gt", ",", "dim", "=", "(", "0", ",", "1", ")", ",", "keepdim", "=", "True", ")", "+", "0.0001", ")", "\n", "\n", "mask_reweighting", "=", "gt_foreground_norm", "*", "cfg", ".", "mask_proto_reweight_coeff", "+", "gt_background_norm", "\n", "mask_reweighting", "*=", "mask_h", "*", "mask_w", "\n", "\n", "", "", "cur_pos", "=", "pos", "[", "idx", "]", "\n", "pos_idx_t", "=", "idx_t", "[", "idx", ",", "cur_pos", "]", "\n", "\n", "\n", "if", "process_gt_bboxes", ":", "\n", "# Note: this is in point-form", "\n", "                ", "pos_gt_box_t", "=", "gt_box_t", "[", "idx", ",", "cur_pos", "]", "\n", "", "if", "pos_idx_t", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "proto_masks", "=", "proto_data", "[", "idx", "]", "\n", "proto_coef", "=", "mask_data", "[", "idx", ",", "cur_pos", ",", ":", "]", "\n", "\n", "if", "cfg", ".", "mask_proto_coeff_diversity_loss", ":", "# Default: False", "\n", "                ", "if", "inst_data", "is", "not", "None", ":", "\n", "                    ", "div_coeffs", "=", "inst_data", "[", "idx", ",", "cur_pos", ",", ":", "]", "\n", "", "else", ":", "\n", "                    ", "div_coeffs", "=", "proto_coef", "\n", "\n", "", "loss_d", "+=", "self", ".", "coeff_diversity_loss", "(", "div_coeffs", ",", "pos_idx_t", ")", "\n", "\n", "# If we have over the allowed number of masks, select a random sample", "\n", "", "old_num_pos", "=", "proto_coef", ".", "size", "(", "0", ")", "\n", "if", "old_num_pos", ">", "cfg", ".", "masks_to_train", ":", "\n", "                ", "perm", "=", "torch", ".", "randperm", "(", "proto_coef", ".", "size", "(", "0", ")", ")", "\n", "select", "=", "perm", "[", ":", "cfg", ".", "masks_to_train", "]", "\n", "\n", "proto_coef", "=", "proto_coef", "[", "select", ",", ":", "]", "\n", "pos_idx_t", "=", "pos_idx_t", "[", "select", "]", "\n", "\n", "if", "process_gt_bboxes", ":", "\n", "                    ", "pos_gt_box_t", "=", "pos_gt_box_t", "[", "select", ",", ":", "]", "\n", "\n", "", "", "num_pos", "=", "proto_coef", ".", "size", "(", "0", ")", "\n", "mask_t", "=", "downsampled_masks", "[", ":", ",", ":", ",", "pos_idx_t", "]", "\n", "\n", "# Size: [mask_h, mask_w, num_pos]", "\n", "pred_masks", "=", "proto_masks", "@", "proto_coef", ".", "t", "(", ")", "\n", "pred_masks", "=", "cfg", ".", "mask_proto_mask_activation", "(", "pred_masks", ")", "\n", "\n", "\n", "#-----Preparing for panoptic loss ----", "\n", "if", "cfg", ".", "use_panoptic_head", ":", "\n", "                ", "if", "pos_pan", "[", "idx", "]", ".", "sum", "(", ")", ">", "0", ":", "\n", "                    ", "cur_pos_pan", "=", "pos_pan", "[", "idx", "]", "\n", "pos_idx_t_pan", "=", "idx_t_pan", "[", "idx", ",", "cur_pos_pan", "]", "\n", "proto_coef_pan", "=", "mask_data", "[", "idx", ",", "cur_pos_pan", ",", ":", "]", "\n", "pred_masks_pan", "=", "proto_masks", "@", "proto_coef_pan", ".", "t", "(", ")", "\n", "# pred_masks_pan = cfg.mask_proto_mask_activation(pred_masks_pan)", "\n", "pred_masks_pan", "=", "crop", "(", "pred_masks_pan", ",", "gt_box_t_pan", "[", "idx", ",", "cur_pos_pan", "]", ")", "\n", "\n", "pred_masks_list", ".", "append", "(", "pred_masks_pan", ")", "\n", "pos_gt_box_list", ".", "append", "(", "gt_box_t_pan", "[", "idx", ",", "cur_pos_pan", "]", ")", "\n", "mask_t_list", ".", "append", "(", "masks", "[", "idx", "]", "[", "pos_idx_t_pan", ",", ":", ",", ":", "]", ")", "\n", "", "else", ":", "\n", "                    ", "pred_masks_list", ".", "append", "(", "torch", ".", "zeros", "(", "(", "0", ")", ")", ")", "\n", "pos_gt_box_list", ".", "append", "(", "torch", ".", "zeros", "(", "(", "0", ")", ")", ")", "\n", "mask_t_list", ".", "append", "(", "torch", ".", "zeros", "(", "(", "0", ")", ")", ")", "\n", "#--------------------------------------", "\n", "\n", "", "", "if", "cfg", ".", "mask_proto_double_loss", ":", "# Default: False", "\n", "                ", "if", "cfg", ".", "mask_proto_mask_activation", "==", "activation_func", ".", "sigmoid", ":", "\n", "                    ", "pre_loss", "=", "F", ".", "binary_cross_entropy", "(", "torch", ".", "clamp", "(", "pred_masks", ",", "0", ",", "1", ")", ",", "mask_t", ",", "reduction", "=", "'sum'", ")", "\n", "", "else", ":", "\n", "                    ", "pre_loss", "=", "F", ".", "smooth_l1_loss", "(", "pred_masks", ",", "mask_t", ",", "reduction", "=", "'sum'", ")", "\n", "\n", "", "loss_m", "+=", "cfg", ".", "mask_proto_double_loss_alpha", "*", "pre_loss", "\n", "\n", "", "if", "cfg", ".", "mask_proto_crop", ":", "# Default: True", "\n", "                ", "pred_masks", "=", "crop", "(", "pred_masks", ",", "pos_gt_box_t", ")", "\n", "\n", "", "if", "cfg", ".", "mask_proto_mask_activation", "==", "activation_func", ".", "sigmoid", ":", "#Default : Sigmoid", "\n", "                ", "if", "cfg", ".", "mask_dice_loss", ":", "\n", "\n", "                    ", "inter", "=", "(", "pred_masks", "*", "mask_t", ")", ".", "sum", "(", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "area_p", "=", "(", "pred_masks", "**", "2", ")", ".", "sum", "(", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "area_t", "=", "(", "mask_t", "**", "2", ")", ".", "sum", "(", "dim", "=", "(", "0", ",", "1", ")", ")", "\n", "dice", "=", "2", "*", "inter", "/", "(", "area_p", "+", "area_t", "+", "1e-10", ")", "\n", "pre_loss", "=", "1", "-", "dice", "\n", "", "else", ":", "\n", "                    ", "pre_loss", "=", "F", ".", "binary_cross_entropy", "(", "torch", ".", "clamp", "(", "pred_masks", ",", "0", ",", "1", ")", ",", "mask_t", ",", "reduction", "=", "'none'", ")", "\n", "", "", "else", ":", "\n", "                ", "pre_loss", "=", "F", ".", "smooth_l1_loss", "(", "pred_masks", ",", "mask_t", ",", "reduction", "=", "'none'", ")", "\n", "\n", "", "if", "cfg", ".", "mask_proto_normalize_mask_loss_by_sqrt_area", ":", "# Default: False", "\n", "                ", "gt_area", "=", "torch", ".", "sum", "(", "mask_t", ",", "dim", "=", "(", "0", ",", "1", ")", ",", "keepdim", "=", "True", ")", "\n", "pre_loss", "=", "pre_loss", "/", "(", "torch", ".", "sqrt", "(", "gt_area", ")", "+", "0.0001", ")", "\n", "\n", "", "if", "cfg", ".", "mask_proto_reweight_mask_loss", ":", "# Default: False", "\n", "                ", "pre_loss", "=", "pre_loss", "*", "mask_reweighting", "[", ":", ",", ":", ",", "pos_idx_t", "]", "\n", "\n", "", "if", "cfg", ".", "mask_proto_normalize_emulate_roi_pooling", ":", "# Default: False", "\n", "                ", "weight", "=", "mask_h", "*", "mask_w", "if", "cfg", ".", "mask_proto_crop", "else", "1", "\n", "pos_get_csize", "=", "center_size", "(", "pos_gt_box_t", ")", "\n", "gt_box_width", "=", "pos_get_csize", "[", ":", ",", "2", "]", "*", "mask_w", "\n", "gt_box_height", "=", "pos_get_csize", "[", ":", ",", "3", "]", "*", "mask_h", "\n", "pre_loss", "=", "pre_loss", ".", "sum", "(", "dim", "=", "(", "0", ",", "1", ")", ")", "/", "gt_box_width", "/", "gt_box_height", "*", "weight", "\n", "\n", "\n", "# If the number of masks were limited scale the loss accordingly", "\n", "", "if", "old_num_pos", ">", "num_pos", ":", "\n", "                ", "pre_loss", "*=", "old_num_pos", "/", "num_pos", "\n", "\n", "", "loss_m", "+=", "torch", ".", "sum", "(", "pre_loss", ")", "\n", "\n", "", "if", "cfg", ".", "mask_dice_loss", ":", "\n", "            ", "losses", "=", "{", "'M'", ":", "loss_m", "*", "cfg", ".", "mask_alpha", "}", "\n", "", "else", ":", "\n", "            ", "losses", "=", "{", "'M'", ":", "loss_m", "*", "cfg", ".", "mask_alpha", "/", "mask_h", "/", "mask_w", "}", "# mask_alpha default: 6.125", "\n", "\n", "", "if", "cfg", ".", "mask_proto_coeff_diversity_loss", ":", "# Default: False", "\n", "            ", "losses", "[", "'D'", "]", "=", "loss_d", "\n", "\n", "", "return", "losses", ",", "pred_masks_list", ",", "mask_t_list", ",", "pos_gt_box_list", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.CrossEntropyLoss2d.__init__": [[802, 805], ["torch.Module.__init__", "torch.NLLLoss", "torch.NLLLoss", "torch.NLLLoss"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["    ", "def", "__init__", "(", "self", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ",", "ignore_index", "=", "None", ")", ":", "\n", "        ", "super", "(", "CrossEntropyLoss2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nll_loss", "=", "nn", ".", "NLLLoss", "(", "weight", ",", "reduction", "=", "reduction", ",", "ignore_index", "=", "ignore_index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.CrossEntropyLoss2d.forward": [[806, 808], ["multibox_loss.CrossEntropyLoss2d.nll_loss", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "return", "self", ".", "nll_loss", "(", "F", ".", "log_softmax", "(", "inputs", ",", "dim", "=", "1", ")", ",", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.FocalLoss2d.__init__": [[810, 814], ["torch.Module.__init__", "torch.NLLLoss", "torch.NLLLoss", "torch.NLLLoss"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", "=", "2.", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ")", ":", "\n", "        ", "super", "(", "FocalLoss2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "nll_loss", "=", "nn", ".", "NLLLoss", "(", "weight", ",", "reduction", "=", "reduction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.modules.multibox_loss.FocalLoss2d.forward": [[815, 818], ["multibox_loss.FocalLoss2d.nll_loss", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ",", "targets", ")", ":", "\n", "        ", "eps", "=", "1e-10", "\n", "return", "self", ".", "nll_loss", "(", "(", "1", "-", "F", ".", "softmax", "(", "inputs", "+", "eps", ",", "dim", "=", "1", ")", ")", "**", "self", ".", "gamma", "*", "F", ".", "log_softmax", "(", "inputs", "+", "eps", ",", "dim", "=", "1", ")", ",", "targets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss_pan.smoother": [[32, 40], ["utils.functions.MovingAverage", "range", "len", "utils.functions.MovingAverage.append", "utils.functions.MovingAverage.get_avg"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg"], ["", "", "", "def", "smoother", "(", "y", ",", "interval", "=", "100", ")", ":", "\n", "\t", "avg", "=", "MovingAverage", "(", "interval", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "y", ")", ")", ":", "\n", "\t\t", "avg", ".", "append", "(", "y", "[", "i", "]", ")", "\n", "y", "[", "i", "]", "=", "avg", ".", "get_avg", "(", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss_pan.plot_train": [[41, 62], ["matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.show", "plot_loss_pan.smoother", "plot_loss_pan.smoother", "plot_loss_pan.smoother", "matplotlib.plot", "loss_names.append", "matplotlib.plot", "loss_names.append", "os.path.basesname", "plot_loss_pan.smoother", "plot_loss_pan.smoother"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother"], ["", "def", "plot_train", "(", "data", ")", ":", "\n", "\t", "plt", ".", "title", "(", "os", ".", "path", ".", "basesname", "(", "sys", ".", "argv", "[", "1", "]", ")", "+", "' Training Loss'", ")", "\n", "plt", ".", "xlabel", "(", "'Iteration'", ")", "\n", "plt", ".", "ylabel", "(", "'Loss'", ")", "\n", "\n", "loss_names", "=", "[", "'BBox Loss'", ",", "'Conf Loss'", ",", "'Mask Loss'", "]", "\n", "\n", "x", "=", "[", "x", "[", "'iteration'", "]", "for", "x", "in", "data", "]", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'b'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'c'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'m'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "\n", "if", "data", "[", "0", "]", "[", "'s'", "]", "is", "not", "None", ":", "\n", "\t\t", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'s'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "loss_names", ".", "append", "(", "'Semantic Loss'", ")", "\n", "", "if", "data", "[", "0", "]", "[", "'p'", "]", "is", "not", "None", ":", "\n", "\t\t", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'p'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "loss_names", ".", "append", "(", "'Panoptic Loss'", ")", "\n", "\n", "", "plt", ".", "legend", "(", "loss_names", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss_pan.plot_val": [[63, 74], ["matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.show", "os.path.basename"], "function", ["None"], ["", "def", "plot_val", "(", "data", ")", ":", "\n", "\t", "plt", ".", "title", "(", "os", ".", "path", ".", "basename", "(", "sys", ".", "argv", "[", "1", "]", ")", "+", "' Validation mAP'", ")", "\n", "plt", ".", "xlabel", "(", "'Epoch'", ")", "\n", "plt", ".", "ylabel", "(", "'mAP'", ")", "\n", "\n", "x", "=", "[", "x", "[", "1", "]", "[", "'epoch'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'box'", "]", "\n", "plt", ".", "plot", "(", "x", ",", "[", "x", "[", "0", "]", "[", "'all'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'box'", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "[", "x", "[", "0", "]", "[", "'all'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'mask'", "]", ")", "\n", "\n", "plt", ".", "legend", "(", "[", "'BBox mAP'", ",", "'Mask mAP'", "]", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render": [[27, 62], ["numpy.square", "numpy.square", "numpy.square", "numpy.clip", "fig.canvas.draw_idle", "numpy.tile", "numpy.tile", "numpy.sin", "numpy.sin", "numpy.sin", "numpy.exp", "numpy.exp", "numpy.exp", "matplotlib.imshow", "plt.imshow.set_data", "numpy.array().reshape", "numpy.array().reshape", "math.sin", "math.cos", "math.sin", "math.cos", "math.sin", "math.cos", "numpy.array", "numpy.array", "list", "list", "range", "range"], "function", ["None"], ["def", "render", "(", ")", ":", "\n", "\t", "if", "disable_render", ":", "\n", "\t\t", "return", "\n", "\n", "", "x", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "list", "(", "range", "(", "grid_w", ")", ")", ",", "dtype", "=", "np", ".", "float", ")", ".", "reshape", "(", "1", ",", "grid_w", ")", ",", "[", "grid_h", ",", "1", "]", ")", "-", "grid_w", "*", "center_x", "\n", "y", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "list", "(", "range", "(", "grid_h", ")", ")", ",", "dtype", "=", "np", ".", "float", ")", ".", "reshape", "(", "grid_h", ",", "1", ")", ",", "[", "1", ",", "grid_w", "]", ")", "-", "grid_h", "*", "center_y", "\n", "\n", "x", "/=", "scale", "\n", "y", "/=", "scale", "\n", "\n", "a1", "=", "angle", "+", "math", ".", "pi", "/", "3", "\n", "a2", "=", "-", "angle", "+", "math", ".", "pi", "/", "3", "\n", "a3", "=", "angle", "\n", "\n", "z1", "=", "x", "*", "math", ".", "sin", "(", "a1", ")", "+", "y", "*", "math", ".", "cos", "(", "a1", ")", "\n", "z2", "=", "x", "*", "math", ".", "sin", "(", "a2", ")", "-", "y", "*", "math", ".", "cos", "(", "a2", ")", "\n", "z3", "=", "x", "*", "math", ".", "sin", "(", "a3", ")", "+", "y", "*", "math", ".", "cos", "(", "a3", ")", "\n", "\n", "s1", "=", "np", ".", "square", "(", "np", ".", "sin", "(", "z1", ")", ")", "\n", "s2", "=", "np", ".", "square", "(", "np", ".", "sin", "(", "z2", ")", ")", "\n", "s3", "=", "np", ".", "square", "(", "np", ".", "sin", "(", "z3", ")", ")", "\n", "\n", "line_1", "=", "np", ".", "exp", "(", "s1", "*", "spacing", ")", "*", "s1", "\n", "line_2", "=", "np", ".", "exp", "(", "s2", "*", "spacing", ")", "*", "s2", "\n", "line_3", "=", "np", ".", "exp", "(", "s3", "*", "spacing", ")", "*", "s3", "\n", "\n", "global", "grid", "\n", "grid", "=", "np", ".", "clip", "(", "1", "-", "(", "line_1", "+", "line_2", "+", "line_3", ")", "/", "3", ",", "0", ",", "1", ")", "\n", "\n", "global", "im_handle", "\n", "if", "im_handle", "is", "None", ":", "\n", "\t\t", "im_handle", "=", "plt", ".", "imshow", "(", "grid", ")", "\n", "", "else", ":", "\n", "\t\t", "im_handle", ".", "set_data", "(", "grid", ")", "\n", "", "fig", ".", "canvas", ".", "draw_idle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.update_scale": [[63, 68], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render"], ["", "def", "update_scale", "(", "val", ")", ":", "\n", "\t", "global", "scale", "\n", "scale", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.update_angle": [[69, 74], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render"], ["", "def", "update_angle", "(", "val", ")", ":", "\n", "\t", "global", "angle", "\n", "angle", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.update_centerx": [[75, 80], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render"], ["", "def", "update_centerx", "(", "val", ")", ":", "\n", "\t", "global", "center_x", "\n", "center_x", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.update_centery": [[81, 86], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render"], ["", "def", "update_centery", "(", "val", ")", ":", "\n", "\t", "global", "center_y", "\n", "center_y", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.update_spacing": [[87, 92], ["make_grid.render"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render"], ["", "def", "update_spacing", "(", "val", ")", ":", "\n", "\t", "global", "spacing", "\n", "spacing", "=", "val", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.randomize": [[93, 112], ["random.uniform", "random.uniform", "scale_slider.set_val", "angle_slider.set_val", "centx_slider.set_val", "centy_slider.set_val", "spaci_slider.set_val", "make_grid.render", "random.uniform", "random.uniform", "math.exp", "random.uniform"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.ProgressBar.set_val", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.render"], ["", "def", "randomize", "(", "val", ")", ":", "\n", "\t", "global", "center_x", ",", "center_y", ",", "spacing", ",", "scale", ",", "angle", ",", "disable_render", "\n", "\n", "center_x", ",", "center_y", "=", "(", "random", ".", "uniform", "(", "0", ",", "1", ")", ",", "random", ".", "uniform", "(", "0", ",", "1", ")", ")", "\n", "spacing", "=", "random", ".", "uniform", "(", "-", "0.2", ",", "2", ")", "\n", "scale", "=", "4", "*", "math", ".", "exp", "(", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", ")", "\n", "angle", "=", "random", ".", "uniform", "(", "-", "math", ".", "pi", ",", "math", ".", "pi", ")", "\n", "\n", "disable_render", "=", "True", "\n", "\n", "scale_slider", ".", "set_val", "(", "scale", ")", "\n", "angle_slider", ".", "set_val", "(", "angle", ")", "\n", "centx_slider", ".", "set_val", "(", "center_x", ")", "\n", "centy_slider", ".", "set_val", "(", "center_y", ")", "\n", "spaci_slider", ".", "set_val", "(", "spacing", ")", "\n", "\n", "disable_render", "=", "False", "\n", "\n", "render", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add": [[113, 122], ["all_grids.append", "export_len_text.set_text", "fig.canvas.draw_idle", "make_grid.test_uniqueness", "numpy.stack", "str", "len"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.test_uniqueness"], ["", "def", "add", "(", "val", ")", ":", "\n", "\t", "all_grids", ".", "append", "(", "grid", ")", "\n", "\n", "global", "unique", "\n", "if", "not", "unique", ":", "\n", "\t\t", "unique", "=", "test_uniqueness", "(", "np", ".", "stack", "(", "all_grids", ")", ")", "\n", "\n", "", "export_len_text", ".", "set_text", "(", "'Num Grids: '", "+", "str", "(", "len", "(", "all_grids", ")", ")", ")", "\n", "fig", ".", "canvas", ".", "draw_idle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add_randomize": [[123, 126], ["make_grid.add", "make_grid.randomize"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.add", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.randomize"], ["", "def", "add_randomize", "(", "val", ")", ":", "\n", "\t", "add", "(", "val", ")", "\n", "randomize", "(", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.export": [[127, 137], ["numpy.save", "print", "all_grids.clear", "export_len_text.set_text", "fig.canvas.draw_idle", "numpy.stack", "str", "len", "len"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "def", "export", "(", "val", ")", ":", "\n", "\t", "np", ".", "save", "(", "save_path", ",", "np", ".", "stack", "(", "all_grids", ")", ")", "\n", "print", "(", "'Saved %d grids to \"%s\"'", "%", "(", "len", "(", "all_grids", ")", ",", "save_path", ")", ")", "\n", "\n", "global", "unique", "\n", "unique", "=", "False", "\n", "all_grids", ".", "clear", "(", ")", "\n", "\n", "export_len_text", ".", "set_text", "(", "'Num Grids: '", "+", "str", "(", "len", "(", "all_grids", ")", ")", ")", "\n", "fig", ".", "canvas", ".", "draw_idle", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.make_grid.test_uniqueness": [[138, 158], ["grids.reshape.reshape", "range", "print", "range", "numpy.sum", "numpy.sum", "numpy.abs", "print", "numpy.tile().reshape", "numpy.tile"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "def", "test_uniqueness", "(", "grids", ")", ":", "\n", "# Grids shape [ngrids, h, w]", "\n", "\t", "grids", "=", "grids", ".", "reshape", "(", "(", "-", "1", ",", "grid_h", ",", "grid_w", ")", ")", "\n", "\n", "for", "y", "in", "range", "(", "grid_h", ")", ":", "\n", "\t\t", "for", "x", "in", "range", "(", "grid_h", ")", ":", "\n", "\t\t\t", "pixel_features", "=", "grids", "[", ":", ",", "y", ",", "x", "]", "\n", "\n", "# l1 distance for this pixel with every other", "\n", "l1_dist", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "grids", "-", "np", ".", "tile", "(", "pixel_features", ",", "grid_h", "*", "grid_w", ")", ".", "reshape", "(", "(", "-", "1", ",", "grid_h", ",", "grid_w", ")", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# Equal if l1 distance is really small. Note that this will include this pixel", "\n", "num_equal", "=", "np", ".", "sum", "(", "(", "l1_dist", "<", "0.0001", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "\n", "if", "num_equal", ">", "1", ":", "\n", "\t\t\t\t", "print", "(", "'Pixel at (%d, %d) has %d other pixel%s with the same representation.'", "%", "(", "x", ",", "y", ",", "num_equal", "-", "1", ",", "''", "if", "num_equal", "==", "2", "else", "'s'", ")", ")", "\n", "return", "False", "\n", "\n", "", "", "", "print", "(", "'Each pixel has a distinct representation.'", ")", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.augment_boxes": [[18, 26], ["numpy.concatenate", "np.concatenate.append", "open", "pickle.dump", "augment_bbox.prep_box"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.prep_box"], ["def", "augment_boxes", "(", "bboxes", ")", ":", "\n", "\t", "bboxes_rel", "=", "[", "]", "\n", "for", "box", "in", "bboxes", ":", "\n", "\t\t", "bboxes_rel", ".", "append", "(", "prep_box", "(", "box", ")", ")", "\n", "", "bboxes_rel", "=", "np", ".", "concatenate", "(", "bboxes_rel", ",", "axis", "=", "0", ")", "\n", "\n", "with", "open", "(", "dump_file", ",", "'wb'", ")", "as", "f", ":", "\n", "\t\t", "pickle", ".", "dump", "(", "bboxes_rel", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.prep_box": [[27, 75], ["numpy.array", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "augment_bbox.random_sample_crop", "numpy.random.randint", "int", "int", "int", "int", "print"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.random_sample_crop", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "", "def", "prep_box", "(", "box_list", ")", ":", "\n", "\t", "global", "augment_idx", "\n", "boxes", "=", "np", ".", "array", "(", "[", "box_list", "[", "2", ":", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# Image width and height", "\n", "width", ",", "height", "=", "box_list", "[", ":", "2", "]", "\n", "\n", "# To point form", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "\n", "\n", "# Expand", "\n", "ratio", "=", "random", ".", "uniform", "(", "1", ",", "4", ")", "\n", "left", "=", "random", ".", "uniform", "(", "0", ",", "width", "*", "ratio", "-", "width", ")", "\n", "top", "=", "random", ".", "uniform", "(", "0", ",", "height", "*", "ratio", "-", "height", ")", "\n", "\n", "height", "*=", "ratio", "\n", "width", "*=", "ratio", "\n", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "(", "int", "(", "left", ")", ",", "int", "(", "top", ")", ")", "\n", "\n", "\n", "# RandomSampleCrop", "\n", "height", ",", "width", ",", "boxes", "=", "random_sample_crop", "(", "height", ",", "width", ",", "boxes", ")", "\n", "\n", "\n", "# RandomMirror", "\n", "if", "random", ".", "randint", "(", "0", ",", "2", ")", ":", "\n", "\t\t", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "width", "-", "boxes", "[", ":", ",", "2", ":", ":", "-", "2", "]", "\n", "\n", "\n", "# Resize", "\n", "", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "*=", "(", "max_image_size", "/", "width", ")", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "*=", "(", "max_image_size", "/", "height", ")", "\n", "width", "=", "height", "=", "max_image_size", "\n", "\n", "\n", "# ToPercentCoords", "\n", "boxes", "[", ":", ",", "[", "0", ",", "2", "]", "]", "/=", "width", "\n", "boxes", "[", ":", ",", "[", "1", ",", "3", "]", "]", "/=", "height", "\n", "\n", "if", "augment_idx", "%", "50000", "==", "0", ":", "\n", "\t\t", "print", "(", "'Current idx: %d'", "%", "augment_idx", ")", "\n", "\n", "", "augment_idx", "+=", "1", "\n", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.intersect": [[91, 96], ["numpy.minimum", "numpy.maximum", "numpy.clip"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "max_xy", "=", "np", ".", "minimum", "(", "box_a", "[", ":", ",", "2", ":", "]", ",", "box_b", "[", "2", ":", "]", ")", "\n", "min_xy", "=", "np", ".", "maximum", "(", "box_a", "[", ":", ",", ":", "2", "]", ",", "box_b", "[", ":", "2", "]", ")", "\n", "inter", "=", "np", ".", "clip", "(", "(", "max_xy", "-", "min_xy", ")", ",", "a_min", "=", "0", ",", "a_max", "=", "np", ".", "inf", ")", "\n", "return", "inter", "[", ":", ",", "0", "]", "*", "inter", "[", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.jaccard_numpy": [[98, 116], ["augment_bbox.intersect"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.intersect"], ["", "def", "jaccard_numpy", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: Multiple bounding boxes, Shape: [num_boxes,4]\n        box_b: Single bounding box, Shape: [4]\n    Return:\n        jaccard overlap: Shape: [box_a.shape[0], box_a.shape[1]]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", "2", "]", "-", "box_b", "[", "0", "]", ")", "*", "\n", "(", "box_b", "[", "3", "]", "-", "box_b", "[", "1", "]", ")", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.random_sample_crop": [[118, 164], ["numpy.random.choice", "range", "float", "float", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.array", "augment_bbox.jaccard_numpy", "boxes[].copy", "numpy.maximum", "numpy.minimum", "mask.any", "int", "int", "int", "int", "jaccard_numpy.min", "jaccard_numpy.max"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.augment_bbox.jaccard_numpy", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "def", "random_sample_crop", "(", "height", ",", "width", ",", "boxes", "=", "None", ")", ":", "\n", "\t", "global", "sample_options", "\n", "\n", "while", "True", ":", "\n", "# randomly choose a mode", "\n", "\t\t", "mode", "=", "random", ".", "choice", "(", "sample_options", ")", "\n", "if", "mode", "is", "None", ":", "\n", "\t\t\t", "return", "height", ",", "width", ",", "boxes", "\n", "\n", "", "min_iou", ",", "max_iou", "=", "mode", "\n", "if", "min_iou", "is", "None", ":", "\n", "\t\t\t", "min_iou", "=", "float", "(", "'-inf'", ")", "\n", "", "if", "max_iou", "is", "None", ":", "\n", "\t\t\t", "max_iou", "=", "float", "(", "'inf'", ")", "\n", "\n", "", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "\t\t\t", "w", "=", "random", ".", "uniform", "(", "0.3", "*", "width", ",", "width", ")", "\n", "h", "=", "random", ".", "uniform", "(", "0.3", "*", "height", ",", "height", ")", "\n", "\n", "if", "h", "/", "w", "<", "0.5", "or", "h", "/", "w", ">", "2", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "left", "=", "random", ".", "uniform", "(", "0", ",", "width", "-", "w", ")", "\n", "top", "=", "random", ".", "uniform", "(", "0", ",", "height", "-", "h", ")", "\n", "\n", "rect", "=", "np", ".", "array", "(", "[", "int", "(", "left", ")", ",", "int", "(", "top", ")", ",", "int", "(", "left", "+", "w", ")", ",", "int", "(", "top", "+", "h", ")", "]", ")", "\n", "overlap", "=", "jaccard_numpy", "(", "boxes", ",", "rect", ")", "\n", "if", "overlap", ".", "min", "(", ")", "<", "min_iou", "and", "max_iou", "<", "overlap", ".", "max", "(", ")", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "centers", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2.0", "\n", "\n", "m1", "=", "(", "rect", "[", "0", "]", "<", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "1", "]", "<", "centers", "[", ":", ",", "1", "]", ")", "\n", "m2", "=", "(", "rect", "[", "2", "]", ">", "centers", "[", ":", ",", "0", "]", ")", "*", "(", "rect", "[", "3", "]", ">", "centers", "[", ":", ",", "1", "]", ")", "\n", "mask", "=", "m1", "*", "m2", "\n", "\n", "if", "not", "mask", ".", "any", "(", ")", ":", "\n", "\t\t\t\t", "continue", "\n", "\n", "", "current_boxes", "=", "boxes", "[", "mask", ",", ":", "]", ".", "copy", "(", ")", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "current_boxes", "[", ":", ",", ":", "2", "]", ",", "rect", "[", ":", "2", "]", ")", "\n", "current_boxes", "[", ":", ",", ":", "2", "]", "-=", "rect", "[", ":", "2", "]", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "current_boxes", "[", ":", ",", "2", ":", "]", ",", "rect", "[", "2", ":", "]", ")", "\n", "current_boxes", "[", ":", ",", "2", ":", "]", "-=", "rect", "[", ":", "2", "]", "\n", "\n", "return", "h", ",", "w", ",", "current_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother": [[35, 43], ["utils.functions.MovingAverage", "range", "len", "utils.functions.MovingAverage.append", "utils.functions.MovingAverage.get_avg"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.get_avg"], ["", "", "", "def", "smoother", "(", "y", ",", "interval", "=", "100", ")", ":", "\n", "\t", "avg", "=", "MovingAverage", "(", "interval", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "y", ")", ")", ":", "\n", "\t\t", "avg", ".", "append", "(", "y", "[", "i", "]", ")", "\n", "y", "[", "i", "]", "=", "avg", ".", "get_avg", "(", ")", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.plot_train": [[44, 62], ["matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.show", "plot_loss.smoother", "plot_loss.smoother", "plot_loss.smoother", "matplotlib.plot", "loss_names.append", "os.path.basename", "plot_loss.smoother"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.smoother"], ["", "def", "plot_train", "(", "data", ")", ":", "\n", "\t", "plt", ".", "title", "(", "os", ".", "path", ".", "basename", "(", "sys", ".", "argv", "[", "1", "]", ")", "+", "' Training Loss'", ")", "\n", "plt", ".", "xlabel", "(", "'Iteration'", ")", "\n", "plt", ".", "ylabel", "(", "'Loss'", ")", "\n", "\n", "loss_names", "=", "[", "'BBox Loss'", ",", "'Conf Loss'", ",", "'Mask Loss'", "]", "\n", "\n", "x", "=", "[", "x", "[", "'iteration'", "]", "for", "x", "in", "data", "]", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'b'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'c'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'m'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "\n", "if", "data", "[", "0", "]", "[", "'s'", "]", "is", "not", "None", ":", "\n", "\t\t", "plt", ".", "plot", "(", "x", ",", "smoother", "(", "[", "y", "[", "'s'", "]", "for", "y", "in", "data", "]", ")", ")", "\n", "loss_names", ".", "append", "(", "'Segmentation Loss'", ")", "\n", "\n", "", "plt", ".", "legend", "(", "loss_names", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.plot_loss.plot_val": [[63, 74], ["matplotlib.title", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "matplotlib.show", "os.path.basename"], "function", ["None"], ["", "def", "plot_val", "(", "data", ")", ":", "\n", "\t", "plt", ".", "title", "(", "os", ".", "path", ".", "basename", "(", "sys", ".", "argv", "[", "1", "]", ")", "+", "' Validation mAP'", ")", "\n", "plt", ".", "xlabel", "(", "'Epoch'", ")", "\n", "plt", ".", "ylabel", "(", "'mAP'", ")", "\n", "\n", "x", "=", "[", "x", "[", "1", "]", "[", "'epoch'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'box'", "]", "\n", "plt", ".", "plot", "(", "x", ",", "[", "x", "[", "0", "]", "[", "'all'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'box'", "]", ")", "\n", "plt", ".", "plot", "(", "x", ",", "[", "x", "[", "0", "]", "[", "'all'", "]", "for", "x", "in", "data", "if", "x", "[", "0", "]", "[", "'type'", "]", "==", "'mask'", "]", ")", "\n", "\n", "plt", ".", "legend", "(", "[", "'BBox mAP'", ",", "'Mask mAP'", "]", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.intersect": [[24, 43], ["box_a.size", "box_b.size", "torch.min", "torch.max", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [A,4].\n      box_b: (tensor) bounding boxes, Shape: [B,4].\n    Return:\n      (tensor) intersection area, Shape: [A,B].\n    \"\"\"", "\n", "A", "=", "box_a", ".", "size", "(", "0", ")", "\n", "B", "=", "box_b", ".", "size", "(", "0", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "box_a", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.jaccard": [[45, 68], ["optimize_bboxes.intersect"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ",", "iscrowd", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes. If iscrowd=True, put the crowd in box_b.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_b", "[", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "\n", "if", "iscrowd", ":", "\n", "        ", "return", "inter", "/", "area_a", "\n", "", "else", ":", "\n", "        ", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.to_relative": [[70, 72], ["numpy.concatenate"], "function", ["None"], ["", "", "def", "to_relative", "(", "bboxes", ")", ":", "\n", "    ", "return", "np", ".", "concatenate", "(", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "/", "bboxes", "[", ":", ",", ":", "2", "]", ",", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "+", "bboxes", "[", ":", ",", "4", ":", "]", ")", "/", "bboxes", "[", ":", ",", ":", "2", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.make_priors": [[74, 92], ["itertools.product", "torch.Tensor().view().cuda", "range", "range", "zip", "torch.Tensor().view", "torch.Tensor"], "function", ["None"], ["", "def", "make_priors", "(", "conv_size", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "    ", "prior_data", "=", "[", "]", "\n", "conv_h", "=", "conv_size", "[", "0", "]", "\n", "conv_w", "=", "conv_size", "[", "1", "]", "\n", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "        ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "scale", ",", "ars", "in", "zip", "(", "scales", ",", "aspect_ratios", ")", ":", "\n", "            ", "for", "ar", "in", "ars", ":", "\n", "                ", "w", "=", "scale", "*", "ar", "/", "conv_w", "\n", "h", "=", "scale", "/", "ar", "/", "conv_h", "\n", "\n", "# Point form", "\n", "prior_data", "+=", "[", "x", "-", "w", "/", "2", ",", "y", "-", "h", "/", "2", ",", "x", "+", "w", "/", "2", ",", "y", "+", "h", "/", "2", "]", "\n", "", "", "", "return", "torch", ".", "Tensor", "(", "prior_data", ")", ".", "view", "(", "-", "1", ",", "4", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.compute_hits": [[104, 109], ["optimize_bboxes.jaccard", "torch.max"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard"], ["def", "compute_hits", "(", "bboxes", ",", "anchors", ",", "iou_threshold", "=", "0.5", ")", ":", "\n", "    ", "ious", "=", "jaccard", "(", "bboxes", ",", "anchors", ")", "\n", "perGTAnchorMax", ",", "_", "=", "torch", ".", "max", "(", "ious", ",", "dim", "=", "1", ")", "\n", "\n", "return", "(", "perGTAnchorMax", ">", "iou_threshold", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.compute_recall": [[110, 113], ["torch.sum", "hits.size"], "function", ["None"], ["", "def", "compute_recall", "(", "hits", ",", "base_hits", ")", ":", "\n", "    ", "hits", "=", "(", "hits", "|", "base_hits", ")", ".", "float", "(", ")", "\n", "return", "torch", ".", "sum", "(", "hits", ")", "/", "hits", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.step": [[115, 122], ["x_func", "optimize_bboxes.make_priors", "float", "compute_recall().cpu", "optimize_bboxes.compute_recall", "optimize_bboxes.compute_hits"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.make_priors", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.compute_recall", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.compute_hits"], ["", "def", "step", "(", "x", ",", "x_func", ",", "bboxes", ",", "base_hits", ",", "optim_idx", ")", ":", "\n", "# This should set the scale and aspect ratio", "\n", "    ", "x_func", "(", "x", ",", "scales", "[", "optim_idx", "]", ",", "aspect_ratios", "[", "optim_idx", "]", ")", "\n", "\n", "anchors", "=", "make_priors", "(", "conv_sizes", "[", "optim_idx", "]", ",", "scales", "[", "optim_idx", "]", ",", "aspect_ratios", "[", "optim_idx", "]", ")", "\n", "\n", "return", "-", "float", "(", "compute_recall", "(", "compute_hits", "(", "bboxes", ",", "anchors", ")", ",", "base_hits", ")", ".", "cpu", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.optimize": [[124, 155], ["min", "optimize_bboxes.compute_hits", "scipy.optimize.minimize", "full_bboxes.size", "optimize_bboxes.make_priors", "torch.cat", "full_bboxes.size", "range", "range", "range", "len", "len", "max", "len", "range", "sum", "len"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.compute_hits", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.make_priors"], ["", "def", "optimize", "(", "full_bboxes", ",", "optim_idx", ",", "batch_size", "=", "5000", ")", ":", "\n", "    ", "global", "batch_idx", ",", "scales", ",", "aspect_ratios", ",", "conv_sizes", "\n", "\n", "start", "=", "batch_idx", "*", "batch_size", "\n", "end", "=", "min", "(", "(", "batch_idx", "+", "1", ")", "*", "batch_size", ",", "full_bboxes", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "batch_idx", ">", "(", "full_bboxes", ".", "size", "(", "0", ")", "//", "batch_size", ")", ":", "\n", "        ", "batch_idx", "=", "0", "\n", "\n", "", "bboxes", "=", "full_bboxes", "[", "start", ":", "end", ",", ":", "]", "\n", "\n", "anchor_base", "=", "[", "\n", "make_priors", "(", "conv_sizes", "[", "idx", "]", ",", "scales", "[", "idx", "]", ",", "aspect_ratios", "[", "idx", "]", ")", "\n", "for", "idx", "in", "range", "(", "len", "(", "conv_sizes", ")", ")", "if", "idx", "!=", "optim_idx", "]", "\n", "base_hits", "=", "compute_hits", "(", "bboxes", ",", "torch", ".", "cat", "(", "anchor_base", ",", "dim", "=", "0", ")", ")", "\n", "\n", "\n", "def", "set_x", "(", "x", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "        ", "if", "optimize_scales", ":", "\n", "            ", "for", "i", "in", "range", "(", "len", "(", "scales", ")", ")", ":", "\n", "                ", "scales", "[", "i", "]", "=", "max", "(", "x", "[", "i", "]", ",", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "k", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "aspect_ratios", ")", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "len", "(", "aspect_ratios", "[", "i", "]", ")", ")", ":", "\n", "                    ", "aspect_ratios", "[", "i", "]", "[", "j", "]", "=", "x", "[", "k", "]", "\n", "k", "+=", "1", "\n", "\n", "\n", "", "", "", "", "res", "=", "minimize", "(", "step", ",", "x0", "=", "scales", "[", "optim_idx", "]", "if", "optimize_scales", "else", "sum", "(", "aspect_ratios", "[", "optim_idx", "]", ",", "[", "]", ")", ",", "method", "=", "'Powell'", ",", "\n", "args", "=", "(", "set_x", ",", "bboxes", ",", "base_hits", ",", "optim_idx", ")", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.pretty_str": [[157, 164], ["isinstance", "isinstance", "optimize_bboxes.pretty_str", "list", "optimize_bboxes.pretty_str"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.pretty_str", "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.optimize_bboxes.pretty_str"], ["", "def", "pretty_str", "(", "x", ":", "list", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "list", ")", ":", "\n", "        ", "return", "'['", "+", "', '", ".", "join", "(", "[", "pretty_str", "(", "y", ")", "for", "y", "in", "x", "]", ")", "+", "']'", "\n", "", "elif", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "pretty_str", "(", "list", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "'%.2f'", "%", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.cluster_bbox_sizes.to_relative": [[21, 23], ["None"], "function", ["None"], ["def", "to_relative", "(", "bboxes", ")", ":", "\n", "\t", "return", "bboxes", "[", ":", ",", "2", ":", "4", "]", "/", "bboxes", "[", ":", ",", ":", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.cluster_bbox_sizes.process": [[24, 26], ["cluster_bbox_sizes.to_relative"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.to_relative"], ["", "def", "process", "(", "bboxes", ")", ":", "\n", "\t", "return", "to_relative", "(", "bboxes", ")", "*", "max_size", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.intersect": [[24, 43], ["box_a.size", "box_b.size", "torch.min", "torch.max", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [A,4].\n      box_b: (tensor) bounding boxes, Shape: [B,4].\n    Return:\n      (tensor) intersection area, Shape: [A,B].\n    \"\"\"", "\n", "A", "=", "box_a", ".", "size", "(", "0", ")", "\n", "B", "=", "box_b", ".", "size", "(", "0", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "box_a", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.jaccard": [[45, 68], ["bbox_recall.intersect"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ",", "iscrowd", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes. If iscrowd=True, put the crowd in box_b.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_b", "[", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "\n", "if", "iscrowd", ":", "\n", "        ", "return", "inter", "/", "area_a", "\n", "", "else", ":", "\n", "        ", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.to_relative": [[70, 72], ["numpy.concatenate"], "function", ["None"], ["", "", "def", "to_relative", "(", "bboxes", ")", ":", "\n", "    ", "return", "np", ".", "concatenate", "(", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "/", "bboxes", "[", ":", ",", ":", "2", "]", ",", "(", "bboxes", "[", ":", ",", "2", ":", "4", "]", "+", "bboxes", "[", ":", ",", "4", ":", "]", ")", "/", "bboxes", "[", ":", ",", ":", "2", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.bbox_recall.make_priors": [[74, 93], ["itertools.product", "numpy.array().reshape", "range", "range", "zip", "numpy.array"], "function", ["None"], ["", "def", "make_priors", "(", "conv_size", ",", "scales", ",", "aspect_ratios", ")", ":", "\n", "    ", "prior_data", "=", "[", "]", "\n", "conv_h", "=", "conv_size", "[", "0", "]", "\n", "conv_w", "=", "conv_size", "[", "1", "]", "\n", "\n", "# Iteration order is important (it has to sync up with the convout)", "\n", "for", "j", ",", "i", "in", "product", "(", "range", "(", "conv_h", ")", ",", "range", "(", "conv_w", ")", ")", ":", "\n", "        ", "x", "=", "(", "i", "+", "0.5", ")", "/", "conv_w", "\n", "y", "=", "(", "j", "+", "0.5", ")", "/", "conv_h", "\n", "\n", "for", "scale", ",", "ars", "in", "zip", "(", "scales", ",", "aspect_ratios", ")", ":", "\n", "            ", "for", "ar", "in", "ars", ":", "\n", "                ", "w", "=", "scale", "*", "ar", "/", "conv_w", "\n", "h", "=", "scale", "/", "ar", "/", "conv_h", "\n", "\n", "# Point form", "\n", "prior_data", "+=", "[", "x", "-", "w", "/", "2", ",", "y", "-", "h", "/", "2", ",", "x", "+", "w", "/", "2", ",", "y", "+", "h", "/", "2", "]", "\n", "\n", "", "", "", "return", "np", ".", "array", "(", "prior_data", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.mask_iou": [[10, 21], ["torch.matmul", "torch.matmul", "torch.sum().view", "torch.sum().view", "torch.sum().view", "torch.sum().view", "mask2.t", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum().view.t"], "function", ["None"], ["def", "mask_iou", "(", "mask1", ",", "mask2", ")", ":", "\n", "    ", "\"\"\"\n    Inputs inputs are matricies of size _ x N. Output is size _1 x _2.\n    Note: if iscrowd is True, then mask2 should be the crowd.\n    \"\"\"", "\n", "intersection", "=", "torch", ".", "matmul", "(", "mask1", ",", "mask2", ".", "t", "(", ")", ")", "\n", "area1", "=", "torch", ".", "sum", "(", "mask1", ",", "dim", "=", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "area2", "=", "torch", ".", "sum", "(", "mask2", ",", "dim", "=", "1", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "union", "=", "(", "area1", ".", "t", "(", ")", "+", "area2", ")", "-", "intersection", "\n", "\n", "return", "intersection", "/", "union", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.paint_mask": [[22, 39], ["img_numpy.copy.copy", "numpy.tile", "numpy.array().reshape", "numpy.tile", "np.tile.reshape", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy"], ["", "def", "paint_mask", "(", "img_numpy", ",", "mask", ",", "color", ")", ":", "\n", "\t", "h", ",", "w", ",", "_", "=", "img_numpy", ".", "shape", "\n", "img_numpy", "=", "img_numpy", ".", "copy", "(", ")", "\n", "\n", "mask", "=", "np", ".", "tile", "(", "mask", ".", "reshape", "(", "h", ",", "w", ",", "1", ")", ",", "(", "1", ",", "1", ",", "3", ")", ")", "\n", "color_np", "=", "np", ".", "array", "(", "color", "[", ":", "3", "]", ")", ".", "reshape", "(", "1", ",", "1", ",", "3", ")", "\n", "color_np", "=", "np", ".", "tile", "(", "color_np", ",", "(", "h", ",", "w", ",", "1", ")", ")", "\n", "mask_color", "=", "mask", "*", "color_np", "\n", "\n", "mask_alpha", "=", "0.3", "\n", "\n", "# Blend image and mask", "\n", "image_crop", "=", "img_numpy", "*", "mask", "\n", "img_numpy", "*=", "(", "1", "-", "mask", ")", "\n", "img_numpy", "+=", "image_crop", "*", "(", "1", "-", "mask_alpha", ")", "+", "mask_color", "*", "mask_alpha", "\n", "\n", "return", "img_numpy", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.logit": [[41, 43], ["numpy.log"], "function", ["None"], ["", "def", "logit", "(", "x", ")", ":", "\n", "\t", "return", "np", ".", "log", "(", "x", "/", "(", "1", "-", "x", "+", "0.0001", ")", "+", "0.0001", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.scripts.compute_masks.sigmoid": [[44, 46], ["numpy.exp"], "function", ["None"], ["", "def", "sigmoid", "(", "x", ")", ":", "\n", "\t", "return", "1", "/", "(", "1", "+", "np", ".", "exp", "(", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.do_GET": [[11, 20], ["server.Handler.send_str", "server.Handler.path.startswith", "server.Handler.translate_path().split", "server.Handler.send_file", "super().do_GET", "os.path.join", "server.Handler.translate_path", "pathlib.Path().glob", "int", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_str", "home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_file", "home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.do_GET"], ["\t", "def", "do_GET", "(", "self", ")", ":", "\n", "\t\t", "if", "self", ".", "path", "==", "'/detindex'", ":", "\n", "\t\t\t", "self", ".", "send_str", "(", "'\\n'", ".", "join", "(", "[", "p", ".", "name", "[", ":", "-", "5", "]", "for", "p", "in", "Path", "(", "'dets/'", ")", ".", "glob", "(", "'*.json'", ")", "]", ")", ")", "\n", "", "elif", "self", ".", "path", ".", "startswith", "(", "'/image'", ")", ":", "\n", "# Unsafe practices ahead!", "\n", "\t\t\t", "path", "=", "self", ".", "translate_path", "(", "self", ".", "path", ")", ".", "split", "(", "'image'", ")", "\n", "self", ".", "send_file", "(", "os", ".", "path", ".", "join", "(", "path", "[", "0", "]", ",", "IMAGE_PATH", ",", "IMAGE_FMT", "%", "int", "(", "path", "[", "1", "]", ")", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "super", "(", ")", ".", "do_GET", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_str": [[21, 29], ["server.Handler.send_response", "server.Handler.send_header", "server.Handler.send_header", "server.Handler.send_header", "server.Handler.end_headers", "server.Handler.wfile.write", "str", "server.Handler.date_time_string", "string.encode", "len"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_response", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.layers.box_utils.encode"], ["", "", "def", "send_str", "(", "self", ",", "string", ")", ":", "\n", "\t\t", "self", ".", "send_response", "(", "HTTPStatus", ".", "OK", ")", "\n", "self", ".", "send_header", "(", "'Content-type'", ",", "'text/plain'", ")", "\n", "self", ".", "send_header", "(", "'Content-Length'", ",", "str", "(", "len", "(", "string", ")", ")", ")", "\n", "self", ".", "send_header", "(", "'Last-Modified'", ",", "self", ".", "date_time_string", "(", ")", ")", "\n", "self", ".", "end_headers", "(", ")", "\n", "\n", "self", ".", "wfile", ".", "write", "(", "string", ".", "encode", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_file": [[30, 48], ["open", "server.Handler.send_response", "server.Handler.send_header", "os.fstat", "server.Handler.send_header", "server.Handler.send_header", "server.Handler.end_headers", "server.Handler.copyfile", "open.close", "server.Handler.send_error", "server.Handler.guess_type", "open.fileno", "str", "server.Handler.date_time_string"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_response"], ["", "def", "send_file", "(", "self", ",", "path", ")", ":", "\n", "\t\t", "try", ":", "\n", "\t\t\t", "f", "=", "open", "(", "path", ",", "'rb'", ")", "\n", "", "except", "OSError", ":", "\n", "\t\t\t", "self", ".", "send_error", "(", "HTTPStatus", ".", "NOT_FOUND", ",", "\"File not found\"", ")", "\n", "return", "\n", "\n", "", "try", ":", "\n", "\t\t\t", "self", ".", "send_response", "(", "HTTPStatus", ".", "OK", ")", "\n", "self", ".", "send_header", "(", "\"Content-type\"", ",", "self", ".", "guess_type", "(", "path", ")", ")", "\n", "fs", "=", "os", ".", "fstat", "(", "f", ".", "fileno", "(", ")", ")", "\n", "self", ".", "send_header", "(", "\"Content-Length\"", ",", "str", "(", "fs", "[", "6", "]", ")", ")", "\n", "self", ".", "send_header", "(", "\"Last-Modified\"", ",", "self", ".", "date_time_string", "(", "fs", ".", "st_mtime", ")", ")", "\n", "self", ".", "end_headers", "(", ")", "\n", "\n", "self", ".", "copyfile", "(", "f", ",", "self", ".", "wfile", ")", "\n", "", "finally", ":", "\n", "\t\t\t", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_response": [[49, 51], ["super().send_response"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.web.server.Handler.send_response"], ["", "", "def", "send_response", "(", "self", ",", "code", ",", "message", "=", "None", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "send_response", "(", "code", ",", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOAnnotationTransform.__init__": [[31, 33], ["coco.get_label_map"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.get_label_map"], ["def", "__init__", "(", "self", ",", "is_stuff", "=", "False", ")", ":", "\n", "        ", "self", ".", "label_map", "=", "get_label_map", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOAnnotationTransform.__call__": [[34, 57], ["coco.get_label_map", "numpy.array", "list", "list.append", "print", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.get_label_map", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "def", "__call__", "(", "self", ",", "target", ",", "width", ",", "height", ",", "is_stuff", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            target (dict): COCO target json annotation as a python dict\n            height (int): height\n            width (int): width\n        Returns:\n            a list containing lists of bounding boxes  [bbox coords, class idx]\n        \"\"\"", "\n", "self", ".", "label_map", "=", "get_label_map", "(", "is_stuff", "=", "is_stuff", ")", "\n", "scale", "=", "np", ".", "array", "(", "[", "width", ",", "height", ",", "width", ",", "height", "]", ")", "\n", "res", "=", "[", "]", "\n", "for", "obj", "in", "target", ":", "\n", "            ", "if", "'bbox'", "in", "obj", ":", "\n", "                ", "bbox", "=", "obj", "[", "'bbox'", "]", "\n", "label_idx", "=", "self", ".", "label_map", "[", "obj", "[", "'category_id'", "]", "]", "-", "1", "if", "is_stuff", "is", "not", "True", "else", "self", ".", "label_map", "[", "obj", "[", "'category_id'", "]", "]", "#**Cause Stuff id=0 denotes background ", "\n", "final_box", "=", "list", "(", "np", ".", "array", "(", "[", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", ",", "bbox", "[", "0", "]", "+", "bbox", "[", "2", "]", ",", "bbox", "[", "1", "]", "+", "bbox", "[", "3", "]", "]", ")", "/", "scale", ")", "\n", "final_box", ".", "append", "(", "label_idx", ")", "\n", "res", "+=", "[", "final_box", "]", "# [xmin, ymin, xmax, ymax, label_idx]", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"No bbox found for object \"", ",", "obj", ")", "\n", "\n", "", "", "return", "res", "# [[xmin, ymin, xmax, ymax, label_idx], ... ]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.__init__": [[71, 89], ["coco.COCOAnnotationTransform", "COCO", "list", "coco.COCODetection.coco.imgToAnns.keys", "list", "len", "coco.COCODetection.coco.imgs.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "image_path", ",", "info_file", ",", "transform", "=", "None", ",", "\n", "target_transform", "=", "COCOAnnotationTransform", "(", ")", ",", "\n", "dataset_name", "=", "'MS COCO'", ",", "has_gt", "=", "True", ")", ":", "\n", "# Do this here because we have too many things named COCO", "\n", "        ", "from", "pycocotools", ".", "coco", "import", "COCO", "\n", "\n", "self", ".", "root", "=", "image_path", "\n", "self", ".", "coco", "=", "COCO", "(", "info_file", ")", "\n", "\n", "self", ".", "ids", "=", "list", "(", "self", ".", "coco", ".", "imgToAnns", ".", "keys", "(", ")", ")", "\n", "if", "len", "(", "self", ".", "ids", ")", "==", "0", "or", "not", "has_gt", ":", "\n", "            ", "self", ".", "ids", "=", "list", "(", "self", ".", "coco", ".", "imgs", ".", "keys", "(", ")", ")", "\n", "\n", "", "self", ".", "transform", "=", "transform", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "\n", "self", ".", "name", "=", "dataset_name", "\n", "self", ".", "has_gt", "=", "has_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.__getitem__": [[90, 100], ["coco.COCODetection.pull_item"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_item"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n        Returns:\n            tuple: Tuple (image, (target, masks, num_crowds)).\n                   target is the object returned by ``coco.loadAnns``.\n        \"\"\"", "\n", "im", ",", "gt", ",", "masks", ",", "h", ",", "w", ",", "num_crowds", "=", "self", ".", "pull_item", "(", "index", ")", "\n", "return", "im", ",", "(", "gt", ",", "masks", ",", "num_crowds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.__len__": [[101, 103], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.pull_item": [[104, 176], ["len", "file_name.startswith", "os.join", "os.join", "os.exists", "os.exists", "cv2.imread", "coco.COCODetection.coco.getAnnIds", "coco.COCODetection.coco.loadAnns", "len", "numpy.vstack", "masks.reshape.reshape.reshape", "coco.COCODetection.target_transform", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "coco.COCODetection.coco.loadImgs", "file_name.split", "coco.COCODetection.coco.annToMask().reshape", "len", "len", "numpy.array", "coco.COCODetection.transform", "numpy.hstack", "coco.COCODetection.transform", "numpy.zeros", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "coco.COCODetection.coco.annToMask", "numpy.expand_dims", "numpy.array"], "methods", ["None"], ["", "def", "pull_item", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n        Returns:\n            tuple: Tuple (image, target, masks, height, width, crowd).\n                   target is the object returned by ``coco.loadAnns``.\n            Note that if no crowd annotations exist, crowd will be None\n        \"\"\"", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "\n", "if", "self", ".", "has_gt", ":", "\n", "            ", "target", "=", "self", ".", "coco", ".", "imgToAnns", "[", "img_id", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "img_id", ")", "\n", "\n", "# Target has {'segmentation', 'area', iscrowd', 'image_id', 'bbox', 'category_id'}", "\n", "target", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "", "else", ":", "\n", "            ", "target", "=", "[", "]", "\n", "\n", "# Separate out crowd annotations. These are annotations that signify a large crowd of", "\n", "# objects of said class, where there is no annotation for each individual object. Both", "\n", "# during testing and training, consider these crowds as neutral.", "\n", "", "crowd", "=", "[", "x", "for", "x", "in", "target", "if", "(", "'iscrowd'", "in", "x", "and", "x", "[", "'iscrowd'", "]", ")", "]", "\n", "target", "=", "[", "x", "for", "x", "in", "target", "if", "not", "(", "'iscrowd'", "in", "x", "and", "x", "[", "'iscrowd'", "]", ")", "]", "\n", "num_crowds", "=", "len", "(", "crowd", ")", "\n", "\n", "# This is so we ensure that all crowd annotations are at the end of the array", "\n", "target", "+=", "crowd", "\n", "\n", "# The split here is to have compatibility with both COCO2014 and 2017 annotations.", "\n", "# In 2014, images have the pattern COCO_{train/val}2014_%012d.jpg, while in 2017 it's %012d.jpg.", "\n", "# Our script downloads the images as %012d.jpg so convert accordingly.", "\n", "file_name", "=", "self", ".", "coco", ".", "loadImgs", "(", "img_id", ")", "[", "0", "]", "[", "'file_name'", "]", "\n", "\n", "if", "file_name", ".", "startswith", "(", "'COCO'", ")", ":", "\n", "            ", "file_name", "=", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", "\n", "\n", "", "path", "=", "osp", ".", "join", "(", "self", ".", "root", ",", "file_name", ")", "\n", "assert", "osp", ".", "exists", "(", "path", ")", ",", "'Image path does not exist: {}'", ".", "format", "(", "path", ")", "\n", "\n", "img", "=", "cv2", ".", "imread", "(", "path", ")", "\n", "height", ",", "width", ",", "_", "=", "img", ".", "shape", "\n", "\n", "if", "len", "(", "target", ")", ">", "0", ":", "\n", "# Pool all the masks for this image into one [num_objects,height,width] matrix", "\n", "            ", "masks", "=", "[", "self", ".", "coco", ".", "annToMask", "(", "obj", ")", ".", "reshape", "(", "-", "1", ")", "for", "obj", "in", "target", "]", "\n", "masks", "=", "np", ".", "vstack", "(", "masks", ")", "\n", "masks", "=", "masks", ".", "reshape", "(", "-", "1", ",", "height", ",", "width", ")", "\n", "", "if", "self", ".", "target_transform", "is", "not", "None", "and", "len", "(", "target", ")", ">", "0", ":", "\n", "            ", "target", "=", "self", ".", "target_transform", "(", "target", ",", "width", ",", "height", ")", "\n", "\n", "", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "target", ")", ">", "0", ":", "\n", "                ", "target", "=", "np", ".", "array", "(", "target", ")", "\n", "img", ",", "masks", ",", "boxes", ",", "labels", "=", "self", ".", "transform", "(", "img", ",", "masks", ",", "target", "[", ":", ",", ":", "4", "]", ",", "\n", "{", "'num_crowds'", ":", "num_crowds", ",", "'labels'", ":", "target", "[", ":", ",", "4", "]", "}", ")", "\n", "\n", "# I stored num_crowds in labels so I didn't have to modify the entirety of augmentations", "\n", "num_crowds", "=", "labels", "[", "'num_crowds'", "]", "\n", "labels", "=", "labels", "[", "'labels'", "]", "\n", "\n", "target", "=", "np", ".", "hstack", "(", "(", "boxes", ",", "np", ".", "expand_dims", "(", "labels", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n", "\n", "", "else", ":", "\n", "                ", "img", ",", "_", ",", "_", ",", "_", "=", "self", ".", "transform", "(", "img", ",", "np", ".", "zeros", "(", "(", "1", ",", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float", ")", ",", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "1", ",", "1", "]", "]", ")", ",", "\n", "{", "'num_crowds'", ":", "0", ",", "'labels'", ":", "np", ".", "array", "(", "[", "0", "]", ")", "}", ")", "\n", "masks", "=", "None", "\n", "target", "=", "None", "\n", "\n", "", "", "return", "torch", ".", "from_numpy", "(", "img", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ",", "target", ",", "masks", ",", "height", ",", "width", ",", "num_crowds", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.pull_image": [[177, 191], ["cv2.imread", "os.join", "os.join", "coco.COCODetection.coco.loadImgs"], "methods", ["None"], ["", "def", "pull_image", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original image object at index in PIL form\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to show\n        Return:\n            cv2 img\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "path", "=", "self", ".", "coco", ".", "loadImgs", "(", "img_id", ")", "[", "0", "]", "[", "'file_name'", "]", "\n", "return", "cv2", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "root", ",", "path", ")", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.pull_anno": [[192, 207], ["coco.COCODetection.coco.getAnnIds", "coco.COCODetection.coco.loadAnns"], "methods", ["None"], ["", "def", "pull_anno", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original annotation of image at index\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to get annotation of\n        Return:\n            list:  [img_id, [(label, bbox coords),...]]\n                eg: ('001718', [('dog', (96, 13, 438, 332))])\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "img_id", ")", "\n", "return", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCODetection.__repr__": [[208, 217], ["coco.COCODetection.__len__", "coco.COCODetection.transform.__repr__().replace", "coco.COCODetection.target_transform.__repr__().replace", "coco.COCODetection.transform.__repr__", "coco.COCODetection.target_transform.__repr__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__len__", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "fmt_str", "=", "'Dataset '", "+", "self", ".", "__class__", ".", "__name__", "+", "'\\n'", "\n", "fmt_str", "+=", "'    Number of datapoints: {}\\n'", ".", "format", "(", "self", ".", "__len__", "(", ")", ")", "\n", "fmt_str", "+=", "'    Root Location: {}\\n'", ".", "format", "(", "self", ".", "root", ")", "\n", "tmp", "=", "'    Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}\\n'", ".", "format", "(", "tmp", ",", "self", ".", "transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "tmp", "=", "'    Target Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}'", ".", "format", "(", "tmp", ",", "self", ".", "target_transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "return", "fmt_str", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.__init__": [[230, 253], ["coco.COCOAnnotationTransform", "open", "json.load", "info_file.replace"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace"], ["def", "__init__", "(", "self", ",", "image_path", ",", "info_file", ",", "pan_folder", ",", "transform", "=", "None", ",", "\n", "target_transform", "=", "COCOAnnotationTransform", "(", ")", ",", "\n", "dataset_name", "=", "'MS COCO'", ",", "has_gt", "=", "True", ")", ":", "\n", "# Do this here because we have too many things named COCO", "\n", "        ", "with", "open", "(", "info_file", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "self", ".", "info_json", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "if", "has_gt", ":", "\n", "            ", "if", "pan_folder", "is", "None", ":", "\n", "                ", "pan_folder", "=", "info_file", ".", "replace", "(", "'.json'", ",", "''", ")", "\n", "", "self", ".", "gt_folder", "=", "pan_folder", "\n", "self", ".", "gt_annotations", "=", "{", "el", "[", "'image_id'", "]", ":", "el", "for", "el", "in", "self", ".", "info_json", "[", "'annotations'", "]", "}", "# {image_id : annotation}", "\n", "\n", "", "self", ".", "pan_categories", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "self", ".", "info_json", "[", "'categories'", "]", "}", "# { cat_id : cat_info }", "\n", "self", ".", "ids", "=", "[", "el", "[", "'id'", "]", "for", "el", "in", "self", ".", "info_json", "[", "'images'", "]", "]", "\n", "self", ".", "file_names", "=", "{", "el", "[", "'id'", "]", ":", "el", "[", "'file_name'", "]", "for", "el", "in", "self", ".", "info_json", "[", "'images'", "]", "}", "\n", "self", ".", "root", "=", "image_path", "\n", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "\n", "self", ".", "name", "=", "dataset_name", "\n", "self", ".", "has_gt", "=", "has_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.__getitem__": [[254, 264], ["coco.COCOPanoptic.pull_item"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_item"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n        Returns:\n            tuple: Tuple (image, (target, masks, num_crowds)).\n                   target is the object returned by ``coco.loadAnns``.\n        \"\"\"", "\n", "im", ",", "gt", ",", "masks_thing", ",", "mask_stuff", ",", "h", ",", "w", ",", "num_crowds", "=", "self", ".", "pull_item", "(", "index", ")", "\n", "return", "im", ",", "(", "gt", ",", "masks_thing", ",", "mask_stuff", ",", "num_crowds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.__len__": [[265, 267], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.pull_item": [[268, 385], ["len", "len", "len", "file_name.startswith", "os.join", "os.join", "os.exists", "os.exists", "cv2.imread", "numpy.array", "panopticapi.utils.rgb2id", "list", "numpy.array", "numpy.zeros", "range", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "PIL.open", "seg_infos.keys", "file_name.split", "len", "coco.COCOPanoptic.target_transform", "len", "coco.COCOPanoptic.target_transform", "len", "numpy.array", "numpy.ones", "numpy.concatenate", "coco.COCOPanoptic.transform", "numpy.hstack", "coco.COCOPanoptic.transform", "len", "len", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "coco.COCOPanoptic.append", "coco.COCOPanoptic.append", "numpy.array.astype", "numpy.where", "numpy.where", "numpy.zeros", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "coco.COCOPanoptic.file_names[].replace", "target[].reshape", "numpy.expand_dims", "numpy.array", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace"], ["", "def", "pull_item", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n        Returns:\n            tuple: Tuple (image, target, masks, height, width, crowd).\n                   target is the object returned by ``coco.loadAnns``.\n            Note that if no crowd annotations exist, crowd will be None\n        \"\"\"", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "\n", "if", "self", ".", "has_gt", ":", "\n", "            ", "target_thing", "=", "[", "]", "\n", "target_stuff", "=", "[", "]", "\n", "annotation", "=", "self", ".", "gt_annotations", "[", "img_id", "]", "# {segment_info , file_name, image_id}", "\n", "pan_gt", "=", "np", ".", "array", "(", "Image", ".", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "gt_folder", ",", "self", ".", "file_names", "[", "img_id", "]", ".", "replace", "(", "'.jpg'", ",", "'.png'", ")", ")", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "pan_gt", "=", "rgb2id", "(", "pan_gt", ")", "\n", "seg_infos", "=", "{", "el", "[", "'id'", "]", ":", "el", "for", "el", "in", "annotation", "[", "'segments_info'", "]", "}", "#get all segments' info", "\n", "seg_ids", "=", "list", "(", "seg_infos", ".", "keys", "(", ")", ")", "\n", "seg_masks", "=", "{", "seg_id", ":", "(", "pan_gt", "==", "seg_id", ")", ".", "astype", "(", "np", ".", "float16", ")", "for", "seg_id", "in", "seg_ids", "}", "\n", "for", "seg_id", "in", "seg_ids", ":", "\n", "                ", "cat_id", "=", "seg_infos", "[", "seg_id", "]", "[", "'category_id'", "]", "\n", "target_dict", "=", "seg_infos", "[", "seg_id", "]", "# { seg_id , cat_id, is_crowd, bbox, area, mask}", "\n", "if", "self", ".", "pan_categories", "[", "cat_id", "]", "[", "'isthing'", "]", "==", "1", ":", "\n", "                    ", "target_thing", ".", "append", "(", "target_dict", ")", "\n", "", "else", ":", "\n", "                    ", "target_stuff", ".", "append", "(", "target_dict", ")", "\n", "", "", "", "else", ":", "\n", "            ", "target_thing", "=", "[", "]", "\n", "target_stuff", "=", "[", "]", "\n", "\n", "\n", "# Separate out crowd annotations. These are annotations that signify a large crowd of", "\n", "# objects of said class, where there is no annotation for each individual object. Both", "\n", "# during testing and training, consider these crowds as neutral.", "\n", "", "crowd", "=", "[", "x", "for", "x", "in", "target_thing", "if", "(", "'iscrowd'", "in", "x", "and", "x", "[", "'iscrowd'", "]", ")", "]", "\n", "target_thing", "=", "[", "x", "for", "x", "in", "target_thing", "if", "not", "(", "'iscrowd'", "in", "x", "and", "x", "[", "'iscrowd'", "]", ")", "]", "\n", "num_crowds", "=", "len", "(", "crowd", ")", "\n", "\n", "# This is so we ensure that all crowd annotations are at the end of the array", "\n", "target_thing", "+=", "crowd", "\n", "\n", "n_thing", "=", "len", "(", "target_thing", ")", "\n", "n_stuff", "=", "len", "(", "target_stuff", ")", "\n", "\n", "# The split here is to have compatibility with both COCO2014 and 2017 annotations.", "\n", "# In 2014, images have the pattern COCO_{train/val}2014_%012d.jpg, while in 2017 it's %012d.jpg.", "\n", "# Our script downloads the images as %012d.jpg so convert accordingly.", "\n", "file_name", "=", "self", ".", "file_names", "[", "img_id", "]", "\n", "\n", "if", "file_name", ".", "startswith", "(", "'COCO'", ")", ":", "\n", "            ", "file_name", "=", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", "\n", "\n", "", "path", "=", "osp", ".", "join", "(", "self", ".", "root", ",", "file_name", ")", "\n", "\n", "assert", "osp", ".", "exists", "(", "path", ")", ",", "'Image path does not exist: {}'", ".", "format", "(", "path", ")", "\n", "\n", "img", "=", "cv2", ".", "imread", "(", "path", ")", "\n", "height", ",", "width", ",", "_", "=", "img", ".", "shape", "\n", "\n", "if", "n_thing", ">", "0", "and", "self", ".", "has_gt", ":", "\n", "            ", "masks", "=", "np", ".", "array", "(", "[", "seg_masks", "[", "t", "[", "'id'", "]", "]", "for", "t", "in", "target_thing", "]", "+", "[", "seg_masks", "[", "t", "[", "'id'", "]", "]", "for", "t", "in", "target_stuff", "]", ")", "\n", "", "else", ":", "\n", "            ", "masks", "=", "None", "\n", "\n", "#mix the target from thing and stuff", "\n", "", "if", "self", ".", "target_transform", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "target_thing", ")", ">", "0", ":", "\n", "                ", "target_thing", "=", "self", ".", "target_transform", "(", "target_thing", ",", "width", ",", "height", ")", "\n", "", "if", "len", "(", "target_stuff", ")", ">", "0", ":", "\n", "                ", "target_stuff", "=", "self", ".", "target_transform", "(", "target_stuff", ",", "width", ",", "height", ",", "is_stuff", "=", "True", ")", "\n", "\n", "", "", "target", "=", "target_thing", "+", "target_stuff", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "target_thing", ")", ">", "0", ":", "\n", "                ", "target", "=", "np", ".", "array", "(", "target", ")", "\n", "thing_checks", "=", "np", ".", "ones", "(", "(", "target", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "#record each mask which belongs to thing or mask , if thing check=1 else 0", "\n", "thing_checks", "[", "n_thing", ":", ",", ":", "]", "=", "0", "\n", "cls_labels", "=", "np", ".", "concatenate", "(", "(", "thing_checks", ",", "target", "[", ":", ",", "4", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "\n", "img", ",", "masks", ",", "boxes", ",", "labels", "=", "self", ".", "transform", "(", "img", ",", "masks", ".", "astype", "(", "np", ".", "uint8", ")", ",", "target", "[", ":", ",", ":", "4", "]", ",", "\n", "{", "'num_crowds'", ":", "num_crowds", ",", "'labels'", ":", "cls_labels", "}", ")", "\n", "\n", "# I stored num_crowds in labels so I didn't have to modify the entirety of augmentations", "\n", "num_crowds", "=", "labels", "[", "'num_crowds'", "]", "\n", "labels", "=", "labels", "[", "'labels'", "]", "\n", "\n", "#only keep thing in target(label and bboxes)", "\n", "thing_idx", "=", "np", ".", "where", "(", "labels", "[", ":", ",", "0", "]", "==", "1", ")", "[", "0", "]", "\n", "label_thing", "=", "labels", "[", "thing_idx", ",", "1", "]", "\n", "stuff_idx", "=", "np", ".", "where", "(", "labels", "[", ":", ",", "0", "]", "==", "0", ")", "[", "0", "]", "\n", "label_stuff", "=", "labels", "[", "stuff_idx", ",", "1", "]", "\n", "boxes", "=", "boxes", "[", "thing_idx", ",", ":", "]", "\n", "target", "=", "np", ".", "hstack", "(", "(", "boxes", ",", "np", ".", "expand_dims", "(", "label_thing", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "img", ",", "_", ",", "_", ",", "_", "=", "self", ".", "transform", "(", "img", ",", "np", ".", "zeros", "(", "(", "1", ",", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float", ")", ",", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "1", ",", "1", "]", "]", ")", ",", "\n", "{", "'num_crowds'", ":", "0", ",", "'labels'", ":", "np", ".", "array", "(", "[", "0", "]", ")", "}", ")", "\n", "masks", "=", "None", "\n", "target", "=", "None", "\n", "\n", "# build semantic segmentation format output", "\n", "\n", "", "", "if", "masks", "is", "not", "None", "and", "len", "(", "thing_idx", ")", ">", "0", ":", "#mask sure that after cropping there are still things mask", "\n", "            ", "masks_thing", "=", "masks", "[", "thing_idx", ",", ":", ",", ":", "]", "\n", "mask_stuff", "=", "masks", "[", "stuff_idx", ",", ":", ",", ":", "]", "\n", "stuff_logits", "=", "np", ".", "zeros", "(", "(", "mask_stuff", ".", "shape", "[", "1", "]", ",", "mask_stuff", ".", "shape", "[", "2", "]", ")", ")", "\n", "things_idx", "=", "cfg", ".", "stuff_num_classes", "-", "1", "\n", "for", "i", "in", "range", "(", "len", "(", "stuff_idx", ")", ")", ":", "\n", "                ", "stuff_logits", "[", "mask_stuff", "[", "i", ",", ":", ",", ":", "]", "!=", "0", "]", "=", "label_stuff", "[", "i", "]", "\n", "", "stuff_logits", "[", "np", ".", "sum", "(", "masks_thing", ",", "axis", "=", "0", ")", ">", "0", "]", "=", "things_idx", "\n", "\n", "", "else", ":", "\n", "            ", "masks_thing", "=", "None", "\n", "stuff_logits", "=", "None", "\n", "\n", "", "return", "torch", ".", "from_numpy", "(", "img", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ",", "target", ",", "masks_thing", ",", "stuff_logits", ",", "height", ",", "width", ",", "num_crowds", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.pull_image": [[386, 401], ["cv2.imread", "os.join", "os.join"], "methods", ["None"], ["", "def", "pull_image", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original image object at index in PIL form\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to show\n        Return:\n            cv2 img\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "path", "=", "self", ".", "file_names", "[", "img_id", "]", "\n", "\n", "return", "cv2", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "root", ",", "path", ")", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.pull_image_name": [[402, 405], ["None"], "methods", ["None"], ["", "def", "pull_image_name", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "return", "self", ".", "file_names", "[", "img_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.pull_anno": [[406, 420], ["None"], "methods", ["None"], ["", "def", "pull_anno", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original annotation of image at index\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to get annotation of\n        Return:\n            list:  [img_id, [(label, bbox coords),...]]\n                eg: ('001718', [('dog', (96, 13, 438, 332))])\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "return", "self", ".", "gt_annotations", "[", "img_id", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic.__repr__": [[421, 430], ["coco.COCOPanoptic.__len__", "coco.COCOPanoptic.transform.__repr__().replace", "coco.COCOPanoptic.target_transform.__repr__().replace", "coco.COCOPanoptic.transform.__repr__", "coco.COCOPanoptic.target_transform.__repr__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__len__", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "fmt_str", "=", "'Dataset '", "+", "self", ".", "__class__", ".", "__name__", "+", "'\\n'", "\n", "fmt_str", "+=", "'    Number of datapoints: {}\\n'", ".", "format", "(", "self", ".", "__len__", "(", ")", ")", "\n", "fmt_str", "+=", "'    Root Location: {}\\n'", ".", "format", "(", "self", ".", "root", ")", "\n", "tmp", "=", "'    Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}\\n'", ".", "format", "(", "tmp", ",", "self", ".", "transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "tmp", "=", "'    Target Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}'", ".", "format", "(", "tmp", ",", "self", ".", "target_transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "return", "fmt_str", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__init__": [[444, 463], ["coco.COCOAnnotationTransform", "COCO", "COCO", "list", "coco.COCOPanoptic_inst_sem.coco.imgToAnns.keys", "list", "len", "coco.COCOPanoptic_inst_sem.coco.imgs.keys"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "image_path", ",", "info_file", ",", "stuff_info_file", ",", "transform", "=", "None", ",", "\n", "target_transform", "=", "COCOAnnotationTransform", "(", ")", ",", "\n", "dataset_name", "=", "'MS COCO'", ",", "has_gt", "=", "True", ")", ":", "\n", "# Do this here because we have too many things named COCO", "\n", "        ", "from", "pycocotools", ".", "coco", "import", "COCO", "\n", "\n", "self", ".", "root", "=", "image_path", "\n", "self", ".", "coco", "=", "COCO", "(", "info_file", ")", "\n", "self", ".", "coco_stuff", "=", "COCO", "(", "stuff_info_file", ")", "\n", "\n", "self", ".", "ids", "=", "list", "(", "self", ".", "coco", ".", "imgToAnns", ".", "keys", "(", ")", ")", "\n", "if", "len", "(", "self", ".", "ids", ")", "==", "0", "or", "not", "has_gt", ":", "\n", "            ", "self", ".", "ids", "=", "list", "(", "self", ".", "coco", ".", "imgs", ".", "keys", "(", ")", ")", "\n", "\n", "", "self", ".", "transform", "=", "transform", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "\n", "self", ".", "name", "=", "dataset_name", "\n", "self", ".", "has_gt", "=", "has_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__getitem__": [[464, 474], ["coco.COCOPanoptic_inst_sem.pull_item"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_item"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n        Returns:\n            tuple: Tuple (image, (target, masks, num_crowds)).\n                   target is the object returned by ``coco.loadAnns``.\n        \"\"\"", "\n", "im", ",", "gt", ",", "masks_thing", ",", "mask_stuff", ",", "h", ",", "w", ",", "num_crowds", "=", "self", ".", "pull_item", "(", "index", ")", "\n", "return", "im", ",", "(", "gt", ",", "masks_thing", ",", "mask_stuff", ",", "num_crowds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__len__": [[475, 477], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_item": [[478, 580], ["len", "len", "len", "file_name.startswith", "os.join", "os.join", "os.exists", "os.exists", "cv2.imread", "numpy.zeros", "range", "coco.COCOPanoptic_inst_sem.coco.getAnnIds", "coco.COCOPanoptic_inst_sem.coco_stuff.getAnnIds", "coco.COCOPanoptic_inst_sem.coco.loadAnns", "coco.COCOPanoptic_inst_sem.coco_stuff.loadAnns", "len", "numpy.vstack", "masks.reshape.reshape.reshape", "len", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "torch.from_numpy().permute", "coco.COCOPanoptic_inst_sem.coco.loadImgs", "file_name.split", "coco.COCOPanoptic_inst_sem.coco.annToMask().reshape", "coco.COCOPanoptic_inst_sem.coco_stuff.annToMask().reshape", "len", "coco.COCOPanoptic_inst_sem.target_transform", "len", "coco.COCOPanoptic_inst_sem.target_transform", "len", "numpy.array", "numpy.ones", "numpy.concatenate", "coco.COCOPanoptic_inst_sem.transform", "numpy.hstack", "coco.COCOPanoptic_inst_sem.transform", "numpy.where", "numpy.where", "numpy.zeros", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "coco.COCOPanoptic_inst_sem.coco.annToMask", "coco.COCOPanoptic_inst_sem.coco_stuff.annToMask", "target[].reshape", "numpy.expand_dims", "numpy.array"], "methods", ["None"], ["", "def", "pull_item", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n        Returns:\n            tuple: Tuple (image, target, masks, height, width, crowd).\n                   target is the object returned by ``coco.loadAnns``.\n            Note that if no crowd annotations exist, crowd will be None\n        \"\"\"", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "\n", "if", "self", ".", "has_gt", ":", "\n", "            ", "target", "=", "self", ".", "coco", ".", "imgToAnns", "[", "img_id", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "img_id", ")", "\n", "ann_ids_stuff", "=", "self", ".", "coco_stuff", ".", "getAnnIds", "(", "imgIds", "=", "img_id", ")", "\n", "\n", "# Target has {'segmentation', 'area', iscrowd', 'image_id', 'bbox', 'category_id'}", "\n", "target", "=", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "target_stuff", "=", "self", ".", "coco_stuff", ".", "loadAnns", "(", "ann_ids_stuff", ")", "\n", "", "else", ":", "\n", "            ", "target", "=", "[", "]", "\n", "\n", "# Separate out crowd annotations. These are annotations that signify a large crowd of", "\n", "# objects of said class, where there is no annotation for each individual object. Both", "\n", "# during testing and training, consider these crowds as neutral.", "\n", "", "crowd", "=", "[", "x", "for", "x", "in", "target", "if", "(", "'iscrowd'", "in", "x", "and", "x", "[", "'iscrowd'", "]", ")", "]", "\n", "target", "=", "[", "x", "for", "x", "in", "target", "if", "not", "(", "'iscrowd'", "in", "x", "and", "x", "[", "'iscrowd'", "]", ")", "]", "\n", "num_crowds", "=", "len", "(", "crowd", ")", "\n", "\n", "# This is so we ensure that all crowd annotations are at the end of the array", "\n", "target", "+=", "crowd", "\n", "\n", "n_thing", "=", "len", "(", "target", ")", "\n", "n_stuff", "=", "len", "(", "target_stuff", ")", "\n", "\n", "# The split here is to have compatibility with both COCO2014 and 2017 annotations.", "\n", "# In 2014, images have the pattern COCO_{train/val}2014_%012d.jpg, while in 2017 it's %012d.jpg.", "\n", "# Our script downloads the images as %012d.jpg so convert accordingly.", "\n", "file_name", "=", "self", ".", "coco", ".", "loadImgs", "(", "img_id", ")", "[", "0", "]", "[", "'file_name'", "]", "\n", "\n", "if", "file_name", ".", "startswith", "(", "'COCO'", ")", ":", "\n", "            ", "file_name", "=", "file_name", ".", "split", "(", "'_'", ")", "[", "-", "1", "]", "\n", "\n", "", "path", "=", "osp", ".", "join", "(", "self", ".", "root", ",", "file_name", ")", "\n", "assert", "osp", ".", "exists", "(", "path", ")", ",", "'Image path does not exist: {}'", ".", "format", "(", "path", ")", "\n", "\n", "img", "=", "cv2", ".", "imread", "(", "path", ")", "\n", "height", ",", "width", ",", "_", "=", "img", ".", "shape", "\n", "\n", "if", "len", "(", "target", ")", ">", "0", ":", "\n", "# Pool all the masks for this image into one [num_objects,height,width] matrix", "\n", "            ", "masks_thing", "=", "[", "self", ".", "coco", ".", "annToMask", "(", "obj", ")", ".", "reshape", "(", "-", "1", ")", "for", "obj", "in", "target", "]", "\n", "masks_stuff", "=", "[", "self", ".", "coco_stuff", ".", "annToMask", "(", "obj", ")", ".", "reshape", "(", "-", "1", ")", "for", "obj", "in", "target_stuff", "]", "\n", "masks", "=", "masks_thing", "+", "masks_stuff", "\n", "masks", "=", "np", ".", "vstack", "(", "masks", ")", "\n", "masks", "=", "masks", ".", "reshape", "(", "-", "1", ",", "height", ",", "width", ")", "\n", "\n", "#mix the target from thing and stuff", "\n", "", "if", "self", ".", "target_transform", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "target", ")", ">", "0", ":", "\n", "                ", "target", "=", "self", ".", "target_transform", "(", "target", ",", "width", ",", "height", ")", "\n", "", "if", "len", "(", "target_stuff", ")", ">", "0", ":", "\n", "                ", "target_stuff", "=", "self", ".", "target_transform", "(", "target_stuff", ",", "width", ",", "height", ",", "is_stuff", "=", "True", ")", "\n", "\n", "", "", "target", "=", "target", "+", "target_stuff", "\n", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "target", ")", ">", "0", ":", "\n", "                ", "target", "=", "np", ".", "array", "(", "target", ")", "\n", "thing_checks", "=", "np", ".", "ones", "(", "(", "target", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "#record each mask which belongs to thing or mask , if thing check=1 else 0", "\n", "thing_checks", "[", "n_thing", ":", ",", ":", "]", "=", "0", "\n", "cls_labels", "=", "np", ".", "concatenate", "(", "(", "thing_checks", ",", "target", "[", ":", ",", "4", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "\n", "img", ",", "masks", ",", "boxes", ",", "labels", "=", "self", ".", "transform", "(", "img", ",", "masks", ",", "target", "[", ":", ",", ":", "4", "]", ",", "\n", "{", "'num_crowds'", ":", "num_crowds", ",", "'labels'", ":", "cls_labels", "}", ")", "\n", "\n", "# I stored num_crowds in labels so I didn't have to modify the entirety of augmentations", "\n", "num_crowds", "=", "labels", "[", "'num_crowds'", "]", "\n", "labels", "=", "labels", "[", "'labels'", "]", "\n", "\n", "#only keep thing in target(label and bboxes)", "\n", "thing_idx", "=", "np", ".", "where", "(", "labels", "[", ":", ",", "0", "]", "==", "1", ")", "[", "0", "]", "\n", "label_thing", "=", "labels", "[", "thing_idx", ",", "1", "]", "\n", "stuff_idx", "=", "np", ".", "where", "(", "labels", "[", ":", ",", "0", "]", "==", "0", ")", "[", "0", "]", "\n", "label_stuff", "=", "labels", "[", "stuff_idx", ",", "1", "]", "\n", "boxes", "=", "boxes", "[", "thing_idx", ",", ":", "]", "\n", "target", "=", "np", ".", "hstack", "(", "(", "boxes", ",", "np", ".", "expand_dims", "(", "label_thing", ",", "axis", "=", "1", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "img", ",", "_", ",", "_", ",", "_", "=", "self", ".", "transform", "(", "img", ",", "np", ".", "zeros", "(", "(", "1", ",", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "float", ")", ",", "np", ".", "array", "(", "[", "[", "0", ",", "0", ",", "1", ",", "1", "]", "]", ")", ",", "\n", "{", "'num_crowds'", ":", "0", ",", "'labels'", ":", "np", ".", "array", "(", "[", "0", "]", ")", "}", ")", "\n", "masks", "=", "None", "\n", "target", "=", "None", "\n", "\n", "#build semantic segmentation format output", "\n", "", "", "masks_thing", "=", "masks", "[", "thing_idx", ",", ":", ",", ":", "]", "\n", "mask_stuff", "=", "masks", "[", "stuff_idx", ",", ":", ",", ":", "]", "\n", "stuff_logits", "=", "np", ".", "zeros", "(", "(", "mask_stuff", ".", "shape", "[", "1", "]", ",", "mask_stuff", ".", "shape", "[", "2", "]", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "stuff_idx", ")", ")", ":", "\n", "            ", "stuff_logits", "[", "mask_stuff", "[", "i", ",", ":", ",", ":", "]", "!=", "0", "]", "=", "label_stuff", "[", "i", "]", "\n", "\n", "", "return", "torch", ".", "from_numpy", "(", "img", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ",", "target", ",", "masks_thing", ",", "stuff_logits", ",", "height", ",", "width", ",", "num_crowds", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image": [[581, 595], ["cv2.imread", "os.join", "os.join", "coco.COCOPanoptic_inst_sem.coco.loadImgs"], "methods", ["None"], ["", "def", "pull_image", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original image object at index in PIL form\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to show\n        Return:\n            cv2 img\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "path", "=", "self", ".", "coco", ".", "loadImgs", "(", "img_id", ")", "[", "0", "]", "[", "'file_name'", "]", "\n", "return", "cv2", ".", "imread", "(", "osp", ".", "join", "(", "self", ".", "root", ",", "path", ")", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_image_name": [[596, 600], ["coco.COCOPanoptic_inst_sem.coco.loadImgs"], "methods", ["None"], ["", "def", "pull_image_name", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "path", "=", "self", ".", "coco", ".", "loadImgs", "(", "img_id", ")", "[", "0", "]", "[", "'file_name'", "]", "\n", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.pull_anno": [[601, 616], ["coco.COCOPanoptic_inst_sem.coco.getAnnIds", "coco.COCOPanoptic_inst_sem.coco.loadAnns"], "methods", ["None"], ["", "def", "pull_anno", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original annotation of image at index\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to get annotation of\n        Return:\n            list:  [img_id, [(label, bbox coords),...]]\n                eg: ('001718', [('dog', (96, 13, 438, 332))])\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "ann_ids", "=", "self", ".", "coco", ".", "getAnnIds", "(", "imgIds", "=", "img_id", ")", "\n", "return", "self", ".", "coco", ".", "loadAnns", "(", "ann_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__": [[617, 626], ["coco.COCOPanoptic_inst_sem.__len__", "coco.COCOPanoptic_inst_sem.transform.__repr__().replace", "coco.COCOPanoptic_inst_sem.target_transform.__repr__().replace", "coco.COCOPanoptic_inst_sem.transform.__repr__", "coco.COCOPanoptic_inst_sem.target_transform.__repr__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__len__", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__", "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.COCOPanoptic_inst_sem.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "fmt_str", "=", "'Dataset '", "+", "self", ".", "__class__", ".", "__name__", "+", "'\\n'", "\n", "fmt_str", "+=", "'    Number of datapoints: {}\\n'", ".", "format", "(", "self", ".", "__len__", "(", ")", ")", "\n", "fmt_str", "+=", "'    Root Location: {}\\n'", ".", "format", "(", "self", ".", "root", ")", "\n", "tmp", "=", "'    Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}\\n'", ".", "format", "(", "tmp", ",", "self", ".", "transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "tmp", "=", "'    Target Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}'", ".", "format", "(", "tmp", ",", "self", ".", "target_transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "return", "fmt_str", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.coco.get_label_map": [[17, 24], ["range", "len"], "function", ["None"], ["def", "get_label_map", "(", "is_stuff", "=", "False", ")", ":", "\n", "    ", "label_map", "=", "cfg", ".", "dataset", ".", "label_map", "if", "is_stuff", "is", "False", "else", "cfg", ".", "dataset", ".", "stuff_label_map", "\n", "class_names", "=", "cfg", ".", "dataset", ".", "class_names", "if", "is_stuff", "is", "False", "else", "cfg", ".", "dataset", ".", "stuff_class_names", "\n", "if", "label_map", "is", "None", ":", "\n", "        ", "return", "{", "x", "+", "1", ":", "x", "+", "1", "for", "x", "in", "range", "(", "len", "(", "class_names", ")", ")", "}", "\n", "", "else", ":", "\n", "        ", "return", "label_map", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.__init__": [[95, 98], ["config_dict.items", "config.Config.__setattr__"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "config_dict", ")", ":", "\n", "        ", "for", "key", ",", "val", "in", "config_dict", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.copy": [[99, 111], ["config.Config", "new_config_dict.items", "vars", "object.__setattr__"], "methods", ["None"], ["", "", "def", "copy", "(", "self", ",", "new_config_dict", "=", "{", "}", ")", ":", "\n", "        ", "\"\"\"\n        Copies this config into a new config object, making\n        the changes given by new_config_dict.\n        \"\"\"", "\n", "\n", "ret", "=", "Config", "(", "vars", "(", "self", ")", ")", "\n", "\n", "for", "key", ",", "val", "in", "new_config_dict", ".", "items", "(", ")", ":", "\n", "            ", "ret", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace": [[112, 122], ["isinstance", "vars.items", "vars", "config.Config.__setattr__"], "methods", ["None"], ["", "def", "replace", "(", "self", ",", "new_config_dict", ")", ":", "\n", "        ", "\"\"\"\n        Copies new_config_dict into this config object.\n        Note: new_config_dict can also be a config object.\n        \"\"\"", "\n", "if", "isinstance", "(", "new_config_dict", ",", "Config", ")", ":", "\n", "            ", "new_config_dict", "=", "vars", "(", "new_config_dict", ")", "\n", "\n", "", "for", "key", ",", "val", "in", "new_config_dict", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "__setattr__", "(", "key", ",", "val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print": [[123, 131], ["vars().items", "isinstance", "vars", "config.Config.print"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.print"], ["", "", "def", "print", "(", "self", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "vars", "(", "self", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "Config", ")", ":", "\n", "                ", "print", "(", "'\\n====={}:====='", ".", "format", "(", "k", ")", ")", "\n", "v", ".", "print", "(", ")", "\n", "print", "(", "'==========\\n'", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "k", ",", "' = '", ",", "v", ")", "\n", "", "", "", "def", "write", "(", "self", ",", "f", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write": [[131, 139], ["vars().items", "isinstance", "vars", "f.write", "v.write", "f.write", "f.write"], "methods", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write", "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.write"], ["", "", "", "def", "write", "(", "self", ",", "f", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "vars", "(", "self", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "v", ",", "Config", ")", ":", "\n", "                ", "f", ".", "write", "(", "'\\n====={}:=====\\n'", ".", "format", "(", "k", ")", ")", "\n", "v", ".", "write", "(", "f", ")", "\n", "f", ".", "write", "(", "'==========\\n\\n'", ")", "\n", "", "else", ":", "\n", "                ", "f", ".", "write", "(", "'{} = {}\\n'", ".", "format", "(", "k", ",", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.set_cfg": [[854, 861], ["cfg.replace", "eval"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.data.config.Config.replace"], ["def", "set_cfg", "(", "config_name", ":", "str", ")", ":", "\n", "    ", "\"\"\" Sets the active config. Works even if cfg is already imported! \"\"\"", "\n", "global", "cfg", "\n", "\n", "# Note this is not just an eval because I'm lazy, but also because it can", "\n", "# be used like ssd300_config.copy({'max_size': 400}) for extreme fine-tuning", "\n", "cfg", ".", "replace", "(", "eval", "(", "config_name", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.config.set_dataset": [[862, 865], ["eval"], "function", ["None"], ["", "def", "set_dataset", "(", "dataset_name", ":", "str", ")", ":", "\n", "    ", "\"\"\" Sets the dataset of the current config. \"\"\"", "\n", "cfg", ".", "dataset", "=", "eval", "(", "dataset_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neo85824_epsnet.data.__init__.detection_collate": [[7, 38], ["imgs.append", "targets.append", "masks_thing.append", "masks_stuff.append", "num_crowds.append", "len", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.stack"], "function", ["home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append", "home.repos.pwc.inspect_result.neo85824_epsnet.utils.functions.MovingAverage.append"], []]}