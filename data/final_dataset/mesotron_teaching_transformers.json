{"home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.RunParams.__init__": [[249, 293], ["str", "str", "str", "Exception", "str", "Exception"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "\n", "to_coord", "=", "None", ",", "\n", "max_train_examples", "=", "sys", ".", "maxsize", ",", "\n", "max_validation_examples", "=", "100", ",", "\n", "max_test_examples", "=", "100", ",", "\n", "coordinates", "=", "True", ",", "\n", "prefix_pid_style", "=", "PrefixPID", ".", "BY_WORD", ",", "\n", "text_tag_style", "=", "TextTag", ".", "NONE", ",", "\n", "look", "=", "True", ",", "\n", "narrate_positions", "=", "False", ",", "\n", "endcap_length", "=", "50", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "to_coord", "=", "to_coord", "\n", "if", "self", ".", "to_coord", "is", "None", ":", "\n", "            ", "if", "text_tag_style", "==", "TextTag", ".", "NONE", ":", "\n", "                ", "self", ".", "to_coord", "=", "to_basic_coord", "\n", "", "elif", "text_tag_style", "==", "TextTag", ".", "BY_WORD_LIKE_PREFIX", ":", "\n", "                ", "self", ".", "to_coord", "=", "to_basic_coord_tag_words_prefix_encoding", "\n", "", "else", ":", "\n", "                ", "raise", "Exception", "(", "'Unrecognized text_tag_style'", ")", "\n", "", "", "else", ":", "\n", "            ", "if", "text_tag_style", "!=", "TextTag", ".", "NONE", ":", "\n", "                ", "raise", "Exception", "(", "'to_coord is specified, but so is text_tag_style, which constrains the value of to_coord'", ")", "\n", "\n", "", "", "self", ".", "max_train_examples", "=", "max_train_examples", "\n", "self", ".", "code", "=", "'_'", "+", "str", "(", "max_train_examples", ")", "\n", "self", ".", "max_validation_examples", "=", "max_validation_examples", "\n", "self", ".", "max_test_examples", "=", "max_test_examples", "\n", "self", ".", "coordinates", "=", "coordinates", "\n", "self", ".", "code", "+=", "(", "'G'", "if", "coordinates", "else", "''", ")", "\n", "\n", "self", ".", "prefix_pid_style", "=", "prefix_pid_style", "\n", "self", ".", "code", "+=", "'p'", "+", "str", "(", "prefix_pid_style", ".", "value", ")", "\n", "self", ".", "text_tag_style", "=", "text_tag_style", "\n", "self", ".", "code", "+=", "'t'", "+", "str", "(", "text_tag_style", ".", "value", ")", "\n", "\n", "self", ".", "look", "=", "look", "\n", "self", ".", "code", "+=", "(", "'L'", "if", "look", "else", "''", ")", "\n", "self", ".", "code", "+=", "'N'", "# indicates that narration / no-ops are present", "\n", "self", ".", "narrate_positions", "=", "narrate_positions", "\n", "self", ".", "code", "+=", "(", "'+'", "if", "narrate_positions", "else", "''", ")", "\n", "self", ".", "endcap_length", "=", "endcap_length", "\n", "self", ".", "code", "+=", "(", "'e'", "+", "str", "(", "endcap_length", ")", ")", "if", "endcap_length", "!=", "50", "else", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.to_basic_coord": [[72, 84], ["None"], "function", ["None"], ["def", "to_basic_coord", "(", "x", ",", "y", ",", "grid", ")", ":", "\n", "    ", "\"\"\"\n    Return string of 0-padded x and y coordinates separated by a comma. `grid`\n    is an argument only so that the function pointer signature matches\n    to_basic_coord_tag_words_prefix_encoding - this makes it so all functions\n    that might be assigned to to_coord have the same signature\n\n    :param int x: x-coordinate\n    :param int y: y-coordinate\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    \"\"\"", "\n", "return", "f'{x:02d},{y:02d}'", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.to_basic_coord_tag_words": [[85, 106], ["re.fullmatch"], "function", ["None"], ["", "def", "to_basic_coord_tag_words", "(", "x", ",", "y", ",", "grid", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Return string of 0-padded x and y coordinates separated by a comma, followed\n    by a numeric tag k+n where k is some constant, and n is defined such that\n    the symbol S at grid[(x,y)] is the nth consecutive symbol in the\n    alphanumeric string that S appears in. (n is 0-based).\n\n    :param int x: x-coordinate\n    :param int y: y-coordinate\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    :param int k: any constant\n    \"\"\"", "\n", "count", "=", "0", "\n", "i", "=", "x", "\n", "while", "True", ":", "\n", "        ", "i", "-=", "1", "\n", "if", "i", ">=", "0", "and", "re", ".", "fullmatch", "(", "r'[A-Za-z0-9]'", ",", "grid", "[", "(", "i", ",", "y", ")", "]", ")", ":", "\n", "            ", "count", "+=", "1", "\n", "", "else", ":", "\n", "            ", "break", "\n", "", "", "return", "f'{x:02d},{y:02d}:{k+count}'", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.to_basic_coord_tag_words_prefix_encoding": [[107, 121], ["demonstrator.to_basic_coord_tag_words"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.to_basic_coord_tag_words"], ["", "def", "to_basic_coord_tag_words_prefix_encoding", "(", "x", ",", "y", ",", "grid", ")", ":", "\n", "    ", "\"\"\"\n    Return string of 0-padded x and y coordinates separated by a comma, followed\n    by a numeric tag 201+n where n is defined such that the symbol S at\n    grid[(x,y)] is the nth consecutive symbol in the alphanumeric string that S\n    appears in. (n is 0-based). This allows the numeric tags to be represented\n    by single bytepair encoding tokens which differ from the tokens used to\n    express x and y.\n\n    :param int x: x-coordinate\n    :param int y: y-coordinate\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    \"\"\"", "\n", "return", "to_basic_coord_tag_words", "(", "x", ",", "y", ",", "grid", ",", "201", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at": [[124, 137], ["run.to_coord"], "function", ["None"], ["", "def", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", ":", "\n", "    ", "\"\"\"\n    Return the part of a 'look' action string corresponding to 'looking at' a\n    grid coordinate (x, y). Specifically: a string consisting of a space,\n    followed by a representation of the coordinate, followed by the symbol\n    currently located there.\n\n    :param int x: x-coordinate\n    :param int y: y-coordinate\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    :param RunParams run: configuration of this training/validation/test run\n    \"\"\"", "\n", "return", "f' {run.to_coord(x, y, grid)} {grid[(x, y)]}'", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register": [[138, 157], ["run.to_coord"], "function", ["None"], ["", "def", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "char", ",", "run", ")", ":", "\n", "    ", "\"\"\"\n    Write a particular character to a grid location.\n\n    Return a 2-tuple such that the first element is a space, followed by a\n    representation of the coordinate, followed by new symbol located there; the\n    second element is the grid itself. This is not strictly necessary to return,\n    but reminds us that this function modifies the grid.\n\n    :param str text: action string that we want to append the write action onto\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    :param int x: x-coordinate\n    :param int y: y-coordinate\n    :param str char: character to write\n    :param RunParams run: configuration of this training/validation/test run\n    \"\"\"", "\n", "text", "+=", "f' {run.to_coord(x, y, grid)} {char}'", "\n", "grid", "[", "(", "x", ",", "y", ")", "]", "=", "char", "\n", "return", "(", "text", ",", "grid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_lookstr_index": [[158, 172], ["re.sub", "re.sub.strip().split", "re.sub.strip"], "function", ["None"], ["", "def", "get_lookstr_index", "(", "lookstr", ",", "index", ")", ":", "\n", "    ", "\"\"\"\n    Given a lookstring (a string corresponding to a full 'look' action) that\n    represents the action of looking at a number of 1 or more digits, and an\n    index, return the indexth digit of that number, preceded by its position\n    tag.\n\n    :param str lookstr: the lookstring (a string corresponding to a full 'look'\n                        action)\n    :param int index:  the index of the desired digit\n    \"\"\"", "\n", "lookstr", "=", "re", ".", "sub", "(", "r'(\\d+),(\\d+):(\\d+) _ '", ",", "''", ",", "lookstr", ")", "\n", "tokens", "=", "lookstr", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "return", "tokens", "[", "index", "*", "2", "]", "+", "' '", "+", "tokens", "[", "index", "*", "2", "+", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_comparison_narration": [[173, 218], ["str", "str", "len", "len", "range", "demonstrator.get_lookstr_index", "demonstrator.get_lookstr_index", "int", "int"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_lookstr_index", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_lookstr_index"], ["", "def", "get_comparison_narration", "(", "look1", ",", "look2", ",", "value1", ",", "value2", ",", "compare_digits", ")", ":", "\n", "    ", "\"\"\"\n    Return the string representing the sequence of actions that corresponds to\n    comparing two numbers.\n\n   :param str look1: the lookstring (string corresponding to a full 'look'\n                     action) for the first number\n    :param str look2: the lookstring for the second number\n    :param int value1: the value of the first number\n    :param int value2: the value of the second number\n    :param bool compare_digits: whether to start out by comparing how many\n                                digits the two numbers have\n\n    \"\"\"", "\n", "str_value1", "=", "str", "(", "value1", ")", "\n", "str_value2", "=", "str", "(", "value2", ")", "\n", "digit_count1", "=", "len", "(", "str_value1", ")", "\n", "digit_count2", "=", "len", "(", "str_value2", ")", "\n", "output", "=", "''", "\n", "if", "compare_digits", ":", "\n", "        ", "output", "=", "f' {{ compare }} look{look1} {{ {digit_count1} digits }} look{look2} {{ {digit_count2} digits'", "\n", "\n", "", "if", "digit_count1", "==", "digit_count2", ":", "\n", "        ", "if", "compare_digits", ":", "\n", "            ", "output", "+=", "f' equal }}'", "\n", "", "for", "i", "in", "range", "(", "digit_count1", ")", ":", "\n", "            ", "digit_i1", "=", "get_lookstr_index", "(", "look1", ",", "i", ")", "\n", "digit_i2", "=", "get_lookstr_index", "(", "look2", ",", "i", ")", "\n", "digit1", "=", "int", "(", "str_value1", "[", "i", "]", ")", "\n", "digit2", "=", "int", "(", "str_value2", "[", "i", "]", ")", "\n", "output", "+=", "f' look {digit_i1} look {digit_i2} {{ {digit1} , {digit2}'", "\n", "if", "digit1", ">", "digit2", ":", "\n", "                ", "output", "+=", "f' smaller }}'", "\n", "break", "\n", "", "elif", "digit1", "<", "digit2", ":", "\n", "                ", "output", "+=", "f' larger }}'", "\n", "break", "\n", "", "else", ":", "\n", "                ", "output", "+=", "f' equal }}'", "\n", "\n", "", "", "", "elif", "digit_count1", ">", "digit_count2", ":", "\n", "        ", "output", "+=", "f' smaller }}'", "\n", "", "elif", "digit_count1", "<", "digit_count2", ":", "\n", "        ", "output", "+=", "f' larger }}'", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_coordinates": [[295, 298], ["re.sub"], "function", ["None"], ["", "", "def", "clean_coordinates", "(", "s", ")", ":", "\n", "    ", "\"\"\" Return a version of `s` with the coordinates erased. \"\"\"", "\n", "return", "re", ".", "sub", "(", "r' \\d\\d,\\d\\d'", ",", "''", ",", "' '", "+", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_position_ids": [[299, 302], ["re.sub().strip", "re.sub"], "function", ["None"], ["", "def", "clean_position_ids", "(", "s", ")", ":", "\n", "    ", "\"\"\" Return a version of `s` with the position ids erased. \"\"\"", "\n", "return", "re", ".", "sub", "(", "r' \\d\\d\\d'", ",", "''", ",", "' '", "+", "s", ")", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean": [[303, 318], ["re.sub.replace", "re.sub.strip", "re.sub", "re.sub"], "function", ["None"], ["", "def", "clean", "(", "text", ",", "drop_annotations", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Return a version of `text` with underscores and spaces between characters\n    removed, and optionally position ids, coordinates and tags as well.\n\n    :param str text:  text to clean\n    :param bool drop_annotations:  Whether to erase position ids, coordinates\n                                 and tags\n    \"\"\"", "\n", "if", "drop_annotations", ":", "\n", "      ", "text", "=", "re", ".", "sub", "(", "r' \\d\\d,\\d\\d(:\\d\\d\\d)?'", ",", "''", ",", "' '", "+", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r' \\d\\d\\d'", ",", "''", ",", "' '", "+", "text", ")", "\n", "", "text", "=", "text", ".", "replace", "(", "' '", ",", "''", ")", "\n", "text", "=", "text", ".", "strip", "(", "'_'", ")", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_division_problem": [[319, 355], ["re.search", "demonstrator.clean_position_ids", "demonstrator.clean_position_ids", "clean_position_ids.split", "clean_position_ids.split", "demonstrator.register", "re.search.group", "re.search.group", "demonstrator.register", "demonstrator.register", "int", "int"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_position_ids", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_position_ids", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register"], ["", "def", "write_division_problem", "(", "prefix", ",", "run", ",", "grid", ")", ":", "\n", "    ", "\"\"\"\n    Given the initial prefix representing the division problem to be solved,\n    return a 3-tuple consisting of:\n    - the action string consisting of the series of actions that writes the\n    division problem to the grid\n    - the divisor (int)\n    - the dividend (int)\n\n    :param str prefix: initial prefix representing the division problem to be\n                       solved\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n\n    \"\"\"", "\n", "text", "=", "' write'", "\n", "pattern", "=", "r'w/h/e/n/_ (.*?)/_/i/s/_/d/i/v/i/d/e/d/_/b/y/_ (.*?)/(\\.|\\?)'", ".", "replace", "(", "r'/'", ",", "r' \\d\\d\\d '", ")", "\n", "\n", "m", "=", "re", ".", "search", "(", "pattern", ",", "prefix", ")", "\n", "dividend_str", "=", "clean_position_ids", "(", "m", ".", "group", "(", "1", ")", ")", "\n", "divisor_str", "=", "clean_position_ids", "(", "m", ".", "group", "(", "2", ")", ")", "\n", "dividend_tokens", "=", "dividend_str", ".", "split", "(", ")", "\n", "divisor_tokens", "=", "divisor_str", ".", "split", "(", ")", "\n", "\n", "x", "=", "START_X", "\n", "y", "=", "START_Y", "\n", "to_coord", "=", "run", ".", "to_coord", "\n", "for", "token", "in", "divisor_tokens", ":", "\n", "        ", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "token", ",", "run", ")", "\n", "x", "+=", "1", "\n", "", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "'\u017f'", ",", "run", ")", "\n", "x", "+=", "1", "\n", "for", "token", "in", "dividend_tokens", ":", "\n", "        ", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "token", ",", "run", ")", "\n", "x", "+=", "1", "\n", "", "return", "(", "text", ",", "int", "(", "''", ".", "join", "(", "divisor_tokens", ")", ")", ",", "int", "(", "''", ".", "join", "(", "dividend_tokens", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.spacify": [[357, 368], ["str", "out_string.strip"], "function", ["None"], ["", "def", "spacify", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Given a number or string, return a string that contains all of the\n    digits/characters of the original, but separated by spaces. The result\n    neither begins nor ends with a space.\n    \"\"\"", "\n", "s", "=", "str", "(", "x", ")", "\n", "out_string", "=", "''", "\n", "for", "char", "in", "s", ":", "\n", "        ", "out_string", "+=", "char", "+", "' '", "\n", "", "return", "out_string", ".", "strip", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_n_spaces": [[370, 386], ["range", "demonstrator.look_at"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at"], ["", "def", "look_from_coord_n_spaces", "(", "x", ",", "y", ",", "n", ",", "run", ",", "grid", ")", ":", "\n", "    ", "\"\"\"\n    Return a portion of an action string that represents where we are currently\n    'looking'. Start at (x, y), and continue going towards the right, reading a\n    total of n characters.\n\n    :param int n: number of characters to read\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    \"\"\"", "\n", "look_str", "=", "''", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "look_str", "+=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "x", "+=", "1", "\n", "", "return", "look_str", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol": [[388, 413], ["demonstrator.look_at", "demonstrator.look_at"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at"], ["", "def", "look_from_coord_to_symbol", "(", "x", ",", "y", ",", "symbol", ",", "run", ",", "grid", ")", ":", "\n", "    ", "\"\"\"\n    Return a portion of an action string that represents where we are currently\n    'looking'. Start at (x, y), and continue going towards the right until you\n    see `symbol`. If you never see `symbol`, then stop as soon as: you see\n    nothing at all (underscore) AND you have looked at more than one tile.\n\n    :param int x: x-coordinate of start location\n    :param int y: y-coordinate of start location\n    :param str symbol: symbol to stop at\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    \"\"\"", "\n", "look_str", "=", "''", "\n", "look_str", "+=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "count", "=", "1", "\n", "while", "True", ":", "\n", "        ", "if", "grid", "[", "(", "x", ",", "y", ")", "]", "==", "symbol", "and", "count", ">", "1", ":", "\n", "            ", "break", "\n", "", "if", "grid", "[", "(", "x", ",", "y", ")", "]", "==", "'_'", "and", "count", ">", "1", ":", "\n", "            ", "break", "\n", "", "count", "+=", "1", "\n", "x", "+=", "1", "\n", "look_str", "+=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "", "return", "x", ",", "look_str", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at_divisor": [[414, 432], ["str", "demonstrator.look_at"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at"], ["", "def", "look_at_divisor", "(", "divisor", ",", "grid", ",", "run", ")", ":", "\n", "    ", "\"\"\"\n    Return a 3-tuple consisting of:\n    - x-coordinate just after end of the divisor\n    - y-coordinate just after end of the divisor\n    - portion of an action string that represents looking at each digit in the divisor\n\n    :param int divisor: the divisor\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    \"\"\"", "\n", "x", "=", "0", "\n", "y", "=", "2", "\n", "look_str", "=", "''", "\n", "for", "c", "in", "str", "(", "divisor", ")", ":", "\n", "        ", "look_str", "+=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "x", "+=", "1", "\n", "", "return", "(", "x", ",", "y", ",", "look_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.trim_blanks": [[433, 448], ["re.sub", "re.sub", "re.sub", "re.sub"], "function", ["None"], ["", "def", "trim_blanks", "(", "lookstr", ",", "run", ")", ":", "\n", "    ", "\"\"\"\n    Return version of `lookstr` having trimmed underscores from beginning and\n    end (e.g., having trimmed underscores from the output of look_from_coord_to_symbol).\n\n    :param str lookstr: a string corresponding to a 'look' action\n    :param RunParams run: configuration of this training/validation/test run\n    \"\"\"", "\n", "if", "(", "run", ".", "text_tag_style", "==", "TextTag", ".", "NONE", ")", ":", "\n", "        ", "lookstr", "=", "re", ".", "sub", "(", "r'^( _)*'", ",", "''", ",", "lookstr", ")", "\n", "lookstr", "=", "re", ".", "sub", "(", "r'( _)*$'", ",", "''", ",", "lookstr", ")", "\n", "", "else", ":", "\n", "        ", "lookstr", "=", "re", ".", "sub", "(", "r'^( \\d\\d,\\d\\d(:\\d\\d\\d)? _)*'", ",", "''", ",", "lookstr", ")", "\n", "lookstr", "=", "re", ".", "sub", "(", "r'( \\d\\d,\\d\\d(:\\d\\d\\d)? _)*$'", ",", "''", ",", "lookstr", ")", "\n", "", "return", "lookstr", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_interim_remainder": [[449, 613], ["demonstrator.register", "range", "range", "demonstrator.look_from_coord_to_symbol", "len", "demonstrator.register", "demonstrator.look_at", "demonstrator.look_at", "demonstrator.get_comparison_narration", "demonstrator.look_at", "demonstrator.look_at", "len", "len", "len", "len", "value1.isdigit", "int", "value2.isdigit", "int", "demonstrator.register", "demonstrator.register", "demonstrator.clean", "demonstrator.register", "demonstrator.look_from_coord_to_symbol", "demonstrator.clean", "demonstrator.look_at", "str", "str", "demonstrator.register", "int", "demonstrator.register", "demonstrator.spacify", "demonstrator.spacify", "demonstrator.register", "str", "int", "int"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_comparison_narration", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.spacify", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.spacify", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register"], ["", "def", "write_interim_remainder", "(", "text", ",", "gm_str", ",", "divisor", ",", "dividend", ",", "number_str", ",", "run", ",", "grid", ",", "number_x", ",", "number_y", ",", "quotient_x", ")", ":", "\n", "    ", "\"\"\"\n    Add to `text` the action substring for the part of a division problem that\n    computes an 'interim remainder' - which may be the final remainder if there\n    are no further numbers to 'pull down' from the dividend.\n    If there is a further digit to pull down, return (text, number, number_x,\n    number_y, quotient_x), where 'text' is the text of the action substring,\n    number is the the new number that the divisor needs to go into (created by\n    doing the subtraction problem and pulling down the next digit), number_x &\n    number_y are its x and y coordinates, and quotient_x is the x-coordinate of\n    the digit of the quotient we most recently updated.\n    If there is no further digit to pull down, meaning that the remainder\n    computed is the final one, then return (text, None, None, None, None,\n    str_remainder).\n\n    :param str text: action string so far\n    :param str gm_str: greatest multiple of the divisor that is less than int(number_str)\n    :param int divisor: main divisor\n    :param int dividend: main dividend\n    :param str number_str: the current number to divide into\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    :param int number_x: x-coordinate of number_str\n    :param int number_y: y-coordinate of number_str\n    :param int quotient_x: x-coordinate of the most recently updated digit of the quotient\n    \"\"\"", "\n", "\n", "# Write the minus sign and the greatest common multiple in the locations", "\n", "# they need to be to set up the subtraction problem", "\n", "\n", "x", "=", "number_x", "-", "1", "\n", "y", "=", "number_y", "+", "1", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "'-'", ",", "run", ")", "\n", "\n", "x", "=", "number_x", "+", "(", "len", "(", "number_str", ")", "-", "len", "(", "gm_str", ")", ")", "\n", "original_last_digit_x", "=", "x", "+", "len", "(", "gm_str", ")", "\n", "y", "=", "number_y", "+", "1", "\n", "text", "+=", "' write'", "\n", "for", "i", "in", "range", "(", "x", ",", "x", "+", "len", "(", "gm_str", ")", ")", ":", "\n", "        ", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "i", ",", "y", ",", "gm_str", "[", "i", "-", "x", "]", ",", "run", ")", "\n", "\n", "# All set up - we can start to subtract.", "\n", "", "x", "=", "x", "+", "len", "(", "gm_str", ")", "-", "1", "\n", "y", "=", "number_y", "\n", "\n", "while", "True", ":", "\n", "        ", "value1", "=", "grid", "[", "(", "x", ",", "y", ")", "]", "\n", "look1", "=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "y", "+=", "1", "\n", "value2", "=", "grid", "[", "(", "x", ",", "y", ")", "]", "\n", "look2", "=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "\n", "answer_x", "=", "x", "# keeping track for easy reference in the future", "\n", "answer_y", "=", "y", "+", "1", "\n", "\n", "if", "(", "value1", "==", "'_'", "or", "value2", "==", "'-'", ")", ":", "\n", "            ", "break", "\n", "\n", "", "value1", "=", "int", "(", "value1", ")", "if", "value1", ".", "isdigit", "(", ")", "else", "0", "\n", "value2", "=", "int", "(", "value2", ")", "if", "value2", ".", "isdigit", "(", ")", "else", "0", "\n", "text", "+=", "get_comparison_narration", "(", "look1", ",", "look2", ",", "value1", ",", "value2", ",", "False", ")", "\n", "if", "value1", "<", "value2", ":", "\n", "            ", "text", "+=", "' { borrow a 1 }'", "\n", "y", "-=", "1", "\n", "while", "True", ":", "\n", "                ", "x", "-=", "1", "\n", "look_to_borrow", "=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "# We should never run off the edge of the left side of the", "\n", "# subtraction problem when borrowing a 1:", "\n", "assert", "(", "grid", "[", "(", "x", ",", "y", ")", "]", "!=", "'_'", ")", "\n", "if", "run", ".", "look", ":", "\n", "                    ", "text", "+=", "' look'", "+", "look_to_borrow", "\n", "", "if", "grid", "[", "(", "x", ",", "y", ")", "]", "==", "'0'", ":", "\n", "                    ", "text", "+=", "' { change 0 to 9 }'", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "'9'", ",", "run", ")", "\n", "", "elif", "grid", "[", "(", "x", ",", "y", ")", "]", "in", "'123456789'", ":", "\n", "                    ", "text", "+=", "f' {{ {grid[(x, y)]} - 1 = {int(grid[(x, y)]) - 1} }}'", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "str", "(", "int", "(", "grid", "[", "(", "x", ",", "y", ")", "]", ")", "-", "1", ")", ",", "run", ")", "\n", "break", "\n", "\n", "", "", "text", "+=", "f' {{ {spacify(value1 + 10)} - {value2} = {value1 + 10 - value2} }}'", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "answer_x", ",", "answer_y", ",", "str", "(", "value1", "+", "10", "-", "value2", ")", ",", "run", ")", "\n", "", "else", ":", "\n", "            ", "text", "+=", "f' {{ {value1} - {value2} = {value1 - value2} }}'", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "answer_x", ",", "answer_y", ",", "str", "(", "value1", "-", "value2", ")", ",", "run", ")", "\n", "\n", "", "x", "=", "answer_x", "-", "1", "\n", "y", "=", "answer_y", "-", "2", "\n", "\n", "# At this point we should have our answer. Time to either", "\n", "# - report our result (remainder) as the answer, if there is not a next digit to pull down; or", "\n", "# - pull down the next digit, and return the new 'number' that the divisor needs to go into,", "\n", "#   if there is a next digit to pull down.", "\n", "# First, if there are any leading zeros in the answer, erase them.", "\n", "# This should hopefully also help GPT establish where the interim remainder begins.", "\n", "\n", "", "y", "=", "y", "+", "1", "\n", "interim_remainder_x", "=", "x", "\n", "interim_remainder_y", "=", "y", "\n", "\n", "x_offset", "=", "0", "\n", "for", "x_i", "in", "range", "(", "x", "+", "1", ",", "original_last_digit_x", "+", "1", ")", ":", "\n", "        ", "look_next_digit", "=", "look_at", "(", "grid", ",", "x_i", ",", "y", ",", "run", ")", "\n", "if", "run", ".", "look", ":", "\n", "            ", "text", "+=", "' look'", "+", "look_next_digit", "\n", "\n", "", "if", "grid", "[", "(", "x_i", ",", "y", ")", "]", "in", "'123456789'", ":", "\n", "            ", "interim_remainder_x", "=", "x_i", "\n", "break", "\n", "", "elif", "grid", "[", "(", "x_i", ",", "y", ")", "]", "==", "'0'", ":", "\n", "            ", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x_i", ",", "y", ",", "'_'", ",", "run", ")", "\n", "", "elif", "grid", "[", "(", "x_i", ",", "y", ")", "]", "==", "'_'", ":", "\n", "# We might see this condition if the answer", "\n", "# is ALL zeros (because there was no remainder), and we run", "\n", "# through all of them to emerge on the other side", "\n", "            ", "interim_remainder_x", "=", "x_i", "-", "1", "\n", "x_offset", "+=", "1", "\n", "\n", "", "", "text", "+=", "' { read the answer }'", "\n", "\n", "x", ",", "look_answer", "=", "look_from_coord_to_symbol", "(", "interim_remainder_x", ",", "y", ",", "'_'", ",", "run", ",", "grid", ")", "\n", "\n", "if", "run", ".", "look", ":", "\n", "        ", "text", "+=", "' look'", "+", "look_answer", "\n", "\n", "# This next bit is a loop just in case we need to pull down multiple digits -", "\n", "# we'll break out of it as soon as the new number exceeds the divisor", "\n", "", "while", "True", ":", "\n", "\n", "# Is there a next digit to pull down?", "\n", "        ", "look_next_digit", "=", "look_at", "(", "grid", ",", "x", ",", "START_Y", ",", "run", ")", "\n", "if", "run", ".", "look", ":", "\n", "            ", "text", "+=", "' look'", "+", "look_next_digit", "\n", "\n", "", "if", "(", "grid", "[", "(", "x", ",", "START_Y", ")", "]", "==", "'_'", ")", ":", "\n", "# If not, we have our answer, report it!", "\n", "            ", "remainder_str", "=", "clean", "(", "look_answer", ")", "\n", "if", "remainder_str", "==", "''", ":", "\n", "                ", "remainder_str", "=", "'0'", "\n", "", "text", "+=", "f' {{ final remainder is {spacify(remainder_str)} }}'", "\n", "return", "(", "text", ",", "None", ",", "None", ",", "None", ",", "None", ",", "remainder_str", ")", "\n", "", "else", ":", "\n", "# If so:", "\n", "# - pull down the next digit", "\n", "# - figure out the next 'number'", "\n", "# - Is the result larger than the divisor?", "\n", "#    If so, return the number (and the x, y coordinates of its first digit)", "\n", "#    If not, try to pull down another number, repeating this whole little", "\n", "#    loop at the end", "\n", "\n", "            ", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "grid", "[", "(", "x", ",", "START_Y", ")", "]", ",", "run", ")", "\n", "_", ",", "look_answer", "=", "look_from_coord_to_symbol", "(", "interim_remainder_x", "+", "x_offset", ",", "interim_remainder_y", ",", "'_'", ",", "run", ",", "grid", ")", "\n", "\n", "number_str", "=", "clean", "(", "look_answer", ")", "\n", "number", "=", "0", "if", "number_str", "==", "''", "else", "int", "(", "number_str", ")", "\n", "\n", "return", "(", "text", ",", "number_str", ",", "interim_remainder_x", "+", "x_offset", ",", "interim_remainder_y", ",", "quotient_x", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_greatest_multiple": [[614, 771], ["int", "demonstrator.register", "str", "demonstrator.look_at_divisor", "demonstrator.register", "demonstrator.register", "str", "range", "demonstrator.look_from_coord_to_symbol", "int", "int", "demonstrator.get_comparison_narration", "demonstrator.register", "demonstrator.look_at", "demonstrator.look_at", "demonstrator.register", "demonstrator.register", "demonstrator.clean", "demonstrator.look_from_coord_n_spaces", "demonstrator.look_from_coord_to_symbol", "demonstrator.clean", "demonstrator.look_from_coord_to_symbol", "demonstrator.clean", "demonstrator.look_at", "demonstrator.register", "len", "len", "value1.isdigit", "int", "value2.isdigit", "int", "str", "len", "str", "str", "str", "str", "demonstrator.spacify", "demonstrator.spacify", "demonstrator.spacify"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at_divisor", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_comparison_narration", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_n_spaces", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_at", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.register", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.spacify", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.spacify", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.spacify"], ["", "", "", "def", "write_greatest_multiple", "(", "text", ",", "divisor", ",", "dividend", ",", "number_str", ",", "run", ",", "grid", ",", "\n", "quotient_x", ",", "number_x", ",", "number_y", ",", "first_call", ")", ":", "\n", "    ", "\"\"\"\n    Return a 2-tuple containing the\n    - action substring that corresponds to finding the greatest multiple of the\n      divisor that is less than int(number_str)\n    - this greatest multiple (as a string)\n    Involves a lot of addition in the scratch area.\n\n    :param str text: action string so far\n    :param int divisor: main divisor\n    :param int dividend: main dividend\n    :param str number_str: the number to divide into (as string)\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    :param int quotient_x: x-coordinate of the most recently updated digit of\n                           the quotient\n    :param int number_x: x-coordinate of number_str\n    :param int number_y: y-coordinate of number_str\n    :param bool first_call: is this the first time this function is being called\n                            during this division problem?\n    \"\"\"", "\n", "\n", "number", "=", "int", "(", "number_str", ")", "\n", "\n", "# Start by putting down a tentative quotient of 0", "\n", "quotient_y", "=", "1", "\n", "quotient", "=", "0", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "quotient_x", ",", "quotient_y", ",", "str", "(", "quotient", ")", ",", "run", ")", "\n", "\n", "# ************************************************", "\n", "# Do repeated addition, increasing the quotient so long as we are less than 'number'", "\n", "# ************************************************", "\n", "\n", "# - Add the divisor to itself. Start by just writing the initial addition problem", "\n", "text", "+=", "' clear'", "\n", "\n", "if", "run", ".", "look", ":", "\n", "        ", "x", ",", "y", ",", "look_str", "=", "look_at_divisor", "(", "divisor", ",", "grid", ",", "run", ")", "\n", "text", "+=", "' look'", "+", "look_str", "\n", "text", "+=", "' write'", "\n", "\n", "", "x", "=", "70", "\n", "y", "=", "0", "\n", "\n", "for", "c", "in", "(", "'_'", "*", "(", "len", "(", "str", "(", "divisor", ")", ")", "-", "1", ")", ")", "+", "'0'", ":", "\n", "        ", "x", "+=", "1", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "c", ",", "run", ")", "\n", "\n", "", "x", "=", "70", "\n", "y", "=", "1", "\n", "\n", "while", "True", ":", "\n", "        ", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "'+'", ",", "run", ")", "\n", "carry_the_1", "=", "False", "\n", "\n", "# Position divisor properly", "\n", "x", "=", "70", "\n", "\n", "for", "c", "in", "str", "(", "divisor", ")", ":", "\n", "            ", "x", "+=", "1", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "c", ",", "run", ")", "\n", "\n", "# - Next, solve the addition problem", "\n", "", "for", "i", "in", "range", "(", "len", "(", "str", "(", "divisor", ")", ")", "+", "1", ")", ":", "\n", "            ", "y", "-=", "1", "\n", "value1", "=", "grid", "[", "(", "x", ",", "y", ")", "]", "\n", "look1", "=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "y", "+=", "1", "\n", "look2", "=", "look_at", "(", "grid", ",", "x", ",", "y", ",", "run", ")", "\n", "value2", "=", "grid", "[", "(", "x", ",", "y", ")", "]", "\n", "if", "run", ".", "look", ":", "\n", "                ", "text", "+=", "' look'", "+", "look1", "+", "look2", "\n", "\n", "", "if", "(", "value2", "==", "'+'", ")", ":", "\n", "                ", "break", "\n", "\n", "", "value1", "=", "int", "(", "value1", ")", "if", "value1", ".", "isdigit", "(", ")", "else", "0", "\n", "value2", "=", "int", "(", "value2", ")", "if", "value2", ".", "isdigit", "(", ")", "else", "0", "\n", "value_sum", "=", "value1", "+", "value2", "\n", "\n", "text", "+=", "f' {{{look1 if run.narrate_positions else value1}'", "+", "f' +{look2 if run.narrate_positions else value2} = {spacify(value1 + value2)} }}'", "\n", "if", "carry_the_1", ":", "\n", "                ", "text", "+=", "f' {{ {spacify(value1 + value2)} + 1 = {spacify(value1 + value2 + 1)} }}'", "\n", "value_sum", "+=", "1", "\n", "\n", "", "y", "+=", "1", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "str", "(", "value_sum", "%", "10", ")", ",", "run", ")", "\n", "\n", "if", "(", "value_sum", ">=", "10", ")", ":", "\n", "                ", "carry_the_1", "=", "True", "\n", "text", "+=", "' { carry the 1 }'", "\n", "", "else", ":", "\n", "                ", "carry_the_1", "=", "False", "\n", "", "x", "-=", "1", "\n", "y", "-=", "1", "\n", "\n", "# We have now observed that we are at the edge of the addition problem", "\n", "# -- having observed a _ and a + -- and it is time to wrap up", "\n", "", "if", "carry_the_1", ":", "\n", "            ", "text", "+=", "' { 0 + 0 = 0 } { 0 + 1 = 1 }'", "\n", "y", "+=", "1", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "x", ",", "y", ",", "'1'", ",", "run", ")", "\n", "", "else", ":", "\n", "            ", "text", "+=", "' { 0 + 0 = 0 }'", "\n", "y", "+=", "1", "\n", "\n", "# ************************************************", "\n", "# Compare: is the result greater than 'number'?", "\n", "# ************************************************", "\n", "\n", "# Look at the result", "\n", "", "_", ",", "look_result", "=", "look_from_coord_to_symbol", "(", "x", ",", "y", ",", "'_'", ",", "run", ",", "grid", ")", "\n", "result", "=", "int", "(", "clean", "(", "look_result", ")", ")", "\n", "\n", "# Look at the number we're comparing against", "\n", "if", "first_call", ":", "\n", "            ", "look_number", "=", "look_from_coord_n_spaces", "(", "number_x", ",", "number_y", ",", "len", "(", "str", "(", "number", ")", ")", ",", "run", ",", "grid", ")", "\n", "", "else", ":", "\n", "# the other branch doesn't work when there's a 0 in front", "\n", "# (but there never will be when first_call is true)", "\n", "            ", "_", ",", "look_number", "=", "look_from_coord_to_symbol", "(", "number_x", ",", "number_y", ",", "'_'", ",", "run", ",", "grid", ")", "\n", "\n", "", "number", "=", "int", "(", "clean", "(", "look_number", ")", ")", "\n", "\n", "text", "+=", "get_comparison_narration", "(", "look_result", ",", "look_number", ",", "result", ",", "number", ",", "True", ")", "\n", "\n", "# If result > number, stop and return the greatest multiple that is less than 'number'", "\n", "if", "(", "result", ">", "number", ")", ":", "\n", "            ", "y", "-=", "2", "\n", "_", ",", "look_greatest_multiple", "=", "look_from_coord_to_symbol", "(", "x", ",", "y", ",", "'_'", ",", "run", ",", "grid", ")", "\n", "if", "run", ".", "look", ":", "\n", "                ", "text", "+=", "' look'", "+", "look_greatest_multiple", "\n", "", "gm_str", "=", "clean", "(", "look_greatest_multiple", ")", "\n", "return", "text", ",", "gm_str", "\n", "", "else", ":", "\n", "# Otherwise, increment the quotient", "\n", "            ", "look_quotient", "=", "look_at", "(", "grid", ",", "quotient_x", ",", "quotient_y", ",", "run", ")", "\n", "if", "run", ".", "look", ":", "\n", "                ", "text", "+=", "' look'", "+", "look_quotient", "\n", "", "text", "+=", "f' {{{look_quotient if run.narrate_positions else quotient} + 1 = { quotient + 1 } }}'", "\n", "quotient", "+=", "1", "\n", "text", "+=", "' write'", "\n", "text", ",", "grid", "=", "register", "(", "text", ",", "grid", ",", "quotient_x", ",", "quotient_y", ",", "str", "(", "quotient", ")", ",", "run", ")", "\n", "\n", "# Position the cursor to be ready to write a plus sign, and let the", "\n", "# loop take its course", "\n", "# (prepare to keep adding the divisor until result > number)", "\n", "if", "carry_the_1", ":", "\n", "# if the sum was one digit longer than the inputs, then move", "\n", "# the plus sign for the next problem a space to the left", "\n", "                ", "x", "-=", "1", "\n", "", "y", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_first_subproblem": [[773, 811], ["len", "demonstrator.look_from_coord_to_symbol", "int", "demonstrator.look_from_coord_n_spaces", "demonstrator.get_comparison_narration", "str", "int", "demonstrator.look_from_coord_n_spaces", "demonstrator.get_comparison_narration", "str", "str"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_to_symbol", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_n_spaces", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_comparison_narration", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.look_from_coord_n_spaces", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.get_comparison_narration"], ["", "", "", "def", "write_first_subproblem", "(", "text", ",", "divisor", ",", "dividend", ",", "run", ",", "grid", ")", ":", "\n", "    ", "\"\"\"\n    Execute the steps at the very beginning of solving a division problem,\n    specifically those above and including the first diamond in Camos & Baumer\n    (2015) Fig 3: if N starts as the number of digits in the divisor, see if the\n    N leftmost digits in the dividend are larger than the divisor; if not, keep\n    add 1 to N and repeat. Return a 2-tuple consisting of\n\n    - the action string given in `text` + the actions to accomplish the above\n    - the N leftmost digits in the dividend, for first N that yields a number\n      larger than the divisor (as int)\n\n    :param str text: action string so far\n    :param int divisor: main divisor\n    :param int dividend: main dividend\n    :param RunParams run: configuration of this training/validation/test run\n    :param defaultdict grid: mapping from coords to the symbols located at them\n    \"\"\"", "\n", "\n", "n", "=", "len", "(", "str", "(", "divisor", ")", ")", "# 'N = number of digits in divisor'", "\n", "\n", "divisor_end", ",", "look_divisor", "=", "look_from_coord_to_symbol", "(", "0", ",", "START_Y", ",", "'\u017f'", ",", "run", ",", "grid", ")", "# look at divisor", "\n", "\n", "number", "=", "int", "(", "str", "(", "dividend", ")", "[", ":", "n", "]", ")", "# 'Number = N leftmost digits in dividend'", "\n", "\n", "dividend_start", "=", "divisor_end", "+", "1", "\n", "look_number", "=", "look_from_coord_n_spaces", "(", "dividend_start", ",", "START_Y", ",", "n", ",", "run", ",", "grid", ")", "# look at N leftmost digits in dividend", "\n", "\n", "text", "+=", "get_comparison_narration", "(", "look_divisor", ",", "look_number", ",", "divisor", ",", "number", ",", "True", ")", "\n", "while", "(", "number", "<", "divisor", ")", ":", "\n", "        ", "n", "+=", "1", "\n", "number", "=", "int", "(", "str", "(", "dividend", ")", "[", ":", "n", "]", ")", "\n", "look_number", "=", "look_from_coord_n_spaces", "(", "dividend_start", ",", "START_Y", ",", "n", ",", "run", ",", "grid", ")", "# look at N leftmost digits in dividend", "\n", "if", "run", ".", "look", ":", "\n", "            ", "text", "+=", "' look'", "+", "look_number", "\n", "\n", "", "text", "+=", "get_comparison_narration", "(", "look_divisor", ",", "look_number", ",", "divisor", ",", "number", ",", "True", ")", "\n", "", "return", "(", "text", ",", "number", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.label_positions_by_word": [[813, 835], ["cue.split", "prefix_tokens.extend", "prefix_tokens.extend", "enumerate", "str"], "function", ["None"], ["", "def", "label_positions_by_word", "(", "cue", ",", "prefix_pid_style", ")", ":", "\n", "    ", "\"\"\"\n    Return a list consisting of the cue split out character by character,\n    interspersed with position indicators; position indicators represent\n    position from beginning of word. This is the scheme referenced in the paper:\n    \"a format that explicitly labels the position of each character within each\n    word (\u201c201 W 202 h 203 a 204 t 200 _ 201 i 202 s 200 _ \u2026\u201d), in order to\n    circumvent the drawbacks of the default position embeddings and tokenizer.\n\n   :params str cue: string to split out character by character and to\n                    intersperse with position indicators\n    :params PrefixPID prefix_pid_style: 'Position ID' scheme to use for the\n                                        prefix (see PrefixPID class)\n    \"\"\"", "\n", "words", "=", "cue", ".", "split", "(", ")", "\n", "prefix_tokens", "=", "[", "]", "\n", "for", "word", "in", "words", ":", "\n", "        ", "if", "prefix_pid_style", "==", "PrefixPID", ".", "BY_WORD", ":", "\n", "            ", "prefix_tokens", ".", "extend", "(", "[", "str", "(", "i", "+", "200", ")", "+", "' '", "+", "x", "for", "i", ",", "x", "in", "enumerate", "(", "word", ",", "1", ")", "]", ")", "\n", "prefix_tokens", ".", "extend", "(", "[", "'200'", ",", "'_'", "]", ")", "\n", "\n", "", "", "return", "prefix_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.elaborate": [[837, 907], ["collections.defaultdict", "demonstrator.write_division_problem", "demonstrator.write_first_subproblem", "str", "demonstrator.write_greatest_multiple", "demonstrator.write_interim_remainder", "len", "len", "len", "demonstrator.write_greatest_multiple", "demonstrator.write_interim_remainder", "demonstrator.clean_position_ids", "demonstrator.clean_coordinates", "demonstrator.clean_position_ids", "demonstrator.label_positions_by_word", "str", "str", "enumerate", "str().zfill", "cue.replace", "str"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_division_problem", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_first_subproblem", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_greatest_multiple", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_interim_remainder", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_greatest_multiple", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.write_interim_remainder", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_position_ids", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_coordinates", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_position_ids", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.label_positions_by_word"], ["", "def", "elaborate", "(", "cue", ",", "target", ",", "run", ",", "exclude_answer", ")", ":", "\n", "    ", "\"\"\"\n    Given a cue (math problem to be answered) and a target, elaborate the cue by\n    preprocessing the it to address the limitations of the positional encoding\n    vectors, and constructing an action string to help GPT-Neo learn how to get\n    from the cue to the answer. Return this action string.\n\n    :param str cue: the math problem to be answered\n    :param str target: desired answer\n    :param RunParams run: configuration of this training/validation/test run\n   :param bool exclude_answer: whether to output the preprocessed prefix +\n                               action string or just the prefix (i.e. for\n                               generating test files)\n    \"\"\"", "\n", "\n", "# Write out the cue character by character, interspersed with position indicators", "\n", "if", "run", ".", "prefix_pid_style", "==", "PrefixPID", ".", "BY_CHAR", ":", "\n", "# Position indicators represent position from beginning of prefix", "\n", "        ", "prefix_tokens", "=", "[", "str", "(", "i", ")", ".", "zfill", "(", "2", ")", "+", "' '", "+", "x", "for", "i", ",", "x", "in", "enumerate", "(", "cue", ".", "replace", "(", "' '", ",", "'_'", ")", ")", "]", "\n", "", "elif", "run", ".", "prefix_pid_style", "==", "PrefixPID", ".", "BY_WORD", ":", "\n", "# Position indicators represent position from beginning of word", "\n", "        ", "prefix_tokens", "=", "label_positions_by_word", "(", "cue", ",", "run", ".", "prefix_pid_style", ")", "\n", "\n", "", "prefix", "=", "(", "'\\u00ec'", "*", "run", ".", "endcap_length", ")", "+", "' '", "+", "(", "' '", ".", "join", "(", "prefix_tokens", ")", ")", "\n", "prefix", "+=", "' |'", "\n", "\n", "# Write out the division problem", "\n", "grid", "=", "defaultdict", "(", "lambda", ":", "'_'", ")", "# mapping from coords to the symbols located at them", "\n", "text", ",", "divisor", ",", "dividend", "=", "write_division_problem", "(", "prefix", ",", "run", ",", "grid", ")", "\n", "\n", "### First subproblem ###", "\n", "\n", "# Execute the steps above and including the first diamond in Camos & Baumer Fig 3", "\n", "text", ",", "number", "=", "write_first_subproblem", "(", "text", ",", "divisor", ",", "dividend", ",", "run", ",", "grid", ")", "\n", "number_str", "=", "str", "(", "number", ")", "\n", "\n", "# First addition", "\n", "quotient_x", "=", "len", "(", "str", "(", "divisor", ")", ")", "+", "len", "(", "number_str", ")", "\n", "number_x", "=", "len", "(", "str", "(", "divisor", ")", ")", "+", "1", "\n", "number_y", "=", "START_Y", "\n", "text", ",", "gm_str", "=", "write_greatest_multiple", "(", "text", ",", "divisor", ",", "dividend", ",", "number_str", ",", "run", ",", "grid", ",", "\n", "quotient_x", ",", "number_x", ",", "number_y", ",", "first_call", "=", "True", ")", "\n", "\n", "# First subtraction", "\n", "text", ",", "number_str", ",", "number_x", ",", "number_y", ",", "quotient_x", ",", "remainder", "=", "write_interim_remainder", "(", "text", ",", "gm_str", ",", "divisor", ",", "dividend", ",", "number_str", ",", "run", ",", "grid", ",", "number_x", ",", "number_y", ",", "quotient_x", ")", "\n", "\n", "# Continue on until we solve the problem", "\n", "while", "number_str", "is", "not", "None", ":", "\n", "        ", "quotient_x", "+=", "1", "\n", "text", ",", "gm_str", "=", "write_greatest_multiple", "(", "text", ",", "divisor", ",", "dividend", ",", "number_str", ",", "run", ",", "grid", ",", "\n", "quotient_x", ",", "number_x", ",", "number_y", ",", "first_call", "=", "False", ")", "\n", "text", ",", "number_str", ",", "number_x", ",", "number_y", ",", "quotient_x", ",", "remainder", "=", "write_interim_remainder", "(", "text", ",", "gm_str", ",", "divisor", ",", "dividend", ",", "number_str", ",", "run", ",", "grid", ",", "number_x", ",", "number_y", ",", "quotient_x", ")", "\n", "\n", "\n", "# Verify that the target equals the remainder", "\n", "", "assert", "(", "target", "==", "remainder", ")", ";", "\n", "\n", "# Finish up", "\n", "if", "not", "run", ".", "prefix_pid_style", ":", "\n", "        ", "prefix", "=", "clean_position_ids", "(", "prefix", ")", "\n", "", "if", "not", "run", ".", "coordinates", ":", "\n", "        ", "text", "=", "clean_coordinates", "(", "text", ")", "\n", "", "if", "not", "run", ".", "text_tag_style", ":", "\n", "        ", "text", "=", "clean_position_ids", "(", "text", ")", "\n", "", "if", "exclude_answer", ":", "\n", "        ", "return", "prefix", "\n", "", "else", ":", "\n", "        ", "return", "prefix", "+", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_narration": [[909, 922], ["input_filename.replace", "open", "open", "out_file.write", "re.search", "line.replace.replace", "re.search.group", "re.search.group"], "function", ["None"], ["", "", "def", "clean_narration", "(", "input_filename", ")", ":", "\n", "    ", "assert", "(", "'N+'", "in", "input_filename", ")", "\n", "output_filename", "=", "input_filename", ".", "replace", "(", "'N+'", ",", "'+'", ")", "\n", "\n", "with", "open", "(", "formatted_path", "+", "input_filename", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "with", "open", "(", "formatted_path", "+", "output_filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "            ", "for", "line", "in", "in_file", ":", "\n", "                ", "while", "True", ":", "\n", "                    ", "match", "=", "re", ".", "search", "(", "r'\\s+\\{.*?\\}\\s+'", ",", "line", ")", "\n", "if", "(", "not", "match", ")", "or", "(", "'final remainder'", "in", "match", ".", "group", "(", "0", ")", ")", ":", "\n", "                        ", "break", "\n", "", "line", "=", "line", ".", "replace", "(", "match", ".", "group", "(", "0", ")", ",", "' '", ")", "\n", "", "out_file", ".", "write", "(", "line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_looks": [[923, 936], ["input_filename.replace", "open", "open", "out_file.write", "re.search", "line.replace.replace", "re.search.group"], "function", ["None"], ["", "", "", "", "def", "clean_looks", "(", "input_filename", ")", ":", "\n", "    ", "assert", "(", "'L+'", "in", "input_filename", ")", "\n", "output_filename", "=", "input_filename", ".", "replace", "(", "'L+'", ",", "'W'", ")", "\n", "\n", "with", "open", "(", "formatted_path", "+", "input_filename", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "with", "open", "(", "formatted_path", "+", "output_filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "            ", "for", "line", "in", "in_file", ":", "\n", "                ", "while", "True", ":", "\n", "                    ", "match", "=", "re", ".", "search", "(", "r'look (\\d\\d,\\d\\d:\\d\\d\\d . )+'", ",", "line", ")", "\n", "if", "(", "not", "match", ")", ":", "\n", "                        ", "break", "\n", "", "line", "=", "line", ".", "replace", "(", "match", ".", "group", "(", "0", ")", ",", "''", ",", "1", ")", "\n", "", "out_file", ".", "write", "(", "line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.clean_writing": [[939, 954], ["input_filename.replace", "open", "open", "line.replace.replace", "line.replace.replace", "out_file.write", "re.search", "line.replace.replace", "re.search.group"], "function", ["None"], ["", "", "", "", "def", "clean_writing", "(", "input_filename", ")", ":", "\n", "    ", "assert", "(", "'W'", "in", "input_filename", ")", "\n", "output_filename", "=", "input_filename", ".", "replace", "(", "'W'", ",", "''", ")", "\n", "\n", "with", "open", "(", "formatted_path", "+", "input_filename", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "with", "open", "(", "formatted_path", "+", "output_filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "            ", "for", "line", "in", "in_file", ":", "\n", "                ", "while", "True", ":", "\n", "                    ", "match", "=", "re", ".", "search", "(", "r'write (\\d\\d,\\d\\d:\\d\\d\\d . )+'", ",", "line", ")", "\n", "if", "(", "not", "match", ")", ":", "\n", "                        ", "break", "\n", "", "line", "=", "line", ".", "replace", "(", "match", ".", "group", "(", "0", ")", ",", "''", ",", "1", ")", "\n", "", "line", "=", "line", ".", "replace", "(", "'clear '", ",", "''", ")", "\n", "line", "=", "line", ".", "replace", "(", "'write '", ",", "''", ")", "\n", "out_file", ".", "write", "(", "line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.elaborate_file": [[956, 990], ["open", "open", "enumerate", "line.strip.strip", "line.strip.partition", "demonstrator.elaborate", "out_file.write"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.elaborate"], ["", "", "", "", "def", "elaborate_file", "(", "input_filename", ",", "output_filename", ",", "run", ",", "max_examples", ",", "exclude_answer", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Given an input file, elaborate all the cues within it by preprocessing the\n    prefix on each line to address the limitations of the positional encoding\n    vectors, and constructing an action string to help GPT-Neo learn how to get\n    from the prefix to the answer. Write the results to `output_filename`.\n    Intended to be called by generate_training_and_validation and generate_test.\n\n    :param str input_filename: file to read\n    :param str output_filename: file to write\n    :param RunParams run: RunParams with configuration of this run\n    :param int max_examples: maximum number of examples (lines) to read from\n                             input_filename\n    :param bool exclude_answer: whether to output the preprocessed prefix +\n                                action string or just the prefix (i.e. for\n                                generating test files)\n    :return: None\n    \"\"\"", "\n", "\n", "with", "open", "(", "input_filename", ",", "'r'", ")", "as", "in_file", ":", "\n", "        ", "with", "open", "(", "output_filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "\n", "            ", "for", "i", ",", "line", "in", "enumerate", "(", "in_file", ")", ":", "\n", "                ", "if", "i", ">=", "max_examples", ":", "\n", "                    ", "break", "\n", "\n", "", "line", "=", "line", ".", "strip", "(", ")", "\n", "if", "line", "!=", "''", ":", "\n", "                    ", "partitioned", "=", "line", ".", "partition", "(", "'|'", ")", "\n", "\n", "cue", "=", "partitioned", "[", "0", "]", "\n", "target", "=", "partitioned", "[", "2", "]", "\n", "text", "=", "elaborate", "(", "cue", ",", "target", ",", "run", ",", "exclude_answer", ")", "\n", "out_file", ".", "write", "(", "text", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.generate_training_and_validation": [[991, 1017], ["print", "demonstrator.elaborate_file", "print", "demonstrator.elaborate_file"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.elaborate_file", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.elaborate_file"], ["", "", "", "", "", "def", "generate_training_and_validation", "(", "output_filename_prefix", ",", "run", ")", ":", "\n", "    ", "\"\"\"\n    Create elaborated training and validation files by reading in the\n    unelaborated training file train_{QUESTION_TYPE}.txt, and the unelaborated\n    validation file validation_{QUESTION_TYPE}.txt, and writing out elaborated\n    versions. In the title of the output files, include a little code\n    corresponding to the particular configuration settings represented by the\n    RunParams object `run`.\n\n    :param str output_filename_prefix: prefix to prepend to names of output files\n    :param RunParams run: configuration of this training/validation/test run\n    :return: None\n    \"\"\"", "\n", "\n", "print", "(", "f'Generating training data for {output_filename_prefix + run.code}...'", ")", "\n", "\n", "elaborate_file", "(", "input_filename", "=", "originals_path", "+", "'train_'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "\n", "output_filename", "=", "formatted_path", "+", "output_filename_prefix", "+", "run", ".", "code", "+", "'_training.txt'", ",", "\n", "run", "=", "run", ",", "max_examples", "=", "run", ".", "max_train_examples", ")", "\n", "\n", "\n", "print", "(", "f'Generating validation data for {output_filename_prefix + run.code}...'", ")", "\n", "\n", "elaborate_file", "(", "input_filename", "=", "originals_path", "+", "'validation_'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "\n", "output_filename", "=", "formatted_path", "+", "output_filename_prefix", "+", "'_validation.txt'", ",", "\n", "run", "=", "run", ",", "max_examples", "=", "run", ".", "max_validation_examples", ",", "exclude_answer", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.generate_test": [[1019, 1041], ["print", "range", "demonstrator.elaborate_file"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.demonstrator.elaborate_file"], ["", "def", "generate_test", "(", "output_filename_prefix", ",", "distribution_prefix", ",", "run", ",", "test_id_list", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Create elaborated test files by reading in unelaborated test files, and\n    writing out elaborated versions. In the title of the output files, include a\n    little code corresponding to the particular configuration settings\n    represented by the RunParams object `run`.\n\n    :param str output_filename_prefix: prefix to prepend to names of output files\n    :param str distribution_prefix: 'samedist' or 'interpolated'\n    :param RunParams run: configuration of this training/validation/test run\n    :param it test_id_list: an iterable of test ids to read in. Default is range(5)\n    :return: None\n    \"\"\"", "\n", "print", "(", "f'Generating test data for {output_filename_prefix + run.code} ({distribution_prefix})...'", ")", "\n", "\n", "if", "test_id_list", "is", "None", ":", "\n", "        ", "test_id_list", "=", "range", "(", "5", ")", "\n", "\n", "", "for", "i", "in", "test_id_list", ":", "\n", "        ", "elaborate_file", "(", "input_filename", "=", "f'{originals_path}{distribution_prefix}test_{QUESTION_TYPE}_set{i}.txt'", ",", "\n", "output_filename", "=", "f'{formatted_path}{output_filename_prefix}_{distribution_prefix}testset{i}.txt'", ",", "\n", "run", "=", "run", ",", "max_examples", "=", "run", ".", "max_test_examples", ",", "exclude_answer", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.load_training_set": [[37, 49], ["set", "open", "set.add"], "function", ["None"], ["def", "load_training_set", "(", "n", ")", ":", "\n", "    ", "\"\"\" Return a set containing the first n examples of the training set. \"\"\"", "\n", "training_set", "=", "set", "(", ")", "\n", "\n", "with", "open", "(", "math_path", "+", "'train_'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "i", "=", "0", "\n", "for", "line", "in", "in_file", ":", "\n", "            ", "if", "i", "==", "n", ":", "\n", "                ", "break", "\n", "", "training_set", ".", "add", "(", "line", ")", "\n", "i", "+=", "1", "\n", "", "", "return", "training_set", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.get_digit_distribution": [[50, 69], ["collections.defaultdict", "collections.defaultdict", "open", "max", "re.search", "collections.defaultdict.keys", "range", "range", "len", "len", "re.search.group", "re.search.group"], "function", ["None"], ["", "def", "get_digit_distribution", "(", "input_path", ")", ":", "\n", "    ", "\"\"\"\n    Return a string that contains the distribution of divisor and\n    dividend lengths of the problems in the file given by `input_path`.\n    \"\"\"", "\n", "\n", "divisor_lengths", "=", "defaultdict", "(", "int", ")", "\n", "dividend_lengths", "=", "defaultdict", "(", "int", ")", "\n", "\n", "with", "open", "(", "input_path", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "for", "line", "in", "in_file", ":", "\n", "            ", "m", "=", "re", ".", "search", "(", "r'when (\\d+) is divided by (\\d+)(\\.|\\?)\\|(\\d+)'", ",", "line", ")", "\n", "divisor_lengths", "[", "len", "(", "m", ".", "group", "(", "1", ")", ")", "]", "+=", "1", "\n", "dividend_lengths", "[", "len", "(", "m", ".", "group", "(", "2", ")", ")", "]", "+=", "1", "\n", "", "", "upper", "=", "max", "(", "divisor_lengths", ".", "keys", "(", ")", ")", "+", "1", "\n", "divisor_strings", "=", "[", "f'{x}: {divisor_lengths[x]}'", "for", "x", "in", "range", "(", "1", ",", "upper", ")", "]", "\n", "dividend_strings", "=", "[", "f'{x}: {dividend_lengths[x]}'", "for", "x", "in", "range", "(", "1", ",", "upper", ")", "]", "\n", "return", "'divisor lengths\\n'", "+", "'\\n'", ".", "join", "(", "divisor_strings", ")", "+", "'\\ndividend lengths\\n'", "+", "'\\n'", ".", "join", "(", "dividend_strings", ")", "+", "'\\n'", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.inspect_digit_distributions": [[70, 86], ["open", "out_file.write", "out_file.write", "out_file.write", "out_file.write", "out_file.write", "out_file.write", "out_file.write", "out_file.write", "format_benchmarks.get_digit_distribution", "format_benchmarks.get_digit_distribution", "format_benchmarks.get_digit_distribution", "format_benchmarks.get_digit_distribution"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.get_digit_distribution", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.get_digit_distribution", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.get_digit_distribution", "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.get_digit_distribution"], ["", "def", "inspect_digit_distributions", "(", ")", ":", "\n", "    ", "\"\"\"\n    Write a file named 'digit_distributions.txt' (in math_path) that contains\n    the digit distributions of the 'easy', 'medium', 'hard', and interpolated\n    test questions of type QUESTIONTYPE from the DeepMind Mathematics dataset.\n    \"\"\"", "\n", "\n", "with", "open", "(", "math_path", "+", "'digit_distributions.txt'", ",", "'w'", ")", "as", "out_file", ":", "\n", "        ", "out_file", ".", "write", "(", "'Easy\\n'", ")", "\n", "out_file", ".", "write", "(", "get_digit_distribution", "(", "f'{math_path}easy_{QUESTION_TYPE}.txt'", ")", ")", "\n", "out_file", ".", "write", "(", "'Medium\\n'", ")", "\n", "out_file", ".", "write", "(", "get_digit_distribution", "(", "f'{math_path}medium_{QUESTION_TYPE}.txt'", ")", ")", "\n", "out_file", ".", "write", "(", "'Hard\\n'", ")", "\n", "out_file", ".", "write", "(", "get_digit_distribution", "(", "f'{math_path}hard_{QUESTION_TYPE}.txt'", ")", ")", "\n", "out_file", ".", "write", "(", "'Interpolated\\n'", ")", "\n", "out_file", ".", "write", "(", "get_digit_distribution", "(", "f'{math_path}test_{QUESTION_TYPE}.txt'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.flatten_file": [[87, 107], ["open", "open", "enumerate", "out_file.write", "input.strip", "last_question.strip"], "function", ["None"], ["", "", "def", "flatten_file", "(", "input_path", ",", "output_path", ")", ":", "\n", "    ", "\"\"\"\n    Convert a file from the DeepMind Mathematics Dataset format in which every\n    even line has questions and every odd line has answers to a file where every\n    line has a question, a vertical pipe, and an answer.\n\n    :param str input_path: Input filename with path\n    :param str output_path: Output filename with path\n    \"\"\"", "\n", "\n", "with", "open", "(", "input_path", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "with", "open", "(", "output_path", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "            ", "for", "i", ",", "input", "in", "enumerate", "(", "in_file", ")", ":", "\n", "\n", "                ", "if", "i", "%", "2", "==", "0", ":", "\n", "# Every even line has questions", "\n", "                    ", "last_question", "=", "input", "\n", "", "else", ":", "\n", "# Every odd line has answers", "\n", "                    ", "out_file", ".", "write", "(", "last_question", ".", "strip", "(", ")", "+", "'|'", "+", "input", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.flatten_test_file": [[109, 117], ["format_benchmarks.flatten_file"], "function", ["home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.flatten_file"], ["", "", "", "", "", "def", "flatten_test_file", "(", ")", ":", "\n", "    ", "\"\"\"\n    Generate a 'flattened' version of the original 'interpolated' test set from\n    the DeepMind mathematics dataset e.g., a file where each line consists of a\n    question, a vertical pipe, and an answer\n    \"\"\"", "\n", "flatten_file", "(", "math_path", "+", "'interpolate/'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "\n", "math_path", "+", "'test_'", "+", "QUESTION_TYPE", "+", "'.txt'", ")", ";", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.extract_interpolated_test_set": [[118, 136], ["random.seed", "set", "open", "open", "out_file.writelines", "len", "set.add", "random.randint"], "function", ["None"], ["", "def", "extract_interpolated_test_set", "(", "training_set", ",", "seed", ",", "n", ",", "set_id", ")", ":", "\n", "    ", "\"\"\"\n    Extract a test set - ** using data from original 'interpolated' test set **\n    - of size n using the given random seed; write to file with set_id in its\n    name. Relies on the 'flattened' version of this test set generated by\n    flatten_test_file.\n    \"\"\"", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "test_set", "=", "set", "(", ")", "\n", "\n", "with", "open", "(", "math_path", "+", "f'test_{QUESTION_TYPE}.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "lines", "=", "[", "line", "for", "line", "in", "in_file", "]", "\n", "with", "open", "(", "math_path", "+", "f'interpolatedtest_{QUESTION_TYPE}_set{set_id}.txt'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "            ", "while", "len", "(", "test_set", ")", "<", "n", ":", "\n", "                ", "instance", "=", "lines", "[", "random", ".", "randint", "(", "0", ",", "INTERPOLATED_MAX_INSTANCES", "-", "1", ")", "]", "\n", "if", "not", "instance", "in", "training_set", ":", "\n", "                    ", "test_set", ".", "add", "(", "instance", ")", "\n", "", "", "out_file", ".", "writelines", "(", "test_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.extract_same_distribution_test_set": [[139, 161], ["random.seed", "set", "open", "open", "open", "open", "out_file.writelines", "len", "random.choice", "set.add", "random.randint"], "function", ["None"], ["", "", "", "def", "extract_same_distribution_test_set", "(", "training_set", ",", "seed", ",", "n", ",", "set_id", ")", ":", "\n", "    ", "\"\"\"\n    Extract a test set - ** using data from same distribution as the training\n    distribution ** - of size n using the given random seed; write to file with\n    set_id in its name.\n    \"\"\"", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "test_set", "=", "set", "(", ")", "\n", "\n", "with", "open", "(", "math_path", "+", "f'easy_{QUESTION_TYPE}.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "easy_file", ":", "\n", "        ", "with", "open", "(", "math_path", "+", "f'medium_{QUESTION_TYPE}.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "medium_file", ":", "\n", "            ", "with", "open", "(", "math_path", "+", "f'hard_{QUESTION_TYPE}.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "hard_file", ":", "\n", "                ", "easy_lines", "=", "[", "line", "for", "line", "in", "easy_file", "]", "\n", "medium_lines", "=", "[", "line", "for", "line", "in", "medium_file", "]", "\n", "hard_lines", "=", "[", "line", "for", "line", "in", "hard_file", "]", "\n", "with", "open", "(", "math_path", "+", "f'samedisttest_{QUESTION_TYPE}_set{set_id}.txt'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "                    ", "while", "len", "(", "test_set", ")", "<", "n", ":", "\n", "                        ", "lines", "=", "random", ".", "choice", "(", "[", "easy_lines", ",", "medium_lines", ",", "hard_lines", "]", ")", "\n", "instance", "=", "lines", "[", "random", ".", "randint", "(", "0", ",", "SAMEDIST_MAX_INSTANCES", "-", "1", ")", "]", "\n", "if", "not", "instance", "in", "training_set", ":", "\n", "                            ", "test_set", ".", "add", "(", "instance", ")", "\n", "", "", "out_file", ".", "writelines", "(", "test_set", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.interleave_training_files": [[163, 189], ["open", "open", "open", "open", "open", "enumerate", "zip", "range", "out_file.write", "inputs[].strip", "last_questions[].strip"], "function", ["None"], ["", "", "", "", "", "def", "interleave_training_files", "(", ")", ":", "\n", "    ", "\"\"\"\n    Generate training and validation data with an equal number of questions\n    drawn from train-easy, train-medium, and train-hard. Analogous to the method\n    said to be used in https://github.com/deepmind/mathematics_dataset - its\n    README states 'Note the training data for each question type is split into\n    \"train-easy\", \"train-medium\", and \"train-hard\". This allows training models\n    via a curriculum. The data can also be mixed together uniformly from these\n    training datasets to obtain the results reported in the paper.'\n    \"\"\"", "\n", "with", "open", "(", "math_path", "+", "'train-easy/'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "easy_file", ":", "\n", "        ", "with", "open", "(", "math_path", "+", "'train-medium/'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "medium_file", ":", "\n", "            ", "with", "open", "(", "math_path", "+", "'train-hard/'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "hard_file", ":", "\n", "                ", "with", "open", "(", "math_path", "+", "'train_'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "train_file", ":", "\n", "                    ", "with", "open", "(", "math_path", "+", "'validation_'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "validation_file", ":", "\n", "                        ", "out_file", "=", "train_file", "\n", "for", "i", ",", "inputs", "in", "enumerate", "(", "zip", "(", "easy_file", ",", "medium_file", ",", "hard_file", ")", ")", ":", "\n", "                            ", "if", "i", "%", "2", "==", "0", ":", "\n", "# Every even line has questions", "\n", "                                ", "last_questions", "=", "inputs", "\n", "", "else", ":", "\n", "# Every odd line has answers", "\n", "                                ", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "                                    ", "out_file", ".", "write", "(", "last_questions", "[", "j", "]", ".", "strip", "(", ")", "+", "'|'", "+", "inputs", "[", "j", "]", ".", "strip", "(", ")", "+", "'\\n'", ")", "\n", "", "", "if", "i", "==", "VALIDATION_START_LINE", ":", "\n", "                                ", "out_file", "=", "validation_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mesotron_teaching_transformers.remainder.format_benchmarks.generate_transcription_benchmark": [[191, 208], ["open", "open", "enumerate", "line.partition", "re.search", "out_file.write", "str", "re.search.group", "re.search.group"], "function", ["None"], ["", "", "", "", "", "", "", "", "def", "generate_transcription_benchmark", "(", "count", ")", ":", "\n", "    ", "\"\"\"\n    Generate a benchmark for grading the success of the initial transcription only\n    :param int count: Number of examples to include in the benchmark\n    \"\"\"", "\n", "output_filename", "=", "math_path", "+", "'validate-transcriptions_'", "+", "str", "(", "count", ")", "+", "'_'", "+", "QUESTION_TYPE", "+", "'.txt'", "\n", "with", "open", "(", "math_path", "+", "'validation_'", "+", "QUESTION_TYPE", "+", "'.txt'", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", "as", "in_file", ":", "\n", "        ", "with", "open", "(", "output_filename", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "out_file", ":", "\n", "            ", "for", "i", ",", "line", "in", "enumerate", "(", "in_file", ")", ":", "\n", "                ", "if", "(", "i", "==", "count", ")", ":", "\n", "                    ", "break", "\n", "", "tokens", "=", "line", ".", "partition", "(", "'|'", ")", "\n", "tokens", "[", "0", "]", "\n", "\n", "m", "=", "re", ".", "search", "(", "r'when (.*?) is divided by (.*?)(\\.|\\?)'", ",", "tokens", "[", "0", "]", ")", "\n", "desired_transcription", "=", "m", ".", "group", "(", "2", ")", "+", "'\u017f'", "+", "m", ".", "group", "(", "1", ")", "\n", "out_file", ".", "write", "(", "tokens", "[", "0", "]", "+", "'|'", "+", "desired_transcription", "+", "'\\n'", ")", "\n", "\n"]]}