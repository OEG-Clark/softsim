{"home.repos.pwc.inspect_result.oravus_seqNet.None.main.save_checkpoint": [[69, 74], ["os.path.join", "torch.save", "shutil.copyfile", "os.path.join"], "function", ["None"], ["def", "save_checkpoint", "(", "state", ",", "is_best", ",", "filename", "=", "'checkpoint.pth.tar'", ")", ":", "\n", "    ", "model_out_path", "=", "join", "(", "opt", ".", "savePath", ",", "filename", ")", "\n", "torch", ".", "save", "(", "state", ",", "model_out_path", ")", "\n", "if", "is_best", ":", "\n", "        ", "shutil", ".", "copyfile", "(", "model_out_path", ",", "join", "(", "opt", ".", "savePath", ",", "'model_best.pth.tar'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.get_models.Flatten.forward": [[9, 11], ["input.view", "input.size"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", ".", "view", "(", "input", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.get_models.L2Norm.__init__": [[13, 16], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.get_models.L2Norm.forward": [[17, 19], ["torch.normalize", "torch.normalize", "torch.normalize", "torch.normalize"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "F", ".", "normalize", "(", "input", ",", "p", "=", "2", ",", "dim", "=", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.get_models.get_model": [[20, 90], ["torch.Module", "Exception", "opt.pooling.lower", "torch.AdaptiveAvgPool2d", "model.to.add_module", "model.to.to", "opt.mode.lower", "torch.TripletMarginLoss().to", "os.path.isfile", "opt.pooling.lower", "Exception", "torch.Sequential", "opt.pooling.lower", "seqNet.seqNet", "model.to.add_module", "opt.optim.upper", "torch.Adam", "opt.ckpt.lower", "os.path.join", "print", "torch.load", "torch.load", "torch.load", "torch.load", "model.to.load_state_dict", "model.to.to", "print", "print", "opt.pooling.lower", "torch.Sequential", "opt.pooling.lower", "seqNet.seqNet", "model.to.add_module", "filter", "opt.optim.upper", "torch.SGD", "torch.lr_scheduler.StepLR", "ValueError", "torch.TripletMarginLoss", "opt.ckpt.lower", "os.path.join", "optim.SGD.load_state_dict", "torch.Sequential", "opt.pooling.lower", "seqNet.Delta", "model.to.add_module", "model.to.parameters", "filter", "get_models.Flatten", "get_models.L2Norm", "torch.Sequential", "opt.pooling.lower", "torch.AdaptiveAvgPool2d", "model.to.add_module", "model.to.parameters", "get_models.Flatten", "get_models.L2Norm", "torch.Sequential", "opt.pooling.lower", "model.to.add_module", "ValueError", "get_models.Flatten", "get_models.L2Norm", "torch.Sequential", "get_models.L2Norm", "get_models.Flatten", "get_models.L2Norm", "get_models.L2Norm"], "function", ["None"], ["", "", "def", "get_model", "(", "opt", ",", "encoder_dim", ",", "device", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Module", "(", ")", "\n", "\n", "if", "opt", ".", "seqL", "==", "1", "and", "opt", ".", "pooling", ".", "lower", "(", ")", "not", "in", "[", "'single'", ",", "'seqnet'", "]", ":", "\n", "        ", "raise", "Exception", "(", "\"For sequential matching/pooling, set seqL > 1\"", ")", "\n", "", "elif", "opt", ".", "seqL", "!=", "1", "and", "opt", ".", "pooling", ".", "lower", "(", ")", "in", "[", "'single'", "]", ":", "\n", "        ", "raise", "Exception", "(", "\"For single frame based evaluation, set seqL = 1\"", ")", "\n", "\n", "", "if", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'smooth'", ":", "\n", "        ", "global_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "None", ")", ")", "\n", "model", ".", "add_module", "(", "'pool'", ",", "nn", ".", "Sequential", "(", "*", "[", "global_pool", ",", "Flatten", "(", ")", ",", "L2Norm", "(", ")", "]", ")", ")", "\n", "", "elif", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'seqnet'", ":", "\n", "        ", "seqFt", "=", "seqNet", ".", "seqNet", "(", "encoder_dim", ",", "opt", ".", "outDims", ",", "opt", ".", "seqL", ",", "opt", ".", "w", ")", "\n", "model", ".", "add_module", "(", "'pool'", ",", "nn", ".", "Sequential", "(", "*", "[", "seqFt", ",", "Flatten", "(", ")", ",", "L2Norm", "(", ")", "]", ")", ")", "\n", "", "elif", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'s1+seqmatch'", ":", "\n", "        ", "seqFt", "=", "seqNet", ".", "seqNet", "(", "encoder_dim", ",", "opt", ".", "outDims", ",", "1", ",", "opt", ".", "w", ")", "\n", "model", ".", "add_module", "(", "'pool'", ",", "nn", ".", "Sequential", "(", "*", "[", "seqFt", ",", "Flatten", "(", ")", ",", "L2Norm", "(", ")", "]", ")", ")", "\n", "", "elif", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'delta'", ":", "\n", "        ", "deltaFt", "=", "seqNet", ".", "Delta", "(", "inDims", "=", "encoder_dim", ",", "seqL", "=", "opt", ".", "seqL", ")", "\n", "model", ".", "add_module", "(", "'pool'", ",", "nn", ".", "Sequential", "(", "*", "[", "deltaFt", ",", "L2Norm", "(", ")", "]", ")", ")", "\n", "", "elif", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'single'", ":", "\n", "        ", "single", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "opt", ".", "seqL", ",", "None", ")", ")", "# shoud have no effect", "\n", "model", ".", "add_module", "(", "'pool'", ",", "nn", ".", "Sequential", "(", "*", "[", "single", ",", "Flatten", "(", ")", ",", "L2Norm", "(", ")", "]", ")", ")", "\n", "", "elif", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'single+seqmatch'", ":", "\n", "\n", "        ", "model", ".", "add_module", "(", "'pool'", ",", "nn", ".", "Sequential", "(", "*", "[", "L2Norm", "(", "dim", "=", "-", "1", ")", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unknown pooling type: '", "+", "opt", ".", "pooling", ")", "\n", "\n", "", "if", "not", "opt", ".", "resume", ":", "\n", "        ", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "", "scheduler", ",", "optimizer", ",", "criterion", "=", "None", ",", "None", ",", "None", "\n", "if", "opt", ".", "mode", ".", "lower", "(", ")", "==", "'train'", ":", "\n", "        ", "if", "opt", ".", "optim", ".", "upper", "(", ")", "==", "'ADAM'", ":", "\n", "            ", "optimizer", "=", "optim", ".", "Adam", "(", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "\n", "model", ".", "parameters", "(", ")", ")", ",", "lr", "=", "opt", ".", "lr", ")", "#, betas=(0,0.9))", "\n", "", "elif", "opt", ".", "optim", ".", "upper", "(", ")", "==", "'SGD'", ":", "\n", "            ", "optimizer", "=", "optim", ".", "SGD", "(", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "\n", "model", ".", "parameters", "(", ")", ")", ",", "lr", "=", "opt", ".", "lr", ",", "\n", "momentum", "=", "opt", ".", "momentum", ",", "\n", "weight_decay", "=", "opt", ".", "weightDecay", ")", "\n", "\n", "scheduler", "=", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "step_size", "=", "opt", ".", "lrStep", ",", "gamma", "=", "opt", ".", "lrGamma", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown optimizer: '", "+", "opt", ".", "optim", ")", "\n", "\n", "", "criterion", "=", "nn", ".", "TripletMarginLoss", "(", "margin", "=", "opt", ".", "margin", "**", "0.5", ",", "p", "=", "2", ",", "reduction", "=", "'sum'", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "if", "opt", ".", "resume", ":", "\n", "        ", "if", "opt", ".", "ckpt", ".", "lower", "(", ")", "==", "'latest'", ":", "\n", "            ", "resume_ckpt", "=", "join", "(", "opt", ".", "resume", ",", "'checkpoints'", ",", "'checkpoint.pth.tar'", ")", "\n", "", "elif", "opt", ".", "ckpt", ".", "lower", "(", ")", "==", "'best'", ":", "\n", "            ", "resume_ckpt", "=", "join", "(", "opt", ".", "resume", ",", "'checkpoints'", ",", "'model_best.pth.tar'", ")", "\n", "\n", "", "if", "isfile", "(", "resume_ckpt", ")", ":", "\n", "            ", "print", "(", "\"=> loading checkpoint '{}'\"", ".", "format", "(", "resume_ckpt", ")", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "resume_ckpt", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "opt", ".", "start_epoch", "=", "checkpoint", "[", "'epoch'", "]", "\n", "best_metric", "=", "checkpoint", "[", "'best_score'", "]", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "if", "opt", ".", "mode", "==", "'train'", ":", "\n", "                ", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "", "print", "(", "\"=> loaded checkpoint '{}' (epoch {})\"", "\n", ".", "format", "(", "resume_ckpt", ",", "checkpoint", "[", "'epoch'", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"=> no checkpoint found at '{}'\"", ".", "format", "(", "resume_ckpt", ")", ")", "\n", "\n", "", "", "return", "model", ",", "optimizer", ",", "scheduler", ",", "criterion", "", "", ""]], "home.repos.pwc.inspect_result.oravus_seqNet.None.seqNet.seqNet.__init__": [[6, 13], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inDims", ",", "outDims", ",", "seqL", ",", "w", "=", "5", ")", ":", "\n", "\n", "        ", "super", "(", "seqNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inDims", "=", "inDims", "\n", "self", ".", "outDims", "=", "outDims", "\n", "self", ".", "w", "=", "w", "\n", "self", ".", "conv", "=", "nn", ".", "Conv1d", "(", "inDims", ",", "outDims", ",", "kernel_size", "=", "self", ".", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.seqNet.seqNet.forward": [[14, 24], ["x.unsqueeze.unsqueeze.permute", "seqNet.seqNet.conv", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "len", "x.unsqueeze.unsqueeze.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "if", "len", "(", "x", ".", "shape", ")", "<", "3", ":", "\n", "            ", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "# convert [B,C] to [B,1,C]", "\n", "\n", "", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "# from [B,T,C] to [B,C,T]", "\n", "seqFt", "=", "self", ".", "conv", "(", "x", ")", "\n", "seqFt", "=", "torch", ".", "mean", "(", "seqFt", ",", "-", "1", ")", "\n", "\n", "return", "seqFt", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.seqNet.Delta.__init__": [[26, 33], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "numpy.ones", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inDims", ",", "seqL", ")", ":", "\n", "\n", "        ", "super", "(", "Delta", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inDims", "=", "inDims", "\n", "self", ".", "weight", "=", "(", "np", ".", "ones", "(", "seqL", ",", "np", ".", "float32", ")", ")", "/", "(", "seqL", "/", "2.0", ")", "\n", "self", ".", "weight", "[", ":", "seqL", "//", "2", "]", "*=", "-", "1", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "self", ".", "weight", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.seqNet.Delta.forward": [[34, 41], ["x.permute.permute.permute", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "# make desc dim as C", "\n", "        ", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "# makes [B,T,C] as [B,C,T]", "\n", "delta", "=", "torch", ".", "matmul", "(", "x", ",", "self", ".", "weight", ")", "\n", "\n", "return", "delta", "\n", "", "", ""]], "home.repos.pwc.inspect_result.oravus_seqNet.None.train.train": [[11, 105], ["range", "print", "writer.add_scalar", "math.ceil", "numpy.array_split", "print", "model.eval", "torch.utils.data.dataset.Subset", "torch.utils.data.DataLoader", "print", "print", "model.train", "tqdm.tqdm", "len", "optimizer.zero_grad", "torch.cuda.empty_cache", "os.remove", "numpy.arange", "numpy.arange", "h5py.File", "h5.create_dataset", "torch.cuda.memory_allocated", "torch.cuda.memory_reserved", "enumerate", "torch.sum", "torch.cat().float", "input.to.to", "model.pool", "torch.split", "optimizer.zero_grad", "enumerate", "torch.sum.float().to", "loss.backward", "optimizer.step", "loss.item", "len", "len", "len", "len", "opt.pooling.lower", "torch.no_grad", "tqdm.tqdm", "len", "range", "print", "writer.add_scalar", "writer.add_scalar", "print", "print", "len", "enumerate", "input.to.float().to", "model.pool", "model.pool.detach().cpu().numpy", "torch.cat", "criterion", "torch.sum.float", "torch.cuda.memory_allocated", "torch.cuda.memory_cached", "len", "input.to.float", "model.pool.detach().cpu", "indices.detach().numpy", "torch.sum", "model.pool.detach", "indices.detach"], "function", ["home.repos.pwc.inspect_result.oravus_seqNet.None.train.train"], ["def", "train", "(", "opt", ",", "model", ",", "encoder_dim", ",", "device", ",", "dataset", ",", "criterion", ",", "optimizer", ",", "train_set", ",", "whole_train_set", ",", "whole_training_data_loader", ",", "epoch", ",", "writer", ")", ":", "\n", "    ", "epoch_loss", "=", "0", "\n", "startIter", "=", "1", "# keep track of batch iter across subsets for logging", "\n", "\n", "if", "opt", ".", "cacheRefreshRate", ">", "0", ":", "\n", "        ", "subsetN", "=", "ceil", "(", "len", "(", "train_set", ")", "/", "opt", ".", "cacheRefreshRate", ")", "\n", "#TODO randomise the arange before splitting?", "\n", "subsetIdx", "=", "np", ".", "array_split", "(", "np", ".", "arange", "(", "len", "(", "train_set", ")", ")", ",", "subsetN", ")", "\n", "", "else", ":", "\n", "        ", "subsetN", "=", "1", "\n", "subsetIdx", "=", "[", "np", ".", "arange", "(", "len", "(", "train_set", ")", ")", "]", "\n", "\n", "", "nBatches", "=", "(", "len", "(", "train_set", ")", "+", "opt", ".", "batchSize", "-", "1", ")", "//", "opt", ".", "batchSize", "\n", "\n", "for", "subIter", "in", "range", "(", "subsetN", ")", ":", "\n", "        ", "print", "(", "'====> Building Cache'", ")", "\n", "model", ".", "eval", "(", ")", "\n", "with", "h5py", ".", "File", "(", "train_set", ".", "cache", ",", "mode", "=", "'w'", ")", "as", "h5", ":", "\n", "            ", "pool_size", "=", "encoder_dim", "\n", "if", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'seqnet'", ":", "\n", "                ", "pool_size", "=", "opt", ".", "outDims", "\n", "", "h5feat", "=", "h5", ".", "create_dataset", "(", "\"features\"", ",", "[", "len", "(", "whole_train_set", ")", ",", "pool_size", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "for", "iteration", ",", "(", "input", ",", "indices", ")", "in", "tqdm", "(", "enumerate", "(", "whole_training_data_loader", ",", "1", ")", ",", "total", "=", "len", "(", "whole_training_data_loader", ")", "-", "1", ",", "leave", "=", "False", ")", ":", "\n", "                    ", "image_encoding", "=", "(", "input", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "seq_encoding", "=", "model", ".", "pool", "(", "image_encoding", ")", "\n", "h5feat", "[", "indices", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", ":", "]", "=", "seq_encoding", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "del", "input", ",", "image_encoding", ",", "seq_encoding", "\n", "\n", "", "", "", "sub_train_set", "=", "Subset", "(", "dataset", "=", "train_set", ",", "indices", "=", "subsetIdx", "[", "subIter", "]", ")", "\n", "\n", "training_data_loader", "=", "DataLoader", "(", "dataset", "=", "sub_train_set", ",", "num_workers", "=", "opt", ".", "threads", ",", "\n", "batch_size", "=", "opt", ".", "batchSize", ",", "shuffle", "=", "True", ",", "\n", "collate_fn", "=", "dataset", ".", "collate_fn", ",", "pin_memory", "=", "not", "opt", ".", "nocuda", ")", "\n", "\n", "print", "(", "'Allocated:'", ",", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", ")", "\n", "print", "(", "'Cached:'", ",", "torch", ".", "cuda", ".", "memory_reserved", "(", ")", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "for", "iteration", ",", "(", "query", ",", "positives", ",", "negatives", ",", "\n", "negCounts", ",", "indices", ")", "in", "tqdm", "(", "enumerate", "(", "training_data_loader", ",", "startIter", ")", ",", "total", "=", "len", "(", "training_data_loader", ")", ",", "leave", "=", "False", ")", ":", "\n", "            ", "loss", "=", "0", "\n", "if", "query", "is", "None", ":", "\n", "                ", "continue", "# in case we get an empty batch", "\n", "\n", "", "B", "=", "query", ".", "shape", "[", "0", "]", "\n", "nNeg", "=", "torch", ".", "sum", "(", "negCounts", ")", "\n", "\n", "input", "=", "torch", ".", "cat", "(", "[", "query", ",", "positives", ",", "negatives", "]", ")", ".", "float", "(", ")", "\n", "input", "=", "input", ".", "to", "(", "device", ")", "\n", "seq_encoding", "=", "model", ".", "pool", "(", "input", ")", "\n", "\n", "seqQ", ",", "seqP", ",", "seqN", "=", "torch", ".", "split", "(", "seq_encoding", ",", "[", "B", ",", "B", ",", "nNeg", "]", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# calculate loss for each Query, Positive, Negative triplet", "\n", "# due to potential difference in number of negatives have to ", "\n", "# do it per query, per negative", "\n", "for", "i", ",", "negCount", "in", "enumerate", "(", "negCounts", ")", ":", "\n", "                ", "for", "n", "in", "range", "(", "negCount", ")", ":", "\n", "                    ", "negIx", "=", "(", "torch", ".", "sum", "(", "negCounts", "[", ":", "i", "]", ")", "+", "n", ")", ".", "item", "(", ")", "\n", "loss", "+=", "criterion", "(", "seqQ", "[", "i", ":", "i", "+", "1", "]", ",", "seqP", "[", "i", ":", "i", "+", "1", "]", ",", "seqN", "[", "negIx", ":", "negIx", "+", "1", "]", ")", "\n", "\n", "", "", "loss", "/=", "nNeg", ".", "float", "(", ")", ".", "to", "(", "device", ")", "# normalise by actual number of negatives", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "del", "input", ",", "seq_encoding", ",", "seqQ", ",", "seqP", ",", "seqN", "\n", "del", "query", ",", "positives", ",", "negatives", "\n", "\n", "batch_loss", "=", "loss", ".", "item", "(", ")", "\n", "epoch_loss", "+=", "batch_loss", "\n", "\n", "if", "iteration", "%", "50", "==", "0", "or", "nBatches", "<=", "10", ":", "\n", "                ", "print", "(", "\"==> Epoch[{}]({}/{}): Loss: {:.4f}\"", ".", "format", "(", "epoch", ",", "iteration", ",", "\n", "nBatches", ",", "batch_loss", ")", ",", "flush", "=", "True", ")", "\n", "writer", ".", "add_scalar", "(", "'Train/Loss'", ",", "batch_loss", ",", "\n", "(", "(", "epoch", "-", "1", ")", "*", "nBatches", ")", "+", "iteration", ")", "\n", "writer", ".", "add_scalar", "(", "'Train/nNeg'", ",", "nNeg", ",", "\n", "(", "(", "epoch", "-", "1", ")", "*", "nBatches", ")", "+", "iteration", ")", "\n", "print", "(", "'Allocated:'", ",", "torch", ".", "cuda", ".", "memory_allocated", "(", ")", ")", "\n", "print", "(", "'Cached:'", ",", "torch", ".", "cuda", ".", "memory_cached", "(", ")", ")", "\n", "\n", "", "", "startIter", "+=", "len", "(", "training_data_loader", ")", "\n", "del", "training_data_loader", ",", "loss", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "remove", "(", "train_set", ".", "cache", ")", "# delete HDF5 cache", "\n", "\n", "", "avg_loss", "=", "epoch_loss", "/", "nBatches", "\n", "\n", "print", "(", "\"===> Epoch {} Complete: Avg. Loss: {:.4f}\"", ".", "format", "(", "epoch", ",", "avg_loss", ")", ",", "\n", "flush", "=", "True", ")", "\n", "writer", ".", "add_scalar", "(", "'Train/AvgLoss'", ",", "avg_loss", ",", "epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.get_datasets.get_dataset": [[9, 69], ["opt.dataset.lower", "datasets.Dataset", "numpy.load", "numpy.load", "datasets.Dataset.loadPreComputedDescriptors", "opt.dataset.lower", "os.path.join", "os.path.join", "numpy.arange", "numpy.arange", "numpy.arange", "opt.dataset.lower", "datasets.Dataset", "numpy.load", "numpy.load", "numpy.load", "splitInds[].tolist", "splitInds[].tolist", "splitInds[].tolist", "datasets.Dataset.loadPreComputedDescriptors", "opt.dataset.lower", "os.path.join", "os.path.join", "opt.dataset.lower", "datasets.Dataset", "os.path.join", "itertools.product", "datasets.Dataset.loadPreComputedDescriptors", "Exception", "seqBounds_all.append", "ft_all.append", "numpy.arange", "numpy.arange", "numpy.vstack", "numpy.vstack", "numpy.loadtxt", "numpy.load", "numpy.arange", "numpy.arange", "numpy.vstack", "numpy.vstack", "os.path.join.format", "n.split"], "function", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.loadPreComputedDescriptors", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.loadPreComputedDescriptors", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.loadPreComputedDescriptors"], ["def", "get_dataset", "(", "opt", ")", ":", "\n", "\n", "    ", "if", "'nordland'", "in", "opt", ".", "dataset", ".", "lower", "(", ")", ":", "\n", "        ", "dataset", "=", "Dataset", "(", "'nordland'", ",", "'nordland_train_d-40_d2-10.db'", ",", "'nordland_test_d-1_d2-1.db'", ",", "'nordland_val_d-1_d2-1.db'", ",", "opt", ")", "# train, test, val structs", "\n", "if", "'sw'", "in", "opt", ".", "dataset", ".", "lower", "(", ")", ":", "\n", "            ", "ref", ",", "qry", "=", "'summer'", ",", "'winter'", "\n", "", "elif", "'sf'", "in", "opt", ".", "dataset", ".", "lower", "(", ")", ":", "\n", "            ", "ref", ",", "qry", "=", "'spring'", ",", "'fall'", "\n", "", "ft1", "=", "np", ".", "load", "(", "join", "(", "prefix_data", ",", "\"descData/{}/nordland-clean-{}.npy\"", ".", "format", "(", "opt", ".", "descType", ",", "ref", ")", ")", ")", "\n", "ft2", "=", "np", ".", "load", "(", "join", "(", "prefix_data", ",", "\"descData/{}/nordland-clean-{}.npy\"", ".", "format", "(", "opt", ".", "descType", ",", "qry", ")", ")", ")", "\n", "trainInds", ",", "testInds", ",", "valInds", "=", "np", ".", "arange", "(", "15000", ")", ",", "np", ".", "arange", "(", "15100", ",", "18100", ")", ",", "np", ".", "arange", "(", "18200", ",", "21200", ")", "\n", "\n", "dataset", ".", "trainInds", "=", "[", "trainInds", ",", "trainInds", "]", "\n", "dataset", ".", "valInds", "=", "[", "valInds", ",", "valInds", "]", "\n", "dataset", ".", "testInds", "=", "[", "testInds", ",", "testInds", "]", "\n", "encoder_dim", "=", "dataset", ".", "loadPreComputedDescriptors", "(", "ft1", ",", "ft2", ")", "\n", "\n", "", "elif", "'oxford'", "in", "opt", ".", "dataset", ".", "lower", "(", ")", ":", "\n", "        ", "ref", ",", "qry", "=", "'2015-03-17-11-08-44'", ",", "'2014-12-16-18-44-24'", "\n", "structStr", "=", "\"{}_{}_{}\"", ".", "format", "(", "opt", ".", "dataset", ",", "ref", ",", "qry", ")", "\n", "# note: for now temporarily use ox_test as ox_val", "\n", "if", "'v1.0'", "in", "opt", ".", "dataset", ":", "\n", "            ", "testStr", "=", "'_test_d-10_d2-5.db'", "\n", "", "elif", "'pnv'", "in", "opt", ".", "dataset", ":", "\n", "            ", "testStr", "=", "'_test_d-25_d2-5.db'", "\n", "", "dataset", "=", "Dataset", "(", "opt", ".", "dataset", ",", "structStr", "+", "'_train_d-20_d2-5.db'", ",", "structStr", "+", "testStr", ",", "structStr", "+", "testStr", ",", "opt", ")", "# train, test, val structs", "\n", "ft1", "=", "np", ".", "load", "(", "join", "(", "prefix_data", ",", "\"descData/{}/oxford_{}_stereo_left.npy\"", ".", "format", "(", "opt", ".", "descType", ",", "ref", ")", ")", ")", "\n", "ft2", "=", "np", ".", "load", "(", "join", "(", "prefix_data", ",", "\"descData/{}/oxford_{}_stereo_left.npy\"", ".", "format", "(", "opt", ".", "descType", ",", "qry", ")", ")", ")", "\n", "splitInds", "=", "np", ".", "load", "(", "\"./structFiles/{}_splitInds.npz\"", ".", "format", "(", "opt", ".", "dataset", ")", ",", "allow_pickle", "=", "True", ")", "\n", "\n", "dataset", ".", "trainInds", "=", "splitInds", "[", "'trainInds'", "]", ".", "tolist", "(", ")", "\n", "dataset", ".", "valInds", "=", "splitInds", "[", "'valInds'", "]", ".", "tolist", "(", ")", "\n", "dataset", ".", "testInds", "=", "splitInds", "[", "'testInds'", "]", ".", "tolist", "(", ")", "\n", "encoder_dim", "=", "dataset", ".", "loadPreComputedDescriptors", "(", "ft1", ",", "ft2", ")", "\n", "\n", "", "elif", "'msls'", "in", "opt", ".", "dataset", ".", "lower", "(", ")", ":", "\n", "        ", "def", "get_msls_modImgNames", "(", "names", ")", ":", "\n", "            ", "return", "[", "\"/\"", ".", "join", "(", "n", ".", "split", "(", "\"/\"", ")", "[", "8", ":", "]", ")", "for", "n", "in", "names", "]", "\n", "", "trav1", ",", "trav2", "=", "'database'", ",", "'query'", "\n", "trainCity", ",", "valCity", "=", "opt", ".", "msls_trainCity", ",", "opt", ".", "msls_valCity", "\n", "dbFileName_train", "=", "f'msls_{trainCity}_d-20_d2-5.db'", "\n", "dbFileName_val", "=", "f'msls_{valCity}_d-20_d2-5.db'", "\n", "dataset", "=", "Dataset", "(", "'msls'", ",", "dbFileName_train", ",", "dbFileName_val", ",", "dbFileName_val", ",", "opt", ")", "# train, test, val structs", "\n", "ftReadPath", "=", "join", "(", "prefix_data", ",", "\"descData/{}/msls_{}_{}.npy\"", ")", "\n", "seqBounds_all", ",", "ft_all", "=", "[", "]", ",", "[", "]", "\n", "for", "splitCity", ",", "trav", "in", "product", "(", "[", "trainCity", ",", "valCity", "]", ",", "[", "trav1", ",", "trav2", "]", ")", ":", "\n", "            ", "seqBounds_all", ".", "append", "(", "np", ".", "loadtxt", "(", "f\"./structFiles/seqBoundsFiles/msls_{splitCity}_{trav}_seqBounds.txt\"", ",", "int", ")", ")", "\n", "ft_all", ".", "append", "(", "np", ".", "load", "(", "ftReadPath", ".", "format", "(", "opt", ".", "descType", ",", "splitCity", ",", "trav", ")", ")", ")", "\n", "", "ft_train_ref", ",", "ft_train_qry", ",", "ft_val_ref", ",", "ft_val_qry", "=", "ft_all", "\n", "sb_train_ref", ",", "sb_train_qry", ",", "sb_val_ref", ",", "sb_val_qry", "=", "seqBounds_all", "\n", "dataset", ".", "trainInds", "=", "[", "np", ".", "arange", "(", "ft_train_ref", ".", "shape", "[", "0", "]", ")", ",", "np", ".", "arange", "(", "ft_train_qry", ".", "shape", "[", "0", "]", ")", "]", "# append ref & qry", "\n", "dataset", ".", "valInds", "=", "[", "ft_train_ref", ".", "shape", "[", "0", "]", "+", "np", ".", "arange", "(", "ft_val_ref", ".", "shape", "[", "0", "]", ")", ",", "ft_train_qry", ".", "shape", "[", "0", "]", "+", "np", ".", "arange", "(", "ft_val_qry", ".", "shape", "[", "0", "]", ")", "]", "# shift val by train count", "\n", "dataset", ".", "testInds", "=", "dataset", ".", "valInds", "\n", "encoder_dim", "=", "dataset", ".", "loadPreComputedDescriptors", "(", "np", ".", "vstack", "(", "[", "ft_train_ref", ",", "ft_val_ref", "]", ")", ",", "np", ".", "vstack", "(", "[", "ft_train_qry", ",", "ft_val_qry", "]", ")", ",", "[", "np", ".", "vstack", "(", "[", "sb_train_ref", ",", "sb_val_ref", "]", ")", ",", "np", ".", "vstack", "(", "[", "sb_train_qry", ",", "sb_val_qry", "]", ")", "]", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "'Unknown dataset'", ")", "\n", "\n", "", "return", "dataset", ",", "encoder_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.get_datasets.get_splits": [[71, 100], ["opt.mode.lower", "dataset.get_whole_training_set", "torch.utils.data.DataLoader", "dataset.get_training_query_set", "print", "print", "dataset.get_whole_val_set", "print", "len", "len", "opt.mode.lower", "print", "opt.split.lower", "dataset.get_whole_test_set", "print", "opt.split.lower", "dataset.get_whole_training_set", "print", "opt.split.lower", "dataset.get_whole_val_set", "print", "ValueError"], "function", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_training_set", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_training_query_set", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_val_set", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_test_set", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_training_set", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_val_set"], ["", "def", "get_splits", "(", "opt", ",", "dataset", ")", ":", "\n", "    ", "whole_train_set", ",", "whole_training_data_loader", ",", "train_set", ",", "whole_test_set", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "if", "opt", ".", "mode", ".", "lower", "(", ")", "==", "'train'", ":", "\n", "        ", "whole_train_set", "=", "dataset", ".", "get_whole_training_set", "(", ")", "\n", "whole_training_data_loader", "=", "DataLoader", "(", "dataset", "=", "whole_train_set", ",", "\n", "num_workers", "=", "opt", ".", "threads", ",", "batch_size", "=", "opt", ".", "cacheBatchSize", ",", "shuffle", "=", "False", ",", "\n", "pin_memory", "=", "not", "opt", ".", "nocuda", ")", "\n", "\n", "train_set", "=", "dataset", ".", "get_training_query_set", "(", "opt", ".", "margin", ")", "\n", "\n", "print", "(", "'====> Training whole set:'", ",", "len", "(", "whole_train_set", ")", ")", "\n", "print", "(", "'====> Training query set:'", ",", "len", "(", "train_set", ")", ")", "\n", "whole_test_set", "=", "dataset", ".", "get_whole_val_set", "(", ")", "\n", "print", "(", "'===> Evaluating on val set, query count:'", ",", "whole_test_set", ".", "dbStruct", ".", "numQ", ")", "\n", "", "elif", "opt", ".", "mode", ".", "lower", "(", ")", "==", "'test'", ":", "\n", "        ", "if", "opt", ".", "split", ".", "lower", "(", ")", "==", "'test'", ":", "\n", "            ", "whole_test_set", "=", "dataset", ".", "get_whole_test_set", "(", ")", "\n", "print", "(", "'===> Evaluating on test set'", ")", "\n", "", "elif", "opt", ".", "split", ".", "lower", "(", ")", "==", "'train'", ":", "\n", "            ", "whole_test_set", "=", "dataset", ".", "get_whole_training_set", "(", ")", "\n", "print", "(", "'===> Evaluating on train set'", ")", "\n", "", "elif", "opt", ".", "split", ".", "lower", "(", ")", "in", "[", "'val'", "]", ":", "\n", "            ", "whole_test_set", "=", "dataset", ".", "get_whole_val_set", "(", ")", "\n", "print", "(", "'===> Evaluating on val set'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown dataset split: '", "+", "opt", ".", "split", ")", "\n", "", "print", "(", "'====> Query count:'", ",", "whole_test_set", ".", "dbStruct", ".", "numQ", ")", "\n", "\n", "", "return", "whole_train_set", ",", "whole_training_data_loader", ",", "train_set", ",", "whole_test_set", "\n", "", ""]], "home.repos.pwc.inspect_result.oravus_seqNet.None.test.aggregateMatchScores": [[10, 31], ["tqdm.tqdm", "dMat_seq.detach().cpu().numpy", "torch.ones", "range", "time.time", "enumerate", "refCandidates.transpose", "torch.arange", "torch.cdist", "torch.diagonal().mean", "dMat_seq.detach().cpu", "dbDesc[].unsqueeze", "qDesc[].unsqueeze", "torch.diagonal", "dMat_seq.detach"], "function", ["None"], ["def", "aggregateMatchScores", "(", "dbDesc", ",", "qDesc", ",", "device", ",", "refCandidates", "=", "None", ")", ":", "\n", "    ", "numDb", ",", "numQ", "=", "dbDesc", ".", "shape", "[", "0", "]", ",", "qDesc", ".", "shape", "[", "0", "]", "\n", "\n", "if", "refCandidates", "is", "None", ":", "\n", "        ", "shape", "=", "[", "numDb", ",", "numQ", "]", "\n", "", "else", ":", "\n", "        ", "shape", "=", "refCandidates", ".", "transpose", "(", ")", ".", "shape", "\n", "\n", "", "dMat_seq", "=", "-", "1", "*", "torch", ".", "ones", "(", "shape", ",", "device", "=", "device", ")", "\n", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "numQ", ")", ",", "total", "=", "numQ", ",", "leave", "=", "True", ")", ":", "\n", "        ", "t1", "=", "time", ".", "time", "(", ")", "\n", "if", "refCandidates", "is", "not", "None", ":", "\n", "            ", "rCands", "=", "refCandidates", "[", "j", "]", "\n", "", "else", ":", "\n", "            ", "rCands", "=", "torch", ".", "arange", "(", "numDb", ")", "\n", "", "for", "i", ",", "r", "in", "enumerate", "(", "rCands", ")", ":", "\n", "            ", "dMat", "=", "torch", ".", "cdist", "(", "dbDesc", "[", "r", "]", ".", "unsqueeze", "(", "0", ")", ",", "qDesc", "[", "j", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "dMat_seq", "[", "i", ",", "j", "]", "=", "torch", ".", "diagonal", "(", "dMat", ",", "0", ",", "1", ",", "2", ")", ".", "mean", "(", "-", "1", ")", "\n", "\n", "", "", "return", "dMat_seq", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.test.getRecallAtN": [[32, 46], ["numpy.zeros", "enumerate", "len", "enumerate", "len", "numpy.any", "len", "numpy.in1d"], "function", ["None"], ["", "def", "getRecallAtN", "(", "n_values", ",", "predictions", ",", "gt", ")", ":", "\n", "    ", "correct_at_n", "=", "np", ".", "zeros", "(", "len", "(", "n_values", ")", ")", "\n", "numQWithoutGt", "=", "0", "\n", "#TODO can we do this on the matrix in one go?", "\n", "for", "qIx", ",", "pred", "in", "enumerate", "(", "predictions", ")", ":", "\n", "        ", "if", "len", "(", "gt", "[", "qIx", "]", ")", "==", "0", ":", "\n", "            ", "numQWithoutGt", "+=", "1", "\n", "continue", "\n", "", "for", "i", ",", "n", "in", "enumerate", "(", "n_values", ")", ":", "\n", "# if in top N then also in top NN, where NN > N", "\n", "            ", "if", "np", ".", "any", "(", "np", ".", "in1d", "(", "pred", "[", ":", "n", "]", ",", "gt", "[", "qIx", "]", ")", ")", ":", "\n", "                ", "correct_at_n", "[", "i", ":", "]", "+=", "1", "\n", "break", "\n", "", "", "", "return", "correct_at_n", "/", "(", "len", "(", "gt", ")", "-", "numQWithoutGt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.test.test": [[47, 147], ["torch.utils.data.DataLoader", "model.eval", "print", "print", "qFeat.detach().cpu().numpy().astype", "torch.empty.detach().cpu().numpy().astype", "print", "eval_set.get_positives", "scipy.spatial.distance.cdist", "test.getRecallAtN", "enumerate", "torch.no_grad", "print", "tqdm.tqdm", "numpy.mean", "numpy.std", "sklearn.manifold.TSNE().fit_transform", "sklearn.manifold.TSNE().fit_transform", "opt.pooling.lower", "print", "test.aggregateMatchScores", "[].transpose", "print", "faiss.IndexFlatL2", "faiss.IndexFlatL2.add", "faiss.IndexFlatL2.search", "rAtL.append", "print", "opt.pooling.lower", "opt.pooling.lower", "torch.empty", "torch.empty", "enumerate", "time.time", "input.reshape.float().to", "durs_batch.append", "qFeat.detach().cpu().numpy", "torch.empty.detach().cpu().numpy", "numpy.vstack", "numpy.array", "print", "max", "numpy.argwhere().flatten", "test.getRecallAtN", "writer.add_scalar", "opt.pooling.lower", "input.reshape.reshape", "model.pool().reshape", "model.pool", "opt.pooling.lower", "print", "sklearn.manifold.TSNE", "sklearn.manifold.TSNE", "numpy.load", "range", "len", "len", "len", "input.reshape.float", "len", "time.time", "qFeat.detach().cpu", "torch.empty.detach().cpu", "numpy.argsort", "numpy.arange", "numpy.argwhere", "str", "model.pool", "len", "range", "qFeat.detach", "torch.empty.detach", "max"], "function", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.WholeDatasetFromStruct.get_positives", "home.repos.pwc.inspect_result.oravus_seqNet.None.test.getRecallAtN", "home.repos.pwc.inspect_result.oravus_seqNet.None.test.aggregateMatchScores", "home.repos.pwc.inspect_result.oravus_seqNet.None.test.getRecallAtN"], ["", "def", "test", "(", "opt", ",", "model", ",", "encoder_dim", ",", "device", ",", "eval_set", ",", "writer", ",", "epoch", "=", "0", ",", "extract_noEval", "=", "False", ")", ":", "\n", "# TODO what if features dont fit in memory? ", "\n", "    ", "test_data_loader", "=", "DataLoader", "(", "dataset", "=", "eval_set", ",", "\n", "num_workers", "=", "opt", ".", "threads", ",", "batch_size", "=", "opt", ".", "cacheBatchSize", ",", "shuffle", "=", "False", ",", "\n", "pin_memory", "=", "not", "opt", ".", "nocuda", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "print", "(", "'====> Extracting Features'", ")", "\n", "pool_size", "=", "encoder_dim", "\n", "if", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'seqnet'", ":", "\n", "            ", "pool_size", "=", "opt", ".", "outDims", "\n", "", "if", "'seqmatch'", "in", "opt", ".", "pooling", ".", "lower", "(", ")", ":", "\n", "            ", "dbFeat", "=", "torch", ".", "empty", "(", "(", "len", "(", "eval_set", ")", ",", "opt", ".", "seqL", ",", "pool_size", ")", ",", "device", "=", "device", ")", "\n", "", "else", ":", "\n", "            ", "dbFeat", "=", "torch", ".", "empty", "(", "(", "len", "(", "eval_set", ")", ",", "pool_size", ")", ",", "device", "=", "device", ")", "\n", "\n", "", "durs_batch", "=", "[", "]", "\n", "for", "iteration", ",", "(", "input", ",", "indices", ")", "in", "tqdm", "(", "enumerate", "(", "test_data_loader", ",", "1", ")", ",", "total", "=", "len", "(", "test_data_loader", ")", "-", "1", ",", "leave", "=", "False", ")", ":", "\n", "            ", "t1", "=", "time", ".", "time", "(", ")", "\n", "input", "=", "input", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "if", "opt", ".", "pooling", ".", "lower", "(", ")", "==", "'s1+seqmatch'", ":", "\n", "                ", "shapeOrig", "=", "input", ".", "shape", "\n", "input", "=", "input", ".", "reshape", "(", "[", "-", "1", ",", "input", ".", "shape", "[", "-", "1", "]", "]", ")", "\n", "seq_encoding", "=", "model", ".", "pool", "(", "input", ")", ".", "reshape", "(", "shapeOrig", ")", "\n", "", "else", ":", "\n", "                ", "seq_encoding", "=", "model", ".", "pool", "(", "input", ")", "\n", "", "if", "'seqmatch'", "in", "opt", ".", "pooling", ".", "lower", "(", ")", ":", "\n", "                ", "dbFeat", "[", "indices", ",", ":", ",", ":", "]", "=", "seq_encoding", "\n", "", "else", ":", "\n", "                ", "dbFeat", "[", "indices", ",", ":", "]", "=", "seq_encoding", "\n", "", "if", "iteration", "%", "50", "==", "0", "or", "len", "(", "test_data_loader", ")", "<=", "10", ":", "\n", "                ", "print", "(", "\"==> Batch ({}/{})\"", ".", "format", "(", "iteration", ",", "\n", "len", "(", "test_data_loader", ")", ")", ",", "flush", "=", "True", ")", "\n", "", "durs_batch", ".", "append", "(", "time", ".", "time", "(", ")", "-", "t1", ")", "\n", "del", "input", "\n", "", "", "del", "test_data_loader", "\n", "print", "(", "\"Average batch time:\"", ",", "np", ".", "mean", "(", "durs_batch", ")", ",", "np", ".", "std", "(", "durs_batch", ")", ")", "\n", "\n", "# extracted for both db and query, now split in own sets", "\n", "qFeat", "=", "dbFeat", "[", "eval_set", ".", "dbStruct", ".", "numDb", ":", "]", "\n", "dbFeat", "=", "dbFeat", "[", ":", "eval_set", ".", "dbStruct", ".", "numDb", "]", "\n", "print", "(", "dbFeat", ".", "shape", ",", "qFeat", ".", "shape", ")", "\n", "\n", "qFeat_np", "=", "qFeat", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "'float32'", ")", "\n", "dbFeat_np", "=", "dbFeat", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "'float32'", ")", "\n", "\n", "db_emb", ",", "q_emb", "=", "None", ",", "None", "\n", "if", "opt", ".", "numSamples2Project", "!=", "-", "1", "and", "writer", "is", "not", "None", ":", "\n", "        ", "db_emb", "=", "TSNE", "(", "n_components", "=", "2", ")", ".", "fit_transform", "(", "dbFeat_np", "[", ":", "opt", ".", "numSamples2Project", "]", ")", "\n", "q_emb", "=", "TSNE", "(", "n_components", "=", "2", ")", ".", "fit_transform", "(", "qFeat_np", "[", ":", "opt", ".", "numSamples2Project", "]", ")", "\n", "\n", "", "if", "extract_noEval", ":", "\n", "        ", "return", "np", ".", "vstack", "(", "[", "dbFeat_np", ",", "qFeat_np", "]", ")", ",", "db_emb", ",", "q_emb", ",", "None", ",", "None", "\n", "\n", "", "n_values", "=", "[", "1", ",", "5", ",", "10", ",", "20", ",", "100", "]", "\n", "\n", "if", "'seqmatch'", "in", "opt", ".", "pooling", ".", "lower", "(", ")", ":", "\n", "        ", "print", "(", "'====> Performing sequence score aggregation'", ")", "\n", "if", "opt", ".", "predictionsFile", "is", "not", "None", ":", "\n", "            ", "predPrior", "=", "np", ".", "load", "(", "opt", ".", "predictionsFile", ")", "[", "'preds'", "]", "\n", "predPriorTopK", "=", "predPrior", "[", ":", ",", ":", "20", "]", "\n", "", "else", ":", "\n", "            ", "predPriorTopK", "=", "None", "\n", "", "dMatSeq", "=", "aggregateMatchScores", "(", "dbFeat", ",", "qFeat", ",", "device", ",", "refCandidates", "=", "predPriorTopK", ")", "\n", "predictions", "=", "np", ".", "argsort", "(", "dMatSeq", ",", "axis", "=", "0", ")", "[", ":", "max", "(", "n_values", ")", ",", ":", "]", ".", "transpose", "(", ")", "\n", "bestDists", "=", "dMatSeq", "[", "predictions", "[", ":", ",", "0", "]", ",", "np", ".", "arange", "(", "dMatSeq", ".", "shape", "[", "1", "]", ")", "]", "\n", "if", "opt", ".", "predictionsFile", "is", "not", "None", ":", "\n", "            ", "predictions", "=", "np", ".", "array", "(", "[", "predPriorTopK", "[", "qIdx", "]", "[", "predictions", "[", "qIdx", "]", "]", "for", "qIdx", "in", "range", "(", "predictions", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "print", "(", "\"Preds:\"", ",", "predictions", ".", "shape", ")", "\n", "", "", "else", ":", "\n", "        ", "print", "(", "'====> Building faiss index'", ")", "\n", "faiss_index", "=", "faiss", ".", "IndexFlatL2", "(", "pool_size", ")", "\n", "faiss_index", ".", "add", "(", "dbFeat_np", ")", "\n", "\n", "distances", ",", "predictions", "=", "faiss_index", ".", "search", "(", "qFeat_np", ",", "max", "(", "n_values", ")", ")", "\n", "bestDists", "=", "distances", "[", ":", ",", "0", "]", "\n", "\n", "", "print", "(", "'====> Calculating recall @ N'", ")", "\n", "\n", "# for each query get those within threshold distance", "\n", "gt", ",", "gtDists", "=", "eval_set", ".", "get_positives", "(", "retDists", "=", "True", ")", "\n", "gtDistsMat", "=", "cdist", "(", "eval_set", ".", "dbStruct", ".", "utmDb", ",", "eval_set", ".", "dbStruct", ".", "utmQ", ")", "\n", "\n", "# compute recall for different loc radii", "\n", "rAtL", "=", "[", "]", "\n", "for", "locRad", "in", "[", "1", ",", "5", ",", "10", ",", "20", ",", "40", ",", "100", ",", "200", "]", ":", "\n", "        ", "gtAtL", "=", "gtDistsMat", "<=", "locRad", "\n", "gtAtL", "=", "[", "np", ".", "argwhere", "(", "gtAtL", "[", ":", ",", "qIx", "]", ")", ".", "flatten", "(", ")", "for", "qIx", "in", "range", "(", "gtDistsMat", ".", "shape", "[", "1", "]", ")", "]", "\n", "rAtL", ".", "append", "(", "getRecallAtN", "(", "n_values", ",", "predictions", ",", "gtAtL", ")", ")", "\n", "\n", "", "recall_at_n", "=", "getRecallAtN", "(", "n_values", ",", "predictions", ",", "gt", ")", "\n", "\n", "recalls", "=", "{", "}", "#make dict for output", "\n", "for", "i", ",", "n", "in", "enumerate", "(", "n_values", ")", ":", "\n", "        ", "recalls", "[", "n", "]", "=", "recall_at_n", "[", "i", "]", "\n", "print", "(", "\"====> Recall@{}: {:.4f}\"", ".", "format", "(", "n", ",", "recall_at_n", "[", "i", "]", ")", ")", "\n", "if", "writer", "is", "not", "None", ":", "writer", ".", "add_scalar", "(", "'Val/Recall@'", "+", "str", "(", "n", ")", ",", "recall_at_n", "[", "i", "]", ",", "epoch", ")", "\n", "\n", "", "return", "recalls", ",", "db_emb", ",", "q_emb", ",", "rAtL", ",", "predictions", "\n", "", ""]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.__init__": [[21, 38], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset_name", ",", "train_mat_file", ",", "test_mat_file", ",", "val_mat_file", ",", "opt", ")", ":", "\n", "        ", "self", ".", "dataset_name", "=", "dataset_name", "\n", "self", ".", "train_mat_file", "=", "train_mat_file", "\n", "self", ".", "test_mat_file", "=", "test_mat_file", "\n", "self", ".", "val_mat_file", "=", "val_mat_file", "\n", "self", ".", "struct_dir", "=", "\"./structFiles/\"", "\n", "self", ".", "seqL", "=", "opt", ".", "seqL", "\n", "self", ".", "seqL_filterData", "=", "opt", ".", "seqL_filterData", "\n", "\n", "# descriptor settings", "\n", "self", ".", "dbDescs", "=", "None", "\n", "self", ".", "qDescs", "=", "None", "\n", "self", ".", "trainInds", "=", "None", "\n", "self", ".", "valInds", "=", "None", "\n", "self", ".", "testInds", "=", "None", "\n", "self", ".", "db_seqBounds", "=", "None", "\n", "self", ".", "q_seqBounds", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.loadPreComputedDescriptors": [[39, 51], ["print", "print"], "methods", ["None"], ["", "def", "loadPreComputedDescriptors", "(", "self", ",", "ft1", ",", "ft2", ",", "seqBounds", "=", "None", ")", ":", "\n", "        ", "self", ".", "dbDescs", "=", "ft1", "\n", "self", ".", "qDescs", "=", "ft2", "\n", "print", "(", "\"All Db descs: \"", ",", "self", ".", "dbDescs", ".", "shape", ")", "\n", "print", "(", "\"All Qry descs: \"", ",", "self", ".", "qDescs", ".", "shape", ")", "\n", "if", "seqBounds", "is", "None", ":", "\n", "            ", "self", ".", "db_seqBounds", "=", "None", "\n", "self", ".", "q_seqBounds", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "db_seqBounds", "=", "seqBounds", "[", "0", "]", "\n", "self", ".", "q_seqBounds", "=", "seqBounds", "[", "1", "]", "\n", "", "return", "self", ".", "dbDescs", ".", "shape", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_training_set": [[52, 56], ["os.path.join", "datasets.WholeDatasetFromStruct"], "methods", ["None"], ["", "def", "get_whole_training_set", "(", "self", ",", "onlyDB", "=", "False", ")", ":", "\n", "        ", "structFile", "=", "join", "(", "self", ".", "struct_dir", ",", "self", ".", "train_mat_file", ")", "\n", "indsSplit", "=", "self", ".", "trainInds", "\n", "return", "WholeDatasetFromStruct", "(", "structFile", ",", "indsSplit", ",", "self", ".", "dbDescs", ",", "self", ".", "qDescs", ",", "seqL", "=", "self", ".", "seqL", ",", "onlyDB", "=", "onlyDB", ",", "seqBounds", "=", "[", "self", ".", "db_seqBounds", ",", "self", ".", "q_seqBounds", "]", ",", "seqL_filterData", "=", "self", ".", "seqL_filterData", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_val_set": [[57, 63], ["os.path.join", "datasets.WholeDatasetFromStruct"], "methods", ["None"], ["", "def", "get_whole_val_set", "(", "self", ")", ":", "\n", "        ", "structFile", "=", "join", "(", "self", ".", "struct_dir", ",", "self", ".", "val_mat_file", ")", "\n", "indsSplit", "=", "self", ".", "valInds", "\n", "if", "self", ".", "seqL_filterData", "is", "None", "and", "self", ".", "dataset_name", "==", "'msls'", ":", "\n", "            ", "self", ".", "seqL_filterData", "=", "self", ".", "seqL", "\n", "", "return", "WholeDatasetFromStruct", "(", "structFile", ",", "indsSplit", ",", "self", ".", "dbDescs", ",", "self", ".", "qDescs", ",", "seqL", "=", "self", ".", "seqL", ",", "seqBounds", "=", "[", "self", ".", "db_seqBounds", ",", "self", ".", "q_seqBounds", "]", ",", "seqL_filterData", "=", "self", ".", "seqL_filterData", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_whole_test_set": [[64, 73], ["os.path.join", "datasets.WholeDatasetFromStruct", "ValueError"], "methods", ["None"], ["", "def", "get_whole_test_set", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "test_mat_file", "is", "not", "None", ":", "\n", "            ", "structFile", "=", "join", "(", "self", ".", "struct_dir", ",", "self", ".", "test_mat_file", ")", "\n", "indsSplit", "=", "self", ".", "testInds", "\n", "if", "self", ".", "seqL_filterData", "is", "None", "and", "self", ".", "dataset_name", "==", "'msls'", ":", "\n", "                ", "self", ".", "seqL_filterData", "=", "self", ".", "seqL", "\n", "", "return", "WholeDatasetFromStruct", "(", "structFile", ",", "indsSplit", ",", "self", ".", "dbDescs", ",", "self", ".", "qDescs", ",", "seqL", "=", "self", ".", "seqL", ",", "seqBounds", "=", "[", "self", ".", "db_seqBounds", ",", "self", ".", "q_seqBounds", "]", ",", "seqL_filterData", "=", "self", ".", "seqL_filterData", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'test set not available for dataset '", "+", "self", ".", "dataset_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_training_query_set": [[74, 78], ["os.path.join", "datasets.QueryDatasetFromStruct"], "methods", ["None"], ["", "", "def", "get_training_query_set", "(", "self", ",", "margin", "=", "0.1", ",", "nNegSample", "=", "1000", ",", "use_regions", "=", "False", ")", ":", "\n", "        ", "structFile", "=", "join", "(", "self", ".", "struct_dir", ",", "self", ".", "train_mat_file", ")", "\n", "indsSplit", "=", "self", ".", "trainInds", "\n", "return", "QueryDatasetFromStruct", "(", "structFile", ",", "indsSplit", ",", "self", ".", "dbDescs", ",", "self", ".", "qDescs", ",", "nNegSample", "=", "nNegSample", ",", "margin", "=", "margin", ",", "use_regions", "=", "use_regions", ",", "seqL", "=", "self", ".", "seqL", ",", "seqBounds", "=", "[", "self", ".", "db_seqBounds", ",", "self", ".", "q_seqBounds", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.get_val_query_set": [[79, 83], ["os.path.join", "datasets.QueryDatasetFromStruct"], "methods", ["None"], ["", "def", "get_val_query_set", "(", "self", ")", ":", "\n", "        ", "structFile", "=", "join", "(", "self", ".", "struct_dir", ",", "self", ".", "val_mat_file", ")", "\n", "indsSplit", "=", "self", ".", "valInds", "\n", "return", "QueryDatasetFromStruct", "(", "structFile", ",", "indsSplit", ",", "self", ".", "dbDescs", ",", "self", ".", "qDescs", ",", "seqL", "=", "self", ".", "seqL", ",", "seqBounds", "=", "[", "self", ".", "db_seqBounds", ",", "self", ".", "q_seqBounds", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.Dataset.collate_fn": [[84, 112], ["list", "zip", "torch.dataloader.default_collate", "torch.dataloader.default_collate", "torch.dataloader.default_collate", "torch.dataloader.default_collate", "torch.dataloader.default_collate", "torch.dataloader.default_collate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "list", "filter", "len", "itertools.chain"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "collate_fn", "(", "batch", ")", ":", "\n", "        ", "\"\"\"Creates mini-batch tensors from the list of tuples (query, positive, negatives).\n\n        Args:\n            batch: list of tuple (query, positive, negatives).\n                - query: torch tensor of shape (T, C). e.g. (5,4096)\n                - positive: torch tensor of shape (T, C).\n                - negative: torch tensor of shape (N, T, C).\n        Returns:\n            query: torch tensor of shape (batch_size, T, C).\n            positive: torch tensor of shape (batch_size, T, C).\n            negatives: torch tensor of shape (batch_size, T, C).\n        \"\"\"", "\n", "\n", "batch", "=", "list", "(", "filter", "(", "lambda", "x", ":", "x", "is", "not", "None", ",", "batch", ")", ")", "\n", "if", "len", "(", "batch", ")", "==", "0", ":", "\n", "            ", "return", "None", ",", "None", ",", "None", ",", "None", ",", "None", "\n", "\n", "", "query", ",", "positive", ",", "negatives", ",", "indices", "=", "zip", "(", "*", "batch", ")", "\n", "\n", "query", "=", "data", ".", "dataloader", ".", "default_collate", "(", "query", ")", "\n", "positive", "=", "data", ".", "dataloader", ".", "default_collate", "(", "positive", ")", "\n", "negCounts", "=", "data", ".", "dataloader", ".", "default_collate", "(", "[", "x", ".", "shape", "[", "0", "]", "for", "x", "in", "negatives", "]", ")", "\n", "negatives", "=", "torch", ".", "cat", "(", "negatives", ",", "0", ")", "\n", "indices", "=", "list", "(", "itertools", ".", "chain", "(", "*", "indices", ")", ")", "\n", "\n", "return", "query", ",", "positive", ",", "negatives", ",", "negCounts", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.WholeDatasetFromStruct.__init__": [[224, 264], ["torch.Dataset.__init__", "datasets.parse_db_struct", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.array", "numpy.concatenate", "numpy.vstack", "len", "datasets.getValidSeqInds", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "numpy.argwhere().flatten", "datasets.WholeDatasetFromStruct.dbStruct._replace", "numpy.array", "numpy.vstack", "numpy.argwhere", "numpy.argwhere", "numpy.argwhere", "len", "len", "len", "range", "len", "len", "len", "range", "len"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__init__", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.parse_db_struct", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getValidSeqInds"], ["    ", "def", "__init__", "(", "self", ",", "structFile", ",", "indsSplit", ",", "dbDescs", ",", "qDescs", ",", "onlyDB", "=", "False", ",", "seqL", "=", "1", ",", "seqBounds", "=", "None", ",", "seqL_filterData", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "seqL", "=", "seqL", "\n", "self", ".", "filterBoundaryInds", "=", "False", "if", "seqL_filterData", "is", "None", "else", "True", "\n", "\n", "self", ".", "dbStruct", "=", "parse_db_struct", "(", "structFile", ")", "\n", "\n", "self", ".", "images", "=", "dbDescs", "[", "indsSplit", "[", "0", "]", "]", "\n", "\n", "if", "seqBounds", "[", "0", "]", "is", "None", ":", "\n", "            ", "self", ".", "seqBounds", "=", "np", ".", "array", "(", "[", "[", "0", ",", "len", "(", "self", ".", "images", ")", "]", "for", "_", "in", "range", "(", "len", "(", "self", ".", "images", ")", ")", "]", ")", "\n", "\n", "", "if", "not", "onlyDB", ":", "\n", "            ", "qImages", "=", "qDescs", "[", "indsSplit", "[", "1", "]", "]", "\n", "self", ".", "images", "=", "np", ".", "concatenate", "(", "[", "self", ".", "images", ",", "qImages", "]", ",", "0", ")", "\n", "if", "seqBounds", "[", "0", "]", "is", "None", ":", "\n", "                ", "q_seqBounds", "=", "np", ".", "array", "(", "[", "[", "len", "(", "self", ".", "seqBounds", ")", ",", "len", "(", "self", ".", "images", ")", "]", "for", "_", "in", "range", "(", "len", "(", "qImages", ")", ")", "]", ")", "\n", "self", ".", "seqBounds", "=", "np", ".", "vstack", "(", "[", "self", ".", "seqBounds", ",", "q_seqBounds", "]", ")", "\n", "\n", "", "", "if", "seqBounds", "[", "0", "]", "is", "not", "None", ":", "\n", "            ", "db_seqBounds", "=", "seqBounds", "[", "0", "]", "[", "indsSplit", "[", "0", "]", "]", "\n", "q_seqBounds", "=", "db_seqBounds", "[", "-", "1", ",", "-", "1", "]", "+", "seqBounds", "[", "1", "]", "[", "indsSplit", "[", "1", "]", "]", "\n", "self", ".", "seqBounds", "=", "np", ".", "vstack", "(", "[", "db_seqBounds", ",", "q_seqBounds", "]", ")", "\n", "\n", "", "self", ".", "validInds", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "images", ")", ")", "\n", "self", ".", "validInds_db", "=", "np", ".", "arange", "(", "self", ".", "dbStruct", ".", "numDb", ")", "\n", "self", ".", "validInds_q", "=", "np", ".", "arange", "(", "self", ".", "dbStruct", ".", "numQ", ")", "\n", "if", "self", ".", "filterBoundaryInds", ":", "\n", "            ", "validFlags", "=", "getValidSeqInds", "(", "self", ".", "seqBounds", ",", "seqL_filterData", ")", "\n", "self", ".", "validInds", "=", "np", ".", "argwhere", "(", "validFlags", ")", ".", "flatten", "(", ")", "\n", "self", ".", "validInds_db", "=", "np", ".", "argwhere", "(", "validFlags", "[", ":", "self", ".", "dbStruct", ".", "numDb", "]", ")", ".", "flatten", "(", ")", "\n", "self", ".", "validInds_q", "=", "np", ".", "argwhere", "(", "validFlags", "[", "self", ".", "dbStruct", ".", "numDb", ":", "]", ")", ".", "flatten", "(", ")", "\n", "self", ".", "dbStruct", "=", "self", ".", "dbStruct", ".", "_replace", "(", "utmDb", "=", "self", ".", "dbStruct", ".", "utmDb", "[", "self", ".", "validInds_db", "]", ",", "numDb", "=", "len", "(", "self", ".", "validInds_db", ")", ",", "utmQ", "=", "self", ".", "dbStruct", ".", "utmQ", "[", "self", ".", "validInds_q", "]", ",", "numQ", "=", "len", "(", "self", ".", "validInds_q", ")", ")", "\n", "\n", "", "self", ".", "whichSet", "=", "self", ".", "dbStruct", ".", "whichSet", "\n", "self", ".", "dataset", "=", "self", ".", "dbStruct", ".", "dataset", "\n", "\n", "self", ".", "positives", "=", "None", "\n", "self", ".", "distances", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.WholeDatasetFromStruct.__getitem__": [[265, 272], ["datasets.getSeqInds"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getSeqInds"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "origIndex", "=", "index", "\n", "index", "=", "self", ".", "validInds", "[", "index", "]", "\n", "sIdMin", ",", "sIdMax", "=", "self", ".", "seqBounds", "[", "index", "]", "\n", "img", "=", "self", ".", "images", "[", "getSeqInds", "(", "index", ",", "self", ".", "seqL", ",", "sIdMax", ",", "minNum", "=", "sIdMin", ")", "]", "\n", "\n", "return", "img", ",", "origIndex", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.WholeDatasetFromStruct.__len__": [[273, 275], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "validInds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.WholeDatasetFromStruct.get_positives": [[276, 290], ["sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "print", "sklearn.neighbors.NearestNeighbors.radius_neighbors"], "methods", ["None"], ["", "def", "get_positives", "(", "self", ",", "retDists", "=", "False", ")", ":", "\n", "# positives for evaluation are those within trivial threshold range", "\n", "# fit NN to find them, search by radius", "\n", "        ", "if", "self", ".", "positives", "is", "None", ":", "\n", "            ", "knn", "=", "NearestNeighbors", "(", "n_jobs", "=", "-", "1", ")", "\n", "knn", ".", "fit", "(", "self", ".", "dbStruct", ".", "utmDb", ")", "\n", "\n", "print", "(", "\"Using Localization Radius: \"", ",", "self", ".", "dbStruct", ".", "posDistThr", ")", "\n", "self", ".", "distances", ",", "self", ".", "positives", "=", "knn", ".", "radius_neighbors", "(", "self", ".", "dbStruct", ".", "utmQ", ",", "radius", "=", "self", ".", "dbStruct", ".", "posDistThr", ")", "\n", "\n", "", "if", "retDists", ":", "\n", "            ", "return", "self", ".", "positives", ",", "self", ".", "distances", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "positives", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__init__": [[293, 352], ["torch.Dataset.__init__", "datasets.parse_db_struct", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "sklearn.neighbors.NearestNeighbors.radius_neighbors", "list", "enumerate", "print", "sklearn.neighbors.NearestNeighbors.radius_neighbors", "numpy.array", "numpy.array", "numpy.sort", "numpy.where", "len", "len", "datasets.QueryDatasetFromStruct.potential_negatives.append", "numpy.empty", "numpy.setdiff1d", "range", "numpy.array", "numpy.arange", "len", "range", "len", "range", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__init__", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.parse_db_struct"], ["    ", "def", "__init__", "(", "self", ",", "structFile", ",", "indsSplit", ",", "dbDescs", ",", "qDescs", ",", "nNegSample", "=", "1000", ",", "nNeg", "=", "10", ",", "margin", "=", "0.1", ",", "use_regions", "=", "False", ",", "seqL", "=", "1", ",", "seqBounds", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "seqL", "=", "seqL", "\n", "\n", "self", ".", "dbDescs", "=", "dbDescs", "[", "indsSplit", "[", "0", "]", "]", "\n", "self", ".", "qDescs", "=", "qDescs", "[", "indsSplit", "[", "1", "]", "]", "\n", "\n", "self", ".", "margin", "=", "margin", "\n", "\n", "self", ".", "dbStruct", "=", "parse_db_struct", "(", "structFile", ")", "\n", "\n", "if", "seqBounds", "[", "0", "]", "is", "None", ":", "\n", "            ", "self", ".", "db_seqBounds", "=", "np", ".", "array", "(", "[", "[", "0", ",", "len", "(", "self", ".", "dbDescs", ")", "]", "for", "_", "in", "range", "(", "len", "(", "self", ".", "dbDescs", ")", ")", "]", ")", "\n", "self", ".", "q_seqBounds", "=", "np", ".", "array", "(", "[", "[", "0", ",", "len", "(", "self", ".", "qDescs", ")", "]", "for", "_", "in", "range", "(", "len", "(", "self", ".", "qDescs", ")", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "db_seqBounds", "=", "seqBounds", "[", "0", "]", "[", "indsSplit", "[", "0", "]", "]", "\n", "self", ".", "q_seqBounds", "=", "seqBounds", "[", "1", "]", "[", "indsSplit", "[", "1", "]", "]", "\n", "", "self", ".", "whichSet", "=", "self", ".", "dbStruct", ".", "whichSet", "\n", "self", ".", "dataset", "=", "self", ".", "dbStruct", ".", "dataset", "\n", "self", ".", "nNegSample", "=", "nNegSample", "# number of negatives to randomly sample", "\n", "self", ".", "nNeg", "=", "nNeg", "# number of negatives used for training", "\n", "self", ".", "use_faiss", "=", "True", "\n", "self", ".", "use_regions", "=", "use_regions", "\n", "\n", "# potential positives are those within nontrivial threshold range", "\n", "# fit NN to find them, search by radius", "\n", "knn", "=", "NearestNeighbors", "(", "n_jobs", "=", "-", "1", ")", "\n", "knn", ".", "fit", "(", "self", ".", "dbStruct", ".", "utmDb", ")", "\n", "\n", "# TODO use sqeuclidean as metric?", "\n", "self", ".", "nontrivial_distances", ",", "self", ".", "nontrivial_positives", "=", "knn", ".", "radius_neighbors", "(", "self", ".", "dbStruct", ".", "utmQ", ",", "radius", "=", "self", ".", "dbStruct", ".", "nonTrivPosDistSqThr", "**", "0.5", ",", "\n", "return_distance", "=", "True", ")", "\n", "\n", "self", ".", "nontrivial_positives", "=", "list", "(", "self", ".", "nontrivial_positives", ")", "\n", "\n", "# radius returns unsorted, sort once now so we dont have to later", "\n", "for", "i", ",", "posi", "in", "enumerate", "(", "self", ".", "nontrivial_positives", ")", ":", "\n", "            ", "self", ".", "nontrivial_positives", "[", "i", "]", "=", "np", ".", "sort", "(", "posi", ")", "\n", "\n", "# its possible some queries don't have any non trivial potential positives", "\n", "# lets filter those out", "\n", "", "self", ".", "queries", "=", "np", ".", "where", "(", "np", ".", "array", "(", "[", "len", "(", "x", ")", "for", "x", "in", "self", ".", "nontrivial_positives", "]", ")", ">", "0", ")", "[", "0", "]", "\n", "print", "(", "\"\\n Queries within range \"", ",", "len", "(", "self", ".", "queries", ")", ",", "len", "(", "self", ".", "nontrivial_positives", ")", ",", "\"\\n\"", ")", "\n", "\n", "# potential negatives are those outside of posDistThr range", "\n", "potential_positives", "=", "knn", ".", "radius_neighbors", "(", "self", ".", "dbStruct", ".", "utmQ", ",", "\n", "radius", "=", "self", ".", "dbStruct", ".", "posDistThr", ",", "\n", "return_distance", "=", "False", ")", "\n", "\n", "self", ".", "potential_negatives", "=", "[", "]", "\n", "for", "pos", "in", "potential_positives", ":", "\n", "            ", "self", ".", "potential_negatives", ".", "append", "(", "np", ".", "setdiff1d", "(", "np", ".", "arange", "(", "self", ".", "dbStruct", ".", "numDb", ")", ",", "pos", ",", "assume_unique", "=", "True", ")", ")", "\n", "\n", "", "self", ".", "cache", "=", "None", "# filepath of HDF5 containing feature vectors for images", "\n", "self", ".", "h5feat", "=", "None", "\n", "\n", "self", ".", "negCache", "=", "[", "np", ".", "empty", "(", "(", "0", ",", ")", ")", "for", "_", "in", "range", "(", "self", ".", "dbStruct", ".", "numQ", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__getitem__": [[353, 426], ["torch.stack", "torch.stack", "torch.stack", "torch.stack", "h5py.File", "h5.get", "[].item", "[].item", "numpy.random.choice", "numpy.unique", "numpy.sort", "numpy.sqrt.reshape", "negNN.reshape.reshape.reshape", "negSample[].astype", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.stack.append", "torch.stack.append", "faiss.IndexFlatL2", "faiss.IndexFlatL2.add", "faiss.IndexFlatL2.search", "numpy.sqrt", "sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "sklearn.neighbors.NearestNeighbors.kneighbors", "len", "numpy.concatenate", "faiss.IndexFlatL2", "faiss.IndexFlatL2.add", "faiss.IndexFlatL2.search", "numpy.sqrt", "sklearn.neighbors.NearestNeighbors.fit", "sklearn.neighbors.NearestNeighbors.kneighbors", "numpy.sum", "datasets.getSeqInds", "datasets.getSeqInds", "negSample[].astype.tolist", "datasets.QueryDatasetFromStruct.nontrivial_positives[].tolist", "qFeat.reshape", "qFeat.reshape", "numpy.sort.astype().tolist", "qFeat.reshape", "qFeat.reshape", "datasets.getSeqInds", "numpy.sort.astype"], "methods", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getSeqInds", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getSeqInds", "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getSeqInds"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "with", "h5py", ".", "File", "(", "self", ".", "cache", ",", "mode", "=", "'r'", ")", "as", "h5", ":", "\n", "            ", "h5feat", "=", "h5", ".", "get", "(", "\"features\"", ")", "\n", "\n", "qOffset", "=", "self", ".", "dbStruct", ".", "numDb", "\n", "qFeat", "=", "h5feat", "[", "index", "+", "qOffset", "]", "\n", "\n", "posFeat", "=", "h5feat", "[", "self", ".", "nontrivial_positives", "[", "index", "]", ".", "tolist", "(", ")", "]", "\n", "\n", "if", "self", ".", "use_faiss", ":", "\n", "                ", "faiss_index", "=", "faiss", ".", "IndexFlatL2", "(", "posFeat", ".", "shape", "[", "1", "]", ")", "\n", "# noinspection PyArgumentList", "\n", "faiss_index", ".", "add", "(", "posFeat", ")", "\n", "# noinspection PyArgumentList", "\n", "dPos", ",", "posNN", "=", "faiss_index", ".", "search", "(", "qFeat", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "1", ")", "#posFeat.shape[0])", "\n", "dPos", "=", "np", ".", "sqrt", "(", "dPos", ")", "# faiss returns squared distance", "\n", "", "else", ":", "\n", "                ", "knn", "=", "NearestNeighbors", "(", "n_jobs", "=", "-", "1", ")", "\n", "knn", ".", "fit", "(", "posFeat", ")", "\n", "dPos", ",", "posNN", "=", "knn", ".", "kneighbors", "(", "qFeat", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "1", ")", "#posFeat.shape[0])", "\n", "", "if", "len", "(", "self", ".", "nontrivial_positives", "[", "index", "]", ")", "<", "1", ":", "\n", "# if none are violating then skip this query", "\n", "                ", "return", "None", "\n", "", "dPos", "=", "dPos", "[", "0", "]", "[", "-", "1", "]", ".", "item", "(", ")", "\n", "posIndex", "=", "self", ".", "nontrivial_positives", "[", "index", "]", "[", "posNN", "[", "0", ",", "-", "1", "]", "]", ".", "item", "(", ")", "\n", "\n", "negSample", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "potential_negatives", "[", "index", "]", ",", "self", ".", "nNegSample", ")", "\n", "negSample", "=", "np", ".", "unique", "(", "np", ".", "concatenate", "(", "[", "self", ".", "negCache", "[", "index", "]", ",", "negSample", "]", ")", ")", "\n", "negSample", "=", "np", ".", "sort", "(", "negSample", ")", "#essential to order ascending, speeds up h5 by about double", "\n", "\n", "negFeat", "=", "h5feat", "[", "negSample", ".", "astype", "(", "int", ")", ".", "tolist", "(", ")", "]", "\n", "if", "self", ".", "use_faiss", ":", "\n", "                ", "faiss_index", "=", "faiss", ".", "IndexFlatL2", "(", "posFeat", ".", "shape", "[", "1", "]", ")", "\n", "# noinspection PyArgumentList", "\n", "faiss_index", ".", "add", "(", "negFeat", ")", "\n", "# noinspection PyArgumentList", "\n", "dNeg", ",", "negNN", "=", "faiss_index", ".", "search", "(", "qFeat", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "self", ".", "nNeg", "*", "10", ")", "\n", "dNeg", "=", "np", ".", "sqrt", "(", "dNeg", ")", "\n", "", "else", ":", "\n", "                ", "knn", ".", "fit", "(", "negFeat", ")", "\n", "\n", "# to quote netvlad paper code: 10x is hacky but fine", "\n", "dNeg", ",", "negNN", "=", "knn", ".", "kneighbors", "(", "qFeat", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "self", ".", "nNeg", "*", "10", ")", "\n", "\n", "", "dNeg", "=", "dNeg", ".", "reshape", "(", "-", "1", ")", "\n", "negNN", "=", "negNN", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# try to find negatives that are within margin, if there aren't any return none", "\n", "violatingNeg", "=", "dNeg", "<", "dPos", "+", "self", ".", "margin", "**", "0.5", "\n", "\n", "if", "np", ".", "sum", "(", "violatingNeg", ")", "<", "1", ":", "\n", "# if none are violating then skip this query", "\n", "                ", "return", "None", "\n", "\n", "", "negNN", "=", "negNN", "[", "violatingNeg", "]", "[", ":", "self", ".", "nNeg", "]", "\n", "negIndices", "=", "negSample", "[", "negNN", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "self", ".", "negCache", "[", "index", "]", "=", "negIndices", "\n", "\n", "", "sIdMin_q", ",", "sIdMax_q", "=", "self", ".", "q_seqBounds", "[", "index", "]", "\n", "query", "=", "self", ".", "qDescs", "[", "getSeqInds", "(", "index", ",", "self", ".", "seqL", ",", "sIdMax_q", ",", "sIdMin_q", ")", "]", "\n", "sIdMin_p", ",", "sIdMax_p", "=", "self", ".", "db_seqBounds", "[", "posIndex", "]", "\n", "positive", "=", "self", ".", "dbDescs", "[", "getSeqInds", "(", "posIndex", ",", "self", ".", "seqL", ",", "sIdMax_p", ",", "sIdMin_p", ")", "]", "\n", "\n", "negatives", "=", "[", "]", "\n", "for", "negIndex", "in", "negIndices", ":", "\n", "            ", "sIdMin_n", ",", "sIdMax_n", "=", "self", ".", "db_seqBounds", "[", "negIndex", "]", "\n", "negative", "=", "torch", ".", "tensor", "(", "self", ".", "dbDescs", "[", "getSeqInds", "(", "negIndex", ",", "self", ".", "seqL", ",", "sIdMax_n", ",", "sIdMin_n", ")", "]", ")", "\n", "negatives", ".", "append", "(", "negative", ")", "\n", "\n", "", "negatives", "=", "torch", ".", "stack", "(", "negatives", ",", "0", ")", "\n", "\n", "# noinspection PyTypeChecker", "\n", "return", "query", ",", "positive", ",", "negatives", ",", "[", "index", ",", "posIndex", "]", "+", "negIndices", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.QueryDatasetFromStruct.__len__": [[427, 429], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "qDescs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getSeqInds": [[113, 125], ["numpy.arange", "max", "min", "len", "numpy.concatenate", "numpy.concatenate", "numpy.arange", "range", "numpy.arange"], "function", ["None"], ["", "", "def", "getSeqInds", "(", "idx", ",", "seqL", ",", "maxNum", ",", "minNum", "=", "0", ",", "retLenDiff", "=", "False", ")", ":", "\n", "    ", "seqLOrig", "=", "seqL", "\n", "seqInds", "=", "np", ".", "arange", "(", "max", "(", "minNum", ",", "idx", "-", "seqL", "//", "2", ")", ",", "min", "(", "idx", "+", "seqL", "-", "seqL", "//", "2", ",", "maxNum", ")", ",", "1", ")", "\n", "lenDiff", "=", "seqLOrig", "-", "len", "(", "seqInds", ")", "\n", "if", "retLenDiff", ":", "\n", "        ", "return", "lenDiff", "\n", "\n", "", "if", "seqInds", "[", "0", "]", "==", "minNum", ":", "\n", "        ", "seqInds", "=", "np", ".", "concatenate", "(", "[", "seqInds", ",", "np", ".", "arange", "(", "seqInds", "[", "-", "1", "]", "+", "1", ",", "seqInds", "[", "-", "1", "]", "+", "1", "+", "lenDiff", ",", "1", ")", "]", ")", "\n", "", "elif", "lenDiff", ">", "0", "and", "seqInds", "[", "-", "1", "]", "in", "range", "(", "maxNum", "-", "1", ",", "maxNum", ")", ":", "\n", "        ", "seqInds", "=", "np", ".", "concatenate", "(", "[", "np", ".", "arange", "(", "seqInds", "[", "0", "]", "-", "lenDiff", ",", "seqInds", "[", "0", "]", ",", "1", ")", ",", "seqInds", "]", ")", "\n", "", "return", "seqInds", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getValidSeqInds": [[126, 133], ["range", "len", "datasets.getSeqInds", "validFlags.append"], "function", ["home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.getSeqInds"], ["", "def", "getValidSeqInds", "(", "seqBounds", ",", "seqL", ")", ":", "\n", "    ", "validFlags", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "seqBounds", ")", ")", ":", "\n", "        ", "sIdMin", ",", "sIdMax", "=", "seqBounds", "[", "i", "]", "\n", "lenDiff", "=", "getSeqInds", "(", "i", ",", "seqL", ",", "sIdMax", ",", "minNum", "=", "sIdMin", ",", "retLenDiff", "=", "True", ")", "\n", "validFlags", ".", "append", "(", "True", "if", "lenDiff", "==", "0", "else", "False", ")", "\n", "", "return", "validFlags", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.parse_db_struct": [[134, 180], ["scipy.io.loadmat", "list", "[].item", "[].item", "[].item", "[].item", "[].item", "[].item", "dbStruct", "f[].item", "f[].item", "[].item", "numpy.array", "numpy.array", "f[].item", "f[].item"], "function", ["None"], ["", "def", "parse_db_struct", "(", "path", ")", ":", "\n", "    ", "mat", "=", "loadmat", "(", "path", ")", "\n", "\n", "fieldnames", "=", "list", "(", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", ".", "dtype", ".", "names", ")", "\n", "\n", "dataset", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'dataset'", "]", ".", "item", "(", ")", "\n", "whichSet", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'whichSet'", "]", ".", "item", "(", ")", "\n", "\n", "dbImage", "=", "[", "f", "[", "0", "]", ".", "item", "(", ")", "for", "f", "in", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'dbImageFns'", "]", "]", "\n", "qImage", "=", "[", "f", "[", "0", "]", ".", "item", "(", ")", "for", "f", "in", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'qImageFns'", "]", "]", "\n", "\n", "numDb", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'numImages'", "]", ".", "item", "(", ")", "\n", "numQ", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'numQueries'", "]", ".", "item", "(", ")", "\n", "\n", "posDistThr", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'posDistThr'", "]", ".", "item", "(", ")", "\n", "posDistSqThr", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'posDistSqThr'", "]", ".", "item", "(", ")", "\n", "if", "'nonTrivPosDistSqThr'", "in", "fieldnames", ":", "\n", "        ", "nonTrivPosDistSqThr", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'nonTrivPosDistSqThr'", "]", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "        ", "nonTrivPosDistSqThr", "=", "None", "\n", "\n", "", "if", "'dbTimeStamp'", "in", "fieldnames", "and", "'qTimeStamp'", "in", "fieldnames", ":", "\n", "        ", "dbTimeStamp", "=", "[", "f", "[", "0", "]", ".", "item", "(", ")", "for", "f", "in", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'dbTimeStamp'", "]", ".", "T", "]", "\n", "qTimeStamp", "=", "[", "f", "[", "0", "]", ".", "item", "(", ")", "for", "f", "in", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'qTimeStamp'", "]", ".", "T", "]", "\n", "dbTimeStamp", "=", "np", ".", "array", "(", "dbTimeStamp", ")", "\n", "qTimeStamp", "=", "np", ".", "array", "(", "qTimeStamp", ")", "\n", "", "else", ":", "\n", "        ", "dbTimeStamp", "=", "None", "\n", "qTimeStamp", "=", "None", "\n", "\n", "", "if", "'utmQ'", "in", "fieldnames", "and", "'utmDb'", "in", "fieldnames", ":", "\n", "        ", "utmDb", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'utmDb'", "]", ".", "T", "\n", "utmQ", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'utmQ'", "]", ".", "T", "\n", "", "else", ":", "\n", "        ", "utmQ", "=", "None", "\n", "utmDb", "=", "None", "\n", "\n", "", "if", "'gpsQ'", "in", "fieldnames", "and", "'gpsDb'", "in", "fieldnames", ":", "\n", "        ", "gpsDb", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'gpsDb'", "]", ".", "T", "\n", "gpsQ", "=", "mat", "[", "'dbStruct'", "]", "[", "0", ",", "0", "]", "[", "'gpsQ'", "]", ".", "T", "\n", "", "else", ":", "\n", "        ", "gpsQ", "=", "None", "\n", "gpsDb", "=", "None", "\n", "\n", "", "return", "dbStruct", "(", "whichSet", ",", "dataset", ",", "dbImage", ",", "utmDb", ",", "qImage", ",", "utmQ", ",", "numDb", ",", "numQ", ",", "posDistThr", ",", "\n", "posDistSqThr", ",", "nonTrivPosDistSqThr", ",", "dbTimeStamp", ",", "qTimeStamp", ",", "gpsQ", ",", "gpsDb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.save_db_struct": [[182, 219], ["scipy.io.savemat", "len", "len", "numpy.array().reshape", "numpy.array().reshape", "db_struct.dbTimeStamp.astype", "db_struct.qTimeStamp.astype", "len", "len", "len", "len", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "save_db_struct", "(", "path", ",", "db_struct", ")", ":", "\n", "    ", "assert", "db_struct", ".", "numDb", "==", "len", "(", "db_struct", ".", "dbImage", ")", "\n", "assert", "db_struct", ".", "numQ", "==", "len", "(", "db_struct", ".", "qImage", ")", "\n", "\n", "inner_dict", "=", "{", "\n", "'whichSet'", ":", "db_struct", ".", "whichSet", ",", "\n", "'dbImageFns'", ":", "np", ".", "array", "(", "db_struct", ".", "dbImage", ",", "dtype", "=", "np", ".", "object", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "'qImageFns'", ":", "np", ".", "array", "(", "db_struct", ".", "qImage", ",", "dtype", "=", "np", ".", "object", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "\n", "'numImages'", ":", "db_struct", ".", "numDb", ",", "\n", "'numQueries'", ":", "db_struct", ".", "numQ", ",", "\n", "'posDistThr'", ":", "db_struct", ".", "posDistThr", ",", "\n", "'posDistSqThr'", ":", "db_struct", ".", "posDistSqThr", ",", "\n", "}", "\n", "\n", "if", "db_struct", ".", "dataset", "is", "not", "None", ":", "\n", "        ", "inner_dict", "[", "'dataset'", "]", "=", "db_struct", ".", "dataset", "\n", "\n", "", "if", "db_struct", ".", "nonTrivPosDistSqThr", "is", "not", "None", ":", "\n", "        ", "inner_dict", "[", "'nonTrivPosDistSqThr'", "]", "=", "db_struct", ".", "nonTrivPosDistSqThr", "\n", "\n", "", "if", "db_struct", ".", "utmDb", "is", "not", "None", "and", "db_struct", ".", "utmQ", "is", "not", "None", ":", "\n", "        ", "assert", "db_struct", ".", "numDb", "==", "len", "(", "db_struct", ".", "utmDb", ")", "\n", "assert", "db_struct", ".", "numQ", "==", "len", "(", "db_struct", ".", "utmQ", ")", "\n", "inner_dict", "[", "'utmDb'", "]", "=", "db_struct", ".", "utmDb", ".", "T", "\n", "inner_dict", "[", "'utmQ'", "]", "=", "db_struct", ".", "utmQ", ".", "T", "\n", "\n", "", "if", "db_struct", ".", "gpsDb", "is", "not", "None", "and", "db_struct", ".", "gpsQ", "is", "not", "None", ":", "\n", "        ", "assert", "db_struct", ".", "numDb", "==", "len", "(", "db_struct", ".", "gpsDb", ")", "\n", "assert", "db_struct", ".", "numQ", "==", "len", "(", "db_struct", ".", "gpsQ", ")", "\n", "inner_dict", "[", "'gpsDb'", "]", "=", "db_struct", ".", "gpsDb", ".", "T", "\n", "inner_dict", "[", "'gpsQ'", "]", "=", "db_struct", ".", "gpsQ", ".", "T", "\n", "\n", "", "if", "db_struct", ".", "dbTimeStamp", "is", "not", "None", "and", "db_struct", ".", "qTimeStamp", "is", "not", "None", ":", "\n", "        ", "inner_dict", "[", "'dbTimeStamp'", "]", "=", "db_struct", ".", "dbTimeStamp", ".", "astype", "(", "np", ".", "float64", ")", "\n", "inner_dict", "[", "'qTimeStamp'", "]", "=", "db_struct", ".", "qTimeStamp", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "", "savemat", "(", "path", ",", "{", "'dbStruct'", ":", "inner_dict", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.oravus_seqNet.None.datasets.print_db_concise": [[220, 222], ["print", "db._asdict().items", "type", "db._asdict"], "function", ["None"], ["", "def", "print_db_concise", "(", "db", ")", ":", "\n", "    ", "[", "print", "(", "'\\033[1m'", "+", "k", "+", "'\\033[0m'", ",", "v", "[", ":", "10", "]", "if", "type", "(", "v", ")", "is", "list", "else", "v", ")", "for", "k", ",", "v", "in", "db", ".", "_asdict", "(", ")", ".", "items", "(", ")", "]", "\n", "\n"]]}