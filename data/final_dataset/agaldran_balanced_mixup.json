{"home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.sgd_optimizer": [[50, 65], ["model.named_parameters", "torch.optim.SGD", "torch.optim.SGD"], "function", ["None"], ["def", "sgd_optimizer", "(", "model", ",", "lr", ",", "momentum", ",", "weight_decay", ")", ":", "\n", "    ", "params", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "not", "value", ".", "requires_grad", ":", "\n", "            ", "continue", "\n", "", "apply_weight_decay", "=", "weight_decay", "\n", "apply_lr", "=", "lr", "\n", "if", "'bias'", "in", "key", "or", "'bn'", "in", "key", ":", "\n", "            ", "apply_weight_decay", "=", "0", "\n", "# print('set weight decay=0 for {}'.format(key))", "\n", "", "if", "'bias'", "in", "key", ":", "\n", "            ", "apply_lr", "=", "2", "*", "lr", "#   Just a Caffe-style common practice. Made no difference.", "\n", "", "params", "+=", "[", "{", "'params'", ":", "[", "value", "]", ",", "'lr'", ":", "apply_lr", ",", "'weight_decay'", ":", "apply_weight_decay", "}", "]", "\n", "", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "params", ",", "lr", ",", "momentum", "=", "momentum", ")", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.compare_op": [[66, 85], ["None"], "function", ["None"], ["", "def", "compare_op", "(", "metric", ")", ":", "\n", "    ", "'''\n    This should return an operator that given a, b returns True if a is better than b\n    Also, let us return which is an appropriately terrible initial value for such metric\n    '''", "\n", "if", "metric", "==", "'auc'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'mcc'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'kappa'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'f1'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'bacc'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'loss'", ":", "\n", "        ", "return", "operator", ".", "lt", ",", "np", ".", "inf", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.get_lr": [[86, 89], ["None"], "function", ["None"], ["", "", "def", "get_lr", "(", "optimizer", ")", ":", "\n", "    ", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "return", "param_group", "[", "'lr'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.partial_mixup": [[90, 98], ["input.mul().add", "input.size", "indices.size", "RuntimeError", "input.mul"], "function", ["None"], ["", "", "def", "partial_mixup", "(", "input", ":", "torch", ".", "Tensor", ",", "\n", "gamma", ":", "float", ",", "\n", "indices", ":", "torch", ".", "Tensor", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "if", "input", ".", "size", "(", "0", ")", "!=", "indices", ".", "size", "(", "0", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Size mismatch!\"", ")", "\n", "", "perm_input", "=", "input", "[", "indices", "]", "\n", "return", "input", ".", "mul", "(", "gamma", ")", ".", "add", "(", "perm_input", ",", "alpha", "=", "1", "-", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.mixup": [[100, 106], ["torch.randperm", "torch.randperm", "input.size", "train_lt_mxp.partial_mixup", "train_lt_mxp.partial_mixup"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup"], ["", "def", "mixup", "(", "input", ":", "torch", ".", "Tensor", ",", "\n", "target", ":", "torch", ".", "Tensor", ",", "\n", "gamma", ":", "float", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "indices", "=", "torch", ".", "randperm", "(", "input", ".", "size", "(", "0", ")", ",", "device", "=", "input", ".", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "return", "partial_mixup", "(", "input", ",", "gamma", ",", "indices", ")", ",", "partial_mixup", "(", "target", ",", "gamma", ",", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.cross_entropy_loss": [[107, 111], ["input.log_softmax"], "function", ["None"], ["", "def", "cross_entropy_loss", "(", "input", ":", "torch", ".", "Tensor", ",", "\n", "target", ":", "torch", ".", "Tensor", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "return", "-", "(", "input", ".", "log_softmax", "(", "dim", "=", "-", "1", ")", "*", "target", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.run_one_epoch": [[112, 170], ["model.train", "model.eval", "tqdm.trange", "enumerate", "next", "len", "model", "inputs.size", "t.update", "numpy.stack", "numpy.stack", "numpy.stack", "model.parameters", "numpy.random.beta", "train_lt_mxp.cross_entropy_loss", "criterion", "loss.backward", "optimizer.step", "optimizer.zero_grad", "model.softmax", "numpy.argmax", "probs_all.extend", "preds_all.extend", "labels_all.extend", "loss.detach().item", "inputs.size", "t.set_postfix", "t.set_postfix", "inputs.to", "labels.squeeze().to", "balanced_inputs.to", "balanced_labels.squeeze().to", "batch[].to", "batch[].squeeze().to", "logits.softmax.detach().cpu().numpy", "logits.softmax.detach().cpu().numpy", "labels.cpu().numpy", "torch.one_hot", "torch.one_hot", "loss.detach", "labels.squeeze", "balanced_labels.squeeze", "batch[].squeeze", "logits.softmax.detach().cpu", "logits.softmax.detach().cpu", "labels.cpu", "float", "train_lt_mxp.get_lr", "float", "logits.softmax.detach", "logits.softmax.detach"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.cross_entropy_loss", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr"], ["", "def", "run_one_epoch", "(", "loader", ",", "model", ",", "criterion", ",", "do_mixup", "=", "0.", ",", "optimizer", "=", "None", ",", "assess", "=", "False", ")", ":", "\n", "\n", "    ", "device", "=", "'cuda'", "if", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "is_cuda", "else", "'cpu'", "\n", "train", "=", "optimizer", "is", "not", "None", "# if we are in training mode there will be an optimizer and train=True here", "\n", "n_classes", "=", "model", ".", "n_classes", "\n", "\n", "if", "train", ":", "model", ".", "train", "(", ")", "\n", "else", ":", "model", ".", "eval", "(", ")", "\n", "if", "assess", ":", "\n", "        ", "probs_all", ",", "preds_all", ",", "labels_all", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "", "with", "trange", "(", "len", "(", "loader", ")", ")", "as", "t", ":", "\n", "        ", "n_elems", ",", "running_loss", "=", "0", ",", "0", "\n", "\n", "for", "i_batch", ",", "batch", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "if", "train", ":", "\n", "                ", "lam", "=", "np", ".", "random", ".", "beta", "(", "a", "=", "do_mixup", ",", "b", "=", "1", ")", "\n", "\n", "inputs", ",", "labels", "=", "batch", "[", "0", "]", "[", "0", "]", ",", "batch", "[", "0", "]", "[", "1", "]", "\n", "balanced_inputs", ",", "balanced_labels", "=", "batch", "[", "1", "]", "[", "0", "]", ",", "batch", "[", "1", "]", "[", "1", "]", "\n", "\n", "inputs", ",", "labels", "=", "inputs", ".", "to", "(", "device", ")", ",", "labels", ".", "squeeze", "(", ")", ".", "to", "(", "device", ")", "\n", "balanced_inputs", ",", "balanced_labels", "=", "balanced_inputs", ".", "to", "(", "device", ")", ",", "balanced_labels", ".", "squeeze", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "\n", "inputs", "=", "(", "1", "-", "lam", ")", "*", "inputs", "+", "lam", "*", "balanced_inputs", "\n", "mixed_labels", "=", "(", "1", "-", "lam", ")", "*", "F", ".", "one_hot", "(", "labels", ",", "n_classes", ")", "+", "lam", "*", "F", ".", "one_hot", "(", "balanced_labels", ",", "n_classes", ")", "\n", "\n", "del", "balanced_inputs", "\n", "del", "balanced_labels", "\n", "", "else", ":", "\n", "                ", "inputs", ",", "labels", "=", "batch", "[", "0", "]", ".", "to", "(", "device", ")", ",", "batch", "[", "1", "]", ".", "squeeze", "(", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "logits", "=", "model", "(", "inputs", ")", "\n", "loss", "=", "cross_entropy_loss", "(", "logits", ",", "mixed_labels", ")", "if", "train", "else", "criterion", "(", "logits", ",", "labels", ")", "\n", "\n", "if", "train", ":", "# only in training mode", "\n", "                ", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "", "if", "assess", ":", "\n", "                ", "probs", "=", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "preds", "=", "np", ".", "argmax", "(", "probs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "axis", "=", "1", ")", "\n", "probs_all", ".", "extend", "(", "probs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "preds_all", ".", "extend", "(", "preds", ")", "\n", "labels_all", ".", "extend", "(", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# Compute running loss", "\n", "", "running_loss", "+=", "loss", ".", "detach", "(", ")", ".", "item", "(", ")", "*", "inputs", ".", "size", "(", "0", ")", "\n", "n_elems", "+=", "inputs", ".", "size", "(", "0", ")", "\n", "run_loss", "=", "running_loss", "/", "n_elems", "\n", "if", "train", ":", "t", ".", "set_postfix", "(", "loss_lr", "=", "\"{:.4f}/{:.6f}\"", ".", "format", "(", "float", "(", "run_loss", ")", ",", "get_lr", "(", "optimizer", ")", ")", ")", "\n", "else", ":", "t", ".", "set_postfix", "(", "vl_loss", "=", "\"{:.4f}\"", ".", "format", "(", "float", "(", "run_loss", ")", ")", ")", "\n", "t", ".", "update", "(", ")", "\n", "\n", "", "", "if", "assess", ":", "return", "np", ".", "stack", "(", "preds_all", ")", ",", "np", ".", "stack", "(", "probs_all", ")", ",", "np", ".", "stack", "(", "labels_all", ")", ",", "run_loss", "\n", "return", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt_mxp.train_model": [[171, 270], ["train_lt_mxp.compare_op", "range", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "print", "utils.get_loaders.get_combo_loader", "train_lt_mxp.run_one_epoch", "utils.evaluation.evaluate_multi_cls", "utils.evaluation.evaluate_multi_cls", "print", "all_tr_aucs.append", "all_vl_aucs.append", "all_tr_mccs.append", "all_vl_mccs.append", "all_tr_baccs.append", "all_vl_baccs.append", "all_tr_ks.append", "all_vl_ks.append", "all_tr_losses.append", "all_vl_losses.append", "is_better", "numpy.isclose", "torch.no_grad", "torch.no_grad", "train_lt_mxp.run_one_epoch", "train_lt_mxp.run_one_epoch", "os.join", "os.join", "scheduler.step", "print", "print", "best_models.append", "train_lt_mxp.get_lr", "print", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "range", "train_lt_mxp.get_lr", "str().zfill", "print", "utils.model_saving_loading.save_model", "str().zfill", "str().zfill", "os.join", "os.join", "print", "utils.model_saving_loading.save_model", "print", "shutil.rmtree", "str", "sorted", "os.join", "sorted", "str", "str", "operator.itemgetter", "worst_model.split", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.compare_op", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_combo_loader", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.run_one_epoch", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.evaluate_multi_cls", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.evaluate_multi_cls", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.run_one_epoch", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.run_one_epoch", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.save_model", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.save_model"], ["", "def", "train_model", "(", "model", ",", "sampling", ",", "optimizer", ",", "train_criterion", ",", "val_criterion", ",", "do_mixup", ",", "train_loader", ",", "val_loader", ",", "\n", "scheduler", ",", "metric", ",", "n_epochs", ",", "exp_path", ",", "n_checkpoints", ")", ":", "\n", "\n", "    ", "best_loss", ",", "best_auc", ",", "best_bacc", ",", "best_k", ",", "best_mcc", ",", "best_f1", ",", "best_epoch", ",", "best_models", "=", "10", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "[", "]", "\n", "is_better", ",", "best_monitoring_metric", "=", "compare_op", "(", "metric", ")", "\n", "greater_is_better", "=", "best_monitoring_metric", "==", "0", "\n", "all_tr_aucs", ",", "all_vl_aucs", ",", "all_tr_mccs", ",", "all_vl_mccs", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "all_tr_ks", ",", "all_vl_ks", ",", "all_tr_baccs", ",", "all_vl_baccs", ",", "all_tr_losses", ",", "all_vl_losses", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "if", "model", ".", "n_classes", "==", "5", ":", "class_names", "=", "[", "'DR0'", ",", "'DR1'", ",", "'DR2'", ",", "'DR3'", ",", "'DR4'", "]", "\n", "else", ":", "class_names", "=", "[", "'C{}'", ".", "format", "(", "i", ")", "for", "i", "in", "range", "(", "model", ".", "n_classes", ")", "]", "\n", "print_conf", ",", "text_file_train", ",", "text_file_val", "=", "False", ",", "None", ",", "None", "\n", "\n", "for", "epoch", "in", "range", "(", "n_epochs", ")", ":", "\n", "        ", "print", "(", "'\\nEpoch {:d}/{:d}'", ".", "format", "(", "epoch", "+", "1", ",", "n_epochs", ")", ")", "\n", "# Modify sampling", "\n", "combo_loader", "=", "get_combo_loader", "(", "train_loader", ",", "base_sampling", "=", "sampling", ")", "\n", "# train one epoch", "\n", "_", ",", "_", ",", "_", ",", "_", "=", "run_one_epoch", "(", "combo_loader", ",", "model", ",", "train_criterion", ",", "do_mixup", ",", "optimizer", ",", "assess", "=", "True", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "tr_preds", ",", "tr_probs", ",", "tr_labels", ",", "tr_loss", "=", "run_one_epoch", "(", "train_loader", ",", "model", ",", "val_criterion", ",", "assess", "=", "True", ")", "\n", "vl_preds", ",", "vl_probs", ",", "vl_labels", ",", "vl_loss", "=", "run_one_epoch", "(", "val_loader", ",", "model", ",", "val_criterion", ",", "assess", "=", "True", ")", "\n", "\n", "\n", "", "if", "exp_path", "is", "not", "None", ":", "\n", "            ", "print_conf", "=", "True", "\n", "text_file_train", "=", "osp", ".", "join", "(", "exp_path", ",", "'performance_epoch_{}.txt'", ".", "format", "(", "str", "(", "epoch", "+", "1", ")", ".", "zfill", "(", "2", ")", ")", ")", "\n", "text_file_val", "=", "osp", ".", "join", "(", "exp_path", ",", "'performance_epoch_{}.txt'", ".", "format", "(", "str", "(", "epoch", "+", "1", ")", ".", "zfill", "(", "2", ")", ")", ")", "\n", "\n", "", "tr_auc", ",", "tr_k", ",", "tr_mcc", ",", "tr_f1", ",", "tr_bacc", ",", "tr_auc_all", ",", "tr_f1_all", "=", "evaluate_multi_cls", "(", "tr_labels", ",", "tr_preds", ",", "tr_probs", ",", "print_conf", "=", "print_conf", ",", "\n", "class_names", "=", "class_names", ",", "text_file", "=", "text_file_train", ",", "loss", "=", "tr_loss", ")", "\n", "vl_auc", ",", "vl_k", ",", "vl_mcc", ",", "vl_f1", ",", "vl_bacc", ",", "vl_auc_all", ",", "vl_f1_all", "=", "evaluate_multi_cls", "(", "vl_labels", ",", "vl_preds", ",", "vl_probs", ",", "print_conf", "=", "print_conf", ",", "\n", "class_names", "=", "class_names", ",", "text_file", "=", "text_file_val", ",", "loss", "=", "vl_loss", ",", "lr", "=", "get_lr", "(", "optimizer", ")", ")", "\n", "\n", "print", "(", "'Train||Val Loss: {:.4f}||{:.4f} - K: {:.2f}||{:.2f} - mAUC: {:.2f}||{:.2f} - MCC: {:.2f}||{:.2f} - BACC: {:.2f}||{:.2f}'", ".", "format", "(", "\n", "tr_loss", ",", "vl_loss", ",", "100", "*", "tr_k", ",", "100", "*", "vl_k", ",", "100", "*", "tr_auc", ",", "100", "*", "vl_auc", ",", "100", "*", "tr_mcc", ",", "100", "*", "vl_mcc", ",", "100", "*", "tr_bacc", ",", "100", "*", "vl_bacc", ")", ")", "\n", "\n", "all_tr_aucs", ".", "append", "(", "tr_auc_all", ")", "\n", "all_vl_aucs", ".", "append", "(", "vl_auc_all", ")", "\n", "all_tr_mccs", ".", "append", "(", "tr_mcc", ")", "\n", "all_vl_mccs", ".", "append", "(", "vl_mcc", ")", "\n", "all_tr_baccs", ".", "append", "(", "tr_bacc", ")", "\n", "all_vl_baccs", ".", "append", "(", "vl_bacc", ")", "\n", "all_tr_ks", ".", "append", "(", "tr_k", ")", "\n", "all_vl_ks", ".", "append", "(", "vl_k", ")", "\n", "all_tr_losses", ".", "append", "(", "tr_loss", ")", "\n", "all_vl_losses", ".", "append", "(", "vl_loss", ")", "\n", "\n", "# check if performance was better than anyone before and checkpoint if so", "\n", "if", "metric", "==", "'loss'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_loss", ",", "vl_loss", "\n", "elif", "metric", "==", "'kappa'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_k", ",", "vl_k", "\n", "elif", "metric", "==", "'mcc'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_mcc", ",", "vl_mcc", "\n", "elif", "metric", "==", "'f1'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_f1", ",", "vl_f1", "\n", "elif", "metric", "==", "'auc'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_auc", ",", "vl_auc", "\n", "elif", "metric", "==", "'bacc'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_bacc", ",", "vl_bacc", "\n", "\n", "if", "tr_monitoring_metric", ">", "vl_monitoring_metric", ":", "# only if we do not underfit", "\n", "            ", "scheduler", ".", "step", "(", "vl_monitoring_metric", ")", "\n", "\n", "", "if", "is_better", "(", "vl_monitoring_metric", ",", "best_monitoring_metric", ")", ":", "\n", "            ", "print", "(", "'-------- Best {} attained. {:.2f} --> {:.2f} --------'", ".", "format", "(", "metric", ",", "100", "*", "best_monitoring_metric", ",", "100", "*", "vl_monitoring_metric", ")", ")", "\n", "best_loss", ",", "best_k", ",", "best_mcc", ",", "best_f1", ",", "best_auc", ",", "best_bacc", ",", "best_epoch", "=", "vl_loss", ",", "vl_k", ",", "vl_mcc", ",", "vl_f1", ",", "vl_auc", ",", "vl_bacc", ",", "epoch", "+", "1", "\n", "best_monitoring_metric", "=", "vl_monitoring_metric", "\n", "", "else", ":", "\n", "            ", "print", "(", "'-------- Best {} so far {:.2f} at epoch {:d} --------'", ".", "format", "(", "metric", ",", "100", "*", "best_monitoring_metric", ",", "\n", "best_epoch", ")", ")", "\n", "\n", "# SAVE n best - keep deleting worse ones", "\n", "", "if", "exp_path", "is", "not", "None", ":", "\n", "            ", "s_name", "=", "'epoch_{}_K_{:.2f}_mAUC_{:.2f}_MCC_{:.2f}'", ".", "format", "(", "str", "(", "epoch", "+", "1", ")", ".", "zfill", "(", "2", ")", ",", "100", "*", "vl_k", ",", "\n", "100", "*", "vl_auc", ",", "100", "*", "vl_mcc", ")", "\n", "best_models", ".", "append", "(", "[", "osp", ".", "join", "(", "exp_path", ",", "s_name", ")", ",", "vl_monitoring_metric", "]", ")", "\n", "\n", "if", "epoch", "<", "n_checkpoints", ":", "# first n_checkpoints epochs save always", "\n", "                ", "print", "(", "'-------- Checkpointing to {}/ --------'", ".", "format", "(", "s_name", ")", ")", "\n", "save_model", "(", "osp", ".", "join", "(", "exp_path", ",", "s_name", ")", ",", "model", ",", "optimizer", ",", "weights", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "worst_model", "=", "sorted", "(", "best_models", ",", "key", "=", "itemgetter", "(", "1", ")", ",", "reverse", "=", "greater_is_better", ")", "[", "-", "1", "]", "[", "\n", "0", "]", "# False for Loss, True for K", "\n", "if", "s_name", "!=", "worst_model", ":", "# this model was better than one of the best n_checkpoints models, remove that one", "\n", "                    ", "print", "(", "'-------- Checkpointing to {}/ --------'", ".", "format", "(", "s_name", ")", ")", "\n", "save_model", "(", "osp", ".", "join", "(", "exp_path", ",", "s_name", ")", ",", "model", ",", "optimizer", ",", "weights", "=", "True", ")", "\n", "# print('before deleting', os.listdir(osp.join(exp_path, s_name)))", "\n", "print", "(", "'----------- Deleting {}/ -----------'", ".", "format", "(", "worst_model", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ")", ")", "\n", "shutil", ".", "rmtree", "(", "worst_model", ")", "\n", "best_models", "=", "sorted", "(", "best_models", ",", "key", "=", "itemgetter", "(", "1", ")", ",", "reverse", "=", "greater_is_better", ")", "[", ":", "n_checkpoints", "]", "\n", "\n", "", "", "", "if", "np", ".", "isclose", "(", "get_lr", "(", "optimizer", ")", ",", "scheduler", ".", "min_lrs", "[", "0", "]", ")", ":", "\n", "            ", "print", "(", "'Early stopping'", ")", "\n", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "best_auc", ",", "best_bacc", ",", "best_mcc", ",", "best_k", ",", "all_tr_aucs", ",", "all_vl_aucs", ",", "all_tr_mccs", ",", "all_vl_mccs", ",", "all_tr_ks", ",", "all_vl_ks", ",", "all_tr_losses", ",", "all_vl_losses", ",", "best_epoch", "\n", "\n", "", "", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "best_auc", ",", "best_bacc", ",", "best_mcc", ",", "best_k", ",", "all_tr_aucs", ",", "all_vl_aucs", ",", "all_tr_mccs", ",", "all_vl_mccs", ",", "all_tr_ks", ",", "all_vl_ks", ",", "all_tr_losses", ",", "all_vl_losses", ",", "best_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_endo.str2bool": [[19, 29], ["isinstance", "v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["def", "str2bool", "(", "v", ")", ":", "\n", "# as seen here: https://stackoverflow.com/a/43357954/3208255", "\n", "    ", "if", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "       ", "return", "v", "\n", "", "if", "v", ".", "lower", "(", ")", "in", "(", "'true'", ",", "'yes'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'false'", ",", "'no'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_endo.run_one_epoch_cls": [[45, 69], ["torch.device", "torch.device", "model.train", "model.eval", "tqdm.trange", "enumerate", "numpy.stack", "numpy.stack", "torch.cuda.is_available", "torch.cuda.is_available", "len", "model", "torch.max", "torch.max", "probs_all.extend", "preds_all.extend", "t.set_postfix", "t.update", "numpy.stack", "numpy.stack", "numpy.stack", "inputs.to.to", "torch.nn.Softmax", "torch.nn.Softmax", "probs.detach().cpu().numpy", "preds.detach().cpu().numpy", "labels_all.extend", "inputs.to.to", "labels.to", "labels.detach().cpu().numpy", "probs.detach().cpu", "preds.detach().cpu", "float", "labels.detach().cpu", "probs.detach", "preds.detach", "labels.detach"], "function", ["None"], ["def", "run_one_epoch_cls", "(", "loader", ",", "model", ",", "optimizer", "=", "None", ")", ":", "\n", "    ", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "train", "=", "optimizer", "is", "not", "None", "\n", "model", ".", "train", "(", ")", "if", "train", "else", "model", ".", "eval", "(", ")", "\n", "probs_all", ",", "preds_all", ",", "labels_all", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "with", "trange", "(", "len", "(", "loader", ")", ")", "as", "t", ":", "\n", "        ", "for", "i_batch", ",", "(", "inputs", ",", "labels", ",", "_", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "if", "loader", ".", "dataset", ".", "has_labels", ":", "\n", "                ", "inputs", ",", "labels", "=", "inputs", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", ",", "labels", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "inputs", "=", "inputs", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "", "logits", "=", "model", "(", "inputs", ")", "\n", "probs", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "logits", ")", "\n", "_", ",", "preds", "=", "torch", ".", "max", "(", "probs", ",", "1", ")", "\n", "probs_all", ".", "extend", "(", "probs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "preds_all", ".", "extend", "(", "preds", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "loader", ".", "dataset", ".", "has_labels", ":", "\n", "                ", "labels_all", ".", "extend", "(", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "run_loss", "=", "0", "\n", "t", ".", "set_postfix", "(", "vl_loss", "=", "\"{:.4f}\"", ".", "format", "(", "float", "(", "run_loss", ")", ")", ")", "\n", "t", ".", "update", "(", ")", "\n", "", "", "if", "loader", ".", "dataset", ".", "has_labels", ":", "\n", "        ", "return", "np", ".", "stack", "(", "preds_all", ")", ",", "np", ".", "stack", "(", "probs_all", ")", ",", "np", ".", "stack", "(", "labels_all", ")", "\n", "", "return", "np", ".", "stack", "(", "preds_all", ")", ",", "np", ".", "stack", "(", "probs_all", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_endo.test_cls_tta_dihedral": [[70, 91], ["test_loader.dataset.transforms.transforms.insert", "numpy.array", "numpy.mean", "numpy.argmax", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torchvision.transforms.RandomRotation", "numpy.array", "range", "torch.no_grad", "torch.no_grad", "test_with_labels_endo.run_one_epoch_cls", "np.mean.append"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.run_one_epoch_cls"], ["", "def", "test_cls_tta_dihedral", "(", "model", ",", "test_loader", ",", "n", "=", "3", ")", ":", "\n", "    ", "probs_tta", "=", "[", "]", "\n", "prs", "=", "[", "0", ",", "1", "]", "\n", "\n", "test_loader", ".", "dataset", ".", "transforms", ".", "transforms", ".", "insert", "(", "-", "1", ",", "torchvision", ".", "transforms", ".", "RandomRotation", "(", "0", ")", ")", "\n", "rotations", "=", "np", ".", "array", "(", "[", "i", "*", "360", "//", "n", "for", "i", "in", "range", "(", "n", ")", "]", ")", "\n", "for", "angle", "in", "rotations", ":", "\n", "        ", "for", "p2", "in", "prs", ":", "\n", "            ", "test_loader", ".", "dataset", ".", "transforms", ".", "transforms", "[", "2", "]", ".", "p", "=", "p2", "# pr(vertical flip)", "\n", "test_loader", ".", "dataset", ".", "transforms", ".", "transforms", "[", "-", "2", "]", ".", "degrees", "=", "[", "angle", ",", "angle", "]", "\n", "# validate one epoch, note no optimizer is passed", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "test_preds", ",", "test_probs", ",", "test_labels", "=", "run_one_epoch_cls", "(", "test_loader", ",", "model", ")", "\n", "probs_tta", ".", "append", "(", "test_probs", ")", "\n", "\n", "", "", "", "probs_tta", "=", "np", ".", "mean", "(", "np", ".", "array", "(", "probs_tta", ")", ",", "axis", "=", "0", ")", "\n", "preds_tta", "=", "np", ".", "argmax", "(", "probs_tta", ",", "axis", "=", "1", ")", "\n", "\n", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "probs_tta", ",", "preds_tta", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_endo.test_cls": [[92, 100], ["torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.no_grad", "torch.no_grad", "test_with_labels_endo.run_one_epoch_cls"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.run_one_epoch_cls"], ["", "def", "test_cls", "(", "model", ",", "test_loader", ")", ":", "\n", "# validate one epoch, note no optimizer is passed", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "test_preds", ",", "test_probs", ",", "test_labels", "=", "run_one_epoch_cls", "(", "test_loader", ",", "model", ")", "\n", "\n", "", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "test_probs", ",", "test_preds", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.get_aca": [[24, 29], ["sklearn.metrics.confusion_matrix", "numpy.mean", "numpy.diag", "numpy.divide", "numpy.sum"], "function", ["None"], ["def", "get_aca", "(", "y_true", ",", "y_pred", ")", ":", "\n", "    ", "cm", "=", "confusion_matrix", "(", "y_true", ",", "\n", "y_pred", ",", "\n", "labels", "=", "[", "0", ",", "1", ",", "2", ",", "3", ",", "4", "]", ",", "normalize", "=", "'true'", ")", "\n", "return", "np", ".", "mean", "(", "np", ".", "diag", "(", "np", ".", "divide", "(", "cm", ",", "np", ".", "sum", "(", "cm", ",", "axis", "=", "1", ")", "[", ":", ",", "None", "]", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.str2bool": [[31, 41], ["isinstance", "v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["", "def", "str2bool", "(", "v", ")", ":", "\n", "# as seen here: https://stackoverflow.com/a/43357954/3208255", "\n", "    ", "if", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "       ", "return", "v", "\n", "", "if", "v", ".", "lower", "(", ")", "in", "(", "'true'", ",", "'yes'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'false'", ",", "'no'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.run_one_epoch_cls": [[59, 83], ["torch.device", "torch.device", "model.train", "model.eval", "tqdm.trange", "enumerate", "numpy.stack", "numpy.stack", "torch.cuda.is_available", "torch.cuda.is_available", "len", "model", "torch.max", "torch.max", "probs_all.extend", "preds_all.extend", "t.set_postfix", "t.update", "numpy.stack", "numpy.stack", "numpy.stack", "inputs.to.to", "torch.nn.Softmax", "torch.nn.Softmax", "probs.detach().cpu().numpy", "preds.detach().cpu().numpy", "labels_all.extend", "inputs.to.to", "labels.to", "labels.detach().cpu().numpy", "probs.detach().cpu", "preds.detach().cpu", "float", "labels.detach().cpu", "probs.detach", "preds.detach", "labels.detach"], "function", ["None"], ["def", "run_one_epoch_cls", "(", "loader", ",", "model", ",", "optimizer", "=", "None", ")", ":", "\n", "    ", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "train", "=", "optimizer", "is", "not", "None", "\n", "model", ".", "train", "(", ")", "if", "train", "else", "model", ".", "eval", "(", ")", "\n", "probs_all", ",", "preds_all", ",", "labels_all", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "with", "trange", "(", "len", "(", "loader", ")", ")", "as", "t", ":", "\n", "        ", "for", "i_batch", ",", "(", "inputs", ",", "labels", ",", "_", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "if", "loader", ".", "dataset", ".", "has_labels", ":", "\n", "                ", "inputs", ",", "labels", "=", "inputs", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", ",", "labels", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "inputs", "=", "inputs", ".", "to", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "", "logits", "=", "model", "(", "inputs", ")", "\n", "probs", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "logits", ")", "\n", "_", ",", "preds", "=", "torch", ".", "max", "(", "probs", ",", "1", ")", "\n", "probs_all", ".", "extend", "(", "probs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "preds_all", ".", "extend", "(", "preds", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "if", "loader", ".", "dataset", ".", "has_labels", ":", "\n", "                ", "labels_all", ".", "extend", "(", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "run_loss", "=", "0", "\n", "t", ".", "set_postfix", "(", "vl_loss", "=", "\"{:.4f}\"", ".", "format", "(", "float", "(", "run_loss", ")", ")", ")", "\n", "t", ".", "update", "(", ")", "\n", "", "", "if", "loader", ".", "dataset", ".", "has_labels", ":", "\n", "        ", "return", "np", ".", "stack", "(", "preds_all", ")", ",", "np", ".", "stack", "(", "probs_all", ")", ",", "np", ".", "stack", "(", "labels_all", ")", "\n", "", "return", "np", ".", "stack", "(", "preds_all", ")", ",", "np", ".", "stack", "(", "probs_all", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.test_cls_tta_dihedral": [[84, 105], ["test_loader.dataset.transforms.transforms.insert", "numpy.array", "numpy.mean", "numpy.argmax", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "torchvision.transforms.RandomRotation", "numpy.array", "range", "torch.no_grad", "torch.no_grad", "test_with_labels_eyepacs.run_one_epoch_cls", "np.mean.append"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.run_one_epoch_cls"], ["", "def", "test_cls_tta_dihedral", "(", "model", ",", "test_loader", ",", "n", "=", "3", ")", ":", "\n", "    ", "probs_tta", "=", "[", "]", "\n", "prs", "=", "[", "0", ",", "1", "]", "\n", "\n", "test_loader", ".", "dataset", ".", "transforms", ".", "transforms", ".", "insert", "(", "-", "1", ",", "torchvision", ".", "transforms", ".", "RandomRotation", "(", "0", ")", ")", "\n", "rotations", "=", "np", ".", "array", "(", "[", "i", "*", "360", "//", "n", "for", "i", "in", "range", "(", "n", ")", "]", ")", "\n", "for", "angle", "in", "rotations", ":", "\n", "        ", "for", "p2", "in", "prs", ":", "\n", "            ", "test_loader", ".", "dataset", ".", "transforms", ".", "transforms", "[", "2", "]", ".", "p", "=", "p2", "# pr(vertical flip)", "\n", "test_loader", ".", "dataset", ".", "transforms", ".", "transforms", "[", "-", "2", "]", ".", "degrees", "=", "[", "angle", ",", "angle", "]", "\n", "# validate one epoch, note no optimizer is passed", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "test_preds", ",", "test_probs", ",", "test_labels", "=", "run_one_epoch_cls", "(", "test_loader", ",", "model", ")", "\n", "probs_tta", ".", "append", "(", "test_probs", ")", "\n", "\n", "", "", "", "probs_tta", "=", "np", ".", "mean", "(", "np", ".", "array", "(", "probs_tta", ")", ",", "axis", "=", "0", ")", "\n", "preds_tta", "=", "np", ".", "argmax", "(", "probs_tta", ",", "axis", "=", "1", ")", "\n", "\n", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "probs_tta", ",", "preds_tta", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.test_cls": [[106, 114], ["torch.cuda.empty_cache", "torch.cuda.empty_cache", "torch.no_grad", "torch.no_grad", "test_with_labels_eyepacs.run_one_epoch_cls"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.test_with_labels_eyepacs.run_one_epoch_cls"], ["", "def", "test_cls", "(", "model", ",", "test_loader", ")", ":", "\n", "# validate one epoch, note no optimizer is passed", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "test_preds", ",", "test_probs", ",", "test_labels", "=", "run_one_epoch_cls", "(", "test_loader", ",", "model", ")", "\n", "\n", "", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "test_probs", ",", "test_preds", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.compare_op": [[49, 68], ["None"], "function", ["None"], ["def", "compare_op", "(", "metric", ")", ":", "\n", "    ", "'''\n    This should return an operator that given a, b returns True if a is better than b\n    Also, let us return which is an appropriately terrible initial value for such metric\n    '''", "\n", "if", "metric", "==", "'auc'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'mcc'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'kappa'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'f1'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'bacc'", ":", "\n", "        ", "return", "operator", ".", "gt", ",", "0", "\n", "", "elif", "metric", "==", "'loss'", ":", "\n", "        ", "return", "operator", ".", "lt", ",", "np", ".", "inf", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr": [[69, 72], ["None"], "function", ["None"], ["", "", "def", "get_lr", "(", "optimizer", ")", ":", "\n", "    ", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "return", "param_group", "[", "'lr'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.partial_mixup": [[73, 81], ["input.mul().add", "input.size", "indices.size", "RuntimeError", "input.mul"], "function", ["None"], ["", "", "def", "partial_mixup", "(", "input", ":", "torch", ".", "Tensor", ",", "\n", "gamma", ":", "float", ",", "\n", "indices", ":", "torch", ".", "Tensor", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "if", "input", ".", "size", "(", "0", ")", "!=", "indices", ".", "size", "(", "0", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Size mismatch!\"", ")", "\n", "", "perm_input", "=", "input", "[", "indices", "]", "\n", "return", "input", ".", "mul", "(", "gamma", ")", ".", "add", "(", "perm_input", ",", "alpha", "=", "1", "-", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.mixup": [[83, 89], ["torch.randperm", "torch.randperm", "input.size", "train_lt.partial_mixup", "train_lt.partial_mixup"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup"], ["", "def", "mixup", "(", "input", ":", "torch", ".", "Tensor", ",", "\n", "target", ":", "torch", ".", "Tensor", ",", "\n", "gamma", ":", "float", ",", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "    ", "indices", "=", "torch", ".", "randperm", "(", "input", ".", "size", "(", "0", ")", ",", "device", "=", "input", ".", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "return", "partial_mixup", "(", "input", ",", "gamma", ",", "indices", ")", ",", "partial_mixup", "(", "target", ",", "gamma", ",", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.run_one_epoch": [[95, 150], ["model.train", "model.eval", "tqdm.trange", "enumerate", "next", "len", "inputs.size", "t.update", "numpy.stack", "numpy.stack", "numpy.stack", "model.parameters", "inputs.to", "labels.squeeze().to", "sys.exit", "train_lt.mixup", "model", "criterion", "model", "criterion", "criterion.backward", "isinstance", "optimizer.zero_grad", "model.softmax", "numpy.argmax", "probs_all.extend", "preds_all.extend", "labels_all.extend", "criterion.detach().item", "inputs.size", "t.set_postfix", "t.set_postfix", "numpy.random.beta", "model.squeeze", "optimizer.first_step", "model", "criterion", "criterion.backward", "optimizer.second_step", "optimizer.step", "logits.softmax.detach().cpu().numpy", "logits.softmax.detach().cpu().numpy", "labels.cpu().numpy", "labels.squeeze", "criterion.detach", "logits.softmax.detach().cpu", "logits.softmax.detach().cpu", "labels.cpu", "float", "train_lt.get_lr", "float", "logits.softmax.detach", "logits.softmax.detach"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.mixup", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr"], ["", "def", "run_one_epoch", "(", "loader", ",", "model", ",", "criterion", ",", "do_mixup", "=", "0.", ",", "optimizer", "=", "None", ",", "assess", "=", "False", ")", ":", "\n", "\n", "    ", "device", "=", "'cuda'", "if", "next", "(", "model", ".", "parameters", "(", ")", ")", ".", "is_cuda", "else", "'cpu'", "\n", "train", "=", "optimizer", "is", "not", "None", "# if we are in training mode there will be an optimizer and train=True here", "\n", "\n", "if", "train", ":", "model", ".", "train", "(", ")", "\n", "else", ":", "model", ".", "eval", "(", ")", "\n", "if", "assess", ":", "\n", "        ", "probs_all", ",", "preds_all", ",", "labels_all", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "", "with", "trange", "(", "len", "(", "loader", ")", ")", "as", "t", ":", "\n", "        ", "n_elems", ",", "running_loss", "=", "0", ",", "0", "\n", "for", "i_batch", ",", "(", "inputs", ",", "labels", ",", "_", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "inputs", ",", "labels", "=", "inputs", ".", "to", "(", "device", ")", ",", "labels", ".", "squeeze", "(", ")", ".", "to", "(", "device", ")", "\n", "if", "do_mixup", ">", "0", ":", "\n", "                ", "sys", ".", "exit", "(", "'Need to fix mixup to work with cross-entropy'", ")", "\n", "inputs", ",", "mixed_labels", "=", "mixup", "(", "inputs", ",", "labels", ",", "np", ".", "random", ".", "beta", "(", "a", "=", "do_mixup", ",", "b", "=", "do_mixup", ")", ")", "\n", "if", "loader", ".", "dataset", ".", "n_classes", "==", "1", ":", "mixed_labels", "=", "mixed_labels", "[", ":", ",", "1", "]", "\n", "\n", "logits", "=", "model", "(", "inputs", ")", "\n", "loss", "=", "criterion", "(", "logits", ".", "squeeze", "(", ")", ",", "mixed_labels", ")", "\n", "", "else", ":", "\n", "                ", "logits", "=", "model", "(", "inputs", ")", "\n", "loss", "=", "criterion", "(", "logits", ",", "labels", ")", "\n", "\n", "", "if", "train", ":", "# only in training mode", "\n", "                ", "loss", ".", "backward", "(", ")", "\n", "if", "isinstance", "(", "optimizer", ",", "SAM", ")", ":", "\n", "                    ", "optimizer", ".", "first_step", "(", "zero_grad", "=", "True", ")", "\n", "logits", "=", "model", "(", "inputs", ")", "\n", "loss", "=", "criterion", "(", "logits", ",", "labels", ")", "\n", "loss", ".", "backward", "(", ")", "# for grad_acc_steps=0, this is just loss", "\n", "optimizer", ".", "second_step", "(", "zero_grad", "=", "True", ")", "\n", "", "else", ":", "\n", "                    ", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "", "if", "assess", ":", "\n", "                ", "probs", "=", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "preds", "=", "np", ".", "argmax", "(", "probs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "axis", "=", "1", ")", "\n", "probs_all", ".", "extend", "(", "probs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "preds_all", ".", "extend", "(", "preds", ")", "\n", "labels_all", ".", "extend", "(", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "# Compute running loss", "\n", "", "running_loss", "+=", "loss", ".", "detach", "(", ")", ".", "item", "(", ")", "*", "inputs", ".", "size", "(", "0", ")", "\n", "n_elems", "+=", "inputs", ".", "size", "(", "0", ")", "\n", "run_loss", "=", "running_loss", "/", "n_elems", "\n", "if", "train", ":", "t", ".", "set_postfix", "(", "loss_lr", "=", "\"{:.4f}/{:.6f}\"", ".", "format", "(", "float", "(", "run_loss", ")", ",", "get_lr", "(", "optimizer", ")", ")", ")", "\n", "else", ":", "t", ".", "set_postfix", "(", "vl_loss", "=", "\"{:.4f}\"", ".", "format", "(", "float", "(", "run_loss", ")", ")", ")", "\n", "t", ".", "update", "(", ")", "\n", "\n", "", "", "if", "assess", ":", "return", "np", ".", "stack", "(", "preds_all", ")", ",", "np", ".", "stack", "(", "probs_all", ")", ",", "np", ".", "stack", "(", "labels_all", ")", ",", "run_loss", "\n", "return", "None", ",", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.train_model": [[151, 259], ["train_lt.compare_op", "range", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "print", "utils.get_loaders.modify_loader", "train_lt.run_one_epoch", "utils.evaluation.evaluate_multi_cls", "utils.evaluation.evaluate_multi_cls", "print", "all_tr_aucs.append", "all_vl_aucs.append", "all_tr_mccs.append", "all_vl_mccs.append", "all_tr_baccs.append", "all_vl_baccs.append", "all_tr_ks.append", "all_vl_ks.append", "all_tr_losses.append", "all_vl_losses.append", "is_better", "numpy.isclose", "torch.no_grad", "torch.no_grad", "train_lt.run_one_epoch", "os.join", "os.join", "print", "scheduler.step", "print", "print", "best_models.append", "train_lt.get_lr", "print", "torch.cuda.empty_cache", "torch.cuda.empty_cache", "range", "train_lt.get_lr", "str().zfill", "print", "utils.model_saving_loading.save_model", "str().zfill", "str().zfill", "os.join", "os.join", "print", "utils.model_saving_loading.save_model", "print", "shutil.rmtree", "str", "sorted", "os.join", "sorted", "str", "str", "itemgetter", "worst_model.split", "itemgetter"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.compare_op", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.modify_loader", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.run_one_epoch", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.evaluate_multi_cls", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.evaluate_multi_cls", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.run_one_epoch", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.None.train_lt.get_lr", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.save_model", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.save_model"], ["", "def", "train_model", "(", "model", ",", "sampling", ",", "optimizer", ",", "train_criterion", ",", "val_criterion", ",", "do_mixup", ",", "train_loader", ",", "val_loader", ",", "\n", "scheduler", ",", "metric", ",", "n_epochs", ",", "exp_path", ",", "n_checkpoints", ")", ":", "\n", "\n", "    ", "best_loss", ",", "best_auc", ",", "best_bacc", ",", "best_k", ",", "best_mcc", ",", "best_f1", ",", "best_epoch", ",", "best_models", "=", "10", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "[", "]", "\n", "is_better", ",", "best_monitoring_metric", "=", "compare_op", "(", "metric", ")", "\n", "greater_is_better", "=", "best_monitoring_metric", "==", "0", "\n", "all_tr_aucs", ",", "all_vl_aucs", ",", "all_tr_mccs", ",", "all_vl_mccs", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "all_tr_ks", ",", "all_vl_ks", ",", "all_tr_baccs", ",", "all_vl_baccs", ",", "all_tr_losses", ",", "all_vl_losses", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "if", "model", ".", "n_classes", "==", "5", ":", "class_names", "=", "[", "'DR0'", ",", "'DR1'", ",", "'DR2'", ",", "'DR3'", ",", "'DR4'", "]", "\n", "else", ":", "class_names", "=", "[", "'C{}'", ".", "format", "(", "i", ")", "for", "i", "in", "range", "(", "model", ".", "n_classes", ")", "]", "\n", "print_conf", ",", "text_file_train", ",", "text_file_val", "=", "False", ",", "None", ",", "None", "\n", "\n", "for", "epoch", "in", "range", "(", "n_epochs", ")", ":", "\n", "        ", "print", "(", "'\\nEpoch {:d}/{:d}'", ".", "format", "(", "epoch", "+", "1", ",", "n_epochs", ")", ")", "\n", "# Modify sampling", "\n", "mod_loader", "=", "modify_loader", "(", "train_loader", ",", "sampling", ",", "epoch", ",", "n_epochs", ")", "\n", "# train one epoch", "\n", "tr_preds", ",", "tr_probs", ",", "tr_labels", ",", "tr_loss", "=", "run_one_epoch", "(", "mod_loader", ",", "model", ",", "train_criterion", ",", "do_mixup", ",", "optimizer", ",", "assess", "=", "True", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "# tr_preds, tr_probs, tr_labels, tr_loss = run_one_epoch(train_loader, model, val_criterion, assess=True)", "\n", "            ", "vl_preds", ",", "vl_probs", ",", "vl_labels", ",", "vl_loss", "=", "run_one_epoch", "(", "val_loader", ",", "model", ",", "val_criterion", ",", "assess", "=", "True", ")", "\n", "\n", "\n", "", "if", "exp_path", "is", "not", "None", ":", "\n", "            ", "print_conf", "=", "True", "\n", "text_file_train", "=", "osp", ".", "join", "(", "exp_path", ",", "'performance_epoch_{}.txt'", ".", "format", "(", "str", "(", "epoch", "+", "1", ")", ".", "zfill", "(", "2", ")", ")", ")", "\n", "text_file_val", "=", "osp", ".", "join", "(", "exp_path", ",", "'performance_epoch_{}.txt'", ".", "format", "(", "str", "(", "epoch", "+", "1", ")", ".", "zfill", "(", "2", ")", ")", ")", "\n", "\n", "", "tr_auc", ",", "tr_k", ",", "tr_mcc", ",", "tr_f1", ",", "tr_bacc", ",", "tr_auc_all", ",", "tr_f1_all", "=", "evaluate_multi_cls", "(", "tr_labels", ",", "tr_preds", ",", "tr_probs", ",", "print_conf", "=", "print_conf", ",", "\n", "class_names", "=", "class_names", ",", "text_file", "=", "text_file_train", ",", "loss", "=", "tr_loss", ")", "\n", "\n", "vl_auc", ",", "vl_k", ",", "vl_mcc", ",", "vl_f1", ",", "vl_bacc", ",", "vl_auc_all", ",", "vl_f1_all", "=", "evaluate_multi_cls", "(", "vl_labels", ",", "vl_preds", ",", "vl_probs", ",", "print_conf", "=", "print_conf", ",", "\n", "class_names", "=", "class_names", ",", "text_file", "=", "text_file_val", ",", "loss", "=", "vl_loss", ",", "lr", "=", "get_lr", "(", "optimizer", ")", ")", "\n", "\n", "\n", "print", "(", "'Train||Val Loss: {:.4f}||{:.4f} - K: {:.2f}||{:.2f} - mAUC: {:.2f}||{:.2f} - MCC: {:.2f}||{:.2f} - BACC: {:.2f}||{:.2f}'", ".", "format", "(", "\n", "tr_loss", ",", "vl_loss", ",", "100", "*", "tr_k", ",", "100", "*", "vl_k", ",", "100", "*", "tr_auc", ",", "100", "*", "vl_auc", ",", "100", "*", "tr_mcc", ",", "100", "*", "vl_mcc", ",", "100", "*", "tr_bacc", ",", "100", "*", "vl_bacc", ")", ")", "\n", "\n", "if", "model", ".", "n_classes", "==", "6", ":", "\n", "            ", "print", "(", "'AUC: DR0={:.2f}|{:.2f} - DR1={:.2f}|{:.2f} - DR2={:.2f}|{:.2f} - DR3={:.2f}|{:.2f} - DR4={:.2f}|{:.2f} - U={:.2f}|{:.2f}'", ".", "format", "(", "\n", "100", "*", "tr_auc_all", "[", "0", "]", ",", "100", "*", "vl_auc_all", "[", "0", "]", ",", "100", "*", "tr_auc_all", "[", "1", "]", ",", "100", "*", "vl_auc_all", "[", "1", "]", ",", "\n", "100", "*", "tr_auc_all", "[", "2", "]", ",", "100", "*", "vl_auc_all", "[", "2", "]", ",", "100", "*", "tr_auc_all", "[", "3", "]", ",", "100", "*", "vl_auc_all", "[", "3", "]", ",", "\n", "100", "*", "tr_auc_all", "[", "4", "]", ",", "100", "*", "vl_auc_all", "[", "4", "]", ",", "100", "*", "tr_auc_all", "[", "5", "]", ",", "100", "*", "vl_auc_all", "[", "5", "]", ")", ")", "\n", "\n", "", "all_tr_aucs", ".", "append", "(", "tr_auc_all", ")", "\n", "all_vl_aucs", ".", "append", "(", "vl_auc_all", ")", "\n", "all_tr_mccs", ".", "append", "(", "tr_mcc", ")", "\n", "all_vl_mccs", ".", "append", "(", "vl_mcc", ")", "\n", "all_tr_baccs", ".", "append", "(", "tr_bacc", ")", "\n", "all_vl_baccs", ".", "append", "(", "vl_bacc", ")", "\n", "all_tr_ks", ".", "append", "(", "tr_k", ")", "\n", "all_vl_ks", ".", "append", "(", "vl_k", ")", "\n", "all_tr_losses", ".", "append", "(", "tr_loss", ")", "\n", "all_vl_losses", ".", "append", "(", "vl_loss", ")", "\n", "\n", "# check if performance was better than anyone before and checkpoint if so", "\n", "if", "metric", "==", "'loss'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_loss", ",", "vl_loss", "\n", "elif", "metric", "==", "'kappa'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_k", ",", "vl_k", "\n", "elif", "metric", "==", "'mcc'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_mcc", ",", "vl_mcc", "\n", "elif", "metric", "==", "'f1'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_f1", ",", "vl_f1", "\n", "elif", "metric", "==", "'auc'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_auc", ",", "vl_auc", "\n", "elif", "metric", "==", "'bacc'", ":", "tr_monitoring_metric", ",", "vl_monitoring_metric", "=", "tr_bacc", ",", "vl_bacc", "\n", "\n", "if", "tr_monitoring_metric", ">", "vl_monitoring_metric", ":", "# only if we do not underfit", "\n", "            ", "scheduler", ".", "step", "(", "vl_monitoring_metric", ")", "\n", "\n", "\n", "", "if", "is_better", "(", "vl_monitoring_metric", ",", "best_monitoring_metric", ")", ":", "\n", "            ", "print", "(", "'-------- Best {} attained. {:.2f} --> {:.2f} --------'", ".", "format", "(", "metric", ",", "100", "*", "best_monitoring_metric", ",", "100", "*", "vl_monitoring_metric", ")", ")", "\n", "best_loss", ",", "best_k", ",", "best_mcc", ",", "best_f1", ",", "best_auc", ",", "best_bacc", ",", "best_epoch", "=", "vl_loss", ",", "vl_k", ",", "vl_mcc", ",", "vl_f1", ",", "vl_auc", ",", "vl_bacc", ",", "epoch", "+", "1", "\n", "best_monitoring_metric", "=", "vl_monitoring_metric", "\n", "", "else", ":", "\n", "            ", "print", "(", "'-------- Best {} so far {:.2f} at epoch {:d} --------'", ".", "format", "(", "metric", ",", "100", "*", "best_monitoring_metric", ",", "best_epoch", ")", ")", "\n", "\n", "# SAVE n best - keep deleting worse ones", "\n", "", "from", "operator", "import", "itemgetter", "\n", "import", "shutil", "\n", "if", "exp_path", "is", "not", "None", ":", "\n", "            ", "s_name", "=", "'epoch_{}_K_{:.2f}_mAUC_{:.2f}_MCC_{:.2f}'", ".", "format", "(", "str", "(", "epoch", "+", "1", ")", ".", "zfill", "(", "2", ")", ",", "100", "*", "vl_k", ",", "100", "*", "vl_auc", ",", "100", "*", "vl_mcc", ")", "\n", "best_models", ".", "append", "(", "[", "osp", ".", "join", "(", "exp_path", ",", "s_name", ")", ",", "vl_monitoring_metric", "]", ")", "\n", "\n", "if", "epoch", "<", "n_checkpoints", ":", "# first n_checkpoints epochs save always", "\n", "                ", "print", "(", "'-------- Checkpointing to {}/ --------'", ".", "format", "(", "s_name", ")", ")", "\n", "save_model", "(", "osp", ".", "join", "(", "exp_path", ",", "s_name", ")", ",", "model", ",", "optimizer", ",", "weights", "=", "True", ")", "\n", "", "else", ":", "\n", "                ", "worst_model", "=", "sorted", "(", "best_models", ",", "key", "=", "itemgetter", "(", "1", ")", ",", "reverse", "=", "greater_is_better", ")", "[", "-", "1", "]", "[", "0", "]", "# False for Loss, True for K", "\n", "if", "s_name", "!=", "worst_model", ":", "# this model was better than one of the best n_checkpoints models, remove that one", "\n", "                    ", "print", "(", "'-------- Checkpointing to {}/ --------'", ".", "format", "(", "s_name", ")", ")", "\n", "save_model", "(", "osp", ".", "join", "(", "exp_path", ",", "s_name", ")", ",", "model", ",", "optimizer", ",", "weights", "=", "True", ")", "\n", "# print('before deleting', os.listdir(osp.join(exp_path, s_name)))", "\n", "print", "(", "'----------- Deleting {}/ -----------'", ".", "format", "(", "worst_model", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ")", ")", "\n", "shutil", ".", "rmtree", "(", "worst_model", ")", "\n", "best_models", "=", "sorted", "(", "best_models", ",", "key", "=", "itemgetter", "(", "1", ")", ",", "reverse", "=", "greater_is_better", ")", "[", ":", "n_checkpoints", "]", "\n", "\n", "\n", "", "", "", "if", "np", ".", "isclose", "(", "get_lr", "(", "optimizer", ")", ",", "scheduler", ".", "min_lrs", "[", "0", "]", ")", ":", "\n", "            ", "print", "(", "'Early stopping'", ")", "\n", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "best_auc", ",", "best_bacc", ",", "best_mcc", ",", "best_k", ",", "all_tr_aucs", ",", "all_vl_aucs", ",", "all_tr_mccs", ",", "all_vl_mccs", ",", "all_tr_ks", ",", "all_vl_ks", ",", "all_tr_losses", ",", "all_vl_losses", ",", "best_epoch", "\n", "\n", "", "", "del", "model", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "return", "best_auc", ",", "best_bacc", ",", "best_mcc", ",", "best_k", ",", "all_tr_aucs", ",", "all_vl_aucs", ",", "all_tr_mccs", ",", "all_vl_mccs", ",", "all_tr_ks", ",", "all_vl_ks", ",", "all_tr_losses", ",", "all_vl_losses", ",", "best_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.reproducibility.set_seeds": [[5, 14], ["numpy.random.seed", "torch.manual_seed", "random.seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "set_seeds", "(", "seed_value", ",", "use_cuda", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed_value", ")", "# cpu vars", "\n", "torch", ".", "manual_seed", "(", "seed_value", ")", "# cpu  vars", "\n", "random", ".", "seed", "(", "seed_value", ")", "# Python", "\n", "if", "use_cuda", ":", "\n", "        ", "torch", ".", "cuda", ".", "manual_seed", "(", "seed_value", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed_value", ")", "# gpu vars", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "# needed", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboIter.__init__": [[4, 7], ["iter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "my_loader", ")", ":", "\n", "        ", "self", ".", "my_loader", "=", "my_loader", "\n", "self", ".", "loader_iters", "=", "[", "iter", "(", "loader", ")", "for", "loader", "in", "self", ".", "my_loader", ".", "loaders", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboIter.__iter__": [[8, 10], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboIter.__next__": [[11, 18], ["combo_loader.ComboIter.my_loader.combine_batch", "loader_iter.next"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboLoader.combine_batch"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "# When the shortest loader (the one with minimum number of batches)", "\n", "# terminates, this iterator will terminates.", "\n", "# The `StopIteration` raised inside that shortest loader's `__next__`", "\n", "# method will in turn gets out of this `__next__` method.", "\n", "        ", "batches", "=", "[", "loader_iter", ".", "next", "(", ")", "for", "loader_iter", "in", "self", ".", "loader_iters", "]", "\n", "return", "self", ".", "my_loader", ".", "combine_batch", "(", "batches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboIter.__len__": [[19, 21], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "my_loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboLoader.__init__": [[30, 32], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "loaders", ")", ":", "\n", "        ", "self", ".", "loaders", "=", "loaders", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboLoader.__iter__": [[33, 35], ["combo_loader.ComboIter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "ComboIter", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboLoader.__len__": [[36, 38], ["min", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "min", "(", "[", "len", "(", "loader", ")", "for", "loader", "in", "self", ".", "loaders", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.combo_loader.ComboLoader.combine_batch": [[40, 42], ["None"], "methods", ["None"], ["", "def", "combine_batch", "(", "self", ",", "batches", ")", ":", "\n", "        ", "return", "batches", "", "", "", ""]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.save_model": [[6, 14], ["os.makedirs", "os.makedirs", "torch.save", "os.join", "model.state_dict", "optimizer.state_dict"], "function", ["None"], ["def", "save_model", "(", "path", ",", "model", ",", "optimizer", ",", "stats", "=", "None", ",", "weights", "=", "True", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "path", ",", "exist_ok", "=", "True", ")", "\n", "if", "weights", ":", "\n", "        ", "torch", ".", "save", "(", "{", "\n", "'model_state_dict'", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "'optimizer_state_dict'", ":", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'stats'", ":", "stats", "\n", "}", ",", "osp", ".", "join", "(", "path", ",", "'model_checkpoint.pth'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.load_model": [[15, 22], ["os.join", "torch.load", "model.load_state_dict"], "function", ["None"], ["", "", "def", "load_model", "(", "model", ",", "experiment_path", ",", "device", "=", "'cpu'", ",", "with_opt", "=", "False", ")", ":", "\n", "    ", "checkpoint_path", "=", "osp", ".", "join", "(", "experiment_path", ",", "'model_checkpoint.pth'", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "checkpoint_path", ",", "map_location", "=", "device", ")", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model_state_dict'", "]", ")", "\n", "if", "with_opt", ":", "\n", "        ", "return", "model", ",", "checkpoint", "[", "'stats'", "]", ",", "checkpoint", "[", "'optimizer_state_dict'", "]", "\n", "", "return", "model", ",", "checkpoint", "[", "'stats'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.model_saving_loading.str2bool": [[23, 33], ["isinstance", "v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["", "def", "str2bool", "(", "v", ")", ":", "\n", "# as seen here: https://stackoverflow.com/a/43357954/3208255", "\n", "    ", "if", "isinstance", "(", "v", ",", "bool", ")", ":", "\n", "       ", "return", "v", "\n", "", "if", "v", ".", "lower", "(", ")", "in", "(", "'true'", ",", "'yes'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'false'", ",", "'no'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'boolean value expected.'", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.BinClassDataset.__init__": [[16, 34], ["pandas.read_csv", "pandas.set_option", "filtered_df[].replace", "filtered_df[].replace", "list", "torchvision.Normalize", "df[].isin"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "csv_path", ",", "neg_classes", "=", "(", "0", ")", ",", "pos_classes", "=", "(", "1", ",", "2", ")", ",", "data_path", "=", "None", ",", "transforms", "=", "None", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "test", "=", "False", ")", ":", "\n", "        ", "self", ".", "csv_path", "=", "csv_path", "\n", "df", "=", "pd", ".", "read_csv", "(", "self", ".", "csv_path", ")", "\n", "self", ".", "data_path", "=", "data_path", "\n", "classes", "=", "neg_classes", "+", "pos_classes", "\n", "col_names", "=", "df", ".", "columns", "\n", "filtered_df", "=", "df", "[", "df", "[", "col_names", "[", "-", "1", "]", "]", ".", "isin", "(", "classes", ")", "]", "\n", "pd", ".", "set_option", "(", "'mode.chained_assignment'", ",", "None", ")", "\n", "filtered_df", "[", "col_names", "[", "-", "1", "]", "]", "=", "filtered_df", "[", "col_names", "[", "-", "1", "]", "]", ".", "replace", "(", "neg_classes", ",", "0", ")", "\n", "filtered_df", "[", "col_names", "[", "-", "1", "]", "]", "=", "filtered_df", "[", "col_names", "[", "-", "1", "]", "]", ".", "replace", "(", "pos_classes", ",", "1", ")", "\n", "self", ".", "filtered_df", "=", "filtered_df", "\n", "self", ".", "col_names", "=", "col_names", "\n", "self", ".", "im_list", "=", "list", "(", "filtered_df", ".", "image_id", ")", "\n", "self", ".", "has_labels", "=", "not", "test", "\n", "if", "self", ".", "has_labels", ":", "\n", "            ", "self", ".", "dr", "=", "filtered_df", "[", "col_names", "[", "-", "1", "]", "]", ".", "values", "\n", "", "self", ".", "transforms", "=", "transforms", "\n", "self", ".", "normalize", "=", "tr", ".", "Normalize", "(", "mean", ",", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.BinClassDataset.__getitem__": [[35, 54], ["PIL.Image.open", "get_loaders.BinClassDataset.transforms", "get_loaders.BinClassDataset.normalize", "PIL.Image.open", "os.join", "print", "os.join"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# load image and labels", "\n", "        ", "if", "self", ".", "data_path", "is", "not", "None", ":", "\n", "            ", "try", ":", "\n", "                ", "img", "=", "Image", ".", "open", "(", "osp", ".", "join", "(", "self", ".", "data_path", ",", "self", ".", "im_list", "[", "index", "]", ")", ")", "\n", "", "except", ":", "\n", "                ", "print", "(", "osp", ".", "join", "(", "self", ".", "data_path", ",", "self", ".", "im_list", "[", "index", "]", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "img", "=", "Image", ".", "open", "(", "self", ".", "im_list", "[", "index", "]", ")", "\n", "\n", "", "if", "self", ".", "has_labels", ":", "\n", "            ", "dr", "=", "self", ".", "dr", "[", "index", "]", "\n", "\n", "", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", "=", "self", ".", "transforms", "(", "img", ")", "\n", "img", "=", "self", ".", "normalize", "(", "img", ")", "\n", "", "if", "self", ".", "has_labels", ":", "\n", "            ", "return", "img", ",", "dr", ",", "self", ".", "im_list", "[", "index", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.BinClassDataset.__len__": [[55, 57], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "im_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ClassDataset.__init__": [[59, 69], ["pandas.read_csv", "torchvision.Normalize"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "csv_path", ",", "data_path", "=", "None", ",", "transforms", "=", "None", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "test", "=", "False", ")", ":", "\n", "        ", "self", ".", "csv_path", "=", "csv_path", "\n", "df", "=", "pd", ".", "read_csv", "(", "self", ".", "csv_path", ")", "\n", "self", ".", "data_path", "=", "data_path", "\n", "self", ".", "im_list", "=", "df", ".", "image_id", "\n", "self", ".", "has_labels", "=", "not", "test", "\n", "if", "self", ".", "has_labels", ":", "\n", "            ", "self", ".", "dr", "=", "df", "[", "df", ".", "columns", "[", "-", "1", "]", "]", ".", "values", "\n", "", "self", ".", "transforms", "=", "transforms", "\n", "self", ".", "normalize", "=", "tr", ".", "Normalize", "(", "mean", ",", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ClassDataset.__getitem__": [[70, 86], ["PIL.Image.open", "PIL.Image.open", "get_loaders.ClassDataset.transforms", "get_loaders.ClassDataset.normalize", "os.join"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# load image and labels", "\n", "        ", "if", "self", ".", "data_path", "is", "not", "None", ":", "\n", "            ", "img", "=", "Image", ".", "open", "(", "osp", ".", "join", "(", "self", ".", "data_path", ",", "self", ".", "im_list", "[", "index", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "Image", ".", "open", "(", "self", ".", "im_list", "[", "index", "]", ")", "\n", "\n", "", "if", "self", ".", "has_labels", ":", "\n", "            ", "dr", "=", "self", ".", "dr", "[", "index", "]", "\n", "\n", "", "if", "self", ".", "transforms", "is", "not", "None", ":", "\n", "            ", "img", "=", "self", ".", "transforms", "(", "img", ")", "\n", "img", "=", "self", ".", "normalize", "(", "img", ")", "\n", "", "if", "self", ".", "has_labels", ":", "\n", "            ", "return", "img", ",", "dr", ",", "self", ".", "im_list", "[", "index", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ClassDataset.__len__": [[87, 89], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "im_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboIter.__init__": [[93, 96], ["iter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "my_loader", ")", ":", "\n", "        ", "self", ".", "my_loader", "=", "my_loader", "\n", "self", ".", "loader_iters", "=", "[", "iter", "(", "loader", ")", "for", "loader", "in", "self", ".", "my_loader", ".", "loaders", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboIter.__iter__": [[97, 99], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboIter.__next__": [[100, 107], ["get_loaders.ComboIter.my_loader.combine_batch", "loader_iter.next"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboLoader.combine_batch"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "# When the shortest loader (the one with minimum number of batches)", "\n", "# terminates, this iterator will terminates.", "\n", "# The `StopIteration` raised inside that shortest loader's `__next__`", "\n", "# method will in turn gets out of this `__next__` method.", "\n", "        ", "batches", "=", "[", "loader_iter", ".", "next", "(", ")", "for", "loader_iter", "in", "self", ".", "loader_iters", "]", "\n", "return", "self", ".", "my_loader", ".", "combine_batch", "(", "batches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboIter.__len__": [[108, 110], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "my_loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboLoader.__init__": [[119, 121], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "loaders", ")", ":", "\n", "        ", "self", ".", "loaders", "=", "loaders", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboLoader.__iter__": [[122, 124], ["get_loaders.ComboIter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "ComboIter", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboLoader.__len__": [[125, 127], ["min", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "min", "(", "[", "len", "(", "loader", ")", "for", "loader", "in", "self", ".", "loaders", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.ComboLoader.combine_batch": [[129, 131], ["None"], "methods", ["None"], ["", "def", "combine_batch", "(", "self", ",", "batches", ")", ":", "\n", "        ", "return", "batches", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_sampling_probabilities": [[132, 160], ["sys.exit"], "function", ["None"], ["", "", "def", "get_sampling_probabilities", "(", "class_count", ",", "mode", "=", "'instance'", ",", "ep", "=", "None", ",", "n_eps", "=", "None", ")", ":", "\n", "    ", "'''\n    Note that for progressive sampling I use n_eps-1, which I find more intuitive.\n    If you are training for 10 epochs, you pass n_eps=10 to this function. Then, inside\n    the training loop you would have sth like 'for ep in range(n_eps)', so ep=0,...,9,\n    and all fits together.\n    '''", "\n", "if", "mode", "==", "'instance'", ":", "\n", "        ", "q", "=", "0", "\n", "", "elif", "mode", "==", "'class'", ":", "\n", "        ", "q", "=", "1", "\n", "", "elif", "mode", "==", "'sqrt'", ":", "\n", "        ", "q", "=", "0.5", "# 1/2", "\n", "", "elif", "mode", "==", "'cbrt'", ":", "\n", "        ", "q", "=", "0.125", "# 1/8", "\n", "", "elif", "mode", "==", "'prog'", ":", "\n", "        ", "assert", "ep", "!=", "None", "and", "n_eps", "!=", "None", ",", "'progressive sampling requires to pass values for ep and n_eps'", "\n", "relative_freq_imbal", "=", "class_count", "**", "0", "/", "(", "class_count", "**", "0", ")", ".", "sum", "(", ")", "\n", "relative_freq_bal", "=", "class_count", "**", "1", "/", "(", "class_count", "**", "1", ")", ".", "sum", "(", ")", "\n", "sampling_probabilities_imbal", "=", "relative_freq_imbal", "**", "(", "-", "1", ")", "\n", "sampling_probabilities_bal", "=", "relative_freq_bal", "**", "(", "-", "1", ")", "\n", "return", "(", "1", "-", "ep", "/", "(", "n_eps", "-", "1", ")", ")", "*", "sampling_probabilities_imbal", "+", "(", "ep", "/", "(", "n_eps", "-", "1", ")", ")", "*", "sampling_probabilities_bal", "\n", "", "else", ":", "sys", ".", "exit", "(", "'not a valid mode'", ")", "\n", "\n", "relative_freq", "=", "class_count", "**", "q", "/", "(", "class_count", "**", "q", ")", ".", "sum", "(", ")", "\n", "sampling_probabilities", "=", "relative_freq", "**", "(", "-", "1", ")", "\n", "\n", "return", "sampling_probabilities", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.modify_loader": [[161, 169], ["get_loaders.get_sampling_probabilities", "torch.utils.data.WeightedRandomSampler", "torch.utils.data.DataLoader", "numpy.unique", "len"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_sampling_probabilities"], ["", "def", "modify_loader", "(", "loader", ",", "mode", ",", "ep", "=", "None", ",", "n_eps", "=", "None", ")", ":", "\n", "    ", "class_count", "=", "np", ".", "unique", "(", "loader", ".", "dataset", ".", "dr", ",", "return_counts", "=", "True", ")", "[", "1", "]", "\n", "sampling_probs", "=", "get_sampling_probabilities", "(", "class_count", ",", "mode", "=", "mode", ",", "ep", "=", "ep", ",", "n_eps", "=", "n_eps", ")", "\n", "sample_weights", "=", "sampling_probs", "[", "loader", ".", "dataset", ".", "dr", "]", "\n", "\n", "mod_sampler", "=", "WeightedRandomSampler", "(", "weights", "=", "sample_weights", ",", "num_samples", "=", "len", "(", "sample_weights", ")", ")", "\n", "mod_loader", "=", "DataLoader", "(", "loader", ".", "dataset", ",", "batch_size", "=", "loader", ".", "batch_size", ",", "sampler", "=", "mod_sampler", ",", "num_workers", "=", "loader", ".", "num_workers", ")", "\n", "return", "mod_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_combo_loader": [[170, 179], ["get_loaders.modify_loader", "get_loaders.ComboLoader", "get_loaders.modify_loader"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.modify_loader", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.modify_loader"], ["", "def", "get_combo_loader", "(", "loader", ",", "base_sampling", "=", "'instance'", ")", ":", "\n", "    ", "if", "base_sampling", "==", "'instance'", ":", "\n", "        ", "imbalanced_loader", "=", "loader", "\n", "", "else", ":", "\n", "        ", "imbalanced_loader", "=", "modify_loader", "(", "loader", ",", "mode", "=", "base_sampling", ")", "\n", "\n", "", "balanced_loader", "=", "modify_loader", "(", "loader", ",", "mode", "=", "'class'", ")", "\n", "combo_loader", "=", "ComboLoader", "(", "[", "imbalanced_loader", ",", "balanced_loader", "]", ")", "\n", "return", "combo_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_train_val_cls_datasets": [[181, 213], ["get_loaders.ClassDataset", "get_loaders.ClassDataset", "torchvision.Resize", "torchvision.ToTensor", "torchvision.RandomHorizontalFlip", "torchvision.RandomVerticalFlip", "torchvision.RandomRotation", "torchvision.RandomAffine", "torchvision.RandomAffine", "torchvision.RandomChoice", "torchvision.ColorJitter", "torchvision.Compose", "torchvision.Compose", "print", "range", "len", "numpy.count_nonzero", "numpy.count_nonzero", "print", "numpy.unique"], "function", ["None"], ["", "def", "get_train_val_cls_datasets", "(", "csv_path_train", ",", "csv_path_val", ",", "data_path", "=", "None", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "tg_size", "=", "(", "512", ",", "512", ")", ",", "see_classes", "=", "True", ")", ":", "\n", "\n", "    ", "train_dataset", "=", "ClassDataset", "(", "csv_path", "=", "csv_path_train", ",", "data_path", "=", "data_path", ",", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "val_dataset", "=", "ClassDataset", "(", "csv_path", "=", "csv_path_val", ",", "data_path", "=", "data_path", ",", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "\n", "# transforms definition", "\n", "# required transforms", "\n", "resize", "=", "tr", ".", "Resize", "(", "tg_size", ")", "\n", "tensorizer", "=", "tr", ".", "ToTensor", "(", ")", "\n", "# geometric transforms", "\n", "h_flip", "=", "tr", ".", "RandomHorizontalFlip", "(", ")", "\n", "v_flip", "=", "tr", ".", "RandomVerticalFlip", "(", ")", "\n", "rotate", "=", "tr", ".", "RandomRotation", "(", "degrees", "=", "45", ")", "\n", "scale", "=", "tr", ".", "RandomAffine", "(", "degrees", "=", "0", ",", "scale", "=", "(", "0.95", ",", "1.20", ")", ")", "\n", "transl", "=", "tr", ".", "RandomAffine", "(", "degrees", "=", "0", ",", "translate", "=", "(", "0.05", ",", "0", ")", ")", "\n", "# either translate, rotate, or scale", "\n", "scale_transl_rot", "=", "tr", ".", "RandomChoice", "(", "[", "scale", ",", "transl", ",", "rotate", "]", ")", "\n", "# intensity transforms", "\n", "brightness", ",", "contrast", ",", "saturation", ",", "hue", "=", "0.25", ",", "0.25", ",", "0.25", ",", "0.01", "\n", "jitter", "=", "tr", ".", "ColorJitter", "(", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ")", "\n", "train_transforms", "=", "tr", ".", "Compose", "(", "[", "resize", ",", "scale_transl_rot", ",", "jitter", ",", "h_flip", ",", "v_flip", ",", "tensorizer", "]", ")", "\n", "val_transforms", "=", "tr", ".", "Compose", "(", "[", "resize", ",", "tensorizer", "]", ")", "\n", "train_dataset", ".", "transforms", "=", "train_transforms", "\n", "val_dataset", ".", "transforms", "=", "val_transforms", "\n", "if", "see_classes", ":", "\n", "        ", "print", "(", "20", "*", "'*'", ")", "\n", "for", "c", "in", "range", "(", "len", "(", "np", ".", "unique", "(", "train_dataset", ".", "dr", ")", ")", ")", ":", "\n", "            ", "exs_train", "=", "np", ".", "count_nonzero", "(", "train_dataset", ".", "dr", "==", "c", ")", "\n", "exs_val", "=", "np", ".", "count_nonzero", "(", "val_dataset", ".", "dr", "==", "c", ")", "\n", "print", "(", "'Found {:d}/{:d} train/val examples of class {}'", ".", "format", "(", "exs_train", ",", "exs_val", ",", "c", ")", ")", "\n", "\n", "", "", "return", "train_dataset", ",", "val_dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_train_val_cls_loaders": [[214, 223], ["get_loaders.get_train_val_cls_datasets", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.cuda.is_available", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_train_val_cls_datasets"], ["", "def", "get_train_val_cls_loaders", "(", "csv_path_train", ",", "csv_path_val", ",", "data_path", "=", "None", ",", "batch_size", "=", "4", ",", "tg_size", "=", "(", "512", ",", "512", ")", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "\n", "num_workers", "=", "0", ",", "see_classes", "=", "True", ")", ":", "\n", "\n", "    ", "train_dataset", ",", "val_dataset", "=", "get_train_val_cls_datasets", "(", "csv_path_train", ",", "csv_path_val", ",", "data_path", "=", "data_path", ",", "tg_size", "=", "tg_size", ",", "\n", "mean", "=", "mean", ",", "std", "=", "std", ",", "see_classes", "=", "see_classes", ")", "\n", "\n", "train_loader", "=", "DataLoader", "(", "dataset", "=", "train_dataset", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "shuffle", "=", "True", ",", "drop_last", "=", "True", ")", "\n", "val_loader", "=", "DataLoader", "(", "dataset", "=", "val_dataset", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "drop_last", "=", "True", ")", "\n", "return", "train_loader", ",", "val_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_train_val_bin_datasets": [[224, 257], ["get_loaders.BinClassDataset", "get_loaders.BinClassDataset", "torchvision.Resize", "torchvision.ToTensor", "torchvision.RandomHorizontalFlip", "torchvision.RandomVerticalFlip", "torchvision.RandomRotation", "torchvision.RandomAffine", "torchvision.RandomAffine", "torchvision.RandomChoice", "torchvision.ColorJitter", "torchvision.Compose", "torchvision.Compose", "print", "range", "len", "numpy.count_nonzero", "numpy.count_nonzero", "print", "numpy.unique"], "function", ["None"], ["", "def", "get_train_val_bin_datasets", "(", "csv_path_train", ",", "csv_path_val", ",", "neg_classes", "=", "(", "0", ")", ",", "pos_classes", "=", "(", "1", ",", "2", ")", ",", "data_path", "=", "None", ",", "\n", "mean", "=", "None", ",", "std", "=", "None", ",", "tg_size", "=", "(", "512", ",", "512", ")", ",", "see_classes", "=", "True", ")", ":", "\n", "\n", "    ", "train_dataset", "=", "BinClassDataset", "(", "csv_path", "=", "csv_path_train", ",", "neg_classes", "=", "neg_classes", ",", "pos_classes", "=", "pos_classes", ",", "data_path", "=", "data_path", ",", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "val_dataset", "=", "BinClassDataset", "(", "csv_path", "=", "csv_path_val", ",", "neg_classes", "=", "neg_classes", ",", "pos_classes", "=", "pos_classes", ",", "data_path", "=", "data_path", ",", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "\n", "# transforms definition", "\n", "# required transforms", "\n", "resize", "=", "tr", ".", "Resize", "(", "tg_size", ")", "\n", "tensorizer", "=", "tr", ".", "ToTensor", "(", ")", "\n", "# geometric transforms", "\n", "h_flip", "=", "tr", ".", "RandomHorizontalFlip", "(", ")", "\n", "v_flip", "=", "tr", ".", "RandomVerticalFlip", "(", ")", "\n", "rotate", "=", "tr", ".", "RandomRotation", "(", "degrees", "=", "45", ")", "\n", "scale", "=", "tr", ".", "RandomAffine", "(", "degrees", "=", "0", ",", "scale", "=", "(", "0.95", ",", "1.20", ")", ")", "\n", "transl", "=", "tr", ".", "RandomAffine", "(", "degrees", "=", "0", ",", "translate", "=", "(", "0.05", ",", "0", ")", ")", "\n", "# either translate, rotate, or scale", "\n", "scale_transl_rot", "=", "tr", ".", "RandomChoice", "(", "[", "scale", ",", "transl", ",", "rotate", "]", ")", "\n", "# intensity transforms", "\n", "brightness", ",", "contrast", ",", "saturation", ",", "hue", "=", "0.25", ",", "0.25", ",", "0.25", ",", "0.01", "\n", "jitter", "=", "tr", ".", "ColorJitter", "(", "brightness", ",", "contrast", ",", "saturation", ",", "hue", ")", "\n", "train_transforms", "=", "tr", ".", "Compose", "(", "[", "resize", ",", "scale_transl_rot", ",", "jitter", ",", "h_flip", ",", "v_flip", ",", "tensorizer", "]", ")", "\n", "val_transforms", "=", "tr", ".", "Compose", "(", "[", "resize", ",", "tensorizer", "]", ")", "\n", "train_dataset", ".", "transforms", "=", "train_transforms", "\n", "val_dataset", ".", "transforms", "=", "val_transforms", "\n", "if", "see_classes", ":", "\n", "        ", "print", "(", "20", "*", "'*'", ")", "\n", "for", "c", "in", "range", "(", "len", "(", "np", ".", "unique", "(", "train_dataset", ".", "dr", ")", ")", ")", ":", "\n", "            ", "exs_train", "=", "np", ".", "count_nonzero", "(", "train_dataset", ".", "dr", "==", "c", ")", "\n", "exs_val", "=", "np", ".", "count_nonzero", "(", "val_dataset", ".", "dr", "==", "c", ")", "\n", "print", "(", "'Found {:d}/{:d} train/val examples of class {}'", ".", "format", "(", "exs_train", ",", "exs_val", ",", "c", ")", ")", "\n", "\n", "", "", "return", "train_dataset", ",", "val_dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_train_val_bin_cls_loaders": [[258, 267], ["get_loaders.get_train_val_bin_datasets", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.cuda.is_available", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_train_val_bin_datasets"], ["", "def", "get_train_val_bin_cls_loaders", "(", "csv_path_train", ",", "csv_path_val", ",", "neg_classes", "=", "(", "0", ")", ",", "pos_classes", "=", "(", "1", ",", "2", ")", ",", "data_path", "=", "None", ",", "batch_size", "=", "4", ",", "tg_size", "=", "(", "512", ",", "512", ")", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "\n", "num_workers", "=", "0", ",", "see_classes", "=", "True", ")", ":", "\n", "\n", "    ", "train_dataset", ",", "val_dataset", "=", "get_train_val_bin_datasets", "(", "csv_path_train", ",", "csv_path_val", ",", "neg_classes", "=", "neg_classes", ",", "pos_classes", "=", "pos_classes", ",", "\n", "data_path", "=", "data_path", ",", "tg_size", "=", "tg_size", ",", "mean", "=", "mean", ",", "std", "=", "std", ",", "see_classes", "=", "see_classes", ")", "\n", "\n", "train_loader", "=", "DataLoader", "(", "dataset", "=", "train_dataset", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "shuffle", "=", "True", ",", "drop_last", "=", "True", ")", "\n", "val_loader", "=", "DataLoader", "(", "dataset", "=", "val_dataset", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "drop_last", "=", "True", ")", "\n", "return", "train_loader", ",", "val_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_test_cls_dataset": [[269, 283], ["get_loaders.ClassDataset", "torchvision.Resize", "torchvision.RandomHorizontalFlip", "torchvision.RandomVerticalFlip", "torchvision.ToTensor", "torchvision.Compose"], "function", ["None"], ["", "def", "get_test_cls_dataset", "(", "csv_path_test", ",", "data_path", "=", "None", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "tg_size", "=", "(", "512", ",", "512", ")", ",", "test", "=", "False", ")", ":", "\n", "\n", "    ", "test_dataset", "=", "ClassDataset", "(", "csv_path_test", ",", "data_path", "=", "data_path", ",", "mean", "=", "mean", ",", "std", "=", "std", ",", "test", "=", "test", ")", "\n", "\n", "size", "=", "tg_size", "\n", "# required transforms", "\n", "resize", "=", "tr", ".", "Resize", "(", "size", ")", "\n", "h_flip", "=", "tr", ".", "RandomHorizontalFlip", "(", "p", "=", "0", ")", "\n", "v_flip", "=", "tr", ".", "RandomVerticalFlip", "(", "p", "=", "0", ")", "\n", "tensorizer", "=", "tr", ".", "ToTensor", "(", ")", "\n", "test_transforms", "=", "tr", ".", "Compose", "(", "[", "resize", ",", "h_flip", ",", "v_flip", ",", "tensorizer", "]", ")", "\n", "test_dataset", ".", "transforms", "=", "test_transforms", "\n", "\n", "return", "test_dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_test_cls_loader": [[284, 288], ["get_loaders.get_test_cls_dataset", "torch.utils.data.DataLoader", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.get_test_cls_dataset"], ["", "def", "get_test_cls_loader", "(", "csv_path_test", ",", "data_path", "=", "None", ",", "batch_size", "=", "8", ",", "tg_size", "=", "(", "512", ",", "512", ")", ",", "mean", "=", "None", ",", "std", "=", "None", ",", "num_workers", "=", "8", ",", "test", "=", "False", ")", ":", "\n", "    ", "test_dataset", "=", "get_test_cls_dataset", "(", "csv_path_test", ",", "data_path", "=", "data_path", ",", "tg_size", "=", "tg_size", ",", "mean", "=", "mean", ",", "std", "=", "std", ",", "test", "=", "test", ")", "\n", "test_loader", "=", "DataLoader", "(", "dataset", "=", "test_dataset", ",", "batch_size", "=", "batch_size", ",", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ")", "\n", "return", "test_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.modify_dataset_bin": [[289, 346], ["copy.deepcopy", "copy.deepcopy", "numpy.unique", "isinstance", "pandas.concat", "list", "ims_per_class.append", "set", "len", "int", "new_ims_per_class.append", "ims_per_class[].sample", "print", "new_ims_per_class.append", "print", "new_ims_per_class.append", "pandas.merge().sort_values", "new_ims_per_class.append", "print", "ims_per_class[].sample", "interesting_examples.tail.head", "int", "interesting_examples.tail.head", "interesting_examples.tail.tail", "new_ims_per_class[].duplicated", "pandas.merge", "new_ims_per_class[].duplicated"], "function", ["None"], ["", "def", "modify_dataset_bin", "(", "train_loader", ",", "csv_train_path", ",", "im_interest", "=", "None", ",", "keep_samples", "=", "2000", ",", "see_classes", "=", "True", ")", ":", "\n", "    ", "if", "list", "(", "set", "(", "keep_samples", ")", ")", "==", "[", "1", "]", ":", "return", "train_loader", "\n", "train_loader_new", "=", "copy", ".", "deepcopy", "(", "train_loader", ")", "# note, otherwise we modify underlying dataset", "\n", "train_df", "=", "copy", ".", "deepcopy", "(", "train_loader", ".", "dataset", ".", "filtered_df", ")", "\n", "col_names", "=", "train_df", ".", "columns", "\n", "classes", "=", "np", ".", "unique", "(", "train_df", "[", "col_names", "[", "-", "1", "]", "]", ")", "\n", "sample_spec", "=", "False", "\n", "if", "isinstance", "(", "keep_samples", ",", "numbers", ".", "Number", ")", ":", "\n", "        ", "keep_samples", "=", "len", "(", "classes", ")", "*", "[", "keep_samples", "]", "# e.g., get 2,000 samples for each class", "\n", "sample_spec", "=", "True", "\n", "", "ims_per_class", "=", "[", "]", "\n", "new_ims_per_class", "=", "[", "]", "\n", "\n", "for", "c", "in", "classes", ":", "\n", "        ", "ims_per_class", ".", "append", "(", "train_df", ".", "loc", "[", "train_df", "[", "col_names", "[", "-", "1", "]", "]", "==", "c", "]", ")", "\n", "n_ims", "=", "ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", "\n", "if", "sample_spec", ":", "\n", "            ", "oversample", "=", "n_ims", "<", "keep_samples", "[", "c", "]", "\n", "n_samples", "=", "keep_samples", "[", "c", "]", "\n", "", "else", ":", "\n", "            ", "oversample", "=", "n_ims", "<", "keep_samples", "[", "c", "]", "*", "n_ims", "\n", "n_samples", "=", "int", "(", "keep_samples", "[", "c", "]", "*", "n_ims", ")", "\n", "\n", "", "if", "oversample", ":", "# when we oversample, we use bootstrapping", "\n", "            ", "new_ims_per_class", ".", "append", "(", "ims_per_class", "[", "c", "]", ".", "sample", "(", "n", "=", "n_samples", ",", "replace", "=", "oversample", ")", ")", "\n", "duplicate", "=", "new_ims_per_class", "[", "c", "]", "[", "new_ims_per_class", "[", "c", "]", ".", "duplicated", "(", ")", "]", ".", "shape", "[", "0", "]", "\n", "if", "see_classes", ":", "\n", "# print('Class {}: nr samples (%duplicated): {:d} ({:.2%})'.format(c, new_ims_per_class[c].shape[0], duplicate/new_ims_per_class[c].shape[0]))", "\n", "                ", "print", "(", "'Class {}: nr samples (%duplicated): {:d} ({:d})'", ".", "format", "(", "c", ",", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ",", "duplicate", ")", ")", "\n", "", "", "elif", "keep_samples", "[", "c", "]", "==", "1", ":", "# neither oversample nor undersample", "\n", "            ", "new_ims_per_class", ".", "append", "(", "ims_per_class", "[", "c", "]", ")", "\n", "duplicate", "=", "0", "\n", "if", "see_classes", ":", "\n", "                ", "print", "(", "'Class {}: nr samples (%duplicated): {:d} ({:.0%})'", ".", "format", "(", "c", ",", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ",", "duplicate", "/", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "", "else", ":", "# when we undersample is when we want to choose the best examples", "\n", "            ", "if", "im_interest", "is", "None", ":", "# if no interest is provided we fall back to random sampling, but no replacement", "\n", "                ", "new_ims_per_class", ".", "append", "(", "ims_per_class", "[", "c", "]", ".", "sample", "(", "n", "=", "n_samples", ",", "replace", "=", "False", ")", ")", "\n", "", "else", ":", "# if interest is provided, we discard less interesting images", "\n", "                ", "interesting_examples", "=", "pd", ".", "merge", "(", "ims_per_class", "[", "c", "]", ",", "im_interest", ",", "on", "=", "'image_id'", ")", ".", "sort_values", "(", "by", "=", "'interest'", ",", "ascending", "=", "False", ",", "inplace", "=", "False", ")", "\n", "if", "not", "discard_top_losers", ":", "\n", "                    ", "interesting_examples", "=", "interesting_examples", ".", "head", "(", "n", "=", "n_samples", ")", "# keep exs with greater losses", "\n", "", "else", ":", "\n", "                    ", "to_be_kept", "=", "n_samples", "\n", "added_slack", "=", "int", "(", "1.05", "*", "n_samples", ")", "\n", "interesting_examples", "=", "interesting_examples", ".", "head", "(", "n", "=", "added_slack", ")", "# retain 105% interesting images", "\n", "interesting_examples", "=", "interesting_examples", ".", "tail", "(", "n", "=", "to_be_kept", ")", "# discard top 5%", "\n", "", "new_ims_per_class", ".", "append", "(", "interesting_examples", ")", "\n", "", "duplicate", "=", "new_ims_per_class", "[", "c", "]", "[", "new_ims_per_class", "[", "c", "]", ".", "duplicated", "(", ")", "]", ".", "shape", "[", "0", "]", "\n", "if", "see_classes", ":", "\n", "# print('Class {}: nr samples (%duplicated): {:d} ({:.2%})'.format(c, new_ims_per_class[c].shape[0], duplicate/new_ims_per_class[c].shape[0]))", "\n", "                ", "print", "(", "'Class {}: nr samples (%duplicated): {:d} ({:d})'", ".", "format", "(", "c", ",", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ",", "duplicate", ")", ")", "\n", "", "", "", "train_df_under_oversampled", "=", "pd", ".", "concat", "(", "new_ims_per_class", ")", "\n", "\n", "train_loader_new", ".", "dataset", ".", "im_list", "=", "train_df_under_oversampled", "[", "'image_id'", "]", ".", "values", "\n", "train_loader_new", ".", "dataset", ".", "dr", "=", "train_df_under_oversampled", "[", "col_names", "[", "-", "1", "]", "]", ".", "values", "\n", "\n", "return", "train_loader_new", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.get_loaders.modify_dataset": [[347, 405], ["copy.deepcopy", "pandas.read_csv", "numpy.unique", "isinstance", "pandas.concat", "list", "ims_per_class.append", "set", "len", "int", "new_ims_per_class.append", "ims_per_class[].sample", "print", "new_ims_per_class.append", "print", "new_ims_per_class.append", "pandas.merge().sort_values", "new_ims_per_class.append", "print", "ims_per_class[].sample", "interesting_examples.tail.head", "int", "interesting_examples.tail.head", "interesting_examples.tail.tail", "new_ims_per_class[].duplicated", "pandas.merge", "new_ims_per_class[].duplicated"], "function", ["None"], ["", "def", "modify_dataset", "(", "train_loader", ",", "csv_train_path", ",", "im_interest", "=", "None", ",", "keep_samples", "=", "2000", ",", "see_classes", "=", "True", ",", "discard_top_losers", "=", "True", ")", ":", "\n", "    ", "if", "list", "(", "set", "(", "keep_samples", ")", ")", "==", "[", "1", "]", ":", "return", "train_loader", "\n", "train_loader_new", "=", "copy", ".", "deepcopy", "(", "train_loader", ")", "# note, otherwise we modify underlying dataset", "\n", "train_df", "=", "pd", ".", "read_csv", "(", "csv_train_path", ")", "\n", "\n", "col_names", "=", "train_df", ".", "columns", "\n", "classes", "=", "np", ".", "unique", "(", "train_df", "[", "col_names", "[", "-", "1", "]", "]", ")", "\n", "sample_spec", "=", "False", "\n", "if", "isinstance", "(", "keep_samples", ",", "numbers", ".", "Number", ")", ":", "\n", "        ", "keep_samples", "=", "len", "(", "classes", ")", "*", "[", "keep_samples", "]", "# e.g., get 2,000 samples for each class", "\n", "sample_spec", "=", "True", "\n", "", "ims_per_class", "=", "[", "]", "\n", "new_ims_per_class", "=", "[", "]", "\n", "\n", "for", "c", "in", "classes", ":", "\n", "        ", "ims_per_class", ".", "append", "(", "train_df", ".", "loc", "[", "train_df", "[", "col_names", "[", "-", "1", "]", "]", "==", "c", "]", ")", "\n", "n_ims", "=", "ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", "\n", "if", "sample_spec", ":", "\n", "            ", "oversample", "=", "n_ims", "<", "keep_samples", "[", "c", "]", "\n", "n_samples", "=", "keep_samples", "[", "c", "]", "\n", "", "else", ":", "\n", "            ", "oversample", "=", "n_ims", "<", "keep_samples", "[", "c", "]", "*", "n_ims", "\n", "n_samples", "=", "int", "(", "keep_samples", "[", "c", "]", "*", "n_ims", ")", "\n", "\n", "", "if", "oversample", ":", "# when we oversample, we use bootstrapping", "\n", "            ", "new_ims_per_class", ".", "append", "(", "ims_per_class", "[", "c", "]", ".", "sample", "(", "n", "=", "n_samples", ",", "replace", "=", "oversample", ")", ")", "\n", "duplicate", "=", "new_ims_per_class", "[", "c", "]", "[", "new_ims_per_class", "[", "c", "]", ".", "duplicated", "(", ")", "]", ".", "shape", "[", "0", "]", "\n", "if", "see_classes", ":", "\n", "# print('Class {}: nr samples (%duplicated): {:d} ({:.2%})'.format(c, new_ims_per_class[c].shape[0], duplicate/new_ims_per_class[c].shape[0]))", "\n", "                ", "print", "(", "'Class {}: nr samples (%duplicated): {:d} ({:d})'", ".", "format", "(", "c", ",", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ",", "duplicate", ")", ")", "\n", "", "", "elif", "keep_samples", "[", "c", "]", "==", "1", ":", "# neither oversample nor undersample", "\n", "            ", "new_ims_per_class", ".", "append", "(", "ims_per_class", "[", "c", "]", ")", "\n", "duplicate", "=", "0", "\n", "if", "see_classes", ":", "\n", "                ", "print", "(", "'Class {}: nr samples (%duplicated): {:d} ({:.0%})'", ".", "format", "(", "c", ",", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ",", "duplicate", "/", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "", "else", ":", "# when we undersample is when we want to choose the best examples", "\n", "            ", "if", "im_interest", "is", "None", ":", "# if no interest is provided we fall back to random sampling, but no replacement", "\n", "                ", "new_ims_per_class", ".", "append", "(", "ims_per_class", "[", "c", "]", ".", "sample", "(", "n", "=", "n_samples", ",", "replace", "=", "False", ")", ")", "\n", "", "else", ":", "# if interest is provided, we discard less interesting images", "\n", "                ", "interesting_examples", "=", "pd", ".", "merge", "(", "ims_per_class", "[", "c", "]", ",", "im_interest", ",", "on", "=", "'image_id'", ")", ".", "sort_values", "(", "by", "=", "'interest'", ",", "ascending", "=", "False", ",", "inplace", "=", "False", ")", "\n", "if", "not", "discard_top_losers", ":", "\n", "                    ", "interesting_examples", "=", "interesting_examples", ".", "head", "(", "n", "=", "n_samples", ")", "# keep exs with greater losses", "\n", "", "else", ":", "\n", "                    ", "to_be_kept", "=", "n_samples", "\n", "added_slack", "=", "int", "(", "1.05", "*", "n_samples", ")", "\n", "interesting_examples", "=", "interesting_examples", ".", "head", "(", "n", "=", "added_slack", ")", "# retain 105% interesting images", "\n", "interesting_examples", "=", "interesting_examples", ".", "tail", "(", "n", "=", "to_be_kept", ")", "# discard top 5%", "\n", "", "new_ims_per_class", ".", "append", "(", "interesting_examples", ")", "\n", "", "duplicate", "=", "new_ims_per_class", "[", "c", "]", "[", "new_ims_per_class", "[", "c", "]", ".", "duplicated", "(", ")", "]", ".", "shape", "[", "0", "]", "\n", "if", "see_classes", ":", "\n", "# print('Class {}: nr samples (%duplicated): {:d} ({:.2%})'.format(c, new_ims_per_class[c].shape[0], duplicate/new_ims_per_class[c].shape[0]))", "\n", "                ", "print", "(", "'Class {}: nr samples (%duplicated): {:d} ({:d})'", ".", "format", "(", "c", ",", "new_ims_per_class", "[", "c", "]", ".", "shape", "[", "0", "]", ",", "duplicate", ")", ")", "\n", "", "", "", "train_df_under_oversampled", "=", "pd", ".", "concat", "(", "new_ims_per_class", ")", "\n", "\n", "train_loader_new", ".", "dataset", ".", "im_list", "=", "train_df_under_oversampled", "[", "'image_id'", "]", ".", "values", "\n", "train_loader_new", ".", "dataset", ".", "dr", "=", "train_df_under_oversampled", "[", "'dr'", "]", ".", "values", "\n", "\n", "return", "train_loader_new", "", "", ""]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.metric.compute_metric": [[5, 58], ["len", "numpy.argmax", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "sklearn.metrics.accuracy_score", "sklearn.metrics.cohen_kappa_score", "range", "sklearn.metrics.f1_score", "sklearn.metrics.confusion_matrix().ravel", "sklearn.metrics.roc_auc_score", "sklearn.metrics.roc_curve", "ROC_curve.update", "sum", "sum", "sum", "sum", "sum", "sum", "sklearn.metrics.confusion_matrix", "str", "str", "str", "str"], "function", ["None"], ["def", "compute_metric", "(", "datanpGT", ",", "datanpPRED", ",", "target_names", ")", ":", "\n", "\n", "    ", "n_class", "=", "len", "(", "target_names", ")", "\n", "argmaxPRED", "=", "np", ".", "argmax", "(", "datanpPRED", ",", "axis", "=", "1", ")", "\n", "F1_metric", "=", "np", ".", "zeros", "(", "[", "n_class", ",", "1", "]", ")", "\n", "tn", "=", "np", ".", "zeros", "(", "[", "n_class", ",", "1", "]", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "[", "n_class", ",", "1", "]", ")", "\n", "fn", "=", "np", ".", "zeros", "(", "[", "n_class", ",", "1", "]", ")", "\n", "tp", "=", "np", ".", "zeros", "(", "[", "n_class", ",", "1", "]", ")", "\n", "\n", "Accuracy_score", "=", "accuracy_score", "(", "datanpGT", ",", "argmaxPRED", ")", "\n", "ROC_curve", "=", "{", "}", "\n", "mAUC", "=", "0", "\n", "\n", "k", "=", "kappa", "(", "datanpGT", ",", "argmaxPRED", ",", "weights", "=", "'quadratic'", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_class", ")", ":", "\n", "        ", "tmp_label", "=", "datanpGT", "==", "i", "\n", "tmp_pred", "=", "argmaxPRED", "==", "i", "\n", "F1_metric", "[", "i", "]", "=", "f1_score", "(", "tmp_label", ",", "tmp_pred", ")", "\n", "tn", "[", "i", "]", ",", "fp", "[", "i", "]", ",", "fn", "[", "i", "]", ",", "tp", "[", "i", "]", "=", "confusion_matrix", "(", "tmp_label", ",", "tmp_pred", ")", ".", "ravel", "(", ")", "\n", "outAUROC", "=", "roc_auc_score", "(", "tmp_label", ",", "datanpPRED", "[", ":", ",", "i", "]", ")", "\n", "\n", "mAUC", "=", "mAUC", "+", "outAUROC", "\n", "[", "roc_fpr", ",", "roc_tpr", ",", "roc_thresholds", "]", "=", "roc_curve", "(", "tmp_label", ",", "datanpPRED", "[", ":", ",", "i", "]", ")", "\n", "\n", "ROC_curve", ".", "update", "(", "{", "'ROC_fpr_'", "+", "str", "(", "i", ")", ":", "roc_fpr", ",", "\n", "'ROC_tpr_'", "+", "str", "(", "i", ")", ":", "roc_tpr", ",", "\n", "'ROC_T_'", "+", "str", "(", "i", ")", ":", "roc_thresholds", ",", "\n", "'AUC_'", "+", "str", "(", "i", ")", ":", "outAUROC", "}", ")", "\n", "\n", "", "mPrecision", "=", "sum", "(", "tp", ")", "/", "sum", "(", "tp", "+", "fp", ")", "\n", "mRecall", "=", "sum", "(", "tp", ")", "/", "sum", "(", "tp", "+", "fn", ")", "\n", "output", "=", "{", "\n", "'class_name'", ":", "target_names", ",", "\n", "'quad_K'", ":", "k", ",", "\n", "'F1'", ":", "F1_metric", ",", "\n", "'AUC'", ":", "mAUC", "/", "3", ",", "\n", "'Accuracy'", ":", "Accuracy_score", ",", "\n", "\n", "'Sensitivity'", ":", "tp", "/", "(", "tp", "+", "fn", ")", ",", "\n", "'Precision'", ":", "tp", "/", "(", "tp", "+", "fp", ")", ",", "\n", "'Specificity'", ":", "tn", "/", "(", "fp", "+", "tn", ")", ",", "\n", "'ROC_curve'", ":", "ROC_curve", ",", "\n", "'tp'", ":", "tp", ",", "'tn'", ":", "tn", ",", "'fp'", ":", "fp", ",", "'fn'", ":", "fn", ",", "\n", "\n", "'micro-Precision'", ":", "mPrecision", ",", "\n", "'micro-Sensitivity'", ":", "mRecall", ",", "\n", "'micro-Specificity'", ":", "sum", "(", "tn", ")", "/", "sum", "(", "fp", "+", "tn", ")", ",", "\n", "'micro-F1'", ":", "2", "*", "mPrecision", "*", "mRecall", "/", "(", "mPrecision", "+", "mRecall", ")", ",", "\n", "}", "\n", "\n", "return", "output", "\n", "", ""]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.iou_score": [[8, 13], ["numpy.logical_and", "numpy.logical_or", "numpy.sum", "numpy.sum"], "function", ["None"], ["def", "iou_score", "(", "target", ",", "prediction", ")", ":", "\n", "    ", "intersection", "=", "np", ".", "logical_and", "(", "target", ",", "prediction", ")", "\n", "union", "=", "np", ".", "logical_or", "(", "target", ",", "prediction", ")", "\n", "iou_score", "=", "np", ".", "sum", "(", "intersection", ")", "/", "(", "np", ".", "sum", "(", "union", ")", "+", "1e-6", ")", "\n", "return", "iou_score", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.dice_score": [[14, 21], ["numpy.asarray().astype", "numpy.asarray().astype", "numpy.logical_and", "np.asarray().astype.sum", "np.asarray().astype.sum", "numpy.asarray", "numpy.asarray", "np.logical_and.sum"], "function", ["None"], ["", "def", "dice_score", "(", "actual", ",", "predicted", ")", ":", "\n", "    ", "actual", "=", "np", ".", "asarray", "(", "actual", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "predicted", "=", "np", ".", "asarray", "(", "predicted", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "im_sum", "=", "actual", ".", "sum", "(", ")", "+", "predicted", ".", "sum", "(", ")", "\n", "if", "im_sum", "==", "0", ":", "return", "1", "\n", "intersection", "=", "np", ".", "logical_and", "(", "actual", ",", "predicted", ")", "\n", "return", "2.", "*", "intersection", ".", "sum", "(", ")", "/", "im_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.fast_auc": [[23, 28], ["scipy.stats.rankdata", "numpy.sum", "len", "numpy.sum"], "function", ["None"], ["", "def", "fast_auc", "(", "actual", ",", "predicted", ")", ":", "\n", "    ", "r", "=", "rankdata", "(", "predicted", ")", "\n", "n_pos", "=", "np", ".", "sum", "(", "actual", ")", "\n", "n_neg", "=", "len", "(", "actual", ")", "-", "n_pos", "\n", "return", "(", "np", ".", "sum", "(", "r", "[", "actual", "==", "1", "]", ")", "-", "n_pos", "*", "(", "n_pos", "+", "1", ")", "/", "2", ")", "/", "(", "n_pos", "*", "n_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.print_cm": [[29, 69], ["max", "enumerate", "print", "print", "len", "len", "print", "print", "print", "print", "range", "print", "print", "print", "print", "len", "print", "print", "open", "len", "open", "open", "print", "print", "len", "len", "open", "open", "open", "float", "open"], "function", ["None"], ["", "def", "print_cm", "(", "cm", ",", "labels", ",", "hide_zeroes", "=", "False", ",", "hide_diagonal", "=", "False", ",", "hide_threshold", "=", "None", ",", "text_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    pretty print for confusion matrixes\n    https://gist.github.com/zachguo/10296432\n    \"\"\"", "\n", "if", "text_file", "is", "None", ":", "print", "(", "\"\\n\"", ",", "end", "=", "\" \"", ")", "\n", "else", ":", "print", "(", "\"\\n\"", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "\n", "columnwidth", "=", "max", "(", "[", "len", "(", "x", ")", "for", "x", "in", "labels", "]", "+", "[", "5", "]", ")", "# 5 is value length", "\n", "empty_cell", "=", "\" \"", "*", "columnwidth", "\n", "\n", "fst_empty_cell", "=", "(", "columnwidth", "-", "3", ")", "//", "2", "*", "\" \"", "+", "\"t/p\"", "+", "(", "columnwidth", "-", "3", ")", "//", "2", "*", "\" \"", "\n", "\n", "if", "len", "(", "fst_empty_cell", ")", "<", "len", "(", "empty_cell", ")", ":", "\n", "        ", "fst_empty_cell", "=", "\" \"", "*", "(", "len", "(", "empty_cell", ")", "-", "len", "(", "fst_empty_cell", ")", ")", "+", "fst_empty_cell", "\n", "# Print header", "\n", "", "if", "text_file", "is", "None", ":", "print", "(", "\"    \"", "+", "fst_empty_cell", ",", "end", "=", "\" \"", ")", "\n", "else", ":", "print", "(", "\"    \"", "+", "fst_empty_cell", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "\n", "for", "label", "in", "labels", ":", "\n", "        ", "if", "text_file", "is", "None", ":", "print", "(", "\"%{0}s\"", ".", "format", "(", "columnwidth", ")", "%", "label", ",", "end", "=", "\" \"", ")", "\n", "else", ":", "print", "(", "\"%{0}s\"", ".", "format", "(", "columnwidth", ")", "%", "label", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "", "if", "text_file", "is", "None", ":", "print", "(", ")", "\n", "else", ":", "print", "(", "' '", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "# Print rows", "\n", "for", "i", ",", "label1", "in", "enumerate", "(", "labels", ")", ":", "\n", "        ", "if", "text_file", "is", "None", ":", "print", "(", "\"    %{0}s\"", ".", "format", "(", "columnwidth", ")", "%", "label1", ",", "end", "=", "\" \"", ")", "\n", "else", ":", "print", "(", "\"    %{0}s\"", ".", "format", "(", "columnwidth", ")", "%", "label1", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "labels", ")", ")", ":", "\n", "            ", "cell", "=", "\"%{}d\"", ".", "format", "(", "columnwidth", ")", "%", "cm", "[", "i", ",", "j", "]", "\n", "if", "hide_zeroes", ":", "\n", "                ", "cell", "=", "cell", "if", "float", "(", "cm", "[", "i", ",", "j", "]", ")", "!=", "0", "else", "empty_cell", "\n", "", "if", "hide_diagonal", ":", "\n", "                ", "cell", "=", "cell", "if", "i", "!=", "j", "else", "empty_cell", "\n", "", "if", "hide_threshold", ":", "\n", "                ", "cell", "=", "cell", "if", "cm", "[", "i", ",", "j", "]", ">", "hide_threshold", "else", "empty_cell", "\n", "", "if", "text_file", "is", "None", ":", "print", "(", "cell", ",", "end", "=", "\" \"", ")", "\n", "else", ":", "print", "(", "cell", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "", "if", "text_file", "is", "None", ":", "print", "(", ")", "\n", "else", ":", "print", "(", "' '", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.get_one_hot_np": [[70, 73], ["res.reshape", "numpy.eye", "numpy.array().reshape", "list", "numpy.array"], "function", ["None"], ["", "", "def", "get_one_hot_np", "(", "targets", ",", "nb_classes", ")", ":", "\n", "    ", "res", "=", "np", ".", "eye", "(", "nb_classes", ")", "[", "np", ".", "array", "(", "targets", ")", ".", "reshape", "(", "-", "1", ")", "]", "\n", "return", "res", ".", "reshape", "(", "list", "(", "targets", ".", "shape", ")", "+", "[", "nb_classes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.evaluate_bin_cls": [[74, 88], ["numpy.unique", "sklearn.metrics.f1_score", "sklearn.metrics.roc_auc_score", "sklearn.metrics.accuracy_score", "print", "sklearn.metrics.confusion_matrix", "evaluation.print_cm", "open"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.print_cm"], ["", "def", "evaluate_bin_cls", "(", "y_true", ",", "y_pred", ",", "y_proba", ",", "print_conf", "=", "True", ",", "text_file", "=", "None", ",", "class_names", "=", "None", ",", "loss", "=", "0", ")", ":", "\n", "    ", "classes", ",", "_", "=", "np", ".", "unique", "(", "y_true", ",", "return_counts", "=", "True", ")", "\n", "f1", "=", "f1_score", "(", "y_true", ",", "y_pred", ")", "\n", "auc", "=", "roc_auc_score", "(", "y_true", ",", "y_proba", ")", "\n", "\n", "acc", "=", "accuracy_score", "(", "y_true", ",", "y_pred", ")", "\n", "\n", "if", "text_file", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"AUC={:.2f} - ACC={:.2f} - F1={:.2f} - Loss={:.4f}\\n\"", ".", "format", "(", "100", "*", "auc", ",", "100", "*", "acc", ",", "100", "*", "f1", ",", "loss", ")", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "if", "print_conf", ":", "\n", "            ", "cm", "=", "confusion_matrix", "(", "y_true", ",", "y_pred", ",", "labels", "=", "classes", ")", "\n", "print_cm", "(", "cm", ",", "class_names", ",", "text_file", "=", "text_file", ")", "\n", "\n", "", "", "return", "auc", ",", "acc", ",", "f1", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.evaluate_multi_cls": [[89, 147], ["sklearn.metrics.f1_score", "sklearn.metrics.matthews_corrcoef", "sklearn.metrics.cohen_kappa_score", "sklearn.metrics.balanced_accuracy_score", "numpy.unique", "list", "list", "range", "get_one_hot_np().astype", "get_one_hot_np().astype", "len", "sklearn.metrics.roc_auc_score", "sklearn.metrics.roc_auc_score", "sklearn.metrics.confusion_matrix", "evaluation.print_cm", "y_proba.sum", "len", "len", "sklearn.metrics.f1_score", "sklearn.metrics.roc_auc_score", "str", "evaluation.get_one_hot_np", "evaluation.get_one_hot_np", "range", "range", "print", "print", "len", "print", "len", "len", "len", "len", "len", "print", "open", "open", "open", "len", "print", "print", "open", "open", "open"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.print_cm", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.get_one_hot_np", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.evaluation.get_one_hot_np"], ["", "def", "evaluate_multi_cls", "(", "y_true", ",", "y_pred", ",", "y_proba", ",", "print_conf", "=", "True", ",", "text_file", "=", "None", ",", "class_names", "=", "None", ",", "loss", "=", "0", ",", "lr", "=", "None", ")", ":", "\n", "# preds", "\n", "    ", "f1", "=", "f1_score", "(", "y_true", ",", "y_pred", ",", "average", "=", "'macro'", ")", "\n", "mcc", "=", "matthews_corrcoef", "(", "y_true", ",", "y_pred", ")", "\n", "k", "=", "kappa", "(", "y_true", ",", "y_pred", ",", "weights", "=", "'quadratic'", ")", "\n", "bacc", "=", "bal_acc", "(", "y_true", ",", "y_pred", ")", "\n", "# probs - handle case of not every label in y_true", "\n", "present_classes", ",", "_", "=", "np", ".", "unique", "(", "y_true", ",", "return_counts", "=", "True", ")", "\n", "present_classes", "=", "list", "(", "present_classes", ")", "\n", "classes", "=", "list", "(", "range", "(", "y_proba", ".", "shape", "[", "1", "]", ")", ")", "\n", "if", "present_classes", "!=", "classes", ":", "\n", "        ", "y_proba", "=", "y_proba", "[", ":", ",", "present_classes", "]", "\n", "y_proba", "/=", "y_proba", ".", "sum", "(", "axis", "=", "1", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "f1_all", "=", "len", "(", "present_classes", ")", "*", "[", "0", "]", "\n", "auc_all", "=", "len", "(", "present_classes", ")", "*", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "y_true_ohe", "=", "get_one_hot_np", "(", "y_true", ",", "len", "(", "present_classes", ")", ")", ".", "astype", "(", "int", ")", "\n", "y_pred_ohe", "=", "get_one_hot_np", "(", "y_pred", ",", "len", "(", "present_classes", ")", ")", ".", "astype", "(", "int", ")", "\n", "f1_all", "=", "[", "f1_score", "(", "y_true_ohe", "[", ":", ",", "i", "]", ",", "y_pred_ohe", "[", ":", ",", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "present_classes", ")", ")", "]", "\n", "auc_all", "=", "[", "roc_auc_score", "(", "y_true_ohe", "[", ":", ",", "i", "]", ",", "y_proba", "[", ":", ",", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "present_classes", ")", ")", "]", "\n", "", "if", "len", "(", "classes", ")", "==", "2", ":", "\n", "        ", "mean_auc", "=", "roc_auc_score", "(", "y_true", ",", "y_proba", "[", ":", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "mean_auc", "=", "roc_auc_score", "(", "y_true", ",", "y_proba", ",", "multi_class", "=", "'ovr'", ")", "# equivalent to np.mean(auc_all)", "\n", "\n", "# mean_auc = roc_auc_score(y_true, y_proba, average='weighted', multi_class='ovr')", "\n", "# ovo should be better, but average is not clear from docs", "\n", "# mean_auc = roc_auc_score(y_true, y_proba, average='macro', multi_class='ovo')", "\n", "\n", "", "if", "class_names", "is", "None", ":", "\n", "        ", "class_names", "=", "[", "str", "(", "n", ")", "for", "n", "in", "present_classes", "]", "\n", "\n", "", "if", "print_conf", ":", "\n", "        ", "if", "text_file", "is", "not", "None", ":", "\n", "            ", "if", "lr", "is", "None", ":", "\n", "                ", "print", "(", "\"K={:.2f} - BACC={:.2f} - MCC={:.2f}- F1={:.2f} - AUC={:.2f} - Loss={:.4f}\"", ".", "format", "(", "100", "*", "k", ",", "100", "*", "bacc", ",", "100", "*", "mcc", ",", "100", "*", "f1", ",", "100", "*", "mean_auc", ",", "loss", ")", ",", "\n", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"K={:.2f} - BACC={:.2f} - MCC={:.2f} - F1={:.2f} - AUC={:.2f} - Loss={:.4f} - LR={:.5f}\"", ".", "format", "(", "100", "*", "k", ",", "100", "*", "bacc", ",", "100", "*", "mcc", ",", "100", "*", "f1", ",", "100", "*", "mean_auc", ",", "loss", ",", "lr", ")", ",", "\n", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "\n", "", "if", "len", "(", "class_names", ")", "==", "3", ":", "\n", "                ", "print", "(", "'\\nAUC: No={:.2f} - cDME={:.2f} - DME={:.2f}'", ".", "format", "(", "\n", "100", "*", "auc_all", "[", "0", "]", ",", "100", "*", "auc_all", "[", "1", "]", ",", "100", "*", "auc_all", "[", "2", "]", ")", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "", "elif", "len", "(", "class_names", ")", "==", "5", ":", "\n", "                ", "print", "(", "'\\nAUC: DR0={:.2f} - DR1={:.2f} - DR2={:.2f} - DR3={:.2f} - DR4={:.2f}'", ".", "format", "(", "\n", "100", "*", "auc_all", "[", "0", "]", ",", "100", "*", "auc_all", "[", "1", "]", ",", "100", "*", "auc_all", "[", "2", "]", ",", "100", "*", "auc_all", "[", "3", "]", ",", "100", "*", "auc_all", "[", "4", "]", ")", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "", "elif", "len", "(", "class_names", ")", "==", "6", ":", "\n", "                ", "print", "(", "'\\nF1: DR0={:.2f} - DR1={:.2f} - DR2={:.2f} - DR3={:.2f} - DR4={:.2f} - U={:.2f}'", ".", "format", "(", "\n", "100", "*", "f1_all", "[", "0", "]", ",", "100", "*", "f1_all", "[", "1", "]", ",", "100", "*", "f1_all", "[", "2", "]", ",", "100", "*", "f1_all", "[", "3", "]", ",", "100", "*", "f1_all", "[", "4", "]", ",", "100", "*", "f1_all", "[", "5", "]", ")", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "print", "(", "'\\nAUC: DR0={:.2f} - DR1={:.2f} - DR2={:.2f} - DR3={:.2f} - DR4={:.2f} - U={:.2f}'", ".", "format", "(", "\n", "100", "*", "auc_all", "[", "0", "]", ",", "100", "*", "auc_all", "[", "1", "]", ",", "100", "*", "auc_all", "[", "2", "]", ",", "100", "*", "auc_all", "[", "3", "]", ",", "100", "*", "auc_all", "[", "4", "]", ",", "100", "*", "auc_all", "[", "5", "]", ")", ",", "end", "=", "\" \"", ",", "file", "=", "open", "(", "text_file", ",", "\"a\"", ")", ")", "\n", "", "else", ":", "\n", "                ", "return", "mean_auc", ",", "k", ",", "mcc", ",", "f1", ",", "bacc", ",", "auc_all", ",", "f1_all", "\n", "#sys.exit('invalid number of clases in print conf')", "\n", "", "", "cm", "=", "confusion_matrix", "(", "y_true", ",", "y_pred", ",", "labels", "=", "classes", ")", "\n", "print_cm", "(", "cm", ",", "class_names", ",", "text_file", "=", "text_file", ")", "\n", "", "return", "mean_auc", ",", "k", ",", "mcc", ",", "f1", ",", "bacc", ",", "auc_all", ",", "f1_all", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CostSensitiveRegularizedLoss.__init__": [[96, 127], ["torch.nn.Module.__init__", "numpy.abs", "M.max", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.nn.Softmax", "torch.nn.Softmax", "torch.nn.Softmax", "numpy.arange", "numpy.abs", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "torch.nn.Sigmoid", "losses.label_smoothing_criterion", "losses.label_smoothing_criterion", "FocalLoss", "sys.exit"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.label_smoothing_criterion", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.label_smoothing_criterion"], ["    ", "def", "__init__", "(", "self", ",", "n_classes", "=", "5", ",", "exp", "=", "2", ",", "normalization", "=", "'softmax'", ",", "reduction", "=", "'mean'", ",", "base_loss", "=", "'gls'", ",", "lambd", "=", "10", ")", ":", "\n", "        ", "super", "(", "CostSensitiveRegularizedLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "normalization", "==", "'softmax'", ":", "\n", "            ", "self", ".", "normalization", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "", "elif", "normalization", "==", "'sigmoid'", ":", "\n", "            ", "self", ".", "normalization", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "normalization", "=", "None", "\n", "", "self", ".", "reduction", "=", "reduction", "\n", "x", "=", "np", ".", "abs", "(", "np", ".", "arange", "(", "n_classes", ",", "dtype", "=", "np", ".", "float32", ")", ")", "\n", "M", "=", "np", ".", "abs", "(", "(", "x", "[", ":", ",", "np", ".", "newaxis", "]", "-", "x", "[", "np", ".", "newaxis", ",", ":", "]", ")", ")", "**", "exp", "\n", "M", "/=", "M", ".", "max", "(", ")", "\n", "if", "n_classes", "==", "6", ":", "# if we have unclassifiable class, we do not penalize it", "\n", "            ", "M", "[", ":", ",", "-", "1", "]", "=", "0", "\n", "M", "[", "-", "1", ",", ":", "]", "=", "0", "\n", "\n", "", "self", ".", "M", "=", "torch", ".", "from_numpy", "(", "M", ")", "\n", "self", ".", "lambd", "=", "lambd", "\n", "self", ".", "base_loss", "=", "base_loss", "\n", "\n", "if", "self", ".", "base_loss", "==", "'ce'", ":", "\n", "            ", "self", ".", "base_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "reduction", ")", "\n", "", "elif", "self", ".", "base_loss", "==", "'ls'", ":", "\n", "            ", "self", ".", "base_loss", "=", "label_smoothing_criterion", "(", "distribution", "=", "'uniform'", ",", "reduction", "=", "reduction", ")", "\n", "", "elif", "self", ".", "base_loss", "==", "'gls'", ":", "\n", "            ", "self", ".", "base_loss", "=", "label_smoothing_criterion", "(", "distribution", "=", "'gaussian'", ",", "reduction", "=", "reduction", ")", "\n", "", "elif", "self", ".", "base_loss", "==", "'focal_loss'", ":", "\n", "            ", "kwargs", "=", "{", "\"alpha\"", ":", "0.5", ",", "\"gamma\"", ":", "2.0", ",", "\"reduction\"", ":", "reduction", "}", "\n", "self", ".", "base_loss", "=", "FocalLoss", "(", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "sys", ".", "exit", "(", "'not a supported base_loss'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CostSensitiveRegularizedLoss.cost_sensitive_loss": [[128, 135], ["losses.CostSensitiveRegularizedLoss.M.to", "input.size", "target.size", "ValueError", "input.size", "target.size", "input.float"], "methods", ["None"], ["", "", "def", "cost_sensitive_loss", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "if", "input", ".", "size", "(", "0", ")", "!=", "target", ".", "size", "(", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected input batch_size ({}) to match target batch_size ({}).'", "\n", ".", "format", "(", "input", ".", "size", "(", "0", ")", ",", "target", ".", "size", "(", "0", ")", ")", ")", "\n", "", "device", "=", "input", ".", "device", "\n", "M", "=", "self", ".", "M", ".", "to", "(", "device", ")", "\n", "return", "(", "M", "[", "target", ",", ":", "]", "*", "input", ".", "float", "(", ")", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CostSensitiveRegularizedLoss.forward": [[136, 151], ["losses.CostSensitiveRegularizedLoss.base_loss", "losses.CostSensitiveRegularizedLoss.base_loss", "losses.CostSensitiveRegularizedLoss.normalization", "losses.CostSensitiveRegularizedLoss.cost_sensitive_loss", "ValueError", "losses.CostSensitiveRegularizedLoss.mean", "losses.CostSensitiveRegularizedLoss.sum"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CostSensitiveRegularizedLoss.cost_sensitive_loss"], ["", "def", "forward", "(", "self", ",", "logits", ",", "target", ")", ":", "\n", "        ", "base_l", "=", "self", ".", "base_loss", "(", "logits", ",", "target", ")", "\n", "if", "self", ".", "lambd", "==", "0", ":", "\n", "            ", "return", "self", ".", "base_loss", "(", "logits", ",", "target", ")", "\n", "", "else", ":", "\n", "            ", "preds", "=", "self", ".", "normalization", "(", "logits", ")", "\n", "loss", "=", "self", ".", "cost_sensitive_loss", "(", "preds", ",", "target", ")", "\n", "if", "self", ".", "reduction", "==", "'none'", ":", "\n", "                ", "return", "base_l", "+", "self", ".", "lambd", "*", "loss", "\n", "", "elif", "self", ".", "reduction", "==", "'mean'", ":", "\n", "                ", "return", "base_l", "+", "self", ".", "lambd", "*", "loss", ".", "mean", "(", ")", "\n", "", "elif", "self", ".", "reduction", "==", "'sum'", ":", "\n", "                ", "return", "base_l", "+", "self", ".", "lambd", "*", "loss", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'`reduction` must be one of \\'none\\', \\'mean\\', or \\'sum\\'.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.__init__": [[156, 162], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_classes", ",", "input_only", "=", "False", ",", "alpha", "=", "0.2", ",", "reduction", "=", "'none'", ")", ":", "\n", "        ", "super", "(", "MixUpCELoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "input_only", "=", "input_only", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "reduction", "=", "reduction", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup": [[163, 168], ["input.mul().add", "input.size", "indices.size", "RuntimeError", "input.mul"], "methods", ["None"], ["", "def", "partial_mixup", "(", "self", ",", "input", ",", "gamma", ",", "indices", ")", ":", "\n", "        ", "if", "input", ".", "size", "(", "0", ")", "!=", "indices", ".", "size", "(", "0", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"Size mismatch!\"", ")", "\n", "", "perm_input", "=", "input", "[", "indices", "]", "\n", "return", "input", ".", "mul", "(", "gamma", ")", ".", "add", "(", "perm_input", ",", "alpha", "=", "1", "-", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.mixup": [[169, 172], ["torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "input.size", "losses.MixUpCELoss.partial_mixup", "losses.MixUpCELoss.partial_mixup"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup"], ["", "def", "mixup", "(", "self", ",", "input", ",", "target", ",", "gamma", ")", ":", "\n", "        ", "indices", "=", "torch", ".", "randperm", "(", "input", ".", "size", "(", "0", ")", ",", "device", "=", "input", ".", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "return", "self", ".", "partial_mixup", "(", "input", ",", "gamma", ",", "indices", ")", ",", "self", ".", "partial_mixup", "(", "target", ",", "gamma", ",", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.forward": [[173, 187], ["torch.one_hot", "torch.one_hot", "torch.one_hot", "losses.MixUpCELoss.partial_mixup", "losses.MixUpCELoss.mixup", "numpy.random.beta", "loss.mean", "numpy.random.beta", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "losses.MixUpCELoss.size", "losses.MixUpCELoss.log_softmax"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.partial_mixup", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.MixUpCELoss.mixup"], ["", "def", "forward", "(", "self", ",", "logits", ",", "labels", ")", ":", "\n", "\n", "        ", "labels", "=", "F", ".", "one_hot", "(", "labels", ",", "self", ".", "n_classes", ")", "\n", "if", "self", ".", "input_only", ":", "\n", "            ", "logits", "=", "self", ".", "partial_mixup", "(", "logits", ",", "gamma", "=", "np", ".", "random", ".", "beta", "(", "self", ".", "alpha", "+", "1", ",", "self", ".", "alpha", ")", ",", "\n", "indices", "=", "torch", ".", "randperm", "(", "logits", ".", "size", "(", "0", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "logits", ",", "labels", "=", "self", ".", "mixup", "(", "logits", ",", "labels", ",", "np", ".", "random", ".", "beta", "(", "self", ".", "alpha", ",", "self", ".", "alpha", ")", ")", "\n", "\n", "", "loss", "=", "-", "(", "logits", ".", "log_softmax", "(", "dim", "=", "-", "1", ")", "*", "labels", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "if", "self", ".", "reduction", "==", "'none'", ":", "\n", "            ", "return", "loss", "\n", "", "elif", "self", ".", "reduction", "==", "'mean'", ":", "\n", "            ", "return", "loss", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CDOLoss.__init__": [[189, 211], ["super().__init__", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "losses.label_smoothing_criterion", "losses.CostSensitiveRegularizedLoss", "losses.MixUpCELoss", "ValueError"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.label_smoothing_criterion"], ["    ", "def", "__init__", "(", "self", ",", "base_loss", "=", "'ce'", ",", "cdo", "=", "'l1'", ",", "alpha", "=", "1", ",", "beta", "=", "1", ",", "n_classes", "=", "5", ",", "reduction", "=", "'mean'", ",", "normalization", "=", "'sigmoid'", ",", "do_not_add", "=", "True", ")", ":", "\n", "        ", "super", "(", "CDOLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "cdo", "=", "cdo", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "normalization", "=", "normalization", "\n", "self", ".", "base_loss", "=", "base_loss", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "do_not_add", "=", "do_not_add", "\n", "if", "base_loss", "==", "'ce'", ":", "\n", "            ", "self", ".", "base_loss", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'none'", ")", "\n", "", "elif", "base_loss", "==", "'fl'", ":", "\n", "            ", "focal_loss", "=", "torch", ".", "hub", ".", "load", "(", "'adeelh/pytorch-multi-class-focal-loss'", ",", "model", "=", "'FocalLoss'", ",", "alpha", "=", "None", ",", "gamma", "=", "2", ",", "reduction", "=", "reduction", ")", "\n", "self", ".", "base_loss", "=", "focal_loss", "\n", "", "elif", "base_loss", "==", "'gls'", ":", "\n", "            ", "self", ".", "base_loss", "=", "label_smoothing_criterion", "(", "distribution", "=", "'gaussian'", ",", "reduction", "=", "'none'", ")", "\n", "", "elif", "base_loss", "==", "'cs_reg'", ":", "\n", "            ", "self", ".", "base_loss", "=", "CostSensitiveRegularizedLoss", "(", "n_classes", "=", "self", ".", "n_classes", ",", "reduction", "=", "'none'", ")", "\n", "", "elif", "base_loss", "==", "'ce_mixup'", ":", "\n", "            ", "self", ".", "base_loss", "=", "MixUpCELoss", "(", "n_classes", "=", "self", ".", "n_classes", ",", "input_only", "=", "False", ",", "alpha", "=", "0.1", ",", "reduction", "=", "'none'", ")", "\n", "", "else", ":", "raise", "ValueError", "(", "'`base_loss` must be \\'ce\\',\\'fl\\', \\'gls\\', or \\'cs_reg\\'.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CDOLoss.dice_loss": [[212, 219], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "dice_loss", "(", "self", ",", "probs", ",", "cum_labels", ")", ":", "\n", "# compute intersection", "\n", "        ", "intersection", "=", "torch", ".", "sum", "(", "probs", "*", "cum_labels", ",", "dim", "=", "1", ")", "\n", "# compute union", "\n", "union", "=", "torch", ".", "sum", "(", "probs", "*", "probs", ",", "dim", "=", "1", ")", "+", "torch", ".", "sum", "(", "cum_labels", "*", "cum_labels", ",", "dim", "=", "1", ")", "\n", "dice_score", "=", "2.", "*", "intersection", "/", "union", "\n", "return", "1", "-", "dice_score", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CDOLoss.bce_loss": [[220, 222], ["torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy().mean", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy"], "methods", ["None"], ["", "def", "bce_loss", "(", "self", ",", "probs", ",", "cum_labels", ")", ":", "\n", "        ", "return", "torch", ".", "nn", ".", "functional", ".", "binary_cross_entropy", "(", "probs", ",", "cum_labels", ",", "reduction", "=", "'none'", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CDOLoss.forward": [[223, 264], ["torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "losses.CDOLoss.base_loss", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "labels.view", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "losses.CDOLoss.dice_loss", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "logits.sigmoid", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "logits.softmax", "losses.CDOLoss.bce_loss", "ValueError", "logits.sigmoid", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "losses.CDOLoss.mean", "losses.CDOLoss.mean", "losses.CDOLoss.mean", "losses.CDOLoss.mean", "labels.size", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "ValueError", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.smooth_l1_loss().mean", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss", "torch.nn.functional.smooth_l1_loss"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.dice_loss", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CDOLoss.bce_loss"], ["", "def", "forward", "(", "self", ",", "logits", ",", "labels", ")", ":", "\n", "        ", "ohe_labels", "=", "torch", ".", "zeros", "(", "labels", ".", "size", "(", "0", ")", ",", "self", ".", "n_classes", ")", ".", "to", "(", "labels", ".", "device", ")", ".", "scatter_", "(", "1", ",", "labels", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "# dist = get_gaussian_label_distribution(n_classes=self.n_classes)", "\n", "# ohe_labels = torch.from_numpy(dist[labels.cpu().numpy()]).to(logits.device).float()", "\n", "\n", "cum_labels", "=", "torch", ".", "cumsum", "(", "ohe_labels", ",", "dim", "=", "1", ")", "\n", "# the model predicts PDFs", "\n", "base_loss", "=", "self", ".", "base_loss", "(", "logits", ",", "labels", ")", "\n", "\n", "# convert logits to probabilities before lifting to CDF", "\n", "if", "self", ".", "normalization", "==", "'sigmoid'", ":", "\n", "            ", "probs", "=", "logits", ".", "sigmoid", "(", ")", "/", "(", "torch", ".", "sum", "(", "logits", ".", "sigmoid", "(", ")", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "", "elif", "self", ".", "normalization", "==", "'softmax'", ":", "\n", "            ", "probs", "=", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "\n", "# lift PDF to CDF", "\n", "", "cum_probs", "=", "torch", ".", "clamp", "(", "torch", ".", "cumsum", "(", "probs", ",", "dim", "=", "1", ")", ",", "0", ",", "1", ")", "\n", "\n", "if", "self", ".", "cdo", "==", "'dice'", ":", "\n", "            ", "cdo_loss", "=", "self", ".", "dice_loss", "(", "cum_probs", ",", "cum_labels", ")", "# + self.dice_loss(torch.clamp(1-cum_probs, 0, 1), 1-cum_labels)", "\n", "", "elif", "self", ".", "cdo", "==", "'bce'", ":", "\n", "            ", "cdo_loss", "=", "self", ".", "bce_loss", "(", "cum_probs", ",", "cum_labels", ")", "\n", "", "elif", "self", ".", "cdo", "==", "'l1'", ":", "\n", "            ", "cdo_loss", "=", "torch", ".", "nn", ".", "functional", ".", "l1_loss", "(", "cum_probs", ",", "cum_labels", ",", "reduction", "=", "'none'", ")", ".", "mean", "(", "dim", "=", "1", ")", "/", "self", ".", "n_classes", "\n", "", "elif", "self", ".", "cdo", "==", "'l2'", ":", "\n", "            ", "cdo_loss", "=", "torch", ".", "nn", ".", "functional", ".", "mse_loss", "(", "cum_probs", ",", "cum_labels", ",", "reduction", "=", "'none'", ")", ".", "mean", "(", "dim", "=", "1", ")", "/", "self", ".", "n_classes", "\n", "", "elif", "self", ".", "cdo", "==", "'huber'", ":", "\n", "            ", "cdo_loss", "=", "torch", ".", "nn", ".", "functional", ".", "smooth_l1_loss", "(", "cum_probs", ",", "cum_labels", ",", "reduction", "=", "'none'", ")", ".", "mean", "(", "dim", "=", "1", ")", "/", "self", ".", "n_classes", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'`cdo` must be \\'dice\\',\\'bce\\', \\'l1\\', or \\'l2\\'.'", ")", "\n", "\n", "", "if", "self", ".", "reduction", "==", "'none'", ":", "\n", "            ", "if", "self", ".", "do_not_add", ":", "\n", "                ", "return", "base_loss", ",", "cdo_loss", "\n", "", "return", "self", ".", "alpha", "*", "base_loss", "+", "self", ".", "beta", "*", "cdo_loss", "\n", "", "elif", "self", ".", "reduction", "==", "'mean'", ":", "\n", "            ", "if", "self", ".", "do_not_add", ":", "\n", "                ", "return", "base_loss", ".", "mean", "(", ")", ",", "cdo_loss", ".", "mean", "(", ")", "\n", "", "return", "self", ".", "alpha", "*", "base_loss", ".", "mean", "(", ")", "+", "self", ".", "beta", "*", "cdo_loss", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'`reduction` must be \\'none\\' or \\'mean\\'.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CeDiceLoss.__init__": [[266, 277], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__"], ["    ", "def", "__init__", "(", "self", ",", "base_loss", "=", "'ce'", ",", "alpha", "=", "1", ",", "n_classes", "=", "5", ",", "reduction", "=", "'none'", ",", "\n", "f1_acc", "=", "False", ",", "normalization", "=", "'sigmoid'", ",", "do_not_add", "=", "True", ")", ":", "\n", "        ", "super", "(", "CeDiceLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "f1_acc", "=", "f1_acc", "\n", "self", ".", "normalization", "=", "normalization", "\n", "self", ".", "base_loss", "=", "base_loss", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "do_not_add", "=", "do_not_add", "\n", "self", ".", "f1_acc", "=", "f1_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CeDiceLoss.acc_dice_loss": [[278, 292], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "labels.float"], "methods", ["None"], ["", "def", "acc_dice_loss", "(", "self", ",", "probs", ",", "labels", ")", ":", "\n", "# map everything to [-1,1]", "\n", "        ", "labels", "=", "2", "*", "labels", ".", "float", "(", ")", "-", "1", "\n", "probs", "=", "2", "*", "probs", "-", "1", "\n", "\n", "# compute intersection", "\n", "intersection", "=", "torch", ".", "sum", "(", "probs", "*", "labels", ",", "dim", "=", "1", ")", "\n", "# compute union", "\n", "union", "=", "torch", ".", "sum", "(", "probs", "*", "probs", ",", "dim", "=", "1", ")", "+", "torch", ".", "sum", "(", "labels", "*", "labels", ",", "dim", "=", "1", ")", "\n", "dice_score", "=", "2.", "*", "intersection", "/", "union", "\n", "# map back to [0,1]", "\n", "dice_score", "=", "0.5", "*", "(", "dice_score", "+", "1", ")", "\n", "\n", "return", "1", "-", "dice_score", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CeDiceLoss.dice_loss": [[293, 300], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "dice_loss", "(", "self", ",", "probs", ",", "ohe_labels", ")", ":", "\n", "# compute intersection", "\n", "        ", "intersection", "=", "torch", ".", "sum", "(", "probs", "*", "ohe_labels", ",", "dim", "=", "1", ")", "\n", "# compute union", "\n", "union", "=", "torch", ".", "sum", "(", "probs", "*", "probs", ",", "dim", "=", "1", ")", "+", "torch", ".", "sum", "(", "ohe_labels", "*", "ohe_labels", ",", "dim", "=", "1", ")", "\n", "dice_score", "=", "2.", "*", "intersection", "/", "union", "\n", "return", "1", "-", "dice_score", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CeDiceLoss.forward": [[301, 337], ["torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "labels.view", "losses.CeDiceLoss.acc_dice_loss", "losses.CeDiceLoss.dice_loss", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "torch.hub.load", "logits.sigmoid", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "logits.softmax", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "ValueError", "losses.label_smoothing_criterion", "logits.sigmoid", "torch.cross_entropy.mean", "losses.CostSensitiveRegularizedLoss", "ValueError", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cross_entropy.mean", "losses.CeDiceLoss.mean", "losses.CeDiceLoss.mean", "labels.size"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CeDiceLoss.acc_dice_loss", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.dice_loss", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.label_smoothing_criterion"], ["", "def", "forward", "(", "self", ",", "logits", ",", "labels", ")", ":", "\n", "# base loss", "\n", "        ", "if", "self", ".", "base_loss", "==", "'ce'", ":", "\n", "            ", "base_loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "", "elif", "self", ".", "base_loss", "==", "'fl'", ":", "\n", "            ", "focal_loss", "=", "torch", ".", "hub", ".", "load", "(", "'adeelh/pytorch-multi-class-focal-loss'", ",", "model", "=", "'FocalLoss'", ",", "alpha", "=", "None", ",", "gamma", "=", "2", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "self", ".", "base_loss", "=", "focal_loss", "\n", "", "elif", "self", ".", "base_loss", "==", "'gls'", ":", "\n", "            ", "self", ".", "base_loss", "=", "label_smoothing_criterion", "(", "distribution", "=", "'gaussian'", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "", "elif", "self", ".", "base_loss", "==", "'cs_reg'", ":", "\n", "            ", "self", ".", "base_loss", "=", "CostSensitiveRegularizedLoss", "(", "n_classes", "=", "self", ".", "n_classes", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'`base_loss` must be \\'ce\\',\\'fl\\', \\'gls\\', or \\'cs_reg\\'.'", ")", "\n", "\n", "# F1 loss:", "\n", "", "if", "self", ".", "normalization", "==", "'sigmoid'", ":", "\n", "            ", "probs", "=", "logits", ".", "sigmoid", "(", ")", "/", "(", "torch", ".", "sum", "(", "logits", ".", "sigmoid", "(", ")", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "", "elif", "self", ".", "normalization", "==", "'softmax'", ":", "\n", "            ", "probs", "=", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "\n", "", "ohe_labels", "=", "torch", ".", "zeros", "(", "labels", ".", "size", "(", "0", ")", ",", "self", ".", "n_classes", ")", ".", "to", "(", "labels", ".", "device", ")", ".", "scatter_", "(", "1", ",", "labels", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "if", "self", ".", "f1_acc", ":", "\n", "            ", "d_loss", "=", "self", ".", "acc_dice_loss", "(", "probs", ",", "ohe_labels", ")", "\n", "", "else", ":", "\n", "            ", "d_loss", "=", "self", ".", "dice_loss", "(", "probs", ",", "ohe_labels", ")", "\n", "\n", "", "if", "self", ".", "reduction", "==", "'none'", ":", "\n", "            ", "if", "self", ".", "do_not_add", ":", "\n", "                ", "return", "base_loss", ",", "d_loss", "\n", "", "return", "self", ".", "alpha", "*", "base_loss", "+", "d_loss", "\n", "", "elif", "self", ".", "reduction", "==", "'mean'", ":", "\n", "            ", "if", "self", ".", "do_not_add", ":", "\n", "                ", "return", "base_loss", ".", "mean", "(", ")", ",", "d_loss", ".", "mean", "(", ")", "\n", "", "return", "base_loss", ".", "mean", "(", ")", "+", "self", ".", "alpha", "*", "d_loss", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'`reduction` must be \\'batch\\' or \\'mean\\'.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.__init__": [[360, 370], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_classes", "=", "5", ",", "amplifier", "=", "50", ",", "noise", "=", "0.25", ",", "cdo", "=", "'dice'", ",", "normalization", "=", "'sigmoid'", ",", "alpha", "=", "1", ",", "beta", "=", "1", ",", "reduction", "=", "'mean'", ")", ":", "\n", "        ", "super", "(", "GranularGLS", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "amplifier", "=", "amplifier", "\n", "self", ".", "noise", "=", "noise", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "cdo", "=", "cdo", "\n", "self", ".", "normalization", "=", "normalization", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.get_super_noisy_gauss_label": [[371, 381], ["numpy.random.uniform", "numpy.random.uniform", "scipy.norm.pdf", "numpy.sum", "numpy.arange"], "methods", ["None"], ["", "def", "get_super_noisy_gauss_label", "(", "self", ",", "label", ")", ":", "\n", "        ", "n", "=", "self", ".", "n_classes", "*", "self", ".", "amplifier", "\n", "half_int", "=", "self", ".", "amplifier", "/", "2", "\n", "noisy_int", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "half_int", "/", "4", ",", "high", "=", "3", "*", "half_int", "/", "4", ")", "\n", "label_noise", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "-", "self", ".", "noise", ",", "high", "=", "self", ".", "noise", ")", "\n", "label", "+=", "label_noise", "\n", "label_new", "=", "half_int", "+", "label", "*", "self", ".", "amplifier", "\n", "gauss_label", "=", "stats2", ".", "norm", ".", "pdf", "(", "np", ".", "arange", "(", "n", ")", ",", "label_new", ",", "noisy_int", ")", "\n", "gauss_label", "/=", "np", ".", "sum", "(", "gauss_label", ")", "\n", "return", "gauss_label", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.get_all_super_noisy_gauss_labels": [[382, 388], ["range", "numpy.stack", "gauss_labels.append", "losses.GranularGLS.get_super_noisy_gauss_label"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.get_super_noisy_gauss_label"], ["", "def", "get_all_super_noisy_gauss_labels", "(", "self", ")", ":", "\n", "        ", "gauss_labels", "=", "[", "]", "\n", "for", "label", "in", "range", "(", "self", ".", "n_classes", ")", ":", "\n", "            ", "gauss_labels", ".", "append", "(", "self", ".", "get_super_noisy_gauss_label", "(", "label", ")", ")", "\n", "", "distribs", "=", "np", ".", "stack", "(", "gauss_labels", ",", "axis", "=", "0", ")", "\n", "return", "distribs", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.dice_loss": [[389, 396], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "dice_loss", "(", "self", ",", "probs", ",", "cum_labels", ")", ":", "\n", "# compute intersection", "\n", "        ", "intersection", "=", "torch", ".", "sum", "(", "probs", "*", "cum_labels", ",", "dim", "=", "1", ")", "\n", "# compute union", "\n", "union", "=", "torch", ".", "sum", "(", "probs", "*", "probs", ",", "dim", "=", "1", ")", "+", "torch", ".", "sum", "(", "cum_labels", "*", "cum_labels", ",", "dim", "=", "1", ")", "\n", "dice_score", "=", "2.", "*", "intersection", "/", "union", "\n", "return", "1", "-", "dice_score", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.forward": [[397, 426], ["losses.GranularGLS.get_all_super_noisy_gauss_labels", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.from_numpy().float().to", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "losses.GranularGLS.dice_loss", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "torch.sum().mean", "logits.sigmoid", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "logits.softmax", "losses.GranularGLS.bce_loss", "torch.sum().mean.mean", "torch.sum().mean.mean", "torch.sum().mean.mean", "losses.GranularGLS.mean", "logits.sigmoid", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "torch.nn.functional.l1_loss().mean", "ValueError", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.mse_loss().mean", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "torch.nn.functional.l1_loss", "labels.cpu().numpy", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "torch.nn.functional.mse_loss", "labels.cpu"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.get_all_super_noisy_gauss_labels", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.GranularGLS.dice_loss", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.CDOLoss.bce_loss"], ["", "def", "forward", "(", "self", ",", "logits", ",", "labels", ")", ":", "\n", "        ", "gauss_labels", "=", "self", ".", "get_all_super_noisy_gauss_labels", "(", ")", "\n", "ohe_labels", "=", "torch", ".", "from_numpy", "(", "gauss_labels", "[", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", ")", ".", "float", "(", ")", ".", "to", "(", "logits", ".", "device", ")", "\n", "logp", "=", "F", ".", "log_softmax", "(", "logits", ",", "dim", "=", "1", ")", "\n", "if", "self", ".", "reduction", "==", "'none'", ":", "\n", "            ", "loss", "=", "torch", ".", "sum", "(", "-", "logp", "*", "ohe_labels", ",", "dim", "=", "1", ")", "\n", "", "elif", "self", ".", "reduction", "==", "'mean'", ":", "\n", "            ", "loss", "=", "torch", ".", "sum", "(", "-", "logp", "*", "ohe_labels", ",", "dim", "=", "1", ")", ".", "mean", "(", ")", "\n", "\n", "", "cum_labels", "=", "torch", ".", "cumsum", "(", "ohe_labels", ",", "dim", "=", "1", ")", "\n", "# convert logits to probabilities before lifting to CDF", "\n", "if", "self", ".", "normalization", "==", "'sigmoid'", ":", "\n", "            ", "probs", "=", "logits", ".", "sigmoid", "(", ")", "/", "(", "torch", ".", "sum", "(", "logits", ".", "sigmoid", "(", ")", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "", "elif", "self", ".", "normalization", "==", "'softmax'", ":", "\n", "            ", "probs", "=", "logits", ".", "softmax", "(", "dim", "=", "1", ")", "\n", "# lift PDF to CDF", "\n", "", "cum_probs", "=", "torch", ".", "clamp", "(", "torch", ".", "cumsum", "(", "probs", ",", "dim", "=", "1", ")", ",", "0", ",", "1", ")", "\n", "if", "self", ".", "cdo", "==", "'dice'", ":", "\n", "            ", "cdo_loss", "=", "self", ".", "dice_loss", "(", "cum_probs", ",", "cum_labels", ")", "\n", "", "elif", "self", ".", "cdo", "==", "'bce'", ":", "\n", "            ", "cdo_loss", "=", "self", ".", "bce_loss", "(", "cum_probs", ",", "cum_labels", ")", "\n", "", "elif", "self", ".", "cdo", "==", "'l1'", ":", "\n", "            ", "cdo_loss", "=", "torch", ".", "nn", ".", "functional", ".", "l1_loss", "(", "cum_probs", ",", "cum_labels", ",", "reduction", "=", "'none'", ")", ".", "mean", "(", "dim", "=", "1", ")", "/", "self", ".", "n_classes", "\n", "", "elif", "self", ".", "cdo", "==", "'l2'", ":", "\n", "            ", "cdo_loss", "=", "torch", ".", "nn", ".", "functional", ".", "mse_loss", "(", "cum_probs", ",", "cum_labels", ",", "reduction", "=", "'none'", ")", ".", "mean", "(", "dim", "=", "1", ")", "/", "self", ".", "n_classes", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'`cdo` must be \\'dice\\',\\'bce\\', \\'l1\\', or \\'l2\\'.'", ")", "\n", "\n", "", "return", "self", ".", "alpha", "*", "loss", ".", "mean", "(", ")", "+", "self", ".", "beta", "*", "cdo_loss", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_gauss_label": [[12, 25], ["numpy.random.uniform", "scipy.norm.pdf", "numpy.sum", "numpy.abs", "numpy.arange", "numpy.abs"], "function", ["None"], ["def", "get_gauss_label", "(", "label", ",", "n_classes", ",", "amplifier", ",", "noise", "=", "0", ")", ":", "\n", "    ", "n", "=", "n_classes", "*", "amplifier", "\n", "half_int", "=", "amplifier", "/", "2", "\n", "label_noise", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "-", "noise", ",", "high", "=", "noise", ")", "\n", "if", "label", "==", "0", ":", "\n", "        ", "label_noise", "=", "np", ".", "abs", "(", "label_noise", ")", "\n", "", "if", "label", "==", "4", ":", "\n", "        ", "label_noise", "=", "-", "np", ".", "abs", "(", "label_noise", ")", "\n", "", "label", "+=", "label_noise", "\n", "label_new", "=", "half_int", "+", "label", "*", "amplifier", "\n", "gauss_label", "=", "stats2", ".", "norm", ".", "pdf", "(", "np", ".", "arange", "(", "n", ")", ",", "label_new", ",", "half_int", "/", "2", ")", "\n", "gauss_label", "/=", "np", ".", "sum", "(", "gauss_label", ")", "\n", "return", "gauss_label", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_gaussian_label_distribution": [[26, 32], ["range", "numpy.stack", "cls.append", "scipy.norm.pdf", "range"], "function", ["None"], ["", "def", "get_gaussian_label_distribution", "(", "n_classes", ",", "std", "=", "0.5", ")", ":", "\n", "    ", "cls", "=", "[", "]", "\n", "for", "n", "in", "range", "(", "n_classes", ")", ":", "\n", "        ", "cls", ".", "append", "(", "stats2", ".", "norm", ".", "pdf", "(", "range", "(", "n_classes", ")", ",", "n", ",", "std", ")", ")", "\n", "", "dists", "=", "np", ".", "stack", "(", "cls", ",", "axis", "=", "0", ")", "\n", "return", "dists", "\n", "# if n_classes == 3:", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.cross_entropy_loss_one_hot": [[58, 70], ["torch.log_softmax", "torch.sum", "torch.sum", "torch.sum", "torch.sum.mean", "torch.sum.sum", "ValueError"], "function", ["None"], ["", "def", "cross_entropy_loss_one_hot", "(", "logits", ",", "target", ",", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "logp", "=", "F", ".", "log_softmax", "(", "logits", ",", "dim", "=", "1", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "-", "logp", "*", "target", ",", "dim", "=", "1", ")", "\n", "if", "reduction", "==", "'none'", ":", "\n", "        ", "return", "loss", "\n", "", "elif", "reduction", "==", "'mean'", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "elif", "reduction", "==", "'sum'", ":", "\n", "        ", "return", "loss", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'`reduction` must be one of \\'none\\', \\'mean\\', or \\'sum\\'.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.one_hot_encoding": [[71, 73], ["torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "label.view", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros", "torch.zeros", "torch.zeros", "label.size"], "function", ["None"], ["", "", "def", "one_hot_encoding", "(", "label", ",", "n_classes", ")", ":", "\n", "    ", "return", "torch", ".", "zeros", "(", "label", ".", "size", "(", "0", ")", ",", "n_classes", ")", ".", "to", "(", "label", ".", "device", ")", ".", "scatter_", "(", "1", ",", "label", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.label_smoothing_criterion": [[74, 94], ["logits.size", "one_hot_encoding().float().to", "losses.cross_entropy_loss_one_hot", "torch.from_numpy().to.float", "one_hot_encoding().float", "torch.ones_like().to", "torch.ones_like().to", "torch.ones_like().to", "losses.get_gaussian_label_distribution", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "losses.one_hot_encoding", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "labels.cpu().numpy", "labels.cpu"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.cross_entropy_loss_one_hot", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_gaussian_label_distribution", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.one_hot_encoding"], ["", "def", "label_smoothing_criterion", "(", "alpha", "=", "0.1", ",", "distribution", "=", "'uniform'", ",", "std", "=", "0.5", ",", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "def", "_label_smoothing_criterion", "(", "logits", ",", "labels", ")", ":", "\n", "        ", "n_classes", "=", "logits", ".", "size", "(", "1", ")", "\n", "device", "=", "logits", ".", "device", "\n", "# manipulate labels", "\n", "one_hot", "=", "one_hot_encoding", "(", "labels", ",", "n_classes", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "if", "distribution", "==", "'uniform'", ":", "\n", "            ", "uniform", "=", "torch", ".", "ones_like", "(", "one_hot", ")", ".", "to", "(", "device", ")", "/", "n_classes", "\n", "soft_labels", "=", "(", "1", "-", "alpha", ")", "*", "one_hot", "+", "alpha", "*", "uniform", "\n", "", "elif", "distribution", "==", "'gaussian'", ":", "\n", "            ", "dist", "=", "get_gaussian_label_distribution", "(", "n_classes", ",", "std", "=", "std", ")", "\n", "soft_labels", "=", "torch", ".", "from_numpy", "(", "dist", "[", "labels", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "loss", "=", "cross_entropy_loss_one_hot", "(", "logits", ",", "soft_labels", ".", "float", "(", ")", ",", "reduction", ")", "\n", "\n", "return", "loss", "\n", "\n", "", "return", "_label_smoothing_criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_focal_loss": [[338, 341], ["torch.hub.load", "torch.hub.load", "torch.hub.load"], "function", ["None"], ["", "", "", "def", "get_focal_loss", "(", "alpha", "=", "None", ",", "gamma", "=", "2.0", ",", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "focal_loss", "=", "torch", ".", "hub", ".", "load", "(", "'adeelh/pytorch-multi-class-focal-loss'", ",", "model", "=", "'FocalLoss'", ",", "alpha", "=", "alpha", ",", "gamma", "=", "gamma", ",", "reduction", "=", "reduction", ")", "\n", "return", "focal_loss", ",", "focal_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_ce_dice_criterion": [[342, 348], ["losses.CeDiceLoss", "losses.CeDiceLoss"], "function", ["None"], ["", "def", "get_ce_dice_criterion", "(", "n_classes", "=", "5", ",", "reduction", "=", "'mean'", ",", "base_loss", "=", "'ce'", ",", "f1_acc", "=", "False", ",", "normalization", "=", "'sigmoid'", ",", "alpha", "=", "1", ")", ":", "\n", "    ", "train_criterion", "=", "CeDiceLoss", "(", "base_loss", ",", "alpha", "=", "alpha", ",", "n_classes", "=", "n_classes", ",", "reduction", "=", "reduction", ",", "f1_acc", "=", "f1_acc", ",", "\n", "normalization", "=", "normalization", ",", "do_not_add", "=", "True", ")", "\n", "val_criterion", "=", "CeDiceLoss", "(", "base_loss", ",", "alpha", "=", "alpha", ",", "n_classes", "=", "n_classes", ",", "reduction", "=", "reduction", ",", "f1_acc", "=", "f1_acc", ",", "\n", "normalization", "=", "normalization", ",", "do_not_add", "=", "True", ")", "\n", "return", "train_criterion", ",", "val_criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_cdo_criterion": [[349, 353], ["losses.CDOLoss", "losses.CDOLoss"], "function", ["None"], ["", "def", "get_cdo_criterion", "(", "n_classes", "=", "5", ",", "base_loss", "=", "'ce'", ",", "cdo", "=", "'l2'", ",", "alpha", "=", "1", ",", "beta", "=", "1", ",", "normalization", "=", "'sigmoid'", ",", "reduction", "=", "'mean'", ",", "do_not_add", "=", "True", ")", ":", "\n", "    ", "train_criterion", "=", "CDOLoss", "(", "base_loss", ",", "cdo", "=", "cdo", ",", "alpha", "=", "alpha", ",", "beta", "=", "beta", ",", "n_classes", "=", "n_classes", ",", "reduction", "=", "reduction", ",", "normalization", "=", "normalization", ",", "do_not_add", "=", "do_not_add", ")", "\n", "val_criterion", "=", "CDOLoss", "(", "base_loss", ",", "cdo", "=", "cdo", ",", "alpha", "=", "alpha", ",", "beta", "=", "beta", ",", "n_classes", "=", "n_classes", ",", "reduction", "=", "reduction", ",", "normalization", "=", "normalization", ",", "do_not_add", "=", "do_not_add", ")", "\n", "return", "train_criterion", ",", "val_criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_cost_sensitive_regularized_criterion": [[354, 358], ["losses.CostSensitiveRegularizedLoss", "losses.CostSensitiveRegularizedLoss"], "function", ["None"], ["", "def", "get_cost_sensitive_regularized_criterion", "(", "base_loss", "=", "'ce'", ",", "n_classes", "=", "6", ",", "lambd", "=", "10", ",", "exp", "=", "2", ",", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "train_criterion", "=", "CostSensitiveRegularizedLoss", "(", "n_classes", ",", "exp", "=", "exp", ",", "normalization", "=", "'softmax'", ",", "base_loss", "=", "base_loss", ",", "lambd", "=", "lambd", ",", "reduction", "=", "reduction", ")", "\n", "val_criterion", "=", "CostSensitiveRegularizedLoss", "(", "n_classes", ",", "exp", "=", "exp", ",", "normalization", "=", "'softmax'", ",", "base_loss", "=", "base_loss", ",", "lambd", "=", "lambd", ",", "reduction", "=", "reduction", ")", "\n", "return", "train_criterion", ",", "val_criterion", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.utils.losses.get_granular_label_smoothing_criterion": [[427, 432], ["losses.GranularGLS", "losses.GranularGLS"], "function", ["None"], ["", "", "def", "get_granular_label_smoothing_criterion", "(", "n_classes", ",", "amplifier", "=", "50", ",", "noise", "=", "0.25", ",", "alpha", "=", "1", ",", "beta", "=", "0", ",", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "train_criterion", "=", "GranularGLS", "(", "n_classes", ",", "amplifier", ",", "noise", ",", "alpha", "=", "alpha", ",", "beta", "=", "beta", ",", "reduction", "=", "reduction", ")", "\n", "val_criterion", "=", "GranularGLS", "(", "n_classes", ",", "amplifier", ",", "noise", "=", "0", ",", "alpha", "=", "alpha", ",", "beta", "=", "beta", ",", "reduction", "=", "reduction", ")", "\n", "\n", "return", "train_criterion", ",", "val_criterion", "", "", ""]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.StdConv2d.forward": [[27, 33], ["torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.var_mean", "torch.conv2d", "torch.conv2d", "torch.conv2d", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["None"], ["  ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "    ", "w", "=", "self", ".", "weight", "\n", "v", ",", "m", "=", "torch", ".", "var_mean", "(", "w", ",", "dim", "=", "[", "1", ",", "2", ",", "3", "]", ",", "keepdim", "=", "True", ",", "unbiased", "=", "False", ")", "\n", "w", "=", "(", "w", "-", "m", ")", "/", "torch", ".", "sqrt", "(", "v", "+", "1e-10", ")", "\n", "return", "F", ".", "conv2d", "(", "x", ",", "w", ",", "self", ".", "bias", ",", "self", ".", "stride", ",", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "self", ".", "groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.PreActBottleneck.__init__": [[61, 77], ["torch.Module.__init__", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "bit_models.conv1x1", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "bit_models.conv3x3", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "bit_models.conv1x1", "torch.ReLU", "torch.ReLU", "torch.ReLU", "bit_models.conv1x1"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.conv1x1", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.conv3x3", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.conv1x1", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.conv1x1"], ["def", "__init__", "(", "self", ",", "cin", ",", "cout", "=", "None", ",", "cmid", "=", "None", ",", "stride", "=", "1", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "cout", "=", "cout", "or", "cin", "\n", "cmid", "=", "cmid", "or", "cout", "//", "4", "\n", "\n", "self", ".", "gn1", "=", "nn", ".", "GroupNorm", "(", "32", ",", "cin", ")", "\n", "self", ".", "conv1", "=", "conv1x1", "(", "cin", ",", "cmid", ")", "\n", "self", ".", "gn2", "=", "nn", ".", "GroupNorm", "(", "32", ",", "cmid", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "cmid", ",", "cmid", ",", "stride", ")", "# Original code has it on conv1!!", "\n", "self", ".", "gn3", "=", "nn", ".", "GroupNorm", "(", "32", ",", "cmid", ")", "\n", "self", ".", "conv3", "=", "conv1x1", "(", "cmid", ",", "cout", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "if", "(", "stride", "!=", "1", "or", "cin", "!=", "cout", ")", ":", "\n", "# Projection also with pre-activation according to paper.", "\n", "      ", "self", ".", "downsample", "=", "conv1x1", "(", "cin", ",", "cout", ",", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.PreActBottleneck.forward": [[78, 92], ["bit_models.PreActBottleneck.relu", "hasattr", "bit_models.PreActBottleneck.conv1", "bit_models.PreActBottleneck.conv2", "bit_models.PreActBottleneck.conv3", "bit_models.PreActBottleneck.gn1", "bit_models.PreActBottleneck.downsample", "bit_models.PreActBottleneck.relu", "bit_models.PreActBottleneck.relu", "bit_models.PreActBottleneck.gn2", "bit_models.PreActBottleneck.gn3"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "    ", "out", "=", "self", ".", "relu", "(", "self", ".", "gn1", "(", "x", ")", ")", "\n", "\n", "# Residual branch", "\n", "residual", "=", "x", "\n", "if", "hasattr", "(", "self", ",", "'downsample'", ")", ":", "\n", "      ", "residual", "=", "self", ".", "downsample", "(", "out", ")", "\n", "\n", "# Unit's branch", "\n", "", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "self", ".", "relu", "(", "self", ".", "gn2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "conv3", "(", "self", ".", "relu", "(", "self", ".", "gn3", "(", "out", ")", ")", ")", "\n", "\n", "return", "out", "+", "residual", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.PreActBottleneck.load_from": [[93, 108], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "bit_models.PreActBottleneck.conv1.weight.copy_", "bit_models.PreActBottleneck.conv2.weight.copy_", "bit_models.PreActBottleneck.conv3.weight.copy_", "bit_models.PreActBottleneck.gn1.weight.copy_", "bit_models.PreActBottleneck.gn2.weight.copy_", "bit_models.PreActBottleneck.gn3.weight.copy_", "bit_models.PreActBottleneck.gn1.bias.copy_", "bit_models.PreActBottleneck.gn2.bias.copy_", "bit_models.PreActBottleneck.gn3.bias.copy_", "hasattr", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "bit_models.PreActBottleneck.downsample.weight.copy_", "bit_models.tf2th"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th"], ["", "def", "load_from", "(", "self", ",", "weights", ",", "prefix", "=", "''", ")", ":", "\n", "    ", "convname", "=", "'standardized_conv2d'", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "      ", "self", ".", "conv1", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}a/{convname}/kernel'", "]", ")", ")", "\n", "self", ".", "conv2", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}b/{convname}/kernel'", "]", ")", ")", "\n", "self", ".", "conv3", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}c/{convname}/kernel'", "]", ")", ")", "\n", "self", ".", "gn1", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}a/group_norm/gamma'", "]", ")", ")", "\n", "self", ".", "gn2", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}b/group_norm/gamma'", "]", ")", ")", "\n", "self", ".", "gn3", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}c/group_norm/gamma'", "]", ")", ")", "\n", "self", ".", "gn1", ".", "bias", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}a/group_norm/beta'", "]", ")", ")", "\n", "self", ".", "gn2", ".", "bias", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}b/group_norm/beta'", "]", ")", ")", "\n", "self", ".", "gn3", ".", "bias", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}c/group_norm/beta'", "]", ")", ")", "\n", "if", "hasattr", "(", "self", ",", "'downsample'", ")", ":", "\n", "        ", "w", "=", "weights", "[", "f'{prefix}a/proj/{convname}/kernel'", "]", "\n", "self", ".", "downsample", ".", "weight", ".", "copy_", "(", "tf2th", "(", "w", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__": [[113, 153], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "bit_models.StdConv2d", "torch.ConstantPad2d", "torch.ConstantPad2d", "torch.ConstantPad2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.GroupNorm", "torch.GroupNorm", "torch.GroupNorm", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "collections.OrderedDict", "bit_models.PreActBottleneck", "bit_models.PreActBottleneck", "range", "bit_models.PreActBottleneck", "bit_models.PreActBottleneck", "range", "bit_models.PreActBottleneck", "bit_models.PreActBottleneck", "range", "bit_models.PreActBottleneck", "bit_models.PreActBottleneck", "range"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.__init__"], ["def", "__init__", "(", "self", ",", "block_units", ",", "width_factor", ",", "head_size", "=", "21843", ",", "zero_head", "=", "False", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "wf", "=", "width_factor", "# shortcut 'cause we'll use it a lot.", "\n", "\n", "# The following will be unreadable if we split lines.", "\n", "# pylint: disable=line-too-long", "\n", "self", ".", "root", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'conv'", ",", "StdConv2d", "(", "3", ",", "64", "*", "wf", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "bias", "=", "False", ")", ")", ",", "\n", "(", "'pad'", ",", "nn", ".", "ConstantPad2d", "(", "1", ",", "0", ")", ")", ",", "\n", "(", "'pool'", ",", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", ")", ",", "\n", "# The following is subtly not the same!", "\n", "# ('pool', nn.MaxPool2d(kernel_size=3, stride=2, padding=1)),", "\n", "]", ")", ")", "\n", "\n", "self", ".", "body", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'block1'", ",", "nn", ".", "Sequential", "(", "OrderedDict", "(", "\n", "[", "(", "'unit01'", ",", "PreActBottleneck", "(", "cin", "=", "64", "*", "wf", ",", "cout", "=", "256", "*", "wf", ",", "cmid", "=", "64", "*", "wf", ")", ")", "]", "+", "\n", "[", "(", "f'unit{i:02d}'", ",", "PreActBottleneck", "(", "cin", "=", "256", "*", "wf", ",", "cout", "=", "256", "*", "wf", ",", "cmid", "=", "64", "*", "wf", ")", ")", "for", "i", "in", "range", "(", "2", ",", "block_units", "[", "0", "]", "+", "1", ")", "]", ",", "\n", ")", ")", ")", ",", "\n", "(", "'block2'", ",", "nn", ".", "Sequential", "(", "OrderedDict", "(", "\n", "[", "(", "'unit01'", ",", "PreActBottleneck", "(", "cin", "=", "256", "*", "wf", ",", "cout", "=", "512", "*", "wf", ",", "cmid", "=", "128", "*", "wf", ",", "stride", "=", "2", ")", ")", "]", "+", "\n", "[", "(", "f'unit{i:02d}'", ",", "PreActBottleneck", "(", "cin", "=", "512", "*", "wf", ",", "cout", "=", "512", "*", "wf", ",", "cmid", "=", "128", "*", "wf", ")", ")", "for", "i", "in", "range", "(", "2", ",", "block_units", "[", "1", "]", "+", "1", ")", "]", ",", "\n", ")", ")", ")", ",", "\n", "(", "'block3'", ",", "nn", ".", "Sequential", "(", "OrderedDict", "(", "\n", "[", "(", "'unit01'", ",", "PreActBottleneck", "(", "cin", "=", "512", "*", "wf", ",", "cout", "=", "1024", "*", "wf", ",", "cmid", "=", "256", "*", "wf", ",", "stride", "=", "2", ")", ")", "]", "+", "\n", "[", "(", "f'unit{i:02d}'", ",", "PreActBottleneck", "(", "cin", "=", "1024", "*", "wf", ",", "cout", "=", "1024", "*", "wf", ",", "cmid", "=", "256", "*", "wf", ")", ")", "for", "i", "in", "range", "(", "2", ",", "block_units", "[", "2", "]", "+", "1", ")", "]", ",", "\n", ")", ")", ")", ",", "\n", "(", "'block4'", ",", "nn", ".", "Sequential", "(", "OrderedDict", "(", "\n", "[", "(", "'unit01'", ",", "PreActBottleneck", "(", "cin", "=", "1024", "*", "wf", ",", "cout", "=", "2048", "*", "wf", ",", "cmid", "=", "512", "*", "wf", ",", "stride", "=", "2", ")", ")", "]", "+", "\n", "[", "(", "f'unit{i:02d}'", ",", "PreActBottleneck", "(", "cin", "=", "2048", "*", "wf", ",", "cout", "=", "2048", "*", "wf", ",", "cmid", "=", "512", "*", "wf", ")", ")", "for", "i", "in", "range", "(", "2", ",", "block_units", "[", "3", "]", "+", "1", ")", "]", ",", "\n", ")", ")", ")", ",", "\n", "]", ")", ")", "\n", "# pylint: enable=line-too-long", "\n", "\n", "self", ".", "zero_head", "=", "zero_head", "\n", "self", ".", "head", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "[", "\n", "(", "'gn'", ",", "nn", ".", "GroupNorm", "(", "32", ",", "2048", "*", "wf", ")", ")", ",", "\n", "(", "'relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ",", "\n", "(", "'avg'", ",", "nn", ".", "AdaptiveAvgPool2d", "(", "output_size", "=", "1", ")", ")", ",", "\n", "(", "'conv'", ",", "nn", ".", "Conv2d", "(", "2048", "*", "wf", ",", "head_size", ",", "kernel_size", "=", "1", ",", "bias", "=", "True", ")", ")", ",", "\n", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.forward": [[155, 159], ["bit_models.ResNetV2.head", "bit_models.ResNetV2.body", "bit_models.ResNetV2.root"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "    ", "x", "=", "self", ".", "head", "(", "self", ".", "body", "(", "self", ".", "root", "(", "x", ")", ")", ")", "\n", "assert", "x", ".", "shape", "[", "-", "2", ":", "]", "==", "(", "1", ",", "1", ")", "# We should have no spatial shape left.", "\n", "return", "x", "[", "...", ",", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.load_from": [[160, 176], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "bit_models.ResNetV2.root.conv.weight.copy_", "bit_models.ResNetV2.head.gn.weight.copy_", "bit_models.ResNetV2.head.gn.bias.copy_", "bit_models.ResNetV2.body.named_children", "bit_models.tf2th", "bit_models.tf2th", "bit_models.tf2th", "torch.init.zeros_", "torch.init.zeros_", "torch.init.zeros_", "torch.init.zeros_", "torch.init.zeros_", "torch.init.zeros_", "bit_models.ResNetV2.head.conv.weight.copy_", "bit_models.ResNetV2.head.conv.bias.copy_", "block.named_children", "bit_models.tf2th", "bit_models.tf2th", "unit.load_from"], "methods", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th", "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.load_from"], ["", "def", "load_from", "(", "self", ",", "weights", ",", "prefix", "=", "'resnet/'", ")", ":", "\n", "    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "      ", "self", ".", "root", ".", "conv", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}root_block/standardized_conv2d/kernel'", "]", ")", ")", "# pylint: disable=line-too-long", "\n", "self", ".", "head", ".", "gn", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}group_norm/gamma'", "]", ")", ")", "\n", "self", ".", "head", ".", "gn", ".", "bias", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}group_norm/beta'", "]", ")", ")", "\n", "if", "self", ".", "zero_head", ":", "\n", "        ", "nn", ".", "init", ".", "zeros_", "(", "self", ".", "head", ".", "conv", ".", "weight", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "self", ".", "head", ".", "conv", ".", "bias", ")", "\n", "\n", "", "else", ":", "\n", "        ", "self", ".", "head", ".", "conv", ".", "weight", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}head/conv2d/kernel'", "]", ")", ")", "# pylint: disable=line-too-long", "\n", "self", ".", "head", ".", "conv", ".", "bias", ".", "copy_", "(", "tf2th", "(", "weights", "[", "f'{prefix}head/conv2d/bias'", "]", ")", ")", "\n", "\n", "", "for", "bname", ",", "block", "in", "self", ".", "body", ".", "named_children", "(", ")", ":", "\n", "        ", "for", "uname", ",", "unit", "in", "block", ".", "named_children", "(", ")", ":", "\n", "          ", "unit", ".", "load_from", "(", "weights", ",", "prefix", "=", "f'{prefix}{bname}/{uname}/'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.conv3x3": [[35, 38], ["bit_models.StdConv2d"], "function", ["None"], ["", "", "def", "conv3x3", "(", "cin", ",", "cout", ",", "stride", "=", "1", ",", "groups", "=", "1", ",", "bias", "=", "False", ")", ":", "\n", "  ", "return", "StdConv2d", "(", "cin", ",", "cout", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "bias", ",", "groups", "=", "groups", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.conv1x1": [[40, 43], ["bit_models.StdConv2d"], "function", ["None"], ["", "def", "conv1x1", "(", "cin", ",", "cout", ",", "stride", "=", "1", ",", "bias", "=", "False", ")", ":", "\n", "  ", "return", "StdConv2d", "(", "cin", ",", "cout", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.tf2th": [[45, 50], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "conv_weights.transpose.transpose"], "function", ["None"], ["", "def", "tf2th", "(", "conv_weights", ")", ":", "\n", "  ", "\"\"\"Possibly convert HWIO to OIHW.\"\"\"", "\n", "if", "conv_weights", ".", "ndim", "==", "4", ":", "\n", "    ", "conv_weights", "=", "conv_weights", ".", "transpose", "(", "[", "3", ",", "2", ",", "0", ",", "1", "]", ")", "\n", "", "return", "torch", ".", "from_numpy", "(", "conv_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.get_model.get_arch": [[9, 30], ["setattr", "torchvision.models.mobilenet_v2", "torch.nn.Linear", "torchvision.models.mobilenet_v2.load_from", "sys.exit", "os.path.isfile", "print", "os.system", "numpy.load"], "function", ["home.repos.pwc.inspect_result.agaldran_balanced_mixup.models.bit_models.ResNetV2.load_from"], ["def", "get_arch", "(", "model_name", ",", "in_c", "=", "3", ",", "n_classes", "=", "1", ")", ":", "\n", "\n", "    ", "if", "model_name", "==", "'mobilenetV2'", ":", "\n", "        ", "model", "=", "mobilenet_v2", "(", "pretrained", "=", "True", ")", "\n", "num_ftrs", "=", "model", ".", "classifier", "[", "1", "]", ".", "in_features", "\n", "model", ".", "classifier", "=", "torch", ".", "nn", ".", "Linear", "(", "num_ftrs", ",", "n_classes", ")", "\n", "mean", ",", "std", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", ",", "[", "0.229", ",", "0.224", ",", "0.225", "]", "\n", "\n", "", "elif", "model_name", "==", "'bit_resnext50_1'", ":", "\n", "        ", "bit_variant", "=", "'BiT-M-R50x1'", "\n", "model", "=", "bit_models", ".", "KNOWN_MODELS", "[", "bit_variant", "]", "(", "head_size", "=", "n_classes", ",", "zero_head", "=", "True", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "'models/BiT-M-R50x1.npz'", ")", ":", "\n", "            ", "print", "(", "'downloading bit_resnext50_1 weights:'", ")", "\n", "os", ".", "system", "(", "'wget https://storage.googleapis.com/bit_models/BiT-M-R50x1.npz -P models/'", ")", "\n", "", "model", ".", "load_from", "(", "np", ".", "load", "(", "'models/BiT-M-R50x1.npz'", ")", ")", "\n", "mean", ",", "std", "=", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", ",", "0.5", "]", "\n", "", "else", ":", "\n", "        ", "sys", ".", "exit", "(", "'not a valid model_name, check models.get_model.py'", ")", "\n", "", "setattr", "(", "model", ",", "'n_classes'", ",", "n_classes", ")", "\n", "\n", "return", "model", ",", "mean", ",", "std", "\n", "\n"]]}