{"home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.None.train.train": [[145, 243], ["model.train", "utils.solver.build_optimizer", "utils.solver.build_lr_scheduler", "utils.checkpointer.DetectionCheckpointer", "layers.modules.multibox_loss_combined.MultiBoxLoss_combined", "utils.checkpointer.PeriodicCheckpointer", "utils.sampler.TrainingSampler", "iter", "logger.info", "utils.checkpointer.DetectionCheckpointer.resume_or_load().get", "utils.event.CommonMetricPrinter", "utils.event.TensorboardXWriter", "data.VOCDetection", "utils.sampler.TrainingSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "train.init_reweight", "data.COCODetection.set_mixup", "logger.info", "len", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "utils.event.EventStorage", "range", "data.preproc", "data.AnnotationTransform", "data.COCODetection", "ValueError", "len", "storage.step", "next", "model", "layers.modules.multibox_loss_combined.MultiBoxLoss_combined.", "sum", "storage.put_scalars", "utils.solver.build_optimizer.zero_grad", "sum.backward", "utils.solver.build_optimizer.step", "storage.put_scalar", "utils.solver.build_lr_scheduler.step", "utils.checkpointer.PeriodicCheckpointer.step", "utils.checkpointer.DetectionCheckpointer.resume_or_load", "data.preproc", "data.COCODetection.set_mixup", "iter", "isinstance", "str", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "model.module.normalize", "model.normalize", "writer.write", "criterion.values"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.None.train.train", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.build_optimizer", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.build_lr_scheduler", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.iter", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.None.train.init_reweight", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.set_mixup", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.step", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_scalars", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.step", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_scalar", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.step", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.step", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.resume_or_load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.set_mixup", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.iter", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.normalize", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.normalize", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.CommonMetricPrinter.write", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.values"], ["def", "train", "(", "model", ",", "resume", "=", "False", ")", ":", "\n", "    ", "model", ".", "train", "(", ")", "\n", "optimizer", "=", "build_optimizer", "(", "args", ",", "model", ")", "\n", "scheduler", "=", "build_lr_scheduler", "(", "args", ",", "optimizer", ")", "\n", "checkpointer", "=", "DetectionCheckpointer", "(", "\n", "model", ",", "args", ",", "optimizer", "=", "optimizer", ",", "scheduler", "=", "scheduler", "\n", ")", "\n", "criterion", "=", "MultiBoxLoss_combined", "(", "num_classes", ",", "overlap_threshold", ",", "True", ",", "0", ",", "True", ",", "3", ",", "0.5", ",", "False", ")", "\n", "start_iter", "=", "(", "\n", "checkpointer", ".", "resume_or_load", "(", "args", ".", "basenet", "if", "args", ".", "phase", "==", "1", "else", "args", ".", "load_file", ",", "\n", "resume", "=", "resume", ")", ".", "get", "(", "\"iteration\"", ",", "-", "1", ")", "+", "1", "\n", ")", "\n", "max_iter", "=", "args", ".", "max_iter", "\n", "periodic_checkpointer", "=", "PeriodicCheckpointer", "(", "\n", "checkpointer", ",", "args", ".", "checkpoint_period", ",", "max_iter", "=", "max_iter", "\n", ")", "\n", "\n", "writers", "=", "(", "\n", "[", "\n", "CommonMetricPrinter", "(", "max_iter", ")", ",", "\n", "TensorboardXWriter", "(", "args", ".", "save_folder", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "if", "args", ".", "dataset", "==", "'VOC'", ":", "\n", "        ", "dataset", "=", "VOCDetection", "(", "args", ",", "VOCroot", ",", "train_sets", ",", "preproc", "(", "\n", "img_dim", ",", "rgb_means", ",", "p", ")", ",", "AnnotationTransform", "(", "0", "if", "args", ".", "setting", "==", "'transfer'", "else", "args", ".", "split", ")", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'COCO'", ":", "\n", "        ", "dataset", "=", "COCODetection", "(", "COCOroot", ",", "train_sets", ",", "preproc", "(", "\n", "img_dim", ",", "rgb_means", ",", "p", ")", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Unknown dataset: {args.dataset}\"", ")", "\n", "\n", "", "if", "args", ".", "phase", "==", "2", "and", "args", ".", "method", "==", "'ours'", ":", "\n", "        ", "sampler", "=", "TrainingSampler", "(", "len", "(", "dataset", ")", ")", "\n", "data_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "args", ".", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "collate_fn", "=", "detection_collate", ",", "\n", ")", "\n", "# initialize the OBJ(Target) parameters", "\n", "init_reweight", "(", "args", ",", "model", ",", "data_loader", ")", "\n", "dataset", ".", "set_mixup", "(", "np", ".", "random", ".", "beta", ",", "1.5", ",", "1.5", ")", "\n", "logger", ".", "info", "(", "'Fine tuning on '", "+", "str", "(", "args", ".", "shot", ")", "+", "'-shot task'", ")", "\n", "\n", "", "sampler", "=", "TrainingSampler", "(", "len", "(", "dataset", ")", ")", "\n", "data_loader", "=", "iter", "(", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "args", ".", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "collate_fn", "=", "detection_collate", ",", "\n", ")", ")", "\n", "assert", "model", ".", "training", ",", "'Model.train() must be True during training.'", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "\n", "# scheduler = optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=args.gamma, last_epoch=epoch - 1)", "\n", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "storage", ":", "\n", "        ", "for", "iteration", "in", "range", "(", "start_iter", ",", "max_iter", ")", ":", "\n", "            ", "iteration", "=", "iteration", "+", "1", "\n", "storage", ".", "step", "(", ")", "\n", "if", "args", ".", "phase", "==", "2", "and", "args", ".", "method", "==", "'ours'", "and", "iteration", "==", "(", "args", ".", "max_iter", "-", "args", ".", "no_mixup_iter", ")", ":", "\n", "                ", "dataset", ".", "set_mixup", "(", "None", ")", "\n", "data_loader", "=", "iter", "(", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "args", ".", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "args", ".", "num_workers", ",", "\n", "collate_fn", "=", "detection_collate", ",", "\n", ")", ")", "\n", "\n", "", "data", ",", "targets", "=", "next", "(", "data_loader", ")", "\n", "# storage.put_image('image', vis_tensorboard(data))", "\n", "output", "=", "model", "(", "data", ")", "\n", "loss_dict", "=", "criterion", "(", "output", ",", "priors", ",", "targets", ")", "\n", "losses", "=", "sum", "(", "loss", "for", "loss", "in", "loss_dict", ".", "values", "(", ")", ")", "\n", "# assert torch.isfinite(losses).all(), loss_dict", "\n", "storage", ".", "put_scalars", "(", "total_loss", "=", "losses", ",", "**", "loss_dict", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "args", ".", "phase", "==", "2", "and", "args", ".", "method", "==", "'ours'", ":", "\n", "                ", "if", "isinstance", "(", "model", ",", "(", "DistributedDataParallel", ",", "DataParallel", ")", ")", ":", "\n", "                    ", "model", ".", "module", ".", "normalize", "(", ")", "\n", "", "else", ":", "\n", "                    ", "model", ".", "normalize", "(", ")", "\n", "", "", "storage", ".", "put_scalar", "(", "\"lr\"", ",", "optimizer", ".", "param_groups", "[", "-", "1", "]", "[", "\"lr\"", "]", ",", "smoothing_hint", "=", "False", ")", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "if", "iteration", "-", "start_iter", ">", "5", "and", "(", "iteration", "%", "20", "==", "0", "or", "iteration", "==", "max_iter", ")", ":", "\n", "                ", "for", "writer", "in", "writers", ":", "\n", "                    ", "writer", ".", "write", "(", ")", "\n", "", "", "periodic_checkpointer", ".", "step", "(", "iteration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.None.train.vis_tensorboard": [[245, 250], ["torch.Tensor().to", "torch.Tensor().to", "image[].byte", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["", "", "", "def", "vis_tensorboard", "(", "images", ")", ":", "\n", "    ", "rgb_mean", "=", "torch", ".", "Tensor", "(", "rgb_means", ")", ".", "to", "(", "images", ".", "device", ")", "\n", "image", "=", "images", "[", "0", "]", "+", "rgb_mean", "[", ":", ",", "None", ",", "None", "]", "\n", "image", "=", "image", "[", "[", "2", ",", "1", ",", "0", "]", "]", ".", "byte", "(", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.None.train.init_reweight": [[252, 287], ["logger.info", "zip", "isinstance", "torch.empty().to", "torch.empty().to", "range", "data.size", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cuda.is_available", "torch.cuda.is_available", "range", "anno.to", "torch.no_grad", "torch.no_grad", "model", "utils.box_utils.match", "torch.cat", "torch.cat", "torch.empty", "torch.empty", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.BoolTensor", "torch.BoolTensor", "range", "range", "item.norm", "item.norm", "item.norm"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.match"], ["", "def", "init_reweight", "(", "args", ",", "model", ",", "data_loader", ")", ":", "\n", "    ", "\"\"\"\n    Initialize the OBJ(Target) parameters.\n    \"\"\"", "\n", "logger", ".", "info", "(", "'Initializing the OBJ(Target) parameters...'", ")", "\n", "device", "=", "'cuda'", "if", "args", ".", "cuda", "and", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", "\n", "cls_list", "=", "[", "torch", ".", "empty", "(", "0", ")", ".", "to", "(", "device", ")", "for", "_", "in", "range", "(", "num_classes", "-", "1", ")", "]", "\n", "\n", "for", "(", "data", ",", "targets", ")", ",", "iteration", "in", "zip", "(", "data_loader", ",", "range", "(", "args", ".", "init_iter", ")", ")", ":", "\n", "# vis_picture(images, targets)", "\n", "        ", "num", "=", "data", ".", "size", "(", "0", ")", "\n", "targets", "=", "[", "anno", ".", "to", "(", "device", ")", "for", "anno", "in", "targets", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "conf_data", "=", "model", "(", "data", ",", "init", "=", "True", ")", "\n", "\n", "", "loc_t", "=", "torch", ".", "Tensor", "(", "num", ",", "num_priors", ",", "4", ")", ".", "to", "(", "device", ")", "\n", "conf_t", "=", "torch", ".", "Tensor", "(", "num", ",", "num_priors", ",", "2", ")", ".", "to", "(", "device", ")", "\n", "obj_t", "=", "torch", ".", "BoolTensor", "(", "num", ",", "num_priors", ")", ".", "to", "(", "device", ")", "\n", "\n", "# match priors with gt", "\n", "for", "idx", "in", "range", "(", "num", ")", ":", "# batch_size", "\n", "            ", "truths", "=", "targets", "[", "idx", "]", "[", ":", ",", ":", "-", "2", "]", ".", "data", "# [obj_num, 4]", "\n", "labels", "=", "targets", "[", "idx", "]", "[", ":", ",", "-", "2", ":", "]", ".", "data", "# [obj_num]", "\n", "defaults", "=", "priors", ".", "data", "# [num_priors,4]", "\n", "match", "(", "overlap_threshold", ",", "truths", ",", "defaults", ",", "[", "0.1", ",", "0.2", "]", ",", "labels", ",", "loc_t", ",", "conf_t", ",", "obj_t", ",", "idx", ")", "\n", "\n", "", "conf_data_list", "=", "[", "conf_data", "[", "conf_t", "[", ":", ",", ":", ",", "0", "]", "==", "i", "]", "for", "i", "in", "range", "(", "1", ",", "num_classes", ")", "]", "\n", "cls_list", "=", "[", "torch", ".", "cat", "(", "(", "cls_list", "[", "i", "]", ",", "conf_data_list", "[", "i", "]", ")", ",", "0", ")", "for", "i", "in", "range", "(", "num_classes", "-", "1", ")", "]", "\n", "", "cls_list", "=", "[", "(", "item", "/", "item", ".", "norm", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", ".", "mean", "(", "0", ")", "for", "item", "in", "cls_list", "]", "\n", "if", "args", ".", "setting", "==", "'incre'", ":", "\n", "        ", "cls_list", "=", "cls_list", "[", "15", ":", "]", "\n", "", "if", "isinstance", "(", "model", ",", "(", "DistributedDataParallel", ",", "DataParallel", ")", ")", ":", "\n", "        ", "model", ".", "module", ".", "OBJ_Target", ".", "weight", ".", "data", "=", "torch", ".", "stack", "(", "[", "item", "/", "item", ".", "norm", "(", ")", "for", "item", "in", "cls_list", "]", ",", "0", ")", "\n", "", "else", ":", "\n", "        ", "model", ".", "OBJ_Target", ".", "weight", ".", "data", "=", "torch", ".", "stack", "(", "[", "item", "/", "item", ".", "norm", "(", ")", "for", "item", "in", "cls_list", "]", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.None.test.do_test": [[96, 176], ["len", "data.BaseTransform", "os.path.join", "range", "logger.info", "data.COCODetection.evaluate_detections", "data.VOCDetection", "utils.timer.Timer", "utils.timer.Timer", "open", "pickle.load", "logger.info", "data.COCODetection.evaluate_detections", "data.COCODetection.pull_image", "torch.Tensor().to", "torch.Tensor().to", "_t[].tic", "model", "detector.forward", "_t[].toc", "boxes.cpu().numpy.cpu().numpy", "scores.cpu().numpy.cpu().numpy", "_t[].tic", "range", "_t[].toc", "open", "pickle.dump", "data.AnnotationTransform", "data.COCODetection", "ValueError", "range", "torch.no_grad", "torch.no_grad", "data.BaseTransform.unsqueeze", "numpy.hstack().astype", "utils.nms_wrapper.nms", "numpy.hstack", "logger.info", "_t[].clear", "_t[].clear", "range", "torch.Tensor", "torch.Tensor", "boxes.cpu().numpy.cpu", "scores.cpu().numpy.cpu", "numpy.where", "len", "numpy.empty", "len", "range", "data.BaseTransform.", "numpy.hstack", "numpy.sort", "range", "numpy.where"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.evaluate_detections", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.evaluate_detections", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.pull_image", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.forward", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.tic", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.toc", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.nms_wrapper.nms", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.clear", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.clear"], ["", "", "def", "do_test", "(", "args", ",", "model", ",", "detector", ",", "max_per_image", "=", "200", ",", "thresh", "=", "0.01", ")", ":", "\n", "    ", "if", "args", ".", "dataset", "==", "'VOC'", ":", "\n", "        ", "dataset", "=", "VOCDetection", "(", "args", ",", "VOCroot", ",", "[", "(", "'2007'", ",", "'test'", ")", "]", ",", "None", ",", "\n", "AnnotationTransform", "(", "0", "if", "args", ".", "setting", "==", "'transfer'", "else", "args", ".", "split", ")", ",", "True", ")", "\n", "", "elif", "args", ".", "dataset", "==", "'COCO'", ":", "\n", "        ", "dataset", "=", "COCODetection", "(", "\n", "COCOroot", ",", "[", "(", "'2014'", ",", "'split_nonvoc_minival'", ")", "]", ",", "None", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Unknown dataset: {args.dataset}\"", ")", "\n", "\n", "", "num_images", "=", "len", "(", "dataset", ")", "\n", "all_boxes", "=", "[", "[", "[", "]", "for", "_", "in", "range", "(", "num_images", ")", "]", "\n", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "transform", "=", "BaseTransform", "(", "model", ".", "size", ",", "rgb_means", ",", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n", "_t", "=", "{", "'im_detect'", ":", "Timer", "(", ")", ",", "'misc'", ":", "Timer", "(", ")", "}", "\n", "det_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "save_folder", ",", "'detections.pkl'", ")", "\n", "\n", "if", "args", ".", "retest", ":", "\n", "        ", "f", "=", "open", "(", "det_file", ",", "'rb'", ")", "\n", "all_boxes", "=", "pickle", ".", "load", "(", "f", ")", "\n", "logger", ".", "info", "(", "'Evaluating detections'", ")", "\n", "dataset", ".", "evaluate_detections", "(", "all_boxes", ",", "args", ".", "save_folder", ")", "\n", "return", "\n", "\n", "", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "        ", "img", "=", "dataset", ".", "pull_image", "(", "i", ")", "\n", "scale", "=", "torch", ".", "Tensor", "(", "[", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "0", "]", ",", "\n", "img", ".", "shape", "[", "1", "]", ",", "img", ".", "shape", "[", "0", "]", "]", ")", ".", "to", "(", "model", ".", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x", "=", "transform", "(", "img", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "_t", "[", "'im_detect'", "]", ".", "tic", "(", ")", "\n", "\n", "pred", "=", "model", "(", "x", ")", "# forward pass", "\n", "boxes", ",", "scores", "=", "detector", ".", "forward", "(", "pred", ",", "priors", ")", "\n", "detect_time", "=", "_t", "[", "'im_detect'", "]", ".", "toc", "(", ")", "\n", "boxes", "=", "boxes", "[", "0", "]", "# percent and point form detection boxes", "\n", "scores", "=", "scores", "[", "0", "]", "# [1, num_priors, num_classes]", "\n", "\n", "boxes", "*=", "scale", "# scale each detection back up to the image", "\n", "boxes", "=", "boxes", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "_t", "[", "'misc'", "]", ".", "tic", "(", ")", "\n", "\n", "for", "j", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "            ", "inds", "=", "np", ".", "where", "(", "scores", "[", ":", ",", "j", "]", ">", "thresh", ")", "[", "0", "]", "\n", "if", "len", "(", "inds", ")", "==", "0", ":", "\n", "                ", "all_boxes", "[", "j", "]", "[", "i", "]", "=", "np", ".", "empty", "(", "[", "0", ",", "5", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "continue", "\n", "", "c_bboxes", "=", "boxes", "[", "inds", "]", "\n", "c_scores", "=", "scores", "[", "inds", ",", "j", "]", "\n", "c_dets", "=", "np", ".", "hstack", "(", "(", "c_bboxes", ",", "c_scores", "[", ":", ",", "np", ".", "newaxis", "]", ")", ")", ".", "astype", "(", "\n", "np", ".", "float32", ",", "copy", "=", "False", ")", "\n", "\n", "keep", "=", "nms", "(", "c_dets", ",", "0.45", ",", "force_cpu", "=", "args", ".", "cpu", ")", "\n", "c_dets", "=", "c_dets", "[", "keep", ",", ":", "]", "\n", "all_boxes", "[", "j", "]", "[", "i", "]", "=", "c_dets", "\n", "", "if", "max_per_image", ">", "0", ":", "\n", "            ", "image_scores", "=", "np", ".", "hstack", "(", "[", "all_boxes", "[", "j", "]", "[", "i", "]", "[", ":", ",", "-", "1", "]", "for", "j", "in", "range", "(", "1", ",", "num_classes", ")", "]", ")", "\n", "if", "len", "(", "image_scores", ")", ">", "max_per_image", ":", "\n", "                ", "image_thresh", "=", "np", ".", "sort", "(", "image_scores", ")", "[", "-", "max_per_image", "]", "\n", "for", "j", "in", "range", "(", "1", ",", "num_classes", ")", ":", "\n", "                    ", "keep", "=", "np", ".", "where", "(", "all_boxes", "[", "j", "]", "[", "i", "]", "[", ":", ",", "-", "1", "]", ">=", "image_thresh", ")", "[", "0", "]", "\n", "all_boxes", "[", "j", "]", "[", "i", "]", "=", "all_boxes", "[", "j", "]", "[", "i", "]", "[", "keep", ",", ":", "]", "\n", "\n", "", "", "", "nms_time", "=", "_t", "[", "'misc'", "]", ".", "toc", "(", ")", "\n", "\n", "if", "i", "%", "20", "==", "0", ":", "\n", "            ", "logger", ".", "info", "(", "'im_detect: {:d}/{:d} {:.3f}s {:.3f}s'", "\n", ".", "format", "(", "i", "+", "1", ",", "num_images", ",", "detect_time", ",", "nms_time", ")", ")", "\n", "_t", "[", "'im_detect'", "]", ".", "clear", "(", ")", "\n", "_t", "[", "'misc'", "]", ".", "clear", "(", ")", "\n", "\n", "", "", "with", "open", "(", "det_file", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "all_boxes", ",", "f", ",", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "", "logger", ".", "info", "(", "'Evaluating detections'", ")", "\n", "dataset", ".", "evaluate_detections", "(", "all_boxes", ",", "args", ".", "save_folder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.custom_build_ext.build_extensions": [[109, 112], ["build.customize_compiler_for_nvcc", "Cython.Distutils.build_ext.build_extensions"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.customize_compiler_for_nvcc", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.custom_build_ext.build_extensions"], ["    ", "def", "build_extensions", "(", "self", ")", ":", "\n", "        ", "customize_compiler_for_nvcc", "(", "self", ".", "compiler", ")", "\n", "build_ext", ".", "build_extensions", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.find_in_path": [[16, 24], ["path.split", "os.path.join", "os.path.exists", "os.path.abspath"], "function", ["None"], ["def", "find_in_path", "(", "name", ",", "path", ")", ":", "\n", "    ", "\"Find a file in a search path\"", "\n", "# adapted fom http://code.activestate.com/recipes/52224-find-a-file-given-a-search-path/", "\n", "for", "dir", "in", "path", ".", "split", "(", "os", ".", "pathsep", ")", ":", "\n", "        ", "binpath", "=", "pjoin", "(", "dir", ",", "name", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "binpath", ")", ":", "\n", "            ", "return", "os", ".", "path", ".", "abspath", "(", "binpath", ")", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.locate_cuda": [[26, 57], ["cudaconfig.items", "os.path.join", "os.path.join", "build.find_in_path", "os.path.dirname", "os.path.join", "os.path.join", "EnvironmentError", "os.path.dirname", "os.path.exists", "EnvironmentError"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.find_in_path"], ["", "def", "locate_cuda", "(", ")", ":", "\n", "    ", "\"\"\"Locate the CUDA environment on the system\n\n    Returns a dict with keys 'home', 'nvcc', 'include', and 'lib64'\n    and values giving the absolute path to each directory.\n\n    Starts by looking for the CUDAHOME env variable. If not found, everything\n    is based on finding 'nvcc' in the PATH.\n    \"\"\"", "\n", "\n", "# first check if the CUDAHOME env variable is in use", "\n", "if", "'CUDAHOME'", "in", "os", ".", "environ", ":", "\n", "        ", "home", "=", "os", ".", "environ", "[", "'CUDAHOME'", "]", "\n", "nvcc", "=", "pjoin", "(", "home", ",", "'bin'", ",", "'nvcc'", ")", "\n", "", "else", ":", "\n", "# otherwise, search the PATH for NVCC", "\n", "        ", "default_path", "=", "pjoin", "(", "os", ".", "sep", ",", "'usr'", ",", "'local'", ",", "'cuda'", ",", "'bin'", ")", "\n", "nvcc", "=", "find_in_path", "(", "'nvcc'", ",", "os", ".", "environ", "[", "'PATH'", "]", "+", "os", ".", "pathsep", "+", "default_path", ")", "\n", "if", "nvcc", "is", "None", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The nvcc binary could not be '", "\n", "'located in your $PATH. Either add it to your path, or set $CUDAHOME'", ")", "\n", "", "home", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "nvcc", ")", ")", "\n", "\n", "", "cudaconfig", "=", "{", "'home'", ":", "home", ",", "'nvcc'", ":", "nvcc", ",", "\n", "'include'", ":", "pjoin", "(", "home", ",", "'include'", ")", ",", "\n", "'lib64'", ":", "pjoin", "(", "home", ",", "'lib64'", ")", "}", "\n", "for", "k", ",", "v", "in", "cudaconfig", ".", "items", "(", ")", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "v", ")", ":", "\n", "            ", "raise", "EnvironmentError", "(", "'The CUDA %s path could not be located in %s'", "%", "(", "k", ",", "v", ")", ")", "\n", "\n", "", "", "return", "cudaconfig", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.build.customize_compiler_for_nvcc": [[68, 105], ["build..src_extensions.append", "print", "build..set_executable", "os.path.splitext"], "function", ["None"], ["", "def", "customize_compiler_for_nvcc", "(", "self", ")", ":", "\n", "    ", "\"\"\"inject deep into distutils to customize how the dispatch\n    to gcc/nvcc works.\n\n    If you subclass UnixCCompiler, it's not trivial to get your subclass\n    injected in, and still have the right customizations (i.e.\n    distutils.sysconfig.customize_compiler) run on it. So instead of going\n    the OO route, I have this. Note, it's kindof like a wierd functional\n    subclassing going on.\"\"\"", "\n", "\n", "# tell the compiler it can processes .cu", "\n", "self", ".", "src_extensions", ".", "append", "(", "'.cu'", ")", "\n", "\n", "# save references to the default compiler_so and _comple methods", "\n", "default_compiler_so", "=", "self", ".", "compiler_so", "\n", "super", "=", "self", ".", "_compile", "\n", "\n", "# now redefine the _compile method. This gets executed for each", "\n", "# object but distutils doesn't have the ability to change compilers", "\n", "# based on source extension: we add it.", "\n", "def", "_compile", "(", "obj", ",", "src", ",", "ext", ",", "cc_args", ",", "extra_postargs", ",", "pp_opts", ")", ":", "\n", "        ", "print", "(", "extra_postargs", ")", "\n", "if", "os", ".", "path", ".", "splitext", "(", "src", ")", "[", "1", "]", "==", "'.cu'", ":", "\n", "# use the cuda for .cu files", "\n", "            ", "self", ".", "set_executable", "(", "'compiler_so'", ",", "CUDA", "[", "'nvcc'", "]", ")", "\n", "# use only a subset of the extra_postargs, which are 1-1 translated", "\n", "# from the extra_compile_args in the Extension class", "\n", "postargs", "=", "extra_postargs", "[", "'nvcc'", "]", "\n", "", "else", ":", "\n", "            ", "postargs", "=", "extra_postargs", "[", "'gcc'", "]", "\n", "\n", "", "super", "(", "obj", ",", "src", ",", "ext", ",", "cc_args", ",", "postargs", ",", "pp_opts", ")", "\n", "# reset the default compiler_so, which we might have changed for cuda", "\n", "self", ".", "compiler_so", "=", "default_compiler_so", "\n", "\n", "# inject our redefined _compile method into the class", "\n", "", "self", ".", "_compile", "=", "_compile", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.__init__": [[13, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "total_time", "=", "0.", "\n", "self", ".", "calls", "=", "0", "\n", "self", ".", "start_time", "=", "0.", "\n", "self", ".", "diff", "=", "0.", "\n", "self", ".", "average_time", "=", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.tic": [[20, 24], ["time.time"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "# using time.time instead of time.clock because time time.clock", "\n", "# does not normalize for multithreading", "\n", "        ", "self", ".", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.toc": [[25, 34], ["time.time"], "methods", ["None"], ["", "def", "toc", "(", "self", ",", "average", "=", "True", ")", ":", "\n", "        ", "self", ".", "diff", "=", "time", ".", "time", "(", ")", "-", "self", ".", "start_time", "\n", "self", ".", "total_time", "+=", "self", ".", "diff", "\n", "self", ".", "calls", "+=", "1", "\n", "self", ".", "average_time", "=", "self", ".", "total_time", "/", "self", ".", "calls", "\n", "if", "average", ":", "\n", "            ", "return", "self", ".", "average_time", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.timer.Timer.clear": [[35, 41], ["None"], "methods", ["None"], ["", "", "def", "clear", "(", "self", ")", ":", "\n", "        ", "self", ".", "total_time", "=", "0.", "\n", "self", ".", "calls", "=", "0", "\n", "self", ".", "start_time", "=", "0.", "\n", "self", ".", "diff", "=", "0.", "\n", "self", ".", "average_time", "=", "0.", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.WarmupMultiStepLR.__init__": [[50, 70], ["super().__init__", "ValueError", "list", "sorted"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", ",", "\n", "milestones", ":", "List", "[", "int", "]", ",", "\n", "gamma", ":", "float", "=", "0.1", ",", "\n", "warmup_factor", ":", "float", "=", "1e-6", ",", "\n", "warmup_iters", ":", "int", "=", "1000", ",", "\n", "warmup_method", ":", "str", "=", "\"linear\"", ",", "\n", "last_epoch", ":", "int", "=", "-", "1", ",", "\n", ")", ":", "\n", "        ", "if", "not", "list", "(", "milestones", ")", "==", "sorted", "(", "milestones", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Milestones should be a list of\"", "\" increasing integers. Got {}\"", ",", "milestones", "\n", ")", "\n", "", "self", ".", "milestones", "=", "milestones", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "warmup_factor", "=", "warmup_factor", "\n", "self", ".", "warmup_iters", "=", "warmup_iters", "\n", "self", ".", "warmup_method", "=", "warmup_method", "\n", "super", "(", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.WarmupMultiStepLR.get_lr": [[71, 78], ["solver._get_warmup_factor_at_iter", "bisect.bisect_right"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver._get_warmup_factor_at_iter"], ["", "def", "get_lr", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "        ", "warmup_factor", "=", "_get_warmup_factor_at_iter", "(", "\n", "self", ".", "warmup_method", ",", "self", ".", "last_epoch", ",", "self", ".", "warmup_iters", ",", "self", ".", "warmup_factor", "\n", ")", "\n", "return", "[", "\n", "base_lr", "*", "warmup_factor", "*", "self", ".", "gamma", "**", "bisect_right", "(", "self", ".", "milestones", ",", "self", ".", "last_epoch", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.WarmupMultiStepLR._compute_values": [[80, 83], ["solver.WarmupMultiStepLR.get_lr"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.WarmupMultiStepLR.get_lr"], ["", "def", "_compute_values", "(", "self", ")", "->", "List", "[", "float", "]", ":", "\n", "# The new interface", "\n", "        ", "return", "self", ".", "get_lr", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.build_optimizer": [[6, 34], ["model.named_parameters", "torch.optim.SGD"], "function", ["None"], ["def", "build_optimizer", "(", "args", ",", "model", ":", "torch", ".", "nn", ".", "Module", ")", "->", "torch", ".", "optim", ".", "Optimizer", ":", "\n", "    ", "\"\"\"\n    Build an optimizer from args.\n    \"\"\"", "\n", "params", ":", "List", "[", "Dict", "[", "str", ",", "Any", "]", "]", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "        ", "if", "not", "value", ".", "requires_grad", ":", "\n", "            ", "continue", "\n", "", "lr", "=", "args", ".", "lr", "\n", "weight_decay", "=", "args", ".", "weight_decay", "\n", "if", "args", ".", "phase", "==", "2", "and", "args", ".", "method", "==", "'ours'", ":", "\n", "            ", "if", "'base'", "in", "key", ":", "\n", "                ", "lr", "=", "args", ".", "lr", "*", "0.1", "\n", "", "elif", "'extras'", "in", "key", "or", "'Norm'", "in", "key", ":", "\n", "                ", "lr", "=", "args", ".", "lr", "*", "0.5", "\n", "# if key.endswith(\"norm.weight\") or key.endswith(\"norm.bias\"):", "\n", "#     weight_decay = cfg.SOLVER.WEIGHT_DECAY_NORM", "\n", "# elif key.endswith(\".bias\"):", "\n", "#     # NOTE: unlike Detectron v1, we now default BIAS_LR_FACTOR to 1.0", "\n", "#     # and WEIGHT_DECAY_BIAS to WEIGHT_DECAY so that bias optimizer", "\n", "#     # hyperparameters are by default exactly the same as for regular", "\n", "#     # weights.", "\n", "#     lr = cfg.SOLVER.BASE_LR * cfg.SOLVER.BIAS_LR_FACTOR", "\n", "#     weight_decay = cfg.SOLVER.WEIGHT_DECAY_BIAS", "\n", "", "", "params", "+=", "[", "{", "\"params\"", ":", "[", "value", "]", ",", "\"lr\"", ":", "lr", ",", "\"weight_decay\"", ":", "weight_decay", "}", "]", "\n", "\n", "", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "params", ",", "lr", ",", "momentum", "=", "args", ".", "momentum", ")", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver.build_lr_scheduler": [[36, 46], ["solver.WarmupMultiStepLR"], "function", ["None"], ["", "def", "build_lr_scheduler", "(", "\n", "args", ",", "optimizer", ":", "torch", ".", "optim", ".", "Optimizer", "\n", ")", "->", "torch", ".", "optim", ".", "lr_scheduler", ".", "_LRScheduler", ":", "\n", "    ", "\"\"\"\n    Build a LR scheduler from config.\n    \"\"\"", "\n", "return", "WarmupMultiStepLR", "(", "\n", "optimizer", ",", "\n", "args", ".", "steps", ",", "\n", "warmup_iters", "=", "args", ".", "warmup_iter", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.solver._get_warmup_factor_at_iter": [[85, 112], ["ValueError"], "function", ["None"], ["", "", "def", "_get_warmup_factor_at_iter", "(", "\n", "method", ":", "str", ",", "iter", ":", "int", ",", "warmup_iters", ":", "int", ",", "warmup_factor", ":", "float", "\n", ")", "->", "float", ":", "\n", "    ", "\"\"\"\n    Return the learning rate warmup factor at a specific iteration.\n    See https://arxiv.org/abs/1706.02677 for more details.\n\n    Args:\n        method (str): warmup method; either \"constant\" or \"linear\".\n        iter (int): iteration at which to calculate the warmup factor.\n        warmup_iters (int): the number of warmup iterations.\n        warmup_factor (float): the base warmup factor (the meaning changes according\n            to the method used).\n\n    Returns:\n        float: the effective warmup factor at the given iteration.\n    \"\"\"", "\n", "if", "iter", ">=", "warmup_iters", ":", "\n", "        ", "return", "1.0", "\n", "\n", "", "if", "method", "==", "\"constant\"", ":", "\n", "        ", "return", "warmup_factor", "\n", "", "elif", "method", "==", "\"linear\"", ":", "\n", "        ", "alpha", "=", "iter", "/", "warmup_iters", "\n", "return", "warmup_factor", "*", "(", "1", "-", "alpha", ")", "+", "alpha", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown warmup method: {}\"", ".", "format", "(", "method", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._ColorfulFormatter.__init__": [[13, 19], ["kwargs.pop", "len", "logging.Formatter.__init__", "kwargs.pop"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "_root_name", "=", "kwargs", ".", "pop", "(", "\"root_name\"", ")", "+", "\".\"", "\n", "self", ".", "_abbrev_name", "=", "kwargs", ".", "pop", "(", "\"abbrev_name\"", ",", "\"\"", ")", "\n", "if", "len", "(", "self", ".", "_abbrev_name", ")", ":", "\n", "            ", "self", ".", "_abbrev_name", "=", "self", ".", "_abbrev_name", "+", "\".\"", "\n", "", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._ColorfulFormatter.formatMessage": [[20, 30], ["record.name.replace", "super().formatMessage", "termcolor.colored", "termcolor.colored"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._ColorfulFormatter.formatMessage"], ["", "def", "formatMessage", "(", "self", ",", "record", ")", ":", "\n", "        ", "record", ".", "name", "=", "record", ".", "name", ".", "replace", "(", "self", ".", "_root_name", ",", "self", ".", "_abbrev_name", ")", "\n", "log", "=", "super", "(", "_ColorfulFormatter", ",", "self", ")", ".", "formatMessage", "(", "record", ")", "\n", "if", "record", ".", "levelno", "==", "logging", ".", "WARNING", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"WARNING\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", "]", ")", "\n", "", "elif", "record", ".", "levelno", "==", "logging", ".", "ERROR", "or", "record", ".", "levelno", "==", "logging", ".", "CRITICAL", ":", "\n", "            ", "prefix", "=", "colored", "(", "\"ERROR\"", ",", "\"red\"", ",", "attrs", "=", "[", "\"blink\"", ",", "\"underline\"", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "log", "\n", "", "return", "prefix", "+", "\" \"", "+", "log", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger.setup_logger": [[32, 90], ["functools.lru_cache", "logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logger._ColorfulFormatter", "output.endswith", "output.endswith", "os.path.join", "logger._cached_log_stream", "os.path.exists", "os.makedirs", "termcolor.colored", "str"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._cached_log_stream"], ["", "", "@", "functools", ".", "lru_cache", "(", ")", "# so that calling setup_logger multiple times won't add many handlers", "\n", "def", "setup_logger", "(", "\n", "output", "=", "None", ",", "distributed_rank", "=", "0", ",", "*", ",", "color", "=", "True", ",", "name", "=", "\"Context-Transformer\"", ",", "abbrev_name", "=", "None", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        output (str): a file name or a directory to save log. If None, will not save log file.\n            If ends with \".txt\" or \".log\", assumed to be a file name.\n            Otherwise, logs will be saved to `output/log.txt`.\n        name (str): the root module name of this logger\n        abbrev_name (str): an abbreviation of the module, to avoid long names in logs.\n            Set to \"\" to not log the root module in logs.\n            By default, will abbreviate \"detectron2\" to \"d2\" and leave other\n            modules unchanged.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "\n", "if", "abbrev_name", "is", "None", ":", "\n", "        ", "abbrev_name", "=", "\"CT\"", "if", "name", "==", "\"Context-Transformer\"", "else", "name", "\n", "\n", "", "plain_formatter", "=", "logging", ".", "Formatter", "(", "\n", "\"[%(asctime)s] %(name)s %(levelname)s: %(message)s\"", ",", "datefmt", "=", "\"%m/%d %H:%M:%S\"", "\n", ")", "\n", "# stdout logging: master only", "\n", "if", "distributed_rank", "==", "0", ":", "\n", "        ", "ch", "=", "logging", ".", "StreamHandler", "(", "stream", "=", "sys", ".", "stdout", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "if", "color", ":", "\n", "            ", "formatter", "=", "_ColorfulFormatter", "(", "\n", "colored", "(", "\"[%(asctime)s %(name)s]: \"", ",", "\"green\"", ")", "+", "\"%(message)s\"", ",", "\n", "datefmt", "=", "\"%m/%d %H:%M:%S\"", ",", "\n", "root_name", "=", "name", ",", "\n", "abbrev_name", "=", "str", "(", "abbrev_name", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "formatter", "=", "plain_formatter", "\n", "", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n", "# file logging: all workers", "\n", "", "if", "output", "is", "not", "None", ":", "\n", "        ", "if", "output", ".", "endswith", "(", "\".txt\"", ")", "or", "output", ".", "endswith", "(", "\".log\"", ")", ":", "\n", "            ", "filename", "=", "output", "\n", "", "else", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "output", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "output", ")", "\n", "", "filename", "=", "os", ".", "path", ".", "join", "(", "output", ",", "\"log.txt\"", ")", "\n", "", "if", "distributed_rank", ">", "0", ":", "\n", "            ", "filename", "=", "filename", "+", "\".rank{}\"", ".", "format", "(", "distributed_rank", ")", "\n", "\n", "", "fh", "=", "logging", ".", "StreamHandler", "(", "_cached_log_stream", "(", "filename", ")", ")", "\n", "fh", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "fh", ".", "setFormatter", "(", "plain_formatter", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._cached_log_stream": [[94, 97], ["functools.lru_cache", "open"], "function", ["None"], ["", "@", "functools", ".", "lru_cache", "(", "maxsize", "=", "None", ")", "\n", "def", "_cached_log_stream", "(", "filename", ")", ":", "\n", "    ", "return", "open", "(", "filename", ",", "\"a\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._find_caller": [[106, 121], ["sys._getframe", "os.path.join"], "function", ["None"], ["def", "_find_caller", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        str: module name of the caller\n        tuple: a hashable key to be used to identify different callers\n    \"\"\"", "\n", "frame", "=", "sys", ".", "_getframe", "(", "2", ")", "\n", "while", "frame", ":", "\n", "        ", "code", "=", "frame", ".", "f_code", "\n", "if", "os", ".", "path", ".", "join", "(", "\"utils\"", ",", "\"logger.\"", ")", "not", "in", "code", ".", "co_filename", ":", "\n", "            ", "mod_name", "=", "frame", ".", "f_globals", "[", "\"__name__\"", "]", "\n", "if", "mod_name", "==", "\"__main__\"", ":", "\n", "                ", "mod_name", "=", "\"detectron2\"", "\n", "", "return", "mod_name", ",", "(", "code", ".", "co_filename", ",", "frame", ".", "f_lineno", ",", "code", ".", "co_name", ")", "\n", "", "frame", "=", "frame", ".", "f_back", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger.log_first_n": [[127, 160], ["isinstance", "logger._find_caller", "len", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._find_caller"], ["def", "log_first_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ",", "key", "=", "\"caller\"", ")", ":", "\n", "    ", "\"\"\"\n    Log only for the first n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n        key (str or tuple[str]): the string(s) can be one of \"caller\" or\n            \"message\", which defines how to identify duplicated logs.\n            For example, if called with `n=1, key=\"caller\"`, this function\n            will only log the first call from the same caller, regardless of\n            the message content.\n            If called with `n=1, key=\"message\"`, this function will log the\n            same content only once, even if they are called from different places.\n            If called with `n=1, key=(\"caller\", \"message\")`, this function\n            will not log only if the same caller has logged the same message before.\n    \"\"\"", "\n", "if", "isinstance", "(", "key", ",", "str", ")", ":", "\n", "        ", "key", "=", "(", "key", ",", ")", "\n", "", "assert", "len", "(", "key", ")", ">", "0", "\n", "\n", "caller_module", ",", "caller_key", "=", "_find_caller", "(", ")", "\n", "hash_key", "=", "(", ")", "\n", "if", "\"caller\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "caller_key", "\n", "", "if", "\"message\"", "in", "key", ":", "\n", "        ", "hash_key", "=", "hash_key", "+", "(", "msg", ",", ")", "\n", "\n", "", "_LOG_COUNTER", "[", "hash_key", "]", "+=", "1", "\n", "if", "_LOG_COUNTER", "[", "hash_key", "]", "<=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger.log_every_n": [[162, 176], ["logger._find_caller", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._find_caller"], ["", "", "def", "log_every_n", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log once per n times.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "_LOG_COUNTER", "[", "key", "]", "+=", "1", "\n", "if", "n", "==", "1", "or", "_LOG_COUNTER", "[", "key", "]", "%", "n", "==", "1", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger.log_every_n_seconds": [[178, 194], ["logger._find_caller", "_LOG_TIMER.get", "time.time", "logging.getLogger().log", "logging.getLogger"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger._find_caller"], ["", "", "def", "log_every_n_seconds", "(", "lvl", ",", "msg", ",", "n", "=", "1", ",", "*", ",", "name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Log no more than once per n seconds.\n\n    Args:\n        lvl (int): the logging level\n        msg (str):\n        n (int):\n        name (str): name of the logger to use. Will use the caller's module by default.\n    \"\"\"", "\n", "caller_module", ",", "key", "=", "_find_caller", "(", ")", "\n", "last_logged", "=", "_LOG_TIMER", ".", "get", "(", "key", ",", "None", ")", "\n", "current_time", "=", "time", ".", "time", "(", ")", "\n", "if", "last_logged", "is", "None", "or", "current_time", "-", "last_logged", ">=", "n", ":", "\n", "        ", "logging", ".", "getLogger", "(", "name", "or", "caller_module", ")", ".", "log", "(", "lvl", ",", "msg", ")", "\n", "_LOG_TIMER", "[", "key", "]", "=", "current_time", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.logger.create_small_table": [[196, 217], ["tuple", "tabulate.tabulate", "zip", "small_dict.items"], "function", ["None"], ["", "", "def", "create_small_table", "(", "small_dict", ")", ":", "\n", "    ", "\"\"\"\n    Create a small table using the keys of small_dict as headers. This is only\n    suitable for small dictionaries.\n\n    Args:\n        small_dict (dict): a result dictionary of only a few items.\n\n    Returns:\n        str: the table as a string.\n    \"\"\"", "\n", "keys", ",", "values", "=", "tuple", "(", "zip", "(", "*", "small_dict", ".", "items", "(", ")", ")", ")", "\n", "table", "=", "tabulate", "(", "\n", "[", "values", "]", ",", "\n", "headers", "=", "keys", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "stralign", "=", "\"center\"", ",", "\n", "numalign", "=", "\"center\"", ",", "\n", ")", "\n", "return", "table", "\n", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.point_form": [[5, 15], ["torch.cat"], "function", ["None"], ["def", "point_form", "(", "boxes", ")", ":", "\n", "    ", "\"\"\" Convert prior_boxes to (xmin, ymin, xmax, ymax)\n    representation for comparison to point form ground truth data.\n    Args:\n        boxes: (tensor) center-size default boxes from priorbox layers.\n    Return:\n        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.\n    \"\"\"", "\n", "return", "torch", ".", "cat", "(", "(", "boxes", "[", ":", ",", ":", "2", "]", "-", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", ",", "# xmin, ymin", "\n", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", ")", ",", "1", ")", "# xmax, ymax", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.center_size": [[17, 27], ["torch.cat"], "function", ["None"], ["", "def", "center_size", "(", "boxes", ")", ":", "\n", "    ", "\"\"\" Convert prior_boxes to (cx, cy, w, h)\n    representation for comparison to center-size form ground truth data.\n    Args:\n        boxes: (tensor) point_form boxes\n    Return:\n        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.\n    \"\"\"", "\n", "return", "torch", ".", "cat", "(", "(", "boxes", "[", ":", ",", "2", ":", "]", "+", "boxes", "[", ":", ",", ":", "2", "]", ")", "/", "2", ",", "# cx, cy", "\n", "boxes", "[", ":", ",", "2", ":", "]", "-", "boxes", "[", ":", ",", ":", "2", "]", ",", "1", ")", "# w, h", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.intersect": [[29, 48], ["box_a.size", "box_b.size", "torch.min", "torch.max", "torch.clamp", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze().expand", "box_b[].unsqueeze().expand", "box_a[].unsqueeze", "box_b[].unsqueeze", "box_a[].unsqueeze", "box_b[].unsqueeze"], "function", ["None"], ["", "def", "intersect", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\" We resize both tensors to [A,B,2] without new malloc:\n    [A,2] -> [A,1,2] -> [A,B,2]\n    [B,2] -> [1,B,2] -> [A,B,2]\n    Then we compute the area of intersect between box_a and box_b.\n    Args:\n      box_a: (tensor) bounding boxes, Shape: [A,4].\n      box_b: (tensor) bounding boxes, Shape: [B,4].\n    Return:\n      (tensor) intersection area, Shape: [A,B].\n    \"\"\"", "\n", "A", "=", "box_a", ".", "size", "(", "0", ")", "\n", "B", "=", "box_b", ".", "size", "(", "0", ")", "\n", "max_xy", "=", "torch", ".", "min", "(", "box_a", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", "2", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "min_xy", "=", "torch", ".", "max", "(", "box_a", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ",", "\n", "box_b", "[", ":", ",", ":", "2", "]", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "A", ",", "B", ",", "2", ")", ")", "\n", "inter", "=", "torch", ".", "clamp", "(", "(", "max_xy", "-", "min_xy", ")", ",", "min", "=", "0", ")", "\n", "return", "inter", "[", ":", ",", ":", ",", "0", "]", "*", "inter", "[", ":", ",", ":", ",", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.jaccard": [[50, 69], ["box_utils.intersect"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.intersect"], ["", "def", "jaccard", "(", "box_a", ",", "box_b", ")", ":", "\n", "    ", "\"\"\"Compute the jaccard overlap of two sets of boxes.  The jaccard overlap\n    is simply the intersection over union of two boxes.  Here we operate on\n    ground truth boxes and default boxes.\n    E.g.:\n        A \u2229 B / A \u222a B = A \u2229 B / (area(A) + area(B) - A \u2229 B)\n    Args:\n        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]\n        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]\n    Return:\n        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]\n    \"\"\"", "\n", "inter", "=", "intersect", "(", "box_a", ",", "box_b", ")", "\n", "area_a", "=", "(", "(", "box_a", "[", ":", ",", "2", "]", "-", "box_a", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_a", "[", ":", ",", "3", "]", "-", "box_a", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "area_b", "=", "(", "(", "box_b", "[", ":", ",", "2", "]", "-", "box_b", "[", ":", ",", "0", "]", ")", "*", "\n", "(", "box_b", "[", ":", ",", "3", "]", "-", "box_b", "[", ":", ",", "1", "]", ")", ")", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "inter", ")", "# [A,B]", "\n", "union", "=", "area_a", "+", "area_b", "-", "inter", "\n", "return", "inter", "/", "union", "# [A,B]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.matrix_iou": [[70, 81], ["numpy.maximum", "numpy.minimum", "numpy.prod", "numpy.prod", "numpy.prod"], "function", ["None"], ["", "def", "matrix_iou", "(", "a", ",", "b", ")", ":", "\n", "    ", "\"\"\"\n    return iou of a and b, numpy version for data augenmentation\n    \"\"\"", "\n", "lt", "=", "np", ".", "maximum", "(", "a", "[", ":", ",", "np", ".", "newaxis", ",", ":", "2", "]", ",", "b", "[", ":", ",", ":", "2", "]", ")", "\n", "rb", "=", "np", ".", "minimum", "(", "a", "[", ":", ",", "np", ".", "newaxis", ",", "2", ":", "]", ",", "b", "[", ":", ",", "2", ":", "]", ")", "\n", "\n", "area_i", "=", "np", ".", "prod", "(", "rb", "-", "lt", ",", "axis", "=", "2", ")", "*", "(", "lt", "<", "rb", ")", ".", "all", "(", "axis", "=", "2", ")", "\n", "area_a", "=", "np", ".", "prod", "(", "a", "[", ":", ",", "2", ":", "]", "-", "a", "[", ":", ",", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "area_b", "=", "np", ".", "prod", "(", "b", "[", ":", ",", "2", ":", "]", "-", "b", "[", ":", ",", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "return", "area_i", "/", "(", "area_a", "[", ":", ",", "np", ".", "newaxis", "]", "+", "area_b", "-", "area_i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.match": [[83, 133], ["box_utils.jaccard", "jaccard.max", "jaccard.max", "best_truth_idx.squeeze_", "best_truth_overlap.squeeze_", "best_prior_idx.squeeze_", "best_prior_overlap.squeeze_", "best_truth_overlap.index_fill_", "range", "box_utils.encode", "box_utils.point_form", "best_prior_idx.size"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.jaccard", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.encode", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.point_form"], ["", "def", "match", "(", "threshold", ",", "truths", ",", "priors", ",", "variances", ",", "labels", ",", "loc_t", ",", "conf_t", ",", "obj_t", ",", "idx", ",", "overlap", "=", "None", ")", ":", "\n", "    ", "\"\"\"Match each prior box with the ground truth box of the highest jaccard\n    overlap, encode the bounding boxes, then return the matched indices\n    corresponding to both confidence and location preds.\n    Args:\n        threshold: (float) The overlap threshold used when mathing boxes.\n        truths: (tensor) Ground truth boxes, Shape: [num_obj, num_priors].\n        priors: (tensor) Prior boxes from priorbox layers, Shape: [n_priors,4].\n        variances: (tensor) Variances corresponding to each prior coord,\n            Shape: [num_priors, 4].\n        labels: (tensor) All the class labels for the image, Shape: [num_obj].\n        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.\n        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds.\n        idx: (int) current batch index\n    Return:\n        The matched indices corresponding to 1)location and 2)confidence preds.\n    \"\"\"", "\n", "# # ensure that groundtruth boxes with pos labels get priority during match", "\n", "# labels, indeces = torch.sort(labels)", "\n", "# truths = truths[indeces]", "\n", "# jaccard index", "\n", "overlaps", "=", "jaccard", "(", "\n", "truths", ",", "# point_form", "\n", "point_form", "(", "priors", ")", "\n", ")", "\n", "# (Bipartite Matching)", "\n", "# [num_objects,1] best prior for each ground truth", "\n", "best_prior_overlap", ",", "best_prior_idx", "=", "overlaps", ".", "max", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "# [1,num_priors] best ground truth for each prior", "\n", "best_truth_overlap", ",", "best_truth_idx", "=", "overlaps", ".", "max", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "best_truth_idx", ".", "squeeze_", "(", "0", ")", "\n", "best_truth_overlap", ".", "squeeze_", "(", "0", ")", "\n", "best_prior_idx", ".", "squeeze_", "(", "1", ")", "\n", "best_prior_overlap", ".", "squeeze_", "(", "1", ")", "\n", "if", "overlap", "is", "not", "None", ":", "\n", "        ", "overlap", "[", "idx", "]", "=", "best_truth_overlap", "\n", "", "best_truth_overlap", ".", "index_fill_", "(", "0", ",", "best_prior_idx", ",", "2", ")", "# ensure best prior", "\n", "# TODO refactor: index  best_prior_idx with long tensor", "\n", "# ensure every gt matches with its prior of max overlap", "\n", "for", "j", "in", "range", "(", "best_prior_idx", ".", "size", "(", "0", ")", ")", ":", "\n", "        ", "best_truth_idx", "[", "best_prior_idx", "[", "j", "]", "]", "=", "j", "\n", "", "matches", "=", "truths", "[", "best_truth_idx", "]", "# truths[obj_num, 4], matches[num_priors,4]", "\n", "conf", "=", "labels", "[", "best_truth_idx", "]", "# labels[num_priors]", "\n", "conf", "[", "best_truth_overlap", "<", "threshold", ",", "0", "]", "=", "0", "# label as background", "\n", "conf", "[", "best_truth_overlap", "<", "threshold", ",", "1", "]", "=", "1", "# set the weight for bg as 1", "\n", "loc", "=", "encode", "(", "matches", ",", "priors", ",", "variances", ")", "\n", "obj", "=", "conf", "[", ":", ",", "0", "]", "!=", "0", "\n", "loc_t", "[", "idx", "]", "=", "loc", "# [num_priors,4] encoded offsets to learn", "\n", "conf_t", "[", "idx", "]", "=", "conf", "# [num_priors, 2] top class label and corresponding weight (mixup) for each prior", "\n", "obj_t", "[", "idx", "]", "=", "obj", "# [num_priors] object or not label", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.encode": [[135, 157], ["torch.cat", "torch.log"], "function", ["None"], ["", "def", "encode", "(", "matched", ",", "priors", ",", "variances", ")", ":", "\n", "    ", "\"\"\"Encode the variances from the priorbox layers into the ground truth boxes\n    we have matched (based on jaccard overlap) with the prior boxes.\n    Args:\n        matched: (tensor) Coords of ground truth for each prior in point-form\n            Shape: [num_priors, 4].\n        priors: (tensor) Prior boxes in center-offset form\n            Shape: [num_priors,4].\n        variances: (list[float]) Variances of priorboxes\n    Return:\n        encoded boxes (tensor), Shape: [num_priors, 4]\n    \"\"\"", "\n", "\n", "# dist b/t match center and prior's center", "\n", "g_cxcy", "=", "(", "matched", "[", ":", ",", ":", "2", "]", "+", "matched", "[", ":", ",", "2", ":", "]", ")", "/", "2", "-", "priors", "[", ":", ",", ":", "2", "]", "\n", "# encode variance", "\n", "g_cxcy", "/=", "(", "variances", "[", "0", "]", "*", "priors", "[", ":", ",", "2", ":", "]", ")", "\n", "# match wh / prior wh", "\n", "g_wh", "=", "(", "matched", "[", ":", ",", "2", ":", "]", "-", "matched", "[", ":", ",", ":", "2", "]", ")", "/", "priors", "[", ":", ",", "2", ":", "]", "\n", "g_wh", "=", "torch", ".", "log", "(", "g_wh", ")", "/", "variances", "[", "1", "]", "\n", "# return target for smooth_l1_loss", "\n", "return", "torch", ".", "cat", "(", "[", "g_cxcy", ",", "g_wh", "]", ",", "1", ")", "# [num_priors,4]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.encode_multi": [[159, 182], ["g_cxcy.div_", "torch.cat", "torch.log"], "function", ["None"], ["", "def", "encode_multi", "(", "matched", ",", "priors", ",", "offsets", ",", "variances", ")", ":", "\n", "    ", "\"\"\"Encode the variances from the priorbox layers into the ground truth boxes\n    we have matched (based on jaccard overlap) with the prior boxes.\n    Args:\n        matched: (tensor) Coords of ground truth for each prior in point-form\n            Shape: [num_priors, 4].\n        priors: (tensor) Prior boxes in center-offset form\n            Shape: [num_priors,4].\n        variances: (list[float]) Variances of priorboxes\n    Return:\n        encoded boxes (tensor), Shape: [num_priors, 4]\n    \"\"\"", "\n", "\n", "# dist b/t match center and prior's center", "\n", "g_cxcy", "=", "(", "matched", "[", ":", ",", ":", "2", "]", "+", "matched", "[", ":", ",", "2", ":", "]", ")", "/", "2", "-", "priors", "[", ":", ",", ":", "2", "]", "-", "offsets", "[", ":", ",", ":", "2", "]", "\n", "# encode variance", "\n", "#g_cxcy /= (variances[0] * priors[:, 2:])", "\n", "g_cxcy", ".", "div_", "(", "variances", "[", "0", "]", "*", "offsets", "[", ":", ",", "2", ":", "]", ")", "\n", "# match wh / prior wh", "\n", "g_wh", "=", "(", "matched", "[", ":", ",", "2", ":", "]", "-", "matched", "[", ":", ",", ":", "2", "]", ")", "/", "priors", "[", ":", ",", "2", ":", "]", "\n", "g_wh", "=", "torch", ".", "log", "(", "g_wh", ")", "/", "variances", "[", "1", "]", "\n", "# return target for smooth_l1_loss", "\n", "return", "torch", ".", "cat", "(", "[", "g_cxcy", ",", "g_wh", "]", ",", "1", ")", "# [num_priors,4]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.decode": [[184, 203], ["torch.cat", "torch.exp"], "function", ["None"], ["", "def", "decode", "(", "loc", ",", "priors", ",", "variances", ")", ":", "\n", "    ", "\"\"\"Decode locations from predictions using priors to undo\n    the encoding we did for offset regression at train time.\n    Args:\n        loc (tensor): location predictions for loc layers,\n            Shape: [num_priors,4]\n        priors (tensor): Prior boxes in center-offset form.\n            Shape: [num_priors,4].\n        variances: (list[float]) Variances of priorboxes\n    Return:\n        decoded bounding box predictions\n    \"\"\"", "\n", "\n", "boxes", "=", "torch", ".", "cat", "(", "(", "\n", "priors", "[", ":", ",", ":", "2", "]", "+", "loc", "[", ":", ",", ":", "2", "]", "*", "variances", "[", "0", "]", "*", "priors", "[", ":", ",", "2", ":", "]", ",", "\n", "priors", "[", ":", ",", "2", ":", "]", "*", "torch", ".", "exp", "(", "loc", "[", ":", ",", "2", ":", "]", "*", "variances", "[", "1", "]", ")", ")", ",", "1", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "-=", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", "# \u5de6\u4e0a\u89d2\u7684\u5750\u6807,percent\u5f62\u5f0f", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "# \u5de6\u4e0a\u89d2\u52a0(w,h),percent\u5f62\u5f0f", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.decode_multi": [[204, 223], ["torch.cat", "torch.exp"], "function", ["None"], ["", "def", "decode_multi", "(", "loc", ",", "priors", ",", "offsets", ",", "variances", ")", ":", "\n", "    ", "\"\"\"Decode locations from predictions using priors to undo\n    the encoding we did for offset regression at train time.\n    Args:\n        loc (tensor): location predictions for loc layers,\n            Shape: [num_priors,4]\n        priors (tensor): Prior boxes in center-offset form.\n            Shape: [num_priors,4].\n        variances: (list[float]) Variances of priorboxes\n    Return:\n        decoded bounding box predictions\n    \"\"\"", "\n", "\n", "boxes", "=", "torch", ".", "cat", "(", "(", "\n", "priors", "[", ":", ",", ":", "2", "]", "+", "offsets", "[", ":", ",", ":", "2", "]", "+", "loc", "[", ":", ",", ":", "2", "]", "*", "variances", "[", "0", "]", "*", "offsets", "[", ":", ",", "2", ":", "]", ",", "\n", "priors", "[", ":", ",", "2", ":", "]", "*", "torch", ".", "exp", "(", "loc", "[", ":", ",", "2", ":", "]", "*", "variances", "[", "1", "]", ")", ")", ",", "1", ")", "\n", "boxes", "[", ":", ",", ":", "2", "]", "-=", "boxes", "[", ":", ",", "2", ":", "]", "/", "2", "\n", "boxes", "[", ":", ",", "2", ":", "]", "+=", "boxes", "[", ":", ",", ":", "2", "]", "\n", "return", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.log_sum_exp": [[224, 233], ["x.data.max", "torch.log", "torch.sum", "torch.exp"], "function", ["None"], ["", "def", "log_sum_exp", "(", "x", ")", ":", "\n", "    ", "\"\"\"Utility function for computing log_sum_exp while determining\n    This will be used to determine unaveraged confidence loss across\n    all examples in a batch.\n    Args:\n        x (Variable(tensor)): conf_preds from conf layers\n    \"\"\"", "\n", "x_max", "=", "x", ".", "data", ".", "max", "(", ")", "\n", "return", "torch", ".", "log", "(", "torch", ".", "sum", "(", "torch", ".", "exp", "(", "x", "-", "x_max", ")", ",", "1", ",", "keepdim", "=", "True", ")", ")", "+", "x_max", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.nms": [[238, 303], ["torch.Tensor().fill_().long", "torch.mul", "scores.sort", "boxes.new", "boxes.new", "boxes.new", "boxes.new", "boxes.new", "boxes.new", "boxes.numel", "idx.numel", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp.resize_as_", "torch.clamp.resize_as_", "torch.clamp", "torch.clamp", "torch.index_select", "torch.Tensor().fill_", "idx.size", "IoU.le", "torch.Tensor", "scores.size"], "function", ["None"], ["", "def", "nms", "(", "boxes", ",", "scores", ",", "overlap", "=", "0.5", ",", "top_k", "=", "200", ")", ":", "\n", "    ", "\"\"\"Apply non-maximum suppression at test time to avoid detecting too many\n    overlapping bounding boxes for a given object.\n    Args:\n        boxes: (tensor) The location preds for the img, Shape: [num_priors,4].\n        scores: (tensor) The class predscores for the img, Shape:[num_priors].\n        overlap: (float) The overlap thresh for suppressing unnecessary boxes.\n        top_k: (int) The Maximum number of box preds to consider.\n    Return:\n        The indices of the kept boxes with respect to num_priors.\n    \"\"\"", "\n", "\n", "keep", "=", "torch", ".", "Tensor", "(", "scores", ".", "size", "(", "0", ")", ")", ".", "fill_", "(", "0", ")", ".", "long", "(", ")", "\n", "if", "boxes", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "keep", "\n", "", "x1", "=", "boxes", "[", ":", ",", "0", "]", "\n", "y1", "=", "boxes", "[", ":", ",", "1", "]", "\n", "x2", "=", "boxes", "[", ":", ",", "2", "]", "\n", "y2", "=", "boxes", "[", ":", ",", "3", "]", "\n", "area", "=", "torch", ".", "mul", "(", "x2", "-", "x1", ",", "y2", "-", "y1", ")", "\n", "v", ",", "idx", "=", "scores", ".", "sort", "(", "0", ")", "# sort in ascending order", "\n", "# I = I[v >= 0.01]", "\n", "idx", "=", "idx", "[", "-", "top_k", ":", "]", "# indices of the top-k largest vals", "\n", "xx1", "=", "boxes", ".", "new", "(", ")", "\n", "yy1", "=", "boxes", ".", "new", "(", ")", "\n", "xx2", "=", "boxes", ".", "new", "(", ")", "\n", "yy2", "=", "boxes", ".", "new", "(", ")", "\n", "w", "=", "boxes", ".", "new", "(", ")", "\n", "h", "=", "boxes", ".", "new", "(", ")", "\n", "\n", "# keep = torch.Tensor()", "\n", "count", "=", "0", "\n", "while", "idx", ".", "numel", "(", ")", ">", "0", ":", "\n", "        ", "i", "=", "idx", "[", "-", "1", "]", "# index of current largest val", "\n", "# keep.append(i)", "\n", "keep", "[", "count", "]", "=", "i", "\n", "count", "+=", "1", "\n", "if", "idx", ".", "size", "(", "0", ")", "==", "1", ":", "\n", "            ", "break", "\n", "", "idx", "=", "idx", "[", ":", "-", "1", "]", "# remove kept element from view", "\n", "# load bboxes of next highest vals", "\n", "torch", ".", "index_select", "(", "x1", ",", "0", ",", "idx", ",", "out", "=", "xx1", ")", "\n", "torch", ".", "index_select", "(", "y1", ",", "0", ",", "idx", ",", "out", "=", "yy1", ")", "\n", "torch", ".", "index_select", "(", "x2", ",", "0", ",", "idx", ",", "out", "=", "xx2", ")", "\n", "torch", ".", "index_select", "(", "y2", ",", "0", ",", "idx", ",", "out", "=", "yy2", ")", "\n", "# store element-wise max with next highest score", "\n", "xx1", "=", "torch", ".", "clamp", "(", "xx1", ",", "min", "=", "x1", "[", "i", "]", ")", "\n", "yy1", "=", "torch", ".", "clamp", "(", "yy1", ",", "min", "=", "y1", "[", "i", "]", ")", "\n", "xx2", "=", "torch", ".", "clamp", "(", "xx2", ",", "max", "=", "x2", "[", "i", "]", ")", "\n", "yy2", "=", "torch", ".", "clamp", "(", "yy2", ",", "max", "=", "y2", "[", "i", "]", ")", "\n", "w", ".", "resize_as_", "(", "xx2", ")", "\n", "h", ".", "resize_as_", "(", "yy2", ")", "\n", "w", "=", "xx2", "-", "xx1", "\n", "h", "=", "yy2", "-", "yy1", "\n", "# check sizes of xx1 and xx2.. after each iteration", "\n", "w", "=", "torch", ".", "clamp", "(", "w", ",", "min", "=", "0.0", ")", "\n", "h", "=", "torch", ".", "clamp", "(", "h", ",", "min", "=", "0.0", ")", "\n", "inter", "=", "w", "*", "h", "\n", "# IoU = i / (area(a) + area(b) - i)", "\n", "rem_areas", "=", "torch", ".", "index_select", "(", "area", ",", "0", ",", "idx", ")", "# load remaining areas)", "\n", "union", "=", "(", "rem_areas", "-", "inter", ")", "+", "area", "[", "i", "]", "\n", "IoU", "=", "inter", "/", "union", "# store result in iou", "\n", "# keep only elements with an IoU <= overlap", "\n", "idx", "=", "idx", "[", "IoU", ".", "le", "(", "overlap", ")", "]", "\n", "", "return", "keep", ",", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.TrainingSampler.__init__": [[20, 35], ["int", "numpy.random.randint"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ":", "int", ",", "shuffle", ":", "bool", "=", "True", ",", "seed", ":", "Optional", "[", "int", "]", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            size (int): the total number of data of the underlying dataset to sample from\n            shuffle (bool): whether to shuffle the indices or not\n            seed (int): the initial seed of the shuffle. Must be the same\n                across all workers. If None, will use a random seed shared\n                among workers (require synchronization among all workers).\n        \"\"\"", "\n", "self", ".", "_size", "=", "size", "\n", "assert", "size", ">", "0", "\n", "self", ".", "_shuffle", "=", "shuffle", "\n", "if", "seed", "is", "None", ":", "\n", "            ", "seed", "=", "np", ".", "random", ".", "randint", "(", "2", "**", "31", ")", "\n", "", "self", ".", "_seed", "=", "int", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.TrainingSampler.__iter__": [[36, 38], ["sampler.TrainingSampler._infinite_indices"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.TrainingSampler._infinite_indices"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "yield", "from", "self", ".", "_infinite_indices", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.TrainingSampler._infinite_indices": [[39, 47], ["torch.Generator", "torch.Generator.manual_seed", "torch.randperm", "torch.arange"], "methods", ["None"], ["", "def", "_infinite_indices", "(", "self", ")", ":", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "_seed", ")", "\n", "while", "True", ":", "\n", "            ", "if", "self", ".", "_shuffle", ":", "\n", "                ", "yield", "from", "torch", ".", "randperm", "(", "self", ".", "_size", ")", "\n", "", "else", ":", "\n", "                ", "yield", "from", "torch", ".", "arange", "(", "self", ".", "_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.EpisodicBatchSampler.__init__": [[50, 55], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "n_classes", ",", "n_way", ",", "n_episodes", ",", "phase", "=", "'train'", ")", ":", "\n", "        ", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "n_way", "=", "n_way", "\n", "self", ".", "n_episodes", "=", "n_episodes", "# 100", "\n", "self", ".", "phase", "=", "phase", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.EpisodicBatchSampler.__len__": [[56, 58], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_episodes", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.sampler.EpisodicBatchSampler.__iter__": [[59, 65], ["range", "[].tolist", "[].tolist", "torch.randperm", "torch.arange"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "n_episodes", ")", ":", "\n", "            ", "if", "self", ".", "phase", "==", "'train'", ":", "\n", "                ", "yield", "torch", ".", "randperm", "(", "self", ".", "n_classes", ")", "[", ":", "self", ".", "n_way", "]", ".", "tolist", "(", ")", "\n", "", "else", ":", "\n", "                ", "yield", "torch", ".", "arange", "(", "self", ".", "n_classes", ")", "[", ":", "self", ".", "n_way", "]", ".", "tolist", "(", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.nms_wrapper.nms": [[23, 32], ["nms.gpu_nms.gpu_nms", "nms.cpu_nms.cpu_nms"], "function", ["None"], ["def", "nms", "(", "dets", ",", "thresh", ",", "force_cpu", "=", "False", ")", ":", "\n", "    ", "\"\"\"Dispatch to either CPU or GPU NMS implementations.\"\"\"", "\n", "\n", "if", "dets", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "", "if", "force_cpu", ":", "\n", "#return cpu_soft_nms(dets, thresh, method = 0)", "\n", "        ", "return", "cpu_nms", "(", "dets", ",", "thresh", ")", "\n", "", "return", "gpu_nms", "(", "dets", ",", "thresh", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.__init__": [[21, 47], ["isinstance", "copy.copy", "logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "model", ":", "nn", ".", "Module", ",", "\n", "save_dir", ":", "str", "=", "\"\"", ",", "\n", "*", ",", "\n", "save_to_disk", ":", "bool", "=", "True", ",", "\n", "**", "checkpointables", ":", "object", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            model (nn.Module): model.\n            save_dir (str): a directory to save and find checkpoints.\n            save_to_disk (bool): if True, save checkpoint to disk, otherwise\n                disable saving for this checkpointer.\n            checkpointables (object): any checkpointable objects, i.e., objects\n                that have the `state_dict()` and `load_state_dict()` method. For\n                example, it can be used like\n                `Checkpointer(model, \"dir\", optimizer=optimizer)`.\n        \"\"\"", "\n", "if", "isinstance", "(", "model", ",", "(", "DistributedDataParallel", ",", "DataParallel", ")", ")", ":", "\n", "            ", "model", "=", "model", ".", "module", "\n", "", "self", ".", "model", "=", "model", "\n", "self", ".", "checkpointables", "=", "copy", ".", "copy", "(", "checkpointables", ")", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "'Context-Transformer.'", "+", "__name__", ")", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "save_to_disk", "=", "save_to_disk", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.save": [[48, 72], ["dict", "checkpointer.Checkpointer.model.state_dict", "checkpointer.Checkpointer.checkpointables.items", "dict.update", "os.path.join", "checkpointer.Checkpointer.logger.info", "checkpointer.Checkpointer.tag_last_checkpoint", "obj.state_dict", "os.path.basename", "open", "torch.save", "torch.save", "torch.save", "torch.save"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.update", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.tag_last_checkpoint", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save"], ["", "def", "save", "(", "self", ",", "name", ":", "str", ",", "**", "kwargs", ":", "dict", ")", ":", "\n", "        ", "\"\"\"\n        Dump model and checkpointables to a file.\n\n        Args:\n            name (str): name of the file.\n            kwargs (dict): extra arbitrary data to save.\n        \"\"\"", "\n", "if", "not", "self", ".", "save_dir", "or", "not", "self", ".", "save_to_disk", ":", "\n", "            ", "return", "\n", "\n", "", "data", "=", "dict", "(", ")", "\n", "data", "[", "\"model\"", "]", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "for", "key", ",", "obj", "in", "self", ".", "checkpointables", ".", "items", "(", ")", ":", "\n", "            ", "data", "[", "key", "]", "=", "obj", ".", "state_dict", "(", ")", "\n", "", "data", ".", "update", "(", "kwargs", ")", "\n", "\n", "basename", "=", "\"{}.pth\"", ".", "format", "(", "name", ")", "\n", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "basename", ")", "\n", "assert", "os", ".", "path", ".", "basename", "(", "save_file", ")", "==", "basename", ",", "basename", "\n", "self", ".", "logger", ".", "info", "(", "\"Saving checkpoint to {}\"", ".", "format", "(", "save_file", ")", ")", "\n", "with", "open", "(", "save_file", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "torch", ".", "save", "(", "data", ",", "f", ")", "\n", "", "self", ".", "tag_last_checkpoint", "(", "basename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.load": [[73, 104], ["checkpointer.Checkpointer.logger.info", "checkpointer.Checkpointer._load_file", "checkpointer.Checkpointer._load_model", "checkpointer.Checkpointer.checkpointables.items", "checkpointer.Checkpointer.logger.info", "checkpointer.Checkpointer.logger.info", "obj.load_state_dict", "checkpointer.Checkpointer.pop"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer._load_file", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer._load_model", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info"], ["", "def", "load", "(", "self", ",", "path", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Load from the given checkpoint. When path points to network file, this\n        function has to be called on all ranks.\n\n        Args:\n            path (str): path or url to the checkpoint. If empty, will not load\n                anything.\n        Returns:\n            dict:\n                extra data loaded from the checkpoint that has not been\n                processed. For example, those saved with\n                :meth:`.save(**extra_data)`.\n        \"\"\"", "\n", "if", "not", "path", ":", "\n", "# no checkpoint provided", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\n", "\"No checkpoint found. Initializing model from scratch\"", "\n", ")", "\n", "return", "{", "}", "\n", "", "self", ".", "logger", ".", "info", "(", "\"Loading checkpoint from {}\"", ".", "format", "(", "path", ")", ")", "\n", "\n", "checkpoint", "=", "self", ".", "_load_file", "(", "path", ")", "\n", "self", ".", "_load_model", "(", "checkpoint", ")", "\n", "for", "key", ",", "obj", "in", "self", ".", "checkpointables", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", "in", "checkpoint", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Loading {} from {}\"", ".", "format", "(", "key", ",", "path", ")", ")", "\n", "obj", ".", "load_state_dict", "(", "checkpoint", ".", "pop", "(", "key", ")", ")", "\n", "\n", "# return any further checkpoint data", "\n", "", "", "return", "checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.has_checkpoint": [[105, 112], ["os.path.join", "os.path.exists"], "methods", ["None"], ["", "def", "has_checkpoint", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            bool: whether a checkpoint exists in the target directory.\n        \"\"\"", "\n", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "return", "os", ".", "path", ".", "exists", "(", "save_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.get_checkpoint_file": [[113, 127], ["os.path.join", "os.path.join", "open", "f.read().strip", "f.read"], "methods", ["None"], ["", "def", "get_checkpoint_file", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            str: The latest checkpoint file in target directory.\n        \"\"\"", "\n", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "try", ":", "\n", "            ", "with", "open", "(", "save_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "                ", "last_saved", "=", "f", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", "", "except", "IOError", ":", "\n", "# if file doesn't exist, maybe because it has just been", "\n", "# deleted by a separate process", "\n", "            ", "return", "\"\"", "\n", "", "return", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "last_saved", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.resume_or_load": [[128, 144], ["checkpointer.Checkpointer.load", "checkpointer.Checkpointer.has_checkpoint", "checkpointer.Checkpointer.get_checkpoint_file"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.has_checkpoint", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.get_checkpoint_file"], ["", "def", "resume_or_load", "(", "self", ",", "path", ":", "str", ",", "*", ",", "resume", ":", "bool", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        If `resume` is True, this method attempts to resume from the last\n        checkpoint, if exists. Otherwise, load checkpoint from the given path.\n        This is useful when restarting an interrupted training job.\n\n        Args:\n            path (str): path to the checkpoint.\n            resume (bool): if True, resume from the last checkpoint if it exists.\n\n        Returns:\n            same as :meth:`load`.\n        \"\"\"", "\n", "if", "resume", "and", "self", ".", "has_checkpoint", "(", ")", ":", "\n", "            ", "path", "=", "self", ".", "get_checkpoint_file", "(", ")", "\n", "", "return", "self", ".", "load", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer.tag_last_checkpoint": [[145, 155], ["os.path.join", "open", "f.write"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.CommonMetricPrinter.write"], ["", "def", "tag_last_checkpoint", "(", "self", ",", "last_filename_basename", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Tag the last checkpoint.\n\n        Args:\n            last_filename_basename (str): the basename of the last filename.\n        \"\"\"", "\n", "save_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "\"last_checkpoint\"", ")", "\n", "with", "open", "(", "save_file", ",", "\"w\"", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "last_filename_basename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer._load_file": [[156, 168], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.device", "torch.device", "torch.device", "torch.device"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load"], ["", "", "def", "_load_file", "(", "self", ",", "f", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Load a checkpoint file. Can be overwritten by subclasses to support\n        different formats.\n        Args:\n            f (str): a locally mounted file path.\n        Returns:\n            dict: with keys \"model\" and optionally others that are saved by\n                the checkpointer dict[\"model\"] must be a dict which maps strings\n                to torch.Tensor or numpy arrays.\n        \"\"\"", "\n", "return", "torch", ".", "load", "(", "f", ",", "map_location", "=", "torch", ".", "device", "(", "\"cpu\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer._load_model": [[169, 207], ["checkpoint.pop", "checkpointer._strip_prefix_if_present", "checkpointer.Checkpointer.model.state_dict", "list", "checkpointer.Checkpointer.model.load_state_dict", "checkpoint.pop.keys", "checkpointer.Checkpointer.logger.info", "checkpointer.Checkpointer.logger.info", "tuple", "tuple", "checkpointer.get_missing_parameters_message", "checkpointer.get_unexpected_parameters_message", "checkpointer.Checkpointer.logger.warning", "checkpoint.pop.pop"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._strip_prefix_if_present", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.get_missing_parameters_message", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.get_unexpected_parameters_message"], ["", "def", "_load_model", "(", "self", ",", "checkpoint", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Load weights from a checkpoint.\n        Args:\n            checkpoint (Any): checkpoint contains the weights.\n        \"\"\"", "\n", "checkpoint_state_dict", "=", "checkpoint", ".", "pop", "(", "\"model\"", ")", "\n", "\n", "# if the state_dict comes from a model that was wrapped in a", "\n", "# DataParallel or DistributedDataParallel during serialization,", "\n", "# remove the \"module\" prefix before performing the matching.", "\n", "_strip_prefix_if_present", "(", "checkpoint_state_dict", ",", "\"module.\"", ")", "\n", "\n", "# work around https://github.com/pytorch/pytorch/issues/24139", "\n", "model_state_dict", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "for", "k", "in", "list", "(", "checkpoint_state_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "k", "in", "model_state_dict", ":", "\n", "                ", "shape_model", "=", "tuple", "(", "model_state_dict", "[", "k", "]", ".", "shape", ")", "\n", "shape_checkpoint", "=", "tuple", "(", "checkpoint_state_dict", "[", "k", "]", ".", "shape", ")", "\n", "if", "shape_model", "!=", "shape_checkpoint", ":", "\n", "                    ", "self", ".", "logger", ".", "warning", "(", "\n", "\"'{}' has shape {} in the checkpoint but {} in the \"", "\n", "\"model! Skipped.\"", ".", "format", "(", "\n", "k", ",", "shape_checkpoint", ",", "shape_model", "\n", ")", "\n", ")", "\n", "checkpoint_state_dict", ".", "pop", "(", "k", ")", "\n", "\n", "", "", "", "incompatible", "=", "self", ".", "model", ".", "load_state_dict", "(", "\n", "checkpoint_state_dict", ",", "strict", "=", "False", "\n", ")", "\n", "if", "incompatible", ".", "missing_keys", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\n", "get_missing_parameters_message", "(", "incompatible", ".", "missing_keys", ")", "\n", ")", "\n", "", "if", "incompatible", ".", "unexpected_keys", ":", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\n", "get_unexpected_parameters_message", "(", "incompatible", ".", "unexpected_keys", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.__init__": [[216, 224], ["checkpointer.Checkpointer.__init__"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["def", "__init__", "(", "self", ",", "model", ",", "args", ",", "*", ",", "save_to_disk", "=", "True", ",", "**", "checkpointables", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "model", ",", "\n", "args", ".", "save_folder", ",", "\n", "save_to_disk", "=", "save_to_disk", ",", "\n", "**", "checkpointables", ",", "\n", ")", "\n", "self", ".", "phase", "=", "args", ".", "phase", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer._load_file": [[225, 245], ["filename.endswith", "checkpointer.Checkpointer._load_file", "open", "pickle.load", "checkpointer.DetectionCheckpointer.logger.info", "pickle.load.items", "k.endswith"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer._load_file", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info"], ["", "def", "_load_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "if", "filename", ".", "endswith", "(", "\".pkl\"", ")", ":", "\n", "            ", "with", "open", "(", "filename", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "if", "\"model\"", "in", "data", "and", "\"__author__\"", "in", "data", ":", "\n", "# file is in Detectron2 model zoo format", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Reading a file from '{}'\"", ".", "format", "(", "data", "[", "\"__author__\"", "]", ")", ")", "\n", "return", "data", "\n", "", "else", ":", "\n", "# assume file is from Caffe2 / Detectron1 model zoo", "\n", "                ", "if", "\"blobs\"", "in", "data", ":", "\n", "# Detection models have \"blobs\", but ImageNet models don't", "\n", "                    ", "data", "=", "data", "[", "\"blobs\"", "]", "\n", "", "data", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "if", "not", "k", ".", "endswith", "(", "\"_momentum\"", ")", "}", "\n", "return", "{", "\"model\"", ":", "data", ",", "\"__author__\"", ":", "\"Caffe2\"", ",", "\"matching_heuristics\"", ":", "True", "}", "\n", "\n", "", "", "loaded", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "# load native pth checkpoint", "\n", "if", "\"model\"", "not", "in", "loaded", ":", "\n", "            ", "loaded", "=", "{", "\"model\"", ":", "loaded", "}", "\n", "", "return", "loaded", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load": [[259, 298], ["checkpointer.DetectionCheckpointer.logger.info", "checkpointer.DetectionCheckpointer._load_file", "checkpointer.DetectionCheckpointer._load_model", "checkpointer.DetectionCheckpointer.checkpointables.items", "checkpointer.DetectionCheckpointer.logger.info", "collections.OrderedDict", "checkpointer.DetectionCheckpointer.pop", "checkpointer.DetectionCheckpointer.logger.info", "obj.load_state_dict", "checkpointer.DetectionCheckpointer.pop", "checkpoint[].items"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer._load_file", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.Checkpointer._load_model", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info"], ["", "def", "load", "(", "self", ",", "path", ":", "str", ")", ":", "\n", "        ", "\"\"\"\n        Load from the given checkpoint. When path points to network file, this\n        function has to be called on all ranks.\n\n        Args:\n            path (str): path or url to the checkpoint. If empty, will not load\n                anything.\n        Returns:\n            dict:\n                extra data loaded from the checkpoint that has not been\n                processed. For example, those saved with\n                :meth:`.save(**extra_data)`.\n        \"\"\"", "\n", "if", "not", "path", ":", "\n", "# no checkpoint provided", "\n", "            ", "self", ".", "logger", ".", "info", "(", "\n", "\"No checkpoint found. Initializing model from scratch\"", "\n", ")", "\n", "return", "{", "}", "\n", "", "self", ".", "logger", ".", "info", "(", "\"Loading checkpoint from {}\"", ".", "format", "(", "path", ")", ")", "\n", "\n", "checkpoint", "=", "self", ".", "_load_file", "(", "path", ")", "\n", "if", "'vgg16_reducedfc'", "in", "path", ":", "\n", "            ", "checkpoint", "[", "'model'", "]", "=", "OrderedDict", "(", "{", "'base.'", "+", "key", ":", "value", "for", "key", ",", "value", "in", "checkpoint", "[", "'model'", "]", ".", "items", "(", ")", "}", ")", "\n", "", "self", ".", "_load_model", "(", "checkpoint", ")", "\n", "if", "self", ".", "phase", "==", "2", ":", "\n", "            ", "self", ".", "checkpointables", "=", "{", "}", "\n", "try", ":", "\n", "                ", "checkpoint", ".", "pop", "(", "'iteration'", ")", "\n", "", "except", "KeyError", ":", "\n", "                ", "pass", "\n", "", "", "for", "key", ",", "obj", "in", "self", ".", "checkpointables", ".", "items", "(", ")", ":", "\n", "            ", "if", "key", "in", "checkpoint", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Loading {} from {}\"", ".", "format", "(", "key", ",", "path", ")", ")", "\n", "obj", ".", "load_state_dict", "(", "checkpoint", ".", "pop", "(", "key", ")", ")", "\n", "\n", "# return any further checkpoint data", "\n", "", "", "return", "checkpoint", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.__init__": [[307, 319], ["int"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "checkpointer", ":", "Any", ",", "period", ":", "int", ",", "max_iter", ":", "int", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            checkpointer (Any): the checkpointer object used to save\n            checkpoints.\n            period (int): the period to save checkpoint.\n            max_iter (int): maximum number of iterations. When it is reached,\n                a checkpoint named \"model_final\" will be saved.\n        \"\"\"", "\n", "self", ".", "checkpointer", "=", "checkpointer", "\n", "self", ".", "period", "=", "int", "(", "period", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.step": [[320, 338], ["int", "additional_state.update", "checkpointer.PeriodicCheckpointer.checkpointer.save", "checkpointer.PeriodicCheckpointer.checkpointer.save"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.update", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save"], ["", "def", "step", "(", "self", ",", "iteration", ":", "int", ",", "**", "kwargs", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Perform the appropriate action at the given iteration.\n\n        Args:\n            iteration (int): the current iteration, ranged in [0, max_iter-1].\n            kwargs (Any): extra data to save, same as in\n                :meth:`Checkpointer.save`.\n        \"\"\"", "\n", "iteration", "=", "int", "(", "iteration", ")", "\n", "additional_state", "=", "{", "\"iteration\"", ":", "iteration", "}", "\n", "additional_state", ".", "update", "(", "kwargs", ")", "\n", "if", "(", "iteration", "+", "1", ")", "%", "self", ".", "period", "==", "0", ":", "\n", "            ", "self", ".", "checkpointer", ".", "save", "(", "\n", "\"model_{:07d}\"", ".", "format", "(", "iteration", ")", ",", "**", "additional_state", "\n", ")", "\n", "", "if", "iteration", ">=", "self", ".", "max_iter", "-", "1", ":", "\n", "            ", "self", ".", "checkpointer", ".", "save", "(", "\"model_final\"", ",", "**", "additional_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save": [[339, 350], ["checkpointer.PeriodicCheckpointer.checkpointer.save"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.PeriodicCheckpointer.save"], ["", "", "def", "save", "(", "self", ",", "name", ":", "str", ",", "**", "kwargs", ":", "Any", ")", ":", "\n", "        ", "\"\"\"\n        Same argument as :meth:`Checkpointer.save`.\n        Use this method to manually save checkpoints outside the schedule.\n\n        Args:\n            name (str): file name.\n            kwargs (Any): extra data to save, same as in\n                :meth:`Checkpointer.save`.\n        \"\"\"", "\n", "self", ".", "checkpointer", ".", "save", "(", "name", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.get_missing_parameters_message": [[352, 367], ["checkpointer._group_checkpoint_keys", "termcolor.colored", "_group_checkpoint_keys.items", "checkpointer._group_to_str"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._group_checkpoint_keys", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._group_to_str"], ["", "", "def", "get_missing_parameters_message", "(", "keys", ":", "list", ")", ":", "\n", "    ", "\"\"\"\n    Get a logging-friendly message to report parameter names (keys) that are in\n    the model but not found in a checkpoint.\n    Args:\n        keys (list[str]): List of keys that were not found in the checkpoint.\n    Returns:\n        str: message.\n    \"\"\"", "\n", "groups", "=", "_group_checkpoint_keys", "(", "keys", ")", "\n", "msg", "=", "\"Some model parameters are not in the checkpoint:\\n\"", "\n", "msg", "+=", "\"\\n\"", ".", "join", "(", "\n", "\"  \"", "+", "colored", "(", "k", "+", "_group_to_str", "(", "v", ")", ",", "\"blue\"", ")", "for", "k", ",", "v", "in", "groups", ".", "items", "(", ")", "\n", ")", "\n", "return", "msg", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.get_unexpected_parameters_message": [[369, 385], ["checkpointer._group_checkpoint_keys", "termcolor.colored", "_group_checkpoint_keys.items", "checkpointer._group_to_str"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._group_checkpoint_keys", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._group_to_str"], ["", "def", "get_unexpected_parameters_message", "(", "keys", ":", "list", ")", ":", "\n", "    ", "\"\"\"\n    Get a logging-friendly message to report parameter names (keys) that are in\n    the checkpoint but not found in the model.\n    Args:\n        keys (list[str]): List of keys that were not found in the model.\n    Returns:\n        str: message.\n    \"\"\"", "\n", "groups", "=", "_group_checkpoint_keys", "(", "keys", ")", "\n", "msg", "=", "\"The checkpoint contains parameters not used by the model:\\n\"", "\n", "msg", "+=", "\"\\n\"", ".", "join", "(", "\n", "\"  \"", "+", "colored", "(", "k", "+", "_group_to_str", "(", "v", ")", ",", "\"magenta\"", ")", "\n", "for", "k", ",", "v", "in", "groups", ".", "items", "(", ")", "\n", ")", "\n", "return", "msg", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._strip_prefix_if_present": [[387, 418], ["sorted", "state_dict.keys", "all", "state_dict.pop", "list", "metadata.keys", "metadata.pop", "len", "len", "key.startswith", "len", "len"], "function", ["None"], ["", "def", "_strip_prefix_if_present", "(", "state_dict", ":", "collections", ".", "OrderedDict", ",", "prefix", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Strip the prefix in metadata, if any.\n    Args:\n        state_dict (OrderedDict): a state-dict to be loaded to the model.\n        prefix (str): prefix.\n    \"\"\"", "\n", "keys", "=", "sorted", "(", "state_dict", ".", "keys", "(", ")", ")", "\n", "if", "not", "all", "(", "len", "(", "key", ")", "==", "0", "or", "key", ".", "startswith", "(", "prefix", ")", "for", "key", "in", "keys", ")", ":", "\n", "        ", "return", "\n", "\n", "", "for", "key", "in", "keys", ":", "\n", "        ", "newkey", "=", "key", "[", "len", "(", "prefix", ")", ":", "]", "\n", "state_dict", "[", "newkey", "]", "=", "state_dict", ".", "pop", "(", "key", ")", "\n", "\n", "# also strip the prefix in metadata, if any..", "\n", "", "try", ":", "\n", "        ", "metadata", "=", "state_dict", ".", "_metadata", "\n", "", "except", "AttributeError", ":", "\n", "        ", "pass", "\n", "", "else", ":", "\n", "        ", "for", "key", "in", "list", "(", "metadata", ".", "keys", "(", ")", ")", ":", "\n", "# for the metadata dict, the key can be:", "\n", "# '': for the DDP module, which we want to remove.", "\n", "# 'module': for the actual model.", "\n", "# 'module.xx.xx': for the rest.", "\n", "\n", "            ", "if", "len", "(", "key", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "", "newkey", "=", "key", "[", "len", "(", "prefix", ")", ":", "]", "\n", "metadata", "[", "newkey", "]", "=", "metadata", ".", "pop", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._group_checkpoint_keys": [[420, 439], ["collections.defaultdict", "key.rfind", "groups[].extend"], "function", ["None"], ["", "", "", "def", "_group_checkpoint_keys", "(", "keys", ":", "list", ")", ":", "\n", "    ", "\"\"\"\n    Group keys based on common prefixes. A prefix is the string up to the final\n    \".\" in each key.\n    Args:\n        keys (list[str]): list of parameter names, i.e. keys in the model\n            checkpoint dict.\n    Returns:\n        dict[list]: keys with common prefixes are grouped into lists.\n    \"\"\"", "\n", "groups", "=", "defaultdict", "(", "list", ")", "\n", "for", "key", "in", "keys", ":", "\n", "        ", "pos", "=", "key", ".", "rfind", "(", "\".\"", ")", "\n", "if", "pos", ">=", "0", ":", "\n", "            ", "head", ",", "tail", "=", "key", "[", ":", "pos", "]", ",", "[", "key", "[", "pos", "+", "1", ":", "]", "]", "\n", "", "else", ":", "\n", "            ", "head", ",", "tail", "=", "key", ",", "[", "]", "\n", "", "groups", "[", "head", "]", ".", "extend", "(", "tail", ")", "\n", "", "return", "groups", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer._group_to_str": [[441, 456], ["len", "len"], "function", ["None"], ["", "def", "_group_to_str", "(", "group", ":", "list", ")", ":", "\n", "    ", "\"\"\"\n    Format a group of parameter name suffixes into a loggable string.\n    Args:\n        group (list[str]): list of parameter name suffixes.\n    Returns:\n        str: formated string.\n    \"\"\"", "\n", "if", "len", "(", "group", ")", "==", "0", ":", "\n", "        ", "return", "\"\"", "\n", "\n", "", "if", "len", "(", "group", ")", "==", "1", ":", "\n", "        ", "return", "\".\"", "+", "group", "[", "0", "]", "\n", "\n", "", "return", "\".{\"", "+", "\", \"", ".", "join", "(", "group", ")", "+", "\"}\"", "\n", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventWriter.write": [[32, 34], ["None"], "methods", ["None"], ["def", "write", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventWriter.close": [[35, 37], ["None"], "methods", ["None"], ["", "def", "close", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.JSONWriter.__init__": [[85, 94], ["open"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "json_file", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            json_file (str): path to the json file. New data will be appended if the file exists.\n            window_size (int): the window size of median smoothing for the scalars whose\n                `smoothing_hint` are True.\n        \"\"\"", "\n", "self", ".", "_file_handle", "=", "open", "(", "json_file", ",", "\"a\"", ")", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.JSONWriter.write": [[95, 105], ["event.get_event_storage", "to_save.update", "event.JSONWriter._file_handle.write", "event.JSONWriter._file_handle.flush", "get_event_storage.latest_with_smoothing_hint", "os.fsync", "json.dumps", "event.JSONWriter._file_handle.fileno"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.get_event_storage", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.update", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.CommonMetricPrinter.write", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "to_save", "=", "{", "\"iteration\"", ":", "storage", ".", "iter", "}", "\n", "to_save", ".", "update", "(", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ")", "\n", "self", ".", "_file_handle", ".", "write", "(", "json", ".", "dumps", "(", "to_save", ",", "sort_keys", "=", "True", ")", "+", "\"\\n\"", ")", "\n", "self", ".", "_file_handle", ".", "flush", "(", ")", "\n", "try", ":", "\n", "            ", "os", ".", "fsync", "(", "self", ".", "_file_handle", ".", "fileno", "(", ")", ")", "\n", "", "except", "AttributeError", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.JSONWriter.close": [[106, 108], ["event.JSONWriter._file_handle.close"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.TensorboardXWriter.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "_file_handle", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.TensorboardXWriter.__init__": [[115, 127], ["SummaryWriter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "log_dir", ":", "str", ",", "window_size", ":", "int", "=", "20", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            log_dir (str): the directory to save the output events\n            window_size (int): the scalars will be median-smoothed by this window size\n\n            kwargs: other arguments passed to `torch.utils.tensorboard.SummaryWriter(...)`\n        \"\"\"", "\n", "self", ".", "_window_size", "=", "window_size", "\n", "from", "torch", ".", "utils", ".", "tensorboard", "import", "SummaryWriter", "\n", "\n", "self", ".", "_writer", "=", "SummaryWriter", "(", "log_dir", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.TensorboardXWriter.write": [[128, 137], ["event.get_event_storage", "get_event_storage.latest_with_smoothing_hint().items", "event.TensorboardXWriter._writer.add_scalar", "len", "get_event_storage.clear_images", "get_event_storage.latest_with_smoothing_hint", "event.TensorboardXWriter._writer.add_image"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.get_event_storage", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.clear_images", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.latest_with_smoothing_hint"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "for", "k", ",", "v", "in", "storage", ".", "latest_with_smoothing_hint", "(", "self", ".", "_window_size", ")", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "_writer", ".", "add_scalar", "(", "k", ",", "v", ",", "storage", ".", "iter", ")", "\n", "\n", "", "if", "len", "(", "storage", ".", "vis_data", ")", ">=", "1", ":", "\n", "            ", "for", "img_name", ",", "img", ",", "step_num", "in", "storage", ".", "vis_data", ":", "\n", "                ", "self", ".", "_writer", ".", "add_image", "(", "img_name", ",", "img", ",", "step_num", ")", "\n", "", "storage", ".", "clear_images", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.TensorboardXWriter.close": [[138, 141], ["hasattr", "event.TensorboardXWriter._writer.close"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.TensorboardXWriter.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "\"_writer\"", ")", ":", "# doesn't exist when the code fails at import", "\n", "            ", "self", ".", "_writer", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.CommonMetricPrinter.__init__": [[151, 159], ["logging.getLogger"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_iter", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            max_iter (int): the maximum number of iterations to train.\n                Used to compute ETA.\n        \"\"\"", "\n", "self", ".", "logger", "=", "logging", ".", "getLogger", "(", "'Context-Transformer.'", "+", "__name__", ")", "\n", "self", ".", "_max_iter", "=", "max_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.CommonMetricPrinter.write": [[160, 205], ["event.get_event_storage", "torch.cuda.is_available", "event.CommonMetricPrinter.logger.info", "get_event_storage.history().avg", "get_event_storage.history().global_avg", "get_event_storage.put_scalar", "str", "get_event_storage.history().median", "datetime.timedelta", "get_event_storage.history().latest", "get_event_storage.history", "get_event_storage.history", "torch.cuda.max_memory_allocated", "get_event_storage.history", "int", "get_event_storage.history", "v.median", "get_event_storage.histories().items", "get_event_storage.histories"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.get_event_storage", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.avg", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.global_avg", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_scalar", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.median", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.latest", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.history", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.history", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.history", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.history", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.median", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.histories"], ["", "def", "write", "(", "self", ")", ":", "\n", "        ", "storage", "=", "get_event_storage", "(", ")", "\n", "iteration", "=", "storage", ".", "iter", "\n", "\n", "data_time", ",", "time", "=", "None", ",", "None", "\n", "eta_string", "=", "\"N/A\"", "\n", "try", ":", "\n", "            ", "data_time", "=", "storage", ".", "history", "(", "\"data_time\"", ")", ".", "avg", "(", "20", ")", "\n", "time", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "global_avg", "(", ")", "\n", "eta_seconds", "=", "storage", ".", "history", "(", "\"time\"", ")", ".", "median", "(", "1000", ")", "*", "(", "self", ".", "_max_iter", "-", "iteration", ")", "\n", "storage", ".", "put_scalar", "(", "\"eta_seconds\"", ",", "eta_seconds", ",", "smoothing_hint", "=", "False", ")", "\n", "eta_string", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_seconds", ")", ")", ")", "\n", "", "except", "KeyError", ":", "# they may not exist in the first few iterations (due to warmup)", "\n", "            ", "pass", "\n", "\n", "", "try", ":", "\n", "            ", "lr", "=", "\"{:.6f}\"", ".", "format", "(", "storage", ".", "history", "(", "\"lr\"", ")", ".", "latest", "(", ")", ")", "\n", "", "except", "KeyError", ":", "\n", "            ", "lr", "=", "\"N/A\"", "\n", "\n", "", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "max_mem_mb", "=", "torch", ".", "cuda", ".", "max_memory_allocated", "(", ")", "/", "1024.0", "/", "1024.0", "\n", "", "else", ":", "\n", "            ", "max_mem_mb", "=", "None", "\n", "\n", "# NOTE: max_mem is parsed by grep in \"dev/parse_results.sh\"", "\n", "", "self", ".", "logger", ".", "info", "(", "\n", "\"\"\"\\\neta: {eta}  iter: {iter}  {losses}  \\\n{time}  {data_time}  \\\nlr: {lr}  {memory}\\\n\"\"\"", ".", "format", "(", "\n", "eta", "=", "eta_string", ",", "\n", "iter", "=", "iteration", ",", "\n", "losses", "=", "\"  \"", ".", "join", "(", "\n", "[", "\n", "\"{}: {:.3f}\"", ".", "format", "(", "k", ",", "v", ".", "median", "(", "20", ")", ")", "\n", "for", "k", ",", "v", "in", "storage", ".", "histories", "(", ")", ".", "items", "(", ")", "\n", "if", "\"loss\"", "in", "k", "\n", "]", "\n", ")", ",", "\n", "time", "=", "\"time: {:.4f}\"", ".", "format", "(", "time", ")", "if", "time", "is", "not", "None", "else", "\"\"", ",", "\n", "data_time", "=", "\"data_time: {:.4f}\"", ".", "format", "(", "data_time", ")", "if", "data_time", "is", "not", "None", "else", "\"\"", ",", "\n", "lr", "=", "lr", ",", "\n", "memory", "=", "\"max_mem: {:.0f}M\"", ".", "format", "(", "max_mem_mb", ")", "if", "max_mem_mb", "is", "not", "None", "else", "\"\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.__init__": [[216, 227], ["collections.defaultdict"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "start_iter", "=", "0", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter (int): the iteration number to start with\n        \"\"\"", "\n", "self", ".", "_history", "=", "defaultdict", "(", "HistoryBuffer", ")", "\n", "self", ".", "_smoothing_hints", "=", "{", "}", "\n", "self", ".", "_latest_scalars", "=", "{", "}", "\n", "self", ".", "_iter", "=", "start_iter", "\n", "self", ".", "_current_prefix", "=", "\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_image": [[228, 241], ["event.EventStorage._vis_data.append"], "methods", ["None"], ["", "def", "put_image", "(", "self", ",", "img_name", ",", "img_tensor", ")", ":", "\n", "        ", "\"\"\"\n        Add an `img_tensor` to the `_vis_data` associated with `img_name`.\n\n        Args:\n            img_name (str): The name of the image to put into tensorboard.\n            img_tensor (torch.Tensor or numpy.array): An `uint8` or `float`\n                Tensor of shape `[channel, height, width]` where `channel` is\n                3. The image format should be RGB. The elements in img_tensor\n                can either have values in [0, 1] (float32) or [0, 255] (uint8).\n                The `img_tensor` will be visualized in tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", ".", "append", "(", "(", "img_name", ",", "img_tensor", ",", "self", ".", "_iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.clear_images": [[242, 248], ["None"], "methods", ["None"], ["", "def", "clear_images", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Delete all the stored images for visualization. This should be called\n        after images are written to tensorboard.\n        \"\"\"", "\n", "self", ".", "_vis_data", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_scalar": [[249, 275], ["float", "history.update", "event.EventStorage._smoothing_hints.get"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.update"], ["", "def", "put_scalar", "(", "self", ",", "name", ",", "value", ",", "smoothing_hint", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the hint\n                and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be smoothed to\n                provide any useful signal.\n        \"\"\"", "\n", "name", "=", "self", ".", "_current_prefix", "+", "name", "\n", "history", "=", "self", ".", "_history", "[", "name", "]", "\n", "value", "=", "float", "(", "value", ")", "\n", "history", ".", "update", "(", "value", ",", "self", ".", "_iter", ")", "\n", "self", ".", "_latest_scalars", "[", "name", "]", "=", "value", "\n", "\n", "existing_hint", "=", "self", ".", "_smoothing_hints", ".", "get", "(", "name", ")", "\n", "if", "existing_hint", "is", "not", "None", ":", "\n", "            ", "assert", "(", "\n", "existing_hint", "==", "smoothing_hint", "\n", ")", ",", "\"Scalar {} was put with a different smoothing_hint!\"", ".", "format", "(", "name", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "_smoothing_hints", "[", "name", "]", "=", "smoothing_hint", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_scalars": [[276, 286], ["kwargs.items", "event.EventStorage.put_scalar"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.put_scalar"], ["", "", "def", "put_scalars", "(", "self", ",", "*", ",", "smoothing_hint", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Put multiple scalars from keyword arguments.\n\n        Examples:\n\n            storage.put_scalars(loss=my_loss, accuracy=my_accuracy, smoothing_hint=True)\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "put_scalar", "(", "k", ",", "v", ",", "smoothing_hint", "=", "smoothing_hint", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.history": [[287, 296], ["event.EventStorage._history.get", "KeyError"], "methods", ["None"], ["", "", "def", "history", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            HistoryBuffer: the scalar history for name\n        \"\"\"", "\n", "ret", "=", "self", ".", "_history", ".", "get", "(", "name", ",", "None", ")", "\n", "if", "ret", "is", "None", ":", "\n", "            ", "raise", "KeyError", "(", "\"No history metric available for {}!\"", ".", "format", "(", "name", ")", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.histories": [[297, 303], ["None"], "methods", ["None"], ["", "def", "histories", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> HistoryBuffer]: the HistoryBuffer for all scalars\n        \"\"\"", "\n", "return", "self", ".", "_history", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.latest": [[304, 310], ["None"], "methods", ["None"], ["", "def", "latest", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> number]: the scalars that's added in the current iteration.\n        \"\"\"", "\n", "return", "self", ".", "_latest_scalars", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.latest_with_smoothing_hint": [[311, 324], ["event.EventStorage._latest_scalars.items", "event.EventStorage._history[].median"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.median"], ["", "def", "latest_with_smoothing_hint", "(", "self", ",", "window_size", "=", "20", ")", ":", "\n", "        ", "\"\"\"\n        Similar to :meth:`latest`, but the returned values\n        are either the un-smoothed original latest value,\n        or a median of the given window_size,\n        depend on whether the smoothing_hint is True.\n\n        This provides a default behavior that other writers can use.\n        \"\"\"", "\n", "result", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "self", ".", "_latest_scalars", ".", "items", "(", ")", ":", "\n", "            ", "result", "[", "k", "]", "=", "self", ".", "_history", "[", "k", "]", ".", "median", "(", "window_size", ")", "if", "self", ".", "_smoothing_hints", "[", "k", "]", "else", "v", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.smoothing_hints": [[325, 332], ["None"], "methods", ["None"], ["", "def", "smoothing_hints", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            dict[name -> bool]: the user-provided hint on whether the scalar\n                is noisy and needs smoothing.\n        \"\"\"", "\n", "return", "self", ".", "_smoothing_hints", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.step": [[333, 342], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        User should call this function at the beginning of each iteration, to\n        notify the storage of the start of a new iteration.\n        The storage will then be able to associate the new data with the\n        correct iteration number.\n        \"\"\"", "\n", "self", ".", "_iter", "+=", "1", "\n", "self", ".", "_latest_scalars", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.vis_data": [[343, 346], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "vis_data", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_vis_data", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.iter": [[347, 350], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iter", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.iteration": [[351, 355], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "iteration", "(", "self", ")", ":", "\n", "# for backward compatibility", "\n", "        ", "return", "self", ".", "_iter", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.__enter__": [[356, 359], ["_CURRENT_STORAGE_STACK.append"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "_CURRENT_STORAGE_STACK", ".", "append", "(", "self", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.__exit__": [[360, 363], ["_CURRENT_STORAGE_STACK.pop"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "exc_type", ",", "exc_val", ",", "exc_tb", ")", ":", "\n", "        ", "assert", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "==", "self", "\n", "_CURRENT_STORAGE_STACK", ".", "pop", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.name_scope": [[364, 375], ["name.rstrip"], "methods", ["None"], ["", "@", "contextmanager", "\n", "def", "name_scope", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Yields:\n            A context within which all the events added to this storage\n            will be prefixed by the name scope.\n        \"\"\"", "\n", "old_prefix", "=", "self", ".", "_current_prefix", "\n", "self", ".", "_current_prefix", "=", "name", ".", "rstrip", "(", "\"/\"", ")", "+", "\"/\"", "\n", "yield", "\n", "self", ".", "_current_prefix", "=", "old_prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.__init__": [[383, 394], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_length", ":", "int", "=", "1000000", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            max_length: maximal number of values that can be stored in the\n                buffer. When the capacity of the buffer is exhausted, old\n                values will be removed.\n        \"\"\"", "\n", "self", ".", "_max_length", ":", "int", "=", "max_length", "\n", "self", ".", "_data", ":", "List", "[", "Tuple", "[", "float", ",", "float", "]", "]", "=", "[", "]", "# (value, iteration) pairs", "\n", "self", ".", "_count", ":", "int", "=", "0", "\n", "self", ".", "_global_avg", ":", "float", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.update": [[395, 409], ["event.HistoryBuffer._data.append", "len", "event.HistoryBuffer._data.pop"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "value", ":", "float", ",", "iteration", ":", "float", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Add a new scalar value produced at certain iteration. If the length\n        of the buffer exceeds self._max_length, the oldest element will be\n        removed from the buffer.\n        \"\"\"", "\n", "if", "iteration", "is", "None", ":", "\n", "            ", "iteration", "=", "self", ".", "_count", "\n", "", "if", "len", "(", "self", ".", "_data", ")", "==", "self", ".", "_max_length", ":", "\n", "            ", "self", ".", "_data", ".", "pop", "(", "0", ")", "\n", "", "self", ".", "_data", ".", "append", "(", "(", "value", ",", "iteration", ")", ")", "\n", "\n", "self", ".", "_count", "+=", "1", "\n", "self", ".", "_global_avg", "+=", "(", "value", "-", "self", ".", "_global_avg", ")", "/", "self", ".", "_count", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.latest": [[410, 415], ["None"], "methods", ["None"], ["", "def", "latest", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the latest scalar value added to the buffer.\n        \"\"\"", "\n", "return", "self", ".", "_data", "[", "-", "1", "]", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.median": [[416, 421], ["numpy.median"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.median"], ["", "def", "median", "(", "self", ",", "window_size", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Return the median of the latest `window_size` values in the buffer.\n        \"\"\"", "\n", "return", "np", ".", "median", "(", "[", "x", "[", "0", "]", "for", "x", "in", "self", ".", "_data", "[", "-", "window_size", ":", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.avg": [[422, 427], ["numpy.mean"], "methods", ["None"], ["", "def", "avg", "(", "self", ",", "window_size", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Return the mean of the latest `window_size` values in the buffer.\n        \"\"\"", "\n", "return", "np", ".", "mean", "(", "[", "x", "[", "0", "]", "for", "x", "in", "self", ".", "_data", "[", "-", "window_size", ":", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.global_avg": [[428, 434], ["None"], "methods", ["None"], ["", "def", "global_avg", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the mean of all the elements in the buffer. Note that this\n        includes those getting removed due to limited buffer storage.\n        \"\"\"", "\n", "return", "self", ".", "_global_avg", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.values": [[435, 441], ["None"], "methods", ["None"], ["", "def", "values", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            list[(number, iteration)]: content of the current buffer.\n        \"\"\"", "\n", "return", "self", ".", "_data", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.get_event_storage": [[15, 25], ["len"], "function", ["None"], ["def", "get_event_storage", "(", ")", ":", "\n", "    ", "\"\"\"\n    Returns:\n        The :class:`EventStorage` object that's currently being used.\n        Throws an error if no :class`EventStorage` is currently enabled.\n    \"\"\"", "\n", "assert", "len", "(", "\n", "_CURRENT_STORAGE_STACK", "\n", ")", ",", "\"get_event_storage() has to be called inside a 'with EventStorage(...)' context!\"", "\n", "return", "_CURRENT_STORAGE_STACK", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.__init__": [[71, 89], ["dict", "dict", "dict", "dict", "collections.defaultdict", "collections.defaultdict", "print", "time.time", "json.load", "print", "coco.COCO.createIndex", "open", "type", "type", "time.time"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.createIndex"], ["    ", "def", "__init__", "(", "self", ",", "annotation_file", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Constructor of Microsoft COCO helper class for reading and visualizing annotations.\n        :param annotation_file (str): location of annotation file\n        :param image_folder (str): location to the folder that hosts images.\n        :return:\n        \"\"\"", "\n", "# load dataset", "\n", "self", ".", "dataset", ",", "self", ".", "anns", ",", "self", ".", "cats", ",", "self", ".", "imgs", "=", "dict", "(", ")", ",", "dict", "(", ")", ",", "dict", "(", ")", ",", "dict", "(", ")", "\n", "self", ".", "imgToAnns", ",", "self", ".", "catToImgs", "=", "defaultdict", "(", "list", ")", ",", "defaultdict", "(", "list", ")", "\n", "if", "annotation_file", "is", "not", "None", ":", "\n", "            ", "print", "(", "'loading annotations into memory...'", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "dataset", "=", "json", ".", "load", "(", "open", "(", "annotation_file", ",", "'r'", ")", ")", "\n", "assert", "type", "(", "dataset", ")", "==", "dict", ",", "'annotation file format {} not supported'", ".", "format", "(", "type", "(", "dataset", ")", ")", "\n", "print", "(", "'Done (t={:0.2f}s)'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "tic", ")", ")", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "createIndex", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.createIndex": [[90, 120], ["print", "print", "collections.defaultdict", "collections.defaultdict", "imgToAnns[].append", "catToImgs[].append"], "methods", ["None"], ["", "", "def", "createIndex", "(", "self", ")", ":", "\n", "# create index", "\n", "        ", "print", "(", "'creating index...'", ")", "\n", "anns", ",", "cats", ",", "imgs", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "imgToAnns", ",", "catToImgs", "=", "defaultdict", "(", "list", ")", ",", "defaultdict", "(", "list", ")", "\n", "if", "'annotations'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", ":", "\n", "                ", "imgToAnns", "[", "ann", "[", "'image_id'", "]", "]", ".", "append", "(", "ann", ")", "\n", "anns", "[", "ann", "[", "'id'", "]", "]", "=", "ann", "\n", "\n", "", "", "if", "'images'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "img", "in", "self", ".", "dataset", "[", "'images'", "]", ":", "\n", "                ", "imgs", "[", "img", "[", "'id'", "]", "]", "=", "img", "\n", "\n", "", "", "if", "'categories'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "cat", "in", "self", ".", "dataset", "[", "'categories'", "]", ":", "\n", "                ", "cats", "[", "cat", "[", "'id'", "]", "]", "=", "cat", "\n", "\n", "", "", "if", "'annotations'", "in", "self", ".", "dataset", "and", "'categories'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", ":", "\n", "                ", "catToImgs", "[", "ann", "[", "'category_id'", "]", "]", ".", "append", "(", "ann", "[", "'image_id'", "]", ")", "\n", "\n", "", "", "print", "(", "'index created!'", ")", "\n", "\n", "# create class members", "\n", "self", ".", "anns", "=", "anns", "\n", "self", ".", "imgToAnns", "=", "imgToAnns", "\n", "self", ".", "catToImgs", "=", "catToImgs", "\n", "self", ".", "imgs", "=", "imgs", "\n", "self", ".", "cats", "=", "cats", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.info": [[121, 128], ["coco.COCO.dataset[].items", "print"], "methods", ["None"], ["", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Print information about the annotation file.\n        :return:\n        \"\"\"", "\n", "for", "key", ",", "value", "in", "self", ".", "dataset", "[", "'info'", "]", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'{}: {}'", ".", "format", "(", "key", ",", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getAnnIds": [[129, 156], ["coco._isArrayLike", "coco._isArrayLike", "len", "len", "len", "list", "len", "itertools.chain.from_iterable", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike"], ["", "", "def", "getAnnIds", "(", "self", ",", "imgIds", "=", "[", "]", ",", "catIds", "=", "[", "]", ",", "areaRng", "=", "[", "]", ",", "iscrowd", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Get ann ids that satisfy given filter conditions. default skips that filter\n        :param imgIds  (int array)     : get anns for given imgs\n               catIds  (int array)     : get anns for given cats\n               areaRng (float array)   : get anns for given area range (e.g. [0 inf])\n               iscrowd (boolean)       : get anns for given crowd label (False or True)\n        :return: ids (int array)       : integer array of ann ids\n        \"\"\"", "\n", "imgIds", "=", "imgIds", "if", "_isArrayLike", "(", "imgIds", ")", "else", "[", "imgIds", "]", "\n", "catIds", "=", "catIds", "if", "_isArrayLike", "(", "catIds", ")", "else", "[", "catIds", "]", "\n", "\n", "if", "len", "(", "imgIds", ")", "==", "len", "(", "catIds", ")", "==", "len", "(", "areaRng", ")", "==", "0", ":", "\n", "            ", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "else", ":", "\n", "            ", "if", "not", "len", "(", "imgIds", ")", "==", "0", ":", "\n", "                ", "lists", "=", "[", "self", ".", "imgToAnns", "[", "imgId", "]", "for", "imgId", "in", "imgIds", "if", "imgId", "in", "self", ".", "imgToAnns", "]", "\n", "anns", "=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "lists", ")", ")", "\n", "", "else", ":", "\n", "                ", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "anns", "=", "anns", "if", "len", "(", "catIds", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'category_id'", "]", "in", "catIds", "]", "\n", "anns", "=", "anns", "if", "len", "(", "areaRng", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'area'", "]", ">", "areaRng", "[", "0", "]", "and", "ann", "[", "'area'", "]", "<", "areaRng", "[", "1", "]", "]", "\n", "", "if", "iscrowd", "is", "not", "None", ":", "\n", "            ", "ids", "=", "[", "ann", "[", "'id'", "]", "for", "ann", "in", "anns", "if", "ann", "[", "'iscrowd'", "]", "==", "iscrowd", "]", "\n", "", "else", ":", "\n", "            ", "ids", "=", "[", "ann", "[", "'id'", "]", "for", "ann", "in", "anns", "]", "\n", "", "return", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getCatIds": [[157, 178], ["coco._isArrayLike", "coco._isArrayLike", "coco._isArrayLike", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike"], ["", "def", "getCatIds", "(", "self", ",", "catNms", "=", "[", "]", ",", "supNms", "=", "[", "]", ",", "catIds", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        filtering parameters. default skips that filter.\n        :param catNms (str array)  : get cats for given cat names\n        :param supNms (str array)  : get cats for given supercategory names\n        :param catIds (int array)  : get cats for given cat ids\n        :return: ids (int array)   : integer array of cat ids\n        \"\"\"", "\n", "catNms", "=", "catNms", "if", "_isArrayLike", "(", "catNms", ")", "else", "[", "catNms", "]", "\n", "supNms", "=", "supNms", "if", "_isArrayLike", "(", "supNms", ")", "else", "[", "supNms", "]", "\n", "catIds", "=", "catIds", "if", "_isArrayLike", "(", "catIds", ")", "else", "[", "catIds", "]", "\n", "\n", "if", "len", "(", "catNms", ")", "==", "len", "(", "supNms", ")", "==", "len", "(", "catIds", ")", "==", "0", ":", "\n", "            ", "cats", "=", "self", ".", "dataset", "[", "'categories'", "]", "\n", "", "else", ":", "\n", "            ", "cats", "=", "self", ".", "dataset", "[", "'categories'", "]", "\n", "cats", "=", "cats", "if", "len", "(", "catNms", ")", "==", "0", "else", "[", "cat", "for", "cat", "in", "cats", "if", "cat", "[", "'name'", "]", "in", "catNms", "]", "\n", "cats", "=", "cats", "if", "len", "(", "supNms", ")", "==", "0", "else", "[", "cat", "for", "cat", "in", "cats", "if", "cat", "[", "'supercategory'", "]", "in", "supNms", "]", "\n", "cats", "=", "cats", "if", "len", "(", "catIds", ")", "==", "0", "else", "[", "cat", "for", "cat", "in", "cats", "if", "cat", "[", "'id'", "]", "in", "catIds", "]", "\n", "", "ids", "=", "[", "cat", "[", "'id'", "]", "for", "cat", "in", "cats", "]", "\n", "return", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getImgIds": [[179, 199], ["list", "coco._isArrayLike", "coco._isArrayLike", "len", "len", "coco.COCO.imgs.keys", "set", "enumerate", "set", "set", "len"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike"], ["", "def", "getImgIds", "(", "self", ",", "imgIds", "=", "[", "]", ",", "catIds", "=", "[", "]", ")", ":", "\n", "        ", "'''\n        Get img ids that satisfy given filter conditions.\n        :param imgIds (int array) : get imgs for given ids\n        :param catIds (int array) : get imgs with all given cats\n        :return: ids (int array)  : integer array of img ids\n        '''", "\n", "imgIds", "=", "imgIds", "if", "_isArrayLike", "(", "imgIds", ")", "else", "[", "imgIds", "]", "\n", "catIds", "=", "catIds", "if", "_isArrayLike", "(", "catIds", ")", "else", "[", "catIds", "]", "\n", "\n", "if", "len", "(", "imgIds", ")", "==", "len", "(", "catIds", ")", "==", "0", ":", "\n", "            ", "ids", "=", "self", ".", "imgs", ".", "keys", "(", ")", "\n", "", "else", ":", "\n", "            ", "ids", "=", "set", "(", "imgIds", ")", "\n", "for", "i", ",", "catId", "in", "enumerate", "(", "catIds", ")", ":", "\n", "                ", "if", "i", "==", "0", "and", "len", "(", "ids", ")", "==", "0", ":", "\n", "                    ", "ids", "=", "set", "(", "self", ".", "catToImgs", "[", "catId", "]", ")", "\n", "", "else", ":", "\n", "                    ", "ids", "&=", "set", "(", "self", ".", "catToImgs", "[", "catId", "]", ")", "\n", "", "", "", "return", "list", "(", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadAnns": [[200, 210], ["coco._isArrayLike", "type"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike"], ["", "def", "loadAnns", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        Load anns with the specified ids.\n        :param ids (int array)       : integer ids specifying anns\n        :return: anns (object array) : loaded ann objects\n        \"\"\"", "\n", "if", "_isArrayLike", "(", "ids", ")", ":", "\n", "            ", "return", "[", "self", ".", "anns", "[", "id", "]", "for", "id", "in", "ids", "]", "\n", "", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "            ", "return", "[", "self", ".", "anns", "[", "ids", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadCats": [[211, 221], ["coco._isArrayLike", "type"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike"], ["", "", "def", "loadCats", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        Load cats with the specified ids.\n        :param ids (int array)       : integer ids specifying cats\n        :return: cats (object array) : loaded cat objects\n        \"\"\"", "\n", "if", "_isArrayLike", "(", "ids", ")", ":", "\n", "            ", "return", "[", "self", ".", "cats", "[", "id", "]", "for", "id", "in", "ids", "]", "\n", "", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "            ", "return", "[", "self", ".", "cats", "[", "ids", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadImgs": [[222, 232], ["coco._isArrayLike", "type"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike"], ["", "", "def", "loadImgs", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        Load anns with the specified ids.\n        :param ids (int array)       : integer ids specifying img\n        :return: imgs (object array) : loaded img objects\n        \"\"\"", "\n", "if", "_isArrayLike", "(", "ids", ")", ":", "\n", "            ", "return", "[", "self", ".", "imgs", "[", "id", "]", "for", "id", "in", "ids", "]", "\n", "", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "            ", "return", "[", "self", ".", "imgs", "[", "ids", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.showAnns": [[233, 296], ["len", "matplotlib.gca", "matplotlib.gca.set_autoscale_on", "matplotlib.collections.PatchCollection", "matplotlib.gca.add_collection", "matplotlib.collections.PatchCollection", "matplotlib.gca.add_collection", "Exception", "numpy.array", "matplotlib.plot", "matplotlib.plot", "print", "type", "mask.decode", "numpy.ones", "range", "matplotlib.gca.imshow", "type", "numpy.array", "numpy.all", "numpy.array().reshape", "polygons.append", "color.append", "type", "mask.frPyObjects", "numpy.dstack", "matplotlib.plot", "matplotlib.patches.Polygon", "numpy.array", "numpy.random.random().tolist", "numpy.random.random", "numpy.array", "int", "coco.COCO.loadCats", "numpy.random.random", "len"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.decode", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadCats"], ["", "", "def", "showAnns", "(", "self", ",", "anns", ")", ":", "\n", "        ", "\"\"\"\n        Display the specified annotations.\n        :param anns (array of object): annotations to display\n        :return: None\n        \"\"\"", "\n", "if", "len", "(", "anns", ")", "==", "0", ":", "\n", "            ", "return", "0", "\n", "", "if", "'segmentation'", "in", "anns", "[", "0", "]", "or", "'keypoints'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "datasetType", "=", "'instances'", "\n", "", "elif", "'caption'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "datasetType", "=", "'captions'", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'datasetType not supported'", ")", "\n", "", "if", "datasetType", "==", "'instances'", ":", "\n", "            ", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "ax", ".", "set_autoscale_on", "(", "False", ")", "\n", "polygons", "=", "[", "]", "\n", "color", "=", "[", "]", "\n", "for", "ann", "in", "anns", ":", "\n", "                ", "c", "=", "(", "np", ".", "random", ".", "random", "(", "(", "1", ",", "3", ")", ")", "*", "0.6", "+", "0.4", ")", ".", "tolist", "(", ")", "[", "0", "]", "\n", "if", "'segmentation'", "in", "ann", ":", "\n", "                    ", "if", "type", "(", "ann", "[", "'segmentation'", "]", ")", "==", "list", ":", "\n", "# polygon", "\n", "                        ", "for", "seg", "in", "ann", "[", "'segmentation'", "]", ":", "\n", "                            ", "poly", "=", "np", ".", "array", "(", "seg", ")", ".", "reshape", "(", "(", "int", "(", "len", "(", "seg", ")", "/", "2", ")", ",", "2", ")", ")", "\n", "polygons", ".", "append", "(", "Polygon", "(", "poly", ")", ")", "\n", "color", ".", "append", "(", "c", ")", "\n", "", "", "else", ":", "\n", "# mask", "\n", "                        ", "t", "=", "self", ".", "imgs", "[", "ann", "[", "'image_id'", "]", "]", "\n", "if", "type", "(", "ann", "[", "'segmentation'", "]", "[", "'counts'", "]", ")", "==", "list", ":", "\n", "                            ", "rle", "=", "maskUtils", ".", "frPyObjects", "(", "[", "ann", "[", "'segmentation'", "]", "]", ",", "t", "[", "'height'", "]", ",", "t", "[", "'width'", "]", ")", "\n", "", "else", ":", "\n", "                            ", "rle", "=", "[", "ann", "[", "'segmentation'", "]", "]", "\n", "", "m", "=", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "img", "=", "np", ".", "ones", "(", "(", "m", ".", "shape", "[", "0", "]", ",", "m", ".", "shape", "[", "1", "]", ",", "3", ")", ")", "\n", "if", "ann", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "                            ", "color_mask", "=", "np", ".", "array", "(", "[", "2.0", ",", "166.0", ",", "101.0", "]", ")", "/", "255", "\n", "", "if", "ann", "[", "'iscrowd'", "]", "==", "0", ":", "\n", "                            ", "color_mask", "=", "np", ".", "random", ".", "random", "(", "(", "1", ",", "3", ")", ")", ".", "tolist", "(", ")", "[", "0", "]", "\n", "", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "                            ", "img", "[", ":", ",", ":", ",", "i", "]", "=", "color_mask", "[", "i", "]", "\n", "", "ax", ".", "imshow", "(", "np", ".", "dstack", "(", "(", "img", ",", "m", "*", "0.5", ")", ")", ")", "\n", "", "", "if", "'keypoints'", "in", "ann", "and", "type", "(", "ann", "[", "'keypoints'", "]", ")", "==", "list", ":", "\n", "# turn skeleton into zero-based index", "\n", "                    ", "sks", "=", "np", ".", "array", "(", "self", ".", "loadCats", "(", "ann", "[", "'category_id'", "]", ")", "[", "0", "]", "[", "'skeleton'", "]", ")", "-", "1", "\n", "kp", "=", "np", ".", "array", "(", "ann", "[", "'keypoints'", "]", ")", "\n", "x", "=", "kp", "[", "0", ":", ":", "3", "]", "\n", "y", "=", "kp", "[", "1", ":", ":", "3", "]", "\n", "v", "=", "kp", "[", "2", ":", ":", "3", "]", "\n", "for", "sk", "in", "sks", ":", "\n", "                        ", "if", "np", ".", "all", "(", "v", "[", "sk", "]", ">", "0", ")", ":", "\n", "                            ", "plt", ".", "plot", "(", "x", "[", "sk", "]", ",", "y", "[", "sk", "]", ",", "linewidth", "=", "3", ",", "color", "=", "c", ")", "\n", "", "", "plt", ".", "plot", "(", "x", "[", "v", ">", "0", "]", ",", "y", "[", "v", ">", "0", "]", ",", "'o'", ",", "markersize", "=", "8", ",", "markerfacecolor", "=", "c", ",", "markeredgecolor", "=", "'k'", ",", "markeredgewidth", "=", "2", ")", "\n", "plt", ".", "plot", "(", "x", "[", "v", ">", "1", "]", ",", "y", "[", "v", ">", "1", "]", ",", "'o'", ",", "markersize", "=", "8", ",", "markerfacecolor", "=", "c", ",", "markeredgecolor", "=", "c", ",", "markeredgewidth", "=", "2", ")", "\n", "", "", "p", "=", "PatchCollection", "(", "polygons", ",", "facecolor", "=", "color", ",", "linewidths", "=", "0", ",", "alpha", "=", "0.4", ")", "\n", "ax", ".", "add_collection", "(", "p", ")", "\n", "p", "=", "PatchCollection", "(", "polygons", ",", "facecolor", "=", "'none'", ",", "edgecolors", "=", "color", ",", "linewidths", "=", "2", ")", "\n", "ax", ".", "add_collection", "(", "p", ")", "\n", "", "elif", "datasetType", "==", "'captions'", ":", "\n", "            ", "for", "ann", "in", "anns", ":", "\n", "                ", "print", "(", "ann", "[", "'caption'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadRes": [[297, 357], ["coco.COCO", "print", "time.time", "print", "coco.COCO.createIndex", "json.load", "type", "set", "enumerate", "type", "open", "type", "coco.COCO.loadNumpyAnnotations", "set", "set", "set", "set", "copy.deepcopy", "enumerate", "type", "coco.COCO.getImgIds", "copy.deepcopy", "enumerate", "time.time", "mask.area", "copy.deepcopy", "enumerate", "mask.toBbox", "numpy.min", "numpy.max", "numpy.min", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.createIndex", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadNumpyAnnotations", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getImgIds", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.area", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.toBbox"], ["", "", "", "def", "loadRes", "(", "self", ",", "resFile", ")", ":", "\n", "        ", "\"\"\"\n        Load result file and return a result api object.\n        :param   resFile (str)     : file name of result file\n        :return: res (obj)         : result api object\n        \"\"\"", "\n", "res", "=", "COCO", "(", ")", "\n", "res", ".", "dataset", "[", "'images'", "]", "=", "[", "img", "for", "img", "in", "self", ".", "dataset", "[", "'images'", "]", "]", "\n", "\n", "print", "(", "'Loading and preparing results...'", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "type", "(", "resFile", ")", "==", "str", "or", "(", "PYTHON_VERSION", "==", "2", "and", "type", "(", "resFile", ")", "==", "unicode", ")", ":", "\n", "            ", "anns", "=", "json", ".", "load", "(", "open", "(", "resFile", ")", ")", "\n", "", "elif", "type", "(", "resFile", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "anns", "=", "self", ".", "loadNumpyAnnotations", "(", "resFile", ")", "\n", "", "else", ":", "\n", "            ", "anns", "=", "resFile", "\n", "", "assert", "type", "(", "anns", ")", "==", "list", ",", "'results in not an array of objects'", "\n", "annsImgIds", "=", "[", "ann", "[", "'image_id'", "]", "for", "ann", "in", "anns", "]", "\n", "assert", "set", "(", "annsImgIds", ")", "==", "(", "set", "(", "annsImgIds", ")", "&", "set", "(", "self", ".", "getImgIds", "(", ")", ")", ")", ",", "'Results do not correspond to current coco set'", "\n", "if", "'caption'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "imgIds", "=", "set", "(", "[", "img", "[", "'id'", "]", "for", "img", "in", "res", ".", "dataset", "[", "'images'", "]", "]", ")", "&", "set", "(", "[", "ann", "[", "'image_id'", "]", "for", "ann", "in", "anns", "]", ")", "\n", "res", ".", "dataset", "[", "'images'", "]", "=", "[", "img", "for", "img", "in", "res", ".", "dataset", "[", "'images'", "]", "if", "img", "[", "'id'", "]", "in", "imgIds", "]", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "                ", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "", "", "elif", "'bbox'", "in", "anns", "[", "0", "]", "and", "not", "anns", "[", "0", "]", "[", "'bbox'", "]", "==", "[", "]", ":", "\n", "            ", "res", ".", "dataset", "[", "'categories'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "dataset", "[", "'categories'", "]", ")", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "                ", "bb", "=", "ann", "[", "'bbox'", "]", "\n", "x1", ",", "x2", ",", "y1", ",", "y2", "=", "[", "bb", "[", "0", "]", ",", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", ",", "bb", "[", "1", "]", ",", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "]", "\n", "if", "not", "'segmentation'", "in", "ann", ":", "\n", "                    ", "ann", "[", "'segmentation'", "]", "=", "[", "[", "x1", ",", "y1", ",", "x1", ",", "y2", ",", "x2", ",", "y2", ",", "x2", ",", "y1", "]", "]", "\n", "", "ann", "[", "'area'", "]", "=", "bb", "[", "2", "]", "*", "bb", "[", "3", "]", "\n", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "ann", "[", "'iscrowd'", "]", "=", "0", "\n", "", "", "elif", "'segmentation'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "res", ".", "dataset", "[", "'categories'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "dataset", "[", "'categories'", "]", ")", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "# now only support compressed RLE format as segmentation results", "\n", "                ", "ann", "[", "'area'", "]", "=", "maskUtils", ".", "area", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "if", "not", "'bbox'", "in", "ann", ":", "\n", "                    ", "ann", "[", "'bbox'", "]", "=", "maskUtils", ".", "toBbox", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "ann", "[", "'iscrowd'", "]", "=", "0", "\n", "", "", "elif", "'keypoints'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "res", ".", "dataset", "[", "'categories'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "dataset", "[", "'categories'", "]", ")", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "                ", "s", "=", "ann", "[", "'keypoints'", "]", "\n", "x", "=", "s", "[", "0", ":", ":", "3", "]", "\n", "y", "=", "s", "[", "1", ":", ":", "3", "]", "\n", "x0", ",", "x1", ",", "y0", ",", "y1", "=", "np", ".", "min", "(", "x", ")", ",", "np", ".", "max", "(", "x", ")", ",", "np", ".", "min", "(", "y", ")", ",", "np", ".", "max", "(", "y", ")", "\n", "ann", "[", "'area'", "]", "=", "(", "x1", "-", "x0", ")", "*", "(", "y1", "-", "y0", ")", "\n", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "ann", "[", "'bbox'", "]", "=", "[", "x0", ",", "y0", ",", "x1", "-", "x0", ",", "y1", "-", "y0", "]", "\n", "", "", "print", "(", "'DONE (t={:0.2f}s)'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "tic", ")", ")", "\n", "\n", "res", ".", "dataset", "[", "'annotations'", "]", "=", "anns", "\n", "res", ".", "createIndex", "(", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.download": [[358, 381], ["len", "enumerate", "print", "len", "coco.COCO.imgs.values", "coco.COCO.loadImgs", "os.path.exists", "os.makedirs", "time.time", "os.path.join", "print", "os.path.exists", "urlretrieve", "time.time"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.values", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadImgs"], ["", "def", "download", "(", "self", ",", "tarDir", "=", "None", ",", "imgIds", "=", "[", "]", ")", ":", "\n", "        ", "'''\n        Download COCO images from mscoco.org server.\n        :param tarDir (str): COCO results directory name\n               imgIds (list): images to be downloaded\n        :return:\n        '''", "\n", "if", "tarDir", "is", "None", ":", "\n", "            ", "print", "(", "'Please specify target directory'", ")", "\n", "return", "-", "1", "\n", "", "if", "len", "(", "imgIds", ")", "==", "0", ":", "\n", "            ", "imgs", "=", "self", ".", "imgs", ".", "values", "(", ")", "\n", "", "else", ":", "\n", "            ", "imgs", "=", "self", ".", "loadImgs", "(", "imgIds", ")", "\n", "", "N", "=", "len", "(", "imgs", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "tarDir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "tarDir", ")", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "            ", "tic", "=", "time", ".", "time", "(", ")", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "tarDir", ",", "img", "[", "'file_name'", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "fname", ")", ":", "\n", "                ", "urlretrieve", "(", "img", "[", "'coco_url'", "]", ",", "fname", ")", "\n", "", "print", "(", "'downloaded {}/{} images (t={:0.1f}s)'", ".", "format", "(", "i", ",", "N", ",", "time", ".", "time", "(", ")", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadNumpyAnnotations": [[382, 404], ["print", "print", "range", "type", "print", "int", "int"], "methods", ["None"], ["", "", "def", "loadNumpyAnnotations", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"\n        Convert result data from a numpy array [Nx7] where each row contains {imageID,x1,y1,w,h,score,class}\n        :param  data (numpy.ndarray)\n        :return: annotations (python nested list)\n        \"\"\"", "\n", "print", "(", "'Converting ndarray to lists...'", ")", "\n", "assert", "(", "type", "(", "data", ")", "==", "np", ".", "ndarray", ")", "\n", "print", "(", "data", ".", "shape", ")", "\n", "assert", "(", "data", ".", "shape", "[", "1", "]", "==", "7", ")", "\n", "N", "=", "data", ".", "shape", "[", "0", "]", "\n", "ann", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "if", "i", "%", "1000000", "==", "0", ":", "\n", "                ", "print", "(", "'{}/{}'", ".", "format", "(", "i", ",", "N", ")", ")", "\n", "", "ann", "+=", "[", "{", "\n", "'image_id'", ":", "int", "(", "data", "[", "i", ",", "0", "]", ")", ",", "\n", "'bbox'", ":", "[", "data", "[", "i", ",", "1", "]", ",", "data", "[", "i", ",", "2", "]", ",", "data", "[", "i", ",", "3", "]", ",", "data", "[", "i", ",", "4", "]", "]", ",", "\n", "'score'", ":", "data", "[", "i", ",", "5", "]", ",", "\n", "'category_id'", ":", "int", "(", "data", "[", "i", ",", "6", "]", ")", ",", "\n", "}", "]", "\n", "", "return", "ann", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.annToRLE": [[405, 425], ["type", "mask.frPyObjects", "mask.merge", "type", "mask.frPyObjects"], "methods", ["None"], ["", "def", "annToRLE", "(", "self", ",", "ann", ")", ":", "\n", "        ", "\"\"\"\n        Convert annotation which can be polygons, uncompressed RLE to RLE.\n        :return: binary mask (numpy 2D array)\n        \"\"\"", "\n", "t", "=", "self", ".", "imgs", "[", "ann", "[", "'image_id'", "]", "]", "\n", "h", ",", "w", "=", "t", "[", "'height'", "]", ",", "t", "[", "'width'", "]", "\n", "segm", "=", "ann", "[", "'segmentation'", "]", "\n", "if", "type", "(", "segm", ")", "==", "list", ":", "\n", "# polygon -- a single object might consist of multiple parts", "\n", "# we merge all parts into one mask rle code", "\n", "            ", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "segm", ",", "h", ",", "w", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "", "elif", "type", "(", "segm", "[", "'counts'", "]", ")", "==", "list", ":", "\n", "# uncompressed RLE", "\n", "            ", "rle", "=", "maskUtils", ".", "frPyObjects", "(", "segm", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "# rle", "\n", "            ", "rle", "=", "ann", "[", "'segmentation'", "]", "\n", "", "return", "rle", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.annToMask": [[426, 434], ["coco.COCO.annToRLE", "mask.decode"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.annToRLE", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.decode"], ["", "def", "annToMask", "(", "self", ",", "ann", ")", ":", "\n", "        ", "\"\"\"\n        Convert annotation which can be polygons, uncompressed RLE, or RLE to binary mask.\n        :return: binary mask (numpy 2D array)\n        \"\"\"", "\n", "rle", "=", "self", ".", "annToRLE", "(", "ann", ")", "\n", "m", "=", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "return", "m", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco._isArrayLike": [[66, 68], ["hasattr", "hasattr"], "function", ["None"], ["", "def", "_isArrayLike", "(", "obj", ")", ":", "\n", "    ", "return", "hasattr", "(", "obj", ",", "'__iter__'", ")", "and", "hasattr", "(", "obj", ",", "'__len__'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.encode": [[81, 87], ["len", "_mask.encode", "len", "_mask.encode", "bimask.reshape"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.encode", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.encode"], ["def", "encode", "(", "bimask", ")", ":", "\n", "    ", "if", "len", "(", "bimask", ".", "shape", ")", "==", "3", ":", "\n", "        ", "return", "_mask", ".", "encode", "(", "bimask", ")", "\n", "", "elif", "len", "(", "bimask", ".", "shape", ")", "==", "2", ":", "\n", "        ", "h", ",", "w", "=", "bimask", ".", "shape", "\n", "return", "_mask", ".", "encode", "(", "bimask", ".", "reshape", "(", "(", "h", ",", "w", ",", "1", ")", ",", "order", "=", "'F'", ")", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.decode": [[88, 93], ["type", "_mask.decode", "_mask.decode"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.decode", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.decode"], ["", "", "def", "decode", "(", "rleObjs", ")", ":", "\n", "    ", "if", "type", "(", "rleObjs", ")", "==", "list", ":", "\n", "        ", "return", "_mask", ".", "decode", "(", "rleObjs", ")", "\n", "", "else", ":", "\n", "        ", "return", "_mask", ".", "decode", "(", "[", "rleObjs", "]", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.area": [[94, 99], ["type", "_mask.area", "_mask.area"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.area", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.area"], ["", "", "def", "area", "(", "rleObjs", ")", ":", "\n", "    ", "if", "type", "(", "rleObjs", ")", "==", "list", ":", "\n", "        ", "return", "_mask", ".", "area", "(", "rleObjs", ")", "\n", "", "else", ":", "\n", "        ", "return", "_mask", ".", "area", "(", "[", "rleObjs", "]", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.toBbox": [[100, 105], ["type", "_mask.toBbox", "_mask.toBbox"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.toBbox", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.toBbox"], ["", "", "def", "toBbox", "(", "rleObjs", ")", ":", "\n", "    ", "if", "type", "(", "rleObjs", ")", "==", "list", ":", "\n", "        ", "return", "_mask", ".", "toBbox", "(", "rleObjs", ")", "\n", "", "else", ":", "\n", "        ", "return", "_mask", ".", "toBbox", "(", "[", "rleObjs", "]", ")", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.__init__": [[60, 82], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "cocoeval.Params", "print", "sorted", "sorted", "cocoGt.getImgIds", "cocoGt.getCatIds"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getImgIds", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getCatIds"], ["    ", "def", "__init__", "(", "self", ",", "cocoGt", "=", "None", ",", "cocoDt", "=", "None", ",", "iouType", "=", "'segm'", ")", ":", "\n", "        ", "'''\n        Initialize CocoEval using coco APIs for gt and dt\n        :param cocoGt: coco object with ground truth annotations\n        :param cocoDt: coco object with detection results\n        :return: None\n        '''", "\n", "if", "not", "iouType", ":", "\n", "            ", "print", "(", "'iouType not specified. use default iouType segm'", ")", "\n", "", "self", ".", "cocoGt", "=", "cocoGt", "# ground truth COCO API", "\n", "self", ".", "cocoDt", "=", "cocoDt", "# detections COCO API", "\n", "self", ".", "evalImgs", "=", "defaultdict", "(", "list", ")", "# per-image per-category evaluation results [KxAxI] elements", "\n", "self", ".", "eval", "=", "{", "}", "# accumulated evaluation results", "\n", "self", ".", "_gts", "=", "defaultdict", "(", "list", ")", "# gt for evaluation", "\n", "self", ".", "_dts", "=", "defaultdict", "(", "list", ")", "# dt for evaluation", "\n", "self", ".", "params", "=", "Params", "(", "iouType", "=", "iouType", ")", "# parameters", "\n", "self", ".", "_paramsEval", "=", "{", "}", "# parameters for evaluation", "\n", "self", ".", "stats", "=", "[", "]", "# result summarization", "\n", "self", ".", "ious", "=", "{", "}", "# ious between all gts and dts", "\n", "if", "not", "cocoGt", "is", "None", ":", "\n", "            ", "self", ".", "params", ".", "imgIds", "=", "sorted", "(", "cocoGt", ".", "getImgIds", "(", ")", ")", "\n", "self", ".", "params", ".", "catIds", "=", "sorted", "(", "cocoGt", ".", "getCatIds", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval._prepare": [[84, 120], ["collections.defaultdict", "collections.defaultdict", "collections.defaultdict", "cocoeval.COCOeval.cocoGt.loadAnns", "cocoeval.COCOeval.cocoDt.loadAnns", "cocoeval.COCOeval.cocoGt.loadAnns", "cocoeval.COCOeval.cocoDt.loadAnns", "cocoeval.COCOeval._prepare._toMask"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadAnns", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadAnns", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadAnns", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadAnns"], ["", "", "def", "_prepare", "(", "self", ")", ":", "\n", "        ", "'''\n        Prepare ._gts and ._dts for evaluation based on params\n        :return: None\n        '''", "\n", "def", "_toMask", "(", "anns", ",", "coco", ")", ":", "\n", "# modify ann['segmentation'] by reference", "\n", "            ", "for", "ann", "in", "anns", ":", "\n", "                ", "rle", "=", "coco", ".", "annToRLE", "(", "ann", ")", "\n", "ann", "[", "'segmentation'", "]", "=", "rle", "\n", "", "", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gts", "=", "self", ".", "cocoGt", ".", "loadAnns", "(", "self", ".", "cocoGt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ",", "catIds", "=", "p", ".", "catIds", ")", ")", "\n", "dts", "=", "self", ".", "cocoDt", ".", "loadAnns", "(", "self", ".", "cocoDt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ",", "catIds", "=", "p", ".", "catIds", ")", ")", "\n", "", "else", ":", "\n", "            ", "gts", "=", "self", ".", "cocoGt", ".", "loadAnns", "(", "self", ".", "cocoGt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ")", ")", "\n", "dts", "=", "self", ".", "cocoDt", ".", "loadAnns", "(", "self", ".", "cocoDt", ".", "getAnnIds", "(", "imgIds", "=", "p", ".", "imgIds", ")", ")", "\n", "\n", "# convert ground truth to mask if iouType == 'segm'", "\n", "", "if", "p", ".", "iouType", "==", "'segm'", ":", "\n", "            ", "_toMask", "(", "gts", ",", "self", ".", "cocoGt", ")", "\n", "_toMask", "(", "dts", ",", "self", ".", "cocoDt", ")", "\n", "# set ignore flag", "\n", "", "for", "gt", "in", "gts", ":", "\n", "            ", "gt", "[", "'ignore'", "]", "=", "gt", "[", "'ignore'", "]", "if", "'ignore'", "in", "gt", "else", "0", "\n", "gt", "[", "'ignore'", "]", "=", "'iscrowd'", "in", "gt", "and", "gt", "[", "'iscrowd'", "]", "\n", "if", "p", ".", "iouType", "==", "'keypoints'", ":", "\n", "                ", "gt", "[", "'ignore'", "]", "=", "(", "gt", "[", "'num_keypoints'", "]", "==", "0", ")", "or", "gt", "[", "'ignore'", "]", "\n", "", "", "self", ".", "_gts", "=", "defaultdict", "(", "list", ")", "# gt for evaluation", "\n", "self", ".", "_dts", "=", "defaultdict", "(", "list", ")", "# dt for evaluation", "\n", "for", "gt", "in", "gts", ":", "\n", "            ", "self", ".", "_gts", "[", "gt", "[", "'image_id'", "]", ",", "gt", "[", "'category_id'", "]", "]", ".", "append", "(", "gt", ")", "\n", "", "for", "dt", "in", "dts", ":", "\n", "            ", "self", ".", "_dts", "[", "dt", "[", "'image_id'", "]", ",", "dt", "[", "'category_id'", "]", "]", ".", "append", "(", "dt", ")", "\n", "", "self", ".", "evalImgs", "=", "defaultdict", "(", "list", ")", "# per-image per-category evaluation results", "\n", "self", ".", "eval", "=", "{", "}", "# accumulated evaluation results", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.evaluate": [[121, 162], ["time.time", "print", "print", "list", "sorted", "cocoeval.COCOeval._prepare", "copy.deepcopy", "time.time", "print", "print", "numpy.unique", "list", "cocoeval.COCOeval.computeIoU"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval._prepare", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.computeIoU"], ["", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "'''\n        Run per image evaluation on given images and store results (a list of dict) in self.evalImgs\n        :return: None\n        '''", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'Running per image evaluation...'", ")", "\n", "p", "=", "self", ".", "params", "\n", "# add backward compatibility if useSegm is specified in params", "\n", "if", "not", "p", ".", "useSegm", "is", "None", ":", "\n", "            ", "p", ".", "iouType", "=", "'segm'", "if", "p", ".", "useSegm", "==", "1", "else", "'bbox'", "\n", "print", "(", "'useSegm (deprecated) is not None. Running {} evaluation'", ".", "format", "(", "p", ".", "iouType", ")", ")", "\n", "", "print", "(", "'Evaluate annotation type *{}*'", ".", "format", "(", "p", ".", "iouType", ")", ")", "\n", "p", ".", "imgIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "imgIds", ")", ")", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "p", ".", "catIds", "=", "list", "(", "np", ".", "unique", "(", "p", ".", "catIds", ")", ")", "\n", "", "p", ".", "maxDets", "=", "sorted", "(", "p", ".", "maxDets", ")", "\n", "self", ".", "params", "=", "p", "\n", "\n", "self", ".", "_prepare", "(", ")", "\n", "# loop through images, area range, max detection number", "\n", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "else", "[", "-", "1", "]", "\n", "\n", "if", "p", ".", "iouType", "==", "'segm'", "or", "p", ".", "iouType", "==", "'bbox'", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeIoU", "\n", "", "elif", "p", ".", "iouType", "==", "'keypoints'", ":", "\n", "            ", "computeIoU", "=", "self", ".", "computeOks", "\n", "", "self", ".", "ious", "=", "{", "(", "imgId", ",", "catId", ")", ":", "computeIoU", "(", "imgId", ",", "catId", ")", "for", "imgId", "in", "p", ".", "imgIds", "\n", "for", "catId", "in", "catIds", "}", "\n", "\n", "evaluateImg", "=", "self", ".", "evaluateImg", "\n", "maxDet", "=", "p", ".", "maxDets", "[", "-", "1", "]", "\n", "self", ".", "evalImgs", "=", "[", "evaluateImg", "(", "imgId", ",", "catId", ",", "areaRng", ",", "maxDet", ")", "\n", "for", "catId", "in", "catIds", "\n", "for", "areaRng", "in", "p", ".", "areaRng", "\n", "for", "imgId", "in", "p", ".", "imgIds", "\n", "]", "\n", "self", ".", "_paramsEval", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'DONE (t={:0.2f}s).'", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.computeIoU": [[163, 191], ["numpy.argsort", "mask.iou", "len", "int", "len", "len", "Exception"], "methods", ["None"], ["", "def", "computeIoU", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "'score'", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "'mergesort'", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dt", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dt", "=", "dt", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "\n", "", "if", "p", ".", "iouType", "==", "'segm'", ":", "\n", "            ", "g", "=", "[", "g", "[", "'segmentation'", "]", "for", "g", "in", "gt", "]", "\n", "d", "=", "[", "d", "[", "'segmentation'", "]", "for", "d", "in", "dt", "]", "\n", "", "elif", "p", ".", "iouType", "==", "'bbox'", ":", "\n", "            ", "g", "=", "[", "g", "[", "'bbox'", "]", "for", "g", "in", "gt", "]", "\n", "d", "=", "[", "d", "[", "'bbox'", "]", "for", "d", "in", "dt", "]", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'unknown iouType for iou computation'", ")", "\n", "\n", "# compute iou between each dt and gt region", "\n", "", "iscrowd", "=", "[", "int", "(", "o", "[", "'iscrowd'", "]", ")", "for", "o", "in", "gt", "]", "\n", "ious", "=", "maskUtils", ".", "iou", "(", "d", ",", "g", ",", "iscrowd", ")", "\n", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.computeOks": [[192, 234], ["numpy.argsort", "numpy.zeros", "len", "enumerate", "len", "numpy.array", "numpy.count_nonzero", "enumerate", "len", "len", "len", "len", "numpy.array", "numpy.zeros", "numpy.sum", "numpy.max", "numpy.max", "numpy.max", "numpy.max", "numpy.exp", "numpy.spacing"], "methods", ["None"], ["", "def", "computeOks", "(", "self", ",", "imgId", ",", "catId", ")", ":", "\n", "        ", "p", "=", "self", ".", "params", "\n", "# dimention here should be Nxm", "\n", "gts", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dts", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "inds", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "'score'", "]", "for", "d", "in", "dts", "]", ",", "kind", "=", "'mergesort'", ")", "\n", "dts", "=", "[", "dts", "[", "i", "]", "for", "i", "in", "inds", "]", "\n", "if", "len", "(", "dts", ")", ">", "p", ".", "maxDets", "[", "-", "1", "]", ":", "\n", "            ", "dts", "=", "dts", "[", "0", ":", "p", ".", "maxDets", "[", "-", "1", "]", "]", "\n", "# if len(gts) == 0 and len(dts) == 0:", "\n", "", "if", "len", "(", "gts", ")", "==", "0", "or", "len", "(", "dts", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "dts", ")", ",", "len", "(", "gts", ")", ")", ")", "\n", "sigmas", "=", "p", ".", "kpt_oks_sigmas", "\n", "vars", "=", "(", "sigmas", "*", "2", ")", "**", "2", "\n", "k", "=", "len", "(", "sigmas", ")", "\n", "# compute oks between each detection and ground truth object", "\n", "for", "j", ",", "gt", "in", "enumerate", "(", "gts", ")", ":", "\n", "# create bounds for ignore regions(double the gt bbox)", "\n", "            ", "g", "=", "np", ".", "array", "(", "gt", "[", "'keypoints'", "]", ")", "\n", "xg", "=", "g", "[", "0", ":", ":", "3", "]", ";", "yg", "=", "g", "[", "1", ":", ":", "3", "]", ";", "vg", "=", "g", "[", "2", ":", ":", "3", "]", "\n", "k1", "=", "np", ".", "count_nonzero", "(", "vg", ">", "0", ")", "\n", "bb", "=", "gt", "[", "'bbox'", "]", "\n", "x0", "=", "bb", "[", "0", "]", "-", "bb", "[", "2", "]", ";", "x1", "=", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", "*", "2", "\n", "y0", "=", "bb", "[", "1", "]", "-", "bb", "[", "3", "]", ";", "y1", "=", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "*", "2", "\n", "for", "i", ",", "dt", "in", "enumerate", "(", "dts", ")", ":", "\n", "                ", "d", "=", "np", ".", "array", "(", "dt", "[", "'keypoints'", "]", ")", "\n", "xd", "=", "d", "[", "0", ":", ":", "3", "]", ";", "yd", "=", "d", "[", "1", ":", ":", "3", "]", "\n", "if", "k1", ">", "0", ":", "\n", "# measure the per-keypoint distance if keypoints visible", "\n", "                    ", "dx", "=", "xd", "-", "xg", "\n", "dy", "=", "yd", "-", "yg", "\n", "", "else", ":", "\n", "# measure minimum distance to keypoints in (x0,y0) & (x1,y1)", "\n", "                    ", "z", "=", "np", ".", "zeros", "(", "(", "k", ")", ")", "\n", "dx", "=", "np", ".", "max", "(", "(", "z", ",", "x0", "-", "xd", ")", ",", "axis", "=", "0", ")", "+", "np", ".", "max", "(", "(", "z", ",", "xd", "-", "x1", ")", ",", "axis", "=", "0", ")", "\n", "dy", "=", "np", ".", "max", "(", "(", "z", ",", "y0", "-", "yd", ")", ",", "axis", "=", "0", ")", "+", "np", ".", "max", "(", "(", "z", ",", "yd", "-", "y1", ")", ",", "axis", "=", "0", ")", "\n", "", "e", "=", "(", "dx", "**", "2", "+", "dy", "**", "2", ")", "/", "vars", "/", "(", "gt", "[", "'area'", "]", "+", "np", ".", "spacing", "(", "1", ")", ")", "/", "2", "\n", "if", "k1", ">", "0", ":", "\n", "                    ", "e", "=", "e", "[", "vg", ">", "0", "]", "\n", "", "ious", "[", "i", ",", "j", "]", "=", "np", ".", "sum", "(", "np", ".", "exp", "(", "-", "e", ")", ")", "/", "e", ".", "shape", "[", "0", "]", "\n", "", "", "return", "ious", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.evaluateImg": [[235, 313], ["numpy.argsort", "numpy.argsort", "len", "len", "len", "numpy.zeros", "numpy.zeros", "numpy.array", "numpy.zeros", "numpy.array().reshape", "numpy.logical_or", "int", "enumerate", "numpy.logical_and", "len", "len", "len", "len", "enumerate", "numpy.array", "len", "numpy.repeat", "min", "enumerate"], "methods", ["None"], ["", "def", "evaluateImg", "(", "self", ",", "imgId", ",", "catId", ",", "aRng", ",", "maxDet", ")", ":", "\n", "        ", "'''\n        perform evaluation for single category and image\n        :return: dict (single image results)\n        '''", "\n", "p", "=", "self", ".", "params", "\n", "if", "p", ".", "useCats", ":", "\n", "            ", "gt", "=", "self", ".", "_gts", "[", "imgId", ",", "catId", "]", "\n", "dt", "=", "self", ".", "_dts", "[", "imgId", ",", "catId", "]", "\n", "", "else", ":", "\n", "            ", "gt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_gts", "[", "imgId", ",", "cId", "]", "]", "\n", "dt", "=", "[", "_", "for", "cId", "in", "p", ".", "catIds", "for", "_", "in", "self", ".", "_dts", "[", "imgId", ",", "cId", "]", "]", "\n", "", "if", "len", "(", "gt", ")", "==", "0", "and", "len", "(", "dt", ")", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "for", "g", "in", "gt", ":", "\n", "            ", "if", "g", "[", "'ignore'", "]", "or", "(", "g", "[", "'area'", "]", "<", "aRng", "[", "0", "]", "or", "g", "[", "'area'", "]", ">", "aRng", "[", "1", "]", ")", ":", "\n", "                ", "g", "[", "'_ignore'", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "g", "[", "'_ignore'", "]", "=", "0", "\n", "\n", "# sort dt highest score first, sort gt ignore last", "\n", "", "", "gtind", "=", "np", ".", "argsort", "(", "[", "g", "[", "'_ignore'", "]", "for", "g", "in", "gt", "]", ",", "kind", "=", "'mergesort'", ")", "\n", "gt", "=", "[", "gt", "[", "i", "]", "for", "i", "in", "gtind", "]", "\n", "dtind", "=", "np", ".", "argsort", "(", "[", "-", "d", "[", "'score'", "]", "for", "d", "in", "dt", "]", ",", "kind", "=", "'mergesort'", ")", "\n", "dt", "=", "[", "dt", "[", "i", "]", "for", "i", "in", "dtind", "[", "0", ":", "maxDet", "]", "]", "\n", "iscrowd", "=", "[", "int", "(", "o", "[", "'iscrowd'", "]", ")", "for", "o", "in", "gt", "]", "\n", "# load computed ious", "\n", "ious", "=", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "[", ":", ",", "gtind", "]", "if", "len", "(", "self", ".", "ious", "[", "imgId", ",", "catId", "]", ")", ">", "0", "else", "self", ".", "ious", "[", "imgId", ",", "catId", "]", "\n", "\n", "T", "=", "len", "(", "p", ".", "iouThrs", ")", "\n", "G", "=", "len", "(", "gt", ")", "\n", "D", "=", "len", "(", "dt", ")", "\n", "gtm", "=", "np", ".", "zeros", "(", "(", "T", ",", "G", ")", ")", "\n", "dtm", "=", "np", ".", "zeros", "(", "(", "T", ",", "D", ")", ")", "\n", "gtIg", "=", "np", ".", "array", "(", "[", "g", "[", "'_ignore'", "]", "for", "g", "in", "gt", "]", ")", "\n", "dtIg", "=", "np", ".", "zeros", "(", "(", "T", ",", "D", ")", ")", "\n", "if", "not", "len", "(", "ious", ")", "==", "0", ":", "\n", "            ", "for", "tind", ",", "t", "in", "enumerate", "(", "p", ".", "iouThrs", ")", ":", "\n", "                ", "for", "dind", ",", "d", "in", "enumerate", "(", "dt", ")", ":", "\n", "# information about best match so far (m=-1 -> unmatched)", "\n", "                    ", "iou", "=", "min", "(", "[", "t", ",", "1", "-", "1e-10", "]", ")", "\n", "m", "=", "-", "1", "\n", "for", "gind", ",", "g", "in", "enumerate", "(", "gt", ")", ":", "\n", "# if this gt already matched, and not a crowd, continue", "\n", "                        ", "if", "gtm", "[", "tind", ",", "gind", "]", ">", "0", "and", "not", "iscrowd", "[", "gind", "]", ":", "\n", "                            ", "continue", "\n", "# if dt matched to reg gt, and on ignore gt, stop", "\n", "", "if", "m", ">", "-", "1", "and", "gtIg", "[", "m", "]", "==", "0", "and", "gtIg", "[", "gind", "]", "==", "1", ":", "\n", "                            ", "break", "\n", "# continue to next gt unless better match made", "\n", "", "if", "ious", "[", "dind", ",", "gind", "]", "<", "iou", ":", "\n", "                            ", "continue", "\n", "# if match successful and best so far, store appropriately", "\n", "", "iou", "=", "ious", "[", "dind", ",", "gind", "]", "\n", "m", "=", "gind", "\n", "# if match made store id of match for both dt and gt", "\n", "", "if", "m", "==", "-", "1", ":", "\n", "                        ", "continue", "\n", "", "dtIg", "[", "tind", ",", "dind", "]", "=", "gtIg", "[", "m", "]", "\n", "dtm", "[", "tind", ",", "dind", "]", "=", "gt", "[", "m", "]", "[", "'id'", "]", "\n", "gtm", "[", "tind", ",", "m", "]", "=", "d", "[", "'id'", "]", "\n", "# set unmatched detections outside of area range to ignore", "\n", "", "", "", "a", "=", "np", ".", "array", "(", "[", "d", "[", "'area'", "]", "<", "aRng", "[", "0", "]", "or", "d", "[", "'area'", "]", ">", "aRng", "[", "1", "]", "for", "d", "in", "dt", "]", ")", ".", "reshape", "(", "(", "1", ",", "len", "(", "dt", ")", ")", ")", "\n", "dtIg", "=", "np", ".", "logical_or", "(", "dtIg", ",", "np", ".", "logical_and", "(", "dtm", "==", "0", ",", "np", ".", "repeat", "(", "a", ",", "T", ",", "0", ")", ")", ")", "\n", "# store results for given image and category", "\n", "return", "{", "\n", "'image_id'", ":", "imgId", ",", "\n", "'category_id'", ":", "catId", ",", "\n", "'aRng'", ":", "aRng", ",", "\n", "'maxDet'", ":", "maxDet", ",", "\n", "'dtIds'", ":", "[", "d", "[", "'id'", "]", "for", "d", "in", "dt", "]", ",", "\n", "'gtIds'", ":", "[", "g", "[", "'id'", "]", "for", "g", "in", "gt", "]", ",", "\n", "'dtMatches'", ":", "dtm", ",", "\n", "'gtMatches'", ":", "gtm", ",", "\n", "'dtScores'", ":", "[", "d", "[", "'score'", "]", "for", "d", "in", "dt", "]", ",", "\n", "'gtIgnore'", ":", "gtIg", ",", "\n", "'dtIgnore'", ":", "dtIg", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.accumulate": [[315, 421], ["print", "time.time", "len", "len", "len", "len", "set", "set", "set", "set", "len", "len", "enumerate", "time.time", "print", "print", "len", "numpy.ones", "numpy.ones", "numpy.ones", "map", "enumerate", "datetime.datetime.now().strftime", "enumerate", "enumerate", "enumerate", "enumerate", "enumerate", "map", "numpy.concatenate", "numpy.argsort", "numpy.concatenate", "numpy.count_nonzero", "numpy.logical_and", "numpy.logical_and", "numpy.cumsum().astype", "numpy.cumsum().astype", "enumerate", "datetime.datetime.now", "len", "numpy.concatenate", "numpy.concatenate", "numpy.logical_not", "numpy.logical_not", "numpy.logical_not", "zip", "numpy.array", "numpy.array", "len", "numpy.zeros", "numpy.zeros", "pr.tolist.tolist.tolist", "q.tolist.tolist.tolist", "range", "numpy.searchsorted", "numpy.array", "numpy.array", "tuple", "numpy.cumsum", "numpy.cumsum", "enumerate", "numpy.spacing"], "methods", ["None"], ["", "def", "accumulate", "(", "self", ",", "p", "=", "None", ")", ":", "\n", "        ", "'''\n        Accumulate per image evaluation results and store the result in self.eval\n        :param p: input params for evaluation\n        :return: None\n        '''", "\n", "print", "(", "'Accumulating evaluation results...'", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "not", "self", ".", "evalImgs", ":", "\n", "            ", "print", "(", "'Please run evaluate() first'", ")", "\n", "# allows input customized parameters", "\n", "", "if", "p", "is", "None", ":", "\n", "            ", "p", "=", "self", ".", "params", "\n", "", "p", ".", "catIds", "=", "p", ".", "catIds", "if", "p", ".", "useCats", "==", "1", "else", "[", "-", "1", "]", "\n", "T", "=", "len", "(", "p", ".", "iouThrs", ")", "\n", "R", "=", "len", "(", "p", ".", "recThrs", ")", "\n", "K", "=", "len", "(", "p", ".", "catIds", ")", "if", "p", ".", "useCats", "else", "1", "\n", "A", "=", "len", "(", "p", ".", "areaRng", ")", "\n", "M", "=", "len", "(", "p", ".", "maxDets", ")", "\n", "precision", "=", "-", "np", ".", "ones", "(", "(", "T", ",", "R", ",", "K", ",", "A", ",", "M", ")", ")", "# -1 for the precision of absent categories", "\n", "recall", "=", "-", "np", ".", "ones", "(", "(", "T", ",", "K", ",", "A", ",", "M", ")", ")", "\n", "scores", "=", "-", "np", ".", "ones", "(", "(", "T", ",", "R", ",", "K", ",", "A", ",", "M", ")", ")", "\n", "\n", "# create dictionary for future indexing", "\n", "_pe", "=", "self", ".", "_paramsEval", "\n", "catIds", "=", "_pe", ".", "catIds", "if", "_pe", ".", "useCats", "else", "[", "-", "1", "]", "\n", "setK", "=", "set", "(", "catIds", ")", "\n", "setA", "=", "set", "(", "map", "(", "tuple", ",", "_pe", ".", "areaRng", ")", ")", "\n", "setM", "=", "set", "(", "_pe", ".", "maxDets", ")", "\n", "setI", "=", "set", "(", "_pe", ".", "imgIds", ")", "\n", "# get inds to evaluate", "\n", "k_list", "=", "[", "n", "for", "n", ",", "k", "in", "enumerate", "(", "p", ".", "catIds", ")", "if", "k", "in", "setK", "]", "\n", "m_list", "=", "[", "m", "for", "n", ",", "m", "in", "enumerate", "(", "p", ".", "maxDets", ")", "if", "m", "in", "setM", "]", "\n", "a_list", "=", "[", "n", "for", "n", ",", "a", "in", "enumerate", "(", "map", "(", "lambda", "x", ":", "tuple", "(", "x", ")", ",", "p", ".", "areaRng", ")", ")", "if", "a", "in", "setA", "]", "\n", "i_list", "=", "[", "n", "for", "n", ",", "i", "in", "enumerate", "(", "p", ".", "imgIds", ")", "if", "i", "in", "setI", "]", "\n", "I0", "=", "len", "(", "_pe", ".", "imgIds", ")", "\n", "A0", "=", "len", "(", "_pe", ".", "areaRng", ")", "\n", "# retrieve E at each category, area range, and max number of detections", "\n", "for", "k", ",", "k0", "in", "enumerate", "(", "k_list", ")", ":", "\n", "            ", "Nk", "=", "k0", "*", "A0", "*", "I0", "\n", "for", "a", ",", "a0", "in", "enumerate", "(", "a_list", ")", ":", "\n", "                ", "Na", "=", "a0", "*", "I0", "\n", "for", "m", ",", "maxDet", "in", "enumerate", "(", "m_list", ")", ":", "\n", "                    ", "E", "=", "[", "self", ".", "evalImgs", "[", "Nk", "+", "Na", "+", "i", "]", "for", "i", "in", "i_list", "]", "\n", "E", "=", "[", "e", "for", "e", "in", "E", "if", "not", "e", "is", "None", "]", "\n", "if", "len", "(", "E", ")", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "dtScores", "=", "np", ".", "concatenate", "(", "[", "e", "[", "'dtScores'", "]", "[", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ")", "\n", "\n", "# different sorting method generates slightly different results.", "\n", "# mergesort is used to be consistent as Matlab implementation.", "\n", "inds", "=", "np", ".", "argsort", "(", "-", "dtScores", ",", "kind", "=", "'mergesort'", ")", "\n", "dtScoresSorted", "=", "dtScores", "[", "inds", "]", "\n", "\n", "dtm", "=", "np", ".", "concatenate", "(", "[", "e", "[", "'dtMatches'", "]", "[", ":", ",", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ",", "axis", "=", "1", ")", "[", ":", ",", "inds", "]", "\n", "dtIg", "=", "np", ".", "concatenate", "(", "[", "e", "[", "'dtIgnore'", "]", "[", ":", ",", "0", ":", "maxDet", "]", "for", "e", "in", "E", "]", ",", "axis", "=", "1", ")", "[", ":", ",", "inds", "]", "\n", "gtIg", "=", "np", ".", "concatenate", "(", "[", "e", "[", "'gtIgnore'", "]", "for", "e", "in", "E", "]", ")", "\n", "npig", "=", "np", ".", "count_nonzero", "(", "gtIg", "==", "0", ")", "\n", "if", "npig", "==", "0", ":", "\n", "                        ", "continue", "\n", "", "tps", "=", "np", ".", "logical_and", "(", "dtm", ",", "np", ".", "logical_not", "(", "dtIg", ")", ")", "\n", "fps", "=", "np", ".", "logical_and", "(", "np", ".", "logical_not", "(", "dtm", ")", ",", "np", ".", "logical_not", "(", "dtIg", ")", ")", "\n", "\n", "tp_sum", "=", "np", ".", "cumsum", "(", "tps", ",", "axis", "=", "1", ")", ".", "astype", "(", "dtype", "=", "np", ".", "float", ")", "\n", "fp_sum", "=", "np", ".", "cumsum", "(", "fps", ",", "axis", "=", "1", ")", ".", "astype", "(", "dtype", "=", "np", ".", "float", ")", "\n", "for", "t", ",", "(", "tp", ",", "fp", ")", "in", "enumerate", "(", "zip", "(", "tp_sum", ",", "fp_sum", ")", ")", ":", "\n", "                        ", "tp", "=", "np", ".", "array", "(", "tp", ")", "\n", "fp", "=", "np", ".", "array", "(", "fp", ")", "\n", "nd", "=", "len", "(", "tp", ")", "\n", "rc", "=", "tp", "/", "npig", "\n", "pr", "=", "tp", "/", "(", "fp", "+", "tp", "+", "np", ".", "spacing", "(", "1", ")", ")", "\n", "q", "=", "np", ".", "zeros", "(", "(", "R", ",", ")", ")", "\n", "ss", "=", "np", ".", "zeros", "(", "(", "R", ",", ")", ")", "\n", "\n", "if", "nd", ":", "\n", "                            ", "recall", "[", "t", ",", "k", ",", "a", ",", "m", "]", "=", "rc", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                            ", "recall", "[", "t", ",", "k", ",", "a", ",", "m", "]", "=", "0", "\n", "\n", "# numpy is slow without cython optimization for accessing elements", "\n", "# use python array gets significant speed improvement", "\n", "", "pr", "=", "pr", ".", "tolist", "(", ")", ";", "q", "=", "q", ".", "tolist", "(", ")", "\n", "\n", "for", "i", "in", "range", "(", "nd", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "                            ", "if", "pr", "[", "i", "]", ">", "pr", "[", "i", "-", "1", "]", ":", "\n", "                                ", "pr", "[", "i", "-", "1", "]", "=", "pr", "[", "i", "]", "\n", "\n", "", "", "inds", "=", "np", ".", "searchsorted", "(", "rc", ",", "p", ".", "recThrs", ",", "side", "=", "'left'", ")", "\n", "try", ":", "\n", "                            ", "for", "ri", ",", "pi", "in", "enumerate", "(", "inds", ")", ":", "\n", "                                ", "q", "[", "ri", "]", "=", "pr", "[", "pi", "]", "\n", "ss", "[", "ri", "]", "=", "dtScoresSorted", "[", "pi", "]", "\n", "", "", "except", "Exception", ":", "\n", "                            ", "pass", "\n", "", "precision", "[", "t", ",", ":", ",", "k", ",", "a", ",", "m", "]", "=", "np", ".", "array", "(", "q", ")", "\n", "scores", "[", "t", ",", ":", ",", "k", ",", "a", ",", "m", "]", "=", "np", ".", "array", "(", "ss", ")", "\n", "", "", "", "", "self", ".", "eval", "=", "{", "\n", "'params'", ":", "p", ",", "\n", "'counts'", ":", "[", "T", ",", "R", ",", "K", ",", "A", ",", "M", "]", ",", "\n", "'date'", ":", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "'%Y-%m-%d %H:%M:%S'", ")", ",", "\n", "'precision'", ":", "precision", ",", "\n", "'recall'", ":", "recall", ",", "\n", "'scores'", ":", "scores", ",", "\n", "}", "\n", "toc", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'DONE (t={:0.2f}s).'", ".", "format", "(", "toc", "-", "tic", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.summarize": [[422, 494], ["cocoeval.COCOeval.summarize"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.summarize"], ["", "def", "summarize", "(", "self", ")", ":", "\n", "        ", "'''\n        Compute and display summary metrics for evaluation results.\n        Note this functin can *only* be applied on the default parameter setting\n        '''", "\n", "def", "_summarize", "(", "ap", "=", "1", ",", "iouThr", "=", "None", ",", "areaRng", "=", "'all'", ",", "maxDets", "=", "100", ")", ":", "\n", "            ", "p", "=", "self", ".", "params", "\n", "iStr", "=", "' {:<18} {} @[ IoU={:<9} | area={:>6s} | maxDets={:>3d} ] = {:0.3f}'", "\n", "titleStr", "=", "'Average Precision'", "if", "ap", "==", "1", "else", "'Average Recall'", "\n", "typeStr", "=", "'(AP)'", "if", "ap", "==", "1", "else", "'(AR)'", "\n", "iouStr", "=", "'{:0.2f}:{:0.2f}'", ".", "format", "(", "p", ".", "iouThrs", "[", "0", "]", ",", "p", ".", "iouThrs", "[", "-", "1", "]", ")", "if", "iouThr", "is", "None", "else", "'{:0.2f}'", ".", "format", "(", "iouThr", ")", "\n", "\n", "aind", "=", "[", "i", "for", "i", ",", "aRng", "in", "enumerate", "(", "p", ".", "areaRngLbl", ")", "if", "aRng", "==", "areaRng", "]", "\n", "mind", "=", "[", "i", "for", "i", ",", "mDet", "in", "enumerate", "(", "p", ".", "maxDets", ")", "if", "mDet", "==", "maxDets", "]", "\n", "if", "ap", "==", "1", ":", "\n", "# dimension of precision: [TxRxKxAxM]", "\n", "                ", "s", "=", "self", ".", "eval", "[", "'precision'", "]", "\n", "# IoU", "\n", "if", "iouThr", "is", "not", "None", ":", "\n", "                    ", "t", "=", "np", ".", "where", "(", "iouThr", "==", "p", ".", "iouThrs", ")", "[", "0", "]", "\n", "s", "=", "s", "[", "t", "]", "\n", "", "s", "=", "s", "[", ":", ",", ":", ",", ":", ",", "aind", ",", "mind", "]", "\n", "", "else", ":", "\n", "# dimension of recall: [TxKxAxM]", "\n", "                ", "s", "=", "self", ".", "eval", "[", "'recall'", "]", "\n", "if", "iouThr", "is", "not", "None", ":", "\n", "                    ", "t", "=", "np", ".", "where", "(", "iouThr", "==", "p", ".", "iouThrs", ")", "[", "0", "]", "\n", "s", "=", "s", "[", "t", "]", "\n", "", "s", "=", "s", "[", ":", ",", ":", ",", "aind", ",", "mind", "]", "\n", "", "if", "len", "(", "s", "[", "s", ">", "-", "1", "]", ")", "==", "0", ":", "\n", "                ", "mean_s", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "mean_s", "=", "np", ".", "mean", "(", "s", "[", "s", ">", "-", "1", "]", ")", "\n", "", "print", "(", "iStr", ".", "format", "(", "titleStr", ",", "typeStr", ",", "iouStr", ",", "areaRng", ",", "maxDets", ",", "mean_s", ")", ")", "\n", "return", "mean_s", "\n", "", "def", "_summarizeDets", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "12", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "iouThr", "=", ".5", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "iouThr", "=", ".75", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "'small'", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "'medium'", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "1", ",", "areaRng", "=", "'large'", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "0", "]", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "1", "]", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "'small'", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "10", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "'medium'", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "stats", "[", "11", "]", "=", "_summarize", "(", "0", ",", "areaRng", "=", "'large'", ",", "maxDets", "=", "self", ".", "params", ".", "maxDets", "[", "2", "]", ")", "\n", "return", "stats", "\n", "", "def", "_summarizeKps", "(", ")", ":", "\n", "            ", "stats", "=", "np", ".", "zeros", "(", "(", "10", ",", ")", ")", "\n", "stats", "[", "0", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ")", "\n", "stats", "[", "1", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "iouThr", "=", ".5", ")", "\n", "stats", "[", "2", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "iouThr", "=", ".75", ")", "\n", "stats", "[", "3", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "areaRng", "=", "'medium'", ")", "\n", "stats", "[", "4", "]", "=", "_summarize", "(", "1", ",", "maxDets", "=", "20", ",", "areaRng", "=", "'large'", ")", "\n", "stats", "[", "5", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ")", "\n", "stats", "[", "6", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "iouThr", "=", ".5", ")", "\n", "stats", "[", "7", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "iouThr", "=", ".75", ")", "\n", "stats", "[", "8", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "areaRng", "=", "'medium'", ")", "\n", "stats", "[", "9", "]", "=", "_summarize", "(", "0", ",", "maxDets", "=", "20", ",", "areaRng", "=", "'large'", ")", "\n", "return", "stats", "\n", "", "if", "not", "self", ".", "eval", ":", "\n", "            ", "raise", "Exception", "(", "'Please run accumulate() first'", ")", "\n", "", "iouType", "=", "self", ".", "params", ".", "iouType", "\n", "if", "iouType", "==", "'segm'", "or", "iouType", "==", "'bbox'", ":", "\n", "            ", "summarize", "=", "_summarizeDets", "\n", "", "elif", "iouType", "==", "'keypoints'", ":", "\n", "            ", "summarize", "=", "_summarizeKps", "\n", "", "self", ".", "stats", "=", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.__str__": [[495, 497], ["cocoeval.COCOeval.summarize"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.summarize"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "self", ".", "summarize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.Params.setDetParams": [[502, 512], ["numpy.linspace", "numpy.linspace", "int", "int", "numpy.round", "numpy.round"], "methods", ["None"], ["def", "setDetParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "# np.arange causes trouble.  the data point on arange is slightly larger than the true value", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", ".5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", ".5", ")", "/", ".05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", ".0", ",", "1.00", ",", "int", "(", "np", ".", "round", "(", "(", "1.00", "-", ".0", ")", "/", ".01", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "1", ",", "10", ",", "100", "]", "\n", "self", ".", "areaRng", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "'all'", ",", "'small'", ",", "'medium'", ",", "'large'", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.Params.setKpParams": [[513, 524], ["numpy.linspace", "numpy.linspace", "numpy.array", "int", "int", "numpy.round", "numpy.round"], "methods", ["None"], ["", "def", "setKpParams", "(", "self", ")", ":", "\n", "        ", "self", ".", "imgIds", "=", "[", "]", "\n", "self", ".", "catIds", "=", "[", "]", "\n", "# np.arange causes trouble.  the data point on arange is slightly larger than the true value", "\n", "self", ".", "iouThrs", "=", "np", ".", "linspace", "(", ".5", ",", "0.95", ",", "int", "(", "np", ".", "round", "(", "(", "0.95", "-", ".5", ")", "/", ".05", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "recThrs", "=", "np", ".", "linspace", "(", ".0", ",", "1.00", ",", "int", "(", "np", ".", "round", "(", "(", "1.00", "-", ".0", ")", "/", ".01", ")", ")", "+", "1", ",", "endpoint", "=", "True", ")", "\n", "self", ".", "maxDets", "=", "[", "20", "]", "\n", "self", ".", "areaRng", "=", "[", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", "]", "\n", "self", ".", "areaRngLbl", "=", "[", "'all'", ",", "'medium'", ",", "'large'", "]", "\n", "self", ".", "useCats", "=", "1", "\n", "self", ".", "kpt_oks_sigmas", "=", "np", ".", "array", "(", "[", ".26", ",", ".25", ",", ".25", ",", ".35", ",", ".35", ",", ".79", ",", ".79", ",", ".72", ",", ".72", ",", ".62", ",", ".62", ",", "1.07", ",", "1.07", ",", ".87", ",", ".87", ",", ".89", ",", ".89", "]", ")", "/", "10.0", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.Params.__init__": [[525, 535], ["cocoeval.Params.setDetParams", "cocoeval.Params.setKpParams", "Exception"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.Params.setDetParams", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.Params.setKpParams"], ["", "def", "__init__", "(", "self", ",", "iouType", "=", "'segm'", ")", ":", "\n", "        ", "if", "iouType", "==", "'segm'", "or", "iouType", "==", "'bbox'", ":", "\n", "            ", "self", ".", "setDetParams", "(", ")", "\n", "", "elif", "iouType", "==", "'keypoints'", ":", "\n", "            ", "self", ".", "setKpParams", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'iouType not supported'", ")", "\n", "", "self", ".", "iouType", "=", "iouType", "\n", "# useSegm is deprecated", "\n", "self", ".", "useSegm", "=", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.nms.py_cpu_nms.py_cpu_nms": [[10, 39], ["scores.argsort", "keep.append", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.where"], "function", ["None"], ["def", "py_cpu_nms", "(", "dets", ",", "thresh", ")", ":", "\n", "    ", "\"\"\"Pure Python NMS baseline.\"\"\"", "\n", "x1", "=", "dets", "[", ":", ",", "0", "]", "\n", "y1", "=", "dets", "[", ":", ",", "1", "]", "\n", "x2", "=", "dets", "[", ":", ",", "2", "]", "\n", "y2", "=", "dets", "[", ":", ",", "3", "]", "\n", "scores", "=", "dets", "[", ":", ",", "4", "]", "\n", "\n", "areas", "=", "(", "x2", "-", "x1", "+", "1", ")", "*", "(", "y2", "-", "y1", "+", "1", ")", "\n", "order", "=", "scores", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "keep", "=", "[", "]", "\n", "while", "order", ".", "size", ">", "0", ":", "\n", "        ", "i", "=", "order", "[", "0", "]", "\n", "keep", ".", "append", "(", "i", ")", "\n", "xx1", "=", "np", ".", "maximum", "(", "x1", "[", "i", "]", ",", "x1", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "yy1", "=", "np", ".", "maximum", "(", "y1", "[", "i", "]", ",", "y1", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "xx2", "=", "np", ".", "minimum", "(", "x2", "[", "i", "]", ",", "x2", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "yy2", "=", "np", ".", "minimum", "(", "y2", "[", "i", "]", ",", "y2", "[", "order", "[", "1", ":", "]", "]", ")", "\n", "\n", "w", "=", "np", ".", "maximum", "(", "0.0", ",", "xx2", "-", "xx1", "+", "1", ")", "\n", "h", "=", "np", ".", "maximum", "(", "0.0", ",", "yy2", "-", "yy1", "+", "1", ")", "\n", "inter", "=", "w", "*", "h", "\n", "ovr", "=", "inter", "/", "(", "areas", "[", "i", "]", "+", "areas", "[", "order", "[", "1", ":", "]", "]", "-", "inter", ")", "\n", "\n", "inds", "=", "np", ".", "where", "(", "ovr", "<=", "thresh", ")", "[", "0", "]", "\n", "order", "=", "order", "[", "inds", "+", "1", "]", "\n", "\n", "", "return", "keep", "\n", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.functions.detection.Detect.__init__": [[12, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "bkg_label", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "background_label", "=", "bkg_label", "\n", "\n", "self", ".", "variance", "=", "cfg", "[", "'variance'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.functions.detection.Detect.forward": [[18, 56], ["loc_data.size", "prior_data.size", "torch.zeros", "torch.zeros", "range", "detection.Detect.boxes.cuda", "detection.Detect.scores.cuda", "utils.box_utils.decode", "conf_data[].clone", "obj_data[].unsqueeze().expand_as().mul", "torch.cat", "obj_data[].unsqueeze().expand_as", "obj_data[].unsqueeze", "obj_data[].unsqueeze"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.mask.decode"], ["", "def", "forward", "(", "self", ",", "predictions", ",", "prior", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            loc_data: (tensor) Loc preds from loc layers\n                Shape: [batch,num_priors*4]\n            conf_data: (tensor) Shape: Conf preds from conf layers\n                Shape: [batch,num_priors,num_classes]\n            prior_data: (tensor) Prior boxes and variances from priorbox layers\n                Shape: [batch,num_priors,4]\n        \"\"\"", "\n", "\n", "loc", ",", "conf", ",", "obj", "=", "predictions", "\n", "\n", "loc_data", "=", "loc", ".", "data", "# [num, num_priors, 4]", "\n", "conf_data", "=", "conf", ".", "data", "# [num, num_priors, num_classes]", "\n", "prior_data", "=", "prior", ".", "data", "# [num_priors, 4]", "\n", "obj_data", "=", "obj", ".", "data", "# [num, num_priors, 2]", "\n", "num", "=", "loc_data", ".", "size", "(", "0", ")", "# batch size", "\n", "self", ".", "num_priors", "=", "prior_data", ".", "size", "(", "0", ")", "\n", "self", ".", "boxes", "=", "torch", ".", "zeros", "(", "num", ",", "self", ".", "num_priors", ",", "4", ")", "\n", "self", ".", "scores", "=", "torch", ".", "zeros", "(", "num", ",", "self", ".", "num_priors", ",", "self", ".", "num_classes", ")", "# num_classes = 21", "\n", "if", "loc_data", ".", "is_cuda", ":", "\n", "            ", "self", ".", "boxes", "=", "self", ".", "boxes", ".", "cuda", "(", ")", "\n", "self", ".", "scores", "=", "self", ".", "scores", ".", "cuda", "(", ")", "\n", "\n", "# Decode predictions into bboxes.", "\n", "", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "            ", "decoded_boxes", "=", "decode", "(", "loc_data", "[", "i", "]", ",", "prior_data", ",", "self", ".", "variance", ")", "\n", "conf_scores", "=", "conf_data", "[", "i", "]", ".", "clone", "(", ")", "\n", "\n", "conf_scores", "=", "obj_data", "[", "i", ",", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "conf_scores", ")", ".", "mul", "(", "conf_scores", ")", "# conf score multiply the obj score", "\n", "# [num_priors, num_classes-1]", "\n", "conf_scores", "=", "torch", ".", "cat", "(", "(", "obj_data", "[", "i", ",", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", ",", "conf_scores", ")", ",", "1", ")", "# concatenate the background score", "\n", "# [num_priors, num_classes]", "\n", "self", ".", "boxes", "[", "i", "]", "=", "decoded_boxes", "\n", "self", ".", "scores", "[", "i", "]", "=", "conf_scores", "\n", "\n", "", "return", "self", ".", "boxes", ",", "self", ".", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.functions.prior_box.PriorBox.__init__": [[15, 30], ["object.__init__", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "super", "(", "PriorBox", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "image_size", "=", "cfg", "[", "'min_dim'", "]", "\n", "# number of priors for feature map location (either 4 or 6)", "\n", "self", ".", "num_priors", "=", "len", "(", "cfg", "[", "'aspect_ratios'", "]", ")", "\n", "self", ".", "variance", "=", "cfg", "[", "'variance'", "]", "or", "[", "0.1", "]", "\n", "self", ".", "feature_maps", "=", "cfg", "[", "'feature_maps'", "]", "\n", "self", ".", "min_sizes", "=", "cfg", "[", "'min_sizes'", "]", "\n", "self", ".", "max_sizes", "=", "cfg", "[", "'max_sizes'", "]", "\n", "self", ".", "steps", "=", "cfg", "[", "'steps'", "]", "\n", "self", ".", "aspect_ratios", "=", "cfg", "[", "'aspect_ratios'", "]", "\n", "self", ".", "clip", "=", "cfg", "[", "'clip'", "]", "\n", "for", "v", "in", "self", ".", "variance", ":", "\n", "            ", "if", "v", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "'Variances must be greater than 0'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.functions.prior_box.PriorBox.forward": [[31, 57], ["enumerate", "torch.Tensor().view", "itertools.product", "torch.Tensor().view.clamp_", "range", "math.sqrt", "torch.Tensor", "math.sqrt", "math.sqrt", "math.sqrt", "math.sqrt"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ")", ":", "\n", "        ", "mean", "=", "[", "]", "\n", "for", "k", ",", "f", "in", "enumerate", "(", "self", ".", "feature_maps", ")", ":", "\n", "            ", "for", "i", ",", "j", "in", "product", "(", "range", "(", "f", ")", ",", "repeat", "=", "2", ")", ":", "\n", "                ", "f_k", "=", "self", ".", "image_size", "/", "self", ".", "steps", "[", "k", "]", "\n", "cx", "=", "(", "j", "+", "0.5", ")", "/", "f_k", "\n", "cy", "=", "(", "i", "+", "0.5", ")", "/", "f_k", "\n", "\n", "s_k", "=", "self", ".", "min_sizes", "[", "k", "]", "/", "self", ".", "image_size", "\n", "mean", "+=", "[", "cx", ",", "cy", ",", "s_k", ",", "s_k", "]", "\n", "\n", "# aspect_ratio: 1", "\n", "# rel size: sqrt(s_k * s_(k+1))", "\n", "s_k_prime", "=", "sqrt", "(", "s_k", "*", "(", "self", ".", "max_sizes", "[", "k", "]", "/", "self", ".", "image_size", ")", ")", "\n", "mean", "+=", "[", "cx", ",", "cy", ",", "s_k_prime", ",", "s_k_prime", "]", "\n", "\n", "# rest of aspect ratios", "\n", "for", "ar", "in", "self", ".", "aspect_ratios", "[", "k", "]", ":", "\n", "                    ", "mean", "+=", "[", "cx", ",", "cy", ",", "s_k", "*", "sqrt", "(", "ar", ")", ",", "s_k", "/", "sqrt", "(", "ar", ")", "]", "\n", "mean", "+=", "[", "cx", ",", "cy", ",", "s_k", "/", "sqrt", "(", "ar", ")", ",", "s_k", "*", "sqrt", "(", "ar", ")", "]", "\n", "\n", "# back to torch land", "\n", "", "", "", "output", "=", "torch", ".", "Tensor", "(", "mean", ")", ".", "view", "(", "-", "1", ",", "4", ")", "\n", "if", "self", ".", "clip", ":", "\n", "            ", "output", ".", "clamp_", "(", "max", "=", "1", ",", "min", "=", "0", ")", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.modules.multibox_loss_combined.MultiBoxLoss_combined.__init__": [[30, 41], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "overlap_thresh", ",", "prior_for_matching", ",", "bkg_label", ",", "neg_mining", ",", "neg_pos", ",", "neg_overlap", ",", "encode_target", ")", ":", "\n", "        ", "super", "(", "MultiBoxLoss_combined", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "threshold", "=", "overlap_thresh", "\n", "self", ".", "background_label", "=", "bkg_label", "\n", "self", ".", "encode_target", "=", "encode_target", "\n", "self", ".", "use_prior_for_matching", "=", "prior_for_matching", "\n", "self", ".", "do_neg_mining", "=", "neg_mining", "\n", "self", ".", "negpos_ratio", "=", "neg_pos", "\n", "self", ".", "neg_overlap", "=", "neg_overlap", "\n", "self", ".", "variance", "=", "[", "0.1", ",", "0.2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.modules.multibox_loss_combined.MultiBoxLoss_combined.forward": [[42, 125], ["loc_data.size", "priors.size", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "torch.BoolTensor().to", "range", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.smooth_l1_loss", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "conf_data.view", "obj_data.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "logit.view.view.view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "num_pos.sum", "anno.to", "utils.box_utils.match", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "loss_obj.view.view.view", "loss_obj.view.view.sort", "loss_idx.sort", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "batch_obj[].unsqueeze", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "batch_obj[].unsqueeze().expand_as", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.BoolTensor", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "obj_data.view", "torch.BoolTensor().to.long().view", "torch.BoolTensor().to.long().view", "torch.BoolTensor().to.long().view", "torch.clamp.expand_as", "torch.clamp.expand_as", "torch.clamp.expand_as", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.exp().sum", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.BoolTensor().to.view", "torch.BoolTensor().to.view", "torch.BoolTensor().to.view", "obj_t[].long", "batch_obj[].unsqueeze", "[].long", "torch.BoolTensor().to.long", "torch.BoolTensor().to.long", "torch.BoolTensor().to.long", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "pos.float"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.match"], ["", "def", "forward", "(", "self", ",", "predictions", ",", "priors", ",", "targets", ")", ":", "\n", "        ", "\"\"\"Multibox Loss\n        Args:\n            predictions (tuple): A tuple containing loc preds, conf preds,\n            and prior boxes from SSD net.\n                conf shape: torch.size(batch_size,num_priors,num_classes)\n                loc shape: torch.size(batch_size,num_priors,4)\n                priors shape: torch.size(num_priors,4)\n\n            ground_truth (tensor): Ground truth boxes and labels for a batch,\n                shape: [batch_size,num_objs,5] (last idx is the label).\n        \"\"\"", "\n", "# loc_data[batch_size, num_priors, 4]", "\n", "# conf_data[batch_size, num_priors, num_classes]", "\n", "# obj_data[batch_size, num_priors, 2]", "\n", "loc_data", ",", "conf_data", ",", "obj_data", "=", "predictions", "\n", "\n", "device", "=", "loc_data", ".", "device", "\n", "targets", "=", "[", "anno", ".", "to", "(", "device", ")", "for", "anno", "in", "targets", "]", "\n", "num", "=", "loc_data", ".", "size", "(", "0", ")", "\n", "num_priors", "=", "priors", ".", "size", "(", "0", ")", "\n", "\n", "# match priors (default boxes) and ground truth boxes", "\n", "loc_t", "=", "torch", ".", "Tensor", "(", "num", ",", "num_priors", ",", "4", ")", ".", "to", "(", "device", ")", "\n", "conf_t", "=", "torch", ".", "Tensor", "(", "num", ",", "num_priors", ",", "2", ")", ".", "to", "(", "device", ")", "\n", "obj_t", "=", "torch", ".", "BoolTensor", "(", "num", ",", "num_priors", ")", ".", "to", "(", "device", ")", "\n", "\n", "# match priors with gt", "\n", "for", "idx", "in", "range", "(", "num", ")", ":", "# batch_size", "\n", "            ", "truths", "=", "targets", "[", "idx", "]", "[", ":", ",", ":", "-", "2", "]", ".", "data", "# [obj_num, 4]", "\n", "labels", "=", "targets", "[", "idx", "]", "[", ":", ",", "-", "2", ":", "]", ".", "data", "# [obj_num]", "\n", "defaults", "=", "priors", ".", "data", "# [num_priors,4]", "\n", "match", "(", "self", ".", "threshold", ",", "truths", ",", "defaults", ",", "self", ".", "variance", ",", "labels", ",", "loc_t", ",", "conf_t", ",", "obj_t", ",", "idx", ")", "\n", "\n", "", "pos", "=", "(", "conf_t", "[", ":", ",", ":", ",", "0", "]", ">", "0", ")", ".", "bool", "(", ")", "# [num, num_priors]", "\n", "num_pos", "=", "(", "conf_t", "[", ":", ",", ":", ",", "1", "]", "*", "pos", ".", "float", "(", ")", ")", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", ".", "long", "(", ")", "\n", "\n", "# Localization Loss (Smooth L1)", "\n", "# Shape: [batch,num_priors,4]", "\n", "loc_p", "=", "loc_data", "[", "pos", "]", "\n", "loc_t", "=", "loc_t", "[", "pos", "]", "\n", "loss_l", "=", "F", ".", "smooth_l1_loss", "(", "loc_p", ",", "loc_t", ",", "reduction", "=", "'none'", ")", "\n", "weight_pos", "=", "conf_t", "[", "pos", "]", "[", ":", ",", "1", "]", "\n", "loss_l", "=", "torch", ".", "sum", "(", "torch", ".", "sum", "(", "loss_l", ",", "dim", "=", "1", ")", "*", "weight_pos", ")", "\n", "\n", "# Compute object loss across batch for hard negative mining", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "loss_obj", "=", "F", ".", "cross_entropy", "(", "obj_data", ".", "view", "(", "-", "1", ",", "2", ")", ",", "obj_t", ".", "long", "(", ")", ".", "view", "(", "-", "1", ")", ",", "reduction", "=", "'none'", ")", "\n", "# Hard Negative Mining", "\n", "loss_obj", "[", "obj_t", ".", "view", "(", "-", "1", ")", "]", "=", "0", "# filter out pos boxes (label>0) and ignored boxes (label=-1) for now", "\n", "loss_obj", "=", "loss_obj", ".", "view", "(", "num", ",", "-", "1", ")", "\n", "_", ",", "loss_idx", "=", "loss_obj", ".", "sort", "(", "1", ",", "descending", "=", "True", ")", "\n", "_", ",", "idx_rank", "=", "loss_idx", ".", "sort", "(", "1", ")", "\n", "num_neg", "=", "torch", ".", "clamp", "(", "self", ".", "negpos_ratio", "*", "num_pos", ",", "max", "=", "num_priors", "-", "1", ")", "\n", "neg", "=", "idx_rank", "<", "num_neg", ".", "expand_as", "(", "idx_rank", ")", "# [num, num_priors]", "\n", "\n", "# Object Loss Including Positive and Negative Examples", "\n", "", "mask", "=", "pos", "|", "neg", "\n", "weight", "=", "conf_t", "[", "mask", "]", "[", ":", ",", "1", "]", "\n", "loss_obj", "=", "torch", ".", "sum", "(", "F", ".", "cross_entropy", "(", "obj_data", "[", "mask", "]", ",", "obj_t", "[", "mask", "]", ".", "long", "(", ")", ",", "reduction", "=", "'none'", ")", "*", "weight", ")", "\n", "\n", "# Confidence Loss (cosine distance to classes center)", "\n", "# pos [num, num_priors]", "\n", "# conf_data [num, num_priors, feature_dim]", "\n", "batch_conf", "=", "conf_data", ".", "view", "(", "-", "1", ",", "self", ".", "num_classes", "-", "1", ")", "\n", "\n", "# Compute max conf across batch for hard negative mining (logit-combined)", "\n", "batch_obj", "=", "obj_data", ".", "view", "(", "-", "1", ",", "2", ")", "# [num*num_priors, 2]", "\n", "logit_0", "=", "batch_obj", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "+", "torch", ".", "log", "(", "\n", "torch", ".", "exp", "(", "batch_conf", ")", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "logit_k", "=", "batch_obj", "[", ":", ",", "1", "]", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "batch_conf", ")", "+", "batch_conf", "\n", "logit", "=", "torch", ".", "cat", "(", "(", "logit_0", ",", "logit_k", ")", ",", "1", ")", "\n", "\n", "# Confidence Loss Including Positive and Negative Examples", "\n", "logit", "=", "logit", ".", "view", "(", "num", ",", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "loss_c", "=", "torch", ".", "sum", "(", "F", ".", "cross_entropy", "(", "logit", "[", "mask", "]", ",", "conf_t", "[", "mask", "]", "[", ":", ",", "0", "]", ".", "long", "(", ")", ",", "reduction", "=", "'none'", ")", "*", "weight", ")", "\n", "\n", "N", "=", "num_pos", ".", "sum", "(", ")", "\n", "loss_l", "/=", "N", "\n", "loss_c", "/=", "N", "\n", "loss_obj", "/=", "N", "\n", "\n", "return", "{", "'loss_box_reg'", ":", "loss_l", ",", "'loss_cls'", ":", "loss_c", ",", "'loss_obj'", ":", "loss_obj", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.BasicConv.__init__": [[9, 15], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "dilation", "=", "1", ",", "groups", "=", "1", ",", "relu", "=", "True", ",", "bn", "=", "True", ",", "bias", "=", "False", ")", ":", "\n", "        ", "super", "(", "BasicConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "out_channels", "=", "out_planes", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "dilation", "=", "dilation", ",", "groups", "=", "groups", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "out_planes", ",", "eps", "=", "1e-5", ",", "momentum", "=", "0.01", ",", "affine", "=", "True", ")", "if", "bn", "else", "None", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "if", "relu", "else", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.BasicConv.forward": [[16, 23], ["RFB_Net_vgg.BasicConv.conv", "RFB_Net_vgg.BasicConv.bn", "RFB_Net_vgg.BasicConv.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv", "(", "x", ")", "\n", "if", "self", ".", "bn", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "bn", "(", "x", ")", "\n", "", "if", "self", ".", "relu", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.BasicRFB.__init__": [[28, 52], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "torch.ReLU", "torch.ReLU", "torch.ReLU", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "scale", "=", "0.1", ",", "visual", "=", "1", ")", ":", "\n", "        ", "super", "(", "BasicRFB", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "out_channels", "=", "out_planes", "\n", "inter_planes", "=", "in_planes", "//", "8", "\n", "self", ".", "branch0", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "2", "*", "inter_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ")", ",", "\n", "BasicConv", "(", "2", "*", "inter_planes", ",", "2", "*", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "visual", ",", "dilation", "=", "visual", ",", "relu", "=", "False", ")", "\n", ")", "\n", "self", ".", "branch1", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "inter_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "2", "*", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ")", ",", "\n", "BasicConv", "(", "2", "*", "inter_planes", ",", "2", "*", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "visual", "+", "1", ",", "dilation", "=", "visual", "+", "1", ",", "relu", "=", "False", ")", "\n", ")", "\n", "self", ".", "branch2", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "inter_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "(", "inter_planes", "//", "2", ")", "*", "3", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "BasicConv", "(", "(", "inter_planes", "//", "2", ")", "*", "3", ",", "2", "*", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ")", ",", "\n", "BasicConv", "(", "2", "*", "inter_planes", ",", "2", "*", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "2", "*", "visual", "+", "1", ",", "dilation", "=", "2", "*", "visual", "+", "1", ",", "relu", "=", "False", ")", "\n", ")", "\n", "\n", "self", ".", "ConvLinear", "=", "BasicConv", "(", "6", "*", "inter_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "relu", "=", "False", ")", "\n", "self", ".", "shortcut", "=", "BasicConv", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "relu", "=", "False", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.BasicRFB.forward": [[53, 65], ["RFB_Net_vgg.BasicRFB.branch0", "RFB_Net_vgg.BasicRFB.branch1", "RFB_Net_vgg.BasicRFB.branch2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "RFB_Net_vgg.BasicRFB.ConvLinear", "RFB_Net_vgg.BasicRFB.shortcut", "RFB_Net_vgg.BasicRFB.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x0", "=", "self", ".", "branch0", "(", "x", ")", "\n", "x1", "=", "self", ".", "branch1", "(", "x", ")", "\n", "x2", "=", "self", ".", "branch2", "(", "x", ")", "\n", "\n", "out", "=", "torch", ".", "cat", "(", "(", "x0", ",", "x1", ",", "x2", ")", ",", "1", ")", "\n", "out", "=", "self", ".", "ConvLinear", "(", "out", ")", "\n", "short", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "out", "*", "self", ".", "scale", "+", "short", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.BasicRFB_a.__init__": [[69, 99], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "torch.ReLU", "torch.ReLU", "torch.ReLU", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ",", "scale", "=", "0.1", ")", ":", "\n", "        ", "super", "(", "BasicRFB_a", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "out_channels", "=", "out_planes", "\n", "inter_planes", "=", "in_planes", "//", "4", "\n", "\n", "self", ".", "branch0", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "inter_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "relu", "=", "False", ")", "\n", ")", "\n", "self", ".", "branch1", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "inter_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "inter_planes", ",", "kernel_size", "=", "(", "3", ",", "1", ")", ",", "stride", "=", "1", ",", "padding", "=", "(", "1", ",", "0", ")", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "3", ",", "dilation", "=", "3", ",", "relu", "=", "False", ")", "\n", ")", "\n", "self", ".", "branch2", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "inter_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "inter_planes", ",", "kernel_size", "=", "(", "1", ",", "3", ")", ",", "stride", "=", "stride", ",", "padding", "=", "(", "0", ",", "1", ")", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "3", ",", "dilation", "=", "3", ",", "relu", "=", "False", ")", "\n", ")", "\n", "self", ".", "branch3", "=", "nn", ".", "Sequential", "(", "\n", "BasicConv", "(", "in_planes", ",", "inter_planes", "//", "2", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", ",", "\n", "BasicConv", "(", "inter_planes", "//", "2", ",", "(", "inter_planes", "//", "4", ")", "*", "3", ",", "kernel_size", "=", "(", "1", ",", "3", ")", ",", "stride", "=", "1", ",", "padding", "=", "(", "0", ",", "1", ")", ")", ",", "\n", "BasicConv", "(", "(", "inter_planes", "//", "4", ")", "*", "3", ",", "inter_planes", ",", "kernel_size", "=", "(", "3", ",", "1", ")", ",", "stride", "=", "stride", ",", "padding", "=", "(", "1", ",", "0", ")", ")", ",", "\n", "BasicConv", "(", "inter_planes", ",", "inter_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "5", ",", "dilation", "=", "5", ",", "relu", "=", "False", ")", "\n", ")", "\n", "\n", "self", ".", "ConvLinear", "=", "BasicConv", "(", "4", "*", "inter_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "relu", "=", "False", ")", "\n", "self", ".", "shortcut", "=", "BasicConv", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "relu", "=", "False", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.BasicRFB_a.forward": [[100, 113], ["RFB_Net_vgg.BasicRFB_a.branch0", "RFB_Net_vgg.BasicRFB_a.branch1", "RFB_Net_vgg.BasicRFB_a.branch2", "RFB_Net_vgg.BasicRFB_a.branch3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "RFB_Net_vgg.BasicRFB_a.ConvLinear", "RFB_Net_vgg.BasicRFB_a.shortcut", "RFB_Net_vgg.BasicRFB_a.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x0", "=", "self", ".", "branch0", "(", "x", ")", "\n", "x1", "=", "self", ".", "branch1", "(", "x", ")", "\n", "x2", "=", "self", ".", "branch2", "(", "x", ")", "\n", "x3", "=", "self", ".", "branch3", "(", "x", ")", "\n", "\n", "out", "=", "torch", ".", "cat", "(", "(", "x0", ",", "x1", ",", "x2", ",", "x3", ")", ",", "1", ")", "\n", "out", "=", "self", ".", "ConvLinear", "(", "out", ")", "\n", "short", "=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "out", "*", "self", ".", "scale", "+", "short", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.__init__": [[132, 189], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "RFB_Net_vgg.BasicRFB_a", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "RFB_Net_vgg.RFBNet.init_weight", "print", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "RFB_Net_vgg.RFBNet.theta.bias.data.fill_", "RFB_Net_vgg.RFBNet.phi.bias.data.fill_", "RFB_Net_vgg.RFBNet.g.bias.data.fill_", "RFB_Net_vgg.RFBNet.Wz.data.fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "RFB_Net_vgg.RFBNet.fc_base.weight.data.fill_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "RFB_Net_vgg.RFBNet.fc_base.bias.data.fill_", "RFB_Net_vgg.RFBNet.theta.bias.data.fill_", "RFB_Net_vgg.RFBNet.phi.bias.data.fill_", "RFB_Net_vgg.RFBNet.g.bias.data.fill_", "RFB_Net_vgg.RFBNet.Wz.data.fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.init_weight"], ["def", "__init__", "(", "self", ",", "args", ",", "size", ",", "base", ",", "extras", ",", "head", ",", "num_classes", ")", ":", "\n", "        ", "super", "(", "RFBNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "method", "=", "args", ".", "method", "\n", "self", ".", "phase", "=", "args", ".", "phase", "\n", "self", ".", "setting", "=", "args", ".", "setting", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "size", "=", "size", "\n", "\n", "if", "size", "==", "300", ":", "\n", "            ", "self", ".", "indicator", "=", "3", "\n", "", "elif", "size", "==", "512", ":", "\n", "            ", "self", ".", "indicator", "=", "5", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Error: Sorry only SSD300 and SSD512 are supported!\"", ")", "\n", "return", "\n", "# vgg network", "\n", "", "self", ".", "base", "=", "nn", ".", "ModuleList", "(", "base", ")", "\n", "# conv_4", "\n", "self", ".", "Norm", "=", "BasicRFB_a", "(", "512", ",", "512", ",", "stride", "=", "1", ",", "scale", "=", "1.0", ")", "\n", "self", ".", "extras", "=", "nn", ".", "ModuleList", "(", "extras", ")", "\n", "\n", "self", ".", "loc", "=", "nn", ".", "ModuleList", "(", "head", "[", "0", "]", ")", "\n", "self", ".", "conf", "=", "nn", ".", "ModuleList", "(", "head", "[", "1", "]", ")", "\n", "self", ".", "obj", "=", "nn", ".", "ModuleList", "(", "head", "[", "2", "]", ")", "\n", "self", ".", "init_weight", "(", ")", "\n", "if", "args", ".", "method", "==", "'ours'", "and", "args", ".", "phase", "==", "2", ":", "\n", "            ", "if", "args", ".", "setting", "==", "'transfer'", ":", "\n", "                ", "self", ".", "theta", "=", "nn", ".", "Linear", "(", "60", ",", "60", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Linear", "(", "60", ",", "60", ")", "\n", "self", ".", "g", "=", "nn", ".", "Linear", "(", "60", ",", "60", ")", "\n", "self", ".", "Wz", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "60", ")", ")", "\n", "self", ".", "OBJ_Target", "=", "nn", ".", "Linear", "(", "60", ",", "20", ",", "bias", "=", "False", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "[", "5", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "init", ".", "kaiming_normal_", "(", "self", ".", "theta", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "init", ".", "kaiming_normal_", "(", "self", ".", "phi", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "init", ".", "kaiming_normal_", "(", "self", ".", "g", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "self", ".", "theta", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "phi", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "g", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "Wz", ".", "data", ".", "fill_", "(", "0", ")", "\n", "", "elif", "args", ".", "setting", "==", "'incre'", ":", "\n", "                ", "self", ".", "fc_base", "=", "nn", ".", "Linear", "(", "15", ",", "15", ")", "\n", "self", ".", "theta", "=", "nn", ".", "Linear", "(", "15", ",", "15", ")", "\n", "self", ".", "phi", "=", "nn", ".", "Linear", "(", "15", ",", "15", ")", "\n", "self", ".", "g", "=", "nn", ".", "Linear", "(", "15", ",", "15", ")", "\n", "self", ".", "Wz", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "15", ")", ")", "\n", "self", ".", "OBJ_Target", "=", "nn", ".", "Linear", "(", "15", ",", "5", ",", "bias", "=", "False", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "[", "5", "]", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "fc_base", ".", "weight", ".", "data", ".", "fill_", "(", "0", ")", "\n", "init", ".", "kaiming_normal_", "(", "self", ".", "theta", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "init", ".", "kaiming_normal_", "(", "self", ".", "phi", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "init", ".", "kaiming_normal_", "(", "self", ".", "g", ".", "weight", ",", "mode", "=", "'fan_out'", ")", "\n", "self", ".", "fc_base", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "theta", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "phi", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "g", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "self", ".", "Wz", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.forward": [[190, 287], ["v.to", "v.size", "list", "list", "list", "list", "list", "range", "RFB_Net_vgg.RFBNet.Norm", "list.append", "range", "enumerate", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "len", "v", "zip", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.view", "torch.cat.view", "torch.cat.view", "conf_pool.view.view.view", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.softmax", "list.append", "l().permute().contiguous", "c().permute().contiguous", "o().permute().contiguous", "conf_pool.view.view.append", "o.view", "o.view", "o.view", "RFB_Net_vgg.RFBNet.theta", "RFB_Net_vgg.RFBNet.phi", "RFB_Net_vgg.RFBNet.g", "conf_phi.transpose", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "conf_novel.norm", "RFB_Net_vgg.RFBNet.OBJ_Target", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.softmax", "torch.functional.max_pool2d().permute().contiguous", "torch.functional.max_pool2d().permute().contiguous", "torch.functional.max_pool2d().permute().contiguous", "o.size", "o.size", "o.size", "o.view", "RFB_Net_vgg.RFBNet.fc_base", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.cat.view", "l().permute", "c().permute", "o().permute", "o.size", "torch.cat.view", "torch.cat.view", "torch.cat.view", "torch.functional.max_pool2d().permute", "torch.functional.max_pool2d().permute", "torch.functional.max_pool2d().permute", "l", "c", "o", "torch.functional.max_pool2d", "torch.functional.max_pool2d", "torch.functional.max_pool2d", "c"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ",", "init", "=", "False", ")", ":", "\n", "        ", "\"\"\"Applies network layers and ops on input image(s) x.\n\n        Args:\n            x: input image or batch of images. Shape: [batch,3*batch,300,300].\n\n        Return:\n            Depending on phase:\n            test:\n                list of concat outputs from:\n                    1: softmax layers, Shape: [batch*num_priors,num_classes]\n                    2: localization layers, Shape: [batch,num_priors*4]\n                    3: priorbox layers, Shape: [2,num_priors*4]\n\n            train:\n                list of concat outputs from:\n                    1: confidence layers, Shape: [batch*num_priors,num_classes]\n                    2: localization layers, Shape: [batch,num_priors*4]\n                    3: priorbox layers, Shape: [2,num_priors*4]\n        \"\"\"", "\n", "x", "=", "x", ".", "to", "(", "self", ".", "device", ")", "\n", "num", "=", "x", ".", "size", "(", "0", ")", "\n", "sources", "=", "list", "(", ")", "\n", "loc", "=", "list", "(", ")", "\n", "conf", "=", "list", "(", ")", "\n", "obj", "=", "list", "(", ")", "\n", "conf_pool", "=", "list", "(", ")", "\n", "\n", "# apply vgg up to conv4_3 relu", "\n", "for", "k", "in", "range", "(", "23", ")", ":", "\n", "            ", "x", "=", "self", ".", "base", "[", "k", "]", "(", "x", ")", "\n", "\n", "", "s", "=", "self", ".", "Norm", "(", "x", ")", "\n", "sources", ".", "append", "(", "s", ")", "\n", "\n", "# apply vgg up to fc7", "\n", "for", "k", "in", "range", "(", "23", ",", "len", "(", "self", ".", "base", ")", ")", ":", "\n", "            ", "x", "=", "self", ".", "base", "[", "k", "]", "(", "x", ")", "\n", "\n", "# apply extra layers and cache source layer outputs", "\n", "", "for", "k", ",", "v", "in", "enumerate", "(", "self", ".", "extras", ")", ":", "\n", "            ", "x", "=", "v", "(", "x", ")", "# a module that includes Relu", "\n", "if", "k", "<", "self", ".", "indicator", "or", "k", "%", "2", "==", "0", ":", "\n", "                ", "sources", ".", "append", "(", "x", ")", "\n", "\n", "", "", "kernel_size", "=", "[", "3", ",", "2", ",", "2", ",", "2", ",", "1", ",", "1", "]", "\n", "stride", "=", "[", "3", ",", "2", ",", "2", ",", "2", ",", "1", ",", "1", "]", "\n", "# apply multibox head to source layers", "\n", "for", "i", ",", "(", "x", ",", "l", ",", "c", ",", "o", ")", "in", "enumerate", "(", "zip", "(", "sources", ",", "self", ".", "loc", ",", "self", ".", "conf", ",", "self", ".", "obj", ")", ")", ":", "\n", "            ", "loc", ".", "append", "(", "l", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "# [num, map_size, map_size, 6*4]", "\n", "conf", ".", "append", "(", "c", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "# [num, map_size, map_size, 6*num_classes]", "\n", "obj", ".", "append", "(", "o", "(", "x", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "# [num, map_size, map_size, 6*2]", "\n", "if", "self", ".", "method", "==", "'ours'", "and", "self", ".", "phase", "==", "2", ":", "\n", "                ", "conf_pool", ".", "append", "(", "nn", ".", "functional", ".", "max_pool2d", "(", "c", "(", "x", ")", ",", "kernel_size", "=", "kernel_size", "[", "i", "]", ",", "stride", "=", "stride", "[", "i", "]", ",", "\n", "ceil_mode", "=", "True", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ")", "\n", "\n", "", "", "loc", "=", "torch", ".", "cat", "(", "[", "o", ".", "view", "(", "o", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "o", "in", "loc", "]", ",", "1", ")", "# concat all the output feature maps", "\n", "conf", "=", "torch", ".", "cat", "(", "[", "o", ".", "view", "(", "o", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "o", "in", "conf", "]", ",", "1", ")", "\n", "obj", "=", "torch", ".", "cat", "(", "[", "o", ".", "view", "(", "o", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "o", "in", "obj", "]", ",", "1", ")", "\n", "\n", "if", "init", ":", "\n", "            ", "return", "conf", ".", "view", "(", "num", ",", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "\n", "", "if", "self", ".", "method", "==", "'ours'", "and", "self", ".", "phase", "==", "2", ":", "\n", "            ", "conf_pool", "=", "torch", ".", "cat", "(", "[", "o", ".", "view", "(", "o", ".", "size", "(", "0", ")", ",", "-", "1", ")", "for", "o", "in", "conf_pool", "]", ",", "1", ")", "\n", "conf", "=", "conf", ".", "view", "(", "num", ",", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "conf_pool", "=", "conf_pool", ".", "view", "(", "num", ",", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "if", "self", ".", "setting", "==", "'incre'", ":", "\n", "                ", "conf_base", "=", "self", ".", "fc_base", "(", "conf", ")", "+", "conf", "\n", "", "conf_theta", "=", "self", ".", "theta", "(", "conf", ")", "+", "conf", "\n", "conf_phi", "=", "self", ".", "phi", "(", "conf_pool", ")", "+", "conf_pool", "\n", "conf_g", "=", "self", ".", "g", "(", "conf_pool", ")", "+", "conf_pool", "\n", "weight", "=", "torch", ".", "matmul", "(", "conf_theta", ",", "conf_phi", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "weight", "=", "nn", ".", "functional", ".", "softmax", "(", "weight", ",", "dim", "=", "2", ")", "\n", "delta_conf", "=", "torch", ".", "matmul", "(", "weight", ",", "conf_g", ")", "*", "self", ".", "Wz", "\n", "conf_novel", "=", "conf", "+", "delta_conf", "\n", "conf_novel", "=", "conf_novel", "/", "conf_novel", ".", "norm", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", "# [num, num_priors, feature_dim]", "\n", "conf_novel", "=", "self", ".", "OBJ_Target", "(", "conf_novel", ")", "*", "self", ".", "scale", "# [num*num_priors, 20]", "\n", "if", "self", ".", "setting", "==", "'transfer'", ":", "\n", "                ", "conf", "=", "conf_novel", "\n", "", "elif", "self", ".", "setting", "==", "'incre'", ":", "\n", "                ", "conf", "=", "torch", ".", "cat", "(", "(", "conf_base", ",", "conf_novel", ")", ",", "dim", "=", "2", ")", "\n", "\n", "", "", "if", "self", ".", "training", ":", "\n", "            ", "output", "=", "(", "\n", "loc", ".", "view", "(", "num", ",", "-", "1", ",", "4", ")", ",", "\n", "conf", "if", "self", ".", "phase", "==", "2", "and", "self", ".", "method", "==", "'ours'", "else", "conf", ".", "view", "(", "num", ",", "-", "1", ",", "self", ".", "num_classes", ")", ",", "\n", "obj", ".", "view", "(", "num", ",", "-", "1", ",", "2", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "(", "\n", "loc", ".", "view", "(", "num", ",", "-", "1", ",", "4", ")", ",", "\n", "nn", ".", "functional", ".", "softmax", "(", "\n", "conf", "if", "self", ".", "phase", "==", "2", "and", "self", ".", "method", "==", "'ours'", "else", "conf", ".", "view", "(", "num", ",", "-", "1", ",", "self", ".", "num_classes", ")", ",", "dim", "=", "-", "1", ")", ",", "\n", "nn", ".", "functional", ".", "softmax", "(", "obj", ".", "view", "(", "num", ",", "-", "1", ",", "2", ")", ",", "dim", "=", "-", "1", ")", "\n", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.load_weights": [[288, 296], ["os.path.splitext", "print", "RFB_Net_vgg.RFBNet.load_state_dict", "print", "print", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load"], ["", "def", "load_weights", "(", "self", ",", "base_file", ")", ":", "\n", "        ", "other", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "base_file", ")", "\n", "if", "ext", "==", "'.pkl'", "or", "'.pth'", ":", "\n", "            ", "print", "(", "'Loading weights into state dict...'", ")", "\n", "self", ".", "load_state_dict", "(", "torch", ".", "load", "(", "base_file", ")", ")", "\n", "print", "(", "'Finished!'", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'Sorry only .pth and .pkl files supported.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.init_weight": [[297, 315], ["RFB_Net_vgg.RFBNet.base.apply", "RFB_Net_vgg.RFBNet.Norm.apply", "RFB_Net_vgg.RFBNet.extras.apply", "RFB_Net_vgg.RFBNet.loc.apply", "RFB_Net_vgg.RFBNet.conf.apply", "RFB_Net_vgg.RFBNet.obj.apply", "m.state_dict", "key.split", "torch.kaiming_normal_", "torch.kaiming_normal_", "torch.kaiming_normal_", "key.split", "m.state_dict", "m.state_dict", "m.state_dict"], "methods", ["None"], ["", "", "def", "init_weight", "(", "self", ")", ":", "\n", "        ", "def", "weights_init", "(", "m", ")", ":", "\n", "            ", "for", "key", "in", "m", ".", "state_dict", "(", ")", ":", "\n", "                ", "if", "key", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "==", "'weight'", ":", "\n", "                    ", "if", "'conv'", "in", "key", ":", "\n", "                        ", "init", ".", "kaiming_normal_", "(", "m", ".", "state_dict", "(", ")", "[", "key", "]", ",", "mode", "=", "'fan_out'", ")", "\n", "", "if", "'bn'", "in", "key", ":", "\n", "                        ", "m", ".", "state_dict", "(", ")", "[", "key", "]", "[", "...", "]", "=", "1", "\n", "", "", "elif", "key", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "==", "'bias'", ":", "\n", "                    ", "m", ".", "state_dict", "(", ")", "[", "key", "]", "[", "...", "]", "=", "0", "\n", "\n", "# initialize newly added layers' weights with kaiming_normal method", "\n", "", "", "", "self", ".", "base", ".", "apply", "(", "weights_init", ")", "\n", "self", ".", "Norm", ".", "apply", "(", "weights_init", ")", "\n", "self", ".", "extras", ".", "apply", "(", "weights_init", ")", "\n", "self", ".", "loc", ".", "apply", "(", "weights_init", ")", "\n", "self", ".", "conf", ".", "apply", "(", "weights_init", ")", "\n", "self", ".", "obj", ".", "apply", "(", "weights_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.RFBNet.normalize": [[316, 319], ["RFB_Net_vgg.RFBNet.OBJ_Target.weight.norm"], "methods", ["None"], ["", "def", "normalize", "(", "self", ")", ":", "\n", "        ", "self", ".", "OBJ_Target", ".", "weight", ".", "data", "=", "self", ".", "OBJ_Target", ".", "weight", "/", "self", ".", "OBJ_Target", ".", "weight", ".", "norm", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.vgg": [[323, 344], ["torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.Conv2d", "torch.MaxPool2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU"], "function", ["None"], ["", "", "def", "vgg", "(", "cfg", ",", "i", ",", "batch_norm", "=", "False", ")", ":", "\n", "    ", "layers", "=", "[", "]", "\n", "in_channels", "=", "i", "\n", "for", "v", "in", "cfg", ":", "\n", "        ", "if", "v", "==", "'M'", ":", "\n", "            ", "layers", "+=", "[", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "]", "\n", "", "elif", "v", "==", "'C'", ":", "\n", "            ", "layers", "+=", "[", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", "]", "\n", "", "else", ":", "\n", "            ", "conv2d", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "v", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "if", "batch_norm", ":", "\n", "                ", "layers", "+=", "[", "conv2d", ",", "nn", ".", "BatchNorm2d", "(", "v", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", "\n", "", "else", ":", "\n", "                ", "layers", "+=", "[", "conv2d", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", "\n", "", "in_channels", "=", "v", "\n", "", "", "pool5", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "conv6", "=", "nn", ".", "Conv2d", "(", "512", ",", "1024", ",", "kernel_size", "=", "3", ",", "padding", "=", "6", ",", "dilation", "=", "6", ")", "\n", "conv7", "=", "nn", ".", "Conv2d", "(", "1024", ",", "1024", ",", "kernel_size", "=", "1", ")", "\n", "layers", "+=", "[", "pool5", ",", "conv6", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "conv7", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "]", "\n", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.add_extras": [[354, 379], ["enumerate", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "print", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicConv", "RFB_Net_vgg.BasicRFB", "RFB_Net_vgg.BasicRFB", "RFB_Net_vgg.BasicRFB"], "function", ["None"], ["def", "add_extras", "(", "size", ",", "cfg", ",", "in_channels", ")", ":", "# in_channels = 1024", "\n", "# Extra layers added to VGG for feature scaling", "\n", "    ", "layers", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "enumerate", "(", "cfg", ")", ":", "\n", "        ", "if", "in_channels", "!=", "'S'", ":", "\n", "            ", "if", "v", "==", "'S'", ":", "\n", "                ", "if", "in_channels", "==", "256", "and", "size", "==", "512", ":", "\n", "                    ", "layers", "+=", "[", "BasicRFB", "(", "in_channels", ",", "cfg", "[", "k", "+", "1", "]", ",", "stride", "=", "2", ",", "scale", "=", "1.0", ",", "visual", "=", "1", ")", "]", "\n", "", "else", ":", "\n", "                    ", "layers", "+=", "[", "BasicRFB", "(", "in_channels", ",", "cfg", "[", "k", "+", "1", "]", ",", "stride", "=", "2", ",", "scale", "=", "1.0", ",", "visual", "=", "2", ")", "]", "\n", "", "", "else", ":", "\n", "                ", "layers", "+=", "[", "BasicRFB", "(", "in_channels", ",", "v", ",", "scale", "=", "1.0", ",", "visual", "=", "2", ")", "]", "\n", "", "", "in_channels", "=", "v", "\n", "", "if", "size", "==", "512", ":", "\n", "        ", "layers", "+=", "[", "BasicConv", "(", "256", ",", "128", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "]", "\n", "layers", "+=", "[", "BasicConv", "(", "128", ",", "256", ",", "kernel_size", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "]", "\n", "", "elif", "size", "==", "300", ":", "\n", "        ", "layers", "+=", "[", "BasicConv", "(", "256", ",", "128", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "]", "\n", "layers", "+=", "[", "BasicConv", "(", "128", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ")", "]", "\n", "layers", "+=", "[", "BasicConv", "(", "256", ",", "128", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ")", "]", "\n", "layers", "+=", "[", "BasicConv", "(", "128", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ")", "]", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Error: Sorry only RFBNet300 and RFBNet512 are supported!\"", ")", "\n", "return", "\n", "", "return", "layers", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.multibox": [[387, 417], ["enumerate", "enumerate", "print", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "function", ["None"], ["def", "multibox", "(", "size", ",", "vgg", ",", "extra_layers", ",", "cfg", ",", "num_classes", ")", ":", "\n", "    ", "loc_layers", "=", "[", "]", "\n", "conf_layers", "=", "[", "]", "\n", "obj_layers", "=", "[", "]", "\n", "vgg_source", "=", "[", "-", "2", "]", "# the last but one layer of vgg network", "\n", "for", "k", ",", "v", "in", "enumerate", "(", "vgg_source", ")", ":", "\n", "        ", "if", "k", "==", "0", ":", "\n", "            ", "loc_layers", "+=", "[", "nn", ".", "Conv2d", "(", "512", ",", "cfg", "[", "k", "]", "*", "4", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "conf_layers", "+=", "[", "nn", ".", "Conv2d", "(", "512", ",", "cfg", "[", "k", "]", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "obj_layers", "+=", "[", "nn", ".", "Conv2d", "(", "512", ",", "cfg", "[", "k", "]", "*", "2", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "", "else", ":", "\n", "            ", "loc_layers", "+=", "[", "nn", ".", "Conv2d", "(", "vgg", "[", "v", "]", ".", "out_channels", ",", "cfg", "[", "k", "]", "*", "4", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "conf_layers", "+=", "[", "nn", ".", "Conv2d", "(", "vgg", "[", "v", "]", ".", "out_channels", ",", "cfg", "[", "k", "]", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "obj_layers", "+=", "[", "nn", ".", "Conv2d", "(", "vgg", "[", "v", "]", ".", "out_channels", ",", "cfg", "[", "k", "]", "*", "2", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "", "", "i", "=", "1", "\n", "if", "size", "==", "300", ":", "\n", "        ", "indicator", "=", "3", "\n", "", "elif", "size", "==", "512", ":", "\n", "        ", "indicator", "=", "5", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"Error: Sorry only RFBNet300 and RFBNet512 are supported!\"", ")", "\n", "return", "\n", "\n", "", "for", "k", ",", "v", "in", "enumerate", "(", "extra_layers", ")", ":", "\n", "        ", "if", "k", "<", "indicator", "or", "k", "%", "2", "==", "0", ":", "\n", "            ", "loc_layers", "+=", "[", "nn", ".", "Conv2d", "(", "v", ".", "out_channels", ",", "cfg", "[", "i", "]", "*", "4", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "conf_layers", "+=", "[", "nn", ".", "Conv2d", "(", "v", ".", "out_channels", ",", "cfg", "[", "i", "]", "*", "num_classes", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "obj_layers", "+=", "[", "nn", ".", "Conv2d", "(", "v", ".", "out_channels", ",", "cfg", "[", "i", "]", "*", "2", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "]", "\n", "i", "+=", "1", "\n", "", "", "return", "vgg", ",", "extra_layers", ",", "(", "loc_layers", ",", "conf_layers", ",", "obj_layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.build_net": [[425, 433], ["RFB_Net_vgg.RFBNet", "print", "RFB_Net_vgg.multibox", "RFB_Net_vgg.vgg", "RFB_Net_vgg.add_extras", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.multibox", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.vgg", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.models.RFB_Net_vgg.add_extras"], ["def", "build_net", "(", "args", ",", "size", ",", "num_classes", ")", ":", "\n", "    ", "if", "size", "!=", "300", "and", "size", "!=", "512", ":", "\n", "        ", "print", "(", "\"Error: Sorry only RFBNet300 and RFBNet512 are supported!\"", ")", "\n", "return", "\n", "\n", "", "return", "RFBNet", "(", "args", ",", "size", ",", "*", "multibox", "(", "size", ",", "vgg", "(", "base", "[", "str", "(", "size", ")", "]", ",", "3", ")", ",", "\n", "add_extras", "(", "size", ",", "extras", "[", "str", "(", "size", ")", "]", ",", "1024", ")", ",", "\n", "mbox", "[", "str", "(", "size", ")", "]", ",", "num_classes", ")", ",", "num_classes", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.preproc.__init__": [[166, 170], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "resize", ",", "rgb_means", ",", "p", ")", ":", "\n", "        ", "self", ".", "means", "=", "rgb_means", "\n", "self", ".", "resize", "=", "resize", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.preproc.__call__": [[171, 222], ["targets[].copy", "targets[].copy", "preproc_for_test.copy", "targets.copy", "numpy.expand_dims", "numpy.hstack", "data_augment._distort", "data_augment._expand", "data_augment._mirror", "data_augment.preproc_for_test", "boxes.copy.copy.copy", "labels[].copy", "numpy.expand_dims", "numpy.hstack", "data_augment._crop", "data_augment._crop", "numpy.minimum", "torch.from_numpy", "len", "data_augment.preproc_for_test", "data_augment.preproc_for_test", "torch.from_numpy", "len", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._distort", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._expand", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._mirror", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.preproc_for_test", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._crop", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._crop", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.preproc_for_test", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.preproc_for_test"], ["", "def", "__call__", "(", "self", ",", "image", ",", "targets", ",", "cls", "=", "None", ")", ":", "\n", "        ", "boxes", "=", "targets", "[", ":", ",", ":", "-", "1", "]", ".", "copy", "(", ")", "\n", "labels", "=", "targets", "[", ":", ",", "-", "1", "]", ".", "copy", "(", ")", "\n", "\n", "# TODO can share the procedure of convert the box to percent format", "\n", "# convert to percent format, o means origin image", "\n", "image_o", "=", "image", ".", "copy", "(", ")", "\n", "targets_o", "=", "targets", ".", "copy", "(", ")", "\n", "height_o", ",", "width_o", ",", "_", "=", "image_o", ".", "shape", "\n", "boxes_o", "=", "targets_o", "[", ":", ",", ":", "-", "1", "]", "\n", "labels_o", "=", "targets_o", "[", ":", ",", "-", "1", "]", "\n", "boxes_o", "[", ":", ",", "0", ":", ":", "2", "]", "/=", "width_o", "\n", "boxes_o", "[", ":", ",", "1", ":", ":", "2", "]", "/=", "height_o", "\n", "labels_o", "=", "np", ".", "expand_dims", "(", "labels_o", ",", "1", ")", "\n", "targets_o", "=", "np", ".", "hstack", "(", "(", "boxes_o", ",", "labels_o", ")", ")", "\n", "\n", "if", "cls", "is", "None", ":", "\n", "            ", "image_t", ",", "boxes", ",", "labels", "=", "_crop", "(", "image", ",", "boxes", ",", "labels", ")", "\n", "", "else", ":", "\n", "            ", "image_t", ",", "boxes", ",", "labels", "=", "_crop", "(", "image", ",", "boxes", ",", "labels", ",", "cls", ")", "\n", "\n", "", "image_t", "=", "_distort", "(", "image_t", ")", "# image channels undergo linear transform, also change the saturability", "\n", "\n", "image_t", ",", "boxes", "=", "_expand", "(", "image_t", ",", "boxes", ",", "self", ".", "means", ",", "self", ".", "p", ")", "\n", "\n", "image_t", ",", "boxes", "=", "_mirror", "(", "image_t", ",", "boxes", ")", "\n", "\n", "height", ",", "width", ",", "_", "=", "image_t", ".", "shape", "\n", "image_t", "=", "preproc_for_test", "(", "image_t", ",", "self", ".", "resize", ",", "self", ".", "means", ")", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "/=", "width", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", "/=", "height", "\n", "b_w", "=", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "*", "1.", "\n", "b_h", "=", "(", "boxes", "[", ":", ",", "3", "]", "-", "boxes", "[", ":", ",", "1", "]", ")", "*", "1.", "\n", "mask_b", "=", "np", ".", "minimum", "(", "b_w", ",", "b_h", ")", ">", "0.01", "\n", "boxes_t", "=", "boxes", "[", "mask_b", "]", "\n", "labels_t", "=", "labels", "[", "mask_b", "]", ".", "copy", "(", ")", "\n", "\n", "if", "cls", "is", "None", ":", "\n", "            ", "if", "len", "(", "boxes_t", ")", "==", "0", ":", "\n", "                ", "image", "=", "preproc_for_test", "(", "image_o", ",", "self", ".", "resize", ",", "self", ".", "means", ")", "\n", "return", "torch", ".", "from_numpy", "(", "image", ")", ",", "targets_o", "\n", "", "", "else", ":", "\n", "            ", "if", "len", "(", "boxes_t", ")", "==", "0", "or", "(", "labels_t", "!=", "(", "cls", "+", "1", ")", ")", ".", "all", "(", ")", ":", "\n", "                ", "image", "=", "preproc_for_test", "(", "image_o", ",", "self", ".", "resize", ",", "self", ".", "means", ")", "\n", "return", "torch", ".", "from_numpy", "(", "image", ")", ",", "targets_o", "\n", "\n", "", "", "labels_t", "=", "np", ".", "expand_dims", "(", "labels_t", ",", "1", ")", "\n", "targets_t", "=", "np", ".", "hstack", "(", "(", "boxes_t", ",", "labels_t", ")", ")", "\n", "\n", "return", "torch", ".", "from_numpy", "(", "image_t", ")", ",", "targets_t", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.BaseTransform.__init__": [[239, 243], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "resize", ",", "rgb_means", ",", "swap", "=", "(", "2", ",", "0", ",", "1", ")", ")", ":", "\n", "        ", "self", ".", "means", "=", "rgb_means", "\n", "self", ".", "resize", "=", "resize", "\n", "self", ".", "swap", "=", "swap", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.BaseTransform.__call__": [[245, 267], ["cv2.resize().astype", "img.transpose.transpose.transpose", "numpy.expand_dims", "numpy.hstack", "torch.from_numpy", "cv2.resize", "torch.from_numpy", "numpy.array"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img", ",", "target", "=", "None", ")", ":", "\n", "\n", "        ", "if", "target", "is", "not", "None", ":", "\n", "            ", "height", ",", "width", ",", "_", "=", "img", ".", "shape", "\n", "boxes", "=", "target", "[", ":", ",", ":", "-", "1", "]", "\n", "labels", "=", "target", "[", ":", ",", "-", "1", "]", "\n", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "/=", "width", "\n", "boxes", "[", ":", ",", "1", ":", ":", "2", "]", "/=", "height", "\n", "labels", "=", "np", ".", "expand_dims", "(", "labels", ",", "1", ")", "\n", "targets", "=", "np", ".", "hstack", "(", "(", "boxes", ",", "labels", ")", ")", "\n", "\n", "", "interp_methods", "=", "[", "cv2", ".", "INTER_LINEAR", ",", "cv2", ".", "INTER_CUBIC", ",", "cv2", ".", "INTER_AREA", ",", "cv2", ".", "INTER_NEAREST", ",", "cv2", ".", "INTER_LANCZOS4", "]", "\n", "interp_method", "=", "interp_methods", "[", "0", "]", "\n", "img", "=", "cv2", ".", "resize", "(", "np", ".", "array", "(", "img", ")", ",", "(", "self", ".", "resize", ",", "\n", "self", ".", "resize", ")", ",", "interpolation", "=", "interp_method", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "img", "-=", "self", ".", "means", "\n", "img", "=", "img", ".", "transpose", "(", "self", ".", "swap", ")", "\n", "\n", "if", "target", "is", "not", "None", ":", "\n", "            ", "return", "torch", ".", "from_numpy", "(", "img", ")", ",", "targets", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "from_numpy", "(", "img", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._crop": [[18, 79], ["len", "random.choice", "range", "float", "float", "random.uniform", "max", "min", "math.sqrt", "int", "int", "random.randrange", "random.randrange", "numpy.array", "utils.box_utils.matrix_iou", "numpy.logical_and().all", "boxes[].copy", "labels[].copy", "numpy.maximum", "numpy.minimum", "random.uniform", "numpy.logical_and", "len", "utils.box_utils.matrix_iou.min", "utils.box_utils.matrix_iou.max", "len"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.box_utils.matrix_iou"], ["def", "_crop", "(", "image", ",", "boxes", ",", "labels", ",", "cls", "=", "None", ")", ":", "\n", "    ", "height", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "\n", "if", "len", "(", "boxes", ")", "==", "0", ":", "\n", "        ", "return", "image", ",", "boxes", ",", "labels", "\n", "\n", "", "while", "True", ":", "\n", "        ", "mode", "=", "random", ".", "choice", "(", "(", "\n", "None", ",", "\n", "(", "0.1", ",", "None", ")", ",", "\n", "(", "0.3", ",", "None", ")", ",", "\n", "(", "0.5", ",", "None", ")", ",", "\n", "(", "0.7", ",", "None", ")", ",", "\n", "(", "0.9", ",", "None", ")", ",", "\n", "(", "None", ",", "None", ")", ",", "\n", ")", ")", "\n", "\n", "if", "mode", "is", "None", ":", "\n", "            ", "return", "image", ",", "boxes", ",", "labels", "\n", "\n", "", "min_iou", ",", "max_iou", "=", "mode", "\n", "if", "min_iou", "is", "None", ":", "\n", "            ", "min_iou", "=", "float", "(", "'-inf'", ")", "\n", "", "if", "max_iou", "is", "None", ":", "\n", "            ", "max_iou", "=", "float", "(", "'inf'", ")", "\n", "\n", "", "for", "_", "in", "range", "(", "50", ")", ":", "\n", "            ", "scale", "=", "random", ".", "uniform", "(", "0.3", ",", "1.", ")", "\n", "min_ratio", "=", "max", "(", "0.5", ",", "scale", "*", "scale", ")", "# aspect radio", "\n", "max_ratio", "=", "min", "(", "2", ",", "1.", "/", "scale", "/", "scale", ")", "\n", "ratio", "=", "math", ".", "sqrt", "(", "random", ".", "uniform", "(", "min_ratio", ",", "max_ratio", ")", ")", "\n", "w", "=", "int", "(", "scale", "*", "ratio", "*", "width", ")", "\n", "h", "=", "int", "(", "(", "scale", "/", "ratio", ")", "*", "height", ")", "\n", "l", "=", "random", ".", "randrange", "(", "width", "-", "w", ")", "\n", "t", "=", "random", ".", "randrange", "(", "height", "-", "h", ")", "\n", "roi", "=", "np", ".", "array", "(", "(", "l", ",", "t", ",", "l", "+", "w", ",", "t", "+", "h", ")", ")", "\n", "\n", "iou", "=", "matrix_iou", "(", "boxes", ",", "roi", "[", "np", ".", "newaxis", "]", ")", "# roi[1, 4]", "\n", "\n", "if", "not", "(", "min_iou", "<=", "iou", ".", "min", "(", ")", "and", "iou", ".", "max", "(", ")", "<=", "max_iou", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "image_t", "=", "image", "[", "roi", "[", "1", "]", ":", "roi", "[", "3", "]", ",", "roi", "[", "0", "]", ":", "roi", "[", "2", "]", "]", "\n", "centers", "=", "(", "boxes", "[", ":", ",", ":", "2", "]", "+", "boxes", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "mask", "=", "np", ".", "logical_and", "(", "roi", "[", ":", "2", "]", "<", "centers", ",", "centers", "<", "roi", "[", "2", ":", "]", ")", ".", "all", "(", "axis", "=", "1", ")", "# filter out those centers that are out of the roi area", "\n", "boxes_t", "=", "boxes", "[", "mask", "]", ".", "copy", "(", ")", "\n", "labels_t", "=", "labels", "[", "mask", "]", ".", "copy", "(", ")", "\n", "if", "cls", "is", "None", ":", "\n", "                ", "if", "len", "(", "boxes_t", ")", "==", "0", ":", "\n", "                    ", "continue", "\n", "", "", "else", ":", "\n", "                ", "if", "len", "(", "boxes_t", ")", "==", "0", "or", "(", "labels_t", "!=", "(", "cls", "+", "1", ")", ")", ".", "all", "(", ")", ":", "\n", "                    ", "continue", "\n", "\n", "", "", "boxes_t", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "boxes_t", "[", ":", ",", ":", "2", "]", ",", "roi", "[", ":", "2", "]", ")", "\n", "boxes_t", "[", ":", ",", ":", "2", "]", "-=", "roi", "[", ":", "2", "]", "\n", "boxes_t", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "boxes_t", "[", ":", ",", "2", ":", "]", ",", "roi", "[", "2", ":", "]", ")", "\n", "boxes_t", "[", ":", ",", "2", ":", "]", "-=", "roi", "[", ":", "2", "]", "\n", "\n", "return", "image_t", ",", "boxes_t", ",", "labels_t", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._distort": [[81, 109], ["cv2.cvtColor.copy", "random.randrange", "random.randrange", "cv2.cvtColor", "random.randrange", "random.randrange", "cv2.cvtColor", "data_augment._distort._convert"], "function", ["None"], ["", "", "", "def", "_distort", "(", "image", ")", ":", "\n", "    ", "def", "_convert", "(", "image", ",", "alpha", "=", "1", ",", "beta", "=", "0", ")", ":", "\n", "        ", "tmp", "=", "image", ".", "astype", "(", "float", ")", "*", "alpha", "+", "beta", "\n", "tmp", "[", "tmp", "<", "0", "]", "=", "0", "\n", "tmp", "[", "tmp", ">", "255", "]", "=", "255", "\n", "image", "[", ":", "]", "=", "tmp", "\n", "\n", "", "image", "=", "image", ".", "copy", "(", ")", "\n", "\n", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "        ", "_convert", "(", "image", ",", "beta", "=", "random", ".", "uniform", "(", "-", "32", ",", "32", ")", ")", "\n", "\n", "", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "        ", "_convert", "(", "image", ",", "alpha", "=", "random", ".", "uniform", "(", "0.5", ",", "1.5", ")", ")", "\n", "\n", "", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_BGR2HSV", ")", "\n", "\n", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "        ", "tmp", "=", "image", "[", ":", ",", ":", ",", "0", "]", ".", "astype", "(", "int", ")", "+", "random", ".", "randint", "(", "-", "18", ",", "18", ")", "\n", "tmp", "%=", "180", "\n", "image", "[", ":", ",", ":", ",", "0", "]", "=", "tmp", "\n", "\n", "", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "        ", "_convert", "(", "image", "[", ":", ",", ":", ",", "1", "]", ",", "alpha", "=", "random", ".", "uniform", "(", "0.5", ",", "1.5", ")", ")", "\n", "\n", "", "image", "=", "cv2", ".", "cvtColor", "(", "image", ",", "cv2", ".", "COLOR_HSV2BGR", ")", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._expand": [[111, 144], ["random.random", "random.uniform", "max", "min", "math.sqrt", "int", "int", "random.randint", "random.randint", "boxes.copy", "numpy.empty", "random.uniform"], "function", ["None"], ["", "def", "_expand", "(", "image", ",", "boxes", ",", "fill", ",", "p", ")", ":", "\n", "    ", "if", "random", ".", "random", "(", ")", ">", "p", ":", "\n", "        ", "return", "image", ",", "boxes", "\n", "\n", "", "height", ",", "width", ",", "depth", "=", "image", ".", "shape", "\n", "while", "True", ":", "\n", "        ", "scale", "=", "random", ".", "uniform", "(", "1", ",", "4", ")", "\n", "\n", "min_ratio", "=", "max", "(", "0.5", ",", "1.", "/", "scale", "/", "scale", ")", "\n", "max_ratio", "=", "min", "(", "2", ",", "scale", "*", "scale", ")", "\n", "ratio", "=", "math", ".", "sqrt", "(", "random", ".", "uniform", "(", "min_ratio", ",", "max_ratio", ")", ")", "# [0.5, 2]", "\n", "ws", "=", "scale", "*", "ratio", "\n", "hs", "=", "scale", "/", "ratio", "\n", "if", "ws", "<", "1", "or", "hs", "<", "1", ":", "\n", "            ", "continue", "\n", "", "w", "=", "int", "(", "ws", "*", "width", ")", "\n", "h", "=", "int", "(", "hs", "*", "height", ")", "\n", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w", "-", "width", ")", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h", "-", "height", ")", "\n", "\n", "boxes_t", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes_t", "[", ":", ",", ":", "2", "]", "+=", "(", "left", ",", "top", ")", "\n", "boxes_t", "[", ":", ",", "2", ":", "]", "+=", "(", "left", ",", "top", ")", "\n", "\n", "expand_image", "=", "np", ".", "empty", "(", "\n", "(", "h", ",", "w", ",", "depth", ")", ",", "\n", "dtype", "=", "image", ".", "dtype", ")", "\n", "expand_image", "[", ":", ",", ":", "]", "=", "fill", "\n", "expand_image", "[", "top", ":", "top", "+", "height", ",", "left", ":", "left", "+", "width", "]", "=", "image", "\n", "image", "=", "expand_image", "\n", "\n", "return", "image", ",", "boxes_t", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment._mirror": [[146, 153], ["random.randrange", "boxes.copy.copy"], "function", ["None"], ["", "", "def", "_mirror", "(", "image", ",", "boxes", ")", ":", "\n", "    ", "_", ",", "width", ",", "_", "=", "image", ".", "shape", "\n", "if", "random", ".", "randrange", "(", "2", ")", ":", "\n", "        ", "image", "=", "image", "[", ":", ",", ":", ":", "-", "1", "]", "\n", "boxes", "=", "boxes", ".", "copy", "(", ")", "\n", "boxes", "[", ":", ",", "0", ":", ":", "2", "]", "=", "width", "-", "boxes", "[", ":", ",", "2", ":", ":", "-", "2", "]", "\n", "", "return", "image", ",", "boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.data_augment.preproc_for_test": [[155, 162], ["cv2.resize", "image.astype.astype", "image.astype.transpose", "random.randrange"], "function", ["None"], ["", "def", "preproc_for_test", "(", "image", ",", "insize", ",", "mean", ")", ":", "\n", "    ", "interp_methods", "=", "[", "cv2", ".", "INTER_LINEAR", ",", "cv2", ".", "INTER_CUBIC", ",", "cv2", ".", "INTER_AREA", ",", "cv2", ".", "INTER_NEAREST", ",", "cv2", ".", "INTER_LANCZOS4", "]", "\n", "interp_method", "=", "interp_methods", "[", "random", ".", "randrange", "(", "5", ")", "]", "\n", "image", "=", "cv2", ".", "resize", "(", "image", ",", "(", "insize", ",", "insize", ")", ",", "interpolation", "=", "interp_method", ")", "\n", "image", "=", "image", ".", "astype", "(", "np", ".", "float32", ")", "\n", "image", "-=", "mean", "\n", "return", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection.__init__": [[88, 111], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "list", "list", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "utils.pycocotools.coco.COCO", "coco.COCODetection._get_coco_instances_meta", "len", "sorted", "coco.COCODetection._COCO.loadImgs", "coco.COCODetection.ids.extend", "coco.COCODetection.annotations.extend", "coco.COCODetection._COCO.imgs.keys", "coco.COCODetection._load_coco_annotations", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._get_coco_instances_meta", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadImgs", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._load_coco_annotations"], ["self", ".", "createIndex", "(", ")", "\n", "\n", "", "", "def", "createIndex", "(", "self", ")", ":", "\n", "# create index", "\n", "        ", "print", "(", "'creating index...'", ")", "\n", "anns", ",", "cats", ",", "imgs", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "imgToAnns", ",", "catToImgs", "=", "defaultdict", "(", "list", ")", ",", "defaultdict", "(", "list", ")", "\n", "if", "'annotations'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", ":", "\n", "                ", "imgToAnns", "[", "ann", "[", "'image_id'", "]", "]", ".", "append", "(", "ann", ")", "\n", "anns", "[", "ann", "[", "'id'", "]", "]", "=", "ann", "\n", "\n", "", "", "if", "'images'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "img", "in", "self", ".", "dataset", "[", "'images'", "]", ":", "\n", "                ", "imgs", "[", "img", "[", "'id'", "]", "]", "=", "img", "\n", "\n", "", "", "if", "'categories'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "cat", "in", "self", ".", "dataset", "[", "'categories'", "]", ":", "\n", "                ", "cats", "[", "cat", "[", "'id'", "]", "]", "=", "cat", "\n", "\n", "", "", "if", "'annotations'", "in", "self", ".", "dataset", "and", "'categories'", "in", "self", ".", "dataset", ":", "\n", "            ", "for", "ann", "in", "self", ".", "dataset", "[", "'annotations'", "]", ":", "\n", "                ", "catToImgs", "[", "ann", "[", "'category_id'", "]", "]", ".", "append", "(", "ann", "[", "'image_id'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._load_coco_annotations": [[112, 128], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "print", "print", "coco.COCODetection._annotation_from_index", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "open", "pickle.dump", "open", "pickle.load", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._annotation_from_index", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load"], ["", "", "print", "(", "'index created!'", ")", "\n", "\n", "# create class members", "\n", "self", ".", "anns", "=", "anns", "\n", "self", ".", "imgToAnns", "=", "imgToAnns", "\n", "self", ".", "catToImgs", "=", "catToImgs", "\n", "self", ".", "imgs", "=", "imgs", "\n", "self", ".", "cats", "=", "cats", "\n", "\n", "", "def", "info", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Print information about the annotation file.\n        :return:\n        \"\"\"", "\n", "for", "key", ",", "value", "in", "self", ".", "dataset", "[", "'info'", "]", ".", "items", "(", ")", ":", "\n", "            ", "print", "(", "'{}: {}'", ".", "format", "(", "key", ",", "value", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._get_coco_instances_meta": [[129, 147], ["coco.COCODetection._COCO.getCatIds", "coco.COCODetection._COCO.loadCats", "dict", "tuple", "zip", "enumerate", "range"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getCatIds", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadCats"], ["", "", "def", "getAnnIds", "(", "self", ",", "imgIds", "=", "[", "]", ",", "catIds", "=", "[", "]", ",", "areaRng", "=", "[", "]", ",", "iscrowd", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Get ann ids that satisfy given filter conditions. default skips that filter\n        :param imgIds  (int array)     : get anns for given imgs\n               catIds  (int array)     : get anns for given cats\n               areaRng (float array)   : get anns for given area range (e.g. [0 inf])\n               iscrowd (boolean)       : get anns for given crowd label (False or True)\n        :return: ids (int array)       : integer array of ann ids\n        \"\"\"", "\n", "imgIds", "=", "imgIds", "if", "_isArrayLike", "(", "imgIds", ")", "else", "[", "imgIds", "]", "\n", "catIds", "=", "catIds", "if", "_isArrayLike", "(", "catIds", ")", "else", "[", "catIds", "]", "\n", "\n", "if", "len", "(", "imgIds", ")", "==", "len", "(", "catIds", ")", "==", "len", "(", "areaRng", ")", "==", "0", ":", "\n", "            ", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "else", ":", "\n", "            ", "if", "not", "len", "(", "imgIds", ")", "==", "0", ":", "\n", "                ", "lists", "=", "[", "self", ".", "imgToAnns", "[", "imgId", "]", "for", "imgId", "in", "imgIds", "if", "imgId", "in", "self", ".", "imgToAnns", "]", "\n", "anns", "=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "lists", ")", ")", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._annotation_from_index": [[148, 183], ["_COCO.getAnnIds", "_COCO.loadAnns", "len", "numpy.zeros", "enumerate", "_COCO.loadImgs", "numpy.max", "numpy.max", "numpy.min", "numpy.min", "valid_objs.append", "numpy.max", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.getAnnIds", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadAnns", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadImgs"], ["                ", "anns", "=", "self", ".", "dataset", "[", "'annotations'", "]", "\n", "", "anns", "=", "anns", "if", "len", "(", "catIds", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'category_id'", "]", "in", "catIds", "]", "\n", "anns", "=", "anns", "if", "len", "(", "areaRng", ")", "==", "0", "else", "[", "ann", "for", "ann", "in", "anns", "if", "ann", "[", "'area'", "]", ">", "areaRng", "[", "0", "]", "and", "ann", "[", "'area'", "]", "<", "areaRng", "[", "1", "]", "]", "\n", "", "if", "iscrowd", "is", "not", "None", ":", "\n", "            ", "ids", "=", "[", "ann", "[", "'id'", "]", "for", "ann", "in", "anns", "if", "ann", "[", "'iscrowd'", "]", "==", "iscrowd", "]", "\n", "", "else", ":", "\n", "            ", "ids", "=", "[", "ann", "[", "'id'", "]", "for", "ann", "in", "anns", "]", "\n", "", "return", "ids", "\n", "\n", "", "def", "getCatIds", "(", "self", ",", "catNms", "=", "[", "]", ",", "supNms", "=", "[", "]", ",", "catIds", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        filtering parameters. default skips that filter.\n        :param catNms (str array)  : get cats for given cat names\n        :param supNms (str array)  : get cats for given supercategory names\n        :param catIds (int array)  : get cats for given cat ids\n        :return: ids (int array)   : integer array of cat ids\n        \"\"\"", "\n", "catNms", "=", "catNms", "if", "_isArrayLike", "(", "catNms", ")", "else", "[", "catNms", "]", "\n", "supNms", "=", "supNms", "if", "_isArrayLike", "(", "supNms", ")", "else", "[", "supNms", "]", "\n", "catIds", "=", "catIds", "if", "_isArrayLike", "(", "catIds", ")", "else", "[", "catIds", "]", "\n", "\n", "if", "len", "(", "catNms", ")", "==", "len", "(", "supNms", ")", "==", "len", "(", "catIds", ")", "==", "0", ":", "\n", "            ", "cats", "=", "self", ".", "dataset", "[", "'categories'", "]", "\n", "", "else", ":", "\n", "            ", "cats", "=", "self", ".", "dataset", "[", "'categories'", "]", "\n", "cats", "=", "cats", "if", "len", "(", "catNms", ")", "==", "0", "else", "[", "cat", "for", "cat", "in", "cats", "if", "cat", "[", "'name'", "]", "in", "catNms", "]", "\n", "cats", "=", "cats", "if", "len", "(", "supNms", ")", "==", "0", "else", "[", "cat", "for", "cat", "in", "cats", "if", "cat", "[", "'supercategory'", "]", "in", "supNms", "]", "\n", "cats", "=", "cats", "if", "len", "(", "catIds", ")", "==", "0", "else", "[", "cat", "for", "cat", "in", "cats", "if", "cat", "[", "'id'", "]", "in", "catIds", "]", "\n", "", "ids", "=", "[", "cat", "[", "'id'", "]", "for", "cat", "in", "cats", "]", "\n", "return", "ids", "\n", "\n", "", "def", "getImgIds", "(", "self", ",", "imgIds", "=", "[", "]", ",", "catIds", "=", "[", "]", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection.__getitem__": [[184, 201], ["cv2.imread", "numpy.ones", "numpy.hstack", "coco.COCODetection.target_transform", "coco.COCODetection.preproc"], "methods", ["None"], ["\n", "imgIds", "=", "imgIds", "if", "_isArrayLike", "(", "imgIds", ")", "else", "[", "imgIds", "]", "\n", "catIds", "=", "catIds", "if", "_isArrayLike", "(", "catIds", ")", "else", "[", "catIds", "]", "\n", "\n", "if", "len", "(", "imgIds", ")", "==", "len", "(", "catIds", ")", "==", "0", ":", "\n", "            ", "ids", "=", "self", ".", "imgs", ".", "keys", "(", ")", "\n", "", "else", ":", "\n", "            ", "ids", "=", "set", "(", "imgIds", ")", "\n", "for", "i", ",", "catId", "in", "enumerate", "(", "catIds", ")", ":", "\n", "                ", "if", "i", "==", "0", "and", "len", "(", "ids", ")", "==", "0", ":", "\n", "                    ", "ids", "=", "set", "(", "self", ".", "catToImgs", "[", "catId", "]", ")", "\n", "", "else", ":", "\n", "                    ", "ids", "&=", "set", "(", "self", ".", "catToImgs", "[", "catId", "]", ")", "\n", "", "", "", "return", "list", "(", "ids", ")", "\n", "\n", "", "def", "loadAnns", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection.__len__": [[202, 204], ["len"], "methods", ["None"], []], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection.pull_image": [[205, 218], ["cv2.imread"], "methods", ["None"], ["\n", "if", "_isArrayLike", "(", "ids", ")", ":", "\n", "            ", "return", "[", "self", ".", "anns", "[", "id", "]", "for", "id", "in", "ids", "]", "\n", "", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "            ", "return", "[", "self", ".", "anns", "[", "ids", "]", "]", "\n", "\n", "", "", "def", "loadCats", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        Load cats with the specified ids.\n        :param ids (int array)       : integer ids specifying cats\n        :return: cats (object array) : loaded cat objects\n        \"\"\"", "\n", "if", "_isArrayLike", "(", "ids", ")", ":", "\n", "            ", "return", "[", "self", ".", "cats", "[", "id", "]", "for", "id", "in", "ids", "]", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection.pull_tensor": [[219, 231], ["torch.Tensor().unsqueeze_", "torch.Tensor().unsqueeze_", "torch.Tensor().unsqueeze_", "torch.Tensor().unsqueeze_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "coco.COCODetection.pull_image"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.pull_image"], ["", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "            ", "return", "[", "self", ".", "cats", "[", "ids", "]", "]", "\n", "\n", "", "", "def", "loadImgs", "(", "self", ",", "ids", "=", "[", "]", ")", ":", "\n", "        ", "\"\"\"\n        Load anns with the specified ids.\n        :param ids (int array)       : integer ids specifying img\n        :return: imgs (object array) : loaded img objects\n        \"\"\"", "\n", "if", "_isArrayLike", "(", "ids", ")", ":", "\n", "            ", "return", "[", "self", ".", "imgs", "[", "id", "]", "for", "id", "in", "ids", "]", "\n", "", "elif", "type", "(", "ids", ")", "==", "int", ":", "\n", "            ", "return", "[", "self", ".", "imgs", "[", "ids", "]", "]", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._do_detection_eval": [[232, 241], ["coco.COCODetection._COCO.loadRes", "utils.pycocotools.cocoeval.COCOeval", "utils.pycocotools.cocoeval.COCOeval.evaluate", "utils.pycocotools.cocoeval.COCOeval.accumulate", "utils.pycocotools.cocoeval.COCOeval.summarize", "collections.OrderedDict", "coco.COCODetection._derive_coco_results", "coco.print_csv_format"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.coco.COCO.loadRes", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.evaluate", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.accumulate", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.pycocotools.cocoeval.COCOeval.summarize", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._derive_coco_results", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.print_csv_format"], ["\n", "", "", "def", "showAnns", "(", "self", ",", "anns", ")", ":", "\n", "        ", "\"\"\"\n        Display the specified annotations.\n        :param anns (array of object): annotations to display\n        :return: None\n        \"\"\"", "\n", "if", "len", "(", "anns", ")", "==", "0", ":", "\n", "            ", "return", "0", "\n", "", "if", "'segmentation'", "in", "anns", "[", "0", "]", "or", "'keypoints'", "in", "anns", "[", "0", "]", ":", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._coco_results_one_category": [[242, 259], ["enumerate", "boxes[].astype", "results.extend", "range"], "methods", ["None"], ["            ", "datasetType", "=", "'instances'", "\n", "", "elif", "'caption'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "datasetType", "=", "'captions'", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'datasetType not supported'", ")", "\n", "", "if", "datasetType", "==", "'instances'", ":", "\n", "            ", "ax", "=", "plt", ".", "gca", "(", ")", "\n", "ax", ".", "set_autoscale_on", "(", "False", ")", "\n", "polygons", "=", "[", "]", "\n", "color", "=", "[", "]", "\n", "for", "ann", "in", "anns", ":", "\n", "                ", "c", "=", "(", "np", ".", "random", ".", "random", "(", "(", "1", ",", "3", ")", ")", "*", "0.6", "+", "0.4", ")", ".", "tolist", "(", ")", "[", "0", "]", "\n", "if", "'segmentation'", "in", "ann", ":", "\n", "                    ", "if", "type", "(", "ann", "[", "'segmentation'", "]", ")", "==", "list", ":", "\n", "# polygon", "\n", "                        ", "for", "seg", "in", "ann", "[", "'segmentation'", "]", ":", "\n", "                            ", "poly", "=", "np", ".", "array", "(", "seg", ")", ".", "reshape", "(", "(", "int", "(", "len", "(", "seg", ")", "/", "2", ")", ",", "2", ")", ")", "\n", "polygons", ".", "append", "(", "Polygon", "(", "poly", ")", ")", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._write_coco_results_file": [[260, 275], ["enumerate", "print", "print", "results.extend", "open", "json.dump", "fid.flush", "coco.COCODetection._coco_results_one_category"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._coco_results_one_category"], ["color", ".", "append", "(", "c", ")", "\n", "", "", "else", ":", "\n", "# mask", "\n", "                        ", "t", "=", "self", ".", "imgs", "[", "ann", "[", "'image_id'", "]", "]", "\n", "if", "type", "(", "ann", "[", "'segmentation'", "]", "[", "'counts'", "]", ")", "==", "list", ":", "\n", "                            ", "rle", "=", "maskUtils", ".", "frPyObjects", "(", "[", "ann", "[", "'segmentation'", "]", "]", ",", "t", "[", "'height'", "]", ",", "t", "[", "'width'", "]", ")", "\n", "", "else", ":", "\n", "                            ", "rle", "=", "[", "ann", "[", "'segmentation'", "]", "]", "\n", "", "m", "=", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "img", "=", "np", ".", "ones", "(", "(", "m", ".", "shape", "[", "0", "]", ",", "m", ".", "shape", "[", "1", "]", ",", "3", ")", ")", "\n", "if", "ann", "[", "'iscrowd'", "]", "==", "1", ":", "\n", "                            ", "color_mask", "=", "np", ".", "array", "(", "[", "2.0", ",", "166.0", ",", "101.0", "]", ")", "/", "255", "\n", "", "if", "ann", "[", "'iscrowd'", "]", "==", "0", ":", "\n", "                            ", "color_mask", "=", "np", ".", "random", ".", "random", "(", "(", "1", ",", "3", ")", ")", ".", "tolist", "(", ")", "[", "0", "]", "\n", "", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "                            ", "img", "[", ":", ",", ":", ",", "i", "]", "=", "color_mask", "[", "i", "]", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection.evaluate_detections": [[276, 283], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "coco.COCODetection._write_coco_results_file", "coco.COCODetection.coco_name.find", "coco.COCODetection._do_detection_eval"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._write_coco_results_file", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._do_detection_eval"], ["", "ax", ".", "imshow", "(", "np", ".", "dstack", "(", "(", "img", ",", "m", "*", "0.5", ")", ")", ")", "\n", "", "", "if", "'keypoints'", "in", "ann", "and", "type", "(", "ann", "[", "'keypoints'", "]", ")", "==", "list", ":", "\n", "# turn skeleton into zero-based index", "\n", "                    ", "sks", "=", "np", ".", "array", "(", "self", ".", "loadCats", "(", "ann", "[", "'category_id'", "]", ")", "[", "0", "]", "[", "'skeleton'", "]", ")", "-", "1", "\n", "kp", "=", "np", ".", "array", "(", "ann", "[", "'keypoints'", "]", ")", "\n", "x", "=", "kp", "[", "0", ":", ":", "3", "]", "\n", "y", "=", "kp", "[", "1", ":", ":", "3", "]", "\n", "v", "=", "kp", "[", "2", ":", ":", "3", "]", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.COCODetection._derive_coco_results": [[284, 346], ["print", "zip", "min", "list", "itertools.zip_longest", "tabulate.tabulate.tabulate", "print", "results.update", "print", "float", "results_per_category.append", "itertools.chain", "enumerate", "coco.create_small_table", "len", "numpy.mean", "float", "len", "float", "range"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.HistoryBuffer.update", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.create_small_table"], ["for", "sk", "in", "sks", ":", "\n", "                        ", "if", "np", ".", "all", "(", "v", "[", "sk", "]", ">", "0", ")", ":", "\n", "                            ", "plt", ".", "plot", "(", "x", "[", "sk", "]", ",", "y", "[", "sk", "]", ",", "linewidth", "=", "3", ",", "color", "=", "c", ")", "\n", "", "", "plt", ".", "plot", "(", "x", "[", "v", ">", "0", "]", ",", "y", "[", "v", ">", "0", "]", ",", "'o'", ",", "markersize", "=", "8", ",", "markerfacecolor", "=", "c", ",", "markeredgecolor", "=", "'k'", ",", "markeredgewidth", "=", "2", ")", "\n", "plt", ".", "plot", "(", "x", "[", "v", ">", "1", "]", ",", "y", "[", "v", ">", "1", "]", ",", "'o'", ",", "markersize", "=", "8", ",", "markerfacecolor", "=", "c", ",", "markeredgecolor", "=", "c", ",", "markeredgewidth", "=", "2", ")", "\n", "", "", "p", "=", "PatchCollection", "(", "polygons", ",", "facecolor", "=", "color", ",", "linewidths", "=", "0", ",", "alpha", "=", "0.4", ")", "\n", "ax", ".", "add_collection", "(", "p", ")", "\n", "p", "=", "PatchCollection", "(", "polygons", ",", "facecolor", "=", "'none'", ",", "edgecolors", "=", "color", ",", "linewidths", "=", "2", ")", "\n", "ax", ".", "add_collection", "(", "p", ")", "\n", "", "elif", "datasetType", "==", "'captions'", ":", "\n", "            ", "for", "ann", "in", "anns", ":", "\n", "                ", "print", "(", "ann", "[", "'caption'", "]", ")", "\n", "\n", "", "", "", "def", "loadRes", "(", "self", ",", "resFile", ")", ":", "\n", "        ", "\"\"\"\n        Load result file and return a result api object.\n        :param   resFile (str)     : file name of result file\n        :return: res (obj)         : result api object\n        \"\"\"", "\n", "res", "=", "COCO", "(", ")", "\n", "res", ".", "dataset", "[", "'images'", "]", "=", "[", "img", "for", "img", "in", "self", ".", "dataset", "[", "'images'", "]", "]", "\n", "\n", "print", "(", "'Loading and preparing results...'", ")", "\n", "tic", "=", "time", ".", "time", "(", ")", "\n", "if", "type", "(", "resFile", ")", "==", "str", "or", "(", "PYTHON_VERSION", "==", "2", "and", "type", "(", "resFile", ")", "==", "unicode", ")", ":", "\n", "            ", "anns", "=", "json", ".", "load", "(", "open", "(", "resFile", ")", ")", "\n", "", "elif", "type", "(", "resFile", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "anns", "=", "self", ".", "loadNumpyAnnotations", "(", "resFile", ")", "\n", "", "else", ":", "\n", "            ", "anns", "=", "resFile", "\n", "", "assert", "type", "(", "anns", ")", "==", "list", ",", "'results in not an array of objects'", "\n", "annsImgIds", "=", "[", "ann", "[", "'image_id'", "]", "for", "ann", "in", "anns", "]", "\n", "assert", "set", "(", "annsImgIds", ")", "==", "(", "set", "(", "annsImgIds", ")", "&", "set", "(", "self", ".", "getImgIds", "(", ")", ")", ")", ",", "'Results do not correspond to current coco set'", "\n", "if", "'caption'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "imgIds", "=", "set", "(", "[", "img", "[", "'id'", "]", "for", "img", "in", "res", ".", "dataset", "[", "'images'", "]", "]", ")", "&", "set", "(", "[", "ann", "[", "'image_id'", "]", "for", "ann", "in", "anns", "]", ")", "\n", "res", ".", "dataset", "[", "'images'", "]", "=", "[", "img", "for", "img", "in", "res", ".", "dataset", "[", "'images'", "]", "if", "img", "[", "'id'", "]", "in", "imgIds", "]", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "                ", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "", "", "elif", "'bbox'", "in", "anns", "[", "0", "]", "and", "not", "anns", "[", "0", "]", "[", "'bbox'", "]", "==", "[", "]", ":", "\n", "            ", "res", ".", "dataset", "[", "'categories'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "dataset", "[", "'categories'", "]", ")", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "                ", "bb", "=", "ann", "[", "'bbox'", "]", "\n", "x1", ",", "x2", ",", "y1", ",", "y2", "=", "[", "bb", "[", "0", "]", ",", "bb", "[", "0", "]", "+", "bb", "[", "2", "]", ",", "bb", "[", "1", "]", ",", "bb", "[", "1", "]", "+", "bb", "[", "3", "]", "]", "\n", "if", "not", "'segmentation'", "in", "ann", ":", "\n", "                    ", "ann", "[", "'segmentation'", "]", "=", "[", "[", "x1", ",", "y1", ",", "x1", ",", "y2", ",", "x2", ",", "y2", ",", "x2", ",", "y1", "]", "]", "\n", "", "ann", "[", "'area'", "]", "=", "bb", "[", "2", "]", "*", "bb", "[", "3", "]", "\n", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "ann", "[", "'iscrowd'", "]", "=", "0", "\n", "", "", "elif", "'segmentation'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "res", ".", "dataset", "[", "'categories'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "dataset", "[", "'categories'", "]", ")", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "# now only support compressed RLE format as segmentation results", "\n", "                ", "ann", "[", "'area'", "]", "=", "maskUtils", ".", "area", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "if", "not", "'bbox'", "in", "ann", ":", "\n", "                    ", "ann", "[", "'bbox'", "]", "=", "maskUtils", ".", "toBbox", "(", "ann", "[", "'segmentation'", "]", ")", "\n", "", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "ann", "[", "'iscrowd'", "]", "=", "0", "\n", "", "", "elif", "'keypoints'", "in", "anns", "[", "0", "]", ":", "\n", "            ", "res", ".", "dataset", "[", "'categories'", "]", "=", "copy", ".", "deepcopy", "(", "self", ".", "dataset", "[", "'categories'", "]", ")", "\n", "for", "id", ",", "ann", "in", "enumerate", "(", "anns", ")", ":", "\n", "                ", "s", "=", "ann", "[", "'keypoints'", "]", "\n", "x", "=", "s", "[", "0", ":", ":", "3", "]", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.create_small_table": [[348, 369], ["tuple", "tabulate.tabulate", "zip", "small_dict.items"], "function", ["None"], ["x0", ",", "x1", ",", "y0", ",", "y1", "=", "np", ".", "min", "(", "x", ")", ",", "np", ".", "max", "(", "x", ")", ",", "np", ".", "min", "(", "y", ")", ",", "np", ".", "max", "(", "y", ")", "\n", "ann", "[", "'area'", "]", "=", "(", "x1", "-", "x0", ")", "*", "(", "y1", "-", "y0", ")", "\n", "ann", "[", "'id'", "]", "=", "id", "+", "1", "\n", "ann", "[", "'bbox'", "]", "=", "[", "x0", ",", "y0", ",", "x1", "-", "x0", ",", "y1", "-", "y0", "]", "\n", "", "", "print", "(", "'DONE (t={:0.2f}s)'", ".", "format", "(", "time", ".", "time", "(", ")", "-", "tic", ")", ")", "\n", "\n", "res", ".", "dataset", "[", "'annotations'", "]", "=", "anns", "\n", "res", ".", "createIndex", "(", ")", "\n", "return", "res", "\n", "\n", "", "def", "download", "(", "self", ",", "tarDir", "=", "None", ",", "imgIds", "=", "[", "]", ")", ":", "\n", "        ", "'''\n        Download COCO images from mscoco.org server.\n        :param tarDir (str): COCO results directory name\n               imgIds (list): images to be downloaded\n        :return:\n        '''", "\n", "if", "tarDir", "is", "None", ":", "\n", "            ", "print", "(", "'Please specify target directory'", ")", "\n", "return", "-", "1", "\n", "", "if", "len", "(", "imgIds", ")", "==", "0", ":", "\n", "            ", "imgs", "=", "self", ".", "imgs", ".", "values", "(", ")", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.coco.print_csv_format": [[371, 386], ["isinstance", "results.items", "print", "print", "print", "res.items"], "function", ["None"], ["            ", "imgs", "=", "self", ".", "loadImgs", "(", "imgIds", ")", "\n", "", "N", "=", "len", "(", "imgs", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "tarDir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "tarDir", ")", "\n", "", "for", "i", ",", "img", "in", "enumerate", "(", "imgs", ")", ":", "\n", "            ", "tic", "=", "time", ".", "time", "(", ")", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "tarDir", ",", "img", "[", "'file_name'", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "fname", ")", ":", "\n", "                ", "urlretrieve", "(", "img", "[", "'coco_url'", "]", ",", "fname", ")", "\n", "", "print", "(", "'downloaded {}/{} images (t={:0.1f}s)'", ".", "format", "(", "i", ",", "N", ",", "time", ".", "time", "(", ")", "-", "tic", ")", ")", "\n", "\n", "", "", "def", "loadNumpyAnnotations", "(", "self", ",", "data", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc_eval.parse_rec": [[13, 31], ["xml.parse", "ET.parse.findall", "int", "int", "obj.find", "objects.append", "obj.find", "obj.find", "int", "int", "int", "int", "obj.find", "obj.find", "obj.find.find", "obj.find.find", "obj.find.find", "obj.find.find"], "function", ["None"], ["def", "parse_rec", "(", "filename", ")", ":", "\n", "    ", "\"\"\" Parse a PASCAL VOC xml file \"\"\"", "\n", "tree", "=", "ET", ".", "parse", "(", "filename", ")", "\n", "objects", "=", "[", "]", "\n", "for", "obj", "in", "tree", ".", "findall", "(", "'object'", ")", ":", "\n", "        ", "obj_struct", "=", "{", "}", "\n", "obj_struct", "[", "'name'", "]", "=", "obj", ".", "find", "(", "'name'", ")", ".", "text", "\n", "obj_struct", "[", "'pose'", "]", "=", "obj", ".", "find", "(", "'pose'", ")", ".", "text", "\n", "obj_struct", "[", "'truncated'", "]", "=", "int", "(", "obj", ".", "find", "(", "'truncated'", ")", ".", "text", ")", "\n", "obj_struct", "[", "'difficult'", "]", "=", "int", "(", "obj", ".", "find", "(", "'difficult'", ")", ".", "text", ")", "\n", "bbox", "=", "obj", ".", "find", "(", "'bndbox'", ")", "\n", "obj_struct", "[", "'bbox'", "]", "=", "[", "int", "(", "bbox", ".", "find", "(", "'xmin'", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "'ymin'", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "'xmax'", ")", ".", "text", ")", ",", "\n", "int", "(", "bbox", ".", "find", "(", "'ymax'", ")", ".", "text", ")", "]", "\n", "objects", ".", "append", "(", "obj_struct", ")", "\n", "\n", "", "return", "objects", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc_eval.voc_ap": [[33, 65], ["numpy.arange", "numpy.concatenate", "numpy.concatenate", "range", "numpy.sum", "numpy.maximum", "numpy.where", "numpy.sum", "numpy.max"], "function", ["None"], ["", "def", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\" ap = voc_ap(rec, prec, [use_07_metric])\n    Compute VOC AP given precision and recall.\n    If use_07_metric is true, uses the\n    VOC 07 11 point method (default:False).\n    \"\"\"", "\n", "if", "use_07_metric", ":", "\n", "# 11 point metric", "\n", "        ", "ap", "=", "0.", "\n", "for", "t", "in", "np", ".", "arange", "(", "0.", ",", "1.1", ",", "0.1", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "rec", ">=", "t", ")", "==", "0", ":", "\n", "                ", "p", "=", "0", "\n", "", "else", ":", "\n", "                ", "p", "=", "np", ".", "max", "(", "prec", "[", "rec", ">=", "t", "]", ")", "\n", "", "ap", "=", "ap", "+", "p", "/", "11.", "\n", "", "", "else", ":", "\n", "# correct AP calculation", "\n", "# first append sentinel values at the end", "\n", "        ", "mrec", "=", "np", ".", "concatenate", "(", "(", "[", "0.", "]", ",", "rec", ",", "[", "1.", "]", ")", ")", "\n", "mpre", "=", "np", ".", "concatenate", "(", "(", "[", "0.", "]", ",", "prec", ",", "[", "0.", "]", ")", ")", "\n", "\n", "# compute the precision envelope", "\n", "for", "i", "in", "range", "(", "mpre", ".", "size", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", "i", "-", "1", "]", "=", "np", ".", "maximum", "(", "mpre", "[", "i", "-", "1", "]", ",", "mpre", "[", "i", "]", ")", "\n", "\n", "# to calculate area under PR curve, look for points", "\n", "# where X axis (recall) changes value", "\n", "", "i", "=", "np", ".", "where", "(", "mrec", "[", "1", ":", "]", "!=", "mrec", "[", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "\n", "# and sum (\\Delta recall) * prec", "\n", "ap", "=", "np", ".", "sum", "(", "(", "mrec", "[", "i", "+", "1", "]", "-", "mrec", "[", "i", "]", ")", "*", "mpre", "[", "i", "+", "1", "]", ")", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc_eval.voc_eval": [[67, 204], ["os.path.join", "detpath.format", "numpy.array", "numpy.array", "numpy.argsort", "len", "numpy.zeros", "numpy.zeros", "range", "numpy.cumsum", "numpy.cumsum", "voc_eval.voc_ap", "os.path.isdir", "os.mkdir", "open", "f.readlines", "x.strip", "os.path.isfile", "enumerate", "print", "numpy.array", "numpy.array().astype", "open", "f.readlines", "x.strip().split", "BB[].astype", "R[].astype", "float", "numpy.maximum", "voc_eval.parse_rec", "open", "pickle.dump", "open", "pickle.load", "len", "sum", "float", "numpy.maximum", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.maximum", "numpy.maximum", "numpy.max", "numpy.argmax", "annopath.format", "print", "numpy.array", "x.strip", "float", "numpy.finfo", "len"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc_eval.voc_ap", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc_eval.parse_rec", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load"], ["", "def", "voc_eval", "(", "detpath", ",", "\n", "annopath", ",", "\n", "imagesetfile", ",", "\n", "classname", ",", "\n", "cachedir", ",", "\n", "ovthresh", "=", "0.5", ",", "\n", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\"rec, prec, ap = voc_eval(detpath,\n                                annopath,\n                                imagesetfile,\n                                classname,\n                                [ovthresh],\n                                [use_07_metric])\n\n    Top level function that does the PASCAL VOC evaluation.\n\n    detpath: Path to detections\n        detpath.format(classname) should produce the detection results file.\n    annopath: Path to annotations\n        annopath.format(imagename) should be the xml annotations file.\n    imagesetfile: Text file containing the list of images, one image per line.\n    classname: Category name (duh)\n    cachedir: Directory for caching the annotations\n    [ovthresh]: Overlap threshold (default = 0.5)\n    [use_07_metric]: Whether to use VOC07's 11 point AP computation\n        (default False)\n    \"\"\"", "\n", "# assumes detections are in detpath.format(classname)", "\n", "# assumes annotations are in annopath.format(imagename)", "\n", "# assumes imagesetfile is a text file with each line an image name", "\n", "# cachedir caches the annotations in a pickle file", "\n", "\n", "# first load gt", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "cachedir", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "cachedir", ")", "\n", "", "cachefile", "=", "os", ".", "path", ".", "join", "(", "cachedir", ",", "'annots.pkl'", ")", "\n", "# read list of images", "\n", "with", "open", "(", "imagesetfile", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "", "imagenames", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "lines", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "cachefile", ")", ":", "# extract the annots from .xml file and save to cache_file", "\n", "# load annots", "\n", "        ", "recs", "=", "{", "}", "\n", "for", "i", ",", "imagename", "in", "enumerate", "(", "imagenames", ")", ":", "\n", "            ", "recs", "[", "imagename", "]", "=", "parse_rec", "(", "annopath", ".", "format", "(", "imagename", ")", ")", "\n", "if", "i", "%", "100", "==", "0", ":", "\n", "                ", "print", "(", "'Reading annotation for {:d}/{:d}'", ".", "format", "(", "\n", "i", "+", "1", ",", "len", "(", "imagenames", ")", ")", ")", "\n", "# save", "\n", "", "", "print", "(", "'Saving cached annotations to {:s}'", ".", "format", "(", "cachefile", ")", ")", "\n", "with", "open", "(", "cachefile", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "recs", ",", "f", ")", "\n", "", "", "else", ":", "\n", "# load", "\n", "        ", "with", "open", "(", "cachefile", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "recs", "=", "pickle", ".", "load", "(", "f", ")", "\n", "\n", "# extract gt objects for this class", "\n", "", "", "class_recs", "=", "{", "}", "\n", "npos", "=", "0", "\n", "for", "imagename", "in", "imagenames", ":", "\n", "        ", "R", "=", "[", "obj", "for", "obj", "in", "recs", "[", "imagename", "]", "if", "obj", "[", "'name'", "]", "==", "classname", "]", "\n", "bbox", "=", "np", ".", "array", "(", "[", "x", "[", "'bbox'", "]", "for", "x", "in", "R", "]", ")", "\n", "difficult", "=", "np", ".", "array", "(", "[", "x", "[", "'difficult'", "]", "for", "x", "in", "R", "]", ")", ".", "astype", "(", "np", ".", "bool", ")", "\n", "det", "=", "[", "False", "]", "*", "len", "(", "R", ")", "\n", "npos", "=", "npos", "+", "sum", "(", "~", "difficult", ")", "\n", "class_recs", "[", "imagename", "]", "=", "{", "'bbox'", ":", "bbox", ",", "\n", "'difficult'", ":", "difficult", ",", "\n", "'det'", ":", "det", "}", "\n", "\n", "# read dets", "\n", "", "detfile", "=", "detpath", ".", "format", "(", "classname", ")", "\n", "with", "open", "(", "detfile", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "\n", "", "splitlines", "=", "[", "x", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "for", "x", "in", "lines", "]", "\n", "image_ids", "=", "[", "x", "[", "0", "]", "for", "x", "in", "splitlines", "]", "\n", "confidence", "=", "np", ".", "array", "(", "[", "float", "(", "x", "[", "1", "]", ")", "for", "x", "in", "splitlines", "]", ")", "\n", "BB", "=", "np", ".", "array", "(", "[", "[", "float", "(", "z", ")", "for", "z", "in", "x", "[", "2", ":", "]", "]", "for", "x", "in", "splitlines", "]", ")", "# image_ids confidence bbox", "\n", "\n", "# sort by confidence", "\n", "sorted_ind", "=", "np", ".", "argsort", "(", "-", "confidence", ")", "\n", "BB", "=", "BB", "[", "sorted_ind", ",", ":", "]", "if", "BB", ".", "size", "!=", "0", "else", "BB", "\n", "image_ids", "=", "[", "image_ids", "[", "x", "]", "for", "x", "in", "sorted_ind", "]", "\n", "\n", "# go down dets and mark TPs and FPs", "\n", "nd", "=", "len", "(", "image_ids", ")", "# number of detect boxes", "\n", "tp", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "fp", "=", "np", ".", "zeros", "(", "nd", ")", "\n", "for", "d", "in", "range", "(", "nd", ")", ":", "\n", "# if image_ids[d] in ids:", "\n", "        ", "R", "=", "class_recs", "[", "image_ids", "[", "d", "]", "]", "# a dict that consists of all groundtruth boxes that belong to this class in an image", "\n", "bb", "=", "BB", "[", "d", ",", ":", "]", ".", "astype", "(", "float", ")", "\n", "ovmax", "=", "-", "np", ".", "inf", "\n", "BBGT", "=", "R", "[", "'bbox'", "]", ".", "astype", "(", "float", ")", "\n", "\n", "if", "BBGT", ".", "size", ">", "0", ":", "\n", "# compute overlaps", "\n", "# intersection", "\n", "            ", "ixmin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "0", "]", ",", "bb", "[", "0", "]", ")", "\n", "iymin", "=", "np", ".", "maximum", "(", "BBGT", "[", ":", ",", "1", "]", ",", "bb", "[", "1", "]", ")", "\n", "ixmax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "2", "]", ",", "bb", "[", "2", "]", ")", "\n", "iymax", "=", "np", ".", "minimum", "(", "BBGT", "[", ":", ",", "3", "]", ",", "bb", "[", "3", "]", ")", "\n", "iw", "=", "np", ".", "maximum", "(", "ixmax", "-", "ixmin", "+", "1.", ",", "0.", ")", "\n", "ih", "=", "np", ".", "maximum", "(", "iymax", "-", "iymin", "+", "1.", ",", "0.", ")", "\n", "inters", "=", "iw", "*", "ih", "\n", "\n", "# union", "\n", "uni", "=", "(", "(", "bb", "[", "2", "]", "-", "bb", "[", "0", "]", "+", "1.", ")", "*", "(", "bb", "[", "3", "]", "-", "bb", "[", "1", "]", "+", "1.", ")", "+", "\n", "(", "BBGT", "[", ":", ",", "2", "]", "-", "BBGT", "[", ":", ",", "0", "]", "+", "1.", ")", "*", "\n", "(", "BBGT", "[", ":", ",", "3", "]", "-", "BBGT", "[", ":", ",", "1", "]", "+", "1.", ")", "-", "inters", ")", "\n", "\n", "overlaps", "=", "inters", "/", "uni", "\n", "ovmax", "=", "np", ".", "max", "(", "overlaps", ")", "\n", "jmax", "=", "np", ".", "argmax", "(", "overlaps", ")", "\n", "\n", "", "if", "ovmax", ">", "ovthresh", ":", "\n", "            ", "if", "not", "R", "[", "'difficult'", "]", "[", "jmax", "]", ":", "\n", "                ", "if", "not", "R", "[", "'det'", "]", "[", "jmax", "]", ":", "\n", "                    ", "tp", "[", "d", "]", "=", "1.", "\n", "R", "[", "'det'", "]", "[", "jmax", "]", "=", "1", "\n", "", "else", ":", "\n", "                    ", "fp", "[", "d", "]", "=", "1.", "\n", "", "", "", "else", ":", "\n", "            ", "fp", "[", "d", "]", "=", "1.", "\n", "\n", "# compute precision recall", "\n", "", "", "fp", "=", "np", ".", "cumsum", "(", "fp", ")", "\n", "tp", "=", "np", ".", "cumsum", "(", "tp", ")", "\n", "rec", "=", "tp", "/", "float", "(", "npos", ")", "\n", "# avoid divide by zero in case the first detection matches a difficult", "\n", "# ground truth", "\n", "prec", "=", "tp", "/", "np", ".", "maximum", "(", "tp", "+", "fp", ",", "np", ".", "finfo", "(", "np", ".", "float64", ")", ".", "eps", ")", "\n", "ap", "=", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", ")", "\n", "\n", "return", "rec", ",", "prec", ",", "ap", "\n", "", ""]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.split_coco_dataset_voc_nonvoc.split_dataset": [[13, 70], ["print", "print", "print", "set", "set", "print", "print", "open", "json.load", "print", "print", "open", "json.dump", "open", "json.dump", "range", "len", "len", "annotations_split1.append", "set.add", "images_split1.append", "images_split2.append", "len", "len", "len", "annotations_split2.append", "set.add", "Exception"], "function", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.checkpointer.DetectionCheckpointer.load"], ["def", "split_dataset", "(", "dataset_file", ",", "inds_split1", ",", "split1_file", ",", "split2_file", ")", ":", "\n", "    ", "print", "(", "'processing dataset'", ",", "dataset_file", ")", "\n", "\n", "with", "open", "(", "dataset_file", ")", "as", "f", ":", "\n", "        ", "dataset", "=", "json", ".", "load", "(", "f", ")", "\n", "", "categories", "=", "dataset", "[", "'categories'", "]", "\n", "inds_split2", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "categories", ")", ")", "if", "i", "not", "in", "inds_split1", "]", "\n", "\n", "categories_split1", "=", "[", "categories", "[", "i", "]", "for", "i", "in", "inds_split1", "]", "\n", "categories_split2", "=", "[", "categories", "[", "i", "]", "for", "i", "in", "inds_split2", "]", "\n", "cids_split1", "=", "[", "c", "[", "'id'", "]", "for", "c", "in", "categories_split1", "]", "\n", "cids_split2", "=", "[", "c", "[", "'id'", "]", "for", "c", "in", "categories_split2", "]", "\n", "print", "(", "'Split 1: {} classes'", ".", "format", "(", "len", "(", "categories_split1", ")", ")", ")", "\n", "for", "c", "in", "categories_split1", ":", "\n", "        ", "print", "(", "'\\t'", ",", "c", "[", "'name'", "]", ")", "\n", "", "print", "(", "'Split 2: {} classes'", ".", "format", "(", "len", "(", "categories_split2", ")", ")", ")", "\n", "for", "c", "in", "categories_split2", ":", "\n", "        ", "print", "(", "'\\t'", ",", "c", "[", "'name'", "]", ")", "\n", "\n", "", "annotations", "=", "dataset", "[", "'annotations'", "]", "\n", "annotations_split1", "=", "[", "]", "\n", "annotations_split2", "=", "[", "]", "\n", "image_id_split1", "=", "set", "(", ")", "\n", "image_id_split2", "=", "set", "(", ")", "\n", "\n", "for", "ann", "in", "annotations", ":", "\n", "        ", "if", "ann", "[", "'category_id'", "]", "in", "cids_split1", ":", "\n", "            ", "annotations_split1", ".", "append", "(", "ann", ")", "\n", "image_id_split1", ".", "add", "(", "ann", "[", "'image_id'", "]", ")", "\n", "", "elif", "ann", "[", "'category_id'", "]", "in", "cids_split2", ":", "\n", "            ", "annotations_split2", ".", "append", "(", "ann", ")", "\n", "image_id_split2", ".", "add", "(", "ann", "[", "'image_id'", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "Exception", "(", "'This should not happen'", ")", "\n", "\n", "", "", "images", "=", "dataset", "[", "'images'", "]", "\n", "images_split1", "=", "[", "]", "\n", "images_split2", "=", "[", "]", "\n", "for", "image", "in", "images", ":", "\n", "        ", "if", "image", "[", "'id'", "]", "in", "image_id_split1", ":", "\n", "            ", "images_split1", ".", "append", "(", "image", ")", "\n", "", "if", "image", "[", "'id'", "]", "in", "image_id_split2", ":", "\n", "            ", "images_split2", ".", "append", "(", "image", ")", "\n", "", "", "print", "(", "'Split 1: {} anns; save to {}'", ".", "format", "(", "len", "(", "annotations_split1", ")", ",", "split1_file", ")", ")", "\n", "print", "(", "'Split 2: {} anns; save to {}'", ".", "format", "(", "len", "(", "annotations_split2", ")", ",", "split2_file", ")", ")", "\n", "dataset_split1", "=", "{", "\n", "'images'", ":", "images_split1", ",", "\n", "'annotations'", ":", "annotations_split1", ",", "\n", "'categories'", ":", "dataset", "[", "'categories'", "]", "}", "\n", "dataset_split2", "=", "{", "\n", "'images'", ":", "images_split2", ",", "\n", "'annotations'", ":", "annotations_split2", ",", "\n", "'categories'", ":", "dataset", "[", "'categories'", "]", "}", "\n", "with", "open", "(", "split1_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "dataset_split1", ",", "f", ")", "\n", "", "with", "open", "(", "split2_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "dataset_split2", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCSegmentation.__init__": [[79, 96], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "open", "f.readlines", "x.strip"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "root", ",", "image_set", ",", "transform", "=", "None", ",", "target_transform", "=", "None", ",", "\n", "dataset_name", "=", "'VOC2007'", ")", ":", "\n", "        ", "self", ".", "root", "=", "root", "\n", "self", ".", "image_set", "=", "image_set", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "\n", "self", ".", "_annopath", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "root", ",", "dataset_name", ",", "'SegmentationClass'", ",", "'%s.png'", ")", "\n", "self", ".", "_imgpath", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "root", ",", "dataset_name", ",", "'JPEGImages'", ",", "'%s.jpg'", ")", "\n", "self", ".", "_imgsetpath", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "root", ",", "dataset_name", ",", "'ImageSets'", ",", "'Segmentation'", ",", "'%s.txt'", ")", "\n", "\n", "with", "open", "(", "self", ".", "_imgsetpath", "%", "self", ".", "image_set", ")", "as", "f", ":", "\n", "            ", "self", ".", "ids", "=", "f", ".", "readlines", "(", ")", "\n", "", "self", ".", "ids", "=", "[", "x", ".", "strip", "(", "'\\n'", ")", "for", "x", "in", "self", ".", "ids", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCSegmentation.__getitem__": [[97, 110], ["PIL.Image.open().convert", "PIL.Image.open().convert", "voc0712.VOCSegmentation.transform", "voc0712.VOCSegmentation.target_transform", "PIL.Image.open", "PIL.Image.open"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "\n", "target", "=", "Image", ".", "open", "(", "self", ".", "_annopath", "%", "img_id", ")", ".", "convert", "(", "'RGB'", ")", "\n", "img", "=", "Image", ".", "open", "(", "self", ".", "_imgpath", "%", "img_id", ")", ".", "convert", "(", "'RGB'", ")", "\n", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "img", "=", "self", ".", "transform", "(", "img", ")", "\n", "\n", "", "if", "self", ".", "target_transform", "is", "not", "None", ":", "\n", "            ", "target", "=", "self", ".", "target_transform", "(", "target", ")", "\n", "\n", "", "return", "img", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCSegmentation.__len__": [[111, 113], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.AnnotationTransform.__init__": [[128, 132], ["dict", "zip", "range", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "split", ",", "class_to_ind", "=", "None", ",", "keep_difficult", "=", "True", ")", ":", "\n", "        ", "self", ".", "class_to_ind", "=", "class_to_ind", "or", "dict", "(", "\n", "zip", "(", "VOC_CLASSES", "[", "split", "]", ",", "range", "(", "len", "(", "VOC_CLASSES", "[", "split", "]", ")", ")", ")", ")", "\n", "self", ".", "keep_difficult", "=", "keep_difficult", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.AnnotationTransform.__call__": [[133, 160], ["numpy.empty", "target.iter", "obj.find().text.lower().strip", "obj.find", "enumerate", "bndbox.append", "numpy.vstack", "int", "bndbox.append", "obj.find().text.lower", "int", "obj.find", "obj.find.find", "obj.find"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.EventStorage.iter"], ["", "def", "__call__", "(", "self", ",", "target", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            target (annotation) : the target annotation to be made usable\n                will be an ET.Element\n        Returns:\n            a list containing lists of bounding boxes  [bbox coords, class name]\n        \"\"\"", "\n", "res", "=", "np", ".", "empty", "(", "(", "0", ",", "5", ")", ")", "\n", "for", "obj", "in", "target", ".", "iter", "(", "'object'", ")", ":", "\n", "            ", "difficult", "=", "int", "(", "obj", ".", "find", "(", "'difficult'", ")", ".", "text", ")", "==", "1", "\n", "if", "not", "self", ".", "keep_difficult", "and", "difficult", ":", "\n", "                ", "continue", "\n", "", "name", "=", "obj", ".", "find", "(", "'name'", ")", ".", "text", ".", "lower", "(", ")", ".", "strip", "(", ")", "\n", "bbox", "=", "obj", ".", "find", "(", "'bndbox'", ")", "\n", "\n", "pts", "=", "[", "'xmin'", ",", "'ymin'", ",", "'xmax'", ",", "'ymax'", "]", "\n", "bndbox", "=", "[", "]", "\n", "for", "i", ",", "pt", "in", "enumerate", "(", "pts", ")", ":", "\n", "                ", "cur_pt", "=", "int", "(", "bbox", ".", "find", "(", "pt", ")", ".", "text", ")", "-", "1", "\n", "# scale height or width", "\n", "bndbox", ".", "append", "(", "cur_pt", ")", "\n", "", "label_idx", "=", "self", ".", "class_to_ind", "[", "name", "]", "\n", "bndbox", ".", "append", "(", "label_idx", ")", "\n", "res", "=", "np", ".", "vstack", "(", "(", "res", ",", "bndbox", ")", ")", "# [xmin, ymin, xmax, ymax, label_ind]", "\n", "\n", "", "return", "res", "# [[xmin, ymin, xmax, ymax, label_ind], ... ]", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__init__": [[179, 224], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "list", "hasattr", "hasattr", "hasattr", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "open", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "voc0712.VOCDetection.ids.append", "open", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "voc0712.VOCDetection.ids.append", "ValueError", "line.strip", "line.strip", "open", "str", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "voc0712.VOCDetection.ids.append", "open().readlines", "voc0712.VOCDetection.ids.append", "open().readlines", "voc0712.VOCDetection.ids.append", "line.strip", "open", "line.strip", "str", "open", "line.strip", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "args", ",", "root", ",", "image_sets", ",", "preproc", "=", "None", ",", "target_transform", "=", "None", ",", "test", "=", "False", ")", ":", "\n", "        ", "self", ".", "root", "=", "root", "\n", "self", ".", "image_set", "=", "image_sets", "\n", "self", ".", "preproc", "=", "preproc", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "self", ".", "_annopath", "=", "os", ".", "path", ".", "join", "(", "'%s'", ",", "'Annotations'", ",", "'%s.xml'", ")", "\n", "self", ".", "_imgpath", "=", "os", ".", "path", ".", "join", "(", "'%s'", ",", "'JPEGImages'", ",", "'%s.jpg'", ")", "\n", "self", ".", "mixup", "=", "None", "\n", "self", ".", "mixup_args", "=", "None", "\n", "self", ".", "ids", "=", "list", "(", ")", "\n", "self", ".", "split", "=", "0", "if", "args", ".", "setting", "==", "'transfer'", "else", "args", ".", "split", "\n", "self", ".", "setting", "=", "args", ".", "setting", "if", "hasattr", "(", "args", ",", "'setting'", ")", "else", "None", "\n", "self", ".", "phase", "=", "args", ".", "phase", "if", "hasattr", "(", "args", ",", "'phase'", ")", "else", "None", "\n", "self", ".", "instance_shot", "=", "args", ".", "instance_shot", "if", "hasattr", "(", "args", ",", "'instance_shot'", ")", "else", "None", "\n", "\n", "for", "(", "year", ",", "name", ")", "in", "image_sets", ":", "\n", "            ", "self", ".", "_year", "=", "year", "\n", "rootpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "'VOC'", "+", "year", ")", "\n", "if", "test", ":", "\n", "                ", "for", "line", "in", "open", "(", "os", ".", "path", ".", "join", "(", "rootpath", ",", "'ImageSets'", ",", "'Main'", ",", "name", "+", "'.txt'", ")", ")", ":", "\n", "                    ", "self", ".", "ids", ".", "append", "(", "(", "rootpath", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "", "elif", "args", ".", "phase", "==", "1", ":", "\n", "                ", "for", "line", "in", "open", "(", "\n", "os", ".", "path", ".", "join", "(", "rootpath", ",", "'ImageSets'", ",", "'Main'", ",", "name", "+", "'_split'", "+", "str", "(", "args", ".", "split", ")", "+", "'.txt'", ")", ")", ":", "\n", "                    ", "self", ".", "ids", ".", "append", "(", "(", "rootpath", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "", "elif", "args", ".", "phase", "==", "2", ":", "\n", "                ", "if", "args", ".", "setting", "==", "'transfer'", ":", "\n", "                    ", "if", "self", ".", "instance_shot", ":", "\n", "                        ", "for", "cls", "in", "VOC_CLASSES", "[", "0", "]", "[", "1", ":", "]", ":", "\n", "                            ", "for", "line", "in", "open", "(", "\n", "os", ".", "path", ".", "join", "(", "rootpath", ",", "'ImageSets'", ",", "'Main'", ",", "'1_box'", ",", "cls", "+", "'.txt'", ")", "\n", ")", ".", "readlines", "(", ")", "[", ":", "args", ".", "shot", "]", ":", "\n", "                                ", "self", ".", "ids", ".", "append", "(", "(", "rootpath", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "", "", "else", ":", "\n", "                        ", "for", "line", "in", "open", "(", "os", ".", "path", ".", "join", "(", "rootpath", ",", "'ImageSets'", ",", "'Main'", ",", "\n", "name", "+", "'_'", "+", "str", "(", "args", ".", "shot", ")", "+", "'shot.txt'", ")", ")", ":", "\n", "                            ", "self", ".", "ids", ".", "append", "(", "(", "rootpath", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "", "", "elif", "args", ".", "setting", "==", "'incre'", ":", "\n", "                    ", "for", "cls", "in", "VOC_CLASSES", "[", "args", ".", "split", "]", "[", "1", ":", "]", ":", "\n", "                        ", "for", "line", "in", "open", "(", "\n", "os", ".", "path", ".", "join", "(", "rootpath", ",", "'ImageSets'", ",", "'Main'", ",", "'1_box'", ",", "cls", "+", "'.txt'", ")", "\n", ")", ".", "readlines", "(", ")", "[", ":", "args", ".", "shot", "]", ":", "\n", "                            ", "self", ".", "ids", ".", "append", "(", "(", "rootpath", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "", "", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f\"Unknown data setting.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__getitem__": [[225, 276], ["ET.parse().getroot", "cv2.imread", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.random.choice", "ET.parse().getroot", "cv2.imread", "numpy.hstack", "numpy.hstack", "numpy.vstack", "voc0712.VOCDetection.target_transform", "voc0712.VOCDetection.preproc", "max", "numpy.ones", "numpy.hstack", "numpy.delete", "voc0712.VOCDetection.target_transform", "voc0712.VOCDetection.preproc", "ET.parse", "min", "numpy.arange", "ET.parse", "numpy.full", "numpy.full", "voc0712.VOCDetection.mixup", "len"], "methods", ["None"], ["", "", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# first image", "\n", "        ", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "target1", "=", "ET", ".", "parse", "(", "self", ".", "_annopath", "%", "img_id", ")", ".", "getroot", "(", ")", "\n", "img1", "=", "cv2", ".", "imread", "(", "self", ".", "_imgpath", "%", "img_id", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "\n", "if", "self", ".", "target_transform", "is", "not", "None", ":", "\n", "            ", "target1", "=", "self", ".", "target_transform", "(", "target1", ")", "\n", "\n", "", "if", "self", ".", "preproc", "is", "not", "None", ":", "\n", "            ", "img1", ",", "target1", "=", "self", ".", "preproc", "(", "img1", ",", "target1", ")", "\n", "\n", "", "if", "self", ".", "phase", "==", "2", "and", "(", "self", ".", "setting", "==", "'incre'", "or", "self", ".", "instance_shot", ")", ":", "\n", "            ", "target1", "[", "1", ":", ",", "-", "1", "]", "=", "-", "1", "\n", "\n", "", "lambd", "=", "1", "\n", "# draw a random lambda ratio from distribution", "\n", "if", "self", ".", "mixup", "is", "not", "None", ":", "\n", "            ", "lambd", "=", "max", "(", "0", ",", "min", "(", "1", ",", "self", ".", "mixup", "(", "*", "self", ".", "mixup_args", ")", ")", ")", "\n", "\n", "", "if", "lambd", ">=", "1", ":", "\n", "            ", "weights1", "=", "np", ".", "ones", "(", "(", "target1", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "target1", "=", "np", ".", "hstack", "(", "(", "target1", ",", "weights1", ")", ")", "\n", "return", "img1", ",", "target1", "\n", "\n", "", "lambd", "=", "torch", ".", "tensor", "(", "lambd", ")", "\n", "# second image", "\n", "index2", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "delete", "(", "np", ".", "arange", "(", "len", "(", "self", ")", ")", ",", "index", ")", ")", "\n", "img_id", "=", "self", ".", "ids", "[", "index2", "]", "\n", "target2", "=", "ET", ".", "parse", "(", "self", ".", "_annopath", "%", "img_id", ")", ".", "getroot", "(", ")", "\n", "img2", "=", "cv2", ".", "imread", "(", "self", ".", "_imgpath", "%", "img_id", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "\n", "if", "self", ".", "target_transform", "is", "not", "None", ":", "\n", "            ", "target2", "=", "self", ".", "target_transform", "(", "target2", ")", "\n", "\n", "", "if", "self", ".", "preproc", "is", "not", "None", ":", "\n", "            ", "img2", ",", "target2", "=", "self", ".", "preproc", "(", "img2", ",", "target2", ")", "\n", "\n", "", "if", "self", ".", "phase", "==", "2", "and", "(", "self", ".", "setting", "==", "'incre'", "or", "self", ".", "instance_shot", ")", ":", "\n", "            ", "target2", "[", "1", ":", ",", "-", "1", "]", "=", "-", "1", "\n", "\n", "# mixup two images", "\n", "", "mix_img", "=", "img1", "*", "lambd", "+", "img2", "*", "(", "1.", "-", "lambd", ")", "\n", "y1", "=", "np", ".", "hstack", "(", "(", "target1", ",", "np", ".", "full", "(", "(", "target1", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "lambd", ")", ")", ")", "\n", "y2", "=", "np", ".", "hstack", "(", "(", "target2", ",", "np", ".", "full", "(", "(", "target2", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "1.", "-", "lambd", ")", ")", ")", "\n", "mix_target", "=", "np", ".", "vstack", "(", "(", "y1", ",", "y2", ")", ")", "\n", "if", "self", ".", "setting", "==", "'incre'", "and", "self", ".", "phase", "==", "2", ":", "\n", "# set the weight of label -1 to 0, ignoring them in loss computation.", "\n", "            ", "mix_target", "[", "mix_target", "[", ":", ",", "-", "2", "]", "==", "-", "1", ",", "-", "1", "]", "=", "0", "\n", "\n", "", "return", "mix_img", ",", "mix_target", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.__len__": [[277, 279], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.set_mixup": [[280, 294], ["None"], "methods", ["None"], ["", "def", "set_mixup", "(", "self", ",", "mixup", ",", "*", "args", ")", ":", "\n", "        ", "\"\"\"Set mixup random sampler, use None to disable.\n\n                Parameters\n                ----------\n                mixup : callable random generator, e.g. np.random.uniform\n                    A random mixup ratio sampler, preferably a random generator from numpy.random\n                    A random float will be sampled each time with mixup(*args)\n                *args : list\n                    Additional arguments for mixup random sampler.\n\n                \"\"\"", "\n", "self", ".", "mixup", "=", "mixup", "\n", "self", ".", "mixup_args", "=", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.pull_image": [[295, 308], ["cv2.imread"], "methods", ["None"], ["", "def", "pull_image", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original image object at index in PIL form\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to show\n        Return:\n            PIL img\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "return", "cv2", ".", "imread", "(", "self", ".", "_imgpath", "%", "img_id", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.pull_anno": [[309, 325], ["ET.parse().getroot", "voc0712.VOCDetection.target_transform", "ET.parse"], "methods", ["None"], ["", "def", "pull_anno", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original annotation of image at index\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to get annotation of\n        Return:\n            list:  [img_id, [(label, bbox coords),...]]\n                eg: ('001718', [('dog', (96, 13, 438, 332))])\n        '''", "\n", "img_id", "=", "self", ".", "ids", "[", "index", "]", "\n", "anno", "=", "ET", ".", "parse", "(", "self", ".", "_annopath", "%", "img_id", ")", ".", "getroot", "(", ")", "\n", "gt", "=", "self", ".", "target_transform", "(", "anno", ")", "\n", "return", "img_id", "[", "1", "]", ",", "gt", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.pull_tensor": [[326, 338], ["torch.Tensor().unsqueeze_", "torch.Tensor().unsqueeze_", "torch.Tensor().unsqueeze_", "torch.Tensor().unsqueeze_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "voc0712.VOCDetection.pull_image"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.pull_image"], ["", "def", "pull_tensor", "(", "self", ",", "index", ")", ":", "\n", "        ", "'''Returns the original image at an index in tensor form\n\n        Note: not using self.__getitem__(), as any transformations passed in\n        could mess up this functionality.\n\n        Argument:\n            index (int): index of img to show\n        Return:\n            tensorized version of img, squeezed\n        '''", "\n", "return", "torch", ".", "Tensor", "(", "self", ".", "pull_image", "(", "index", ")", ")", ".", "unsqueeze_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection.evaluate_detections": [[339, 350], ["voc0712.VOCDetection._write_voc_results_file", "voc0712.VOCDetection._do_python_eval"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._write_voc_results_file", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._do_python_eval"], ["", "def", "evaluate_detections", "(", "self", ",", "all_boxes", ",", "output_dir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        all_boxes is a list of length number-of-classes.\n        Each list element is a list of length number-of-images.\n        Each of those list elements is either an empty list []\n        or a numpy array of detection.\n\n        all_boxes[class][image] = [] or np.array of shape #dets x 5\n        \"\"\"", "\n", "self", ".", "_write_voc_results_file", "(", "all_boxes", ")", "\n", "self", ".", "_do_python_eval", "(", "output_dir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._get_voc_results_file_template": [[351, 359], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs"], "methods", ["None"], ["", "def", "_get_voc_results_file_template", "(", "self", ")", ":", "\n", "        ", "filename", "=", "'comp4_det_test'", "+", "'_{:s}.txt'", "\n", "filedir", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "root", ",", "'results'", ",", "'VOC'", "+", "self", ".", "_year", ",", "'Main'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "filedir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "filedir", ")", "\n", "", "path", "=", "os", ".", "path", ".", "join", "(", "filedir", ",", "filename", ")", "\n", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._write_voc_results_file": [[360, 377], ["enumerate", "print", "voc0712.VOCDetection._get_voc_results_file_template().format", "open", "enumerate", "voc0712.VOCDetection._get_voc_results_file_template", "range", "f.write"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._get_voc_results_file_template", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.utils.event.CommonMetricPrinter.write"], ["", "def", "_write_voc_results_file", "(", "self", ",", "all_boxes", ")", ":", "\n", "        ", "for", "cls_ind", ",", "cls", "in", "enumerate", "(", "VOC_CLASSES", "[", "self", ".", "split", "]", "[", ":", "16", "if", "self", ".", "phase", "==", "1", "else", "21", "]", ")", ":", "\n", "            ", "if", "cls", "==", "'__background__'", ":", "\n", "                ", "continue", "\n", "", "print", "(", "'Writing {} VOC results file'", ".", "format", "(", "cls", ")", ")", "\n", "filename", "=", "self", ".", "_get_voc_results_file_template", "(", ")", ".", "format", "(", "cls", ")", "\n", "with", "open", "(", "filename", ",", "'wt'", ")", "as", "f", ":", "\n", "                ", "for", "im_ind", ",", "index", "in", "enumerate", "(", "self", ".", "ids", ")", ":", "\n", "                    ", "index", "=", "index", "[", "1", "]", "\n", "dets", "=", "all_boxes", "[", "cls_ind", "]", "[", "im_ind", "]", "\n", "if", "dets", "==", "[", "]", ":", "\n", "                        ", "continue", "\n", "", "for", "k", "in", "range", "(", "dets", ".", "shape", "[", "0", "]", ")", ":", "\n", "                        ", "f", ".", "write", "(", "'{:s} {:.3f} {:.1f} {:.1f} {:.1f} {:.1f}\\n'", ".", "\n", "format", "(", "index", ",", "dets", "[", "k", ",", "-", "1", "]", ",", "\n", "dets", "[", "k", ",", "0", "]", "+", "1", ",", "dets", "[", "k", ",", "1", "]", "+", "1", ",", "\n", "dets", "[", "k", ",", "2", "]", "+", "1", ",", "dets", "[", "k", ",", "3", "]", "+", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._do_python_eval": [[378, 427], ["os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "print", "enumerate", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "os.mkdir", "os.mkdir", "os.mkdir", "os.mkdir", "voc0712.VOCDetection._get_voc_results_file_template().format", "voc_eval.voc_eval.voc_eval", "print", "print", "print", "int", "os.path.isdir", "os.path.isdir", "os.path.isdir", "os.path.isdir", "numpy.mean", "numpy.mean", "voc0712.VOCDetection._get_voc_results_file_template", "open", "pickle.dump", "numpy.mean", "numpy.mean", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc_eval.voc_eval", "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.VOCDetection._get_voc_results_file_template"], ["", "", "", "", "", "def", "_do_python_eval", "(", "self", ",", "output_dir", "=", "'output'", ")", ":", "\n", "        ", "rootpath", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "'VOC'", "+", "self", ".", "_year", ")", "\n", "name", "=", "self", ".", "image_set", "[", "0", "]", "[", "1", "]", "\n", "annopath", "=", "os", ".", "path", ".", "join", "(", "\n", "rootpath", ",", "\n", "'Annotations'", ",", "\n", "'{:s}.xml'", ")", "\n", "imagesetfile", "=", "os", ".", "path", ".", "join", "(", "\n", "rootpath", ",", "\n", "'ImageSets'", ",", "\n", "'Main'", ",", "\n", "name", "+", "'.txt'", ")", "\n", "cachedir", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "'annotations_cache'", ")", "\n", "aps", "=", "[", "]", "\n", "# The PASCAL VOC metric changed in 2010", "\n", "use_07_metric", "=", "True", "if", "int", "(", "self", ".", "_year", ")", "<", "2010", "else", "False", "\n", "print", "(", "'VOC07 metric? '", "+", "(", "'Yes'", "if", "use_07_metric", "else", "'No'", ")", ")", "\n", "if", "output_dir", "is", "not", "None", "and", "not", "os", ".", "path", ".", "isdir", "(", "output_dir", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "output_dir", ")", "\n", "", "for", "i", ",", "cls", "in", "enumerate", "(", "VOC_CLASSES", "[", "self", ".", "split", "]", "[", ":", "16", "if", "self", ".", "phase", "==", "1", "else", "21", "]", ")", ":", "\n", "\n", "            ", "if", "cls", "==", "'__background__'", ":", "\n", "                ", "continue", "\n", "\n", "", "filename", "=", "self", ".", "_get_voc_results_file_template", "(", ")", ".", "format", "(", "cls", ")", "\n", "rec", ",", "prec", ",", "ap", "=", "voc_eval", "(", "\n", "filename", ",", "annopath", ",", "imagesetfile", ",", "cls", ",", "cachedir", ",", "ovthresh", "=", "0.5", ",", "\n", "use_07_metric", "=", "use_07_metric", ")", "\n", "aps", "+=", "[", "ap", "]", "\n", "print", "(", "'AP for {} = {:.4f}'", ".", "format", "(", "cls", ",", "ap", ")", ")", "\n", "if", "output_dir", "is", "not", "None", ":", "\n", "                ", "with", "open", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "cls", "+", "'_pr.pkl'", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "                    ", "pickle", ".", "dump", "(", "{", "'rec'", ":", "rec", ",", "'prec'", ":", "prec", ",", "'ap'", ":", "ap", "}", ",", "f", ")", "\n", "", "", "", "print", "(", "'Mean AP = {:.4f}'", ".", "format", "(", "np", ".", "mean", "(", "aps", ")", ")", ")", "\n", "print", "(", "'~~~~~~~~'", ")", "\n", "print", "(", "'Results:'", ")", "\n", "for", "ap", "in", "aps", ":", "\n", "            ", "print", "(", "'{:.4f}'", ".", "format", "(", "ap", ")", ")", "\n", "", "if", "self", ".", "setting", "==", "'incre'", "and", "self", ".", "phase", "==", "2", ":", "\n", "            ", "print", "(", "'Base AP = {:.4f}\\tNovel AP = {:.4f}'", ".", "format", "(", "np", ".", "mean", "(", "aps", "[", ":", "15", "]", ")", ",", "np", ".", "mean", "(", "aps", "[", "15", ":", "]", ")", ")", ")", "\n", "", "print", "(", "'Mean AP = {:.4f}'", ".", "format", "(", "np", ".", "mean", "(", "aps", ")", ")", ")", "\n", "print", "(", "'~~~~~~~~'", ")", "\n", "print", "(", "''", ")", "\n", "print", "(", "'--------------------------------------------------------------'", ")", "\n", "print", "(", "'Results computed with the **unofficial** Python eval code.'", ")", "\n", "print", "(", "'Results should be very close to the official MATLAB eval code.'", ")", "\n", "print", "(", "'Recompute with `./tools/reval.py --matlab ...` for your paper.'", ")", "\n", "print", "(", "'-- Thanks, The Management'", ")", "\n", "print", "(", "'--------------------------------------------------------------'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Ze-Yang_Context-Transformer.data.voc0712.detection_collate": [[429, 452], ["enumerate", "enumerate", "torch.stack", "torch.stack", "torch.is_tensor", "torch.is_tensor", "imgs.append", "isinstance", "type", "torch.from_numpy().float", "torch.from_numpy().float", "targets.append", "numpy.empty", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["", "", "def", "detection_collate", "(", "batch", ")", ":", "\n", "    ", "\"\"\"Custom collate fn for dealing with batches of images that have a different\n    number of associated object annotations (bounding boxes).\n\n    Arguments:\n        batch: (tuple) A tuple of tensor images and lists of annotations\n\n    Return:\n        A tuple containing:\n            1) (tensor) batch of images stacked on their 0 dim\n            2) (list of tensors) annotations for a given image are stacked on 0 dim\n    \"\"\"", "\n", "targets", "=", "[", "]", "\n", "imgs", "=", "[", "]", "\n", "for", "_", ",", "sample", "in", "enumerate", "(", "batch", ")", ":", "\n", "        ", "for", "_", ",", "tup", "in", "enumerate", "(", "sample", ")", ":", "\n", "            ", "if", "torch", ".", "is_tensor", "(", "tup", ")", ":", "\n", "                ", "imgs", ".", "append", "(", "tup", ")", "\n", "", "elif", "isinstance", "(", "tup", ",", "type", "(", "np", ".", "empty", "(", "0", ")", ")", ")", ":", "\n", "                ", "annos", "=", "torch", ".", "from_numpy", "(", "tup", ")", ".", "float", "(", ")", "\n", "targets", ".", "append", "(", "annos", ")", "\n", "\n", "", "", "", "return", "torch", ".", "stack", "(", "imgs", ",", "0", ")", ",", "targets", "\n", "", ""]]}