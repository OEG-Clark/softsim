{"home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.ClusterlingLayer.__init__": [[7, 14], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.init.xavier_uniform_", "torch.init.xavier_uniform_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", "=", "10", ",", "out_features", "=", "10", ",", "alpha", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "ClusterlingLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "out_features", ",", "self", ".", "in_features", ")", ")", "\n", "self", ".", "weight", "=", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.ClusterlingLayer.forward": [[15, 26], ["torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.t", "torch.t", "torch.t", "torch.t", "torch.t.unsqueeze", "torch.t.unsqueeze", "torch.t", "torch.t", "torch.t", "torch.t", "torch.sum", "torch.sum", "torch.sum", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "weight", "\n", "x", "=", "torch", ".", "mul", "(", "x", ",", "x", ")", "\n", "x", "=", "torch", ".", "sum", "(", "x", ",", "dim", "=", "2", ")", "\n", "x_dis", "=", "x", "\n", "x", "=", "1.0", "+", "(", "x", "/", "self", ".", "alpha", ")", "\n", "x", "=", "1.0", "/", "x", "\n", "x", "=", "x", "**", "(", "(", "self", ".", "alpha", "+", "1.0", ")", "/", "2.0", ")", "\n", "x", "=", "torch", ".", "t", "(", "x", ")", "/", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", "\n", "x", "=", "torch", ".", "t", "(", "x", ")", "\n", "return", "x", ",", "x_dis", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.ClusterlingLayer.extra_repr": [[27, 30], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", ":", "\n", "        ", "return", "'in_features={}, out_features={}, alpha={}'", ".", "format", "(", "\n", "self", ".", "in_features", ",", "self", ".", "out_features", ",", "self", ".", "alpha", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.ClusterlingLayer.set_weight": [[32, 34], ["torch.Parameter", "torch.Parameter"], "methods", ["None"], ["", "def", "set_weight", "(", "self", ",", "tensor", ")", ":", "\n", "        ", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "tensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_3.__init__": [[38, 72], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "800", ",", "embedding_dimension", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "# bias = True", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "2", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "embedding_dimension", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "embedding_dimension", ",", "lin_features_len", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "embedding_dimension", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_3.forward": [[73, 98], ["nets.CAE_3.conv1", "nets.CAE_3.relu1_1", "nets.CAE_3.conv2", "nets.CAE_3.relu2_1", "nets.CAE_3.conv3", "nets.CAE_3.view", "nets.CAE_3.embedding", "nets.CAE_3.clustering", "nets.CAE_3.deembedding", "nets.CAE_3.relu1_2", "nets.CAE_3.view", "nets.CAE_3.deconv3", "nets.CAE_3.relu2_2", "nets.CAE_3.deconv2", "nets.CAE_3.relu3_2", "nets.CAE_3.deconv1", "nets.CAE_3.sig", "nets.CAE_3.relu3_1", "nets.CAE_3.size", "nets.CAE_3.size", "nets.CAE_3.tanh"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "2", "]", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "", "", "class", "CAE_bn3", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn3.__init__": [[99, 137], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "800", ",", "embedding_dimension", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_bn3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "# bias = True", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "2", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "embedding_dimension", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "embedding_dimension", ",", "lin_features_len", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "bn3_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "bn2_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "embedding_dimension", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn3.forward": [[138, 167], ["nets.CAE_bn3.conv1", "nets.CAE_bn3.relu1_1", "nets.CAE_bn3.bn1_1", "nets.CAE_bn3.conv2", "nets.CAE_bn3.relu2_1", "nets.CAE_bn3.bn2_1", "nets.CAE_bn3.conv3", "nets.CAE_bn3.view", "nets.CAE_bn3.embedding", "nets.CAE_bn3.clustering", "nets.CAE_bn3.deembedding", "nets.CAE_bn3.relu1_2", "nets.CAE_bn3.view", "nets.CAE_bn3.deconv3", "nets.CAE_bn3.relu2_2", "nets.CAE_bn3.bn3_2", "nets.CAE_bn3.deconv2", "nets.CAE_bn3.relu3_2", "nets.CAE_bn3.bn2_2", "nets.CAE_bn3.deconv1", "nets.CAE_bn3.sig", "nets.CAE_bn3.relu3_1", "nets.CAE_bn3.size", "nets.CAE_bn3.size", "nets.CAE_bn3.tanh"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "2", "]", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "", "", "class", "CAE_bn3_MM", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn3_MM.__init__": [[168, 206], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "800", ",", "embedding_dimension", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_bn3_MM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "# bias = True", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "2", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", "*", "4", "//", "3", ",", "embedding_dimension", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "embedding_dimension", ",", "lin_features_len", "*", "4", "//", "3", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "bn3_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "bn2_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "embedding_dimension", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn3_MM.forward": [[207, 242], ["nets.CAE_bn3_MM.forward.forward_single1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "xp", ")", ":", "\n", "        ", "def", "forward_single1", "(", "self", ",", "x", ")", ":", "\n", "            ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "                ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "return", "x", "\n", "", "x_en", "=", "forward_single1", "(", "self", ",", "x", ")", "\n", "xp_en", "=", "forward_single1", "(", "self", ",", "xp", ")", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x_en", ",", "xp_en", "]", ",", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "2", "]", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_3_pair.__init__": [[245, 273], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "800", ",", "embedding_dimension", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_3_pair", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "# bias = True", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "2", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "embedding_dimension", ",", "bias", "=", "bias", ")", "\n", "#self.deembedding = nn.Linear(embedding_dimension, lin_features_len, bias=bias)", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "embedding_dimension", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "#self.out = nn.Sequential(nn.Linear(embedding_dimension, 1),nn.Sigmoid())", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_3_pair.forward": [[276, 297], ["nets.CAE_3_pair.forward.forward_single"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "            ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "                ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "extra_out", "=", "self", ".", "embedding", "(", "x", ")", "\n", "clustering_out", ",", "x_dis", "=", "self", ".", "clustering", "(", "extra_out", ")", "\n", "return", "clustering_out", ",", "extra_out", ",", "x_dis", "\n", "", "clustering_out1", ",", "extra_out1", ",", "x_dis1", "=", "forward_single", "(", "self", ",", "x1", ")", "\n", "clustering_out2", ",", "extra_out2", ",", "x_dis2", "=", "forward_single", "(", "self", ",", "x2", ")", "\n", "#dis = torch.abs(extra_out1 - extra_out2)", "\n", "#sim_score = self.out(dis)", "\n", "sim_score", "=", "nn", ".", "functional", ".", "pairwise_distance", "(", "extra_out1", ",", "extra_out2", ",", "p", "=", "2", ")", "\n", "return", "sim_score", ",", "clustering_out1", ",", "clustering_out2", ",", "extra_out1", ",", "extra_out2", ",", "x_dis1", "\n", "", "", "class", "CAE_5_pair", "(", "nn", ".", "Module", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_5_pair.__init__": [[298, 329], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "800", ",", "embedding_dimension", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", ",", "256", ",", "512", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_5_pair", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "# bias = True", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "3", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "4", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "4", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "embedding_dimension", ",", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "embedding_dimension", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "#self.out = nn.Sequential(nn.Linear(embedding_dimension, 1),nn.Sigmoid())", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_5_pair.forward": [[332, 353], ["nets.CAE_5_pair.forward.forward_single"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "def", "forward_single", "(", "self", ",", "x", ")", ":", "\n", "            ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "                ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "extra_out", "=", "self", ".", "embedding", "(", "x", ")", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "extra_out", ")", "\n", "return", "clustering_out", ",", "extra_out", "\n", "", "clustering_out1", ",", "extra_out1", "=", "forward_single", "(", "self", ",", "x1", ")", "\n", "clustering_out2", ",", "extra_out2", "=", "forward_single", "(", "self", ",", "x2", ")", "\n", "#dis = torch.abs(extra_out1 - extra_out2)", "\n", "#sim_score = self.out(dis)", "\n", "sim_score", "=", "nn", ".", "functional", ".", "pairwise_distance", "(", "extra_out1", ",", "extra_out2", ",", "p", "=", "2", ")", "\n", "return", "sim_score", ",", "clustering_out1", ",", "clustering_out2", ",", "extra_out1", ",", "extra_out2", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_4.__init__": [[428, 473], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", ",", "256", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_4", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "3", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "3", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "num_clusters", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "num_clusters", ",", "lin_features_len", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv4", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "2", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "num_clusters", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_4.forward": [[474, 503], ["nets.CAE_4.conv1", "nets.CAE_4.relu1_1", "nets.CAE_4.conv2", "nets.CAE_4.relu2_1", "nets.CAE_4.conv3", "nets.CAE_4.relu3_1", "nets.CAE_4.conv4", "nets.CAE_4.view", "nets.CAE_4.embedding", "nets.CAE_4.clustering", "nets.CAE_4.deembedding", "nets.CAE_4.relu4_2", "nets.CAE_4.view", "nets.CAE_4.deconv4", "nets.CAE_4.relu3_2", "nets.CAE_4.deconv3", "nets.CAE_4.relu2_2", "nets.CAE_4.deconv2", "nets.CAE_4.relu1_2", "nets.CAE_4.deconv1", "nets.CAE_4.sig", "nets.CAE_4.relu4_1", "nets.CAE_4.size", "nets.CAE_4.size", "nets.CAE_4.tanh"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu4_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "3", "]", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ")", "\n", "x", "=", "self", ".", "deconv4", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn4.__init__": [[506, 557], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", ",", "256", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_bn4", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn3_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "2", "]", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "3", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "3", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "num_clusters", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "num_clusters", ",", "lin_features_len", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv4", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "2", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn4_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "2", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn3_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn2_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "num_clusters", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn4.forward": [[558, 593], ["nets.CAE_bn4.conv1", "nets.CAE_bn4.relu1_1", "nets.CAE_bn4.bn1_1", "nets.CAE_bn4.conv2", "nets.CAE_bn4.relu2_1", "nets.CAE_bn4.bn2_1", "nets.CAE_bn4.conv3", "nets.CAE_bn4.relu3_1", "nets.CAE_bn4.bn3_1", "nets.CAE_bn4.conv4", "nets.CAE_bn4.view", "nets.CAE_bn4.embedding", "nets.CAE_bn4.clustering", "nets.CAE_bn4.deembedding", "nets.CAE_bn4.relu4_2", "nets.CAE_bn4.view", "nets.CAE_bn4.deconv4", "nets.CAE_bn4.relu3_2", "nets.CAE_bn4.bn4_2", "nets.CAE_bn4.deconv3", "nets.CAE_bn4.relu2_2", "nets.CAE_bn4.bn3_2", "nets.CAE_bn4.deconv2", "nets.CAE_bn4.relu1_2", "nets.CAE_bn4.bn2_2", "nets.CAE_bn4.deconv1", "nets.CAE_bn4.sig", "nets.CAE_bn4.relu4_1", "nets.CAE_bn4.size", "nets.CAE_bn4.size", "nets.CAE_bn4.tanh"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu4_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "3", "]", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ")", "\n", "x", "=", "self", ".", "deconv4", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn4_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_5.__init__": [[597, 650], ["torch.Module.__init__", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "800", ",", "embedding_dimension", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "64", ",", "128", ",", "128", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_5", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "3", "]", ",", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "4", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "\n", "lin_features_len", "=", "1152", "\n", "# lin_features_len = ((input_shape[0] // 2 // 1 // 2 // 1 - 1) // 2) * (", "\n", "#             (input_shape[0] // 2 // 1 // 2 // 1 - 1) // 2) * filters[4]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "embedding_dimension", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "embedding_dimension", ",", "lin_features_len", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv5", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "4", "]", ",", "filters", "[", "3", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv4", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "0", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "embedding_dimension", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu5_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu5_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_5.forward": [[651, 685], ["nets.CAE_5.conv1", "nets.CAE_5.relu1_1", "nets.CAE_5.conv2", "nets.CAE_5.relu2_1", "nets.CAE_5.conv3", "nets.CAE_5.relu3_1", "nets.CAE_5.conv4", "nets.CAE_5.relu4_1", "nets.CAE_5.conv5", "nets.CAE_5.view", "nets.CAE_5.embedding", "nets.CAE_5.clustering", "nets.CAE_5.deembedding", "nets.CAE_5.relu4_2", "nets.CAE_5.view", "nets.CAE_5.deconv5", "nets.CAE_5.relu4_2", "nets.CAE_5.deconv4", "nets.CAE_5.relu3_2", "nets.CAE_5.deconv3", "nets.CAE_5.relu2_2", "nets.CAE_5.deconv2", "nets.CAE_5.relu1_2", "nets.CAE_5.deconv1", "nets.CAE_5.sig", "nets.CAE_5.relu5_1", "nets.CAE_5.size", "nets.CAE_5.size", "nets.CAE_5.tanh"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv5", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu5_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "4", "]", ",", "3", ",", "3", ")", "\n", "#x = x.view(x.size(0), self.filters[4], ((self.input_shape[0]//2//2//2//2-1) // 2), ((self.input_shape[0]//2//2//2//2-1) // 2))", "\n", "x", "=", "self", ".", "deconv5", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv4", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn5.__init__": [[689, 749], ["torch.Module.__init__", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "nets.ClusterlingLayer", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.Sigmoid", "torch.Sigmoid", "torch.Tanh", "torch.Tanh", "torch.LeakyReLU", "torch.LeakyReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", "=", "[", "128", ",", "128", ",", "3", "]", ",", "num_clusters", "=", "10", ",", "filters", "=", "[", "32", ",", "64", ",", "128", ",", "256", ",", "512", "]", ",", "leaky", "=", "True", ",", "neg_slope", "=", "0.01", ",", "activations", "=", "False", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "CAE_bn5", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "activations", "=", "activations", "\n", "self", ".", "pretrained", "=", "False", "\n", "self", ".", "num_clusters", "=", "num_clusters", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "filters", "=", "filters", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "if", "leaky", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "neg_slope", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "False", ")", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "2", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "filters", "[", "0", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn3_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "2", "]", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "3", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "bias", ")", "\n", "self", ".", "bn4_1", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "3", "]", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "4", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "bias", "=", "bias", ")", "\n", "\n", "lin_features_len", "=", "(", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "(", "\n", "(", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", "*", "filters", "[", "4", "]", "\n", "self", ".", "embedding", "=", "nn", ".", "Linear", "(", "lin_features_len", ",", "num_clusters", ",", "bias", "=", "bias", ")", "\n", "self", ".", "deembedding", "=", "nn", ".", "Linear", "(", "num_clusters", ",", "lin_features_len", ",", "bias", "=", "bias", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv5", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "4", "]", ",", "filters", "[", "3", "]", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn5_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "3", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv4", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "3", "]", ",", "filters", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn4_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "2", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv3", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "2", "]", ",", "filters", "[", "1", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn3_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "1", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "//", "2", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv2", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "1", "]", ",", "filters", "[", "0", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "bn2_2", "=", "nn", ".", "BatchNorm2d", "(", "filters", "[", "0", "]", ")", "\n", "out_pad", "=", "1", "if", "input_shape", "[", "0", "]", "%", "2", "==", "0", "else", "0", "\n", "self", ".", "deconv1", "=", "nn", ".", "ConvTranspose2d", "(", "filters", "[", "0", "]", ",", "input_shape", "[", "2", "]", ",", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "output_padding", "=", "out_pad", ",", "\n", "bias", "=", "bias", ")", "\n", "self", ".", "clustering", "=", "ClusterlingLayer", "(", "num_clusters", ",", "num_clusters", ")", "\n", "# ReLU copies for graph representation in tensorboard", "\n", "self", ".", "relu1_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu5_1", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu1_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu2_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu3_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu4_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "relu5_2", "=", "copy", ".", "deepcopy", "(", "self", ".", "relu", ")", "\n", "self", ".", "sig", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "tanh", "=", "nn", ".", "Tanh", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.CAE_bn5.forward": [[750, 791], ["nets.CAE_bn5.conv1", "nets.CAE_bn5.relu1_1", "nets.CAE_bn5.bn1_1", "nets.CAE_bn5.conv2", "nets.CAE_bn5.relu2_1", "nets.CAE_bn5.bn2_1", "nets.CAE_bn5.conv3", "nets.CAE_bn5.relu3_1", "nets.CAE_bn5.bn3_1", "nets.CAE_bn5.conv4", "nets.CAE_bn5.relu4_1", "nets.CAE_bn5.bn4_1", "nets.CAE_bn5.conv5", "nets.CAE_bn5.view", "nets.CAE_bn5.embedding", "nets.CAE_bn5.clustering", "nets.CAE_bn5.deembedding", "nets.CAE_bn5.relu5_2", "nets.CAE_bn5.view", "nets.CAE_bn5.deconv5", "nets.CAE_bn5.relu4_2", "nets.CAE_bn5.bn5_2", "nets.CAE_bn5.deconv4", "nets.CAE_bn5.relu3_2", "nets.CAE_bn5.bn4_2", "nets.CAE_bn5.deconv3", "nets.CAE_bn5.relu2_2", "nets.CAE_bn5.bn3_2", "nets.CAE_bn5.deconv2", "nets.CAE_bn5.relu1_2", "nets.CAE_bn5.bn2_2", "nets.CAE_bn5.deconv1", "nets.CAE_bn5.sig", "nets.CAE_bn5.relu5_1", "nets.CAE_bn5.size", "nets.CAE_bn5.size", "nets.CAE_bn5.tanh"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn4_1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv5", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "sig", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "self", ".", "relu5_1", "(", "x", ")", "\n", "", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "embedding", "(", "x", ")", "\n", "extra_out", "=", "x", "\n", "clustering_out", "=", "self", ".", "clustering", "(", "x", ")", "\n", "x", "=", "self", ".", "deembedding", "(", "x", ")", "\n", "x", "=", "self", ".", "relu5_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "filters", "[", "4", "]", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ",", "(", "(", "self", ".", "input_shape", "[", "0", "]", "//", "2", "//", "2", "//", "2", "//", "2", "-", "1", ")", "//", "2", ")", ")", "\n", "x", "=", "self", ".", "deconv5", "(", "x", ")", "\n", "x", "=", "self", ".", "relu4_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn5_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv4", "(", "x", ")", "\n", "x", "=", "self", ".", "relu3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn4_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv3", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn3_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1_2", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2_2", "(", "x", ")", "\n", "x", "=", "self", ".", "deconv1", "(", "x", ")", "\n", "if", "self", ".", "activations", ":", "\n", "            ", "x", "=", "self", ".", "tanh", "(", "x", ")", "\n", "", "return", "x", ",", "clustering_out", ",", "extra_out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.Fiber.__init__": [[14, 19], ["dict"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ds", ",", "transform", "=", "None", ")", ":", "\n", "        ", "self", ".", "ds", "=", "ds", "\n", "#self.dsf = dsf", "\n", "self", ".", "_cache", "=", "dict", "(", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.Fiber.__getitem__": [[20, 29], ["numpy.expand_dims", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tuple"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ":", "int", ")", ":", "\n", "        ", "img", "=", "self", ".", "ds", "[", "index", "]", "\n", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "0", ")", "\n", "#imgf = self.dsf[index]", "\n", "img", "=", "torch", ".", "tensor", "(", "img", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "#imgf=torch.tensor(imgf, dtype=torch.float)", "\n", "# if self.transform is not None:", "\n", "#     img = self.transform(img)", "\n", "return", "tuple", "(", "img", ")", "#imgf", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.Fiber.__len__": [[30, 32], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "ds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.Fiber_pair.__init__": [[35, 40], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "vec", ",", "roi", ",", "transform", "=", "None", ")", ":", "\n", "#vec=np.reshape(vec,(len(ds),-1,ds.shape[1]))", "\n", "        ", "self", ".", "vec", "=", "vec", "#8000*14*3", "\n", "self", ".", "roi", "=", "roi", "\n", "self", ".", "transform", "=", "transform", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.Fiber_pair.__getitem__": [[41, 61], ["numpy.random.randint", "tract_feat._feat_to_3D().squeeze", "torch.tensor.transpose", "torch.tensor.transpose", "tract_feat._feat_to_3D().squeeze", "torch.tensor.transpose", "torch.tensor.transpose", "fiber_distance.fiber_pair_similarity", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "len", "tract_feat._feat_to_3D", "tract_feat._feat_to_3D", "numpy.expand_dims", "numpy.expand_dims"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_pair_similarity", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D"], ["", "def", "__getitem__", "(", "self", ",", "index", ":", "int", ")", ":", "\n", "        ", "index1", "=", "index", "\n", "index2", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "vec", ")", ")", "\n", "# img1=self.ds[index1]", "\n", "# img2 = self.ds[index2]", "\n", "fiber1", "=", "self", ".", "vec", "[", "index1", "]", "\n", "fiber2", "=", "self", ".", "vec", "[", "index2", "]", "\n", "img1", "=", "_feat_to_3D", "(", "np", ".", "expand_dims", "(", "fiber1", ",", "0", ")", ",", "repeat_time", "=", "14", ")", ".", "squeeze", "(", ")", "\n", "img1", "=", "img1", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "img2", "=", "_feat_to_3D", "(", "np", ".", "expand_dims", "(", "fiber2", ",", "0", ")", ",", "repeat_time", "=", "14", ")", ".", "squeeze", "(", ")", "\n", "img2", "=", "img2", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", "\n", "roi1", "=", "self", ".", "roi", "[", "index1", "]", "\n", "roi2", "=", "self", ".", "roi", "[", "index2", "]", "\n", "similarity", "=", "fiber_pair_similarity", "(", "fiber1", ",", "fiber2", ")", "\n", "img1", "=", "torch", ".", "tensor", "(", "img1", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "img2", "=", "torch", ".", "tensor", "(", "img2", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "similarity", "=", "torch", ".", "tensor", "(", "similarity", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "# if self.transform is not None:", "\n", "#     img = self.transform(img)", "\n", "return", "img1", ",", "img2", ",", "similarity", ",", "roi1", ",", "index", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.Fiber_pair.__len__": [[62, 64], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "        ", "return", "len", "(", "self", ".", "vec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST.__init__": [[92, 124], ["os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "os.path.expanduser", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "mnist.MNIST.download", "mnist.MNIST._check_exists", "RuntimeError", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST.download", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST._check_exists"], ["def", "__init__", "(", "self", ",", "root", ",", "train", "=", "True", ",", "transform", "=", "None", ",", "target_transform", "=", "None", ",", "download", "=", "False", ",", "small", "=", "False", ",", "full", "=", "False", ")", ":", "\n", "        ", "self", ".", "root", "=", "os", ".", "path", ".", "expanduser", "(", "root", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "target_transform", "=", "target_transform", "\n", "self", ".", "train", "=", "train", "# training set or test set", "\n", "self", ".", "full", "=", "full", "\n", "\n", "if", "full", ":", "\n", "            ", "self", ".", "train", "=", "True", "\n", "\n", "", "if", "download", ":", "\n", "            ", "self", ".", "download", "(", ")", "\n", "\n", "", "if", "not", "self", ".", "_check_exists", "(", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "'Dataset not found.'", "+", "\n", "' You can use download=True to download it'", ")", "\n", "\n", "", "self", ".", "train_data", ",", "self", ".", "train_labels", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "training_file", ")", ")", "\n", "self", ".", "test_data", ",", "self", ".", "test_labels", "=", "torch", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "test_file", ")", ")", "\n", "\n", "if", "full", ":", "\n", "            ", "self", ".", "train_data", "=", "np", ".", "concatenate", "(", "(", "self", ".", "train_data", ",", "self", ".", "test_data", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "train_labels", "=", "np", ".", "concatenate", "(", "(", "self", ".", "train_labels", ",", "self", ".", "test_labels", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "if", "small", ":", "\n", "            ", "self", ".", "train_data", "=", "self", ".", "train_data", "[", "0", ":", "1400", "]", "\n", "self", ".", "train_labels", "=", "self", ".", "train_labels", "[", "0", ":", "1400", "]", "\n", "if", "not", "full", ":", "\n", "                ", "self", ".", "train_data", "=", "self", ".", "train_data", "[", "0", ":", "1200", "]", "\n", "self", ".", "train_labels", "=", "self", ".", "train_labels", "[", "0", ":", "1200", "]", "\n", "", "self", ".", "test_data", "=", "self", ".", "test_data", "[", "0", ":", "200", "]", "\n", "self", ".", "test_labels", "=", "self", ".", "test_labels", "[", "0", ":", "200", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST.__getitem__": [[125, 152], ["PIL.Image.fromarray", "PIL.Image.fromarray", "mnist.MNIST.transform", "mnist.MNIST.target_transform", "mnist.MNIST.numpy"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            index (int): Index\n\n        Returns:\n            tuple: (image, target) where target is index of the target class.\n        \"\"\"", "\n", "if", "self", ".", "train", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "train_data", "[", "index", "]", ",", "self", ".", "train_labels", "[", "index", "]", "\n", "", "else", ":", "\n", "            ", "img", ",", "target", "=", "self", ".", "test_data", "[", "index", "]", ",", "self", ".", "test_labels", "[", "index", "]", "\n", "\n", "# doing this so that it is consistent with all other datasets", "\n", "# to return a PIL Image", "\n", "", "if", "self", ".", "full", ":", "\n", "            ", "img", "=", "Image", ".", "fromarray", "(", "img", ",", "mode", "=", "'L'", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "Image", ".", "fromarray", "(", "img", ".", "numpy", "(", ")", ",", "mode", "=", "'L'", ")", "\n", "\n", "", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "img", "=", "self", ".", "transform", "(", "img", ")", "\n", "\n", "", "if", "self", ".", "target_transform", "is", "not", "None", ":", "\n", "            ", "target", "=", "self", ".", "target_transform", "(", "target", ")", "\n", "\n", "", "return", "img", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST.__len__": [[153, 158], ["len", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "train", ":", "\n", "            ", "return", "len", "(", "self", ".", "train_data", ")", "\n", "", "else", ":", "\n", "            ", "return", "len", "(", "self", ".", "test_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST._check_exists": [[159, 162], ["os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.exists", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join"], "methods", ["None"], ["", "", "def", "_check_exists", "(", "self", ")", ":", "\n", "        ", "return", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "training_file", ")", ")", "and", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "test_file", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST.download": [[163, 210], ["mnist.MNIST._check_exists", "print", "print", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "print", "urllib.request.urlopen", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.unlink", "os.unlink", "os.unlink", "os.unlink", "mnist.read_image_file", "mnist.read_label_file", "mnist.read_image_file", "mnist.read_label_file", "open", "torch.save", "torch.save", "torch.save", "torch.save", "open", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "url.rpartition", "open", "f.write", "open", "gzip.GzipFile", "out_f.write", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "urllib.request.urlopen.read", "os.path.join.replace", "os.path.join.replace", "zip_f.read"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST._check_exists", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_image_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_label_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_image_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_label_file"], ["", "def", "download", "(", "self", ")", ":", "\n", "        ", "\"\"\"Download the MNIST data if it doesn't exist in processed_folder already.\"\"\"", "\n", "from", "six", ".", "moves", "import", "urllib", "\n", "import", "gzip", "\n", "\n", "if", "self", ".", "_check_exists", "(", ")", ":", "\n", "            ", "return", "\n", "\n", "# download files", "\n", "", "try", ":", "\n", "            ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ")", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ")", ")", "\n", "", "except", "OSError", "as", "e", ":", "\n", "            ", "if", "e", ".", "errno", "==", "errno", ".", "EEXIST", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "raise", "\n", "\n", "", "", "for", "url", "in", "self", ".", "urls", ":", "\n", "            ", "print", "(", "'Downloading '", "+", "url", ")", "\n", "data", "=", "urllib", ".", "request", ".", "urlopen", "(", "url", ")", "\n", "filename", "=", "url", ".", "rpartition", "(", "'/'", ")", "[", "2", "]", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ",", "filename", ")", "\n", "with", "open", "(", "file_path", ",", "'wb'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "data", ".", "read", "(", ")", ")", "\n", "", "with", "open", "(", "file_path", ".", "replace", "(", "'.gz'", ",", "''", ")", ",", "'wb'", ")", "as", "out_f", ",", "gzip", ".", "GzipFile", "(", "file_path", ")", "as", "zip_f", ":", "\n", "                ", "out_f", ".", "write", "(", "zip_f", ".", "read", "(", ")", ")", "\n", "", "os", ".", "unlink", "(", "file_path", ")", "\n", "\n", "# process and save as torch files", "\n", "", "print", "(", "'Processing...'", ")", "\n", "\n", "training_set", "=", "(", "\n", "read_image_file", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ",", "'train-images-idx3-ubyte'", ")", ")", ",", "\n", "read_label_file", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ",", "'train-labels-idx1-ubyte'", ")", ")", "\n", ")", "\n", "test_set", "=", "(", "\n", "read_image_file", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ",", "'t10k-images-idx3-ubyte'", ")", ")", ",", "\n", "read_label_file", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ",", "'t10k-labels-idx1-ubyte'", ")", ")", "\n", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "training_file", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "torch", ".", "save", "(", "training_set", ",", "f", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "test_file", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "torch", ".", "save", "(", "test_set", ",", "f", ")", "\n", "\n", "", "print", "(", "'Done!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST.__repr__": [[211, 222], ["mnist.MNIST.__len__", "mnist.MNIST.transform.__repr__().replace", "mnist.MNIST.target_transform.__repr__().replace", "mnist.MNIST.transform.__repr__", "mnist.MNIST.target_transform.__repr__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST.__len__", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__repr__", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "fmt_str", "=", "'Dataset '", "+", "self", ".", "__class__", ".", "__name__", "+", "'\\n'", "\n", "fmt_str", "+=", "'    Number of datapoints: {}\\n'", ".", "format", "(", "self", ".", "__len__", "(", ")", ")", "\n", "tmp", "=", "'train'", "if", "self", ".", "train", "is", "True", "else", "'test'", "\n", "fmt_str", "+=", "'    Split: {}\\n'", ".", "format", "(", "tmp", ")", "\n", "fmt_str", "+=", "'    Root Location: {}\\n'", ".", "format", "(", "self", ".", "root", ")", "\n", "tmp", "=", "'    Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}\\n'", ".", "format", "(", "tmp", ",", "self", ".", "transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "tmp", "=", "'    Target Transforms (if any): '", "\n", "fmt_str", "+=", "'{0}{1}'", ".", "format", "(", "tmp", ",", "self", ".", "target_transform", ".", "__repr__", "(", ")", ".", "replace", "(", "'\\n'", ",", "'\\n'", "+", "' '", "*", "len", "(", "tmp", ")", ")", ")", "\n", "return", "fmt_str", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST.__init__": [[270, 279], ["mnist.EMNIST._training_file", "mnist.EMNIST._test_file", "mnist.MNIST.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST._training_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST._test_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "split", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "split", "not", "in", "self", ".", "splits", ":", "\n", "            ", "raise", "ValueError", "(", "'Split \"{}\" not found. Valid splits are: {}'", ".", "format", "(", "\n", "split", ",", "', '", ".", "join", "(", "self", ".", "splits", ")", ",", "\n", ")", ")", "\n", "", "self", ".", "split", "=", "split", "\n", "self", ".", "training_file", "=", "self", ".", "_training_file", "(", "split", ")", "\n", "self", ".", "test_file", "=", "self", ".", "_test_file", "(", "split", ")", "\n", "super", "(", "EMNIST", ",", "self", ")", ".", "__init__", "(", "root", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST._training_file": [[280, 282], ["None"], "methods", ["None"], ["", "def", "_training_file", "(", "self", ",", "split", ")", ":", "\n", "        ", "return", "'training_{}.pt'", ".", "format", "(", "split", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST._test_file": [[283, 285], ["None"], "methods", ["None"], ["", "def", "_test_file", "(", "self", ",", "split", ")", ":", "\n", "        ", "return", "'test_{}.pt'", ".", "format", "(", "split", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST.download": [[286, 344], ["mnist.EMNIST._check_exists", "print", "urllib.request.urlopen", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "print", "os.unlink", "os.unlink", "os.unlink", "os.unlink", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.listdir", "os.listdir", "os.listdir", "os.listdir", "shutil.rmtree", "print", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "os.makedirs", "mnist.EMNIST.url.rpartition", "open", "f.write", "zipfile.ZipFile", "zip_f.extractall", "gzip_file.endswith", "print", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "urllib.request.urlopen.read", "print", "mnist.read_image_file", "mnist.read_label_file", "mnist.read_image_file", "mnist.read_label_file", "open", "torch.save", "torch.save", "torch.save", "torch.save", "open", "torch.save", "torch.save", "torch.save", "torch.save", "open", "gzip.GzipFile", "out_f.write", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "zip_f.read", "mnist.EMNIST._training_file", "mnist.EMNIST._test_file", "gzip_file.replace"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.MNIST._check_exists", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_image_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_label_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_image_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_label_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST._training_file", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.EMNIST._test_file"], ["", "def", "download", "(", "self", ")", ":", "\n", "        ", "\"\"\"Download the EMNIST data if it doesn't exist in processed_folder already.\"\"\"", "\n", "from", "six", ".", "moves", "import", "urllib", "\n", "import", "gzip", "\n", "import", "shutil", "\n", "import", "zipfile", "\n", "\n", "if", "self", ".", "_check_exists", "(", ")", ":", "\n", "            ", "return", "\n", "\n", "# download files", "\n", "", "try", ":", "\n", "            ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ")", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ")", ")", "\n", "", "except", "OSError", "as", "e", ":", "\n", "            ", "if", "e", ".", "errno", "==", "errno", ".", "EEXIST", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "raise", "\n", "\n", "", "", "print", "(", "'Downloading '", "+", "self", ".", "url", ")", "\n", "data", "=", "urllib", ".", "request", ".", "urlopen", "(", "self", ".", "url", ")", "\n", "filename", "=", "self", ".", "url", ".", "rpartition", "(", "'/'", ")", "[", "2", "]", "\n", "raw_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "raw_folder", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "filename", ")", "\n", "with", "open", "(", "file_path", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "data", ".", "read", "(", ")", ")", "\n", "\n", "", "print", "(", "'Extracting zip archive'", ")", "\n", "with", "zipfile", ".", "ZipFile", "(", "file_path", ")", "as", "zip_f", ":", "\n", "            ", "zip_f", ".", "extractall", "(", "raw_folder", ")", "\n", "", "os", ".", "unlink", "(", "file_path", ")", "\n", "gzip_folder", "=", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "'gzip'", ")", "\n", "for", "gzip_file", "in", "os", ".", "listdir", "(", "gzip_folder", ")", ":", "\n", "            ", "if", "gzip_file", ".", "endswith", "(", "'.gz'", ")", ":", "\n", "                ", "print", "(", "'Extracting '", "+", "gzip_file", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "gzip_file", ".", "replace", "(", "'.gz'", ",", "''", ")", ")", ",", "'wb'", ")", "as", "out_f", ",", "gzip", ".", "GzipFile", "(", "os", ".", "path", ".", "join", "(", "gzip_folder", ",", "gzip_file", ")", ")", "as", "zip_f", ":", "\n", "                    ", "out_f", ".", "write", "(", "zip_f", ".", "read", "(", ")", ")", "\n", "", "", "", "shutil", ".", "rmtree", "(", "gzip_folder", ")", "\n", "\n", "# process and save as torch files", "\n", "for", "split", "in", "self", ".", "splits", ":", "\n", "            ", "print", "(", "'Processing '", "+", "split", ")", "\n", "training_set", "=", "(", "\n", "read_image_file", "(", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "'emnist-{}-train-images-idx3-ubyte'", ".", "format", "(", "split", ")", ")", ")", ",", "\n", "read_label_file", "(", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "'emnist-{}-train-labels-idx1-ubyte'", ".", "format", "(", "split", ")", ")", ")", "\n", ")", "\n", "test_set", "=", "(", "\n", "read_image_file", "(", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "'emnist-{}-test-images-idx3-ubyte'", ".", "format", "(", "split", ")", ")", ")", ",", "\n", "read_label_file", "(", "os", ".", "path", ".", "join", "(", "raw_folder", ",", "'emnist-{}-test-labels-idx1-ubyte'", ".", "format", "(", "split", ")", ")", ")", "\n", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "_training_file", "(", "split", ")", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "training_set", ",", "f", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "processed_folder", ",", "self", ".", "_test_file", "(", "split", ")", ")", ",", "'wb'", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "test_set", ",", "f", ")", "\n", "\n", "", "", "print", "(", "'Done!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int": [[346, 348], ["int", "codecs.encode"], "function", ["None"], ["", "", "def", "get_int", "(", "b", ")", ":", "\n", "    ", "return", "int", "(", "codecs", ".", "encode", "(", "b", ",", "'hex'", ")", ",", "16", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_label_file": [[350, 357], ["open", "f.read", "mnist.get_int", "numpy.frombuffer", "torch.from_numpy().view().long", "torch.from_numpy().view().long", "mnist.get_int", "torch.from_numpy().view", "torch.from_numpy().view", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int"], ["", "def", "read_label_file", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "data", "=", "f", ".", "read", "(", ")", "\n", "assert", "get_int", "(", "data", "[", ":", "4", "]", ")", "==", "2049", "\n", "length", "=", "get_int", "(", "data", "[", "4", ":", "8", "]", ")", "\n", "parsed", "=", "np", ".", "frombuffer", "(", "data", ",", "dtype", "=", "np", ".", "uint8", ",", "offset", "=", "8", ")", "\n", "return", "torch", ".", "from_numpy", "(", "parsed", ")", ".", "view", "(", "length", ")", ".", "long", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.read_image_file": [[359, 369], ["open", "f.read", "mnist.get_int", "mnist.get_int", "mnist.get_int", "numpy.frombuffer", "torch.from_numpy().view", "torch.from_numpy().view", "mnist.get_int", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.mnist.get_int"], ["", "", "def", "read_image_file", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "data", "=", "f", ".", "read", "(", ")", "\n", "assert", "get_int", "(", "data", "[", ":", "4", "]", ")", "==", "2051", "\n", "length", "=", "get_int", "(", "data", "[", "4", ":", "8", "]", ")", "\n", "num_rows", "=", "get_int", "(", "data", "[", "8", ":", "12", "]", ")", "\n", "num_cols", "=", "get_int", "(", "data", "[", "12", ":", "16", "]", ")", "\n", "images", "=", "[", "]", "\n", "parsed", "=", "np", ".", "frombuffer", "(", "data", ",", "dtype", "=", "np", ".", "uint8", ",", "offset", "=", "16", ")", "\n", "return", "torch", ".", "from_numpy", "(", "parsed", ")", ".", "view", "(", "length", ",", "num_rows", ",", "num_cols", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.DiceLoss.__init__": [[10, 12], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DiceLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.DiceLoss.forward": [[13, 26], ["target.size", "input.view", "target.view", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "print", "intersection.sum", "input.view.sum", "target.view.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "N", "=", "target", ".", "size", "(", "0", ")", "\n", "smooth", "=", "1", "\n", "input_flat", "=", "input", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "target_flat", "=", "target", ".", "view", "(", "N", ",", "-", "1", ")", "\n", "# intersection = input_flat == target_flat", "\n", "# loss = ((intersection.sum(1) + smooth)).float() / (input_flat.size(1)+ smooth)", "\n", "intersection", "=", "input_flat", "*", "target_flat", "\n", "if", "torch", ".", "sum", "(", "intersection", ")", "==", "0", ":", "\n", "            ", "print", "(", "'0'", ")", "\n", "", "loss", "=", "(", "2", "*", "intersection", ".", "sum", "(", "1", ")", "+", "smooth", ")", "/", "(", "input_flat", ".", "sum", "(", "1", ")", "+", "target_flat", ".", "sum", "(", "1", ")", "+", "smooth", ")", "\n", "loss", "=", "1.5", "-", "loss", "#.sum() / N", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.train_model": [[28, 280], ["time.time", "training_functions_fiber_pair.DiceLoss", "utils.print_both", "numpy.load", "torch.load", "torch.load", "model.clustering.set_weight", "utils.print_both", "copy.deepcopy", "utils.print_both", "training_functions_fiber_pair.calculate_predictions_test", "torch.tensor().to", "torch.tensor().to", "range", "utils.print_both", "model.load_state_dict", "preds_uptated.cpu().numpy.cpu().numpy", "torch.load.to", "model.state_dict", "copy.deepcopy", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "torch.tensor().to", "training_functions_fiber_pair.train_model.roi_cluster_uptate"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.ClusterlingLayer.set_weight", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.calculate_predictions_test", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both"], ["", "", "def", "train_model", "(", "model", ",", "dataloader", ",", "criteria", ",", "optimizers", ",", "schedulers", ",", "num_epochs", ",", "params", ",", "x_fs", ",", "fs_flag", ")", ":", "\n", "\n", "# Note the time", "\n", "    ", "since", "=", "time", ".", "time", "(", ")", "\n", "loss_fn", "=", "DiceLoss", "(", ")", "\n", "# Unpack parameters", "\n", "writer", "=", "params", "[", "'writer'", "]", "\n", "if", "writer", "is", "not", "None", ":", "board", "=", "True", "\n", "txt_file", "=", "params", "[", "'txt_file'", "]", "\n", "pretrained", "=", "'nets/CAE_3_pair_130_pretrained.pt'", "#params['model_files'][1] #' #   # 'nets/CAE_3_pair_001_pretrained.pt'", "\n", "pretrain", "=", "params", "[", "'pretrain'", "]", "\n", "print_freq", "=", "params", "[", "'print_freq'", "]", "\n", "dataset_size", "=", "params", "[", "'dataset_size'", "]", "\n", "device", "=", "params", "[", "'device'", "]", "\n", "batch", "=", "params", "[", "'batch'", "]", "\n", "pretrain_epochs", "=", "params", "[", "'pretrain_epochs'", "]", "\n", "gamma", "=", "params", "[", "'gamma'", "]", "\n", "update_interval", "=", "params", "[", "'update_interval'", "]", "\n", "tol", "=", "params", "[", "'tol'", "]", "\n", "\n", "dl", "=", "dataloader", "\n", "\n", "# Pretrain or load weights", "\n", "if", "pretrain", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "pretrained_model", "=", "pretraining", "(", "model", ",", "copy", ".", "deepcopy", "(", "dl", ")", ",", "criteria", "[", "0", "]", ",", "optimizers", "[", "1", "]", ",", "schedulers", "[", "1", "]", ",", "pretrain_epochs", ",", "params", ")", "\n", "if", "pretrained_model", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "for", "layer", "in", "model", ".", "children", "(", ")", ":", "\n", "                    ", "if", "hasattr", "(", "layer", ",", "'reset_parameters'", ")", ":", "\n", "                        ", "layer", ".", "reset_parameters", "(", ")", "\n", "", "", "", "", "model", "=", "pretrained_model", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "pretrained", ")", ")", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'Pretrained weights loaded from file: '", "+", "str", "(", "pretrained", ")", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "\"Couldn't load pretrained weights\"", ")", "\n", "\n", "# Initialise clusters", "\n", "", "", "utils", ".", "print_both", "(", "txt_file", ",", "'\\nInitializing cluster centers based on K-means'", ")", "\n", "#preds_km=kmeans(model, copy.deepcopy(dl), params)", "\n", "preds_km", "=", "np", ".", "load", "(", "'preds_km.npy'", ")", "\n", "weights", "=", "torch", ".", "load", "(", "'weights.pt'", ")", "\n", "model", ".", "clustering", ".", "set_weight", "(", "weights", ".", "to", "(", "params", "[", "'device'", "]", ")", ")", "\n", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'\\nBegin clusters training'", ")", "\n", "\n", "# Prep variables for weights and accuracy of the best model", "\n", "best_model_wts", "=", "copy", ".", "deepcopy", "(", "model", ".", "state_dict", "(", ")", ")", "\n", "best_loss", "=", "10000.0", "\n", "\n", "# Initial target distribution", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'\\nUpdating target distribution'", ")", "\n", "preds_initial", ",", "_", "=", "calculate_predictions_test", "(", "model", ",", "copy", ".", "deepcopy", "(", "dl", ")", ",", "params", ")", "\n", "#output_distribution, preds_initial = calculate_predictions(model, copy.deepcopy(dl), params)", "\n", "preds_uptated", "=", "torch", ".", "tensor", "(", "preds_initial", ")", ".", "to", "(", "device", ")", "\n", "#target_distribution = target(output_distribution)", "\n", "\n", "if", "fs_flag", ":", "\n", "        ", "def", "roi_cluster_uptate", "(", "num_clusters", ",", "preds", ",", "x_fs", ",", "device", ")", ":", "\n", "            ", "roi_cluster", "=", "torch", ".", "zeros", "(", "[", "num_clusters", ",", "x_fs", ".", "shape", "[", "1", "]", "]", ")", "\n", "for", "i", "in", "range", "(", "num_clusters", ")", ":", "\n", "                ", "t", "=", "x_fs", "[", "preds", "==", "i", "]", "\n", "t1", "=", "torch", ".", "sum", "(", "t", ",", "0", ")", "\n", "roi_all", "=", "(", "t1", ">", "t", ".", "shape", "[", "0", "]", "*", "0.4", ")", ".", "nonzero", "(", ")", "\n", "if", "0", "in", "roi_all", ":", "\n", "                    ", "roi_all", "=", "roi_all", "[", "1", ":", "]", "\n", "", "roi_cluster", "[", "i", ",", "roi_all", ".", "long", "(", ")", "]", "=", "1", "\n", "# Initialise roi distribution", "\n", "# roi_cluster = -torch.ones([num_clusters,len(torch.unique(x_fs))])", "\n", "# for i in range(num_clusters):", "\n", "#     roi_onehot = torch.zeros([len(torch.unique(x_fs))])", "\n", "#     t=x_fs[preds==i]", "\n", "#     roi_all=torch.unique(t)", "\n", "#     if 0 in roi_all:", "\n", "#         index_0=roi_all!=0", "\n", "#         roi_all=roi_all[index_0]", "\n", "#     for roi in list(roi_all):", "\n", "#         x=(t==roi).nonzero()[:,0]", "\n", "#         n=len(torch.unique(x))", "\n", "#         #print(n)", "\n", "#         if n>t.shape[0]*0.4:", "\n", "#             roi_onehot[roi.long()]=1", "\n", "#     roi_cluster[i] = roi_onehot", "\n", "", "roi_cluster", "=", "roi_cluster", ".", "to", "(", "device", ")", "\n", "return", "roi_cluster", "\n", "", "preds_km", "=", "torch", ".", "tensor", "(", "preds_km", ")", ".", "to", "(", "device", ")", "\n", "x_fs", "=", "torch", ".", "tensor", "(", "x_fs", ")", ".", "to", "(", "device", ")", "\n", "roi_cluster", "=", "roi_cluster_uptate", "(", "model", ".", "num_clusters", ",", "preds_km", ",", "x_fs", ",", "device", ")", "\n", "\n", "", "finished", "=", "False", "\n", "# Go through all epochs", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "\n", "        ", "utils", ".", "print_both", "(", "txt_file", ",", "'Epoch {}/{}'", ".", "format", "(", "epoch", "+", "1", ",", "num_epochs", ")", ")", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'-'", "*", "10", ")", "\n", "\n", "schedulers", "[", "0", "]", ".", "step", "(", ")", "\n", "model", ".", "train", "(", "True", ")", "# Set model to training mode", "\n", "\n", "running_loss", "=", "0.0", "\n", "running_loss_rec", "=", "0.0", "\n", "running_loss_clust", "=", "0.0", "\n", "\n", "# Keep the batch number for inter-phase statistics", "\n", "batch_num", "=", "1", "\n", "img_counter", "=", "0", "\n", "\n", "# Iterate over data.", "\n", "for", "data", "in", "dataloader", ":", "\n", "# Get the inputs and labels", "\n", "            ", "input1", ",", "input2", ",", "sim", ",", "roi_bat", ",", "index", "=", "data", "\n", "input1", "=", "input1", ".", "to", "(", "device", ")", "\n", "input2", "=", "input2", ".", "to", "(", "device", ")", "\n", "sim", "=", "sim", ".", "to", "(", "device", ")", "\n", "roi_bat", "=", "roi_bat", ".", "to", "(", "device", ")", "\n", "index", "=", "index", ".", "to", "(", "device", ")", "\n", "\n", "# Uptade target distribution, chack and print performance", "\n", "if", "(", "batch_num", "-", "1", ")", "%", "update_interval", "==", "0", "and", "not", "(", "batch_num", "==", "1", "and", "epoch", "==", "0", ")", ":", "\n", "#     utils.print_both(txt_file, '\\nUpdating target distribution:')", "\n", "#     output_distribution,  preds = calculate_predictions(model, dataloader, params)", "\n", "#target_distribution = target(output_distribution)", "\n", "                ", "if", "fs_flag", ":", "\n", "                    ", "roi_cluster", "=", "roi_cluster_uptate", "(", "model", ".", "num_clusters", ",", "preds_uptated", ",", "x_fs", ",", "device", ")", "\n", "#     # check stop criterion", "\n", "#     delta_label = np.sum(preds != preds_prev).astype(np.float32) / preds.shape[0]", "\n", "#     preds_prev = np.copy(preds)", "\n", "#     if delta_label < tol:", "\n", "#         utils.print_both(txt_file, 'Label divergence ' + str(delta_label) + '< tol ' + str(tol))", "\n", "#         utils.print_both(txt_file, 'Reached tolerance threshold. Stopping training.')", "\n", "#         finished = True", "\n", "#         break", "\n", "\n", "# tar_dist = target_distribution[((batch_num - 1) * batch):(batch_num*batch), :]", "\n", "# tar_dist = torch.from_numpy(tar_dist).to(device)", "\n", "# print(tar_dist)", "\n", "\n", "# zero the parameter gradients", "\n", "", "", "optimizers", "[", "0", "]", ".", "zero_grad", "(", ")", "\n", "\n", "# Calculate losses and backpropagate", "\n", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "                ", "outputs", ",", "clusters", ",", "_", ",", "_", ",", "_", ",", "dis_point", "=", "model", "(", "input1", ",", "input2", ")", "\n", "if", "fs_flag", ":", "\n", "                    ", "roi_3D", "=", "roi_bat", ".", "unsqueeze", "(", "1", ")", ".", "to", "(", "device", ")", "\n", "roi_3D", "=", "roi_3D", ".", "repeat", "(", "1", ",", "model", ".", "num_clusters", ",", "1", ")", "\n", "roi_3D", "=", "torch", ".", "reshape", "(", "roi_3D", ",", "(", "-", "1", ",", "roi_3D", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "roi_cluster_3D", "=", "roi_cluster", ".", "repeat", "(", "outputs", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "dis_roi1", "=", "loss_fn", "(", "roi_3D", ",", "roi_cluster_3D", ")", "\n", "dis_roi", "=", "torch", ".", "reshape", "(", "dis_roi1", ",", "(", "outputs", ".", "shape", "[", "0", "]", ",", "model", ".", "num_clusters", ")", ")", "\n", "# calculate new p", "\n", "# alpha = dis_point.max()", "\n", "_", ",", "pred_point", "=", "dis_point", ".", "min", "(", "1", ")", "\n", "_", ",", "pred_roi", "=", "dis_roi", ".", "min", "(", "1", ")", "\n", "index1", "=", "(", "pred_point", "!=", "pred_roi", ")", ".", "nonzero", "(", ")", "\n", "index_dif", "=", "[", "]", "\n", "for", "i", "in", "index1", ":", "\n", "                        ", "if", "dis_roi", "[", "i", ",", "pred_roi", "[", "i", "]", "]", "!=", "dis_roi", "[", "i", ",", "pred_point", "[", "i", "]", "]", ":", "\n", "                            ", "index_dif", ".", "append", "(", "i", ")", "\n", "#print(len(index_dif))", "\n", "", "", "x", "=", "1.0", "+", "dis_point", "*", "dis_roi", "\n", "x", "=", "1.0", "/", "x", "\n", "x", "=", "torch", ".", "t", "(", "x", ")", "/", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", "\n", "x", "=", "torch", ".", "t", "(", "x", ")", "\n", "clusters", "=", "x", "\n", "", "_", ",", "preds", "=", "torch", ".", "max", "(", "clusters", ",", "1", ")", "\n", "#print(torch.sum(preds!=pred_point))", "\n", "preds_uptated", "[", "index", "]", "=", "preds", "\n", "#output_distribution[index.cpu().numpy()]=clusters.detach().cpu().numpy()", "\n", "tar_dist", "=", "target_distribution", "(", "clusters", ")", "\n", "loss_rec", "=", "criteria", "[", "0", "]", "(", "outputs", ",", "sim", ")", "\n", "loss_clust", "=", "gamma", "*", "criteria", "[", "1", "]", "(", "torch", ".", "log", "(", "clusters", ")", ",", "tar_dist", ")", "/", "batch", "\n", "loss", "=", "loss_rec", "+", "loss_clust", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizers", "[", "0", "]", ".", "step", "(", ")", "\n", "\n", "# For keeping statistics", "\n", "", "running_loss", "+=", "loss", ".", "item", "(", ")", "*", "input1", ".", "size", "(", "0", ")", "\n", "running_loss_rec", "+=", "loss_rec", ".", "item", "(", ")", "*", "input1", ".", "size", "(", "0", ")", "\n", "running_loss_clust", "+=", "loss_clust", ".", "item", "(", ")", "*", "input1", ".", "size", "(", "0", ")", "\n", "\n", "# Some current stats", "\n", "loss_batch", "=", "loss", ".", "item", "(", ")", "\n", "loss_batch_rec", "=", "loss_rec", ".", "item", "(", ")", "\n", "loss_batch_clust", "=", "loss_clust", ".", "item", "(", ")", "\n", "loss_accum", "=", "running_loss", "/", "(", "(", "batch_num", "-", "1", ")", "*", "batch", "+", "input1", ".", "size", "(", "0", ")", ")", "\n", "loss_accum_rec", "=", "running_loss_rec", "/", "(", "(", "batch_num", "-", "1", ")", "*", "batch", "+", "input1", ".", "size", "(", "0", ")", ")", "\n", "loss_accum_clust", "=", "running_loss_clust", "/", "(", "(", "batch_num", "-", "1", ")", "*", "batch", "+", "input1", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "batch_num", "%", "print_freq", "==", "0", ":", "\n", "                ", "utils", ".", "print_both", "(", "txt_file", ",", "'Epoch: [{0}][{1}/{2}]\\t'", "\n", "'Loss {3:.4f} ({4:.4f})\\t'", "\n", "'Loss_recovery {5:.4f} ({6:.4f})\\t'", "\n", "'Loss clustering {7:.4f} ({8:.4f})\\t'", ".", "format", "(", "epoch", "+", "1", ",", "batch_num", ",", "\n", "len", "(", "dataloader", ")", ",", "\n", "loss_batch", ",", "\n", "loss_accum", ",", "loss_batch_rec", ",", "\n", "loss_accum_rec", ",", "\n", "loss_batch_clust", ",", "\n", "loss_accum_clust", ")", ")", "\n", "if", "board", ":", "\n", "                    ", "niter", "=", "epoch", "*", "len", "(", "dataloader", ")", "+", "batch_num", "\n", "writer", ".", "add_scalar", "(", "'/Loss'", ",", "loss_accum", ",", "niter", ")", "\n", "writer", ".", "add_scalar", "(", "'/Loss_recovery'", ",", "loss_accum_rec", ",", "niter", ")", "\n", "writer", ".", "add_scalar", "(", "'/Loss_clustering'", ",", "loss_accum_clust", ",", "niter", ")", "\n", "", "", "batch_num", "=", "batch_num", "+", "1", "\n", "\n", "# Print image to tensorboard", "\n", "# if batch_num == len(dataloader) and (epoch+1) % 5:", "\n", "#     inp = utils.tensor2img(inputs)", "\n", "#     out = utils.tensor2img(outputs)", "\n", "#     if board:", "\n", "#         img = np.concatenate((inp, out), axis=1)", "\n", "#         #writer.add_image('Clustering/Epoch_' + str(epoch + 1).zfill(3) + '/Sample_' + str(img_counter).zfill(2), img)", "\n", "#         img_counter += 1", "\n", "\n", "", "if", "finished", ":", "break", "\n", "\n", "epoch_loss", "=", "running_loss", "/", "dataset_size", "\n", "epoch_loss_rec", "=", "running_loss_rec", "/", "dataset_size", "\n", "epoch_loss_clust", "=", "running_loss_clust", "/", "dataset_size", "\n", "\n", "if", "board", ":", "\n", "            ", "writer", ".", "add_scalar", "(", "'/Loss'", "+", "'/Epoch'", ",", "epoch_loss", ",", "epoch", "+", "1", ")", "\n", "writer", ".", "add_scalar", "(", "'/Loss_rec'", "+", "'/Epoch'", ",", "epoch_loss_rec", ",", "epoch", "+", "1", ")", "\n", "writer", ".", "add_scalar", "(", "'/Loss_clust'", "+", "'/Epoch'", ",", "epoch_loss_clust", ",", "epoch", "+", "1", ")", "\n", "\n", "", "utils", ".", "print_both", "(", "txt_file", ",", "'Loss: {0:.4f}\\tLoss_recovery: {1:.4f}\\tLoss_clustering: {2:.4f}'", ".", "format", "(", "epoch_loss", ",", "\n", "epoch_loss_rec", ",", "\n", "epoch_loss_clust", ")", ")", "\n", "\n", "# If wanted to do some criterium in the future (for now useless)", "\n", "if", "epoch_loss", "<", "best_loss", "or", "epoch_loss", ">=", "best_loss", ":", "\n", "            ", "best_loss", "=", "epoch_loss", "\n", "best_model_wts", "=", "copy", ".", "deepcopy", "(", "model", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "utils", ".", "print_both", "(", "txt_file", ",", "''", ")", "\n", "\n", "", "time_elapsed", "=", "time", ".", "time", "(", ")", "-", "since", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'Training complete in {:.0f}m {:.0f}s'", ".", "format", "(", "\n", "time_elapsed", "//", "60", ",", "time_elapsed", "%", "60", ")", ")", "\n", "\n", "# load best model weights", "\n", "model", ".", "load_state_dict", "(", "best_model_wts", ")", "\n", "preds_uptated", "=", "preds_uptated", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "#output_distribution, preds = calculate_predictions(model, dataloader, params)", "\n", "if", "fs_flag", ":", "\n", "        ", "preds_km", "=", "preds_km", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "model", ",", "preds_km", ",", "preds_uptated", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.pretraining": [[283, 390], ["time.time", "copy.deepcopy", "range", "utils.print_both", "model.load_state_dict", "torch.save", "torch.save", "model.state_dict", "utils.print_both", "utils.print_both", "scheduler.step", "model.train", "utils.print_both", "utils.print_both", "time.time", "model.state_dict", "input1.to.to", "input2.to.to", "sim_score.to.to", "optimizer.zero_grad", "criterion.item", "utils.print_both", "writer.add_scalar", "copy.deepcopy", "torch.set_grad_enabled", "torch.set_grad_enabled", "model", "criterion", "criterion.backward", "optimizer.step", "criterion.item", "input1.to.size", "utils.print_both", "model.state_dict", "input1.to.size", "writer.add_scalar", "len", "len"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.train.train", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both"], ["", "def", "pretraining", "(", "model", ",", "dataloader", ",", "criterion", ",", "optimizer", ",", "scheduler", ",", "num_epochs", ",", "params", ")", ":", "\n", "# Note the time", "\n", "    ", "since", "=", "time", ".", "time", "(", ")", "\n", "\n", "# Unpack parameters", "\n", "writer", "=", "params", "[", "'writer'", "]", "\n", "if", "writer", "is", "not", "None", ":", "board", "=", "True", "\n", "txt_file", "=", "params", "[", "'txt_file'", "]", "\n", "pretrained", "=", "params", "[", "'model_files'", "]", "[", "1", "]", "\n", "print_freq", "=", "params", "[", "'print_freq'", "]", "\n", "dataset_size", "=", "params", "[", "'dataset_size'", "]", "\n", "device", "=", "params", "[", "'device'", "]", "\n", "batch", "=", "params", "[", "'batch'", "]", "\n", "\n", "# Prep variables for weights and accuracy of the best model", "\n", "best_model_wts", "=", "copy", ".", "deepcopy", "(", "model", ".", "state_dict", "(", ")", ")", "\n", "best_loss", "=", "10000.0", "\n", "\n", "# Go through all epochs", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "        ", "utils", ".", "print_both", "(", "txt_file", ",", "'Pretraining:\\tEpoch {}/{}'", ".", "format", "(", "epoch", "+", "1", ",", "num_epochs", ")", ")", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'-'", "*", "10", ")", "\n", "\n", "scheduler", ".", "step", "(", ")", "\n", "model", ".", "train", "(", "True", ")", "# Set model to training mode", "\n", "\n", "running_loss", "=", "0.0", "\n", "\n", "# Keep the batch number for inter-phase statistics", "\n", "batch_num", "=", "1", "\n", "# Images to show", "\n", "img_counter", "=", "0", "\n", "\n", "# Iterate over data.", "\n", "for", "data", "in", "dataloader", ":", "\n", "# Get the inputs and labels", "\n", "            ", "input1", ",", "input2", ",", "sim_score", ",", "_", ",", "_", "=", "data", "\n", "input1", "=", "input1", ".", "to", "(", "device", ")", "\n", "input2", "=", "input2", ".", "to", "(", "device", ")", "\n", "sim_score", "=", "sim_score", ".", "to", "(", "device", ")", "\n", "\n", "# zero the parameter gradients", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "with", "torch", ".", "set_grad_enabled", "(", "True", ")", ":", "\n", "                ", "outputs", ",", "_", ",", "_", ",", "_", ",", "_", ",", "_", "=", "model", "(", "input1", ",", "input2", ")", "\n", "loss", "=", "criterion", "(", "outputs", ",", "sim_score", ")", "\n", "#print('outputs',outputs)", "\n", "#print('pseudo gt', sim_score)", "\n", "#loss=loss*100", "\n", "#loss= -torch.log(1-abs(sim_score-outputs))", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "# For keeping statistics", "\n", "", "running_loss", "+=", "loss", ".", "item", "(", ")", "*", "input1", ".", "size", "(", "0", ")", "\n", "\n", "# Some current stats", "\n", "loss_batch", "=", "loss", ".", "item", "(", ")", "\n", "loss_accum", "=", "running_loss", "/", "(", "(", "batch_num", "-", "1", ")", "*", "batch", "+", "input1", ".", "size", "(", "0", ")", ")", "\n", "\n", "if", "batch_num", "%", "print_freq", "==", "0", ":", "\n", "                ", "utils", ".", "print_both", "(", "txt_file", ",", "'Pretraining:\\tEpoch: [{0}][{1}/{2}]\\t'", "\n", "'Loss {3:.4f} ({4:.4f})\\t'", ".", "format", "(", "epoch", "+", "1", ",", "batch_num", ",", "len", "(", "dataloader", ")", ",", "\n", "loss_batch", ",", "\n", "loss_accum", ")", ")", "\n", "if", "board", ":", "\n", "                    ", "niter", "=", "epoch", "*", "len", "(", "dataloader", ")", "+", "batch_num", "\n", "writer", ".", "add_scalar", "(", "'Pretraining/Loss'", ",", "loss_accum", ",", "niter", ")", "\n", "", "", "batch_num", "=", "batch_num", "+", "1", "\n", "\n", "# if batch_num in [len(dataloader), len(dataloader)//2, len(dataloader)//4, 3*len(dataloader)//4]:", "\n", "#     inp = utils.tensor2img(inputs)", "\n", "#     out = utils.tensor2img(outputs)", "\n", "#     if board:", "\n", "#         img = np.concatenate((inp, out), axis=1)", "\n", "#         #writer.add_image('Pretraining/Epoch_' + str(epoch + 1).zfill(3) + '/Sample_' + str(img_counter).zfill(2), img)", "\n", "#         img_counter += 1", "\n", "\n", "", "epoch_loss", "=", "running_loss", "/", "dataset_size", "\n", "if", "epoch", "==", "0", ":", "first_loss", "=", "epoch_loss", "\n", "if", "epoch", "==", "4", "and", "epoch_loss", "/", "first_loss", ">", "1", ":", "\n", "            ", "utils", ".", "print_both", "(", "txt_file", ",", "\"\\nLoss not converging, starting pretraining again\\n\"", ")", "\n", "return", "False", "\n", "\n", "", "if", "board", ":", "\n", "            ", "writer", ".", "add_scalar", "(", "'Pretraining/Loss'", "+", "'/Epoch'", ",", "epoch_loss", ",", "epoch", "+", "1", ")", "\n", "\n", "", "utils", ".", "print_both", "(", "txt_file", ",", "'Pretraining:\\t Loss: {:.4f}'", ".", "format", "(", "epoch_loss", ")", ")", "\n", "\n", "# If wanted to add some criterium in the future", "\n", "if", "epoch_loss", "<", "best_loss", "or", "epoch_loss", ">=", "best_loss", ":", "\n", "            ", "best_loss", "=", "epoch_loss", "\n", "best_model_wts", "=", "copy", ".", "deepcopy", "(", "model", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "utils", ".", "print_both", "(", "txt_file", ",", "''", ")", "\n", "\n", "", "time_elapsed", "=", "time", ".", "time", "(", ")", "-", "since", "\n", "utils", ".", "print_both", "(", "txt_file", ",", "'Pretraining complete in {:.0f}m {:.0f}s'", ".", "format", "(", "\n", "time_elapsed", "//", "60", ",", "time_elapsed", "%", "60", ")", ")", "\n", "\n", "# load best model weights", "\n", "model", ".", "load_state_dict", "(", "best_model_wts", ")", "\n", "model", ".", "pretrained", "=", "True", "\n", "torch", ".", "save", "(", "model", ".", "state_dict", "(", ")", ",", "pretrained", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.kmeans": [[393, 426], ["sklearn.cluster.KMeans", "model.eval", "sklearn.cluster.KMeans.fit_predict", "torch.from_numpy", "torch.from_numpy", "model.clustering.set_weight", "torch.save", "torch.save", "numpy.save", "input1.to.to", "input2.to.to", "model", "torch.from_numpy.to", "numpy.concatenate", "outputs.cpu().detach().numpy", "outputs.cpu().detach().numpy", "outputs.cpu().detach", "outputs.cpu().detach", "outputs.cpu", "outputs.cpu"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.None.nets.ClusterlingLayer.set_weight"], ["", "def", "kmeans", "(", "model", ",", "dataloader", ",", "params", ")", ":", "\n", "    ", "km", "=", "KMeans", "(", "n_clusters", "=", "model", ".", "num_clusters", ",", "n_init", "=", "20", ")", "\n", "output_array", "=", "None", "\n", "model", ".", "eval", "(", ")", "\n", "x_input", "=", "[", "]", "\n", "# Itarate throught the data and concatenate the latent space representations of images", "\n", "for", "data", "in", "dataloader", ":", "\n", "        ", "input1", ",", "input2", ",", "sim_score", ",", "_", ",", "_", "=", "data", "\n", "input1", "=", "input1", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "input2", "=", "input2", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "_", ",", "_", ",", "_", ",", "outputs", ",", "_", ",", "_", "=", "model", "(", "input1", ",", "input2", ")", "\n", "if", "output_array", "is", "not", "None", ":", "\n", "            ", "output_array", "=", "np", ".", "concatenate", "(", "(", "output_array", ",", "outputs", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "output_array", "=", "outputs", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "#print(output_array.shape)", "\n", "#if output_array.shape[0] > 50000: break", "\n", "#x_input.append(inputs.detach().cpu())", "\n", "\n", "# Perform K-means", "\n", "", "", "predicted", "=", "km", ".", "fit_predict", "(", "output_array", ")", "\n", "# x = torch.cat(x_input).numpy()", "\n", "# x_sc=np.reshape(x.transpose((0,2,1)),(x.shape[0],-1))", "\n", "# s=metrics.silhouette_score(x_sc, predicted, metric='euclidean')", "\n", "# print('initial s:',s)", "\n", "\n", "# Update clustering layer weights", "\n", "weights", "=", "torch", ".", "from_numpy", "(", "km", ".", "cluster_centers_", ")", "\n", "model", ".", "clustering", ".", "set_weight", "(", "weights", ".", "to", "(", "params", "[", "'device'", "]", ")", ")", "\n", "torch", ".", "save", "(", "weights", ",", "\"weights.pt\"", ")", "\n", "np", ".", "save", "(", "'preds_km.npy'", ",", "predicted", ")", "\n", "# torch.cuda.empty_cache()", "\n", "return", "predicted", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.calculate_predictions": [[429, 451], ["model.eval", "numpy.argmax", "input1.to.to", "input2.to.to", "model", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "outputs.cpu().detach().numpy", "x_rec.cpu().detach().numpy", "embedding.cpu().detach().numpy", "outputs.cpu().detach().numpy", "x_rec.cpu().detach().numpy", "embedding.cpu().detach().numpy", "outputs.cpu().detach", "x_rec.cpu().detach", "embedding.cpu().detach", "outputs.cpu().detach", "x_rec.cpu().detach", "embedding.cpu().detach", "outputs.cpu", "x_rec.cpu", "embedding.cpu", "outputs.cpu", "x_rec.cpu", "embedding.cpu"], "function", ["None"], ["", "def", "calculate_predictions", "(", "model", ",", "dataloader", ",", "params", ")", ":", "\n", "    ", "output_array", "=", "None", "\n", "x_recs", "=", "None", "\n", "embeddings", "=", "None", "\n", "model", ".", "eval", "(", ")", "\n", "for", "data", "in", "dataloader", ":", "\n", "        ", "input1", ",", "input2", ",", "sim_score", ",", "_", ",", "_", "=", "data", "\n", "input1", "=", "input1", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "input2", "=", "input2", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "x_rec", ",", "outputs", ",", "_", ",", "embedding", ",", "_", ",", "_", "=", "model", "(", "input1", ",", "input2", ")", "\n", "if", "output_array", "is", "not", "None", ":", "\n", "            ", "output_array", "=", "np", ".", "concatenate", "(", "(", "output_array", ",", "outputs", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "x_recs", "=", "np", ".", "concatenate", "(", "(", "x_recs", ",", "x_rec", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "embeddings", "=", "np", ".", "concatenate", "(", "(", "embeddings", ",", "embedding", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "output_array", "=", "outputs", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "x_recs", "=", "x_rec", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "embeddings", "=", "embedding", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "", "preds", "=", "np", ".", "argmax", "(", "output_array", ".", "data", ",", "axis", "=", "1", ")", "\n", "# print(output_array.shape)", "\n", "return", "output_array", ",", "preds", "#x_recs, embeddings", "\n", "", "def", "calculate_predictions_test", "(", "model", ",", "dataloader", ",", "params", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.calculate_predictions_test": [[451, 469], ["model.eval", "input1.to.to", "input2.to.to", "model", "torch.max", "torch.max", "numpy.concatenate", "numpy.concatenate", "preds_single.cpu().detach().numpy", "probs_single.cpu().detach().numpy", "preds_single.cpu().detach().numpy", "probs_single.cpu().detach().numpy", "preds_single.cpu().detach", "probs_single.cpu().detach", "preds_single.cpu().detach", "probs_single.cpu().detach", "preds_single.cpu", "probs_single.cpu", "preds_single.cpu", "probs_single.cpu"], "function", ["None"], ["", "def", "calculate_predictions_test", "(", "model", ",", "dataloader", ",", "params", ")", ":", "\n", "    ", "preds", "=", "None", "\n", "probs", "=", "None", "\n", "model", ".", "eval", "(", ")", "\n", "for", "data", "in", "dataloader", ":", "\n", "        ", "input1", ",", "input2", ",", "sim_score", ",", "_", ",", "_", "=", "data", "\n", "input1", "=", "input1", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "input2", "=", "input2", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "x_rec", ",", "clusters", ",", "_", ",", "embedding", ",", "_", ",", "_", "=", "model", "(", "input1", ",", "input2", ")", "\n", "probs_single", ",", "preds_single", "=", "torch", ".", "max", "(", "clusters", ",", "1", ")", "\n", "if", "preds", "is", "not", "None", ":", "\n", "            ", "preds", "=", "np", ".", "concatenate", "(", "(", "preds", ",", "preds_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "probs", "=", "np", ".", "concatenate", "(", "(", "probs", ",", "probs_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "preds", "=", "preds_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "probs", "=", "probs_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "", "return", "preds", ",", "probs", "#x_recs, embeddings", "\n", "", "def", "calculate_predictions_roi", "(", "model", ",", "dataloader", ",", "params", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.calculate_predictions_roi": [[469, 527], ["training_functions_fiber_pair.DiceLoss", "numpy.load", "torch.tensor().to", "torch.tensor().to", "model.eval", "input1.to.to", "input2.to.to", "roi_bat.to.to", "model", "roi_bat.to.unsqueeze().to", "torch.reshape.repeat", "torch.reshape", "torch.reshape", "torch.tensor().to.repeat", "DiceLoss.", "torch.reshape", "torch.reshape", "dis_point.min", "torch.reshape.min", "torch.t", "torch.t", "torch.max", "torch.max", "torch.tensor", "torch.tensor", "torch.t", "torch.t", "torch.sum", "torch.sum", "numpy.concatenate", "numpy.concatenate", "preds_single.cpu().detach().numpy", "probs_single.cpu().detach().numpy", "roi_bat.to.unsqueeze", "preds_single.cpu().detach().numpy", "probs_single.cpu().detach().numpy", "preds_single.cpu().detach", "probs_single.cpu().detach", "preds_single.cpu().detach", "probs_single.cpu().detach", "preds_single.cpu", "probs_single.cpu", "preds_single.cpu", "probs_single.cpu"], "function", ["None"], ["", "def", "calculate_predictions_roi", "(", "model", ",", "dataloader", ",", "params", ")", ":", "\n", "    ", "loss_fn", "=", "DiceLoss", "(", ")", "\n", "import", "numpy", "\n", "roi_cluster", "=", "numpy", ".", "load", "(", "'roi_cluster_fs_1.npy'", ")", "\n", "roi_cluster", "=", "torch", ".", "tensor", "(", "roi_cluster", ")", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "model", ".", "eval", "(", ")", "\n", "preds", "=", "None", "\n", "probs", "=", "None", "\n", "for", "data", "in", "dataloader", ":", "\n", "        ", "input1", ",", "input2", ",", "sim_score", ",", "roi_bat", ",", "_", "=", "data", "\n", "input1", "=", "input1", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "input2", "=", "input2", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "roi_bat", "=", "roi_bat", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "outputs", ",", "clusters", ",", "_", ",", "embedding", ",", "_", ",", "dis_point", "=", "model", "(", "input1", ",", "input2", ")", "\n", "n_label", "=", "64", "\n", "# roi_batch = torch.zeros([outputs.shape[0], n_label])", "\n", "# for j in range(outputs.shape[0]):", "\n", "#     roi_onehot = torch.zeros([n_label]).to(params['device'])", "\n", "#     roi_label = torch.unique(roi_bat[j])", "\n", "#     if 0 in roi_label:", "\n", "#         index_0 = roi_label != 0", "\n", "#         roi_label = roi_label[index_0]", "\n", "#     roi_onehot[roi_label.long()] = 1", "\n", "#     roi_batch[j] = roi_onehot", "\n", "roi_3D", "=", "roi_bat", ".", "unsqueeze", "(", "1", ")", ".", "to", "(", "params", "[", "'device'", "]", ")", "\n", "roi_3D", "=", "roi_3D", ".", "repeat", "(", "1", ",", "model", ".", "num_clusters", ",", "1", ")", "\n", "roi_3D", "=", "torch", ".", "reshape", "(", "roi_3D", ",", "(", "-", "1", ",", "roi_3D", ".", "shape", "[", "-", "1", "]", ")", ")", "\n", "roi_cluster_3D", "=", "roi_cluster", ".", "repeat", "(", "outputs", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "dis_roi1", "=", "loss_fn", "(", "roi_3D", ",", "roi_cluster_3D", ")", "\n", "dis_roi", "=", "torch", ".", "reshape", "(", "dis_roi1", ",", "(", "outputs", ".", "shape", "[", "0", "]", ",", "model", ".", "num_clusters", ")", ")", "\n", "# calculate new p", "\n", "# alpha = dis_point.max()", "\n", "_", ",", "pred_point", "=", "dis_point", ".", "min", "(", "1", ")", "\n", "_", ",", "pred_roi", "=", "dis_roi", ".", "min", "(", "1", ")", "\n", "x", "=", "1.0", "+", "dis_point", "*", "dis_roi", "\n", "x", "=", "1.0", "/", "x", "\n", "x", "=", "torch", ".", "t", "(", "x", ")", "/", "torch", ".", "sum", "(", "x", ",", "dim", "=", "1", ")", "\n", "x", "=", "torch", ".", "t", "(", "x", ")", "\n", "clusters", "=", "x", "\n", "#_, preds = torch.max(clusters, 1)", "\n", "\n", "probs_single", ",", "preds_single", "=", "torch", ".", "max", "(", "clusters", ",", "1", ")", "\n", "if", "preds", "is", "not", "None", ":", "\n", "            ", "preds", "=", "np", ".", "concatenate", "(", "(", "preds", ",", "preds_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "probs", "=", "np", ".", "concatenate", "(", "(", "probs", ",", "probs_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "preds", "=", "preds_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "probs", "=", "probs_single", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# if output_array is not None:", "\n", "#     output_array = np.concatenate((output_array, clusters.cpu().detach().numpy()), 0)", "\n", "# else:", "\n", "#     output_array = clusters.cpu().detach().numpy()", "\n", "\n", "# preds = np.argmax(output_array.data, axis=1)", "\n", "# probs = np.max(output_array.data, axis=1)", "\n", "# print(output_array.shape)", "\n", "", "", "return", "preds", ",", "probs", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.target": [[529, 533], ["numpy.transpose", "numpy.sum", "numpy.transpose", "numpy.sum"], "function", ["None"], ["", "def", "target", "(", "out_distr", ")", ":", "\n", "    ", "tar_dist", "=", "out_distr", "**", "2", "/", "np", ".", "sum", "(", "out_distr", ",", "axis", "=", "0", ")", "\n", "tar_dist", "=", "np", ".", "transpose", "(", "np", ".", "transpose", "(", "tar_dist", ")", "/", "np", ".", "sum", "(", "tar_dist", ",", "axis", "=", "1", ")", ")", "\n", "return", "tar_dist", "\n", "", "def", "target_distribution", "(", "batch", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.training_functions_fiber_pair.target_distribution": [[533, 543], ["torch.sum", "torch.sum", "weight.t", "torch.sum", "torch.sum"], "function", ["None"], ["", "def", "target_distribution", "(", "batch", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "\"\"\"\n    Compute the target distribution p_ij, given the batch (q_ij), as in 3.1.3 Equation 3 of\n    Xie/Girshick/Farhadi; this is used the KL-divergence loss function.\n\n    :param batch: [batch size, number of clusters] Tensor of dtype float\n    :return: [batch size, number of clusters] Tensor of dtype float\n    \"\"\"", "\n", "weight", "=", "(", "batch", "**", "2", ")", "/", "torch", ".", "sum", "(", "batch", ",", "0", ")", "\n", "return", "(", "weight", ".", "t", "(", ")", "/", "torch", ".", "sum", "(", "weight", ",", "1", ")", ")", ".", "t", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.DiceScore.__init__": [[21, 23], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DiceScore", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.DiceScore.forward": [[24, 35], ["loss.sum", "intersection.sum", "input.sum", "target.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "N", "=", "target", ".", "shape", "[", "0", "]", "\n", "smooth", "=", "1", "\n", "# intersection = input_flat == target_flat", "\n", "# loss = ((intersection.sum(1) + smooth)).float() / (input_flat.size(1)+ smooth)", "\n", "intersection", "=", "input", "*", "target", "\n", "# if torch.sum(intersection)==0:", "\n", "#     print('0')", "\n", "loss", "=", "(", "2", "*", "intersection", ".", "sum", "(", "1", ")", "+", "smooth", ")", "/", "(", "input", ".", "sum", "(", "1", ")", "+", "target", ".", "sum", "(", "1", ")", "+", "smooth", ")", "\n", "loss", "=", "loss", ".", "sum", "(", ")", "/", "N", "\n", "return", "loss", "\n", "", "", "def", "convert_fiber_to_array", "(", "inputFile", ",", "numberOfFibers", ",", "fiberLength", ",", "numberOfFiberPoints", ",", "preproces", "=", "True", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.convert_fiber_to_array": [[35, 80], ["print", "print", "print", "print", "print", "whitematteranalysis.io.read_polydata", "fibers.FiberArray", "fibers.FiberArray.convert_from_polydata", "numpy.dstack", "os.path.exists", "print", "exit", "print", "print", "print", "whitematteranalysis.filter.preprocess", "print", "whitematteranalysis.filter.downsample", "abs"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.convert_from_polydata", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.downsample"], ["", "", "def", "convert_fiber_to_array", "(", "inputFile", ",", "numberOfFibers", ",", "fiberLength", ",", "numberOfFiberPoints", ",", "preproces", "=", "True", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "inputFile", ")", ":", "\n", "        ", "print", "(", "\"<wm_cluster_from_atlas.py> Error: Input file\"", ",", "inputFile", ",", "\"does not exist.\"", ")", "\n", "exit", "(", ")", "\n", "", "print", "(", "\"\\n==========================\"", ")", "\n", "print", "(", "\"input file:\"", ",", "inputFile", ")", "\n", "\n", "if", "numberOfFibers", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"fibers to analyze per subject: \"", ",", "numberOfFibers", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"fibers to analyze per subject: ALL\"", ")", "\n", "", "number_of_fibers", "=", "numberOfFibers", "\n", "fiber_length", "=", "fiberLength", "\n", "print", "(", "\"minimum length of fibers to analyze (in mm): \"", ",", "fiber_length", ")", "\n", "points_per_fiber", "=", "numberOfFiberPoints", "\n", "print", "(", "\"Number of points in each fiber to process: \"", ",", "points_per_fiber", ")", "\n", "\n", "# read data", "\n", "print", "(", "\"<wm_cluster_with_DEC.py> Reading input file:\"", ",", "inputFile", ")", "\n", "pd", "=", "wma", ".", "io", ".", "read_polydata", "(", "inputFile", ")", "\n", "\n", "if", "preproces", ":", "\n", "# preprocessing step: minimum length", "\n", "        ", "print", "(", "\"<wm_cluster_from_atlas.py> Preprocessing by length:\"", ",", "fiber_length", ",", "\"mm.\"", ")", "\n", "pd2", "=", "wma", ".", "filter", ".", "preprocess", "(", "pd", ",", "fiber_length", ",", "return_indices", "=", "False", ",", "preserve_point_data", "=", "True", ",", "\n", "preserve_cell_data", "=", "True", ",", "verbose", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "pd2", "=", "pd", "\n", "\n", "# downsampling fibers if needed", "\n", "", "if", "number_of_fibers", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"<wm_cluster_from_atlas.py> Downsampling to \"", ",", "number_of_fibers", ",", "\"fibers.\"", ")", "\n", "input_data", "=", "wma", ".", "filter", ".", "downsample", "(", "pd2", ",", "number_of_fibers", ",", "return_indices", "=", "False", ",", "preserve_point_data", "=", "True", ",", "\n", "preserve_cell_data", "=", "True", ",", "verbose", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "input_data", "=", "pd2", "\n", "\n", "", "fiber_array", "=", "fibers", ".", "FiberArray", "(", ")", "\n", "fiber_array", ".", "convert_from_polydata", "(", "input_data", ",", "points_per_fiber", "=", "args", ".", "numberOfFiberPoints", ")", "\n", "feat", "=", "numpy", ".", "dstack", "(", "(", "abs", "(", "fiber_array", ".", "fiber_array_r", ")", ",", "fiber_array", ".", "fiber_array_a", ",", "fiber_array", ".", "fiber_array_s", ")", ")", "\n", "feat_ROI", "=", "fiber_array", ".", "roi_list", "\n", "feat_surf_ve", "=", "fiber_array", ".", "fiber_surface_ve", "\n", "feat_surf_dk", "=", "fiber_array", ".", "fiber_surface_dk", "\n", "feat_surf_des", "=", "fiber_array", ".", "fiber_surface_des", "\n", "return", "input_data", ",", "feat", ",", "feat_ROI", ",", "feat_surf_ve", ",", "feat_surf_dk", ",", "feat_surf_des", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.cluster_save": [[81, 132], ["print", "list", "list", "list", "range", "print", "zip", "numpy.array", "print", "os.path.join", "whitematteranalysis.mrml.write", "print", "print", "os.path.exists", "os.makedirs", "numpy.sum", "numpy.array.append", "list.append", "os.path.join", "list.append", "whitematteranalysis.io.write_polydata", "numpy.mean", "numpy.min", "numpy.max", "numpy.around", "print", "numpy.array", "print", "whitematteranalysis.render.render", "wma.render.render.save_views", "print"], "function", ["None"], ["", "def", "cluster_save", "(", "pd_c_list", ",", "outdir", ",", "input_pd", ",", "cluster_numbers_s", ",", "number_of_clusters", ",", "cluster_colors", ")", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "exists", "(", "outdir", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "outdir", ")", "\n", "", "print", "(", "'<wm_cluster_atlas.py> Saving output cluster files in directory:'", ",", "outdir", ")", "\n", "cluster_sizes", "=", "list", "(", ")", "\n", "cluster_fnames", "=", "list", "(", ")", "\n", "fnames", "=", "list", "(", ")", "\n", "# cluster_colors = list()", "\n", "for", "c", "in", "range", "(", "number_of_clusters", ")", ":", "\n", "                ", "mask", "=", "cluster_numbers_s", "==", "c", "\n", "cluster_size", "=", "numpy", ".", "sum", "(", "mask", ")", "\n", "cluster_sizes", ".", "append", "(", "cluster_size", ")", "\n", "pd_c", "=", "pd_c_list", "[", "c", "]", "\n", "# The clusters are stored starting with 1, not 0, for user friendliness.", "\n", "fname_c", "=", "'cluster_{0:05d}.vtp'", ".", "format", "(", "c", "+", "1", ")", "\n", "# save the filename for writing into the MRML file", "\n", "fnames", ".", "append", "(", "fname_c", ")", "\n", "# prepend the output directory", "\n", "fname_c", "=", "os", ".", "path", ".", "join", "(", "outdir", ",", "fname_c", ")", "\n", "cluster_fnames", ".", "append", "(", "fname_c", ")", "\n", "wma", ".", "io", ".", "write_polydata", "(", "pd_c", ",", "fname_c", ")", "\n", "\n", "# Notify user if some clusters empty", "\n", "", "print", "(", "\n", "\"<wm_cluster_atlas.py> Checking for empty clusters (can be due to anatomical variability or too few fibers analyzed).\"", ")", "\n", "for", "sz", ",", "fname", "in", "zip", "(", "cluster_sizes", ",", "cluster_fnames", ")", ":", "\n", "                ", "if", "sz", "==", "0", ":", "\n", "                    ", "print", "(", "sz", ",", "\":\"", ",", "fname", ")", "\n", "\n", "", "", "cluster_sizes", "=", "numpy", ".", "array", "(", "cluster_sizes", ")", "\n", "print", "(", "\"<wm_cluster_from_atlas.py> Mean number of fibers per cluster:\"", ",", "numpy", ".", "mean", "(", "cluster_sizes", ")", ",", "\n", "\"Range:\"", ",", "\n", "numpy", ".", "min", "(", "cluster_sizes", ")", ",", "\"..\"", ",", "numpy", ".", "max", "(", "cluster_sizes", ")", ")", "\n", "# Also write one with 100%% of fibers displayed", "\n", "fname", "=", "os", ".", "path", ".", "join", "(", "outdir", ",", "'clustered_tracts_display_100_percent.mrml'", ")", "\n", "wma", ".", "mrml", ".", "write", "(", "fnames", ",", "numpy", ".", "around", "(", "numpy", ".", "array", "(", "cluster_colors", ")", ",", "decimals", "=", "3", ")", ",", "fname", ",", "ratio", "=", "1.0", ")", "\n", "render", "=", "True", "\n", "# View the whole thing in png format for quality control", "\n", "if", "render", ":", "\n", "\n", "                ", "try", ":", "\n", "                    ", "print", "(", "'<wm_cluster_from_atlas.py> Rendering and saving images of clustered subject.'", ")", "\n", "ren", "=", "wma", ".", "render", ".", "render", "(", "input_pd", ",", "1000", ",", "data_mode", "=", "'Cell'", ",", "data_name", "=", "'EmbeddingColor'", ",", "\n", "verbose", "=", "False", ")", "\n", "ren", ".", "save_views", "(", "outdir", ")", "\n", "del", "ren", "\n", "", "except", ":", "\n", "                    ", "print", "(", "'<wm_cluster_from_atlas.py> No X server available.'", ")", "\n", "\n", "", "", "print", "(", "\"\\n==========================\"", ")", "\n", "print", "(", "'<wm_cluster_from_atlas.py> Done clustering subject.  See output in directory:\\n '", ",", "outdir", ",", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.str2bool": [[133, 140], ["v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["", "def", "str2bool", "(", "v", ")", ":", "\n", "        ", "if", "v", ".", "lower", "(", ")", "in", "(", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", ")", ":", "\n", "            ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", ")", ":", "\n", "            ", "return", "False", "\n", "", "else", ":", "\n", "            ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "", "", "def", "DB_index", "(", "x_array", ",", "predicted", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.DB_index": [[140, 187], ["numpy.unique", "numpy.reshape", "list", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.zeros", "numpy.zeros", "range", "c.append", "alpha.append", "len", "copy.deepcopy", "copy.deepcopy", "numpy.array", "numpy.array", "numpy.max", "numpy.min", "DB_all.append", "numpy.mean.append", "len", "len", "numpy.random.seed", "numpy.random.randint", "len", "numpy.isnan().any", "len", "fiber_distance.fiber_distance", "numpy.sum", "len", "numpy.isnan().any", "fiber_distance.fiber_distance", "fiber_distance.fiber_distance", "len", "len", "len", "len", "numpy.sum", "numpy.isnan", "numpy.argmin", "len", "numpy.isnan", "len"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance"], ["", "", "def", "DB_index", "(", "x_array", ",", "predicted", ")", ":", "\n", "#Sprint('mask')", "\n", "    ", "cluster_id", "=", "numpy", ".", "unique", "(", "predicted", ")", "\n", "fiber_array", "=", "numpy", ".", "reshape", "(", "x_array", ",", "(", "len", "(", "x_array", ")", ",", "-", "1", ",", "3", ")", ")", "\n", "alpha", "=", "[", "]", "\n", "c", "=", "[", "]", "\n", "for", "i", "in", "list", "(", "cluster_id", ")", ":", "\n", "        ", "d_cluster", "=", "fiber_array", "[", "predicted", "==", "i", "]", "\n", "assert", "not", "len", "(", "d_cluster", ")", "==", "0", "\n", "if", "len", "(", "d_cluster", ")", ">", "100", ":", "\n", "            ", "numpy", ".", "random", ".", "seed", "(", "12345", ")", "\n", "index", "=", "numpy", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "d_cluster", ")", ",", "100", ")", "\n", "#print(index)", "\n", "d_cluster", "=", "d_cluster", "[", "index", "]", "\n", "", "distance_array", "=", "numpy", ".", "zeros", "(", "(", "len", "(", "d_cluster", ")", ",", "len", "(", "d_cluster", ")", ")", ")", "\n", "distance_sum", "=", "numpy", ".", "zeros", "(", "(", "len", "(", "d_cluster", ")", ")", ")", "\n", "assert", "not", "numpy", ".", "isnan", "(", "c", ")", ".", "any", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "d_cluster", ")", ")", ":", "\n", "            ", "fiber", "=", "d_cluster", "[", "j", "]", "\n", "distance", "=", "fiber_distance", ".", "fiber_distance", "(", "fiber", ",", "d_cluster", ")", "\n", "distance_array", "[", "j", ",", ":", "]", "=", "distance", "\n", "distance_sum", "[", "j", "]", "=", "numpy", ".", "sum", "(", "distance", ")", "\n", "", "c", ".", "append", "(", "d_cluster", "[", "numpy", ".", "argmin", "(", "distance_sum", ")", "]", ")", "\n", "if", "len", "(", "d_cluster", ")", "==", "1", ":", "\n", "            ", "distance_clu", "=", "0", "\n", "", "else", ":", "\n", "            ", "distance_clu", "=", "numpy", ".", "sum", "(", "distance_array", ")", "/", "(", "len", "(", "d_cluster", ")", "*", "(", "len", "(", "d_cluster", ")", "-", "1", ")", ")", "\n", "", "alpha", ".", "append", "(", "distance_clu", ")", "\n", "assert", "not", "numpy", ".", "isnan", "(", "alpha", ")", ".", "any", "(", ")", "\n", "", "DB_all", "=", "[", "]", "\n", "dis_inter", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "cluster_id", ")", ")", ":", "\n", "        ", "alpha1", "=", "copy", ".", "deepcopy", "(", "alpha", ")", "\n", "c1", "=", "copy", ".", "deepcopy", "(", "c", ")", "\n", "del", "c1", "[", "i", "]", "\n", "del", "alpha1", "[", "i", "]", "\n", "c1", "=", "numpy", ".", "array", "(", "c1", ")", "\n", "alpha1", "=", "numpy", ".", "array", "(", "alpha1", ")", "\n", "temp", "=", "(", "alpha", "[", "i", "]", "+", "alpha1", ")", "/", "(", "fiber_distance", ".", "fiber_distance", "(", "c", "[", "i", "]", ",", "c1", ")", ")", "\n", "DB_clu", "=", "numpy", ".", "max", "(", "temp", ")", "\n", "dis_inter_clu", "=", "numpy", ".", "min", "(", "fiber_distance", ".", "fiber_distance", "(", "c", "[", "i", "]", ",", "c1", ")", ")", "\n", "DB_all", ".", "append", "(", "DB_clu", ")", "\n", "dis_inter", ".", "append", "(", "dis_inter_clu", ")", "\n", "", "DB", "=", "numpy", ".", "mean", "(", "DB_all", ")", "\n", "dis_intra", "=", "numpy", ".", "mean", "(", "alpha", ")", "\n", "dis_inter", "=", "numpy", ".", "mean", "(", "dis_inter", ")", "\n", "return", "DB", ",", "dis_intra", ",", "dis_inter", "\n", "", "def", "DB_index3", "(", "x_array", ",", "predicted", ")", ":", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.None.test.DB_index3": [[187, 240], ["numpy.unique", "numpy.reshape", "numpy.zeros", "enumerate", "range", "numpy.array", "numpy.mean", "numpy.array", "numpy.array", "len", "list", "numpy.zeros", "numpy.zeros", "range", "c.append", "alpha.append", "len", "copy.deepcopy", "copy.deepcopy", "numpy.array", "numpy.array", "numpy.max", "numpy.array.append", "numpy.min", "numpy.array.append", "len", "len", "len", "numpy.random.seed", "numpy.random.randint", "len", "numpy.isnan().any", "len", "fiber_distance.fiber_distance", "numpy.sum", "len", "numpy.isnan().any", "fiber_distance.fiber_distance", "fiber_distance.fiber_distance", "numpy.where", "len", "len", "len", "len", "numpy.sum", "numpy.isnan", "numpy.argmin", "len", "numpy.isnan", "len"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance"], ["", "def", "DB_index3", "(", "x_array", ",", "predicted", ")", ":", "\n", "#Sprint('mask')", "\n", "    ", "cluster_id", "=", "numpy", ".", "unique", "(", "predicted", ")", "\n", "fiber_array", "=", "numpy", ".", "reshape", "(", "x_array", ",", "(", "len", "(", "x_array", ")", ",", "-", "1", ",", "3", ")", ")", "\n", "alpha", "=", "[", "]", "\n", "c", "=", "[", "]", "\n", "flag_detected", "=", "numpy", ".", "zeros", "(", "len", "(", "cluster_id", ")", ")", "\n", "for", "id", ",", "i", "in", "enumerate", "(", "list", "(", "cluster_id", ")", ")", ":", "\n", "        ", "d_cluster", "=", "fiber_array", "[", "predicted", "==", "i", "]", "\n", "assert", "not", "len", "(", "d_cluster", ")", "==", "0", "\n", "if", "len", "(", "d_cluster", ")", ">", "20", ":", "\n", "            ", "flag_detected", "[", "id", "]", "=", "1", "\n", "", "if", "len", "(", "d_cluster", ")", ">", "100", ":", "\n", "            ", "numpy", ".", "random", ".", "seed", "(", "12345", ")", "\n", "index", "=", "numpy", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "d_cluster", ")", ",", "100", ")", "\n", "#print(index)", "\n", "d_cluster", "=", "d_cluster", "[", "index", "]", "\n", "", "distance_array", "=", "numpy", ".", "zeros", "(", "(", "len", "(", "d_cluster", ")", ",", "len", "(", "d_cluster", ")", ")", ")", "\n", "distance_sum", "=", "numpy", ".", "zeros", "(", "(", "len", "(", "d_cluster", ")", ")", ")", "\n", "assert", "not", "numpy", ".", "isnan", "(", "c", ")", ".", "any", "(", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "d_cluster", ")", ")", ":", "\n", "            ", "fiber", "=", "d_cluster", "[", "j", "]", "\n", "distance", "=", "fiber_distance", ".", "fiber_distance", "(", "fiber", ",", "d_cluster", ")", "\n", "distance_array", "[", "j", ",", ":", "]", "=", "distance", "\n", "distance_sum", "[", "j", "]", "=", "numpy", ".", "sum", "(", "distance", ")", "\n", "", "c", ".", "append", "(", "d_cluster", "[", "numpy", ".", "argmin", "(", "distance_sum", ")", "]", ")", "\n", "if", "len", "(", "d_cluster", ")", "==", "1", ":", "\n", "            ", "distance_clu", "=", "0", "\n", "", "else", ":", "\n", "            ", "distance_clu", "=", "numpy", ".", "sum", "(", "distance_array", ")", "/", "(", "len", "(", "d_cluster", ")", "*", "(", "len", "(", "d_cluster", ")", "-", "1", ")", ")", "\n", "", "alpha", ".", "append", "(", "distance_clu", ")", "\n", "#alpha.append(numpy.mean(distance_array))", "\n", "assert", "not", "numpy", ".", "isnan", "(", "alpha", ")", ".", "any", "(", ")", "\n", "", "DB_all", "=", "[", "]", "\n", "dis_inter", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "cluster_id", ")", ")", ":", "\n", "        ", "alpha1", "=", "copy", ".", "deepcopy", "(", "alpha", ")", "\n", "c1", "=", "copy", ".", "deepcopy", "(", "c", ")", "\n", "del", "c1", "[", "i", "]", "\n", "del", "alpha1", "[", "i", "]", "\n", "c1", "=", "numpy", ".", "array", "(", "c1", ")", "\n", "alpha1", "=", "numpy", ".", "array", "(", "alpha1", ")", "\n", "temp", "=", "(", "alpha", "[", "i", "]", "+", "alpha1", ")", "/", "(", "fiber_distance", ".", "fiber_distance", "(", "c", "[", "i", "]", ",", "c1", ")", ")", "\n", "DB_clu", "=", "numpy", ".", "max", "(", "temp", ")", "\n", "DB_all", ".", "append", "(", "DB_clu", ")", "\n", "dis_inter_clu", "=", "numpy", ".", "min", "(", "fiber_distance", ".", "fiber_distance", "(", "c", "[", "i", "]", ",", "c1", ")", ")", "\n", "dis_inter", ".", "append", "(", "dis_inter_clu", ")", "\n", "", "DB_all", "=", "numpy", ".", "array", "(", "DB_all", ")", "\n", "DB_all1", "=", "DB_all", "[", "numpy", ".", "where", "(", "flag_detected", "==", "1", ")", "]", "\n", "DB", "=", "numpy", ".", "mean", "(", "DB_all1", ")", "\n", "dis_intra", "=", "numpy", ".", "array", "(", "alpha", ")", "\n", "dis_inter", "=", "numpy", ".", "array", "(", "dis_inter", ")", "\n", "return", "DB", ",", "DB_all", ",", "dis_intra", ",", "dis_inter", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RAS": [[10, 29], ["utils.fibers.FiberArray", "fibers.FiberArray.convert_from_polydata", "numpy.dstack", "numpy.dstack", "numpy.dstack", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.convert_from_polydata"], ["def", "feat_RAS", "(", "pd_tract", ",", "number_of_points", "=", "15", ",", "bilateral", "=", "False", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "fiber_array", "=", "fibers", ".", "FiberArray", "(", ")", "\n", "fiber_array", ".", "convert_from_polydata", "(", "pd_tract", ",", "points_per_fiber", "=", "number_of_points", ")", "\n", "if", "bilateral", "is", "True", ":", "\n", "\t\t", "feat", "=", "np", ".", "dstack", "(", "(", "abs", "(", "fiber_array", ".", "fiber_array_r", ")", ",", "fiber_array", ".", "fiber_array_a", ",", "fiber_array", ".", "fiber_array_s", ")", ")", "\n", "featf", "=", "np", ".", "dstack", "(", "(", "abs", "(", "fiber_array", ".", "fiber_array_r", "[", ":", ",", ":", ":", "-", "1", "]", ")", ",", "fiber_array", ".", "fiber_array_a", "[", ":", ",", ":", ":", "-", "1", "]", ",", "fiber_array", ".", "fiber_array_s", "[", ":", ",", ":", ":", "-", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "\t\t", "feat", "=", "np", ".", "dstack", "(", "(", "fiber_array", ".", "fiber_array_r", ",", "fiber_array", ".", "fiber_array_a", ",", "fiber_array", ".", "fiber_array_s", ")", ")", "\n", "", "featp", "=", "fiber_array", ".", "fiber_array_p", "\n", "roi_list", "=", "fiber_array", ".", "roi_list", "\n", "return", "feat", ",", "featf", ",", "roi_list", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_orientation": [[30, 61], ["tract_feat.feat_RAS", "numpy.zeros", "numpy.concatenate", "numpy.concatenate", "numpy.sqrt", "numpy.sqrt", "range", "numpy.concatenate", "numpy.sum", "numpy.sum", "numpy.square", "numpy.square"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RAS"], ["", "def", "feat_orientation", "(", "pd_tract", ",", "number_of_points", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "feat_RAS_", "=", "feat_RAS", "(", "pd_tract", ",", "number_of_points", "=", "number_of_points", ")", "\n", "\n", "margin_zeros", "=", "np", ".", "zeros", "(", "(", "feat_RAS_", ".", "shape", "[", "0", "]", ",", "1", ",", "feat_RAS_", ".", "shape", "[", "2", "]", ")", ")", "\n", "\n", "# the last point does not have Next", "\n", "diff_to_next", "=", "np", ".", "concatenate", "(", "(", "feat_RAS_", "[", ":", ",", ":", "-", "1", ",", ":", "]", "-", "feat_RAS_", "[", ":", ",", "1", ":", ",", ":", "]", ",", "margin_zeros", ")", ",", "axis", "=", "1", ")", "\n", "# the first point does not have Previous", "\n", "diff_to_prev", "=", "np", ".", "concatenate", "(", "(", "margin_zeros", ",", "feat_RAS_", "[", ":", ",", "1", ":", ",", ":", "]", "-", "feat_RAS_", "[", ":", ",", ":", "-", "1", ",", ":", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "norm_diff_to_next", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "diff_to_next", ")", ",", "axis", "=", "2", ")", ")", "\n", "norm_diff_to_prev", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "square", "(", "diff_to_prev", ")", ",", "axis", "=", "2", ")", ")", "\n", "\n", "# normalize", "\n", "for", "idx", "in", "range", "(", "diff_to_next", ".", "shape", "[", "2", "]", ")", ":", "\n", "\n", "\t\t", "diff_to_next", "[", "...", ",", "idx", "]", "=", "diff_to_next", "[", "...", ",", "idx", "]", "/", "norm_diff_to_next", "\n", "\n", "diff_to_prev", "[", "...", ",", "idx", "]", "=", "diff_to_prev", "[", "...", ",", "idx", "]", "/", "norm_diff_to_prev", "\n", "\n", "", "feat", "=", "np", ".", "concatenate", "(", "(", "feat_RAS_", ",", "diff_to_prev", ",", "diff_to_next", ")", ",", "axis", "=", "2", ")", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_curv_tors": [[62, 79], ["utils.fibers.FiberArray", "fibers.FiberArray.convert_from_polydata_with_trafic", "numpy.dstack"], "function", ["None"], ["", "def", "feat_curv_tors", "(", "pd_tract", ",", "number_of_points", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "fiber_array", "=", "fibers", ".", "FiberArray", "(", ")", "\n", "fiber_array", ".", "convert_from_polydata_with_trafic", "(", "pd_tract", ",", "points_per_fiber", "=", "number_of_points", ")", "\n", "\n", "\n", "feat", "=", "np", ".", "dstack", "(", "(", "fiber_array", ".", "fiber_array_cur", ",", "fiber_array", ".", "fiber_array_tor", ")", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RAS_curv_tors": [[80, 97], ["utils.fibers.FiberArray", "fibers.FiberArray.convert_from_polydata_with_trafic", "numpy.dstack"], "function", ["None"], ["", "def", "feat_RAS_curv_tors", "(", "pd_tract", ",", "number_of_points", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "fiber_array", "=", "fibers", ".", "FiberArray", "(", ")", "\n", "fiber_array", ".", "convert_from_polydata_with_trafic", "(", "pd_tract", ",", "points_per_fiber", "=", "number_of_points", ")", "\n", "\n", "\n", "feat", "=", "np", ".", "dstack", "(", "(", "fiber_array", ".", "fiber_array_r", ",", "fiber_array", ".", "fiber_array_a", ",", "fiber_array", ".", "fiber_array_s", ",", "fiber_array", ".", "fiber_array_cur", ",", "fiber_array", ".", "fiber_array_tor", ")", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RASF": [[98, 116], ["utils.fibers.FiberArray", "fibers.FiberArray.convert_from_polydata_with_FS", "tract_feat._transform_fs_labels", "numpy.dstack"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._transform_fs_labels"], ["", "def", "feat_RASF", "(", "pd_tract", ",", "number_of_points", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "fiber_array", "=", "fibers", ".", "FiberArray", "(", ")", "\n", "fiber_array", ".", "convert_from_polydata_with_FS", "(", "pd_tract", ",", "points_per_fiber", "=", "number_of_points", ")", "\n", "\n", "fiber_array_fs_t", "=", "_transform_fs_labels", "(", "fiber_array", ".", "fiber_array_fs", ")", "\n", "\n", "feat", "=", "np", ".", "dstack", "(", "(", "fiber_array", ".", "fiber_array_r", ",", "fiber_array", ".", "fiber_array_a", ",", "fiber_array", ".", "fiber_array_s", ",", "fiber_array_fs_t", ")", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RAS_3D": [[117, 135], ["tract_feat.feat_RAS", "tract_feat._feat_to_3D", "tract_feat._feat_to_3D", "feat.reshape"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RAS", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D"], ["", "def", "feat_RAS_3D", "(", "pd_tract", ",", "number_of_points", "=", "15", ",", "repeat_time", "=", "15", ",", "bilateral", "=", "False", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "feat", ",", "featf", ",", "featp", "=", "feat_RAS", "(", "pd_tract", ",", "number_of_points", "=", "number_of_points", ",", "bilateral", "=", "bilateral", ")", "\n", "#featp=np.expand_dims(featp, axis=2)", "\n", "feat_1221_2112_repeat", "=", "_feat_to_3D", "(", "feat", ",", "repeat_time", "=", "repeat_time", ")", "\n", "feat_1221_2112_repeatf", "=", "_feat_to_3D", "(", "featf", ",", "repeat_time", "=", "repeat_time", ")", "\n", "#feat_1221_2112_repeatp = _feat_to_3D(featp, repeat_time=repeat_time)", "\n", "#feat_com=np.concatenate((feat_1221_2112_repeat,feat_1221_2112_repeatf),axis=-1)", "\n", "feat_array", "=", "feat", ".", "reshape", "(", "feat", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "return", "feat_1221_2112_repeat", ",", "feat_array", ",", "feat_1221_2112_repeatf", ",", "featp", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RASF_3D": [[136, 151], ["tract_feat.feat_RASF", "tract_feat._feat_to_3D"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_RASF", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D"], ["", "def", "feat_RASF_3D", "(", "pd_tract", ",", "number_of_points", "=", "15", ",", "repeat_time", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "feat", "=", "feat_RASF", "(", "pd_tract", ",", "number_of_points", "=", "number_of_points", ")", "\n", "\n", "feat_1221_2112_repeat", "=", "_feat_to_3D", "(", "feat", ",", "repeat_time", "=", "repeat_time", ")", "\n", "\n", "return", "feat_1221_2112_repeat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_orientation_3D": [[152, 167], ["tract_feat.feat_orientation", "tract_feat._feat_to_3D"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_orientation", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D"], ["", "def", "feat_orientation_3D", "(", "pd_tract", ",", "number_of_points", "=", "15", ",", "repeat_time", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "feat", "=", "feat_orientation", "(", "pd_tract", ",", "number_of_points", "=", "number_of_points", ")", "\n", "\n", "feat_1221_2112_repeat", "=", "_feat_to_3D", "(", "feat", ",", "repeat_time", "=", "repeat_time", ")", "\n", "\n", "return", "feat_1221_2112_repeat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.feat_1D": [[168, 184], ["whitematteranalysis.fibers.FiberArray", "wma.fibers.FiberArray.convert_from_polydata", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.convert_from_polydata"], ["", "def", "feat_1D", "(", "pd_tract", ",", "number_of_points", "=", "15", ")", ":", "\n", "\n", "\t", "\"\"\"The most simple feature for initial test\n\n\tParameters\n\t----------\n\tTODO:\n\n\t\"\"\"", "\n", "\n", "fiber_array", "=", "wma", ".", "fibers", ".", "FiberArray", "(", ")", "\n", "fiber_array", ".", "convert_from_polydata", "(", "pd_tract", ",", "points_per_fiber", "=", "number_of_points", ")", "\n", "\n", "feat", "=", "np", ".", "concatenate", "(", "(", "fiber_array", ".", "fiber_array_r", ",", "fiber_array", ".", "fiber_array_a", ",", "fiber_array", ".", "fiber_array_s", ")", ",", "axis", "=", "1", ")", "\n", "\n", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D": [[187, 220], ["numpy.flip", "numpy.concatenate", "numpy.concatenate", "numpy.reshape", "numpy.reshape", "numpy.concatenate", "numpy.repeat", "numpy.zeros"], "function", ["None"], ["", "def", "_feat_to_3D", "(", "feat", ",", "repeat_time", "=", "15", ")", ":", "\n", "\n", "# 1 first; 2 last", "\n", "# 12 is the original point order", "\n", "# 21 is the fliped point order", "\n", "\t", "feat_12", "=", "feat", "\n", "feat_21", "=", "np", ".", "flip", "(", "feat_12", ",", "axis", "=", "1", ")", "\n", "\n", "# concatenate the different orders ", "\n", "feat_1221", "=", "np", ".", "concatenate", "(", "(", "feat_12", ",", "feat_21", ")", ",", "axis", "=", "1", ")", "\n", "feat_2112", "=", "np", ".", "concatenate", "(", "(", "feat_21", ",", "feat_12", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# reshape to a 4D array", "\n", "feat_shape", "=", "(", "feat_1221", ".", "shape", "[", "0", "]", ",", "1", ",", "feat_1221", ".", "shape", "[", "1", "]", ",", "feat_1221", ".", "shape", "[", "2", "]", ")", "\n", "\n", "feat_1221", "=", "np", ".", "reshape", "(", "feat_1221", ",", "feat_shape", ")", "\n", "feat_2112", "=", "np", ".", "reshape", "(", "feat_2112", ",", "feat_shape", ")", "\n", "\n", "# Now the dimension is (# of fibers, 2, # of points, 3)", "\n", "# the second D is [1221; 2112]; the fourth D is RAS", "\n", "feat_1221_2112", "=", "np", ".", "concatenate", "(", "(", "feat_1221", ",", "feat_2112", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# Repeat the send D;", "\n", "# In the tmp variable, it is [1221; 1221; ...; 2112; 2112; ....], ", "\n", "# but we want [1221; 2112; 1221; 2112; ....]", "\n", "feat_1221_2112_repeat_tmp", "=", "np", ".", "repeat", "(", "feat_1221_2112", ",", "repeat_time", ",", "axis", "=", "1", ")", "\n", "#del feat_1221_2112", "\n", "feat_1221_2112_repeat", "=", "np", ".", "zeros", "(", "feat_1221_2112_repeat_tmp", ".", "shape", ")", "\n", "\n", "feat_1221_2112_repeat", "[", ":", ",", "0", ":", ":", "2", ",", ":", ",", ":", "]", "=", "feat_1221_2112_repeat_tmp", "[", ":", ",", "0", ":", "repeat_time", ",", ":", ",", ":", "]", "\n", "feat_1221_2112_repeat", "[", ":", ",", "1", ":", ":", "2", ",", ":", ",", ":", "]", "=", "feat_1221_2112_repeat_tmp", "[", ":", ",", "repeat_time", ":", ",", ":", ",", ":", "]", "\n", "\n", "return", "feat_1221_2112_repeat", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._transform_fs_labels": [[221, 237], ["numpy.sort", "numpy.sort", "numpy.save", "numpy.load", "numpy.unique().astype", "tract_feat._region_label_LR", "numpy.unique().astype", "enumerate", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._region_label_LR"], ["", "def", "_transform_fs_labels", "(", "fs_array", ")", ":", "\n", "\n", "\t", "if", "0", ":", "\n", "\t\t", "unique_fs_labels", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "fs_array", ")", ".", "astype", "(", "int", ")", ")", "\n", "fs_dict", "=", "{", "region", ":", "i", "for", "i", ",", "region", "in", "enumerate", "(", "unique_fs_labels", ")", "}", "\n", "np", ".", "save", "(", "'fs_dict.npy'", ",", "fs_dict", ")", "\n", "\n", "fs_dict", "=", "np", ".", "load", "(", "'fs_dict.npy'", ")", "\n", "\n", "", "unique_fs_labels", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "fs_array", ")", ".", "astype", "(", "int", ")", ")", "\n", "\n", "fs_array_t", "=", "fs_array", "\n", "for", "fs_label", "in", "unique_fs_labels", ":", "\n", "\t\t", "fs_array_t", "[", "fs_array", "==", "fs_label", "]", "=", "_region_label_LR", "(", "fs_label", ")", "\n", "\n", "", "return", "fs_array_t", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._region_label_LR": [[238, 290], ["range", "numpy.arange", "numpy.arange", "numpy.arange", "range", "range", "numpy.arange", "range", "range", "numpy.arange", "range", "numpy.array", "range", "len", "len", "range", "range", "len", "len", "len", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "numpy.array", "numpy.where", "numpy.where", "numpy.where"], "function", ["None"], ["", "def", "_region_label_LR", "(", "label", ")", ":", "\n", "\n", "    ", "CC_regions", "=", "range", "(", "251", ",", "256", ")", "\n", "CC_regions_new", "=", "np", ".", "arange", "(", "1", ",", "1", "+", "len", "(", "CC_regions", ")", ")", "\n", "\n", "commissural_sub_cortical_regions", "=", "[", "14", ",", "15", ",", "16", ",", "24", ",", "72", ",", "77", ",", "80", ",", "85", "]", "\n", "commissural_sub_cortical_regions_new", "=", "np", ".", "arange", "(", "CC_regions_new", "[", "-", "1", "]", "+", "1", ",", "CC_regions_new", "[", "-", "1", "]", "+", "1", "+", "len", "(", "commissural_sub_cortical_regions", ")", ")", "\n", "\n", "# combine left and right", "\n", "left_sub_cortical_regions", "=", "range", "(", "1", ",", "14", ")", "+", "range", "(", "17", ",", "21", ")", "+", "range", "(", "25", ",", "40", ")", "# [2, 4, 5, 7, 8, 10, 11, 12, 13, 17, 18, 26, 28, 30, 31]", "\n", "left_sub_cortical_regions_new", "=", "np", ".", "arange", "(", "commissural_sub_cortical_regions_new", "[", "-", "1", "]", ",", "commissural_sub_cortical_regions_new", "[", "-", "1", "]", "+", "1", "+", "len", "(", "left_sub_cortical_regions", ")", ")", "\n", "\n", "right_sub_cortical_regions", "=", "range", "(", "40", ",", "72", ")", "# [41, 43, 44, 46, 47, 49, 50, 51, 52, 53, 54, 58, 60, 62, 63]", "\n", "right_sub_cortical_regions_new", "=", "-", "left_sub_cortical_regions_new", "\n", "\n", "left_GM_cortical_regions", "=", "range", "(", "1000", ",", "1036", ")", "\n", "left_GM_cortical_regions_new", "=", "np", ".", "arange", "(", "left_sub_cortical_regions_new", "[", "-", "1", "]", "+", "1", ",", "left_sub_cortical_regions_new", "[", "-", "1", "]", "+", "1", "+", "len", "(", "left_GM_cortical_regions", ")", ")", "\n", "\n", "right_GM_cortical_regions", "=", "range", "(", "2000", ",", "2036", ")", "\n", "right_GM_cortical_regions_new", "=", "-", "left_GM_cortical_regions_new", "\n", "\n", "left_WM_cortical_regions", "=", "range", "(", "3001", ",", "3036", ")", "\n", "left_WM_cortical_regions_new", "=", "np", ".", "arange", "(", "left_GM_cortical_regions_new", "[", "-", "1", "]", "+", "1", ",", "left_GM_cortical_regions_new", "[", "-", "1", "]", "+", "1", "+", "len", "(", "left_WM_cortical_regions", ")", ")", "\n", "\n", "right_WM_cortical_regions", "=", "range", "(", "4001", ",", "4036", ")", "\n", "right_WM_cortical_regions_new", "=", "-", "left_WM_cortical_regions_new", "\n", "\n", "WM_Unsegmented", "=", "[", "5001", ",", "5002", "]", "\n", "WM_Unsegmented_new", "=", "np", ".", "array", "(", "[", "-", "120", ",", "120", "]", ")", "\n", "\n", "if", "label", "in", "right_WM_cortical_regions", ":", "\n", "        ", "label", "=", "right_WM_cortical_regions_new", "[", "np", ".", "where", "(", "right_WM_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "left_WM_cortical_regions", ":", "\n", "        ", "label", "=", "left_WM_cortical_regions_new", "[", "np", ".", "where", "(", "left_WM_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "right_GM_cortical_regions", ":", "\n", "        ", "label", "=", "right_GM_cortical_regions_new", "[", "np", ".", "where", "(", "right_GM_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "left_GM_cortical_regions", ":", "\n", "        ", "label", "=", "left_GM_cortical_regions_new", "[", "np", ".", "where", "(", "left_GM_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "CC_regions", ":", "\n", "        ", "label", "=", "CC_regions_new", "[", "np", ".", "where", "(", "CC_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "commissural_sub_cortical_regions", ":", "\n", "        ", "label", "=", "commissural_sub_cortical_regions_new", "[", "np", ".", "where", "(", "commissural_sub_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "right_sub_cortical_regions", ":", "\n", "        ", "label", "=", "right_sub_cortical_regions_new", "[", "np", ".", "where", "(", "right_sub_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "left_sub_cortical_regions", ":", "\n", "        ", "label", "=", "left_sub_cortical_regions_new", "[", "np", ".", "where", "(", "left_sub_cortical_regions", "==", "label", ")", "[", "0", "]", "]", "\n", "", "elif", "label", "in", "WM_Unsegmented", ":", "\n", "        ", "label", "=", "WM_Unsegmented_new", "[", "np", ".", "where", "(", "WM_Unsegmented", "==", "label", ")", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "        ", "label", "=", "np", ".", "array", "(", "0", ")", "\n", "\n", "", "return", "-", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.downsample": [[292, 300], ["None"], "function", ["None"], ["", "def", "downsample", "(", "ds_step", ",", "x_data", ",", "y_data", "=", "None", ")", ":", "\n", "\t", "x_data_ds", "=", "x_data", "[", ":", ":", "ds_step", ",", ":", ",", ":", ",", ":", "]", "\n", "\n", "y_data_ds", "=", "None", "\n", "if", "y_data", "is", "not", "None", ":", "\n", "\t\t", "y_data_ds", "=", "y_data", "[", ":", ":", "ds_step", "]", "\n", "\n", "", "return", "(", "x_data_ds", ",", "y_data_ds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.remove_samples": [[301, 312], ["numpy.ones", "numpy.where", "len"], "function", ["None"], ["", "def", "remove_samples", "(", "sample_label", ",", "x_data", ",", "y_data", ")", ":", "\n", "\n", "\t", "rem_indices", "=", "np", ".", "where", "(", "y_data", "==", "sample_label", ")", "[", "0", "]", "\n", "\n", "mask", "=", "np", ".", "ones", "(", "len", "(", "y_data", ")", ",", "dtype", "=", "bool", ")", "\n", "mask", "[", "rem_indices", "]", "=", "False", "\n", "\n", "x_data_ds", "=", "x_data", "[", "mask", ",", ":", ",", ":", ",", ":", "]", "\n", "y_data_ds", "=", "y_data", "[", "mask", "]", "\n", "\n", "return", "(", "x_data_ds", ",", "y_data_ds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.downsample_to_balance": [[313, 341], ["numpy.bincount", "print", "numpy.ones", "numpy.zeros().astype", "numpy.unique", "numpy.min", "len", "numpy.array", "numpy.zeros", "len", "numpy.concatenate", "numpy.random.seed", "numpy.random.shuffle", "numpy.concatenate", "numpy.where"], "function", ["None"], ["", "def", "downsample_to_balance", "(", "x_data", ",", "y_data", ",", "num_sample_per_class", "=", "None", ")", ":", "\n", "\n", "\t", "bin_count", "=", "np", ".", "bincount", "(", "y_data", ")", "\n", "\n", "if", "num_sample_per_class", "is", "None", ":", "\n", "\t\t", "num_sample_per_class", "=", "np", ".", "min", "(", "bin_count", ")", "\n", "\n", "", "print", "(", "\"[balance_samples]: each class has # of samples:\"", ",", "num_sample_per_class", ")", "\n", "\n", "mask", "=", "np", ".", "ones", "(", "len", "(", "y_data", ")", ",", "dtype", "=", "bool", ")", "\n", "\n", "kept_indices", "=", "np", ".", "zeros", "(", "0", ")", ".", "astype", "(", "int", ")", "\n", "for", "label", "in", "np", ".", "unique", "(", "y_data", ")", ":", "\n", "\t\t", "label_indices", "=", "np", ".", "array", "(", "np", ".", "where", "(", "y_data", "==", "label", ")", "[", "0", "]", ")", "\n", "\n", "if", "len", "(", "label_indices", ")", "<=", "num_sample_per_class", ":", "\n", "\t\t\t", "kept_indices", "=", "np", ".", "concatenate", "(", "(", "kept_indices", ",", "label_indices", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "\n", "np", ".", "random", ".", "shuffle", "(", "label_indices", ")", "\n", "\n", "kept_indices", "=", "np", ".", "concatenate", "(", "(", "kept_indices", ",", "label_indices", "[", ":", "num_sample_per_class", "]", ")", ")", "\n", "\n", "", "", "x_data_ds", "=", "x_data", "[", "kept_indices", ",", ":", ",", ":", ",", ":", "]", "\n", "y_data_ds", "=", "y_data", "[", "kept_indices", "]", "\n", "\n", "return", "(", "x_data_ds", ",", "y_data_ds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.upsample_to_balance": [[343, 383], ["numpy.bincount", "numpy.max", "print", "numpy.unique", "numpy.concatenate", "numpy.concatenate", "numpy.array", "numpy.zeros", "numpy.zeros", "x_data_list.append", "y_data_list.append", "len", "print", "numpy.repeat", "numpy.repeat", "numpy.where", "len"], "function", ["None"], ["", "def", "upsample_to_balance", "(", "x_data", ",", "y_data", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "\t", "bin_count", "=", "np", ".", "bincount", "(", "y_data", ")", "\n", "num_sample_per_class", "=", "np", ".", "max", "(", "bin_count", ")", "\n", "\n", "print", "(", "\"[upsample_to_balance]: each class has # of samples:\"", ",", "num_sample_per_class", ")", "\n", "\n", "# x_data_us = np.zeros((0, x_data.shape[1], x_data.shape[2], x_data.shape[3]))", "\n", "# y_data_us = np.zeros(0).astype(int)", "\n", "\n", "x_data_list", "=", "[", "]", "\n", "y_data_list", "=", "[", "]", "\n", "for", "label", "in", "np", ".", "unique", "(", "y_data", ")", ":", "\n", "\t\t", "label_indices", "=", "np", ".", "array", "(", "np", ".", "where", "(", "y_data", "==", "label", ")", "[", "0", "]", ")", "\n", "\n", "copy_times", "=", "num_sample_per_class", "/", "len", "(", "label_indices", ")", "\n", "\n", "if", "verbose", ":", "\n", "\t\t\t", "print", "(", "\"[upsample_to_balance] class\"", ",", "label", ",", "\"has\"", ",", "len", "(", "label_indices", ")", ",", "\"samples, and will repeat\"", ",", "copy_times", ",", "\"times.\"", ")", "\n", "\n", "", "x_data_label", "=", "x_data", "[", "label_indices", ",", ":", ",", ":", ",", ":", "]", "\n", "y_data_label", "=", "y_data", "[", "label_indices", "]", "\n", "\n", "x_data_repeat", "=", "np", ".", "zeros", "(", "0", ")", "\n", "y_data_repeat", "=", "np", ".", "zeros", "(", "0", ")", "\n", "\n", "if", "copy_times", ">", "0", ":", "\n", "\t\t\t", "x_data_repeat", "=", "np", ".", "repeat", "(", "x_data_label", ",", "copy_times", ",", "axis", "=", "0", ")", "\n", "y_data_repeat", "=", "np", ".", "repeat", "(", "y_data_label", ",", "copy_times", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "\t\t\t", "x_data_repeat", "=", "x_data_label", "\n", "y_data_repeat", "=", "y_data_label", "\n", "\n", "", "x_data_list", ".", "append", "(", "x_data_repeat", ")", "\n", "y_data_list", ".", "append", "(", "y_data_repeat", ")", "\n", "\n", "", "x_data_us", "=", "np", ".", "concatenate", "(", "x_data_list", ")", "\n", "y_data_us", "=", "np", ".", "concatenate", "(", "y_data_list", ")", "\n", "\n", "return", "(", "x_data_us", ",", "y_data_us", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.upsample_with_copy": [[384, 421], ["zip", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.array", "numpy.zeros", "numpy.zeros", "x_data_list.append", "y_data_list.append", "print", "numpy.repeat", "numpy.repeat", "tract_feat._add_gaussion", "numpy.where", "len"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._add_gaussion"], ["", "def", "upsample_with_copy", "(", "x_data", ",", "y_data", ",", "labels_to_upsample", "=", "None", ",", "copy_times", "=", "None", ",", "gaussian_sigma", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "\t", "x_data_list", "=", "[", "]", "\n", "y_data_list", "=", "[", "]", "\n", "for", "label", ",", "cp_time", "in", "zip", "(", "labels_to_upsample", ",", "copy_times", ")", ":", "\n", "\n", "\t\t", "label_indices", "=", "np", ".", "array", "(", "np", ".", "where", "(", "y_data", "==", "label", ")", "[", "0", "]", ")", "\n", "\n", "if", "verbose", ":", "\n", "\t\t\t", "print", "(", "\"[upsample_to_balance] class\"", ",", "label", ",", "\"has\"", ",", "len", "(", "label_indices", ")", ",", "\"samples, and will repeat\"", ",", "cp_time", ",", "\"times.\"", ")", "\n", "\n", "", "x_data_label", "=", "x_data", "[", "label_indices", ",", ":", ",", ":", ",", ":", "]", "\n", "y_data_label", "=", "y_data", "[", "label_indices", "]", "\n", "\n", "x_data_repeat", "=", "np", ".", "zeros", "(", "0", ")", "\n", "y_data_repeat", "=", "np", ".", "zeros", "(", "0", ")", "\n", "\n", "if", "cp_time", ">", "0", ":", "\n", "\t\t\t", "x_data_repeat", "=", "np", ".", "repeat", "(", "x_data_label", ",", "cp_time", ",", "axis", "=", "0", ")", "\n", "y_data_repeat", "=", "np", ".", "repeat", "(", "y_data_label", ",", "cp_time", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "\t\t\t", "x_data_repeat", "=", "x_data_label", "\n", "y_data_repeat", "=", "y_data_label", "\n", "\n", "", "if", "gaussian_sigma", "is", "not", "None", ":", "\n", "\t\t\t", "x_data_repeat", "=", "_add_gaussion", "(", "x_data_repeat", ",", "gaussian_sigma", ")", "\n", "\n", "", "x_data_list", ".", "append", "(", "x_data_repeat", ")", "\n", "y_data_list", ".", "append", "(", "y_data_repeat", ")", "\n", "\n", "", "x_data_us", "=", "np", ".", "concatenate", "(", "x_data_list", ")", "\n", "y_data_us", "=", "np", ".", "concatenate", "(", "y_data_list", ")", "\n", "\n", "x_data_us", "=", "np", ".", "concatenate", "(", "(", "x_data", ",", "x_data_us", ")", ")", "\n", "y_data_us", "=", "np", ".", "concatenate", "(", "(", "y_data", ",", "y_data_us", ")", ")", "\n", "\n", "return", "(", "x_data_us", ",", "y_data_us", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._add_gaussion": [[422, 445], ["x_data.reshape.reshape", "scipy.ndimage.filters.gaussian_filter1d", "scipy.ndimage.filters.gaussian_filter1d", "scipy.ndimage.filters.gaussian_filter1d", "numpy.dstack", "tract_feat._feat_to_3D"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._feat_to_3D"], ["", "def", "_add_gaussion", "(", "x_data_repeat", ",", "gaussian_sigma", "=", "1", ")", ":", "\n", "\n", "# 1D Gaussian filter", "\n", "\n", "\t", "number_of_points", "=", "x_data_repeat", ".", "shape", "[", "2", "]", "/", "2", "\n", "repeat_time", "=", "x_data_repeat", ".", "shape", "[", "1", "]", "/", "2", "\n", "\n", "x_data", "=", "x_data_repeat", "[", ":", ",", "0", ",", ":", "number_of_points", ",", ":", "]", "\n", "x_data", "=", "x_data", ".", "reshape", "(", "[", "-", "1", ",", "number_of_points", ",", "x_data_repeat", ".", "shape", "[", "3", "]", "]", ")", "\n", "\n", "x_data_r", "=", "scipy", ".", "ndimage", ".", "filters", ".", "gaussian_filter1d", "(", "x_data", "[", ":", ",", ":", ",", "0", "]", ",", "gaussian_sigma", ",", "axis", "=", "1", ")", "\n", "x_data_a", "=", "scipy", ".", "ndimage", ".", "filters", ".", "gaussian_filter1d", "(", "x_data", "[", ":", ",", ":", ",", "1", "]", ",", "gaussian_sigma", ",", "axis", "=", "1", ")", "\n", "x_data_s", "=", "scipy", ".", "ndimage", ".", "filters", ".", "gaussian_filter1d", "(", "x_data", "[", ":", ",", ":", ",", "2", "]", ",", "gaussian_sigma", ",", "axis", "=", "1", ")", "\n", "\n", "x_data_gauss", "=", "np", ".", "dstack", "(", "(", "x_data_r", ",", "x_data_a", ",", "x_data_s", ")", ")", "\n", "\n", "feat_1221_2112_repeat_gauss", "=", "_feat_to_3D", "(", "x_data_gauss", ",", "repeat_time", ")", "\n", "\n", "# print 'x_data_repeat shape:', x_data_repeat.shape\t", "\n", "# print 'x_data_gauss shape:', x_data_gauss.shape", "\n", "# print 'feat_1221_2112_repeat shape:', feat_1221_2112_repeat_gauss.shape", "\n", "\n", "return", "feat_1221_2112_repeat_gauss", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.split_data": [[446, 465], ["int", "numpy.random.permutation"], "function", ["None"], ["", "def", "split_data", "(", "x_data", ",", "y_data", ",", "split_rate", ")", ":", "\n", "\n", "\t", "n", "=", "x_data", ".", "shape", "[", "0", "]", "\n", "\n", "n_first", "=", "int", "(", "n", "*", "split_rate", ")", "\n", "\n", "#np.random.seed(0)", "\n", "p_indices", "=", "np", ".", "random", ".", "permutation", "(", "n", ")", "\n", "\n", "p_indices_first", "=", "p_indices", "[", ":", "n_first", "]", "\n", "p_indices_second", "=", "p_indices", "[", "n_first", ":", "]", "\n", "\n", "x_data_first", "=", "x_data", "[", "p_indices_first", ",", ":", "]", "\n", "y_data_first", "=", "y_data", "[", "p_indices_first", "]", "\n", "\n", "x_data_second", "=", "x_data", "[", "p_indices_second", ",", ":", "]", "\n", "y_data_second", "=", "y_data", "[", "p_indices_second", "]", "\n", "\n", "return", "(", "x_data_first", ",", "y_data_first", ",", "x_data_second", ",", "y_data_second", ",", "p_indices_first", ",", "p_indices_second", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.bilateralize_feature_OLD": [[466, 501], ["numpy.sort", "numpy.sort", "list", "enumerate", "numpy.array", "numpy.concatenate", "numpy.unique", "numpy.unique", "np.array.append", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "y_names[].replace", "numpy.where", "numpy.where"], "function", ["None"], ["", "def", "bilateralize_feature_OLD", "(", "y_names", ",", "y_data", ",", "x_data", ",", "fliped_copy", "=", "False", ")", ":", "\n", "\n", "\t", "all_y_labels", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "y_data", ")", ")", "\n", "\n", "# Replace y label of right structure to its corresponding left structure", "\n", "# Note: here we assume that right structure is next to the left structure", "\n", "y_data_bilateral_", "=", "y_data", "\n", "for", "y_label", "in", "all_y_labels", ":", "\n", "\t\t", "if", "'left'", "in", "y_names", "[", "y_label", "]", ":", "\n", "# print y_label, y_names[y_label], y_names[y_label+1]", "\n", "\t\t\t", "y_data_bilateral_", "[", "np", ".", "where", "(", "y_data", "==", "y_label", "+", "1", ")", "[", "0", "]", "]", "=", "y_label", "\n", "\n", "# Update y names and re-index y label (to make them continuous numbers)", "\n", "", "", "all_y_labels", "=", "np", ".", "sort", "(", "np", ".", "unique", "(", "y_data_bilateral_", ")", ")", "\n", "y_names_bilateral", "=", "list", "(", ")", "\n", "y_data_bilateral", "=", "y_data_bilateral_", "\n", "for", "idx", ",", "y_label", "in", "enumerate", "(", "all_y_labels", ")", ":", "\n", "\t\t", "y_data_bilateral", "[", "np", ".", "where", "(", "y_data_bilateral_", "==", "y_label", ")", "[", "0", "]", "]", "=", "idx", "\n", "y_names_bilateral", ".", "append", "(", "y_names", "[", "y_label", "]", ".", "replace", "(", "'_left'", ",", "''", ")", ")", "\n", "\n", "", "y_names_bilateral", "=", "np", ".", "array", "(", "y_names_bilateral", ")", "\n", "\n", "# Make bilateral x data", "\n", "x_data_reflected", "=", "x_data", "\n", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "0", "]", "=", "-", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "\n", "x_data_bilateral", "=", "np", ".", "concatenate", "(", "(", "x_data", ",", "x_data_reflected", ")", ",", "axis", "=", "2", ")", "\n", "\n", "# augment for training ", "\n", "if", "fliped_copy", ":", "\n", "\t\t", "x_data_bilateral_fliped", "=", "np", ".", "concatenate", "(", "(", "x_data_reflected", ",", "x_data", ")", ",", "axis", "=", "2", ")", "\n", "x_data_bilateral", "=", "np", ".", "concatenate", "(", "(", "x_data_bilateral", ",", "x_data_bilateral_fliped", ")", ",", "axis", "=", "0", ")", "\n", "y_data_bilateral", "=", "np", ".", "concatenate", "(", "(", "y_data_bilateral", ",", "y_data_bilateral", ")", ")", "\n", "\n", "", "return", "y_names_bilateral", ",", "y_data_bilateral", ",", "x_data_bilateral", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.combine_tract_subdiviations_and_keep_outlier_tracts": [[521, 580], ["tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts"], ["", "def", "combine_tract_subdiviations_and_keep_outlier_tracts", "(", "y_data", ",", "y_names", ",", "y_validation", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "# others", "\n", "\t", "labels_to_combine", "=", "[", "22", ",", "58", ",", "74", ",", "111", ",", "114", ",", "151", "]", "# ['T_FalsePositive' 'T_O_FalsePositive' 'T_O_Partial' 'T_O_Unclassified'  'T_Partial' 'T_Unclassified']", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_Others'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "# Superficial tracts: true positive", "\n", "", "labels_to_combine", "=", "range", "(", "127", ",", "142", ",", "2", ")", "# Sup-T left", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_Sup_left'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "range", "(", "128", ",", "143", ",", "2", ")", "# Sup-T right", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_Sup_right'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "# Superficial tracts: outliers", "\n", "", "labels_to_combine", "=", "range", "(", "87", ",", "102", ",", "2", ")", "# O-Sup-T left", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_O_Sup_left'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "range", "(", "88", ",", "103", ",", "2", ")", "# O-Sup-T right", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_O_Sup_right'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "# CBLM tracts", "\n", "", "labels_to_combine", "=", "[", "29", ",", "31", "]", "# CBLM left", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_CBLM_left'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "[", "30", ",", "32", "]", "# CBLM right", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_CBLM_right'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "[", "65", ",", "67", "]", "# O-CBLM left", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_O_CBLM_left'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "[", "66", ",", "68", "]", "# O-CBLM right", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_O_CBLM_right'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "return", "y_data", ",", "y_names", ",", "y_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.combine_tract_subdiviations_and_merge_outliers": [[582, 618], ["tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "range", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts", "tract_feat._combine_tracts"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts"], ["", "def", "combine_tract_subdiviations_and_merge_outliers", "(", "y_data", ",", "y_names", ",", "y_validation", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "# Others", "\n", "\t", "labels_to_combine", "=", "range", "(", "36", ",", "112", ")", "+", "[", "22", ",", "58", ",", "74", ",", "111", ",", "114", ",", "151", "]", "# All T_O_* tacts and ['T_FalsePositive' 'T_O_FalsePositive' 'T_O_Partial' 'T_O_Unclassified'  'T_Partial' 'T_Unclassified']", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_Others'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "# Superficial tracts: true positive", "\n", "", "labels_to_combine", "=", "range", "(", "127", ",", "142", ",", "2", ")", "# Sup-T left", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_Sup_left'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "range", "(", "128", ",", "143", ",", "2", ")", "# Sup-T right", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_Sup_right'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "# CBLM tracts: true positive", "\n", "", "labels_to_combine", "=", "[", "29", ",", "31", "]", "# CBLM left", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_CBLM_left'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "labels_to_combine", "=", "[", "30", ",", "32", "]", "# CBLM right", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "'T_CBLM_right'", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "\n", "", "return", "y_data", ",", "y_names", ",", "y_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.combine_truepositive_and_falsepositive": [[619, 636], ["enumerate", "tract_feat._combine_tracts", "y_name.replace", "[].tolist", "tract_feat._combine_tracts", "numpy.where"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts"], ["", "def", "combine_truepositive_and_falsepositive", "(", "y_data", ",", "y_names", ",", "y_validation", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "\t", "for", "y_label", ",", "y_name", "in", "enumerate", "(", "y_names", ")", ":", "\n", "\n", "\t\t", "if", "'T_O_'", "in", "y_name", ":", "\n", "\n", "\t\t\t", "tp_tract_name", "=", "'T_'", "+", "y_name", ".", "replace", "(", "'T_O_'", ",", "''", ")", "\n", "idx_tp_tract", "=", "np", ".", "where", "(", "y_names", "==", "tp_tract_name", ")", "[", "0", "]", ".", "tolist", "(", ")", "[", "0", "]", "\n", "\n", "labels_to_combine", "=", "[", "y_label", ",", "idx_tp_tract", "]", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "y_names", "[", "idx_tp_tract", "]", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "", "", "return", "y_data", ",", "y_names", ",", "y_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.bilateralize_feature": [[637, 655], ["enumerate", "y_name.replace", "y_names[].replace", "tract_feat._combine_tracts", "[].tolist", "tract_feat._combine_tracts", "numpy.where"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts"], ["", "def", "bilateralize_feature", "(", "y_data", ",", "y_names", ",", "y_validation", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "\t", "for", "y_label", ",", "y_name", "in", "enumerate", "(", "y_names", ")", ":", "\n", "\n", "\t\t", "if", "'_right'", "in", "y_name", ":", "\n", "\n", "\t\t\t", "left_tract_name", "=", "y_name", ".", "replace", "(", "'_right'", ",", "'_left'", ")", "\n", "idx_left_tract", "=", "np", ".", "where", "(", "y_names", "==", "left_tract_name", ")", "[", "0", "]", ".", "tolist", "(", ")", "[", "0", "]", "\n", "\n", "labels_to_combine", "=", "[", "y_label", ",", "idx_left_tract", "]", "\n", "combined_name", "=", "y_names", "[", "idx_left_tract", "]", ".", "replace", "(", "'_left'", ",", "''", ")", "\n", "\n", "y_data", ",", "y_names", "=", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "combined_name", ",", "y_names", "=", "y_names", ",", "verbose", "=", "verbose", ")", "\n", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t\t\t", "y_validation", ",", "_", "=", "_combine_tracts", "(", "y_validation", ",", "labels_to_combine", ")", "\n", "\n", "", "", "", "return", "y_data", ",", "y_names", ",", "y_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.bilateral_X_data": [[656, 682], ["numpy.concatenate", "print", "numpy.masked_where", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.absolute"], "function", ["None"], ["", "def", "bilateral_X_data", "(", "x_data", ",", "fliped_copy", "=", "False", ",", "y_data", "=", "None", ")", ":", "\n", "\n", "\t", "x_data_reflected", "=", "x_data", "\n", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "0", "]", "=", "-", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "0", "]", "\n", "\n", "if", "x_data_reflected", ".", "shape", "[", "-", "1", "]", "==", "4", ":", "\n", "\t\t", "print", "(", "' # reflect freesurfer labels'", ")", "\n", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "-", "1", "]", "=", "-", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "-", "1", "]", "\n", "\n", "tmp", "=", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "-", "1", "]", "\n", "\n", "c", "=", "ma", ".", "masked_where", "(", "np", ".", "absolute", "(", "tmp", ")", "<=", "13", ",", "tmp", ")", "\n", "\n", "tmp", "[", "c", ".", "mask", "]", "=", "-", "tmp", "[", "c", ".", "mask", "]", "\n", "x_data_reflected", "[", ":", ",", ":", ",", ":", ",", "-", "1", "]", "=", "tmp", "\n", "\n", "", "x_data_bilateral", "=", "np", ".", "concatenate", "(", "(", "x_data", ",", "x_data_reflected", ")", ",", "axis", "=", "2", ")", "\n", "\n", "if", "fliped_copy", ":", "\n", "\t\t", "x_data_bilateral_2", "=", "np", ".", "concatenate", "(", "(", "x_data_reflected", ",", "x_data", ")", ",", "axis", "=", "2", ")", "\n", "x_data_bilateral", "=", "np", ".", "concatenate", "(", "(", "x_data_bilateral", ",", "x_data_bilateral_2", ")", ",", "axis", "=", "0", ")", "\n", "y_data", "=", "np", ".", "concatenate", "(", "(", "y_data", ",", "y_data", ")", ")", "\n", "", "else", ":", "\n", "\t\t", "y_data", "=", "None", "\n", "\n", "", "return", "x_data_bilateral", ",", "y_data", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat._combine_tracts": [[684, 703], ["print", "numpy.where"], "function", ["None"], ["", "def", "_combine_tracts", "(", "y_data", ",", "labels_to_combine", ",", "combined_name", "=", "None", ",", "y_names", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "\n", "\t", "if", "verbose", ":", "\n", "\t\t", "if", "combined_name", "is", "not", "None", ":", "\n", "\t\t\t", "print", "(", "'## combine to ['", ",", "combined_name", ",", "']:'", ",", "y_names", "[", "labels_to_combine", "]", ")", "\n", "\n", "# all_y_labels = np.sort(np.unique(y_data))", "\n", "# for y_label in all_y_labels:", "\n", "\n", "", "", "for", "y_label", "in", "labels_to_combine", "[", ":", "-", "1", "]", ":", "\n", "\t\t", "y_data", "[", "np", ".", "where", "(", "y_data", "==", "y_label", ")", "[", "0", "]", "]", "=", "labels_to_combine", "[", "-", "1", "]", "\n", "\n", "", "if", "combined_name", "is", "not", "None", ":", "\n", "\t\t", "y_names", "[", "labels_to_combine", "[", "-", "1", "]", "]", "=", "combined_name", "\n", "y_names", "[", "labels_to_combine", "[", ":", "-", "1", "]", "]", "=", "''", "\n", "", "else", ":", "\n", "\t\t", "y_names", "=", "None", "\n", "\n", "", "return", "y_data", ",", "y_names", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.compress_labels_and_names": [[704, 722], ["list", "enumerate", "list.append", "numpy.where", "numpy.where"], "function", ["None"], ["", "def", "compress_labels_and_names", "(", "y_train", ",", "y_names", ",", "y_validation", "=", "None", ")", ":", "\n", "\n", "\t", "y_names_new", "=", "list", "(", ")", "\n", "y_train_new", "=", "y_train", "\n", "y_validation_new", "=", "y_validation", "\n", "\n", "y_label_new_cc", "=", "0", "\n", "for", "y_label", ",", "y_name", "in", "enumerate", "(", "y_names", ")", ":", "\n", "\t\t", "if", "y_name", "!=", "''", ":", "\n", "\t\t\t", "y_names_new", ".", "append", "(", "y_name", ")", "\n", "y_train_new", "[", "np", ".", "where", "(", "y_train", "==", "y_label", ")", "[", "0", "]", "]", "=", "y_label_new_cc", "\n", "\n", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t\t\t", "y_validation_new", "[", "np", ".", "where", "(", "y_validation", "==", "y_label", ")", "[", "0", "]", "]", "=", "y_label_new_cc", "\n", "\n", "", "y_label_new_cc", "=", "y_label_new_cc", "+", "1", "\n", "\n", "", "", "return", "y_train_new", ",", "y_names_new", ",", "y_validation_new", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.get_tract_specific_data": [[723, 759], ["list", "enumerate", "numpy.ones", "numpy.zeros", "print", "exit", "len", "len", "numpy.zeros", "y_name.endswith", "list.append", "len", "len", "len"], "function", ["None"], ["", "def", "get_tract_specific_data", "(", "tract", ",", "y_names", ",", "y_data", ",", "x_data", ",", "y_validation", "=", "None", ",", "x_validation", "=", "None", ",", "idx_data", "=", "None", ",", "idx_validation", "=", "None", ")", ":", "\n", "\n", "\t", "kept_labels", "=", "list", "(", ")", "\n", "for", "y_label", ",", "y_name", "in", "enumerate", "(", "y_names", ")", ":", "\n", "\n", "\t\t", "if", "y_name", ".", "endswith", "(", "tract", ")", "or", "\"_\"", "+", "tract", "+", "\"_\"", "in", "y_name", ":", "\n", "\t\t\t", "kept_labels", ".", "append", "(", "y_label", ")", "\n", "\n", "", "", "if", "not", "(", "len", "(", "kept_labels", ")", "==", "4", "or", "len", "(", "kept_labels", ")", "==", "2", ")", ":", "\n", "\t\t", "print", "(", "\"Error: only two or four labels should be found, but now it has\"", ",", "y_names", "[", "kept_labels", "]", ")", "\n", "exit", "(", ")", "\n", "\n", "", "mask", "=", "np", ".", "ones", "(", "len", "(", "y_names", ")", ",", "dtype", "=", "bool", ")", "\n", "mask", "[", "kept_labels", "]", "=", "False", "\n", "y_names", "[", "mask", "]", "=", "''", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "len", "(", "y_data", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "kept_y_label", "in", "kept_labels", ":", "\n", "\t\t", "mask", "[", "y_data", "==", "kept_y_label", "]", "=", "True", "\n", "\n", "", "y_data", "=", "y_data", "[", "mask", "]", "\n", "x_data", "=", "x_data", "[", "mask", ",", ":", "]", "\n", "\n", "if", "idx_data", "is", "not", "None", ":", "\n", "\t\t", "idx_data", "=", "idx_data", "[", "mask", "]", "\n", "\n", "", "if", "y_validation", "is", "not", "None", ":", "\n", "\t\t", "mask", "=", "np", ".", "zeros", "(", "len", "(", "y_validation", ")", ",", "dtype", "=", "bool", ")", "\n", "for", "kept_y_label", "in", "kept_labels", ":", "\n", "\t\t\t", "mask", "[", "y_validation", "==", "kept_y_label", "]", "=", "True", "\n", "\n", "", "y_validation", "=", "y_validation", "[", "mask", "]", "\n", "x_validation", "=", "x_validation", "[", "mask", ",", ":", "]", "\n", "idx_validation", "=", "idx_validation", "[", "mask", "]", "\n", "\n", "", "return", "y_names", ",", "y_data", ",", "x_data", ",", "y_validation", ",", "x_validation", ",", "idx_data", ",", "idx_validation", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.update_y_test_based_on_model_y_names": [[761, 776], ["y_test.copy", "enumerate", "numpy.where", "len", "print"], "function", ["None"], ["", "def", "update_y_test_based_on_model_y_names", "(", "y_test", ",", "y_names", ",", "y_names_in_model", ")", ":", "\n", "\n", "\t", "y_test_updated", "=", "y_test", ".", "copy", "(", ")", "\n", "y_test_updated", "[", ":", "]", "=", "np", ".", "nan", "\n", "for", "y_label_in_model", ",", "y_name_in_model", "in", "enumerate", "(", "y_names_in_model", ")", ":", "\n", "\n", "\t\t", "y_label_in_y_test", "=", "np", ".", "where", "(", "y_names", "==", "y_name_in_model", ")", "[", "0", "]", "\n", "\n", "if", "len", "(", "y_label_in_y_test", ")", "==", "0", ":", "\n", "\t\t\t", "print", "(", "'Warning: tract ['", ",", "y_name_in_model", ",", "'] does not in the test data.'", ")", "\n", "continue", "\n", "\n", "", "y_test_updated", "[", "y_test", "==", "y_label_in_y_test", "]", "=", "y_label_in_model", "\n", "\n", "", "return", "y_test_updated", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.tract_feat.normalize_channel": [[779, 797], ["list", "range", "print", "list.append", "numpy.max"], "function", ["None"], ["", "def", "normalize_channel", "(", "x_data", ",", "pre_max_v_list", "=", "None", ")", ":", "\n", "\n", "\t", "max_v_list", "=", "list", "(", ")", "\n", "for", "c_idx", "in", "range", "(", "x_data", ".", "shape", "[", "-", "1", "]", ")", ":", "\n", "\n", "\t\t", "print", "(", "' # normalizing:'", ",", "c_idx", ")", "\n", "if", "pre_max_v_list", "is", "None", ":", "\n", "\t\t\t", "max_v", "=", "np", ".", "max", "(", "x_data", "[", "...", ",", "c_idx", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t", "max_v", "=", "pre_max_v_list", "[", "c_idx", "]", "\n", "\n", "", "max_v_list", ".", "append", "(", "max_v", ")", "\n", "\n", "x_data", "[", "...", ",", "c_idx", "]", "=", "x_data", "[", "...", ",", "c_idx", "]", "/", "max_v", "\n", "\n", "", "pre_max_v_list", "=", "max_v_list", "\n", "\n", "return", "x_data", ",", "pre_max_v_list", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.__init__": [[19, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "r", "=", "None", "\n", "self", ".", "a", "=", "None", "\n", "self", ".", "s", "=", "None", "\n", "self", ".", "points_per_fiber", "=", "None", "\n", "self", ".", "hemisphere_percent_threshold", "=", "0.95", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.get_equivalent_fiber": [[26, 39], ["fibers.Fiber"], "methods", ["None"], ["", "def", "get_equivalent_fiber", "(", "self", ")", ":", "\n", "        ", "\"\"\" Get the reverse order of current line (trajectory), as the\n        fiber can be equivalently represented in either order.\"\"\"", "\n", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "\n", "fiber", ".", "r", "=", "self", ".", "r", "[", ":", ":", "-", "1", "]", "\n", "fiber", ".", "a", "=", "self", ".", "a", "[", ":", ":", "-", "1", "]", "\n", "fiber", ".", "s", "=", "self", ".", "s", "[", ":", ":", "-", "1", "]", "\n", "\n", "fiber", ".", "points_per_fiber", "=", "self", ".", "points_per_fiber", "\n", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.get_reflected_fiber": [[40, 53], ["fibers.Fiber"], "methods", ["None"], ["", "def", "get_reflected_fiber", "(", "self", ")", ":", "\n", "        ", "\"\"\" Returns reflected version of current fiber by reflecting\n        fiber across midsagittal plane. Just sets output R coordinate to -R.\"\"\"", "\n", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "\n", "fiber", ".", "r", "=", "-", "self", ".", "r", "\n", "fiber", ".", "a", "=", "self", ".", "a", "\n", "fiber", ".", "s", "=", "self", ".", "s", "\n", "\n", "fiber", ".", "points_per_fiber", "=", "self", ".", "points_per_fiber", "\n", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.match_order": [[54, 70], ["other.get_equivalent_fiber", "numpy.multiply", "numpy.multiply", "numpy.sum", "numpy.sum", "numpy.multiply", "numpy.multiply", "numpy.multiply", "numpy.multiply"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_equivalent_fiber"], ["", "def", "match_order", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\" Reverse order of fiber to match this one if needed \"\"\"", "\n", "# compute correlation", "\n", "corr", "=", "numpy", ".", "multiply", "(", "self", ".", "r", ",", "other", ".", "r", ")", "+", "numpy", ".", "multiply", "(", "self", ".", "a", ",", "other", ".", "a", ")", "+", "numpy", ".", "multiply", "(", "self", ".", "s", ",", "other", ".", "s", ")", "\n", "\n", "other2", "=", "other", ".", "get_equivalent_fiber", "(", ")", "\n", "corr2", "=", "numpy", ".", "multiply", "(", "self", ".", "r", ",", "other2", ".", "r", ")", "+", "numpy", ".", "multiply", "(", "self", ".", "a", ",", "other2", ".", "a", ")", "+", "numpy", ".", "multiply", "(", "self", ".", "s", ",", "other2", ".", "s", ")", "\n", "\n", "if", "numpy", ".", "sum", "(", "corr", ")", ">", "numpy", ".", "sum", "(", "corr2", ")", ":", "\n", "            ", "return", "other", "\n", "", "else", ":", "\n", "            ", "return", "other2", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.__add__": [[71, 79], ["fibers.Fiber.match_order", "fibers.Fiber"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.match_order"], ["", "", "def", "__add__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"This is the + operator for fibers\"\"\"", "\n", "other_matched", "=", "self", ".", "match_order", "(", "other", ")", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "fiber", ".", "r", "=", "self", ".", "r", "+", "other_matched", ".", "r", "\n", "fiber", ".", "a", "=", "self", ".", "a", "+", "other_matched", ".", "a", "\n", "fiber", ".", "s", "=", "self", ".", "s", "+", "other_matched", ".", "s", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.__div__": [[80, 87], ["fibers.Fiber", "numpy.divide", "numpy.divide", "numpy.divide"], "methods", ["None"], ["", "def", "__div__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\" This is to divide a fiber by a number\"\"\"", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "fiber", ".", "r", "=", "numpy", ".", "divide", "(", "self", ".", "r", ",", "other", ")", "\n", "fiber", ".", "a", "=", "numpy", ".", "divide", "(", "self", ".", "a", ",", "other", ")", "\n", "fiber", ".", "s", "=", "numpy", ".", "divide", "(", "self", ".", "s", ",", "other", ")", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.__mul__": [[88, 95], ["fibers.Fiber", "numpy.multiply", "numpy.multiply", "numpy.multiply"], "methods", ["None"], ["", "def", "__mul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\" This is to multiply a fiber by a number\"\"\"", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "fiber", ".", "r", "=", "numpy", ".", "multiply", "(", "self", ".", "r", ",", "other", ")", "\n", "fiber", ".", "a", "=", "numpy", ".", "multiply", "(", "self", ".", "a", ",", "other", ")", "\n", "fiber", ".", "s", "=", "numpy", ".", "multiply", "(", "self", ".", "s", ",", "other", ")", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.__subtract__": [[96, 107], ["fibers.Fiber.match_order", "fibers.Fiber"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.Fiber.match_order"], ["", "def", "__subtract__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"This is the - operator for fibers\"\"\"", "\n", "other_matched", "=", "self", ".", "match_order", "(", "other", ")", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "fiber", ".", "r", "=", "self", ".", "r", "-", "other_matched", ".", "r", "\n", "fiber", ".", "a", "=", "self", ".", "a", "-", "other_matched", ".", "a", "\n", "fiber", ".", "s", "=", "self", ".", "s", "-", "other_matched", ".", "s", "\n", "#fiber.r = self.r + other_matched.r", "\n", "#fiber.a = self.a + other_matched.a", "\n", "#fiber.s = self.s + other_matched.s", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.__init__": [[113, 143], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# parameters", "\n", "        ", "self", ".", "points_per_fiber", "=", "10", "\n", "self", ".", "verbose", "=", "0", "\n", "\n", "# fiber data", "\n", "self", ".", "fiber_array_r", "=", "None", "\n", "self", ".", "fiber_array_a", "=", "None", "\n", "self", ".", "fiber_array_s", "=", "None", "\n", "\n", "# output arrays indicating hemisphere/callosal (L,C,R= -1, 0, 1)", "\n", "self", ".", "fiber_hemisphere", "=", "None", "\n", "self", ".", "hemispheres", "=", "False", "\n", "\n", "# output boolean arrays for each hemisphere and callosal fibers", "\n", "self", ".", "is_left_hem", "=", "None", "\n", "self", ".", "is_right_hem", "=", "None", "\n", "self", ".", "is_commissure", "=", "None", "\n", "\n", "# output indices of each type above", "\n", "self", ".", "index_left_hem", "=", "None", "\n", "self", ".", "index_right_hem", "=", "None", "\n", "self", ".", "index_commissure", "=", "None", "\n", "self", ".", "index_hem", "=", "None", "\n", "\n", "# output totals of each type also", "\n", "self", ".", "number_of_fibers", "=", "0", "\n", "self", ".", "number_left_hem", "=", "None", "\n", "self", ".", "number_right_hem", "=", "None", "\n", "self", ".", "number_commissure", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.__str__": [[144, 151], ["str", "str", "str", "str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "output", "=", "\"\\n points_per_fiber\\t\"", "+", "str", "(", "self", ".", "points_per_fiber", ")", "+", "\"\\n number_of_fibers\\t\\t\"", "+", "str", "(", "self", ".", "number_of_fibers", ")", "+", "\"\\n fiber_hemisphere\\t\\t\"", "+", "str", "(", "self", ".", "fiber_hemisphere", ")", "+", "\"\\n verbose\\t\"", "+", "str", "(", "self", ".", "verbose", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray._calculate_line_indices": [[152, 185], ["range", "ptlist.append", "round", "print", "print", "print", "print", "print"], "methods", ["None"], ["", "def", "_calculate_line_indices", "(", "self", ",", "input_line_length", ",", "output_line_length", ")", ":", "\n", "        ", "\"\"\" Figure out indices for downsampling of polyline data.\n\n        The indices include the first and last points on the line,\n        plus evenly spaced points along the line.  This code figures\n        out which indices we actually want from a line based on its\n        length (in number of points) and the desired length.\n\n        \"\"\"", "\n", "\n", "# this is the increment between output points", "\n", "step", "=", "(", "input_line_length", "-", "1.0", ")", "/", "(", "output_line_length", "-", "1.0", ")", "\n", "\n", "# these are the output point indices (0-based)", "\n", "ptlist", "=", "[", "]", "\n", "for", "ptidx", "in", "range", "(", "0", ",", "output_line_length", ")", ":", "\n", "#print(ptidx*step)", "\n", "            ", "ptlist", ".", "append", "(", "ptidx", "*", "step", ")", "\n", "\n", "# test", "\n", "", "if", "__debug__", ":", "\n", "# this tests we output the last point on the line", "\n", "#test = ((output_line_length - 1) * step == input_line_length - 1)", "\n", "            ", "test", "=", "(", "round", "(", "ptidx", "*", "step", ")", "==", "input_line_length", "-", "1", ")", "\n", "if", "not", "test", ":", "\n", "                ", "print", "(", "\"<fibers.py> ERROR: fiber numbers don't add up.\"", ")", "\n", "print", "(", "step", ")", "\n", "print", "(", "input_line_length", ")", "\n", "print", "(", "output_line_length", ")", "\n", "print", "(", "test", ")", "\n", "raise", "AssertionError", "\n", "\n", "", "", "return", "ptlist", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_fiber": [[186, 198], ["fibers.Fiber"], "methods", ["None"], ["", "def", "get_fiber", "(", "self", ",", "fiber_index", ")", ":", "\n", "        ", "\"\"\" Return fiber number fiber_index. Return value is class\n        Fiber.\"\"\"", "\n", "\n", "fiber", "=", "Fiber", "(", ")", "\n", "fiber", ".", "r", "=", "self", ".", "fiber_array_r", "[", "fiber_index", ",", ":", "]", "\n", "fiber", ".", "a", "=", "self", ".", "fiber_array_a", "[", "fiber_index", ",", ":", "]", "\n", "fiber", ".", "s", "=", "self", ".", "fiber_array_s", "[", "fiber_index", ",", ":", "]", "\n", "\n", "fiber", ".", "points_per_fiber", "=", "self", ".", "points_per_fiber", "\n", "\n", "return", "fiber", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_equivalent_fiber": [[199, 208], ["fibers.FiberArray.get_fiber", "fibers.FiberArray.get_equivalent_fiber"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_fiber", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_equivalent_fiber"], ["", "def", "get_equivalent_fiber", "(", "self", ",", "fiber_index", ")", ":", "\n", "        ", "\"\"\" Return equivalent version of fiber number\n        fiber_index. Return value is class Fiber. Gets the reverse\n        order of line (trajectory), as the fiber can be equivalently\n        represented in either order.\"\"\"", "\n", "\n", "fiber", "=", "self", ".", "get_fiber", "(", "fiber_index", ")", "\n", "\n", "return", "fiber", ".", "get_equivalent_fiber", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_fibers": [[209, 257], ["FiberArray.FiberArray", "len", "len", "len", "len", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "print"], "methods", ["None"], ["", "def", "get_fibers", "(", "self", ",", "fiber_indices", ")", ":", "\n", "        ", "\"\"\" Return FiberArray containing subset of data corresponding\n        to fiber_indices\"\"\"", "\n", "\n", "fibers", "=", "FiberArray", "(", ")", "\n", "\n", "fibers", ".", "number_of_fibers", "=", "len", "(", "fiber_indices", ")", "\n", "\n", "# parameters", "\n", "fibers", ".", "points_per_fiber", "=", "self", ".", "points_per_fiber", "\n", "fibers", ".", "verbose", "=", "self", ".", "verbose", "\n", "\n", "# fiber data", "\n", "fibers", ".", "fiber_array_r", "=", "self", ".", "fiber_array_r", "[", "fiber_indices", "]", "\n", "fibers", ".", "fiber_array_a", "=", "self", ".", "fiber_array_a", "[", "fiber_indices", "]", "\n", "fibers", ".", "fiber_array_s", "=", "self", ".", "fiber_array_s", "[", "fiber_indices", "]", "\n", "\n", "if", "self", ".", "fiber_hemisphere", "is", "not", "None", ":", "\n", "# Output arrays indicating hemisphere/callosal (L,C,R= -1, 0, 1)", "\n", "            ", "fibers", ".", "fiber_hemisphere", "=", "self", ".", "fiber_hemisphere", "[", "fiber_indices", "]", "\n", "\n", "# output boolean arrays for each hemisphere and callosal fibers", "\n", "fibers", ".", "is_left_hem", "=", "self", ".", "is_left_hem", "[", "fiber_indices", "]", "\n", "fibers", ".", "is_right_hem", "=", "self", ".", "is_right_hem", "[", "fiber_indices", "]", "\n", "fibers", ".", "is_commissure", "=", "self", ".", "is_commissure", "[", "fiber_indices", "]", "\n", "\n", "# calculate indices of each type above", "\n", "fibers", ".", "index_left_hem", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_left_hem", ")", "[", "0", "]", "\n", "fibers", ".", "index_right_hem", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_right_hem", ")", "[", "0", "]", "\n", "fibers", ".", "index_commissure", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_commissure", ")", "[", "0", "]", "\n", "fibers", ".", "index_hem", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_left_hem", "|", "fibers", ".", "is_right_hem", ")", "[", "0", "]", "\n", "\n", "# output totals of each type also", "\n", "fibers", ".", "number_left_hem", "=", "len", "(", "fibers", ".", "index_left_hem", ")", "\n", "fibers", ".", "number_right_hem", "=", "len", "(", "fibers", ".", "index_right_hem", ")", "\n", "fibers", ".", "number_commissure", "=", "len", "(", "fibers", ".", "index_commissure", ")", "\n", "\n", "# test", "\n", "if", "__debug__", ":", "\n", "                ", "test", "=", "fibers", ".", "number_of_fibers", "==", "(", "fibers", ".", "number_left_hem", "+", "fibers", ".", "number_right_hem", "+", "fibers", ".", "number_commissure", ")", "\n", "if", "not", "test", ":", "\n", "                    ", "print", "(", "\"<fibers.py> ERROR: fiber numbers don't add up.\"", ")", "\n", "raise", "AssertionError", "\n", "\n", "", "", "", "return", "fibers", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_oriented_fibers": [[258, 319], ["FiberArray.FiberArray", "len", "zip", "range", "len", "len", "len", "FiberArray.FiberArray.get_equivalent_fiber", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "print"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.get_equivalent_fiber"], ["", "def", "get_oriented_fibers", "(", "self", ",", "fiber_indices", ",", "order", ")", ":", "\n", "        ", "\"\"\"Return FiberArray containing subset of data corresponding to\n        fiber_indices. Order fibers according to the array (where 0 is no\n\n        change, and 1 means to reverse the order and return the\n        equivalent fiber)\n        \"\"\"", "\n", "\n", "fibers", "=", "FiberArray", "(", ")", "\n", "\n", "fibers", ".", "number_of_fibers", "=", "len", "(", "fiber_indices", ")", "\n", "\n", "# parameters", "\n", "fibers", ".", "points_per_fiber", "=", "self", ".", "points_per_fiber", "\n", "fibers", ".", "verbose", "=", "self", ".", "verbose", "\n", "\n", "# fiber data", "\n", "fibers", ".", "fiber_array_r", "=", "self", ".", "fiber_array_r", "[", "fiber_indices", "]", "\n", "fibers", ".", "fiber_array_a", "=", "self", ".", "fiber_array_a", "[", "fiber_indices", "]", "\n", "fibers", ".", "fiber_array_s", "=", "self", ".", "fiber_array_s", "[", "fiber_indices", "]", "\n", "\n", "# swap orientation as requested", "\n", "for", "(", "ord", ",", "fidx", ")", "in", "zip", "(", "order", ",", "range", "(", "fibers", ".", "number_of_fibers", ")", ")", ":", "\n", "            ", "if", "ord", "==", "1", ":", "\n", "                ", "f2", "=", "fibers", ".", "get_equivalent_fiber", "(", "fidx", ")", "\n", "# replace it in the array", "\n", "fibers", ".", "fiber_array_r", "[", "fidx", ",", ":", "]", "=", "f2", ".", "r", "\n", "fibers", ".", "fiber_array_a", "[", "fidx", ",", ":", "]", "=", "f2", ".", "a", "\n", "fibers", ".", "fiber_array_s", "[", "fidx", ",", ":", "]", "=", "f2", ".", "s", "\n", "\n", "", "", "if", "self", ".", "fiber_hemisphere", "is", "not", "None", ":", "\n", "# Output arrays indicating hemisphere/callosal (L,C,R= -1, 0, 1)", "\n", "            ", "fibers", ".", "fiber_hemisphere", "=", "self", ".", "fiber_hemisphere", "[", "fiber_indices", "]", "\n", "\n", "# output boolean arrays for each hemisphere and callosal fibers", "\n", "fibers", ".", "is_left_hem", "=", "self", ".", "is_left_hem", "[", "fiber_indices", "]", "\n", "fibers", ".", "is_right_hem", "=", "self", ".", "is_right_hem", "[", "fiber_indices", "]", "\n", "fibers", ".", "is_commissure", "=", "self", ".", "is_commissure", "[", "fiber_indices", "]", "\n", "\n", "# calculate indices of each type above", "\n", "fibers", ".", "index_left_hem", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_left_hem", ")", "[", "0", "]", "\n", "fibers", ".", "index_right_hem", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_right_hem", ")", "[", "0", "]", "\n", "fibers", ".", "index_commissure", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_commissure", ")", "[", "0", "]", "\n", "fibers", ".", "index_hem", "=", "numpy", ".", "nonzero", "(", "fibers", ".", "is_left_hem", "|", "fibers", ".", "is_right_hem", ")", "[", "0", "]", "\n", "\n", "# output totals of each type also", "\n", "fibers", ".", "number_left_hem", "=", "len", "(", "fibers", ".", "index_left_hem", ")", "\n", "fibers", ".", "number_right_hem", "=", "len", "(", "fibers", ".", "index_right_hem", ")", "\n", "fibers", ".", "number_commissure", "=", "len", "(", "fibers", ".", "index_commissure", ")", "\n", "\n", "# test", "\n", "if", "__debug__", ":", "\n", "                ", "test", "=", "fibers", ".", "number_of_fibers", "==", "(", "fibers", ".", "number_left_hem", "+", "fibers", ".", "number_right_hem", "+", "fibers", ".", "number_commissure", ")", "\n", "if", "not", "test", ":", "\n", "                    ", "print", "(", "\"<fibers.py> ERROR: fiber numbers don't add up.\"", ")", "\n", "raise", "AssertionError", "\n", "\n", "", "", "", "return", "fibers", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.convert_from_polydata": [[320, 439], ["input_vtk_polydata.GetNumberOfLines", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "input_vtk_polydata.GetPointData", "list", "input_vtk_polydata.GetLines().InitTraversal", "vtk.vtkIdList", "input_vtk_polydata.GetPoints", "vtk.vtkDoubleArray", "vtk.vtkDoubleArray.SetName", "range", "input_vtk_polydata.GetPointData().AddArray", "print", "range", "input_vtk_polydata.GetPointData.GetArray", "input_vtk_polydata.GetLines().GetNextCell", "vtk.vtkIdList.GetNumberOfIds", "range", "enumerate", "fibers.FiberArray.calculate_hemispheres", "input_vtk_polydata.GetPointData.GetNumberOfArrays", "input_vtk_polydata.GetPointData.GetArray.GetName", "input_vtk_polydata.GetLines().InitTraversal", "range", "input_vtk_polydata.GetLines", "vtk.vtkIdList.GetNumberOfIds", "vtk.vtkDoubleArray.InsertNextTuple1", "fibers.FiberArray._calculate_line_indices", "vtk.vtkIdList.GetId", "list", "abs", "input_vtk_polydata.GetPointData", "input_vtk_polydata.GetNumberOfLines", "vtk.vtkIdList", "input_vtk_polydata.GetLines().GetNextCell", "range", "roi_list.append", "input_vtk_polydata.GetPointData.GetArray.GetName", "input_vtk_polydata.GetLines().InitTraversal", "range", "input_vtk_polydata.GetLines", "print", "print", "int", "input_vtk_polydata.GetPoints.GetPoint", "input_vtk_polydata.GetLines", "numpy.ones", "vtk.vtkIdList.GetNumberOfIds", "input_vtk_polydata.GetNumberOfLines", "vtk.vtkIdList", "input_vtk_polydata.GetLines().GetNextCell", "range", "round", "int", "input_vtk_polydata.GetLines", "vtk.vtkIdList.GetNumberOfIds", "input_vtk_polydata.GetPointData.GetArray.GetTuple", "input_vtk_polydata.GetLines", "numpy.ones", "vtk.vtkIdList.GetNumberOfIds", "numpy.load", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "round", "vtk.vtkIdList.GetId", "input_vtk_polydata.GetLines", "vtk.vtkIdList.GetNumberOfIds", "input_vtk_polydata.GetPointData.GetArray.GetTuple", "vtk.vtkIdList.GetId", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.calculate_hemispheres", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray._calculate_line_indices"], ["", "def", "convert_from_polydata", "(", "self", ",", "input_vtk_polydata", ",", "points_per_fiber", "=", "None", ",", "data", "=", "'HCP'", ")", ":", "\n", "\n", "        ", "\"\"\"Convert input vtkPolyData to the fixed length fiber\n        representation of this class.\n\n        The polydata should contain the output of tractography.\n\n        The output is downsampled fibers in array format and\n        hemisphere info is also calculated.\n\n        \"\"\"", "\n", "\n", "# points used in discretization of each trajectory", "\n", "if", "points_per_fiber", "is", "not", "None", ":", "\n", "            ", "self", ".", "points_per_fiber", "=", "points_per_fiber", "\n", "\n", "# line count. Assume all input lines are from tractography.", "\n", "", "self", ".", "number_of_fibers", "=", "input_vtk_polydata", ".", "GetNumberOfLines", "(", ")", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"<fibers.py> Converting polydata to array representation. Lines:\"", ",", "self", ".", "number_of_fibers", ")", "\n", "\n", "# allocate array number of lines by line length", "\n", "", "self", ".", "fiber_array_r", "=", "numpy", ".", "zeros", "(", "(", "self", ".", "number_of_fibers", ",", "\n", "self", ".", "points_per_fiber", ")", ")", "\n", "self", ".", "fiber_array_a", "=", "numpy", ".", "zeros", "(", "(", "self", ".", "number_of_fibers", ",", "\n", "self", ".", "points_per_fiber", ")", ")", "\n", "self", ".", "fiber_array_s", "=", "numpy", ".", "zeros", "(", "(", "self", ".", "number_of_fibers", ",", "\n", "self", ".", "points_per_fiber", ")", ")", "\n", "self", ".", "fiber_length", "=", "numpy", ".", "zeros", "(", "self", ".", "number_of_fibers", ")", "\n", "self", ".", "fiber_surface_dk", "=", "numpy", ".", "zeros", "(", "(", "self", ".", "number_of_fibers", ",", "2", ")", ")", "\n", "\n", "inpointdata", "=", "input_vtk_polydata", ".", "GetPointData", "(", ")", "\n", "point_data_array_indices", "=", "list", "(", "range", "(", "inpointdata", ".", "GetNumberOfArrays", "(", ")", ")", ")", "\n", "roi_list", "=", "[", "]", "\n", "for", "idx", "in", "point_data_array_indices", ":", "\n", "            ", "array", "=", "inpointdata", ".", "GetArray", "(", "idx", ")", "\n", "if", "array", ".", "GetName", "(", ")", "==", "'ROI_label'", ":", "\n", "                ", "input_vtk_polydata", ".", "GetLines", "(", ")", ".", "InitTraversal", "(", ")", "\n", "for", "lidx", "in", "range", "(", "0", ",", "input_vtk_polydata", ".", "GetNumberOfLines", "(", ")", ")", ":", "\n", "#print(lidx)", "\n", "                    ", "ptids", "=", "vtk", ".", "vtkIdList", "(", ")", "\n", "input_vtk_polydata", ".", "GetLines", "(", ")", ".", "GetNextCell", "(", "ptids", ")", "\n", "roi_line", "=", "-", "numpy", ".", "ones", "(", "ptids", ".", "GetNumberOfIds", "(", ")", ")", "\n", "for", "pidx", "in", "range", "(", "0", ",", "ptids", ".", "GetNumberOfIds", "(", ")", ")", ":", "\n", "                        ", "roi_line", "[", "pidx", "]", "=", "array", ".", "GetTuple", "(", "ptids", ".", "GetId", "(", "pidx", ")", ")", "[", "0", "]", "\n", "", "roi_list", ".", "append", "(", "roi_line", ")", "\n", "", "self", ".", "roi_list", "=", "roi_list", "\n", "", "elif", "array", ".", "GetName", "(", ")", "==", "'surf_label_dk'", ":", "\n", "                ", "input_vtk_polydata", ".", "GetLines", "(", ")", ".", "InitTraversal", "(", ")", "\n", "for", "lidx", "in", "range", "(", "0", ",", "input_vtk_polydata", ".", "GetNumberOfLines", "(", ")", ")", ":", "\n", "#print(lidx)", "\n", "                    ", "ptids", "=", "vtk", ".", "vtkIdList", "(", ")", "\n", "input_vtk_polydata", ".", "GetLines", "(", ")", ".", "GetNextCell", "(", "ptids", ")", "\n", "roi_line", "=", "-", "numpy", ".", "ones", "(", "ptids", ".", "GetNumberOfIds", "(", ")", ")", "\n", "for", "pidx", "in", "range", "(", "0", ",", "ptids", ".", "GetNumberOfIds", "(", ")", ")", ":", "\n", "                        ", "roi_line", "[", "pidx", "]", "=", "array", ".", "GetTuple", "(", "ptids", ".", "GetId", "(", "pidx", ")", ")", "[", "0", "]", "\n", "", "if", "not", "data", "==", "'HCP'", ":", "\n", "                        ", "surf_map", "=", "numpy", ".", "load", "(", "'./surf_map.npy'", ")", "\n", "range_ctx", "=", "numpy", ".", "concatenate", "(", "(", "numpy", ".", "array", "(", "range", "(", "1000", ",", "1036", ")", ")", ",", "numpy", ".", "array", "(", "range", "(", "2000", ",", "2036", ")", ")", ")", ")", "\n", "range_wm", "=", "numpy", ".", "concatenate", "(", "(", "numpy", ".", "array", "(", "range", "(", "3000", ",", "3036", ")", ")", ",", "numpy", ".", "array", "(", "range", "(", "4000", ",", "4036", ")", ")", ")", ")", "\n", "range_cw", "=", "numpy", ".", "concatenate", "(", "(", "range_ctx", ",", "range_wm", ")", ")", "\n", "if", "roi_line", "[", "0", "]", "in", "range_cw", ":", "\n", "                            ", "surf_label", "=", "roi_line", "[", "0", "]", "%", "100", "\n", "", "else", ":", "\n", "                            ", "surf_label", "=", "surf_map", "[", "1", ",", "surf_map", "[", "0", "]", "==", "roi_line", "[", "0", "]", "]", "\n", "", "self", ".", "fiber_surface_dk", "[", "lidx", ",", "0", "]", "=", "surf_label", "\n", "\n", "if", "roi_line", "[", "-", "1", "]", "in", "range_cw", ":", "\n", "                            ", "surf_label", "=", "roi_line", "[", "-", "1", "]", "%", "100", "\n", "", "else", ":", "\n", "                            ", "surf_label", "=", "surf_map", "[", "1", ",", "surf_map", "[", "0", "]", "==", "roi_line", "[", "-", "1", "]", "]", "\n", "", "self", ".", "fiber_surface_dk", "[", "lidx", ",", "1", "]", "=", "surf_label", "\n", "", "else", ":", "\n", "                        ", "self", ".", "fiber_surface_dk", "[", "lidx", ",", "0", "]", "=", "roi_line", "[", "0", "]", "\n", "self", ".", "fiber_surface_dk", "[", "lidx", ",", "1", "]", "=", "roi_line", "[", "-", "1", "]", "\n", "\n", "# loop over lines", "\n", "", "", "", "", "input_vtk_polydata", ".", "GetLines", "(", ")", ".", "InitTraversal", "(", ")", "\n", "line_ptids", "=", "vtk", ".", "vtkIdList", "(", ")", "\n", "inpoints", "=", "input_vtk_polydata", ".", "GetPoints", "(", ")", "\n", "vtk_array", "=", "vtk", ".", "vtkDoubleArray", "(", ")", "\n", "vtk_array", ".", "SetName", "(", "'Point_Seq'", ")", "\n", "\n", "for", "lidx", "in", "range", "(", "0", ",", "self", ".", "number_of_fibers", ")", ":", "\n", "\n", "            ", "input_vtk_polydata", ".", "GetLines", "(", ")", ".", "GetNextCell", "(", "line_ptids", ")", "\n", "line_length", "=", "line_ptids", ".", "GetNumberOfIds", "(", ")", "\n", "self", ".", "fiber_length", "[", "lidx", "]", "=", "line_length", "\n", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "if", "lidx", "%", "100", "==", "0", ":", "\n", "                    ", "print", "(", "\"<fibers.py> Line:\"", ",", "lidx", ",", "\"/\"", ",", "self", ".", "number_of_fibers", ")", "\n", "print", "(", "\"<fibers.py> number of points:\"", ",", "line_length", ")", "\n", "\n", "", "", "for", "pidx", "in", "range", "(", "0", ",", "line_ptids", ".", "GetNumberOfIds", "(", ")", ")", ":", "\n", "                ", "vtk_array", ".", "InsertNextTuple1", "(", "pidx", ")", "\n", "# loop over the indices that we want and get those points", "\n", "", "pidx", "=", "0", "\n", "for", "ind", ",", "line_index", "in", "enumerate", "(", "self", ".", "_calculate_line_indices", "(", "line_length", ",", "\n", "self", ".", "points_per_fiber", ")", ")", ":", "\n", "\n", "# do nearest neighbor interpolation: round index", "\n", "                ", "ptidx", "=", "line_ptids", ".", "GetId", "(", "int", "(", "round", "(", "line_index", ")", ")", ")", "\n", "#print(lidx,line_index,ptidx,line_length)", "\n", "roi", "=", "roi_list", "[", "lidx", "]", "[", "int", "(", "round", "(", "line_index", ")", ")", "]", "\n", "#point = inpoints.GetPoint(ptidx)", "\n", "point", "=", "list", "(", "inpoints", ".", "GetPoint", "(", "ptidx", ")", ")", "\n", "point", "[", "0", "]", "=", "abs", "(", "point", "[", "0", "]", ")", "\n", "self", ".", "fiber_array_r", "[", "lidx", ",", "pidx", "]", "=", "point", "[", "0", "]", "\n", "self", ".", "fiber_array_a", "[", "lidx", ",", "pidx", "]", "=", "point", "[", "1", "]", "\n", "self", ".", "fiber_array_s", "[", "lidx", ",", "pidx", "]", "=", "point", "[", "2", "]", "\n", "pidx", "=", "pidx", "+", "1", "\n", "", "", "input_vtk_polydata", ".", "GetPointData", "(", ")", ".", "AddArray", "(", "vtk_array", ")", "\n", "\n", "# initialize hemisphere info", "\n", "if", "self", ".", "hemispheres", ":", "\n", "            ", "self", ".", "calculate_hemispheres", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.calculate_hemispheres": [[440, 490], ["numpy.zeros", "len", "len", "len", "sum", "float", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "numpy.nonzero", "print"], "methods", ["None"], ["", "", "def", "calculate_hemispheres", "(", "self", ")", ":", "\n", "\n", "        ", "\"\"\" For each fiber assign a hemisphere using the first (R)\n        coordinates.\n\n        This part assumes we are in RAS so the first coordinate is\n        positive to the RIGHT and negative to the LEFT.  The fiber\n        must be more than 95% within 1 hemisphere.  This excludes\n        corpus but can retain errant cingulum. We also want to\n        identify likely commissural fibers.\n\n        \"\"\"", "\n", "\n", "# Figure out hemisphere of each line", "\n", "self", ".", "fiber_hemisphere", "=", "numpy", ".", "zeros", "(", "self", ".", "number_of_fibers", ")", "\n", "# percentage in left hemisphere", "\n", "test", "=", "sum", "(", "self", ".", "fiber_array_r", ".", "T", "<", "0", ")", "/", "float", "(", "self", ".", "points_per_fiber", ")", "\n", "thresh", "=", "self", ".", "hemisphere_percent_threshold", "\n", "self", ".", "fiber_hemisphere", "[", "numpy", ".", "nonzero", "(", "test", ">", "thresh", ")", "]", "=", "-", "1", "\n", "self", ".", "fiber_hemisphere", "[", "numpy", ".", "nonzero", "(", "test", "<", "1", "-", "thresh", ")", "]", "=", "1", "\n", "# previous code left for clarity below, concrete example of threshold:", "\n", "#self.fiber_hemisphere[numpy.nonzero(test > 0.95)] = -1", "\n", "#self.fiber_hemisphere[numpy.nonzero(test < 0.05)] = 1", "\n", "# otherwise hem stays 0 for commissural", "\n", "\n", "# output boolean arrays for each hemisphere and callosal fibers", "\n", "self", ".", "is_left_hem", "=", "(", "self", ".", "fiber_hemisphere", "==", "-", "1", ")", "\n", "self", ".", "is_right_hem", "=", "(", "self", ".", "fiber_hemisphere", "==", "1", ")", "\n", "self", ".", "is_commissure", "=", "(", "self", ".", "fiber_hemisphere", "==", "0", ")", "\n", "\n", "# output indices of each type above", "\n", "self", ".", "index_left_hem", "=", "numpy", ".", "nonzero", "(", "self", ".", "is_left_hem", ")", "[", "0", "]", "\n", "self", ".", "index_right_hem", "=", "numpy", ".", "nonzero", "(", "self", ".", "is_right_hem", ")", "[", "0", "]", "\n", "self", ".", "index_commissure", "=", "numpy", ".", "nonzero", "(", "self", ".", "is_commissure", ")", "[", "0", "]", "\n", "self", ".", "index_hem", "=", "numpy", ".", "nonzero", "(", "self", ".", "is_left_hem", "|", "self", ".", "is_right_hem", ")", "[", "0", "]", "\n", "\n", "# output totals of each type also", "\n", "self", ".", "number_left_hem", "=", "len", "(", "self", ".", "index_left_hem", ")", "\n", "self", ".", "number_right_hem", "=", "len", "(", "self", ".", "index_right_hem", ")", "\n", "self", ".", "number_commissure", "=", "len", "(", "self", ".", "index_commissure", ")", "\n", "\n", "# test", "\n", "if", "__debug__", ":", "\n", "            ", "test", "=", "self", ".", "number_of_fibers", "==", "(", "self", ".", "number_left_hem", "+", "self", ".", "number_right_hem", "+", "self", ".", "number_commissure", ")", "\n", "if", "not", "test", ":", "\n", "                ", "print", "(", "\"<fibers.py> ERROR: fiber numbers don't add up.\"", ")", "\n", "raise", "AssertionError", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fibers.FiberArray.convert_to_polydata": [[491, 518], ["vtk.vtkPolyData", "vtk.vtkPoints", "vtk.vtkCellArray", "vtk.vtkCellArray.InitTraversal", "range", "vtk.vtkPolyData.SetLines", "vtk.vtkPolyData.SetPoints", "vtk.vtkIdList", "range", "vtk.vtkCellArray.InsertNextCell", "vtk.vtkPoints.InsertNextPoint", "vtk.vtkIdList.InsertNextId"], "methods", ["None"], ["", "", "", "def", "convert_to_polydata", "(", "self", ")", ":", "\n", "        ", "\"\"\"Convert fiber array to vtkPolyData object.\"\"\"", "\n", "\n", "outpd", "=", "vtk", ".", "vtkPolyData", "(", ")", "\n", "outpoints", "=", "vtk", ".", "vtkPoints", "(", ")", "\n", "outlines", "=", "vtk", ".", "vtkCellArray", "(", ")", "\n", "\n", "outlines", ".", "InitTraversal", "(", ")", "\n", "\n", "for", "lidx", "in", "range", "(", "0", ",", "self", ".", "number_of_fibers", ")", ":", "\n", "            ", "cellptids", "=", "vtk", ".", "vtkIdList", "(", ")", "\n", "\n", "for", "pidx", "in", "range", "(", "0", ",", "self", ".", "points_per_fiber", ")", ":", "\n", "\n", "                ", "idx", "=", "outpoints", ".", "InsertNextPoint", "(", "self", ".", "fiber_array_r", "[", "lidx", ",", "pidx", "]", ",", "\n", "self", ".", "fiber_array_a", "[", "lidx", ",", "pidx", "]", ",", "\n", "self", ".", "fiber_array_s", "[", "lidx", ",", "pidx", "]", ")", "\n", "\n", "cellptids", ".", "InsertNextId", "(", "idx", ")", "\n", "\n", "", "outlines", ".", "InsertNextCell", "(", "cellptids", ")", "\n", "\n", "# put data into output polydata", "\n", "", "outpd", ".", "SetLines", "(", "outlines", ")", "\n", "outpd", ".", "SetPoints", "(", "outpoints", ")", "\n", "\n", "return", "outpd", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance._fiber_distance_internal_use": [[2, 108], ["numpy.square", "numpy.square", "numpy.square", "print", "numpy.nonzero", "numpy.sum", "float", "numpy.sqrt", "numpy.max", "numpy.sum", "len", "numpy.prod", "numpy.sqrt", "numpy.sum", "float", "numpy.divide", "numpy.square", "numpy.linspace", "numpy.divide", "numpy.divide", "numpy.divide", "float", "numpy.zeros", "numpy.linspace", "numpy.max", "print", "Exception", "numpy.size", "numpy.linspace", "numpy.linspace", "numpy.sqrt", "numpy.size", "numpy.size", "numpy.size", "numpy.size"], "function", ["None"], ["def", "_fiber_distance_internal_use", "(", "fiber_r", ",", "fiber_a", ",", "fiber_s", ",", "fiber_array", ",", "threshold", "=", "0", ",", "distance_method", "=", "'Mean'", ",", "fiber_landmarks", "=", "None", ",", "\n", "landmarks", "=", "None", ",", "sigmasq", "=", "None", ")", ":", "\n", "    ", "\"\"\" Compute the total fiber distance from one fiber to an array of\n    many fibers.\n    This function does not handle equivalent fiber representations,\n    for that use fiber_distance, above.\n    \"\"\"", "\n", "if", "landmarks", "is", "not", "None", ":", "\n", "        ", "print", "(", "\"ERROR: Please use distance method Landmarks to compute landmark distances\"", ")", "\n", "\n", "", "fiber_array_r", "=", "fiber_array", "[", ":", ",", ":", ",", "0", "]", "\n", "fiber_array_a", "=", "fiber_array", "[", ":", ",", ":", ",", "1", "]", "\n", "fiber_array_s", "=", "fiber_array", "[", ":", ",", ":", ",", "2", "]", "\n", "\n", "# compute the distance from this fiber to the array of other fibers", "\n", "ddx", "=", "fiber_array_r", "-", "fiber_r", "\n", "ddy", "=", "fiber_array_a", "-", "fiber_a", "\n", "ddz", "=", "fiber_array_s", "-", "fiber_s", "\n", "\n", "dx", "=", "numpy", ".", "square", "(", "ddx", ")", "\n", "dy", "=", "numpy", ".", "square", "(", "ddy", ")", "\n", "dz", "=", "numpy", ".", "square", "(", "ddz", ")", "\n", "\n", "# sum dx dx dz at each point on the fiber and sqrt for threshold", "\n", "# distance = numpy.sqrt(dx + dy + dz)", "\n", "distance", "=", "dx", "+", "dy", "+", "dz", "\n", "\n", "# threshold if requested", "\n", "if", "threshold", ":", "\n", "# set values less than threshold to 0", "\n", "        ", "distance", "=", "distance", "-", "threshold", "*", "threshold", "\n", "idx", "=", "numpy", ".", "nonzero", "(", "distance", "<", "0", ")", "\n", "distance", "[", "idx", "]", "=", "0", "\n", "\n", "", "if", "distance_method", "==", "'Mean'", ":", "\n", "# sum along fiber", "\n", "        ", "distance", "=", "numpy", ".", "sum", "(", "numpy", ".", "sqrt", "(", "distance", ")", ",", "1", ")", "\n", "# Remove effect of number of points along fiber (mean)", "\n", "npts", "=", "float", "(", "fiber_array", ".", "shape", "[", "1", "]", ")", "\n", "#print(npts)", "\n", "distance", "=", "distance", "/", "npts", "\n", "# for consistency with other methods we need to square this value", "\n", "#distance = numpy.square(distance)", "\n", "", "elif", "distance_method", "==", "'Hausdorff'", ":", "\n", "# take max along fiber", "\n", "        ", "distance", "=", "numpy", ".", "max", "(", "distance", ",", "1", ")", "\n", "", "elif", "distance_method", "==", "'MeanSquared'", ":", "\n", "# sum along fiber", "\n", "        ", "distance", "=", "numpy", ".", "sum", "(", "distance", ",", "1", ")", "\n", "# Remove effect of number of points along fiber (mean)", "\n", "npts", "=", "len", "(", "fiber_r", ")", "\n", "distance", "=", "distance", "/", "npts", "\n", "", "elif", "distance_method", "==", "'StrictSimilarity'", ":", "\n", "# for use in laterality", "\n", "# this is the product of all similarity values along the fiber", "\n", "# not truly a distance but it's easiest to compute here in this function", "\n", "# where we have all distances along the fiber", "\n", "# print \"distance range :\", numpy.min(distance), numpy.max(distance)", "\n", "#distance = distance_to_similarity(distance, sigmasq)", "\n", "# print \"similarity range :\", numpy.min(distance), numpy.max(distance)", "\n", "        ", "distance", "=", "numpy", ".", "prod", "(", "distance", ",", "1", ")", "\n", "# print \"overall similarity range:\", numpy.min(distance), numpy.max(distance)", "\n", "", "elif", "distance_method", "==", "'Mean_shape'", ":", "\n", "\n", "# sum along fiber", "\n", "        ", "distance_square", "=", "distance", "\n", "distance", "=", "numpy", ".", "sqrt", "(", "distance_square", ")", "\n", "\n", "d", "=", "numpy", ".", "sum", "(", "distance", ",", "1", ")", "\n", "# Remove effect of number of points along fiber (mean)", "\n", "npts", "=", "float", "(", "fiber_array", ".", "points_per_fiber", ")", "\n", "d", "=", "numpy", ".", "divide", "(", "d", ",", "npts", ")", "\n", "# for consistency with other methods we need to square this value", "\n", "d", "=", "numpy", ".", "square", "(", "d", ")", "\n", "\n", "distance_endpoints", "=", "(", "distance", "[", ":", ",", "0", "]", "+", "distance", "[", ":", ",", "npts", "-", "1", "]", ")", "/", "2", "\n", "\n", "for", "i", "in", "numpy", ".", "linspace", "(", "0", ",", "numpy", ".", "size", "(", "distance", ",", "0", ")", "-", "1", ",", "numpy", ".", "size", "(", "distance", ",", "0", ")", ")", ":", "\n", "            ", "for", "j", "in", "numpy", ".", "linspace", "(", "0", ",", "numpy", ".", "size", "(", "distance", ",", "1", ")", "-", "1", ",", "numpy", ".", "size", "(", "distance", ",", "1", ")", ")", ":", "\n", "                ", "if", "distance", "[", "i", ",", "j", "]", "==", "0", ":", "\n", "                    ", "distance", "[", "i", ",", "j", "]", "=", "1", "\n", "", "", "", "ddx", "=", "numpy", ".", "divide", "(", "ddx", ",", "distance", ")", "\n", "ddy", "=", "numpy", ".", "divide", "(", "ddy", ",", "distance", ")", "\n", "ddz", "=", "numpy", ".", "divide", "(", "ddz", ",", "distance", ")", "\n", "# print ddx*ddx+ddy*ddy+ddz*ddz", "\n", "npts", "=", "float", "(", "fiber_array", ".", "points_per_fiber", ")", "\n", "angles", "=", "numpy", ".", "zeros", "(", "[", "(", "numpy", ".", "size", "(", "distance", ")", ")", "/", "npts", ",", "npts", "*", "(", "npts", "+", "1", ")", "/", "2", "]", ")", "\n", "s", "=", "0", "\n", "n", "=", "numpy", ".", "linspace", "(", "0", ",", "npts", "-", "1", ",", "npts", ")", "\n", "for", "i", "in", "n", ":", "\n", "            ", "m", "=", "numpy", ".", "linspace", "(", "0", ",", "i", ",", "i", "+", "1", ")", "\n", "for", "j", "in", "m", ":", "\n", "                ", "angles", "[", ":", ",", "s", "]", "=", "(", "ddx", "[", ":", ",", "i", "]", "-", "ddx", "[", ":", ",", "j", "]", ")", "*", "(", "ddx", "[", ":", ",", "i", "]", "-", "ddx", "[", ":", ",", "j", "]", ")", "+", "(", "ddy", "[", ":", ",", "i", "]", "-", "ddy", "[", ":", ",", "j", "]", ")", "*", "(", "\n", "ddy", "[", ":", ",", "i", "]", "-", "ddy", "[", ":", ",", "j", "]", ")", "+", "(", "ddz", "[", ":", ",", "i", "]", "-", "ddz", "[", ":", ",", "j", "]", ")", "*", "(", "ddz", "[", ":", ",", "i", "]", "-", "ddz", "[", ":", ",", "j", "]", ")", "\n", "s", "=", "s", "+", "1", "\n", "", "", "angles", "=", "(", "numpy", ".", "sqrt", "(", "angles", ")", ")", "/", "2", "\n", "angle", "=", "numpy", ".", "max", "(", "angles", ",", "1", ")", "\n", "# print angle.max()", "\n", "\n", "distance", "=", "0.5", "*", "d", "+", "0.4", "*", "d", "/", "(", "0.5", "+", "0.5", "*", "(", "1", "-", "angle", "*", "angle", ")", ")", "+", "0.1", "*", "distance_endpoints", "\n", "\n", "", "else", ":", "\n", "        ", "print", "(", "\"<similarity.py> throwing Exception. Unknown input distance method (typo?):\"", ",", "distance_method", ")", "\n", "raise", "Exception", "(", "\"unknown distance method\"", ")", "\n", "\n", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance": [[109, 158], ["fiber_distance._fiber_distance_internal_use", "fiber_distance._fiber_distance_internal_use", "numpy.maximum", "numpy.minimum", "numpy.stack().transpose", "fiber_distance.fiber_distance", "numpy.maximum", "numpy.minimum", "numpy.stack"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance._fiber_distance_internal_use", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance._fiber_distance_internal_use", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_distance"], ["", "def", "fiber_distance", "(", "fiber", ",", "fiber_array", ",", "threshold", "=", "0", ",", "distance_method", "=", "'Mean'", ",", "fiber_landmarks", "=", "None", ",", "landmarks", "=", "None", ",", "\n", "sigmasq", "=", "6400", ",", "bilateral", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Find pairwise fiber distance from fiber to all fibers in fiber_array.\n    The Mean and MeanSquared distances are the average distance per\n    fiber point, to remove scaling effects (dependence on number of\n    points chosen for fiber parameterization). The Hausdorff distance\n    is the maximum distance between corresponding points.\n    input fiber should be class Fiber. fibers should be class FiberArray\n    \"\"\"", "\n", "fiber_r", "=", "fiber", "[", ":", ",", "0", "]", "\n", "fiber_a", "=", "fiber", "[", ":", ",", "1", "]", "\n", "fiber_s", "=", "fiber", "[", ":", ",", "2", "]", "\n", "\n", "# get fiber in reverse point order, equivalent representation", "\n", "fiber_r_quiv", "=", "fiber_r", "[", ":", ":", "-", "1", "]", "\n", "fiber_a_quiv", "=", "fiber_a", "[", ":", ":", "-", "1", "]", "\n", "fiber_s_quiv", "=", "fiber_s", "[", ":", ":", "-", "1", "]", "\n", "\n", "# compute pairwise fiber distances along fibers", "\n", "distance_1", "=", "_fiber_distance_internal_use", "(", "fiber_r", ",", "fiber_a", ",", "fiber_s", ",", "fiber_array", ",", "threshold", ",", "distance_method", ",", "fiber_landmarks", ",", "\n", "landmarks", ",", "sigmasq", ")", "\n", "distance_2", "=", "_fiber_distance_internal_use", "(", "fiber_r_quiv", ",", "fiber_a_quiv", ",", "fiber_s_quiv", ",", "fiber_array", ",", "threshold", ",", "distance_method", ",", "fiber_landmarks", ",", "\n", "landmarks", ",", "sigmasq", ")", "\n", "\n", "# choose the lowest distance, corresponding to the optimal fiber", "\n", "# representation (either forward or reverse order)", "\n", "if", "distance_method", "==", "'StrictSimilarity'", ":", "\n", "# for use in laterality", "\n", "# this is the product of all similarity values along the fiber", "\n", "        ", "distance", "=", "numpy", ".", "maximum", "(", "distance_1", ",", "distance_2", ")", "\n", "", "else", ":", "\n", "        ", "distance", "=", "numpy", ".", "minimum", "(", "distance_1", ",", "distance_2", ")", "\n", "\n", "", "if", "bilateral", ":", "\n", "        ", "fiber_r_ref", "=", "-", "fiber_r", "\n", "fiber_reflect", "=", "numpy", ".", "stack", "(", "(", "fiber_r_ref", ",", "fiber_a", ",", "fiber_s", ")", ")", ".", "transpose", "(", "[", "1", ",", "0", "]", ")", "\n", "# call this function again with the reflected fiber. Do NOT reflect again (bilateral=False) to avoid infinite loop.", "\n", "distance_reflect", "=", "fiber_distance", "(", "fiber_reflect", ",", "fiber_array", ",", "threshold", ",", "distance_method", ",", "fiber_landmarks", ",", "\n", "landmarks", ",", "sigmasq", ",", "bilateral", "=", "False", ")", "\n", "# choose the best distance, corresponding to the optimal fiber", "\n", "# representation (either reflected or not)", "\n", "if", "distance_method", "==", "'StrictSimilarity'", ":", "\n", "# this is the product of all similarity values along the fiber", "\n", "            ", "distance", "=", "numpy", ".", "maximum", "(", "distance", ",", "distance_reflect", ")", "\n", "", "else", ":", "\n", "            ", "distance", "=", "numpy", ".", "minimum", "(", "distance", ",", "distance_reflect", ")", "\n", "\n", "", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_pair_distance": [[163, 181], ["numpy.square", "numpy.square", "numpy.square", "numpy.sum", "len", "numpy.sqrt"], "function", ["None"], ["", "def", "fiber_pair_distance", "(", "fiber1", ",", "fiber2", ")", ":", "\n", "    ", "fiber_r1", "=", "fiber1", "[", ":", ",", "0", "]", "\n", "fiber_a1", "=", "fiber1", "[", ":", ",", "1", "]", "\n", "fiber_s1", "=", "fiber1", "[", ":", ",", "2", "]", "\n", "fiber_r2", "=", "fiber2", "[", ":", ",", "0", "]", "\n", "fiber_a2", "=", "fiber2", "[", ":", ",", "1", "]", "\n", "fiber_s2", "=", "fiber2", "[", ":", ",", "2", "]", "\n", "ddx", "=", "fiber_r1", "-", "fiber_r2", "\n", "ddy", "=", "fiber_a1", "-", "fiber_a2", "\n", "ddz", "=", "fiber_s1", "-", "fiber_s2", "\n", "dx", "=", "numpy", ".", "square", "(", "ddx", ")", "\n", "dy", "=", "numpy", ".", "square", "(", "ddy", ")", "\n", "dz", "=", "numpy", ".", "square", "(", "ddz", ")", "\n", "distance", "=", "dx", "+", "dy", "+", "dz", "\n", "distance", "=", "numpy", ".", "sum", "(", "numpy", ".", "sqrt", "(", "distance", ")", ")", "\n", "npts", "=", "len", "(", "dx", ")", "\n", "distance", "=", "distance", "/", "npts", "\n", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_pair_similarity": [[182, 215], ["fiber_distance.fiber_pair_distance", "fiber_distance.fiber_pair_distance", "numpy.minimum"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_pair_distance", "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.fiber_distance.fiber_pair_distance"], ["", "def", "fiber_pair_similarity", "(", "fiber1", ",", "fiber2", ")", ":", "\n", "    ", "distance1", "=", "fiber_pair_distance", "(", "fiber1", ",", "fiber2", ")", "\n", "fiber1_equiv", "=", "fiber1", "\n", "fiber1_equiv", "[", ":", ",", "0", "]", "=", "fiber1", "[", ":", ":", "-", "1", ",", "0", "]", "\n", "fiber1_equiv", "[", ":", ",", "1", "]", "=", "fiber1", "[", ":", ":", "-", "1", ",", "1", "]", "\n", "fiber1_equiv", "[", ":", ",", "2", "]", "=", "fiber1", "[", ":", ":", "-", "1", ",", "2", "]", "\n", "distance2", "=", "fiber_pair_distance", "(", "fiber1_equiv", ",", "fiber2", ")", "\n", "distance", "=", "numpy", ".", "minimum", "(", "distance1", ",", "distance2", ")", "\n", "\n", "# roi_onehot1 = numpy.zeros([64])", "\n", "# roi_label1 = numpy.unique(roi1)", "\n", "# if 0 in roi_label1:", "\n", "#     index_0 = roi_label1 != 0", "\n", "#     roi_label1 = roi_label1[index_0]", "\n", "#     print(roi_label1)", "\n", "# roi_onehot1[(roi_label1).astype(int)]=1", "\n", "#", "\n", "# roi_onehot2 = numpy.zeros([64])", "\n", "# roi_label2 = numpy.unique(roi2)", "\n", "# if 0 in roi_label2:", "\n", "#     index_0 = roi_label2 != 0", "\n", "#     roi_label2 = roi_label2[index_0]", "\n", "# roi_onehot2[(roi_label2).astype(int)]=1", "\n", "# intersection = roi_onehot1 * roi_onehot2", "\n", "# smooth=1e-10", "\n", "# dis_roi = 1-(2 * intersection.sum() + smooth) / ( roi_onehot1.sum() +  roi_onehot2.sum() + smooth)", "\n", "\n", "#similarity = numpy.exp(-distance / 2000)", "\n", "#print('distance',distance1,distance2,similarity,distance/2000)", "\n", "#print('distance', distance1, distance2,distance)", "\n", "#print(distance,dis_roi)", "\n", "#distance = dis_roi*distance", "\n", "return", "distance", "#similarity", "\n", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.metrics.acc": [[34, 45], ["labels_true.astype.astype.astype", "numpy.zeros", "range", "linear_assignment", "max", "labels_pred.max", "labels_true.astype.astype.max", "numpy.zeros.max", "sum"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "acc", "(", "labels_true", ",", "labels_pred", ")", ":", "\n", "        ", "labels_true", "=", "labels_true", ".", "astype", "(", "np", ".", "int64", ")", "\n", "assert", "labels_pred", ".", "size", "==", "labels_true", ".", "size", "\n", "D", "=", "max", "(", "labels_pred", ".", "max", "(", ")", ",", "labels_true", ".", "max", "(", ")", ")", "+", "1", "\n", "w", "=", "np", ".", "zeros", "(", "(", "D", ",", "D", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "for", "i", "in", "range", "(", "labels_pred", ".", "size", ")", ":", "\n", "            ", "w", "[", "labels_pred", "[", "i", "]", ",", "labels_true", "[", "i", "]", "]", "+=", "1", "\n", "", "from", "sklearn", ".", "utils", ".", "linear_assignment_", "import", "linear_assignment", "\n", "ind", "=", "linear_assignment", "(", "w", ".", "max", "(", ")", "-", "w", ")", "\n", "return", "sum", "(", "[", "w", "[", "i", ",", "j", "]", "for", "i", ",", "j", "in", "ind", "]", ")", "*", "1.0", "/", "labels_pred", ".", "size", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.tensor2img": [[15, 21], ["torch.clamp", "inv_normalize", "tensor.cpu"], "function", ["None"], ["def", "tensor2img", "(", "tensor", ")", ":", "\n", "    ", "img", "=", "tensor", ".", "cpu", "(", ")", ".", "data", "[", "0", "]", "\n", "if", "img", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "        ", "img", "=", "inv_normalize", "(", "img", ")", "\n", "", "img", "=", "torch", ".", "clamp", "(", "img", ",", "0", ",", "1", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.utils.utils.print_both": [[24, 27], ["print", "f.write"], "function", ["None"], ["", "def", "print_both", "(", "f", ",", "text", ")", ":", "\n", "    ", "print", "(", "text", ")", "\n", "f", ".", "write", "(", "text", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.models.GCN.__init__": [[7, 13], ["torch.Module.__init__", "utils.pygcn.layers.GraphConvolution", "utils.pygcn.layers.GraphConvolution"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nfeat", ",", "nhid", ",", "nclass", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "GCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "gc1", "=", "GraphConvolution", "(", "nfeat", ",", "nhid", ")", "\n", "self", ".", "gc2", "=", "GraphConvolution", "(", "nhid", ",", "nclass", ")", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.models.GCN.forward": [[14, 19], ["torch.relu", "torch.relu", "torch.dropout", "torch.dropout", "models.GCN.gc2", "torch.log_softmax", "torch.log_softmax", "models.GCN.gc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "adj", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "gc1", "(", "x", ",", "adj", ")", ")", "\n", "x", "=", "F", ".", "dropout", "(", "x", ",", "self", ".", "dropout", ",", "training", "=", "self", ".", "training", ")", "\n", "x", "=", "self", ".", "gc2", "(", "x", ",", "adj", ")", "\n", "return", "F", ".", "log_softmax", "(", "x", ",", "dim", "=", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.train.train": [[62, 86], ["time.time", "model.train", "optimizer.zero_grad", "model", "torch.nll_loss", "pygcn.utils.accuracy", "F.nll_loss.backward", "optimizer.step", "torch.nll_loss", "pygcn.utils.accuracy", "print", "model.eval", "model", "F.nll_loss.item", "pygcn.utils.accuracy.item", "F.nll_loss.item", "pygcn.utils.accuracy.item", "time.time"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.train.train", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.accuracy", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.accuracy"], ["print", "(", "args", ")", "\n", "\n", "if", "args", ".", "mode", "==", "'pretrain'", "and", "not", "args", ".", "pretrain", ":", "\n", "        ", "print", "(", "\"Nothing to do :(\"", ")", "\n", "exit", "(", ")", "\n", "\n", "", "board", "=", "args", ".", "tensorboard", "\n", "\n", "# Deal with pretraining option and way of showing network path", "\n", "pretrain", "=", "args", ".", "pretrain", "\n", "net_is_path", "=", "True", "\n", "if", "not", "pretrain", ":", "\n", "        ", "try", ":", "\n", "            ", "int", "(", "args", ".", "pretrained_net", ")", "\n", "idx", "=", "args", ".", "pretrained_net", "\n", "net_is_path", "=", "False", "\n", "", "except", ":", "\n", "            ", "pass", "\n", "", "", "params", "=", "{", "'pretrain'", ":", "pretrain", "}", "\n", "\n", "# Directories", "\n", "# Create directories structure", "\n", "dirs", "=", "[", "'runs'", ",", "'reports'", ",", "'nets'", "]", "\n", "list", "(", "map", "(", "lambda", "x", ":", "os", ".", "makedirs", "(", "x", ",", "exist_ok", "=", "True", ")", ",", "dirs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.train.test": [[88, 96], ["model.eval", "model", "torch.nll_loss", "pygcn.utils.accuracy", "print", "F.nll_loss.item", "pygcn.utils.accuracy.item"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.accuracy"], ["model_name", "=", "args", ".", "net_architecture", "\n", "# Indexing (for automated reports saving) - allows to run many trainings and get all the reports collected", "\n", "if", "pretrain", "or", "(", "not", "pretrain", "and", "net_is_path", ")", ":", "\n", "        ", "reports_list", "=", "sorted", "(", "os", ".", "listdir", "(", "'reports'", ")", ",", "reverse", "=", "True", ")", "\n", "if", "reports_list", ":", "\n", "            ", "for", "file", "in", "reports_list", ":", "\n", "# print(file)", "\n", "                ", "if", "fnmatch", ".", "fnmatch", "(", "file", ",", "model_name", "+", "'*'", ")", ":", "\n", "                    ", "idx", "=", "int", "(", "str", "(", "file", ")", "[", "-", "7", ":", "-", "4", "]", ")", "+", "1", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__": [[14, 24], ["torch.nn.modules.module.Module.__init__", "torch.nn.parameter.Parameter", "layers.GraphConvolution.reset_parameters", "torch.FloatTensor", "torch.nn.parameter.Parameter", "layers.GraphConvolution.register_parameter", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__init__", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.reset_parameters"], ["def", "__init__", "(", "self", ",", "in_features", ",", "out_features", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "GraphConvolution", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_features", "=", "in_features", "\n", "self", ".", "out_features", "=", "out_features", "\n", "self", ".", "weight", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "in_features", ",", "out_features", ")", ")", "\n", "if", "bias", ":", "\n", "            ", "self", ".", "bias", "=", "Parameter", "(", "torch", ".", "FloatTensor", "(", "out_features", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "register_parameter", "(", "'bias'", ",", "None", ")", "\n", "", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.reset_parameters": [[25, 30], ["layers.GraphConvolution.weight.data.uniform_", "math.sqrt", "layers.GraphConvolution.bias.data.uniform_", "layers.GraphConvolution.weight.size"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "weight", ".", "size", "(", "1", ")", ")", "\n", "self", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "self", ".", "bias", ".", "data", ".", "uniform_", "(", "-", "stdv", ",", "stdv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.forward": [[31, 38], ["torch.mm", "torch.spmm"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "adj", ")", ":", "\n", "        ", "support", "=", "torch", ".", "mm", "(", "input", ",", "self", ".", "weight", ")", "\n", "output", "=", "torch", ".", "spmm", "(", "adj", ",", "support", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "return", "output", "+", "self", ".", "bias", "\n", "", "else", ":", "\n", "            ", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.layers.GraphConvolution.__repr__": [[39, 43], ["str", "str"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "' ('", "+", "str", "(", "self", ".", "in_features", ")", "+", "' -> '", "+", "str", "(", "self", ".", "out_features", ")", "+", "')'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.encode_onehot": [[6, 13], ["set", "numpy.array", "list", "numpy.identity", "enumerate", "map", "len"], "function", ["None"], ["mean", "=", "(", "0.485", ",", "0.456", ",", "0.406", ")", "\n", "std", "=", "(", "0.229", ",", "0.224", ",", "0.225", ")", "\n", "inv_normalize", "=", "transforms", ".", "Normalize", "(", "\n", "mean", "=", "[", "-", "0.485", "/", ".229", ",", "-", "0.456", "/", "0.224", ",", "-", "0.406", "/", "0.255", "]", ",", "\n", "std", "=", "[", "1", "/", "0.229", ",", "1", "/", "0.224", ",", "1", "/", "0.255", "]", "\n", ")", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.load_data": [[15, 54], ["print", "numpy.genfromtxt", "scipy.csr_matrix", "utils.encode_onehot", "numpy.array", "numpy.genfromtxt", "numpy.array().reshape", "scipy.coo_matrix", "utils.normalize", "utils.normalize", "range", "range", "range", "torch.FloatTensor", "torch.LongTensor", "utils.sparse_mx_to_torch_sparse_tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sparse_mx_to_torch_sparse_tensor.multiply", "numpy.array", "numpy.dtype", "enumerate", "numpy.array", "numpy.ones", "sparse_mx_to_torch_sparse_tensor.T.multiply", "scipy.eye", "torch.FloatTensor.todense", "numpy.where", "list", "map", "np.genfromtxt.flatten"], "function", ["home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.encode_onehot", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.normalize", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.normalize", "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.sparse_mx_to_torch_sparse_tensor"], ["def", "tensor2img", "(", "tensor", ")", ":", "\n", "    ", "img", "=", "tensor", ".", "cpu", "(", ")", ".", "data", "[", "0", "]", "\n", "if", "img", ".", "shape", "[", "0", "]", "!=", "1", ":", "\n", "        ", "img", "=", "inv_normalize", "(", "img", ")", "\n", "", "img", "=", "torch", ".", "clamp", "(", "img", ",", "0", ",", "1", ")", "\n", "return", "img", "\n", "\n", "\n", "# Define printing to console and file", "\n", "", "def", "print_both", "(", "f", ",", "text", ")", ":", "\n", "    ", "print", "(", "text", ")", "\n", "f", ".", "write", "(", "text", "+", "'\\n'", ")", "\n", "\n", "\n", "# Metrics class was copied from DCEC article authors repository (link in README)", "\n", "", "class", "metrics", ":", "\n", "    ", "nmi", "=", "sklearn", ".", "metrics", ".", "normalized_mutual_info_score", "\n", "ari", "=", "sklearn", ".", "metrics", ".", "adjusted_rand_score", "\n", "\n", "@", "staticmethod", "\n", "def", "acc", "(", "labels_true", ",", "labels_pred", ")", ":", "\n", "        ", "labels_true", "=", "labels_true", ".", "astype", "(", "np", ".", "int64", ")", "\n", "assert", "labels_pred", ".", "size", "==", "labels_true", ".", "size", "\n", "D", "=", "max", "(", "labels_pred", ".", "max", "(", ")", ",", "labels_true", ".", "max", "(", ")", ")", "+", "1", "\n", "w", "=", "np", ".", "zeros", "(", "(", "D", ",", "D", ")", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "for", "i", "in", "range", "(", "labels_pred", ".", "size", ")", ":", "\n", "            ", "w", "[", "labels_pred", "[", "i", "]", ",", "labels_true", "[", "i", "]", "]", "+=", "1", "\n", "", "from", "sklearn", ".", "utils", ".", "linear_assignment_", "import", "linear_assignment", "\n", "ind", "=", "linear_assignment", "(", "w", ".", "max", "(", ")", "-", "w", ")", "\n", "return", "sum", "(", "[", "w", "[", "i", ",", "j", "]", "for", "i", ",", "j", "in", "ind", "]", ")", "*", "1.0", "/", "labels_pred", ".", "size", "\n", "", "", ""]], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.normalize": [[56, 64], ["numpy.array", "numpy.power().flatten", "scipy.diags", "sp.diags.dot", "r_mat_inv.dot.sum", "numpy.power", "numpy.isinf"], "function", ["None"], []], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.accuracy": [[66, 71], ["[].type_as", "[].type_as.eq().double", "correct.sum.sum", "len", "[].type_as.eq", "output.max"], "function", ["None"], []], "home.repos.pwc.inspect_result.slicerdmri_dfc.pygcn.utils.sparse_mx_to_torch_sparse_tensor": [[73, 81], ["sparse_mx.tocoo().astype.tocoo().astype", "torch.from_numpy", "torch.from_numpy", "torch.Size", "torch.sparse.FloatTensor", "numpy.vstack().astype", "sparse_mx.tocoo().astype.tocoo", "numpy.vstack"], "function", ["None"], []]}