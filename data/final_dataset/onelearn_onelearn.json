{"home.repos.pwc.inspect_result.onelearn_onelearn.None.check_speed.precompile_amf": [[49, 63], ["sklearn.datasets.make_blobs", "int", "onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.predict_proba", "y.max"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["def", "precompile_amf", "(", ")", ":", "\n", "    ", "X", ",", "y", "=", "make_blobs", "(", "n_samples", "=", "5", ")", "\n", "n_classes", "=", "int", "(", "y", ".", "max", "(", ")", "+", "1", ")", "\n", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "n_classes", ",", "\n", "random_state", "=", "0", ",", "\n", "use_aggregation", "=", "True", ",", "\n", "n_estimators", "=", "1", ",", "\n", "split_pure", "=", "False", ",", "\n", "dirichlet", "=", "0.5", ",", "\n", "step", "=", "1.0", ",", "\n", ")", "\n", "amf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "amf", ".", "predict_proba", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifierNoPython.__init__": [[59, 130], ["tree.TreeClassifier", "tree.TreeClassifier", "range", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_classes", ",", "\n", "n_features", ",", "\n", "n_estimators", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "dirichlet", ",", "\n", "split_pure", ",", "\n", "n_jobs", ",", "\n", "n_samples_increment", ",", "\n", "verbose", ",", "\n", "samples", ",", "\n", "trees_iteration", ",", "\n", "trees_n_nodes", ",", "\n", "trees_n_nodes_capacity", ",", "\n", ")", ":", "\n", "        ", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "n_features", "=", "n_features", "\n", "self", ".", "n_estimators", "=", "n_estimators", "\n", "self", ".", "step", "=", "step", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "use_aggregation", "=", "use_aggregation", "\n", "self", ".", "dirichlet", "=", "dirichlet", "\n", "self", ".", "split_pure", "=", "split_pure", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "self", ".", "n_samples_increment", "=", "n_samples_increment", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "samples", "=", "samples", "\n", "if", "trees_iteration", ".", "size", "==", "0", ":", "\n", "            ", "self", ".", "iteration", "=", "0", "\n", "# TODO: reflected lists will be replaced by typed list soon...", "\n", "iteration", "=", "0", "\n", "n_nodes", "=", "0", "\n", "n_nodes_capacity", "=", "0", "\n", "trees", "=", "[", "\n", "TreeClassifier", "(", "\n", "self", ".", "n_classes", ",", "\n", "self", ".", "n_features", ",", "\n", "self", ".", "step", ",", "\n", "self", ".", "loss", ",", "\n", "self", ".", "use_aggregation", ",", "\n", "self", ".", "dirichlet", ",", "\n", "self", ".", "split_pure", ",", "\n", "self", ".", "samples", ",", "\n", "iteration", ",", "\n", "n_nodes", ",", "\n", "n_nodes_capacity", ",", "\n", ")", "\n", "for", "_", "in", "range", "(", "n_estimators", ")", "\n", "]", "\n", "self", ".", "trees", "=", "trees", "\n", "", "else", ":", "\n", "            ", "trees", "=", "[", "\n", "TreeClassifier", "(", "\n", "self", ".", "n_classes", ",", "\n", "self", ".", "n_features", ",", "\n", "self", ".", "step", ",", "\n", "self", ".", "loss", ",", "\n", "self", ".", "use_aggregation", ",", "\n", "self", ".", "dirichlet", ",", "\n", "self", ".", "split_pure", ",", "\n", "self", ".", "samples", ",", "\n", "trees_iteration", "[", "n_estimator", "]", ",", "\n", "trees_n_nodes", "[", "n_estimator", "]", ",", "\n", "trees_n_nodes_capacity", "[", "n_estimator", "]", ",", "\n", ")", "\n", "for", "n_estimator", "in", "range", "(", "n_estimators", ")", "\n", "]", "\n", "self", ".", "trees", "=", "trees", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressorNoPython.__init__": [[288, 350], ["tree.TreeRegressor", "tree.TreeRegressor", "range", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_features", ",", "\n", "n_estimators", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "split_pure", ",", "\n", "n_jobs", ",", "\n", "n_samples_increment", ",", "\n", "verbose", ",", "\n", "samples", ",", "\n", "trees_iteration", ",", "\n", "trees_n_nodes", ",", "\n", "trees_n_nodes_capacity", ",", "\n", ")", ":", "\n", "        ", "self", ".", "n_features", "=", "n_features", "\n", "self", ".", "n_estimators", "=", "n_estimators", "\n", "self", ".", "step", "=", "step", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "use_aggregation", "=", "use_aggregation", "\n", "self", ".", "split_pure", "=", "split_pure", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "self", ".", "n_samples_increment", "=", "n_samples_increment", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "samples", "=", "samples", "\n", "if", "trees_iteration", ".", "size", "==", "0", ":", "\n", "            ", "self", ".", "iteration", "=", "0", "\n", "iteration", "=", "0", "\n", "n_nodes", "=", "0", "\n", "n_nodes_capacity", "=", "0", "\n", "trees", "=", "[", "\n", "TreeRegressor", "(", "\n", "self", ".", "n_features", ",", "\n", "self", ".", "step", ",", "\n", "self", ".", "loss", ",", "\n", "self", ".", "use_aggregation", ",", "\n", "self", ".", "split_pure", ",", "\n", "self", ".", "samples", ",", "\n", "iteration", ",", "\n", "n_nodes", ",", "\n", "n_nodes_capacity", ",", "\n", ")", "\n", "for", "_", "in", "range", "(", "n_estimators", ")", "\n", "]", "\n", "self", ".", "trees", "=", "trees", "\n", "", "else", ":", "\n", "            ", "trees", "=", "[", "\n", "TreeRegressor", "(", "\n", "self", ".", "n_features", ",", "\n", "self", ".", "step", ",", "\n", "self", ".", "loss", ",", "\n", "self", ".", "use_aggregation", ",", "\n", "self", ".", "split_pure", ",", "\n", "self", ".", "samples", ",", "\n", "trees_iteration", "[", "n_estimator", "]", ",", "\n", "trees_n_nodes", "[", "n_estimator", "]", ",", "\n", "trees_n_nodes_capacity", "[", "n_estimator", "]", ",", "\n", ")", "\n", "for", "n_estimator", "in", "range", "(", "n_estimators", ")", "\n", "]", "\n", "self", ".", "trees", "=", "trees", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.__init__": [[520, 590], ["os.getenv"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_estimators", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "split_pure", ",", "\n", "n_jobs", ",", "\n", "n_samples_increment", ",", "\n", "random_state", ",", "\n", "verbose", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Instantiates a `AMFLearner` instance.\n\n        Parameters\n        ----------\n        n_estimators : :obj:`int`\n            The number of trees in the forest.\n\n        step : :obj:`float`\n            Step-size for the aggregation weights.\n\n        loss : :obj:`str`\n            The loss used for the computation of the aggregation weights.\n\n        use_aggregation : :obj:`bool`\n            Controls if aggregation is used in the trees. It is highly recommended to\n            leave it as `True`.\n\n        split_pure : :obj:`bool`\n            Controls if nodes that contains only sample of the same class should be\n            split (\"pure\" nodes). Default is `False`, namely pure nodes are not split,\n            but `True` can be sometimes better.\n\n        n_jobs : :obj:`int`\n            Sets the number of threads used to grow the tree in parallel. The default is\n            n_jobs=1, namely single-threaded. Fow now, this parameter has no effect and\n            only a single thread can be used.\n\n        n_samples_increment : :obj:`int`\n            Sets the minimum amount of memory which is pre-allocated each time extra\n            memory is required for new samples and new nodes. Decreasing it can slow\n            down training. If you know that each ``partial_fit`` will be called with\n            approximately `n` samples, you can set n_samples_increment = `n` if `n` is\n            larger than the default.\n\n        random_state : :obj:`int` or :obj:`None`\n            Controls the randomness involved in the trees.\n\n        verbose : :obj:`bool`, default = `False`\n            Controls the verbosity when fitting and predicting.\n        \"\"\"", "\n", "# We will instantiate the numba class when data is passed to", "\n", "# `partial_fit`, since we need to know about `n_features` among others things", "\n", "self", ".", "no_python", "=", "None", "\n", "self", ".", "_n_features", "=", "None", "\n", "self", ".", "n_estimators", "=", "n_estimators", "\n", "self", ".", "step", "=", "step", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "use_aggregation", "=", "use_aggregation", "\n", "self", ".", "split_pure", "=", "split_pure", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "self", ".", "n_samples_increment", "=", "n_samples_increment", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "if", "os", ".", "getenv", "(", "\"NUMBA_DISABLE_JIT\"", ",", "None", ")", "==", "\"1\"", ":", "\n", "            ", "self", ".", "_using_numba", "=", "False", "\n", "", "else", ":", "\n", "            ", "self", ".", "_using_numba", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.partial_fit_helper": [[591, 648], ["checks.check_X_y", "forest.AMFLearner._extra_y_test", "forest.AMFLearner._set_random_state", "forest.AMFLearner._partial_fit", "forest.AMFLearner._put_back_random_state", "forest.AMFLearner._instantiate_nopython_class", "ValueError"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_X_y", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._extra_y_test", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._set_random_state", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._put_back_random_state", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._instantiate_nopython_class"], ["", "", "def", "partial_fit_helper", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "\"\"\"Updates the classifier with the given batch of samples.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix.\n\n        y : :obj:`np.ndarray`\n            Input labels vector.\n\n        classes : :obj:`None`\n            Must not be used, only here for backwards compatibility\n\n        Returns\n        -------\n        output : :obj:`AMFClassifier`\n            Updated instance of :obj:`AMFClassifier`\n\n        \"\"\"", "\n", "# First,ensure that X and y are C-contiguous and with float32 dtype", "\n", "X", ",", "y", "=", "check_X_y", "(", "\n", "X", ",", "\n", "y", ",", "\n", "accept_sparse", "=", "False", ",", "\n", "accept_large_sparse", "=", "False", ",", "\n", "dtype", "=", "\"float32\"", ",", "\n", "order", "=", "\"C\"", ",", "\n", "copy", "=", "False", ",", "\n", "force_all_finite", "=", "True", ",", "\n", "ensure_2d", "=", "True", ",", "\n", "allow_nd", "=", "False", ",", "\n", "multi_output", "=", "False", ",", "\n", "ensure_min_samples", "=", "1", ",", "\n", "ensure_min_features", "=", "1", ",", "\n", "y_numeric", "=", "True", ",", "\n", "estimator", "=", "self", ".", "__class__", ".", "__name__", ",", "\n", ")", "\n", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "\n", "self", ".", "_extra_y_test", "(", "y", ")", "\n", "# This is the first call to `partial_fit`, so we need to instantiate", "\n", "# the no python class", "\n", "if", "self", ".", "no_python", "is", "None", ":", "\n", "            ", "self", ".", "_n_features", "=", "n_features", "\n", "self", ".", "_instantiate_nopython_class", "(", ")", "\n", "", "else", ":", "\n", "            ", "_", ",", "n_features", "=", "X", ".", "shape", "\n", "if", "n_features", "!=", "self", ".", "n_features", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`partial_fit` was first called with n_features=%d while \"", "\n", "\"n_features=%d in this call\"", "%", "(", "self", ".", "n_features", ",", "n_features", ")", "\n", ")", "\n", "", "", "self", ".", "_set_random_state", "(", ")", "\n", "self", ".", "_partial_fit", "(", "X", ",", "y", ")", "\n", "self", ".", "_put_back_random_state", "(", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.predict_helper": [[650, 696], ["checks.check_array", "forest.AMFLearner._set_random_state", "forest.AMFLearner._compute_predictions", "forest.AMFLearner._put_back_random_state", "RuntimeError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._set_random_state", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._compute_predictions", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._put_back_random_state"], ["", "def", "predict_helper", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Helper method for the predictions of the given features vectors. This is used\n        in the ``predict`` and ``predict_proba`` methods of ``AMFRegressor`` and\n        ``AMFClassifier``.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix to predict for.\n\n        Returns\n        -------\n        output : :obj:`np.ndarray`\n            Returns the predictions for the input features\n\n        \"\"\"", "\n", "X", "=", "check_array", "(", "\n", "X", ",", "\n", "accept_sparse", "=", "False", ",", "\n", "accept_large_sparse", "=", "False", ",", "\n", "dtype", "=", "[", "\"float32\"", "]", ",", "\n", "order", "=", "\"C\"", ",", "\n", "copy", "=", "False", ",", "\n", "force_all_finite", "=", "True", ",", "\n", "ensure_2d", "=", "True", ",", "\n", "allow_nd", "=", "False", ",", "\n", "ensure_min_samples", "=", "1", ",", "\n", "ensure_min_features", "=", "1", ",", "\n", "estimator", "=", "self", ".", "__class__", ".", "__name__", ",", "\n", ")", "\n", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "if", "not", "self", ".", "no_python", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"You must call `partial_fit` before asking for predictions\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "n_features", "!=", "self", ".", "n_features", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`partial_fit` was called with n_features=%d while predictions are \"", "\n", "\"asked with n_features=%d\"", "%", "(", "self", ".", "n_features", ",", "n_features", ")", "\n", ")", "\n", "# TODO: this is useless for predictions ?!?", "\n", "", "", "self", ".", "_set_random_state", "(", ")", "\n", "predictions", "=", "self", ".", "_compute_predictions", "(", "X", ")", "\n", "self", ".", "_put_back_random_state", "(", ")", "\n", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.weighted_depth_helper": [[697, 725], ["checks.check_array", "forest.AMFLearner._compute_weighted_depths", "RuntimeError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._compute_weighted_depths"], ["", "def", "weighted_depth_helper", "(", "self", ",", "X", ")", ":", "\n", "        ", "X", "=", "check_array", "(", "\n", "X", ",", "\n", "accept_sparse", "=", "False", ",", "\n", "accept_large_sparse", "=", "False", ",", "\n", "dtype", "=", "[", "\"float32\"", "]", ",", "\n", "order", "=", "\"C\"", ",", "\n", "copy", "=", "False", ",", "\n", "force_all_finite", "=", "True", ",", "\n", "ensure_2d", "=", "True", ",", "\n", "allow_nd", "=", "False", ",", "\n", "ensure_min_samples", "=", "1", ",", "\n", "ensure_min_features", "=", "1", ",", "\n", "estimator", "=", "self", ".", "__class__", ".", "__name__", ",", "\n", ")", "\n", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "if", "not", "self", ".", "no_python", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"You must call `partial_fit` before asking for weighted depths\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "n_features", "!=", "self", ".", "n_features", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`partial_fit` was called with n_features=%d while depths are \"", "\n", "\"asked with n_features=%d\"", "%", "(", "self", ".", "n_features", ",", "n_features", ")", "\n", ")", "\n", "", "", "weighted_depths", "=", "self", ".", "_compute_weighted_depths", "(", "X", ")", "\n", "return", "weighted_depths", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.load": [[726, 743], ["open", "pickle.load", "cls._from_dict"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.load", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._from_dict"], ["", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "filename", ")", ":", "\n", "        ", "\"\"\"Loads a AMF object from file (created with :meth:`save`)\n\n        Parameters\n        ----------\n        filename : :obj:`str`\n            Filename containing the serialized AMF object\n\n        Returns\n        -------\n        output : object\n            Either AMFClassifier or AMFRegressor contained in the file\n        \"\"\"", "\n", "with", "open", "(", "filename", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "d", "=", "pkl", ".", "load", "(", "f", ")", "\n", "return", "cls", ".", "_from_dict", "(", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.save": [[744, 756], ["open", "forest.AMFLearner._to_dict", "pickle.dump"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._to_dict"], ["", "", "def", "save", "(", "self", ",", "filename", ")", ":", "\n", "        ", "\"\"\"Saves a AMF object to file using pickle\n\n        Parameters\n        ----------\n        filename : :obj:`str`\n            Filename containing the serialized AMF object\n        \"\"\"", "\n", "\n", "with", "open", "(", "filename", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "d", "=", "self", ".", "_to_dict", "(", ")", "\n", "pkl", ".", "dump", "(", "d", ",", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._compute_predictions": [[757, 759], ["None"], "methods", ["None"], ["", "", "def", "_compute_predictions", "(", "self", ",", "X", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._extra_y_test": [[760, 762], ["None"], "methods", ["None"], ["", "def", "_extra_y_test", "(", "self", ",", "y", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._instantiate_nopython_class": [[763, 765], ["None"], "methods", ["None"], ["", "def", "_instantiate_nopython_class", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._set_random_state": [[766, 779], ["numpy.random.RandomState", "numba._helperlib.rnd_get_np_state_ptr", "numba._helperlib.rnd_set_state", "numpy.random.seed", "numpy.random.RandomState.get_state", "int"], "methods", ["None"], ["", "def", "_set_random_state", "(", "self", ")", ":", "\n", "# This uses a trick by Alexandre Gramfort,", "\n", "#   see https://github.com/numba/numba/issues/3249", "\n", "        ", "if", "self", ".", "_random_state", ">=", "0", ":", "\n", "            ", "if", "self", ".", "_using_numba", ":", "\n", "                ", "r", "=", "np", ".", "random", ".", "RandomState", "(", "self", ".", "_random_state", ")", "\n", "ptr", "=", "_helperlib", ".", "rnd_get_np_state_ptr", "(", ")", "\n", "ints", ",", "index", "=", "r", ".", "get_state", "(", ")", "[", "1", ":", "3", "]", "\n", "_helperlib", ".", "rnd_set_state", "(", "ptr", ",", "(", "index", ",", "[", "int", "(", "x", ")", "for", "x", "in", "ints", "]", ")", ")", "\n", "self", ".", "_ptr", "=", "ptr", "\n", "self", ".", "_r", "=", "r", "\n", "", "else", ":", "\n", "                ", "np", ".", "random", ".", "seed", "(", "self", ".", "_random_state", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._put_back_random_state": [[780, 789], ["numba._helperlib.rnd_get_state", "r.set_state"], "methods", ["None"], ["", "", "", "def", "_put_back_random_state", "(", "self", ")", ":", "\n", "# This uses a trick by Alexandre Gramfort,", "\n", "#   see https://github.com/numba/numba/issues/3249", "\n", "        ", "if", "self", ".", "_random_state", ">=", "0", ":", "\n", "            ", "if", "self", ".", "_using_numba", ":", "\n", "                ", "ptr", "=", "self", ".", "_ptr", "\n", "r", "=", "self", ".", "_r", "\n", "index", ",", "ints", "=", "_helperlib", ".", "rnd_get_state", "(", "ptr", ")", "\n", "r", ".", "set_state", "(", "(", "\"MT19937\"", ",", "ints", ",", "index", ",", "0", ",", "0.0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.get_nodes_df": [[790, 850], ["pd.DataFrame", "tuple", "tuple", "tuple"], "methods", ["None"], ["", "", "", "def", "get_nodes_df", "(", "self", ",", "idx_tree", ")", ":", "\n", "        ", "import", "pandas", "as", "pd", "\n", "\n", "tree", "=", "self", ".", "no_python", ".", "trees", "[", "idx_tree", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "n_nodes", "=", "nodes", ".", "n_nodes", "\n", "index", "=", "nodes", ".", "index", "[", ":", "n_nodes", "]", "\n", "parent", "=", "nodes", ".", "parent", "[", ":", "n_nodes", "]", "\n", "left", "=", "nodes", ".", "left", "[", ":", "n_nodes", "]", "\n", "right", "=", "nodes", ".", "right", "[", ":", "n_nodes", "]", "\n", "feature", "=", "nodes", ".", "feature", "[", ":", "n_nodes", "]", "\n", "threshold", "=", "nodes", ".", "threshold", "[", ":", "n_nodes", "]", "\n", "time", "=", "nodes", ".", "time", "[", ":", "n_nodes", "]", "\n", "depth", "=", "nodes", ".", "depth", "[", ":", "n_nodes", "]", "\n", "memory_range_min", "=", "nodes", ".", "memory_range_min", "[", ":", "n_nodes", "]", "\n", "memory_range_max", "=", "nodes", ".", "memory_range_max", "[", ":", "n_nodes", "]", "\n", "n_samples", "=", "nodes", ".", "n_samples", "[", ":", "n_nodes", "]", "\n", "weight", "=", "nodes", ".", "weight", "[", ":", "n_nodes", "]", "\n", "log_weight_tree", "=", "nodes", ".", "log_weight_tree", "[", ":", "n_nodes", "]", "\n", "is_leaf", "=", "nodes", ".", "is_leaf", "[", ":", "n_nodes", "]", "\n", "# is_memorized = nodes.is_memorized[:n_nodes]", "\n", "counts", "=", "nodes", ".", "counts", "[", ":", "n_nodes", "]", "\n", "\n", "columns", "=", "[", "\n", "\"id\"", ",", "\n", "\"parent\"", ",", "\n", "\"left\"", ",", "\n", "\"right\"", ",", "\n", "\"depth\"", ",", "\n", "\"is_leaf\"", ",", "\n", "\"feature\"", ",", "\n", "\"threshold\"", ",", "\n", "\"time\"", ",", "\n", "\"n_samples\"", ",", "\n", "\"weight\"", ",", "\n", "\"log_weight_tree\"", ",", "\n", "\"memory_range_min\"", ",", "\n", "\"memory_range_max\"", ",", "\n", "\"counts\"", ",", "\n", "]", "\n", "\n", "data", "=", "{", "\n", "\"id\"", ":", "index", ",", "\n", "\"parent\"", ":", "parent", ",", "\n", "\"left\"", ":", "left", ",", "\n", "\"right\"", ":", "right", ",", "\n", "\"depth\"", ":", "depth", ",", "\n", "\"feature\"", ":", "feature", ",", "\n", "\"threshold\"", ":", "threshold", ",", "\n", "\"is_leaf\"", ":", "is_leaf", ",", "\n", "\"time\"", ":", "time", ",", "\n", "\"n_samples\"", ":", "n_samples", ",", "\n", "\"weight\"", ":", "weight", ",", "\n", "\"log_weight_tree\"", ":", "log_weight_tree", ",", "\n", "\"memory_range_min\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "memory_range_min", "]", ",", "\n", "\"memory_range_max\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "memory_range_max", "]", ",", "\n", "\"counts\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "counts", "]", ",", "\n", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "columns", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.n_features": [[856, 859], ["ValueError"], "methods", ["None"], ["", "@", "n_features", ".", "setter", "\n", "def", "n_features", "(", "self", ",", "val", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"`n_features` is a readonly attribute\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.n_estimators": [[865, 878], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "n_estimators", ".", "setter", "\n", "def", "n_estimators", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `n_estimators` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_estimators` must be of type `int`\"", ")", "\n", "", "elif", "val", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_estimators` must be >= 1\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_n_estimators", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.n_jobs": [[884, 895], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "n_jobs", ".", "setter", "\n", "def", "n_jobs", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\"You cannot modify `n_jobs` after calling `partial_fit`\"", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_jobs` must be of type `int`\"", ")", "\n", "", "elif", "val", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_jobs` must be >= 1\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_n_jobs", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.n_samples_increment": [[902, 915], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "n_samples_increment", ".", "setter", "\n", "def", "n_samples_increment", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `n_samples_increment` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_samples_increment` must be of type `int`\"", ")", "\n", "", "elif", "val", "<", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_samples_increment` must be >= 1\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_n_samples_increment", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.step": [[921, 932], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "step", ".", "setter", "\n", "def", "step", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\"You cannot modify `step` after calling `partial_fit`\"", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "float", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`step` must be of type `float`\"", ")", "\n", "", "elif", "val", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"`step` must be > 0\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_step", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.use_aggregation": [[938, 949], ["ValueError", "isinstance", "ValueError"], "methods", ["None"], ["", "@", "use_aggregation", ".", "setter", "\n", "def", "use_aggregation", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `use_aggregation` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "bool", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`use_aggregation` must be of type `bool`\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_use_aggregation", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.split_pure": [[956, 967], ["ValueError", "isinstance", "ValueError"], "methods", ["None"], ["", "@", "split_pure", ".", "setter", "\n", "def", "split_pure", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `split_pure` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "bool", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`split_pure` must be of type `bool`\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_split_pure", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.verbose": [[973, 982], ["ValueError", "isinstance", "ValueError"], "methods", ["None"], ["", "@", "verbose", ".", "setter", "\n", "def", "verbose", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\"You cannot modify `verbose` after calling `partial_fit`\"", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "bool", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`verbose` must be of type `bool`\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_verbose", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.loss": [[988, 991], ["None"], "methods", ["None"], ["", "@", "loss", ".", "setter", "\n", "def", "loss", "(", "self", ",", "val", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.random_state": [[1000, 1015], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "", "@", "random_state", ".", "setter", "\n", "def", "random_state", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `random_state` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "val", "is", "None", ":", "\n", "                ", "self", ".", "_random_state", "=", "-", "1", "\n", "", "elif", "not", "isinstance", "(", "val", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`random_state` must be of type `int`\"", ")", "\n", "", "elif", "val", "<", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"`random_state` must be >= 0\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_random_state", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.__repr__": [[1016, 1029], ["None"], "methods", ["None"], ["", "", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "r", "=", "self", ".", "__class__", ".", "__name__", "\n", "r", "+=", "\"n_estimators={n_estimators}, \"", ".", "format", "(", "n_estimators", "=", "self", ".", "n_estimators", ")", "\n", "r", "+=", "\"step={step}, \"", ".", "format", "(", "step", "=", "self", ".", "step", ")", "\n", "r", "+=", "\"loss={loss}, \"", ".", "format", "(", "loss", "=", "self", ".", "loss", ")", "\n", "r", "+=", "\"use_aggregation={use_aggregation}, \"", ".", "format", "(", "\n", "use_aggregation", "=", "self", ".", "use_aggregation", "\n", ")", "\n", "r", "+=", "\"split_pure={split_pure}, \"", ".", "format", "(", "split_pure", "=", "self", ".", "split_pure", ")", "\n", "r", "+=", "\"n_jobs={n_jobs}, \"", ".", "format", "(", "n_jobs", "=", "self", ".", "n_jobs", ")", "\n", "r", "+=", "\"random_state={random_state}, \"", ".", "format", "(", "random_state", "=", "self", ".", "random_state", ")", "\n", "r", "+=", "\"verbose={verbose})\"", ".", "format", "(", "verbose", "=", "self", ".", "verbose", ")", "\n", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.__init__": [[1068, 1156], ["forest.AMFLearner.__init__", "set", "range"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.TreeRegressor.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_classes", ",", "\n", "n_estimators", "=", "10", ",", "\n", "step", "=", "1.0", ",", "\n", "loss", "=", "\"log\"", ",", "\n", "use_aggregation", "=", "True", ",", "\n", "dirichlet", "=", "None", ",", "\n", "split_pure", "=", "False", ",", "\n", "n_jobs", "=", "1", ",", "\n", "n_samples_increment", "=", "1024", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Instantiates a `AMFClassifier` instance.\n\n        Parameters\n        ----------\n        n_classes : :obj:`int`\n            Number of expected classes in the labels. This is required since we\n            don't know the number of classes in advance in a online setting.\n\n        n_estimators : :obj:`int`, default = 10\n            The number of trees in the forest.\n\n        step : :obj:`float`, default = 1\n            Step-size for the aggregation weights. Default is 1 for classification with\n            the log-loss, which is usually the best choice.\n\n        loss : {\"log\"}, default = \"log\"\n            The loss used for the computation of the aggregation weights. Only \"log\"\n            is supported for now, namely the log-loss for multi-class\n            classification.\n\n        use_aggregation : :obj:`bool`, default = `True`\n            Controls if aggregation is used in the trees. It is highly recommended to\n            leave it as `True`.\n\n        dirichlet : :obj:`float` or :obj:`None`, default = `None`\n            Regularization level of the class frequencies used for predictions in each\n            node. Default is dirichlet=0.5 for n_classes=2 and dirichlet=0.01 otherwise.\n\n        split_pure : :obj:`bool`, default = `False`\n            Controls if nodes that contains only sample of the same class should be\n            split (\"pure\" nodes). Default is `False`, namely pure nodes are not split,\n            but `True` can be sometimes better.\n\n        n_jobs : :obj:`int`, default = 1\n            Sets the number of threads used to grow the tree in parallel. The default is\n            n_jobs=1, namely single-threaded. Fow now, this parameter has no effect and\n            only a single thread can be used.\n\n        n_samples_increment : :obj:`int`, default = 1024\n            Sets the minimum amount of memory which is pre-allocated each time extra\n            memory is required for new samples and new nodes. Decreasing it can slow\n            down training. If you know that each ``partial_fit`` will be called with\n            approximately `n` samples, you can set n_samples_increment = `n` if `n` is\n            larger than the default.\n\n        random_state : :obj:`int` or :obj:`None`, default = `None`\n            Controls the randomness involved in the trees.\n\n        verbose : :obj:`bool`, default = `False`\n            Controls the verbosity when fitting and predicting.\n        \"\"\"", "\n", "AMFLearner", ".", "__init__", "(", "\n", "self", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "step", "=", "step", ",", "\n", "loss", "=", "loss", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "n_samples_increment", "=", "n_samples_increment", ",", "\n", "random_state", "=", "random_state", ",", "\n", "verbose", "=", "verbose", ",", "\n", ")", "\n", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "if", "dirichlet", "is", "None", ":", "\n", "            ", "if", "self", ".", "n_classes", "==", "2", ":", "\n", "                ", "self", ".", "dirichlet", "=", "0.5", "\n", "", "else", ":", "\n", "                ", "self", ".", "dirichlet", "=", "0.01", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "dirichlet", "=", "dirichlet", "\n", "\n", "", "self", ".", "_classes", "=", "set", "(", "range", "(", "n_classes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._extra_y_test": [[1157, 1163], ["y.max", "y.min", "ValueError", "ValueError"], "methods", ["None"], ["", "def", "_extra_y_test", "(", "self", ",", "y", ")", ":", "\n", "        ", "if", "y", ".", "min", "(", ")", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"All the values in `y` must be non-negative\"", ")", "\n", "", "y_max", "=", "y", ".", "max", "(", ")", "\n", "if", "y_max", "not", "in", "self", ".", "_classes", ":", "\n", "            ", "raise", "ValueError", "(", "\"n_classes=%d while y.max()=%d\"", "%", "(", "self", ".", "n_classes", ",", "y_max", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._to_dict": [[1164, 1185], ["forest.amf_classifier_nopython_to_dict", "getattr"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.amf_classifier_nopython_to_dict"], ["", "", "def", "_to_dict", "(", "self", ")", ":", "\n", "        ", "attrs", "=", "[", "\n", "\"_n_features\"", ",", "\n", "\"n_classes\"", ",", "\n", "\"n_estimators\"", ",", "\n", "\"step\"", ",", "\n", "\"loss\"", ",", "\n", "\"use_aggregation\"", ",", "\n", "\"dirichlet\"", ",", "\n", "\"split_pure\"", ",", "\n", "\"n_jobs\"", ",", "\n", "\"n_samples_increment\"", ",", "\n", "\"random_state\"", ",", "\n", "\"verbose\"", ",", "\n", "\"_classes\"", ",", "\n", "]", "\n", "d", "=", "{", "}", "\n", "for", "key", "in", "attrs", ":", "\n", "            ", "d", "[", "key", "]", "=", "getattr", "(", "self", ",", "key", ")", "\n", "", "d", "[", "\"no_python\"", "]", "=", "amf_classifier_nopython_to_dict", "(", "self", ".", "no_python", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._from_dict": [[1186, 1204], ["forest.AMFClassifier", "forest.dict_to_amf_classifier_nopython"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.dict_to_amf_classifier_nopython"], ["", "@", "classmethod", "\n", "def", "_from_dict", "(", "cls", ",", "d", ")", ":", "\n", "        ", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "d", "[", "\"n_classes\"", "]", ",", "\n", "n_estimators", "=", "d", "[", "\"n_estimators\"", "]", ",", "\n", "step", "=", "d", "[", "\"step\"", "]", ",", "\n", "loss", "=", "d", "[", "\"loss\"", "]", ",", "\n", "use_aggregation", "=", "d", "[", "\"use_aggregation\"", "]", ",", "\n", "dirichlet", "=", "d", "[", "\"dirichlet\"", "]", ",", "\n", "split_pure", "=", "d", "[", "\"split_pure\"", "]", ",", "\n", "n_jobs", "=", "d", "[", "\"n_jobs\"", "]", ",", "\n", "n_samples_increment", "=", "d", "[", "\"n_samples_increment\"", "]", ",", "\n", "random_state", "=", "d", "[", "\"random_state\"", "]", ",", "\n", "verbose", "=", "d", "[", "\"verbose\"", "]", ",", "\n", ")", "\n", "amf", ".", "_n_features", "=", "d", "[", "\"_n_features\"", "]", "\n", "amf", ".", "no_python", "=", "dict_to_amf_classifier_nopython", "(", "d", "[", "\"no_python\"", "]", ")", "\n", "return", "amf", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._instantiate_nopython_class": [[1205, 1230], ["numpy.empty", "numpy.empty", "numpy.empty", "sample.SamplesCollection", "forest.AMFClassifierNoPython"], "methods", ["None"], ["", "def", "_instantiate_nopython_class", "(", "self", ")", ":", "\n", "        ", "trees_iteration", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "trees_n_nodes", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "trees_n_nodes_capacity", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "n_samples", "=", "0", "\n", "n_samples_capacity", "=", "0", "\n", "samples", "=", "SamplesCollection", "(", "\n", "self", ".", "n_samples_increment", ",", "self", ".", "n_features", ",", "n_samples", ",", "n_samples_capacity", "\n", ")", "\n", "self", ".", "no_python", "=", "AMFClassifierNoPython", "(", "\n", "self", ".", "n_classes", ",", "\n", "self", ".", "n_features", ",", "\n", "self", ".", "n_estimators", ",", "\n", "self", ".", "step", ",", "\n", "self", ".", "loss", ",", "\n", "self", ".", "use_aggregation", ",", "\n", "self", ".", "dirichlet", ",", "\n", "self", ".", "split_pure", ",", "\n", "self", ".", "n_jobs", ",", "\n", "self", ".", "n_samples_increment", ",", "\n", "self", ".", "verbose", ",", "\n", "samples", ",", "\n", "trees_iteration", ",", "\n", "trees_n_nodes", ",", "\n", "trees_n_nodes_capacity", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._partial_fit": [[1232, 1234], ["forest.forest_classifier_partial_fit"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_classifier_partial_fit"], ["", "def", "_partial_fit", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "forest_classifier_partial_fit", "(", "self", ".", "no_python", ",", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.partial_fit": [[1235, 1256], ["forest.AMFLearner.partial_fit_helper"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.partial_fit_helper"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", ",", "classes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Updates the classifier with the given batch of samples.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix.\n\n        y : :obj:`np.ndarray`\n            Input labels vector.\n\n        classes : :obj:`None`\n            Must not be used, only here for backwards compatibility\n\n        Returns\n        -------\n        output : :obj:`AMFClassifier`\n            Updated instance of :obj:`AMFClassifier`\n\n        \"\"\"", "\n", "return", "AMFLearner", ".", "partial_fit_helper", "(", "self", ",", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier._compute_predictions": [[1257, 1262], ["numpy.zeros", "forest.forest_classifier_predict_proba"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_classifier_predict_proba"], ["", "def", "_compute_predictions", "(", "self", ",", "X", ")", ":", "\n", "        ", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "scores", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", "self", ".", "n_classes", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "forest_classifier_predict_proba", "(", "self", ".", "no_python", ",", "X", ",", "scores", ")", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.predict_proba": [[1263, 1278], ["forest.AMFLearner.predict_helper"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.predict_helper"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predicts the class probabilities for the given features vectors.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix to predict for.\n\n        Returns\n        -------\n        output : :obj:`np.ndarray`, shape=(n_samples, n_classes)\n            Returns the predicted class probabilities for the input features\n\n        \"\"\"", "\n", "return", "AMFLearner", ".", "predict_helper", "(", "self", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.predict_proba_tree": [[1280, 1334], ["RuntimeError", "checks.check_array", "forest.AMFClassifier._set_random_state", "forest.forest_classifier_predict_proba_tree", "forest.AMFClassifier._put_back_random_state", "ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._set_random_state", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_classifier_predict_proba_tree", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner._put_back_random_state"], ["", "def", "predict_proba_tree", "(", "self", ",", "X", ",", "tree", ")", ":", "\n", "        ", "\"\"\"Predicts the class probabilities for the given features vectors using a\n        single tree at given index ``tree``. Should be used only for debugging or\n        visualisation purposes.\n        \n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix to predict for.\n\n        tree : :obj:`int`\n            Index of the tree, must be between 0 and ``n_estimators`` - 1\n\n        Returns\n        -------\n        output : :obj:`np.ndarray`, shape=(n_samples, n_classes)\n            Returns the predicted class probabilities for the input features\n\n        \"\"\"", "\n", "# TODO: unittests for this method", "\n", "if", "not", "self", ".", "no_python", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"You must call `partial_fit` before calling `predict_proba`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "X", "=", "check_array", "(", "\n", "X", ",", "\n", "accept_sparse", "=", "False", ",", "\n", "accept_large_sparse", "=", "False", ",", "\n", "dtype", "=", "[", "\"float32\"", "]", ",", "\n", "order", "=", "\"C\"", ",", "\n", "copy", "=", "False", ",", "\n", "force_all_finite", "=", "True", ",", "\n", "ensure_2d", "=", "True", ",", "\n", "allow_nd", "=", "False", ",", "\n", "ensure_min_samples", "=", "1", ",", "\n", "ensure_min_features", "=", "1", ",", "\n", "estimator", "=", "\"AMFClassifier\"", ",", "\n", ")", "\n", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "if", "n_features", "!=", "self", ".", "n_features", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"`partial_fit` was called with n_features=%d while `predict_proba` \"", "\n", "\"received n_features=%d\"", "%", "(", "self", ".", "n_features", ",", "n_features", ")", "\n", ")", "\n", "", "if", "not", "isinstance", "(", "tree", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`tree` must be of integer type\"", ")", "\n", "", "if", "tree", "<", "0", "or", "tree", ">=", "self", ".", "n_estimators", ":", "\n", "                ", "raise", "ValueError", "(", "\"`tree` must be between 0 and `n_estimators` - 1\"", ")", "\n", "\n", "", "self", ".", "_set_random_state", "(", ")", "\n", "scores", "=", "forest_classifier_predict_proba_tree", "(", "self", ".", "no_python", ",", "tree", ",", "X", ")", "\n", "self", ".", "_put_back_random_state", "(", ")", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.get_nodes_df": [[1343, 1403], ["pd.DataFrame", "tuple", "tuple", "tuple"], "methods", ["None"], ["", "", "def", "get_nodes_df", "(", "self", ",", "idx_tree", ")", ":", "\n", "        ", "import", "pandas", "as", "pd", "\n", "\n", "tree", "=", "self", ".", "no_python", ".", "trees", "[", "idx_tree", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "n_nodes", "=", "nodes", ".", "n_nodes", "\n", "index", "=", "nodes", ".", "index", "[", ":", "n_nodes", "]", "\n", "parent", "=", "nodes", ".", "parent", "[", ":", "n_nodes", "]", "\n", "left", "=", "nodes", ".", "left", "[", ":", "n_nodes", "]", "\n", "right", "=", "nodes", ".", "right", "[", ":", "n_nodes", "]", "\n", "feature", "=", "nodes", ".", "feature", "[", ":", "n_nodes", "]", "\n", "threshold", "=", "nodes", ".", "threshold", "[", ":", "n_nodes", "]", "\n", "time", "=", "nodes", ".", "time", "[", ":", "n_nodes", "]", "\n", "depth", "=", "nodes", ".", "depth", "[", ":", "n_nodes", "]", "\n", "memory_range_min", "=", "nodes", ".", "memory_range_min", "[", ":", "n_nodes", "]", "\n", "memory_range_max", "=", "nodes", ".", "memory_range_max", "[", ":", "n_nodes", "]", "\n", "n_samples", "=", "nodes", ".", "n_samples", "[", ":", "n_nodes", "]", "\n", "weight", "=", "nodes", ".", "weight", "[", ":", "n_nodes", "]", "\n", "log_weight_tree", "=", "nodes", ".", "log_weight_tree", "[", ":", "n_nodes", "]", "\n", "is_leaf", "=", "nodes", ".", "is_leaf", "[", ":", "n_nodes", "]", "\n", "# is_memorized = nodes.is_memorized[:n_nodes]", "\n", "counts", "=", "nodes", ".", "counts", "[", ":", "n_nodes", "]", "\n", "\n", "columns", "=", "[", "\n", "\"id\"", ",", "\n", "\"parent\"", ",", "\n", "\"left\"", ",", "\n", "\"right\"", ",", "\n", "\"depth\"", ",", "\n", "\"is_leaf\"", ",", "\n", "\"feature\"", ",", "\n", "\"threshold\"", ",", "\n", "\"time\"", ",", "\n", "\"n_samples\"", ",", "\n", "\"weight\"", ",", "\n", "\"log_weight_tree\"", ",", "\n", "\"memory_range_min\"", ",", "\n", "\"memory_range_max\"", ",", "\n", "\"counts\"", ",", "\n", "]", "\n", "\n", "data", "=", "{", "\n", "\"id\"", ":", "index", ",", "\n", "\"parent\"", ":", "parent", ",", "\n", "\"left\"", ":", "left", ",", "\n", "\"right\"", ":", "right", ",", "\n", "\"depth\"", ":", "depth", ",", "\n", "\"feature\"", ":", "feature", ",", "\n", "\"threshold\"", ":", "threshold", ",", "\n", "\"is_leaf\"", ":", "is_leaf", ",", "\n", "\"time\"", ":", "time", ",", "\n", "\"n_samples\"", ":", "n_samples", ",", "\n", "\"weight\"", ":", "weight", ",", "\n", "\"log_weight_tree\"", ":", "log_weight_tree", ",", "\n", "\"memory_range_min\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "memory_range_min", "]", ",", "\n", "\"memory_range_max\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "memory_range_max", "]", ",", "\n", "\"counts\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "counts", "]", ",", "\n", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "columns", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.n_classes": [[1409, 1422], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "n_classes", ".", "setter", "\n", "def", "n_classes", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `n_classes` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_classes` must be of type `int`\"", ")", "\n", "", "elif", "val", "<", "2", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_classes` must be >= 2\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_n_classes", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.dirichlet": [[1429, 1442], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "dirichlet", ".", "setter", "\n", "def", "dirichlet", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "no_python", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `dirichlet` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "float", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`dirichlet` must be of type `float`\"", ")", "\n", "", "elif", "val", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"`dirichlet` must be > 0\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_dirichlet", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.loss": [[1448, 1451], ["None"], "methods", ["None"], ["", "@", "loss", ".", "setter", "\n", "def", "loss", "(", "self", ",", "val", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.__repr__": [[1452, 1471], ["repr", "repr", "repr", "repr", "repr", "repr", "repr", "repr", "repr", "repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "r", "=", "\"AMFClassifier\"", "\n", "r", "+=", "\"(n_classes={n_classes}, \"", ".", "format", "(", "n_classes", "=", "repr", "(", "self", ".", "n_classes", ")", ")", "\n", "r", "+=", "\"n_estimators={n_estimators}, \"", ".", "format", "(", "\n", "n_estimators", "=", "repr", "(", "self", ".", "n_estimators", ")", "\n", ")", "\n", "r", "+=", "\"step={step}, \"", ".", "format", "(", "step", "=", "repr", "(", "self", ".", "step", ")", ")", "\n", "r", "+=", "\"loss={loss}, \"", ".", "format", "(", "loss", "=", "repr", "(", "self", ".", "loss", ")", ")", "\n", "r", "+=", "\"use_aggregation={use_aggregation}, \"", ".", "format", "(", "\n", "use_aggregation", "=", "repr", "(", "self", ".", "use_aggregation", ")", "\n", ")", "\n", "r", "+=", "\"dirichlet={dirichlet}, \"", ".", "format", "(", "dirichlet", "=", "repr", "(", "self", ".", "dirichlet", ")", ")", "\n", "r", "+=", "\"split_pure={split_pure}, \"", ".", "format", "(", "split_pure", "=", "repr", "(", "self", ".", "split_pure", ")", ")", "\n", "r", "+=", "\"n_jobs={n_jobs}, \"", ".", "format", "(", "n_jobs", "=", "repr", "(", "self", ".", "n_jobs", ")", ")", "\n", "r", "+=", "\"random_state={random_state}, \"", ".", "format", "(", "\n", "random_state", "=", "repr", "(", "self", ".", "random_state", ")", "\n", ")", "\n", "r", "+=", "\"verbose={verbose})\"", ".", "format", "(", "verbose", "=", "repr", "(", "self", ".", "verbose", ")", ")", "\n", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.__init__": [[1501, 1566], ["forest.AMFLearner.__init__"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.TreeRegressor.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_estimators", "=", "10", ",", "\n", "step", "=", "1.0", ",", "\n", "loss", "=", "\"least-squares\"", ",", "\n", "use_aggregation", "=", "True", ",", "\n", "split_pure", "=", "False", ",", "\n", "n_jobs", "=", "1", ",", "\n", "n_samples_increment", "=", "1024", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Instantiates a `AMFRegressor` instance.\n\n        Parameters\n        ----------\n        n_estimators : :obj:`int`, default = 10\n            The number of trees in the forest.\n\n        step : :obj:`float`, default = 1\n            Step-size for the aggregation weights. Default is ??? for regression with\n            the least-squares loss.\n\n        loss : {\"least-squares\"}, default = \"least-squares\"\n            The loss used for the computation of the aggregation weights. Only\n            \"least-squares\" is supported for now.\n\n        use_aggregation : :obj:`bool`, default = `True`\n            Controls if aggregation is used in the trees. It is highly recommended to\n            leave it as `True`.\n\n        split_pure : :obj:`bool`, default = `False`\n            Controls if nodes that contains only sample of the same class should be\n            split (\"pure\" nodes). Default is `False`, namely pure nodes are not split,\n            but `True` can be sometimes better.\n\n        n_jobs : :obj:`int`, default = 1\n            Sets the number of threads used to grow the tree in parallel. The default is\n            n_jobs=1, namely single-threaded. Fow now, this parameter has no effect and\n            only a single thread can be used.\n\n        n_samples_increment : :obj:`int`, default = 1024\n            Sets the minimum amount of memory which is pre-allocated each time extra\n            memory is required for new samples and new nodes. Decreasing it can slow\n            down training. If you know that each ``partial_fit`` will be called with\n            approximately `n` samples, you can set n_samples_increment = `n` if `n` is\n            larger than the default.\n\n        random_state : :obj:`int` or :obj:`None`, default = `None`\n            Controls the randomness involved in the trees.\n\n        verbose : :obj:`bool`, default = `False`\n            Controls the verbosity when fitting and predicting.\n        \"\"\"", "\n", "AMFLearner", ".", "__init__", "(", "\n", "self", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "step", "=", "step", ",", "\n", "loss", "=", "loss", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "n_samples_increment", "=", "n_samples_increment", ",", "\n", "random_state", "=", "random_state", ",", "\n", "verbose", "=", "verbose", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._instantiate_nopython_class": [[1568, 1591], ["numpy.empty", "numpy.empty", "numpy.empty", "sample.SamplesCollection", "forest.AMFRegressorNoPython"], "methods", ["None"], ["", "def", "_instantiate_nopython_class", "(", "self", ")", ":", "\n", "        ", "trees_iteration", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "trees_n_nodes", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "trees_n_nodes_capacity", "=", "np", ".", "empty", "(", "0", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "n_samples", "=", "0", "\n", "n_samples_capacity", "=", "0", "\n", "samples", "=", "SamplesCollection", "(", "\n", "self", ".", "n_samples_increment", ",", "self", ".", "n_features", ",", "n_samples", ",", "n_samples_capacity", "\n", ")", "\n", "self", ".", "no_python", "=", "AMFRegressorNoPython", "(", "\n", "self", ".", "n_features", ",", "\n", "self", ".", "n_estimators", ",", "\n", "self", ".", "step", ",", "\n", "self", ".", "loss", ",", "\n", "self", ".", "use_aggregation", ",", "\n", "self", ".", "split_pure", ",", "\n", "self", ".", "n_jobs", ",", "\n", "self", ".", "n_samples_increment", ",", "\n", "self", ".", "verbose", ",", "\n", "samples", ",", "\n", "trees_iteration", ",", "\n", "trees_n_nodes", ",", "\n", "trees_n_nodes_capacity", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._to_dict": [[1593, 1611], ["forest.amf_regressor_nopython_to_dict", "getattr"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.amf_regressor_nopython_to_dict"], ["", "def", "_to_dict", "(", "self", ")", ":", "\n", "        ", "attrs", "=", "[", "\n", "\"_n_features\"", ",", "\n", "\"n_estimators\"", ",", "\n", "\"step\"", ",", "\n", "\"loss\"", ",", "\n", "\"use_aggregation\"", ",", "\n", "\"split_pure\"", ",", "\n", "\"n_jobs\"", ",", "\n", "\"n_samples_increment\"", ",", "\n", "\"random_state\"", ",", "\n", "\"verbose\"", ",", "\n", "]", "\n", "d", "=", "{", "}", "\n", "for", "key", "in", "attrs", ":", "\n", "            ", "d", "[", "key", "]", "=", "getattr", "(", "self", ",", "key", ")", "\n", "", "d", "[", "\"no_python\"", "]", "=", "amf_regressor_nopython_to_dict", "(", "self", ".", "no_python", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._from_dict": [[1612, 1628], ["forest.AMFRegressor", "forest.dict_to_amf_regressor_nopython"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.dict_to_amf_regressor_nopython"], ["", "@", "classmethod", "\n", "def", "_from_dict", "(", "cls", ",", "d", ")", ":", "\n", "        ", "amf", "=", "AMFRegressor", "(", "\n", "n_estimators", "=", "d", "[", "\"n_estimators\"", "]", ",", "\n", "step", "=", "d", "[", "\"step\"", "]", ",", "\n", "loss", "=", "d", "[", "\"loss\"", "]", ",", "\n", "use_aggregation", "=", "d", "[", "\"use_aggregation\"", "]", ",", "\n", "split_pure", "=", "d", "[", "\"split_pure\"", "]", ",", "\n", "n_jobs", "=", "d", "[", "\"n_jobs\"", "]", ",", "\n", "n_samples_increment", "=", "d", "[", "\"n_samples_increment\"", "]", ",", "\n", "random_state", "=", "d", "[", "\"random_state\"", "]", ",", "\n", "verbose", "=", "d", "[", "\"verbose\"", "]", ",", "\n", ")", "\n", "amf", ".", "_n_features", "=", "d", "[", "\"_n_features\"", "]", "\n", "amf", ".", "no_python", "=", "dict_to_amf_regressor_nopython", "(", "d", "[", "\"no_python\"", "]", ")", "\n", "return", "amf", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._partial_fit": [[1629, 1631], ["forest.forest_regressor_partial_fit"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_regressor_partial_fit"], ["", "def", "_partial_fit", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "forest_regressor_partial_fit", "(", "self", ".", "no_python", ",", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.partial_fit": [[1632, 1653], ["forest.AMFLearner.partial_fit_helper"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.partial_fit_helper"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", ",", "classes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Updates the classifier with the given batch of samples.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix.\n\n        y : :obj:`np.ndarray`\n            Input labels vector.\n\n        classes : :obj:`None`\n            Must not be used, only here for backwards compatibility\n\n        Returns\n        -------\n        output : :obj:`AMFRegressor`\n            Updated instance of :obj:`AMFRegressor`\n\n        \"\"\"", "\n", "AMFLearner", ".", "partial_fit_helper", "(", "self", ",", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._compute_predictions": [[1654, 1659], ["numpy.zeros", "forest.forest_regressor_predict"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_regressor_predict"], ["", "def", "_compute_predictions", "(", "self", ",", "X", ")", ":", "\n", "        ", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "predictions", "=", "np", ".", "zeros", "(", "n_samples", ",", "dtype", "=", "\"float32\"", ")", "\n", "forest_regressor_predict", "(", "self", ".", "no_python", ",", "X", ",", "predictions", ")", "\n", "return", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor._compute_weighted_depths": [[1660, 1665], ["numpy.zeros", "forest.forest_regressor_weighted_depths"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_regressor_weighted_depths"], ["", "def", "_compute_weighted_depths", "(", "self", ",", "X", ")", ":", "\n", "        ", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "weighted_depths", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", "self", ".", "n_estimators", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "forest_regressor_weighted_depths", "(", "self", ".", "no_python", ",", "X", ",", "weighted_depths", ")", "\n", "return", "weighted_depths", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.predict": [[1666, 1681], ["forest.AMFLearner.predict_helper"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.predict_helper"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predicts the labels for the given features vectors.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n            Input features matrix to predict for.\n\n        Returns\n        -------\n        output : :obj:`np.ndarray`, shape=(n_samples,)\n            Returns the predicted labels for the input features\n\n        \"\"\"", "\n", "return", "AMFLearner", ".", "predict_helper", "(", "self", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.weighted_depth": [[1682, 1684], ["forest.AMFLearner.weighted_depth_helper"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.weighted_depth_helper"], ["", "def", "weighted_depth", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "AMFLearner", ".", "weighted_depth_helper", "(", "self", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.get_nodes_df": [[1685, 1745], ["pd.DataFrame", "tuple", "tuple", "tuple"], "methods", ["None"], ["", "def", "get_nodes_df", "(", "self", ",", "idx_tree", ")", ":", "\n", "        ", "import", "pandas", "as", "pd", "\n", "\n", "tree", "=", "self", ".", "no_python", ".", "trees", "[", "idx_tree", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "n_nodes", "=", "nodes", ".", "n_nodes", "\n", "index", "=", "nodes", ".", "index", "[", ":", "n_nodes", "]", "\n", "parent", "=", "nodes", ".", "parent", "[", ":", "n_nodes", "]", "\n", "left", "=", "nodes", ".", "left", "[", ":", "n_nodes", "]", "\n", "right", "=", "nodes", ".", "right", "[", ":", "n_nodes", "]", "\n", "feature", "=", "nodes", ".", "feature", "[", ":", "n_nodes", "]", "\n", "threshold", "=", "nodes", ".", "threshold", "[", ":", "n_nodes", "]", "\n", "time", "=", "nodes", ".", "time", "[", ":", "n_nodes", "]", "\n", "depth", "=", "nodes", ".", "depth", "[", ":", "n_nodes", "]", "\n", "memory_range_min", "=", "nodes", ".", "memory_range_min", "[", ":", "n_nodes", "]", "\n", "memory_range_max", "=", "nodes", ".", "memory_range_max", "[", ":", "n_nodes", "]", "\n", "n_samples", "=", "nodes", ".", "n_samples", "[", ":", "n_nodes", "]", "\n", "weight", "=", "nodes", ".", "weight", "[", ":", "n_nodes", "]", "\n", "log_weight_tree", "=", "nodes", ".", "log_weight_tree", "[", ":", "n_nodes", "]", "\n", "is_leaf", "=", "nodes", ".", "is_leaf", "[", ":", "n_nodes", "]", "\n", "# is_memorized = nodes.is_memorized[:n_nodes]", "\n", "counts", "=", "nodes", ".", "counts", "[", ":", "n_nodes", "]", "\n", "\n", "columns", "=", "[", "\n", "\"id\"", ",", "\n", "\"parent\"", ",", "\n", "\"left\"", ",", "\n", "\"right\"", ",", "\n", "\"depth\"", ",", "\n", "\"is_leaf\"", ",", "\n", "\"feature\"", ",", "\n", "\"threshold\"", ",", "\n", "\"time\"", ",", "\n", "\"n_samples\"", ",", "\n", "\"weight\"", ",", "\n", "\"log_weight_tree\"", ",", "\n", "\"memory_range_min\"", ",", "\n", "\"memory_range_max\"", ",", "\n", "\"counts\"", ",", "\n", "]", "\n", "\n", "data", "=", "{", "\n", "\"id\"", ":", "index", ",", "\n", "\"parent\"", ":", "parent", ",", "\n", "\"left\"", ":", "left", ",", "\n", "\"right\"", ":", "right", ",", "\n", "\"depth\"", ":", "depth", ",", "\n", "\"feature\"", ":", "feature", ",", "\n", "\"threshold\"", ":", "threshold", ",", "\n", "\"is_leaf\"", ":", "is_leaf", ",", "\n", "\"time\"", ":", "time", ",", "\n", "\"n_samples\"", ":", "n_samples", ",", "\n", "\"weight\"", ":", "weight", ",", "\n", "\"log_weight_tree\"", ":", "log_weight_tree", ",", "\n", "\"memory_range_min\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "memory_range_min", "]", ",", "\n", "\"memory_range_max\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "memory_range_max", "]", ",", "\n", "\"counts\"", ":", "[", "tuple", "(", "t", ")", "for", "t", "in", "counts", "]", ",", "\n", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "data", ",", "columns", "=", "columns", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.loss": [[1751, 1754], ["None"], "methods", ["None"], ["", "@", "loss", ".", "setter", "\n", "def", "loss", "(", "self", ",", "val", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.__repr__": [[1755, 1772], ["repr", "repr", "repr", "repr", "repr", "repr", "repr", "repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "r", "=", "\"AMFRegressor(\"", "\n", "r", "+=", "\"n_estimators={n_estimators}, \"", ".", "format", "(", "\n", "n_estimators", "=", "repr", "(", "self", ".", "n_estimators", ")", "\n", ")", "\n", "r", "+=", "\"step={step}, \"", ".", "format", "(", "step", "=", "repr", "(", "self", ".", "step", ")", ")", "\n", "r", "+=", "\"loss={loss}, \"", ".", "format", "(", "loss", "=", "repr", "(", "self", ".", "loss", ")", ")", "\n", "r", "+=", "\"use_aggregation={use_aggregation}, \"", ".", "format", "(", "\n", "use_aggregation", "=", "repr", "(", "self", ".", "use_aggregation", ")", "\n", ")", "\n", "r", "+=", "\"split_pure={split_pure}, \"", ".", "format", "(", "split_pure", "=", "repr", "(", "self", ".", "split_pure", ")", ")", "\n", "r", "+=", "\"n_jobs={n_jobs}, \"", ".", "format", "(", "n_jobs", "=", "repr", "(", "self", ".", "n_jobs", ")", ")", "\n", "r", "+=", "\"random_state={random_state}, \"", ".", "format", "(", "\n", "random_state", "=", "repr", "(", "self", ".", "random_state", ")", "\n", ")", "\n", "r", "+=", "\"verbose={verbose})\"", ".", "format", "(", "verbose", "=", "repr", "(", "self", ".", "verbose", ")", ")", "\n", "return", "r", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_classifier_partial_fit": [[132, 144], ["numba.njit", "sample.add_samples", "range", "types.void", "utils.get_type", "types.get_array_2d_type", "tree_methods.tree_classifier_partial_fit"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_partial_fit"], ["", "", "", "@", "njit", "(", "void", "(", "get_type", "(", "AMFClassifierNoPython", ")", ",", "get_array_2d_type", "(", "float32", ")", ",", "float32", "[", ":", ":", "1", "]", ",", ")", ")", "\n", "def", "forest_classifier_partial_fit", "(", "forest", ",", "X", ",", "y", ")", ":", "\n", "    ", "n_samples_batch", ",", "n_features", "=", "X", ".", "shape", "\n", "# First, we save the new batch of data", "\n", "n_samples_before", "=", "forest", ".", "samples", ".", "n_samples", "\n", "# Add the samples in the forest", "\n", "add_samples", "(", "forest", ".", "samples", ",", "X", ",", "y", ")", "\n", "for", "i", "in", "range", "(", "n_samples_before", ",", "n_samples_before", "+", "n_samples_batch", ")", ":", "\n", "# Then we fit all the trees using all new samples", "\n", "        ", "for", "tree", "in", "forest", ".", "trees", ":", "\n", "            ", "tree_classifier_partial_fit", "(", "tree", ",", "i", ")", "\n", "", "forest", ".", "iteration", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_classifier_predict_proba": [[168, 189], ["numba.njit", "scores.fill", "numpy.empty", "range", "types.void", "utils.get_type", "types.get_array_2d_type", "types.get_array_2d_type", "tree_methods.tree_classifier_predict"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_predict"], ["", "", "@", "njit", "(", "\n", "void", "(", "\n", "get_type", "(", "AMFClassifierNoPython", ")", ",", "\n", "get_array_2d_type", "(", "float32", ")", ",", "\n", "get_array_2d_type", "(", "float32", ")", ",", "\n", ")", "\n", ")", "\n", "def", "forest_classifier_predict_proba", "(", "forest", ",", "X", ",", "scores", ")", ":", "\n", "# TODO: use predict_proba_tree from below ? Or put it in the tree ?", "\n", "    ", "scores", ".", "fill", "(", "0.0", ")", "\n", "n_samples_batch", ",", "_", "=", "X", ".", "shape", "\n", "\n", "scores_tree", "=", "np", ".", "empty", "(", "forest", ".", "n_classes", ",", "float32", ")", "\n", "for", "i", "in", "range", "(", "n_samples_batch", ")", ":", "\n", "        ", "scores_i", "=", "scores", "[", "i", "]", "\n", "x_i", "=", "X", "[", "i", "]", "\n", "# The prediction is simply the average of the predictions", "\n", "for", "tree", "in", "forest", ".", "trees", ":", "\n", "            ", "tree_classifier_predict", "(", "tree", ",", "x_i", ",", "scores_tree", ",", "forest", ".", "use_aggregation", ")", "\n", "scores_i", "+=", "scores_tree", "\n", "", "scores_i", "/=", "forest", ".", "n_estimators", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_classifier_predict_proba_tree": [[491, 505], ["numba.njit", "numpy.empty", "range", "tree_methods.tree_classifier_predict", "types.get_array_2d_type", "utils.get_type", "types.get_array_2d_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type"], ["", "", "", "@", "njit", "(", "\n", "get_array_2d_type", "(", "float32", ")", "(", "\n", "get_type", "(", "AMFClassifierNoPython", ")", ",", "uint32", ",", "get_array_2d_type", "(", "float32", ")", "\n", ")", "\n", ")", "\n", "def", "forest_classifier_predict_proba_tree", "(", "forest", ",", "idx_tree", ",", "X", ")", ":", "\n", "    ", "n_samples_batch", ",", "_", "=", "X", ".", "shape", "\n", "scores", "=", "np", ".", "empty", "(", "(", "n_samples_batch", ",", "forest", ".", "n_classes", ")", ",", "dtype", "=", "float32", ")", "\n", "tree", "=", "forest", ".", "trees", "[", "idx_tree", "]", "\n", "for", "i", "in", "range", "(", "n_samples_batch", ")", ":", "\n", "        ", "scores_i", "=", "scores", "[", "i", "]", "\n", "x_i", "=", "X", "[", "i", "]", "\n", "tree_classifier_predict", "(", "tree", ",", "x_i", ",", "scores_i", ",", "forest", ".", "use_aggregation", ")", "\n", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.amf_classifier_nopython_to_dict": [[207, 217], ["sample.samples_collection_to_dict", "getattr", "tree.tree_classifier_to_dict"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.samples_collection_to_dict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.tree_classifier_to_dict"], ["", "def", "amf_classifier_nopython_to_dict", "(", "forest", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "_", "in", "spec_amf_classifier", ":", "\n", "        ", "if", "key", "==", "\"samples\"", ":", "\n", "            ", "d", "[", "\"samples\"", "]", "=", "samples_collection_to_dict", "(", "forest", ".", "samples", ")", "\n", "", "elif", "key", "==", "\"trees\"", ":", "\n", "            ", "d", "[", "\"trees\"", "]", "=", "[", "tree_classifier_to_dict", "(", "tree", ")", "for", "tree", "in", "forest", ".", "trees", "]", "\n", "", "else", ":", "\n", "            ", "d", "[", "key", "]", "=", "getattr", "(", "forest", ",", "key", ")", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.dict_to_amf_classifier_nopython": [[219, 278], ["sample.dict_to_samples_collection", "numpy.array", "numpy.array", "numpy.array", "forest.AMFClassifierNoPython", "range", "node_collection.dict_to_nodes_classifier"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.dict_to_samples_collection", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes_classifier"], ["", "def", "dict_to_amf_classifier_nopython", "(", "d", ")", ":", "\n", "    ", "n_classes", "=", "d", "[", "\"n_classes\"", "]", "\n", "n_features", "=", "d", "[", "\"n_features\"", "]", "\n", "n_estimators", "=", "d", "[", "\"n_estimators\"", "]", "\n", "step", "=", "d", "[", "\"step\"", "]", "\n", "loss", "=", "d", "[", "\"loss\"", "]", "\n", "use_aggregation", "=", "d", "[", "\"use_aggregation\"", "]", "\n", "dirichlet", "=", "d", "[", "\"dirichlet\"", "]", "\n", "split_pure", "=", "d", "[", "\"split_pure\"", "]", "\n", "n_jobs", "=", "d", "[", "\"n_jobs\"", "]", "\n", "n_samples_increment", "=", "d", "[", "\"n_samples_increment\"", "]", "\n", "verbose", "=", "d", "[", "\"verbose\"", "]", "\n", "# Create the samples jitclass from a dict", "\n", "samples", "=", "dict_to_samples_collection", "(", "d", "[", "\"samples\"", "]", ")", "\n", "\n", "trees_dict", "=", "d", "[", "\"trees\"", "]", "\n", "trees_iteration", "=", "np", ".", "array", "(", "\n", "[", "tree_dict", "[", "\"iteration\"", "]", "for", "tree_dict", "in", "trees_dict", "]", ",", "dtype", "=", "np", ".", "uint32", "\n", ")", "\n", "trees_n_nodes", "=", "np", ".", "array", "(", "\n", "[", "tree_dict", "[", "\"nodes\"", "]", "[", "\"n_nodes\"", "]", "for", "tree_dict", "in", "trees_dict", "]", ",", "dtype", "=", "np", ".", "uint32", "\n", ")", "\n", "trees_n_nodes_capacity", "=", "np", ".", "array", "(", "\n", "[", "tree_dict", "[", "\"nodes\"", "]", "[", "\"n_nodes_capacity\"", "]", "for", "tree_dict", "in", "trees_dict", "]", ",", "\n", "dtype", "=", "np", ".", "uint32", ",", "\n", ")", "\n", "no_python", "=", "AMFClassifierNoPython", "(", "\n", "n_classes", ",", "\n", "n_features", ",", "\n", "n_estimators", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "dirichlet", ",", "\n", "split_pure", ",", "\n", "n_jobs", ",", "\n", "n_samples_increment", ",", "\n", "verbose", ",", "\n", "samples", ",", "\n", "trees_iteration", ",", "\n", "trees_n_nodes", ",", "\n", "trees_n_nodes_capacity", ",", "\n", ")", "\n", "no_python", ".", "iteration", "=", "d", "[", "\"iteration\"", "]", "\n", "no_python", ".", "samples", "=", "samples", "\n", "trees", "=", "no_python", ".", "trees", "\n", "\n", "# no_python is initialized, it remains to initialize the nodes", "\n", "for", "n_estimator", "in", "range", "(", "n_estimators", ")", ":", "\n", "        ", "tree_dict", "=", "trees_dict", "[", "n_estimator", "]", "\n", "nodes_dict", "=", "tree_dict", "[", "\"nodes\"", "]", "\n", "tree", "=", "trees", "[", "n_estimator", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "# Copy node information", "\n", "dict_to_nodes_classifier", "(", "nodes", ",", "nodes_dict", ")", "\n", "# Copy intensities", "\n", "tree", ".", "intensities", "[", ":", "]", "=", "tree_dict", "[", "\"intensities\"", "]", "\n", "\n", "", "return", "no_python", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_regressor_partial_fit": [[352, 364], ["numba.njit", "sample.add_samples", "range", "types.void", "utils.get_type", "types.get_array_2d_type", "tree_methods.tree_regressor_partial_fit"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_partial_fit"], ["", "", "", "@", "njit", "(", "void", "(", "get_type", "(", "AMFRegressorNoPython", ")", ",", "get_array_2d_type", "(", "float32", ")", ",", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "forest_regressor_partial_fit", "(", "forest", ",", "X", ",", "y", ")", ":", "\n", "    ", "n_samples_batch", ",", "n_features", "=", "X", ".", "shape", "\n", "# First, we save the new batch of data", "\n", "n_samples_before", "=", "forest", ".", "samples", ".", "n_samples", "\n", "# Add the samples in the forest", "\n", "add_samples", "(", "forest", ".", "samples", ",", "X", ",", "y", ")", "\n", "for", "i", "in", "range", "(", "n_samples_before", ",", "n_samples_before", "+", "n_samples_batch", ")", ":", "\n", "# Then we fit all the trees using all new samples", "\n", "        ", "for", "tree", "in", "forest", ".", "trees", ":", "\n", "            ", "tree_regressor_partial_fit", "(", "tree", ",", "i", ")", "\n", "", "forest", ".", "iteration", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_regressor_predict": [[388, 400], ["numba.njit", "predictions.fill", "range", "types.void", "utils.get_type", "types.get_array_2d_type", "tree_methods.tree_regressor_predict"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_predict"], ["", "", "@", "njit", "(", "void", "(", "get_type", "(", "AMFRegressorNoPython", ")", ",", "get_array_2d_type", "(", "float32", ")", ",", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "forest_regressor_predict", "(", "forest", ",", "X", ",", "predictions", ")", ":", "\n", "# TODO: Useless ?", "\n", "    ", "predictions", ".", "fill", "(", "0.0", ")", "\n", "n_samples_batch", ",", "_", "=", "X", ".", "shape", "\n", "for", "i", "in", "range", "(", "n_samples_batch", ")", ":", "\n", "        ", "x_i", "=", "X", "[", "i", "]", "\n", "prediction", "=", "0", "\n", "# The prediction is simply the average of the predictions", "\n", "for", "tree", "in", "forest", ".", "trees", ":", "\n", "            ", "prediction", "+=", "tree_regressor_predict", "(", "tree", ",", "x_i", ",", "forest", ".", "use_aggregation", ")", "\n", "", "predictions", "[", "i", "]", "=", "prediction", "/", "forest", ".", "n_estimators", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.amf_regressor_nopython_to_dict": [[402, 412], ["sample.samples_collection_to_dict", "getattr", "tree.tree_regressor_to_dict"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.samples_collection_to_dict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.tree_regressor_to_dict"], ["", "", "def", "amf_regressor_nopython_to_dict", "(", "forest", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "_", "in", "spec_amf_regressor", ":", "\n", "        ", "if", "key", "==", "\"samples\"", ":", "\n", "            ", "d", "[", "\"samples\"", "]", "=", "samples_collection_to_dict", "(", "forest", ".", "samples", ")", "\n", "", "elif", "key", "==", "\"trees\"", ":", "\n", "            ", "d", "[", "\"trees\"", "]", "=", "[", "tree_regressor_to_dict", "(", "tree", ")", "for", "tree", "in", "forest", ".", "trees", "]", "\n", "", "else", ":", "\n", "            ", "d", "[", "key", "]", "=", "getattr", "(", "forest", ",", "key", ")", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.dict_to_amf_regressor_nopython": [[414, 469], ["sample.dict_to_samples_collection", "numpy.array", "numpy.array", "numpy.array", "forest.AMFRegressorNoPython", "range", "node_collection.dict_to_nodes_regressor"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.dict_to_samples_collection", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes_regressor"], ["", "def", "dict_to_amf_regressor_nopython", "(", "d", ")", ":", "\n", "    ", "n_features", "=", "d", "[", "\"n_features\"", "]", "\n", "n_estimators", "=", "d", "[", "\"n_estimators\"", "]", "\n", "step", "=", "d", "[", "\"step\"", "]", "\n", "loss", "=", "d", "[", "\"loss\"", "]", "\n", "use_aggregation", "=", "d", "[", "\"use_aggregation\"", "]", "\n", "split_pure", "=", "d", "[", "\"split_pure\"", "]", "\n", "n_jobs", "=", "d", "[", "\"n_jobs\"", "]", "\n", "n_samples_increment", "=", "d", "[", "\"n_samples_increment\"", "]", "\n", "verbose", "=", "d", "[", "\"verbose\"", "]", "\n", "# Create the samples jitclass from a dict", "\n", "samples", "=", "dict_to_samples_collection", "(", "d", "[", "\"samples\"", "]", ")", "\n", "\n", "trees_dict", "=", "d", "[", "\"trees\"", "]", "\n", "trees_iteration", "=", "np", ".", "array", "(", "\n", "[", "tree_dict", "[", "\"iteration\"", "]", "for", "tree_dict", "in", "trees_dict", "]", ",", "dtype", "=", "np", ".", "uint32", "\n", ")", "\n", "trees_n_nodes", "=", "np", ".", "array", "(", "\n", "[", "tree_dict", "[", "\"nodes\"", "]", "[", "\"n_nodes\"", "]", "for", "tree_dict", "in", "trees_dict", "]", ",", "dtype", "=", "np", ".", "uint32", "\n", ")", "\n", "trees_n_nodes_capacity", "=", "np", ".", "array", "(", "\n", "[", "tree_dict", "[", "\"nodes\"", "]", "[", "\"n_nodes_capacity\"", "]", "for", "tree_dict", "in", "trees_dict", "]", ",", "\n", "dtype", "=", "np", ".", "uint32", ",", "\n", ")", "\n", "no_python", "=", "AMFRegressorNoPython", "(", "\n", "n_features", ",", "\n", "n_estimators", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "split_pure", ",", "\n", "n_jobs", ",", "\n", "n_samples_increment", ",", "\n", "verbose", ",", "\n", "samples", ",", "\n", "trees_iteration", ",", "\n", "trees_n_nodes", ",", "\n", "trees_n_nodes_capacity", ",", "\n", ")", "\n", "no_python", ".", "iteration", "=", "d", "[", "\"iteration\"", "]", "\n", "no_python", ".", "samples", "=", "samples", "\n", "trees", "=", "no_python", ".", "trees", "\n", "\n", "# no_python is initialized, it remains to initialize the nodes", "\n", "for", "n_estimator", "in", "range", "(", "n_estimators", ")", ":", "\n", "        ", "tree_dict", "=", "trees_dict", "[", "n_estimator", "]", "\n", "nodes_dict", "=", "tree_dict", "[", "\"nodes\"", "]", "\n", "tree", "=", "trees", "[", "n_estimator", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "# Copy node information", "\n", "dict_to_nodes_regressor", "(", "nodes", ",", "nodes_dict", ")", "\n", "# Copy intensities", "\n", "tree", ".", "intensities", "[", ":", "]", "=", "tree_dict", "[", "\"intensities\"", "]", "\n", "\n", "", "return", "no_python", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.forest_regressor_weighted_depths": [[471, 489], ["numba.njit", "range", "types.void", "utils.get_type", "types.get_array_2d_type", "types.get_array_2d_type", "tree_methods.tree_regressor_weighted_depth"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_weighted_depth"], ["", "@", "njit", "(", "\n", "void", "(", "\n", "get_type", "(", "AMFRegressorNoPython", ")", ",", "\n", "get_array_2d_type", "(", "float32", ")", ",", "\n", "get_array_2d_type", "(", "float32", ")", ",", "\n", ")", "\n", ")", "\n", "def", "forest_regressor_weighted_depths", "(", "forest", ",", "X", ",", "weighted_depths", ")", ":", "\n", "    ", "n_samples_batch", ",", "_", "=", "X", ".", "shape", "\n", "for", "i", "in", "range", "(", "n_samples_batch", ")", ":", "\n", "        ", "x_i", "=", "X", "[", "i", "]", "\n", "n_tree", "=", "0", "\n", "for", "tree", "in", "forest", ".", "trees", ":", "\n", "            ", "weighted_depth", "=", "tree_regressor_weighted_depth", "(", "\n", "tree", ",", "x_i", ",", "forest", ".", "use_aggregation", "\n", ")", "\n", "weighted_depths", "[", "i", ",", "n_tree", "]", "=", "weighted_depth", "\n", "n_tree", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.SamplesCollection.__init__": [[44, 68], ["numpy.empty", "numpy.empty", "numpy.empty", "numpy.empty"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "n_samples_increment", ",", "n_features", ",", "n_samples", ",", "n_samples_capacity", ")", ":", "\n", "        ", "\"\"\"Instantiates a `SamplesCollection` instance.\n\n        Parameters\n        ----------\n        n_samples_increment : :obj:`int`\n            Sets the amount of memory which is pre-allocated each time extra memory is\n            required for new samples.\n\n        n_features : :obj:`int`\n            Number of features used during training.\n        \"\"\"", "\n", "if", "n_samples", "==", "0", ":", "\n", "            ", "self", ".", "n_samples_increment", "=", "n_samples_increment", "\n", "self", ".", "n_samples_capacity", "=", "n_samples_increment", "\n", "self", ".", "features", "=", "np", ".", "empty", "(", "(", "n_samples_increment", ",", "n_features", ")", ",", "dtype", "=", "float32", ")", "\n", "self", ".", "labels", "=", "np", ".", "empty", "(", "n_samples_increment", ",", "dtype", "=", "float32", ")", "\n", "self", ".", "n_samples", "=", "0", "\n", "", "else", ":", "\n", "            ", "self", ".", "n_samples_increment", "=", "n_samples_increment", "\n", "self", ".", "n_samples_capacity", "=", "n_samples_capacity", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "self", ".", "features", "=", "np", ".", "empty", "(", "(", "n_samples_capacity", ",", "n_features", ")", ",", "dtype", "=", "float32", ")", "\n", "self", ".", "labels", "=", "np", ".", "empty", "(", "n_samples_capacity", ",", "dtype", "=", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples": [[70, 111], ["numba.njit", "types.void", "utils.resize_array", "utils.resize_array", "utils.get_type", "types.get_array_2d_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type"], ["", "", "", "@", "njit", "(", "void", "(", "get_type", "(", "SamplesCollection", ")", ",", "get_array_2d_type", "(", "float32", ")", ",", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "add_samples", "(", "samples", ",", "X", ",", "y", ")", ":", "\n", "    ", "\"\"\"Adds the features `X` and labels `y` to the collection of samples `samples`\n\n    Parameters\n    ----------\n    samples : :obj:`SamplesCollection`\n        The collection of samples where we want to append X and y\n\n    X : :obj:`np.ndarray`, shape=(n_samples, n_features)\n        Input features matrix to be appended\n\n    y : :obj:`np.ndarray`\n        Input labels vector to be appended\n\n    \"\"\"", "\n", "n_new_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "n_current_samples", "=", "samples", ".", "n_samples", "\n", "n_samples_required", "=", "n_current_samples", "+", "n_new_samples", "\n", "capacity_missing", "=", "n_samples_required", "-", "samples", ".", "n_samples_capacity", "\n", "if", "capacity_missing", ">=", "0", ":", "\n", "# We don't have enough room. Increase the memory reserved.", "\n", "        ", "if", "capacity_missing", ">", "samples", ".", "n_samples_increment", ":", "\n", "# If what's required is larger than the increment, we use what's missing", "\n", "# plus de minimum increment", "\n", "            ", "increment", "=", "capacity_missing", "+", "samples", ".", "n_samples_increment", "\n", "", "else", ":", "\n", "            ", "increment", "=", "samples", ".", "n_samples_increment", "\n", "\n", "", "n_samples_reserved", "=", "samples", ".", "n_samples_capacity", "+", "increment", "\n", "samples", ".", "features", "=", "resize_array", "(", "\n", "samples", ".", "features", ",", "n_current_samples", ",", "n_samples_reserved", "\n", ")", "\n", "samples", ".", "labels", "=", "resize_array", "(", "\n", "samples", ".", "labels", ",", "n_current_samples", ",", "n_samples_reserved", "\n", ")", "\n", "samples", ".", "n_samples_capacity", "+=", "increment", "\n", "\n", "", "samples", ".", "features", "[", "n_current_samples", ":", "n_samples_required", "]", "=", "X", "\n", "samples", ".", "labels", "[", "n_current_samples", ":", "n_samples_required", "]", "=", "y", "\n", "samples", ".", "n_samples", "+=", "n_new_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.samples_collection_to_dict": [[113, 119], ["getattr"], "function", ["None"], ["", "def", "samples_collection_to_dict", "(", "samples", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "dtype", "in", "spec_samples_collection", ":", "\n", "        ", "d", "[", "key", "]", "=", "getattr", "(", "samples", ",", "key", ")", "\n", "", "d", "[", "\"n_features\"", "]", "=", "samples", ".", "features", ".", "shape", "[", "1", "]", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.dict_to_samples_collection": [[121, 132], ["sample.SamplesCollection"], "function", ["None"], ["", "def", "dict_to_samples_collection", "(", "d", ")", ":", "\n", "    ", "n_samples_increment", "=", "d", "[", "\"n_samples_increment\"", "]", "\n", "n_samples_capacity", "=", "d", "[", "\"n_samples_capacity\"", "]", "\n", "n_samples", "=", "d", "[", "\"n_samples\"", "]", "\n", "n_features", "=", "d", "[", "\"n_features\"", "]", "\n", "samples", "=", "SamplesCollection", "(", "\n", "n_samples_increment", ",", "n_features", ",", "n_samples", ",", "n_samples_capacity", "\n", ")", "\n", "samples", ".", "features", "[", ":", "]", "=", "d", "[", "\"features\"", "]", "\n", "samples", ".", "labels", "[", ":", "]", "=", "d", "[", "\"labels\"", "]", "\n", "return", "samples", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_score": [[21, 52], ["numba.njit", "types.float32", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["@", "njit", "(", "float32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_classifier_score", "(", "tree", ",", "node", ",", "idx_class", ")", ":", "\n", "    ", "\"\"\"Computes the score of the node\n\n    Parameters\n    ----------\n    tree : `TreeClassifier`\n        The tree containing the node\n\n    node : `uint32`\n        The index of the node in the tree\n\n    idx_class : `uint32`\n        Class index for which we want the score\n\n    Returns\n    -------\n    output : `float32`\n        The log-loss of the node\n\n    Notes\n    -----\n    This uses Jeffreys prior with dirichlet parameter for smoothing\n    \"\"\"", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "count", "=", "nodes", ".", "counts", "[", "node", ",", "idx_class", "]", "\n", "n_samples", "=", "nodes", ".", "n_samples", "[", "node", "]", "\n", "n_classes", "=", "tree", ".", "n_classes", "\n", "dirichlet", "=", "tree", ".", "dirichlet", "\n", "# We use the Jeffreys prior with dirichlet parameter", "\n", "return", "(", "count", "+", "dirichlet", ")", "/", "(", "n_samples", "+", "dirichlet", "*", "n_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_predict": [[54, 59], ["numba.njit", "range", "types.void", "node_methods.node_classifier_score", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_score", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "node_classifier_predict", "(", "tree", ",", "idx_node", ",", "scores", ")", ":", "\n", "# TODO: this is a bit silly ?... do everything at once", "\n", "    ", "for", "c", "in", "range", "(", "tree", ".", "n_classes", ")", ":", "\n", "        ", "scores", "[", "c", "]", "=", "node_classifier_score", "(", "tree", ",", "idx_node", ",", "c", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_predict": [[61, 83], ["numba.njit", "types.float32", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ")", ")", "\n", "def", "node_regressor_predict", "(", "tree", ",", "node", ")", ":", "\n", "    ", "\"\"\"Returns the prediction of the node.\n\n    Parameters\n    ----------\n    tree : `TreeRegressor\n        The tree containing the node\n\n    node : `uint32`\n        The index of the node in the tree\n\n    Returns\n    -------\n    output : `float32`\n        The log-loss of the node\n\n    Notes\n    -----\n    This uses Jeffreys prior with dirichlet parameter for smoothing\n    \"\"\"", "\n", "return", "tree", ".", "nodes", ".", "mean", "[", "node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_loss": [[85, 91], ["numba.njit", "numba.types.uint8", "node_methods.node_classifier_score", "types.float32", "math.log", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_score", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_classifier_loss", "(", "tree", ",", "node", ",", "idx_sample", ")", ":", "\n", "    ", "c", "=", "types", ".", "uint8", "(", "tree", ".", "samples", ".", "labels", "[", "idx_sample", "]", ")", "\n", "sc", "=", "node_classifier_score", "(", "tree", ",", "node", ",", "c", ")", "\n", "# TODO: benchmark different logarithms", "\n", "return", "-", "log", "(", "sc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_loss": [[93, 97], ["numba.njit", "types.float32", "node_methods.node_regressor_predict", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_regressor_loss", "(", "tree", ",", "node", ",", "idx_sample", ")", ":", "\n", "    ", "r", "=", "node_regressor_predict", "(", "tree", ",", "node", ")", "-", "tree", ".", "samples", ".", "labels", "[", "idx_sample", "]", "\n", "return", "r", "*", "r", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_weight": [[99, 105], ["numba.njit", "node_methods.node_classifier_loss", "types.float32", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_loss", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_classifier_update_weight", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", ":", "\n", "    ", "loss_t", "=", "node_classifier_loss", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", "\n", "if", "tree", ".", "use_aggregation", ":", "\n", "        ", "tree", ".", "nodes", ".", "weight", "[", "idx_node", "]", "-=", "tree", ".", "step", "*", "loss_t", "\n", "", "return", "loss_t", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_weight": [[107, 113], ["numba.njit", "node_methods.node_regressor_loss", "types.float32", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_loss", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_regressor_update_weight", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", ":", "\n", "    ", "loss_t", "=", "node_regressor_loss", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", "\n", "if", "tree", ".", "use_aggregation", ":", "\n", "        ", "tree", ".", "nodes", ".", "weight", "[", "idx_node", "]", "-=", "tree", ".", "step", "*", "loss_t", "\n", "", "return", "loss_t", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_count": [[115, 120], ["numba.njit", "numba.types.uint32", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_classifier_update_count", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", ":", "\n", "# TODO: Don't do it twice...", "\n", "    ", "c", "=", "types", ".", "uint32", "(", "tree", ".", "samples", ".", "labels", "[", "idx_sample", "]", ")", "\n", "tree", ".", "nodes", ".", "counts", "[", "idx_node", ",", "c", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_downwards": [[122, 155], ["numba.njit", "node_methods.node_classifier_update_count", "types.void", "range", "range", "node_methods.node_classifier_update_weight", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_count", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_weight", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ",", "boolean", ")", ")", "\n", "def", "node_classifier_update_downwards", "(", "tree", ",", "idx_node", ",", "idx_sample", ",", "do_update_weight", ")", ":", "\n", "    ", "x_t", "=", "tree", ".", "samples", ".", "features", "[", "idx_sample", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "n_features", "=", "tree", ".", "n_features", "\n", "memory_range_min", "=", "nodes", ".", "memory_range_min", "[", "idx_node", "]", "\n", "memory_range_max", "=", "nodes", ".", "memory_range_max", "[", "idx_node", "]", "\n", "# If it is the first sample, we copy the features vector into the min and", "\n", "# max range", "\n", "if", "nodes", ".", "n_samples", "[", "idx_node", "]", "==", "0", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_features", ")", ":", "\n", "            ", "x_tj", "=", "x_t", "[", "j", "]", "\n", "memory_range_min", "[", "j", "]", "=", "x_tj", "\n", "memory_range_max", "[", "j", "]", "=", "x_tj", "\n", "# Otherwise, we update the range", "\n", "", "", "else", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_features", ")", ":", "\n", "            ", "x_tj", "=", "x_t", "[", "j", "]", "\n", "if", "x_tj", "<", "memory_range_min", "[", "j", "]", ":", "\n", "                ", "memory_range_min", "[", "j", "]", "=", "x_tj", "\n", "", "if", "x_tj", ">", "memory_range_max", "[", "j", "]", ":", "\n", "                ", "memory_range_max", "[", "j", "]", "=", "x_tj", "\n", "\n", "# TODO: we should save the sample here and do a bunch of stuff about", "\n", "#  memorization", "\n", "# One more sample in the node", "\n", "", "", "", "nodes", ".", "n_samples", "[", "idx_node", "]", "+=", "1", "\n", "\n", "if", "do_update_weight", ":", "\n", "# TODO: Using x_t and y_t should be better...", "\n", "        ", "node_classifier_update_weight", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", "\n", "\n", "", "node_classifier_update_count", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_downwards": [[157, 192], ["numba.njit", "types.void", "range", "range", "node_methods.node_regressor_update_weight", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_weight", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "uint32", ",", "boolean", ")", ")", "\n", "def", "node_regressor_update_downwards", "(", "tree", ",", "idx_node", ",", "idx_sample", ",", "do_update_weight", ")", ":", "\n", "    ", "x_t", "=", "tree", ".", "samples", ".", "features", "[", "idx_sample", "]", "\n", "y_t", "=", "tree", ".", "samples", ".", "labels", "[", "idx_sample", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "n_features", "=", "tree", ".", "n_features", "\n", "memory_range_min", "=", "nodes", ".", "memory_range_min", "[", "idx_node", "]", "\n", "memory_range_max", "=", "nodes", ".", "memory_range_max", "[", "idx_node", "]", "\n", "if", "nodes", ".", "n_samples", "[", "idx_node", "]", "==", "0", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_features", ")", ":", "\n", "            ", "x_tj", "=", "x_t", "[", "j", "]", "\n", "memory_range_min", "[", "j", "]", "=", "x_tj", "\n", "memory_range_max", "[", "j", "]", "=", "x_tj", "\n", "", "", "else", ":", "\n", "        ", "for", "j", "in", "range", "(", "n_features", ")", ":", "\n", "            ", "x_tj", "=", "x_t", "[", "j", "]", "\n", "if", "x_tj", "<", "memory_range_min", "[", "j", "]", ":", "\n", "                ", "memory_range_min", "[", "j", "]", "=", "x_tj", "\n", "", "if", "x_tj", ">", "memory_range_max", "[", "j", "]", ":", "\n", "                ", "memory_range_max", "[", "j", "]", "=", "x_tj", "\n", "\n", "# TODO: we should save the sample here and do a bunch of stuff about", "\n", "#  memorization", "\n", "\n", "# Number of samples before the update", "\n", "", "", "", "n_samples", "=", "nodes", ".", "n_samples", "[", "idx_node", "]", "\n", "# One more sample in the node", "\n", "nodes", ".", "n_samples", "[", "idx_node", "]", "+=", "1", "\n", "\n", "if", "do_update_weight", ":", "\n", "# TODO: Using x_t and y_t should be better...", "\n", "        ", "node_regressor_update_weight", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", "\n", "\n", "# Update the mean of the labels in the node online", "\n", "", "nodes", ".", "mean", "[", "idx_node", "]", "=", "(", "n_samples", "*", "nodes", ".", "mean", "[", "idx_node", "]", "+", "y_t", ")", "/", "(", "n_samples", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_weight_tree": [[194, 206], ["numba.njit", "utils.log_sum_2_exp", "types.void", "types.void", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.log_sum_2_exp", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "[", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ")", ",", "void", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ")", "]", ")", "\n", "def", "node_update_weight_tree", "(", "tree", ",", "idx_node", ")", ":", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "if", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "        ", "nodes", ".", "log_weight_tree", "[", "idx_node", "]", "=", "nodes", ".", "weight", "[", "idx_node", "]", "\n", "", "else", ":", "\n", "        ", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_node", "]", "\n", "weight", "=", "nodes", ".", "weight", "[", "idx_node", "]", "\n", "log_weight_tree", "=", "nodes", ".", "log_weight_tree", "\n", "log_weight_tree", "[", "idx_node", "]", "=", "log_sum_2_exp", "(", "\n", "weight", ",", "log_weight_tree", "[", "left", "]", "+", "log_weight_tree", "[", "right", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth": [[209, 226], ["numba.njit", "node_methods.node_update_depth", "node_methods.node_update_depth", "types.void", "types.void", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "@", "njit", "(", "\n", "[", "\n", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint8", ")", ",", "\n", "void", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "uint8", ")", ",", "\n", "]", "\n", ")", "\n", "def", "node_update_depth", "(", "tree", ",", "idx_node", ",", "depth", ")", ":", "\n", "    ", "depth", "+=", "1", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "nodes", ".", "depth", "[", "idx_node", "]", "=", "depth", "\n", "if", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "        ", "return", "\n", "", "else", ":", "\n", "        ", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_node", "]", "\n", "node_update_depth", "(", "tree", ",", "left", ",", "depth", ")", "\n", "node_update_depth", "(", "tree", ",", "right", ",", "depth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_is_dirac": [[228, 235], ["numba.njit", "numba.types.uint8", "types.boolean", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "@", "njit", "(", "boolean", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "float32", ")", ")", "\n", "def", "node_classifier_is_dirac", "(", "tree", ",", "idx_node", ",", "y_t", ")", ":", "\n", "    ", "c", "=", "types", ".", "uint8", "(", "y_t", ")", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "n_samples", "=", "nodes", ".", "n_samples", "[", "idx_node", "]", "\n", "count", "=", "nodes", ".", "counts", "[", "idx_node", ",", "c", "]", "\n", "return", "n_samples", "==", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_get_child": [[237, 251], ["numba.njit", "types.uint32", "types.uint32", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "\n", "uint32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "float32", "[", ":", ":", "1", "]", ")", ",", "\n", "uint32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "float32", "[", ":", ":", "1", "]", ")", ",", "\n", "]", "\n", ")", "\n", "def", "node_get_child", "(", "tree", ",", "idx_node", ",", "x_t", ")", ":", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "feature", "=", "nodes", ".", "feature", "[", "idx_node", "]", "\n", "threshold", "=", "nodes", ".", "threshold", "[", "idx_node", "]", "\n", "if", "x_t", "[", "feature", "]", "<=", "threshold", ":", "\n", "        ", "return", "nodes", ".", "left", "[", "idx_node", "]", "\n", "", "else", ":", "\n", "        ", "return", "nodes", ".", "right", "[", "idx_node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_range": [[253, 265], ["numba.njit", "types.Tuple", "utils.get_type", "types.Tuple", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "@", "njit", "(", "\n", "[", "\n", "Tuple", "(", "(", "float32", ",", "float32", ")", ")", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ")", ",", "\n", "Tuple", "(", "(", "float32", ",", "float32", ")", ")", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "uint32", ")", ",", "\n", "]", "\n", ")", "\n", "def", "node_range", "(", "tree", ",", "idx_node", ",", "j", ")", ":", "\n", "# TODO: do the version without memory...", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "return", "(", "\n", "nodes", ".", "memory_range_min", "[", "idx_node", ",", "j", "]", ",", "\n", "nodes", ".", "memory_range_max", "[", "idx_node", ",", "j", "]", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_compute_range_extension": [[268, 288], ["numba.njit", "range", "node_methods.node_range", "types.float32", "types.float32", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_range", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "\n", "float32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "float32", "[", ":", ":", "1", "]", ",", "float32", "[", ":", ":", "1", "]", ")", ",", "\n", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "float32", "[", ":", ":", "1", "]", ",", "float32", "[", ":", ":", "1", "]", ")", ",", "\n", "]", "\n", ")", "\n", "def", "node_compute_range_extension", "(", "tree", ",", "idx_node", ",", "x_t", ",", "extensions", ")", ":", "\n", "    ", "extensions_sum", "=", "0", "\n", "for", "j", "in", "range", "(", "tree", ".", "n_features", ")", ":", "\n", "        ", "x_tj", "=", "x_t", "[", "j", "]", "\n", "feature_min_j", ",", "feature_max_j", "=", "node_range", "(", "tree", ",", "idx_node", ",", "j", ")", "\n", "if", "x_tj", "<", "feature_min_j", ":", "\n", "            ", "diff", "=", "feature_min_j", "-", "x_tj", "\n", "", "elif", "x_tj", ">", "feature_max_j", ":", "\n", "            ", "diff", "=", "x_tj", "-", "feature_max_j", "\n", "", "else", ":", "\n", "            ", "diff", "=", "0", "\n", "", "extensions", "[", "j", "]", "=", "diff", "\n", "extensions_sum", "+=", "diff", "\n", "", "return", "extensions_sum", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_compute_split_time": [[290, 320], ["numba.njit", "node_methods.node_compute_range_extension", "types.float32", "node_methods.node_classifier_is_dirac", "numpy.random.exponential", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_compute_range_extension", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_is_dirac", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_classifier_compute_split_time", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", ":", "\n", "    ", "samples", "=", "tree", ".", "samples", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "y_t", "=", "samples", ".", "labels", "[", "idx_sample", "]", "\n", "#  Don't split if the node is pure: all labels are equal to the one of y_t", "\n", "if", "not", "tree", ".", "split_pure", "and", "node_classifier_is_dirac", "(", "tree", ",", "idx_node", ",", "y_t", ")", ":", "\n", "        ", "return", "0.0", "\n", "\n", "", "x_t", "=", "samples", ".", "features", "[", "idx_sample", "]", "\n", "extensions_sum", "=", "node_compute_range_extension", "(", "tree", ",", "idx_node", ",", "x_t", ",", "tree", ".", "intensities", ")", "\n", "# If x_t extends the current range of the node", "\n", "if", "extensions_sum", ">", "0", ":", "\n", "# Sample an exponential with intensity = extensions_sum", "\n", "        ", "T", "=", "exponential", "(", "1", "/", "extensions_sum", ")", "\n", "time", "=", "nodes", ".", "time", "[", "idx_node", "]", "\n", "# Splitting time of the node (if splitting occurs)", "\n", "split_time", "=", "time", "+", "T", "\n", "# If the node is a leaf we must split it", "\n", "if", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "            ", "return", "split_time", "\n", "# Otherwise we apply Mondrian process dark magic :)", "\n", "# 1. We get the creation time of the childs (left and right is the same)", "\n", "", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "child_time", "=", "nodes", ".", "time", "[", "left", "]", "\n", "# 2. We check if splitting time occurs before child creation time", "\n", "if", "split_time", "<", "child_time", ":", "\n", "            ", "return", "split_time", "\n", "\n", "", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_compute_split_time": [[322, 353], ["numba.njit", "node_methods.node_compute_range_extension", "types.float32", "numpy.random.exponential", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_compute_range_extension", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "node_regressor_compute_split_time", "(", "tree", ",", "idx_node", ",", "idx_sample", ")", ":", "\n", "    ", "samples", "=", "tree", ".", "samples", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "# y_t = samples.labels[idx_sample]", "\n", "#  Don't split if the node is pure: all labels are equal to the one of y_t", "\n", "# TODO: what do we do here ? Zero variance ?", "\n", "# if not tree.split_pure and node_classifier_is_dirac(tree, idx_node, y_t):", "\n", "#     return 0.0", "\n", "\n", "x_t", "=", "samples", ".", "features", "[", "idx_sample", "]", "\n", "extensions_sum", "=", "node_compute_range_extension", "(", "tree", ",", "idx_node", ",", "x_t", ",", "tree", ".", "intensities", ")", "\n", "# If x_t extends the current range of the node", "\n", "if", "extensions_sum", ">", "0", ":", "\n", "# Sample an exponential with intensity = extensions_sum", "\n", "        ", "T", "=", "exponential", "(", "1", "/", "extensions_sum", ")", "\n", "time", "=", "nodes", ".", "time", "[", "idx_node", "]", "\n", "# Splitting time of the node (if splitting occurs)", "\n", "split_time", "=", "time", "+", "T", "\n", "# If the node is a leaf we must split it", "\n", "if", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "            ", "return", "split_time", "\n", "# Otherwise we apply Mondrian process dark magic :)", "\n", "# 1. We get the creation time of the childs (left and right is the same)", "\n", "", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "child_time", "=", "nodes", ".", "time", "[", "left", "]", "\n", "# 2. We check if splitting time occurs before child creation time", "\n", "if", "split_time", "<", "child_time", ":", "\n", "            ", "return", "split_time", "\n", "\n", "", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_split": [[355, 397], ["numba.njit", "node_collection.add_node_classifier", "node_collection.add_node_classifier", "types.void", "node_collection.copy_node_classifier", "node_collection.copy_node_classifier", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ",", "float32", ",", "float32", ",", "uint32", ",", "boolean", ")", ")", "\n", "def", "node_classifier_split", "(", "\n", "tree", ",", "idx_node", ",", "split_time", ",", "threshold", ",", "feature", ",", "is_right_extension", "\n", ")", ":", "\n", "# Create the two splits", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "left_new", "=", "add_node_classifier", "(", "nodes", ",", "idx_node", ",", "split_time", ")", "\n", "right_new", "=", "add_node_classifier", "(", "nodes", ",", "idx_node", ",", "split_time", ")", "\n", "if", "is_right_extension", ":", "\n", "# left_new is the same as idx_node, excepted for the parent, time and the", "\n", "#  fact that it's a leaf", "\n", "        ", "copy_node_classifier", "(", "nodes", ",", "idx_node", ",", "left_new", ")", "\n", "# so we need to put back the correct parent and time", "\n", "nodes", ".", "parent", "[", "left_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "left_new", "]", "=", "split_time", "\n", "# right_new must have idx_node has parent", "\n", "nodes", ".", "parent", "[", "right_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "right_new", "]", "=", "split_time", "\n", "# We must tell the old childs that they have a new parent, if the", "\n", "# current node is not a leaf", "\n", "if", "not", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "            ", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_node", "]", "\n", "nodes", ".", "parent", "[", "left", "]", "=", "left_new", "\n", "nodes", ".", "parent", "[", "right", "]", "=", "left_new", "\n", "", "", "else", ":", "\n", "        ", "copy_node_classifier", "(", "nodes", ",", "idx_node", ",", "right_new", ")", "\n", "nodes", ".", "parent", "[", "right_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "right_new", "]", "=", "split_time", "\n", "nodes", ".", "parent", "[", "left_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "left_new", "]", "=", "split_time", "\n", "if", "not", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "            ", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_node", "]", "\n", "nodes", ".", "parent", "[", "left", "]", "=", "right_new", "\n", "nodes", ".", "parent", "[", "right", "]", "=", "right_new", "\n", "\n", "", "", "nodes", ".", "feature", "[", "idx_node", "]", "=", "feature", "\n", "nodes", ".", "threshold", "[", "idx_node", "]", "=", "threshold", "\n", "nodes", ".", "left", "[", "idx_node", "]", "=", "left_new", "\n", "nodes", ".", "right", "[", "idx_node", "]", "=", "right_new", "\n", "nodes", ".", "is_leaf", "[", "idx_node", "]", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_split": [[399, 441], ["numba.njit", "node_collection.add_node_regressor", "node_collection.add_node_regressor", "types.void", "node_collection.copy_node_regressor", "node_collection.copy_node_regressor", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ",", "float32", ",", "float32", ",", "uint32", ",", "boolean", ",", ")", ")", "\n", "def", "node_regressor_split", "(", "\n", "tree", ",", "idx_node", ",", "split_time", ",", "threshold", ",", "feature", ",", "is_right_extension", "\n", ")", ":", "\n", "# Create the two splits", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "left_new", "=", "add_node_regressor", "(", "nodes", ",", "idx_node", ",", "split_time", ")", "\n", "right_new", "=", "add_node_regressor", "(", "nodes", ",", "idx_node", ",", "split_time", ")", "\n", "if", "is_right_extension", ":", "\n", "# left_new is the same as idx_node, excepted for the parent, time and the", "\n", "#  fact that it's a leaf", "\n", "        ", "copy_node_regressor", "(", "nodes", ",", "idx_node", ",", "left_new", ")", "\n", "# so we need to put back the correct parent and time", "\n", "nodes", ".", "parent", "[", "left_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "left_new", "]", "=", "split_time", "\n", "# right_new must have idx_node has parent", "\n", "nodes", ".", "parent", "[", "right_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "right_new", "]", "=", "split_time", "\n", "# We must tell the old childs that they have a new parent, if the", "\n", "# current node is not a leaf", "\n", "if", "not", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "            ", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_node", "]", "\n", "nodes", ".", "parent", "[", "left", "]", "=", "left_new", "\n", "nodes", ".", "parent", "[", "right", "]", "=", "left_new", "\n", "", "", "else", ":", "\n", "        ", "copy_node_regressor", "(", "nodes", ",", "idx_node", ",", "right_new", ")", "\n", "nodes", ".", "parent", "[", "right_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "right_new", "]", "=", "split_time", "\n", "nodes", ".", "parent", "[", "left_new", "]", "=", "idx_node", "\n", "nodes", ".", "time", "[", "left_new", "]", "=", "split_time", "\n", "if", "not", "nodes", ".", "is_leaf", "[", "idx_node", "]", ":", "\n", "            ", "left", "=", "nodes", ".", "left", "[", "idx_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_node", "]", "\n", "nodes", ".", "parent", "[", "left", "]", "=", "right_new", "\n", "nodes", ".", "parent", "[", "right", "]", "=", "right_new", "\n", "\n", "", "", "nodes", ".", "feature", "[", "idx_node", "]", "=", "feature", "\n", "nodes", ".", "threshold", "[", "idx_node", "]", "=", "threshold", "\n", "nodes", ".", "left", "[", "idx_node", "]", "=", "left_new", "\n", "nodes", ".", "right", "[", "idx_node", "]", "=", "right_new", "\n", "nodes", ".", "is_leaf", "[", "idx_node", "]", "=", "False", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_go_downwards": [[31, 114], ["numba.njit", "types.uint32", "node_methods.node_classifier_update_downwards", "utils.get_type", "node_methods.node_classifier_compute_split_time", "tree.intensities.sum", "utils.sample_discrete", "node_methods.node_range", "node_methods.node_classifier_split", "node_methods.node_classifier_update_downwards", "node_methods.node_update_depth", "node_methods.node_update_depth", "node_methods.node_classifier_update_downwards", "node_methods.node_classifier_update_downwards", "numpy.random.uniform", "numpy.random.uniform", "node_methods.node_get_child"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_compute_split_time", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.sample_discrete", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_range", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_split", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_get_child"], ["@", "njit", "(", "uint32", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ")", ")", "\n", "def", "tree_classifier_go_downwards", "(", "tree", ",", "idx_sample", ")", ":", "\n", "# We update the nodes along the path which leads to the leaf containing", "\n", "# x_t. For each node on the path, we consider the possibility of", "\n", "# splitting it, following the Mondrian process definition.", "\n", "# Index of the root is 0", "\n", "    ", "idx_current_node", "=", "0", "\n", "x_t", "=", "tree", ".", "samples", ".", "features", "[", "idx_sample", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "\n", "if", "tree", ".", "iteration", "==", "0", ":", "\n", "# If it's the first iteration, we just put x_t in the range of root", "\n", "        ", "node_classifier_update_downwards", "(", "tree", ",", "idx_current_node", ",", "idx_sample", ",", "False", ")", "\n", "return", "idx_current_node", "\n", "", "else", ":", "\n", "        ", "while", "True", ":", "\n", "# If it's not the first iteration (otherwise the current node", "\n", "# is root with no range), we consider the possibility of a split", "\n", "            ", "split_time", "=", "node_classifier_compute_split_time", "(", "\n", "tree", ",", "idx_current_node", ",", "idx_sample", "\n", ")", "\n", "\n", "if", "split_time", ">", "0", ":", "\n", "# We split the current node: because the current node is a", "\n", "# leaf, or because we add a new node along the path", "\n", "# We normalize the range extensions to get probabilities", "\n", "# TODO: faster than this ?", "\n", "                ", "tree", ".", "intensities", "/=", "tree", ".", "intensities", ".", "sum", "(", ")", "\n", "# Sample the feature at random with with a probability", "\n", "# proportional to the range extensions", "\n", "feature", "=", "sample_discrete", "(", "tree", ".", "intensities", ")", "\n", "x_tf", "=", "x_t", "[", "feature", "]", "\n", "# Is it a right extension of the node ?", "\n", "range_min", ",", "range_max", "=", "node_range", "(", "tree", ",", "idx_current_node", ",", "feature", ")", "\n", "is_right_extension", "=", "x_tf", ">", "range_max", "\n", "if", "is_right_extension", ":", "\n", "                    ", "threshold", "=", "uniform", "(", "range_max", ",", "x_tf", ")", "\n", "", "else", ":", "\n", "                    ", "threshold", "=", "uniform", "(", "x_tf", ",", "range_min", ")", "\n", "\n", "", "node_classifier_split", "(", "\n", "tree", ",", "\n", "idx_current_node", ",", "\n", "split_time", ",", "\n", "threshold", ",", "\n", "feature", ",", "\n", "is_right_extension", ",", "\n", ")", "\n", "\n", "# Update the current node", "\n", "node_classifier_update_downwards", "(", "\n", "tree", ",", "idx_current_node", ",", "idx_sample", ",", "True", "\n", ")", "\n", "\n", "left", "=", "nodes", ".", "left", "[", "idx_current_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_current_node", "]", "\n", "depth", "=", "nodes", ".", "depth", "[", "idx_current_node", "]", "\n", "\n", "# Now, get the next node", "\n", "if", "is_right_extension", ":", "\n", "                    ", "idx_current_node", "=", "right", "\n", "", "else", ":", "\n", "                    ", "idx_current_node", "=", "left", "\n", "\n", "", "node_update_depth", "(", "tree", ",", "left", ",", "depth", ")", "\n", "node_update_depth", "(", "tree", ",", "right", ",", "depth", ")", "\n", "\n", "# This is the leaf containing the sample point (we've just", "\n", "# splitted the current node with the data point)", "\n", "leaf", "=", "idx_current_node", "\n", "node_classifier_update_downwards", "(", "tree", ",", "leaf", ",", "idx_sample", ",", "False", ")", "\n", "return", "leaf", "\n", "", "else", ":", "\n", "# There is no split, so we just update the node and go to", "\n", "# the next one", "\n", "                ", "node_classifier_update_downwards", "(", "\n", "tree", ",", "idx_current_node", ",", "idx_sample", ",", "True", "\n", ")", "\n", "is_leaf", "=", "nodes", ".", "is_leaf", "[", "idx_current_node", "]", "\n", "if", "is_leaf", ":", "\n", "                    ", "return", "idx_current_node", "\n", "", "else", ":", "\n", "                    ", "idx_current_node", "=", "node_get_child", "(", "tree", ",", "idx_current_node", ",", "x_t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_go_downwards": [[116, 199], ["numba.njit", "types.uint32", "node_methods.node_regressor_update_downwards", "utils.get_type", "node_methods.node_regressor_compute_split_time", "tree.intensities.sum", "utils.sample_discrete", "node_methods.node_range", "node_methods.node_regressor_split", "node_methods.node_regressor_update_downwards", "node_methods.node_update_depth", "node_methods.node_update_depth", "node_methods.node_regressor_update_downwards", "node_methods.node_regressor_update_downwards", "numpy.random.uniform", "numpy.random.uniform", "node_methods.node_get_child"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_compute_split_time", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.sample_discrete", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_range", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_split", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_update_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_get_child"], ["", "", "", "", "", "@", "njit", "(", "uint32", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ")", ")", "\n", "def", "tree_regressor_go_downwards", "(", "tree", ",", "idx_sample", ")", ":", "\n", "# We update the nodes along the path which leads to the leaf containing", "\n", "# x_t. For each node on the path, we consider the possibility of", "\n", "# splitting it, following the Mondrian process definition.", "\n", "# Index of the root is 0", "\n", "    ", "idx_current_node", "=", "0", "\n", "x_t", "=", "tree", ".", "samples", ".", "features", "[", "idx_sample", "]", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "\n", "if", "tree", ".", "iteration", "==", "0", ":", "\n", "# If it's the first iteration, we just put x_t in the range of root", "\n", "        ", "node_regressor_update_downwards", "(", "tree", ",", "idx_current_node", ",", "idx_sample", ",", "False", ")", "\n", "return", "idx_current_node", "\n", "", "else", ":", "\n", "        ", "while", "True", ":", "\n", "# If it's not the first iteration (otherwise the current node", "\n", "# is root with no range), we consider the possibility of a split", "\n", "            ", "split_time", "=", "node_regressor_compute_split_time", "(", "\n", "tree", ",", "idx_current_node", ",", "idx_sample", "\n", ")", "\n", "\n", "if", "split_time", ">", "0", ":", "\n", "# We split the current node: because the current node is a", "\n", "# leaf, or because we add a new node along the path", "\n", "# We normalize the range extensions to get probabilities", "\n", "# TODO: faster than this ?", "\n", "                ", "tree", ".", "intensities", "/=", "tree", ".", "intensities", ".", "sum", "(", ")", "\n", "# Sample the feature at random with with a probability", "\n", "# proportional to the range extensions", "\n", "feature", "=", "sample_discrete", "(", "tree", ".", "intensities", ")", "\n", "x_tf", "=", "x_t", "[", "feature", "]", "\n", "# Is it a right extension of the node ?", "\n", "range_min", ",", "range_max", "=", "node_range", "(", "tree", ",", "idx_current_node", ",", "feature", ")", "\n", "is_right_extension", "=", "x_tf", ">", "range_max", "\n", "if", "is_right_extension", ":", "\n", "                    ", "threshold", "=", "uniform", "(", "range_max", ",", "x_tf", ")", "\n", "", "else", ":", "\n", "                    ", "threshold", "=", "uniform", "(", "x_tf", ",", "range_min", ")", "\n", "\n", "", "node_regressor_split", "(", "\n", "tree", ",", "\n", "idx_current_node", ",", "\n", "split_time", ",", "\n", "threshold", ",", "\n", "feature", ",", "\n", "is_right_extension", ",", "\n", ")", "\n", "\n", "# Update the current node", "\n", "node_regressor_update_downwards", "(", "\n", "tree", ",", "idx_current_node", ",", "idx_sample", ",", "True", "\n", ")", "\n", "\n", "left", "=", "nodes", ".", "left", "[", "idx_current_node", "]", "\n", "right", "=", "nodes", ".", "right", "[", "idx_current_node", "]", "\n", "depth", "=", "nodes", ".", "depth", "[", "idx_current_node", "]", "\n", "\n", "# Now, get the next node", "\n", "if", "is_right_extension", ":", "\n", "                    ", "idx_current_node", "=", "right", "\n", "", "else", ":", "\n", "                    ", "idx_current_node", "=", "left", "\n", "\n", "", "node_update_depth", "(", "tree", ",", "left", ",", "depth", ")", "\n", "node_update_depth", "(", "tree", ",", "right", ",", "depth", ")", "\n", "\n", "# This is the leaf containing the sample point (we've just", "\n", "# splitted the current node with the data point)", "\n", "leaf", "=", "idx_current_node", "\n", "node_regressor_update_downwards", "(", "tree", ",", "leaf", ",", "idx_sample", ",", "False", ")", "\n", "return", "leaf", "\n", "", "else", ":", "\n", "# There is no split, so we just update the node and go to", "\n", "# the next one", "\n", "                ", "node_regressor_update_downwards", "(", "\n", "tree", ",", "idx_current_node", ",", "idx_sample", ",", "True", "\n", ")", "\n", "is_leaf", "=", "nodes", ".", "is_leaf", "[", "idx_current_node", "]", "\n", "if", "is_leaf", ":", "\n", "                    ", "return", "idx_current_node", "\n", "", "else", ":", "\n", "                    ", "idx_current_node", "=", "node_get_child", "(", "tree", ",", "idx_current_node", ",", "x_t", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_go_upwards": [[201, 213], ["numba.njit", "types.void", "types.void", "node_methods.node_update_weight_tree", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_update_weight_tree", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "", "", "", "@", "njit", "(", "[", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ")", ",", "void", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ")", "]", ")", "\n", "def", "tree_go_upwards", "(", "tree", ",", "leaf", ")", ":", "\n", "    ", "idx_current_node", "=", "leaf", "\n", "if", "tree", ".", "iteration", ">=", "1", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "node_update_weight_tree", "(", "tree", ",", "idx_current_node", ")", "\n", "if", "idx_current_node", "==", "0", ":", "\n", "# We arrived at the root", "\n", "                ", "break", "\n", "# Note that the root node is updated as well", "\n", "# We go up to the root in the tree", "\n", "", "idx_current_node", "=", "tree", ".", "nodes", ".", "parent", "[", "idx_current_node", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_partial_fit": [[215, 221], ["numba.njit", "tree_methods.tree_classifier_go_downwards", "types.void", "tree_methods.tree_go_upwards", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_go_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_go_upwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "", "@", "njit", "(", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "uint32", ")", ")", "\n", "def", "tree_classifier_partial_fit", "(", "tree", ",", "idx_sample", ")", ":", "\n", "    ", "leaf", "=", "tree_classifier_go_downwards", "(", "tree", ",", "idx_sample", ")", "\n", "if", "tree", ".", "use_aggregation", ":", "\n", "        ", "tree_go_upwards", "(", "tree", ",", "leaf", ")", "\n", "", "tree", ".", "iteration", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_partial_fit": [[223, 229], ["numba.njit", "tree_methods.tree_regressor_go_downwards", "types.void", "tree_methods.tree_go_upwards", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_go_downwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_go_upwards", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeRegressor", ")", ",", "uint32", ")", ")", "\n", "def", "tree_regressor_partial_fit", "(", "tree", ",", "idx_sample", ")", ":", "\n", "    ", "leaf", "=", "tree_regressor_go_downwards", "(", "tree", ",", "idx_sample", ")", "\n", "if", "tree", ".", "use_aggregation", ":", "\n", "        ", "tree_go_upwards", "(", "tree", ",", "leaf", ")", "\n", "", "tree", ".", "iteration", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_get_leaf": [[231, 253], ["numba.njit", "types.uint32", "types.uint32", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "\n", "uint32", "(", "get_type", "(", "TreeClassifier", ")", ",", "float32", "[", ":", ":", "1", "]", ")", ",", "\n", "uint32", "(", "get_type", "(", "TreeRegressor", ")", ",", "float32", "[", ":", ":", "1", "]", ")", ",", "\n", "]", "\n", ")", "\n", "def", "tree_get_leaf", "(", "tree", ",", "x_t", ")", ":", "\n", "# Find the index of the leaf that contains the sample. Start at the root.", "\n", "# Index of the root is 0", "\n", "    ", "node", "=", "0", "\n", "is_leaf", "=", "False", "\n", "nodes", "=", "tree", ".", "nodes", "\n", "while", "not", "is_leaf", ":", "\n", "        ", "is_leaf", "=", "nodes", ".", "is_leaf", "[", "node", "]", "\n", "if", "not", "is_leaf", ":", "\n", "            ", "feature", "=", "nodes", ".", "feature", "[", "node", "]", "\n", "threshold", "=", "nodes", ".", "threshold", "[", "node", "]", "\n", "if", "x_t", "[", "feature", "]", "<=", "threshold", ":", "\n", "                ", "node", "=", "nodes", ".", "left", "[", "node", "]", "\n", "", "else", ":", "\n", "                ", "node", "=", "nodes", ".", "right", "[", "node", "]", "\n", "", "", "", "return", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_classifier_predict": [[255, 282], ["numba.njit", "tree_methods.tree_get_leaf", "numpy.empty", "types.void", "node_methods.node_classifier_predict", "utils.get_type", "node_methods.node_classifier_predict", "math.exp", "node_methods.node_classifier_predict", "range"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_get_leaf", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_classifier_predict"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "TreeClassifier", ")", ",", "float32", "[", ":", ":", "1", "]", ",", "float32", "[", ":", ":", "1", "]", ",", "boolean", ")", ")", "\n", "def", "tree_classifier_predict", "(", "tree", ",", "x_t", ",", "scores", ",", "use_aggregation", ")", ":", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "leaf", "=", "tree_get_leaf", "(", "tree", ",", "x_t", ")", "\n", "if", "not", "use_aggregation", ":", "\n", "        ", "node_classifier_predict", "(", "tree", ",", "leaf", ",", "scores", ")", "\n", "return", "\n", "", "current", "=", "leaf", "\n", "# Allocate once and for all", "\n", "pred_new", "=", "np", ".", "empty", "(", "tree", ".", "n_classes", ",", "float32", ")", "\n", "while", "True", ":", "\n", "# This test is useless ?", "\n", "        ", "if", "nodes", ".", "is_leaf", "[", "current", "]", ":", "\n", "            ", "node_classifier_predict", "(", "tree", ",", "current", ",", "scores", ")", "\n", "", "else", ":", "\n", "            ", "weight", "=", "nodes", ".", "weight", "[", "current", "]", "\n", "log_weight_tree", "=", "nodes", ".", "log_weight_tree", "[", "current", "]", "\n", "w", "=", "exp", "(", "weight", "-", "log_weight_tree", ")", "\n", "# Get the predictions of the current node", "\n", "node_classifier_predict", "(", "tree", ",", "current", ",", "pred_new", ")", "\n", "for", "c", "in", "range", "(", "tree", ".", "n_classes", ")", ":", "\n", "                ", "scores", "[", "c", "]", "=", "0.5", "*", "w", "*", "pred_new", "[", "c", "]", "+", "(", "1", "-", "0.5", "*", "w", ")", "*", "scores", "[", "c", "]", "\n", "# Root must be update as well", "\n", "", "", "if", "current", "==", "0", ":", "\n", "            ", "break", "\n", "# And now we go up", "\n", "", "current", "=", "nodes", ".", "parent", "[", "current", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_predict": [[284, 308], ["numba.njit", "tree_methods.tree_get_leaf", "types.float32", "node_methods.node_regressor_predict", "utils.get_type", "node_methods.node_regressor_predict", "math.exp", "node_methods.node_regressor_predict"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_get_leaf", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_methods.node_regressor_predict"], ["", "", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "float32", "[", ":", ":", "1", "]", ",", "boolean", ")", ")", "\n", "def", "tree_regressor_predict", "(", "tree", ",", "x_t", ",", "use_aggregation", ")", ":", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "leaf", "=", "tree_get_leaf", "(", "tree", ",", "x_t", ")", "\n", "if", "not", "use_aggregation", ":", "\n", "        ", "return", "node_regressor_predict", "(", "tree", ",", "leaf", ")", "\n", "", "current", "=", "leaf", "\n", "while", "True", ":", "\n", "# This test is useless ?", "\n", "        ", "if", "nodes", ".", "is_leaf", "[", "current", "]", ":", "\n", "            ", "prediction", "=", "node_regressor_predict", "(", "tree", ",", "current", ")", "\n", "", "else", ":", "\n", "            ", "weight", "=", "nodes", ".", "weight", "[", "current", "]", "\n", "log_weight_tree", "=", "nodes", ".", "log_weight_tree", "[", "current", "]", "\n", "w", "=", "exp", "(", "weight", "-", "log_weight_tree", ")", "\n", "# Get the predictions of the current node", "\n", "prediction_new", "=", "node_regressor_predict", "(", "tree", ",", "current", ")", "\n", "prediction", "=", "0.5", "*", "w", "*", "prediction_new", "+", "(", "1", "-", "0.5", "*", "w", ")", "*", "prediction", "\n", "# Root must be update as well", "\n", "", "if", "current", "==", "0", ":", "\n", "            ", "break", "\n", "# And now we go up", "\n", "", "current", "=", "nodes", ".", "parent", "[", "current", "]", "\n", "", "return", "prediction", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_regressor_weighted_depth": [[310, 331], ["numba.njit", "tree_methods.tree_get_leaf", "types.float32", "types.float32", "math.exp", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree_methods.tree_get_leaf", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "float32", "(", "get_type", "(", "TreeRegressor", ")", ",", "float32", "[", ":", ":", "1", "]", ",", "boolean", ")", ")", "\n", "def", "tree_regressor_weighted_depth", "(", "tree", ",", "x_t", ",", "use_aggregation", ")", ":", "\n", "    ", "nodes", "=", "tree", ".", "nodes", "\n", "depths", "=", "nodes", ".", "depth", "\n", "weights", "=", "nodes", ".", "weight", "\n", "log_weight_trees", "=", "nodes", ".", "log_weight_tree", "\n", "leaf", "=", "tree_get_leaf", "(", "tree", ",", "x_t", ")", "\n", "depth", "=", "depths", "[", "leaf", "]", "\n", "if", "not", "use_aggregation", ":", "\n", "        ", "return", "float32", "(", "depth", ")", "\n", "", "current", "=", "leaf", "\n", "while", "True", ":", "\n", "        ", "weight", "=", "weights", "[", "current", "]", "\n", "log_weight_tree", "=", "log_weight_trees", "[", "current", "]", "\n", "w", "=", "exp", "(", "weight", "-", "log_weight_tree", ")", "\n", "depth_new", "=", "depths", "[", "current", "]", "\n", "depth", "=", "0.5", "*", "w", "*", "depth_new", "+", "(", "1", "-", "0.5", "*", "w", ")", "*", "depth", "\n", "if", "current", "==", "0", ":", "\n", "            ", "break", "\n", "", "current", "=", "nodes", ".", "parent", "[", "current", "]", "\n", "", "return", "depth", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._object_dtype_isnan": [[34, 36], ["None"], "function", ["None"], ["", "def", "_object_dtype_isnan", "(", "X", ")", ":", "\n", "    ", "return", "X", "!=", "X", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._num_samples": [[38, 65], ["type", "hasattr", "callable", "TypeError", "hasattr", "hasattr", "isinstance", "len", "hasattr", "hasattr", "numpy.asarray", "TypeError", "len", "TypeError", "TypeError"], "function", ["None"], ["", "def", "_num_samples", "(", "x", ")", ":", "\n", "    ", "\"\"\"Return number of samples in array-like x.\"\"\"", "\n", "message", "=", "\"Expected sequence or array-like, got %s\"", "%", "type", "(", "x", ")", "\n", "if", "hasattr", "(", "x", ",", "\"fit\"", ")", "and", "callable", "(", "x", ".", "fit", ")", ":", "\n", "# Don't get num_samples from an ensembles length!", "\n", "        ", "raise", "TypeError", "(", "message", ")", "\n", "\n", "", "if", "not", "hasattr", "(", "x", ",", "\"__len__\"", ")", "and", "not", "hasattr", "(", "x", ",", "\"shape\"", ")", ":", "\n", "        ", "if", "hasattr", "(", "x", ",", "\"__array__\"", ")", ":", "\n", "            ", "x", "=", "np", ".", "asarray", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "message", ")", "\n", "\n", "", "", "if", "hasattr", "(", "x", ",", "\"shape\"", ")", "and", "x", ".", "shape", "is", "not", "None", ":", "\n", "        ", "if", "len", "(", "x", ".", "shape", ")", "==", "0", ":", "\n", "            ", "raise", "TypeError", "(", "\n", "\"Singleton array %r cannot be considered\"", "\" a valid collection.\"", "%", "x", "\n", ")", "\n", "# Check that shape is returning an integer or default to len", "\n", "# Dask dataframes may not return numeric shape[0] value", "\n", "", "if", "isinstance", "(", "x", ".", "shape", "[", "0", "]", ",", "numbers", ".", "Integral", ")", ":", "\n", "            ", "return", "x", ".", "shape", "[", "0", "]", "\n", "\n", "", "", "try", ":", "\n", "        ", "return", "len", "(", "x", ")", "\n", "", "except", "TypeError", ":", "\n", "        ", "raise", "TypeError", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._safe_accumulator_op": [[67, 92], ["numpy.issubdtype", "op", "numpy.np.sum"], "function", ["None"], ["", "", "def", "_safe_accumulator_op", "(", "op", ",", "x", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    This function provides numpy accumulator functions with a float64 dtype\n    when used on a floating point input. This prevents accumulator overflow on\n    smaller floating point dtypes.\n    Parameters\n    ----------\n    op : function\n        A numpy accumulator function such as np.mean or np.sum\n    x : numpy array\n        A numpy array to apply the accumulator function\n    *args : positional arguments\n        Positional arguments passed to the accumulator function after the\n        input x\n    **kwargs : keyword arguments\n        Keyword arguments passed to the accumulator function\n    Returns\n    -------\n    result : The output of the accumulator function passed to this function\n    \"\"\"", "\n", "if", "np", ".", "issubdtype", "(", "x", ".", "dtype", ",", "np", ".", "floating", ")", "and", "x", ".", "dtype", ".", "itemsize", "<", "8", ":", "\n", "        ", "result", "=", "op", "(", "x", ",", "*", "args", ",", "**", "kwargs", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "", "else", ":", "\n", "        ", "result", "=", "op", "(", "x", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._check_sample_weight": [[94, 143], ["checks._num_samples", "isinstance", "checks.check_array", "numpy.ones", "numpy.full", "ValueError", "ValueError"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._num_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array"], ["", "def", "_check_sample_weight", "(", "sample_weight", ",", "X", ",", "dtype", "=", "None", ")", ":", "\n", "    ", "\"\"\"Validate sample weights.\n    Note that passing sample_weight=None will output an array of ones.\n    Therefore, in some cases, you may want to protect the call with:\n    if sample_weight is not None:\n        sample_weight = _check_sample_weight(...)\n    Parameters\n    ----------\n    sample_weight : {ndarray, Number or None}, shape (n_samples,)\n       Input sample weights.\n    X : nd-array, list or sparse matrix\n        Input data.\n    dtype: dtype\n       dtype of the validated `sample_weight`.\n       If None, and the input `sample_weight` is an array, the dtype of the\n       input is preserved; otherwise an array with the default numpy dtype\n       is be allocated.  If `dtype` is not one of `float32`, `float64`,\n       `None`, the output will be of dtype `float64`.\n    Returns\n    -------\n    sample_weight : ndarray, shape (n_samples,)\n       Validated sample weight. It is guaranteed to be \"C\" contiguous.\n    \"\"\"", "\n", "n_samples", "=", "_num_samples", "(", "X", ")", "\n", "\n", "if", "dtype", "is", "not", "None", "and", "dtype", "not", "in", "[", "np", ".", "float32", ",", "np", ".", "float64", "]", ":", "\n", "        ", "dtype", "=", "np", ".", "float64", "\n", "\n", "", "if", "sample_weight", "is", "None", "or", "isinstance", "(", "sample_weight", ",", "numbers", ".", "Number", ")", ":", "\n", "        ", "if", "sample_weight", "is", "None", ":", "\n", "            ", "sample_weight", "=", "np", ".", "ones", "(", "n_samples", ",", "dtype", "=", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "sample_weight", "=", "np", ".", "full", "(", "n_samples", ",", "sample_weight", ",", "dtype", "=", "dtype", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "dtype", "is", "None", ":", "\n", "            ", "dtype", "=", "[", "np", ".", "float64", ",", "np", ".", "float32", "]", "\n", "", "sample_weight", "=", "check_array", "(", "\n", "sample_weight", ",", "accept_sparse", "=", "False", ",", "ensure_2d", "=", "False", ",", "dtype", "=", "dtype", ",", "order", "=", "\"C\"", "\n", ")", "\n", "if", "sample_weight", ".", "ndim", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Sample weights must be 1D array or scalar\"", ")", "\n", "\n", "", "if", "sample_weight", ".", "shape", "!=", "(", "n_samples", ",", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"sample_weight.shape == {}, expected {}!\"", ".", "format", "(", "\n", "sample_weight", ".", "shape", ",", "(", "n_samples", ",", ")", "\n", ")", "\n", ")", "\n", "", "", "return", "sample_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.column_or_1d": [[145, 177], ["numpy.shape", "ValueError", "len", "numpy.ravel", "len", "warnings.warn"], "function", ["None"], ["", "def", "column_or_1d", "(", "y", ",", "warn", "=", "False", ")", ":", "\n", "    ", "\"\"\" Ravel column or 1d numpy array, else raises an error\n    Parameters\n    ----------\n    y : array-like\n    warn : boolean, default False\n       To control display of warnings.\n    Returns\n    -------\n    y : array\n    \"\"\"", "\n", "# This is commented compared to the scikit-learn version, so that no copy", "\n", "# of y is done when y.dtype is OK", "\n", "# y = np.asarray(y)", "\n", "shape", "=", "np", ".", "shape", "(", "y", ")", "\n", "if", "len", "(", "shape", ")", "==", "1", ":", "\n", "# This is commented compared to the scikit-learn version, so that no", "\n", "# copy of y is done when y.dtype is OK", "\n", "# return np.ravel(y)", "\n", "        ", "return", "y", "\n", "", "if", "len", "(", "shape", ")", "==", "2", "and", "shape", "[", "1", "]", "==", "1", ":", "\n", "        ", "if", "warn", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"A column-vector y was passed when a 1d array was\"", "\n", "\" expected. Please change the shape of y to \"", "\n", "\"(n_samples, ), for example using ravel().\"", ",", "\n", "DataConversionWarning", ",", "\n", "stacklevel", "=", "2", ",", "\n", ")", "\n", "", "return", "np", ".", "ravel", "(", "y", ")", "\n", "\n", "", "raise", "ValueError", "(", "\"bad input shape {0}\"", ".", "format", "(", "shape", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._assert_all_finite": [[179, 207], ["numpy.asanyarray", "numpy.isfinite", "checks._safe_accumulator_op", "ValueError", "_object_dtype_isnan().any", "numpy.isinf().any", "msg_err.format", "numpy.dtype", "ValueError", "numpy.isfinite().all", "checks._object_dtype_isnan", "numpy.isinf", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._safe_accumulator_op", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._object_dtype_isnan"], ["", "def", "_assert_all_finite", "(", "X", ",", "allow_nan", "=", "False", ",", "msg_dtype", "=", "None", ")", ":", "\n", "    ", "\"\"\"Like assert_all_finite, but only for ndarray.\"\"\"", "\n", "X", "=", "np", ".", "asanyarray", "(", "X", ")", "\n", "# First try an O(n) time, O(1) space solution for the common case that", "\n", "# everything is finite; fall back to O(n) space np.isfinite to prevent", "\n", "# false positives from overflow in sum method. The sum is also calculated", "\n", "# safely to reduce dtype induced overflows.", "\n", "is_float", "=", "X", ".", "dtype", ".", "kind", "in", "\"fc\"", "\n", "if", "is_float", "and", "(", "np", ".", "isfinite", "(", "_safe_accumulator_op", "(", "np", ".", "sum", ",", "X", ")", ")", ")", ":", "\n", "        ", "pass", "\n", "", "elif", "is_float", ":", "\n", "        ", "msg_err", "=", "\"Input contains {} or a value too large for {!r}.\"", "\n", "if", "(", "\n", "allow_nan", "\n", "and", "np", ".", "isinf", "(", "X", ")", ".", "any", "(", ")", "\n", "or", "not", "allow_nan", "\n", "and", "not", "np", ".", "isfinite", "(", "X", ")", ".", "all", "(", ")", "\n", ")", ":", "\n", "            ", "type_err", "=", "\"infinity\"", "if", "allow_nan", "else", "\"NaN, infinity\"", "\n", "raise", "ValueError", "(", "\n", "msg_err", ".", "format", "(", "\n", "type_err", ",", "msg_dtype", "if", "msg_dtype", "is", "not", "None", "else", "X", ".", "dtype", "\n", ")", "\n", ")", "\n", "# for object dtype data, we only check for NaNs (GH-13254)", "\n", "", "", "elif", "X", ".", "dtype", "==", "np", ".", "dtype", "(", "\"object\"", ")", "and", "not", "allow_nan", ":", "\n", "        ", "if", "_object_dtype_isnan", "(", "X", ")", ".", "any", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Input contains NaN\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._ensure_sparse_format": [[209, 297], ["isinstance", "checks._check_large_sparse", "TypeError", "isinstance", "spmatrix.asformat.astype", "spmatrix.asformat.copy", "hasattr", "warnings.warn", "checks._assert_all_finite", "len", "ValueError", "spmatrix.asformat.asformat", "ValueError"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._check_large_sparse", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._assert_all_finite"], ["", "", "", "def", "_ensure_sparse_format", "(", "\n", "spmatrix", ",", "accept_sparse", ",", "dtype", ",", "copy", ",", "force_all_finite", ",", "accept_large_sparse", "\n", ")", ":", "\n", "    ", "\"\"\"Convert a sparse matrix to a given format.\n    Checks the sparse format of spmatrix and converts if necessary.\n    Parameters\n    ----------\n    spmatrix : scipy sparse matrix\n        Input to validate and convert.\n    accept_sparse : string, boolean or list/tuple of strings\n        String[s] representing allowed sparse matrix formats ('csc',\n        'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'). If the input is sparse but\n        not in the allowed format, it will be converted to the first listed\n        format. True allows the input to be any format. False means\n        that a sparse matrix input will raise an error.\n    dtype : string, type or None\n        Data type of result. If None, the dtype of the input is preserved.\n    copy : boolean\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n    force_all_finite : boolean or 'allow-nan', (default=True)\n        Whether to raise an error on np.inf and np.nan in X. The possibilities\n        are:\n        - True: Force all values of X to be finite.\n        - False: accept both np.inf and np.nan in X.\n        - 'allow-nan': accept only np.nan values in X. Values cannot be\n          infinite.\n        .. versionadded:: 0.20\n           ``force_all_finite`` accepts the string ``'allow-nan'``.\n    Returns\n    -------\n    spmatrix_converted : scipy sparse matrix.\n        Matrix that is ensured to have an allowed type.\n    \"\"\"", "\n", "if", "dtype", "is", "None", ":", "\n", "        ", "dtype", "=", "spmatrix", ".", "dtype", "\n", "\n", "", "changed_format", "=", "False", "\n", "\n", "if", "isinstance", "(", "accept_sparse", ",", "str", ")", ":", "\n", "        ", "accept_sparse", "=", "[", "accept_sparse", "]", "\n", "\n", "# Indices dtype validation", "\n", "", "_check_large_sparse", "(", "spmatrix", ",", "accept_large_sparse", ")", "\n", "\n", "if", "accept_sparse", "is", "False", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "\"A sparse matrix was passed, but dense \"", "\n", "\"data is required. Use X.toarray() to \"", "\n", "\"convert to a dense numpy array.\"", "\n", ")", "\n", "", "elif", "isinstance", "(", "accept_sparse", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "if", "len", "(", "accept_sparse", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"When providing 'accept_sparse' \"", "\n", "\"as a tuple or list, it must contain at \"", "\n", "\"least one string value.\"", "\n", ")", "\n", "# ensure correct sparse format", "\n", "", "if", "spmatrix", ".", "format", "not", "in", "accept_sparse", ":", "\n", "# create new with correct sparse", "\n", "            ", "spmatrix", "=", "spmatrix", ".", "asformat", "(", "accept_sparse", "[", "0", "]", ")", "\n", "changed_format", "=", "True", "\n", "", "", "elif", "accept_sparse", "is", "not", "True", ":", "\n", "# any other type", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Parameter 'accept_sparse' should be a string, \"", "\n", "\"boolean or list of strings. You provided \"", "\n", "\"'accept_sparse={}'.\"", ".", "format", "(", "accept_sparse", ")", "\n", ")", "\n", "\n", "", "if", "dtype", "!=", "spmatrix", ".", "dtype", ":", "\n", "# convert dtype", "\n", "        ", "spmatrix", "=", "spmatrix", ".", "astype", "(", "dtype", ")", "\n", "", "elif", "copy", "and", "not", "changed_format", ":", "\n", "# force copy", "\n", "        ", "spmatrix", "=", "spmatrix", ".", "copy", "(", ")", "\n", "\n", "", "if", "force_all_finite", ":", "\n", "        ", "if", "not", "hasattr", "(", "spmatrix", ",", "\"data\"", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Can't check %s sparse matrix for nan or inf.\"", "%", "spmatrix", ".", "format", ",", "\n", "stacklevel", "=", "2", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "_assert_all_finite", "(", "spmatrix", ".", "data", ",", "allow_nan", "=", "force_all_finite", "==", "\"allow-nan\"", ")", "\n", "\n", "", "", "return", "spmatrix", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._ensure_no_complex_data": [[299, 307], ["hasattr", "hasattr", "ValueError"], "function", ["None"], ["", "def", "_ensure_no_complex_data", "(", "array", ")", ":", "\n", "    ", "if", "(", "\n", "hasattr", "(", "array", ",", "\"dtype\"", ")", "\n", "and", "array", ".", "dtype", "is", "not", "None", "\n", "and", "hasattr", "(", "array", ".", "dtype", ",", "\"kind\"", ")", "\n", "and", "array", ".", "dtype", ".", "kind", "==", "\"c\"", "\n", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Complex data not supported\\n\"", "\"{}\\n\"", ".", "format", "(", "array", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_consistent_length": [[309, 324], ["numpy.unique", "checks._num_samples", "len", "ValueError", "int"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._num_samples"], ["", "", "def", "check_consistent_length", "(", "*", "arrays", ")", ":", "\n", "    ", "\"\"\"Check that all arrays have consistent first dimensions.\n    Checks whether all objects in arrays have the same shape or length.\n    Parameters\n    ----------\n    *arrays : list or tuple of input objects.\n        Objects that will be checked for consistent length.\n    \"\"\"", "\n", "\n", "lengths", "=", "[", "_num_samples", "(", "X", ")", "for", "X", "in", "arrays", "if", "X", "is", "not", "None", "]", "\n", "uniques", "=", "np", ".", "unique", "(", "lengths", ")", "\n", "if", "len", "(", "uniques", ")", ">", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Found input variables with inconsistent numbers of\"", "\n", "\" samples: %r\"", "%", "[", "int", "(", "l", ")", "for", "l", "in", "lengths", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array": [[327, 595], ["getattr", "isinstance", "scipy.issparse", "warnings.warn", "isinstance", "hasattr", "hasattr", "hasattr", "numpy.array", "all", "ValueError", "isinstance", "checks._ensure_no_complex_data", "checks._ensure_sparse_format", "checks._ensure_no_complex_data", "checks._num_samples", "warnings.warn", "numpy.may_share_memory", "numpy.array", "warnings.warn", "numpy.result_type", "warnings.catch_warnings", "numpy.issubdtype", "warnings.warn", "np.asarray.astype", "ValueError", "checks._assert_all_finite", "ValueError", "ValueError", "set", "isinstance", "warnings.simplefilter", "ValueError", "ValueError", "numpy.asarray", "np.asarray.astype", "numpy.asarray", "ValueError", "map", "checks._assert_all_finite", "sorted", "numpy.dtype", "set"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._ensure_no_complex_data", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._ensure_sparse_format", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._ensure_no_complex_data", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._num_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._assert_all_finite", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._assert_all_finite"], ["", "", "def", "check_array", "(", "\n", "array", ",", "\n", "accept_sparse", "=", "False", ",", "\n", "accept_large_sparse", "=", "True", ",", "\n", "dtype", "=", "\"numeric\"", ",", "\n", "order", "=", "None", ",", "\n", "copy", "=", "False", ",", "\n", "force_all_finite", "=", "True", ",", "\n", "ensure_2d", "=", "True", ",", "\n", "allow_nd", "=", "False", ",", "\n", "ensure_min_samples", "=", "1", ",", "\n", "ensure_min_features", "=", "1", ",", "\n", "warn_on_dtype", "=", "None", ",", "\n", "estimator", "=", "None", ",", "\n", ")", ":", "\n", "\n", "    ", "\"\"\"Input validation on an array, list, sparse matrix or similar.\n    By default, the input is checked to be a non-empty 2D array containing\n    only finite values. If the dtype of the array is object, attempt\n    converting to float, raising on failure.\n    Parameters\n    ----------\n    array : object\n        Input object to check / convert.\n    accept_sparse : string, boolean or list/tuple of strings (default=False)\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n    accept_large_sparse : bool (default=True)\n        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by\n        accept_sparse, accept_large_sparse=False will cause it to be accepted\n        only if its indices are stored with a 32-bit dtype.\n        .. versionadded:: 0.20\n    dtype : string, type, list of types or None (default=\"numeric\")\n        Data type of result. If None, the dtype of the input is preserved.\n        If \"numeric\", dtype is preserved unless array.dtype is object.\n        If dtype is a list of types, conversion on the first type is only\n        performed if the dtype of the input is not in the list.\n    order : 'F', 'C' or None (default=None)\n        Whether an array will be forced to be fortran or c-style.\n        When order is None (default), then if copy=False, nothing is ensured\n        about the memory layout of the output array; otherwise (copy=True)\n        the memory layout of the returned array is kept as close as possible\n        to the original array.\n    copy : boolean (default=False)\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n    force_all_finite : boolean or 'allow-nan', (default=True)\n        Whether to raise an error on np.inf and np.nan in array. The\n        possibilities are:\n        - True: Force all values of array to be finite.\n        - False: accept both np.inf and np.nan in array.\n        - 'allow-nan': accept only np.nan values in array. Values cannot\n          be infinite.\n        For object dtyped data, only np.nan is checked and not np.inf.\n        .. versionadded:: 0.20\n           ``force_all_finite`` accepts the string ``'allow-nan'``.\n    ensure_2d : boolean (default=True)\n        Whether to raise a value error if array is not 2D.\n    allow_nd : boolean (default=False)\n        Whether to allow array.ndim > 2.\n    ensure_min_samples : int (default=1)\n        Make sure that the array has a minimum number of samples in its first\n        axis (rows for a 2D array). Setting to 0 disables this check.\n    ensure_min_features : int (default=1)\n        Make sure that the 2D array has some minimum number of features\n        (columns). The default value of 1 rejects empty data.\n        This check is only enforced when the input data has effectively 2\n        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0\n        disables this check.\n    warn_on_dtype : boolean or None, optional (default=None)\n        Raise DataConversionWarning if the dtype of the input data structure\n        does not match the requested dtype, causing a memory copy.\n        .. deprecated:: 0.21\n            ``warn_on_dtype`` is deprecated in version 0.21 and will be\n            removed in 0.23.\n    estimator : str or estimator instance (default=None)\n        If passed, include the name of the estimator in warning messages.\n    Returns\n    -------\n    array_converted : object\n        The converted and validated array.\n    \"\"\"", "\n", "# warn_on_dtype deprecation", "\n", "if", "warn_on_dtype", "is", "not", "None", ":", "\n", "        ", "warnings", ".", "warn", "(", "\n", "\"'warn_on_dtype' is deprecated in version 0.21 and will be \"", "\n", "\"removed in 0.23. Don't set `warn_on_dtype` to remove this \"", "\n", "\"warning.\"", ",", "\n", "FutureWarning", ",", "\n", "stacklevel", "=", "2", ",", "\n", ")", "\n", "\n", "# store reference to original array to check if copy is needed when", "\n", "# function returns", "\n", "", "array_orig", "=", "array", "\n", "\n", "# store whether originally we wanted numeric dtype", "\n", "dtype_numeric", "=", "isinstance", "(", "dtype", ",", "str", ")", "and", "dtype", "==", "\"numeric\"", "\n", "\n", "dtype_orig", "=", "getattr", "(", "array", ",", "\"dtype\"", ",", "None", ")", "\n", "if", "not", "hasattr", "(", "dtype_orig", ",", "\"kind\"", ")", ":", "\n", "# not a data type (e.g. a column named dtype in a pandas DataFrame)", "\n", "        ", "dtype_orig", "=", "None", "\n", "\n", "# check if the object contains several dtypes (typically a pandas", "\n", "# DataFrame), and store them. If not, store None.", "\n", "", "dtypes_orig", "=", "None", "\n", "if", "hasattr", "(", "array", ",", "\"dtypes\"", ")", "and", "hasattr", "(", "array", ".", "dtypes", ",", "\"__array__\"", ")", ":", "\n", "        ", "dtypes_orig", "=", "np", ".", "array", "(", "array", ".", "dtypes", ")", "\n", "if", "all", "(", "isinstance", "(", "dtype", ",", "np", ".", "dtype", ")", "for", "dtype", "in", "dtypes_orig", ")", ":", "\n", "            ", "dtype_orig", "=", "np", ".", "result_type", "(", "*", "array", ".", "dtypes", ")", "\n", "\n", "", "", "if", "dtype_numeric", ":", "\n", "        ", "if", "dtype_orig", "is", "not", "None", "and", "dtype_orig", ".", "kind", "==", "\"O\"", ":", "\n", "# if input is object, convert to float.", "\n", "            ", "dtype", "=", "np", ".", "float64", "\n", "", "else", ":", "\n", "            ", "dtype", "=", "None", "\n", "\n", "", "", "if", "isinstance", "(", "dtype", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "        ", "if", "dtype_orig", "is", "not", "None", "and", "dtype_orig", "in", "dtype", ":", "\n", "# no dtype conversion required", "\n", "            ", "dtype", "=", "None", "\n", "", "else", ":", "\n", "# dtype conversion required. Let's select the first element of the", "\n", "# list of accepted types.", "\n", "            ", "dtype", "=", "dtype", "[", "0", "]", "\n", "\n", "", "", "if", "force_all_finite", "not", "in", "(", "True", ",", "False", ",", "\"allow-nan\"", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "'force_all_finite should be a bool or \"allow-nan\"'", "\n", "\". Got {!r} instead\"", ".", "format", "(", "force_all_finite", ")", "\n", ")", "\n", "\n", "", "if", "estimator", "is", "not", "None", ":", "\n", "        ", "if", "isinstance", "(", "estimator", ",", "str", ")", ":", "\n", "            ", "estimator_name", "=", "estimator", "\n", "", "else", ":", "\n", "            ", "estimator_name", "=", "estimator", ".", "__class__", ".", "__name__", "\n", "", "", "else", ":", "\n", "        ", "estimator_name", "=", "\"Estimator\"", "\n", "", "context", "=", "\" by %s\"", "%", "estimator_name", "if", "estimator", "is", "not", "None", "else", "\"\"", "\n", "\n", "if", "sp", ".", "issparse", "(", "array", ")", ":", "\n", "        ", "_ensure_no_complex_data", "(", "array", ")", "\n", "array", "=", "_ensure_sparse_format", "(", "\n", "array", ",", "\n", "accept_sparse", "=", "accept_sparse", ",", "\n", "dtype", "=", "dtype", ",", "\n", "copy", "=", "copy", ",", "\n", "force_all_finite", "=", "force_all_finite", ",", "\n", "accept_large_sparse", "=", "accept_large_sparse", ",", "\n", ")", "\n", "", "else", ":", "\n", "# If np.array(..) gives ComplexWarning, then we convert the warning", "\n", "# to an error. This is needed because specifying a non complex", "\n", "# dtype to the function converts complex to real dtype,", "\n", "# thereby passing the test made in the lines following the scope", "\n", "# of warnings context manager.", "\n", "        ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "warnings", ".", "simplefilter", "(", "\"error\"", ",", "ComplexWarning", ")", "\n", "if", "dtype", "is", "not", "None", "and", "np", ".", "dtype", "(", "dtype", ")", ".", "kind", "in", "\"iu\"", ":", "\n", "# Conversion float -> int should not contain NaN or", "\n", "# inf (numpy#14412). We cannot use casting='safe' because", "\n", "# then conversion float -> int would be disallowed.", "\n", "                    ", "array", "=", "np", ".", "asarray", "(", "array", ",", "order", "=", "order", ")", "\n", "if", "array", ".", "dtype", ".", "kind", "==", "\"f\"", ":", "\n", "                        ", "_assert_all_finite", "(", "array", ",", "allow_nan", "=", "False", ",", "msg_dtype", "=", "dtype", ")", "\n", "", "array", "=", "array", ".", "astype", "(", "dtype", ",", "casting", "=", "\"unsafe\"", ",", "copy", "=", "False", ")", "\n", "", "else", ":", "\n", "                    ", "array", "=", "np", ".", "asarray", "(", "array", ",", "order", "=", "order", ",", "dtype", "=", "dtype", ")", "\n", "", "", "except", "ComplexWarning", ":", "\n", "                ", "raise", "ValueError", "(", "\"Complex data not supported\\n\"", "\"{}\\n\"", ".", "format", "(", "array", ")", ")", "\n", "\n", "# It is possible that the np.array(..) gave no warning. This happens", "\n", "# when no dtype conversion happened, for example dtype = None. The", "\n", "# result is that np.array(..) produces an array of complex dtype", "\n", "# and we need to catch and raise exception for such cases.", "\n", "", "", "_ensure_no_complex_data", "(", "array", ")", "\n", "\n", "if", "ensure_2d", ":", "\n", "# If input is scalar raise error", "\n", "            ", "if", "array", ".", "ndim", "==", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Expected 2D array, got scalar array instead:\\narray={}.\\n\"", "\n", "\"Reshape your data either using array.reshape(-1, 1) if \"", "\n", "\"your data has a single feature or array.reshape(1, -1) \"", "\n", "\"if it contains a single sample.\"", ".", "format", "(", "array", ")", "\n", ")", "\n", "# If input is 1D raise error", "\n", "", "if", "array", ".", "ndim", "==", "1", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Expected 2D array, got 1D array instead:\\narray={}.\\n\"", "\n", "\"Reshape your data either using array.reshape(-1, 1) if \"", "\n", "\"your data has a single feature or array.reshape(1, -1) \"", "\n", "\"if it contains a single sample.\"", ".", "format", "(", "array", ")", "\n", ")", "\n", "\n", "# in the future np.flexible dtypes will be handled like object dtypes", "\n", "", "", "if", "dtype_numeric", "and", "np", ".", "issubdtype", "(", "array", ".", "dtype", ",", "np", ".", "flexible", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "\n", "\"Beginning in version 0.22, arrays of bytes/strings will be \"", "\n", "\"converted to decimal numbers if dtype='numeric'. \"", "\n", "\"It is recommended that you convert the array to \"", "\n", "\"a float dtype before using it in scikit-learn, \"", "\n", "\"for example by using \"", "\n", "\"your_array = your_array.astype(np.float64).\"", ",", "\n", "FutureWarning", ",", "\n", "stacklevel", "=", "2", ",", "\n", ")", "\n", "\n", "# make sure we actually converted to numeric:", "\n", "", "if", "dtype_numeric", "and", "array", ".", "dtype", ".", "kind", "==", "\"O\"", ":", "\n", "            ", "array", "=", "array", ".", "astype", "(", "np", ".", "float64", ")", "\n", "", "if", "not", "allow_nd", "and", "array", ".", "ndim", ">=", "3", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Found array with dim %d. %s expected <= 2.\"", "\n", "%", "(", "array", ".", "ndim", ",", "estimator_name", ")", "\n", ")", "\n", "\n", "", "if", "force_all_finite", ":", "\n", "            ", "_assert_all_finite", "(", "array", ",", "allow_nan", "=", "force_all_finite", "==", "\"allow-nan\"", ")", "\n", "\n", "", "", "if", "ensure_min_samples", ">", "0", ":", "\n", "        ", "n_samples", "=", "_num_samples", "(", "array", ")", "\n", "if", "n_samples", "<", "ensure_min_samples", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Found array with %d sample(s) (shape=%s) while a\"", "\n", "\" minimum of %d is required%s.\"", "\n", "%", "(", "n_samples", ",", "array", ".", "shape", ",", "ensure_min_samples", ",", "context", ")", "\n", ")", "\n", "\n", "", "", "if", "ensure_min_features", ">", "0", "and", "array", ".", "ndim", "==", "2", ":", "\n", "        ", "n_features", "=", "array", ".", "shape", "[", "1", "]", "\n", "if", "n_features", "<", "ensure_min_features", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"Found array with %d feature(s) (shape=%s) while\"", "\n", "\" a minimum of %d is required%s.\"", "\n", "%", "(", "n_features", ",", "array", ".", "shape", ",", "ensure_min_features", ",", "context", ")", "\n", ")", "\n", "\n", "", "", "if", "warn_on_dtype", "and", "dtype_orig", "is", "not", "None", "and", "array", ".", "dtype", "!=", "dtype_orig", ":", "\n", "        ", "msg", "=", "\"Data with input dtype %s was converted to %s%s.\"", "%", "(", "\n", "dtype_orig", ",", "\n", "array", ".", "dtype", ",", "\n", "context", ",", "\n", ")", "\n", "warnings", ".", "warn", "(", "msg", ",", "DataConversionWarning", ",", "stacklevel", "=", "2", ")", "\n", "\n", "", "if", "copy", "and", "np", ".", "may_share_memory", "(", "array", ",", "array_orig", ")", ":", "\n", "        ", "array", "=", "np", ".", "array", "(", "array", ",", "dtype", "=", "dtype", ",", "order", "=", "order", ")", "\n", "\n", "", "if", "warn_on_dtype", "and", "dtypes_orig", "is", "not", "None", "and", "{", "array", ".", "dtype", "}", "!=", "set", "(", "dtypes_orig", ")", ":", "\n", "# if there was at the beginning some other types than the final one", "\n", "# (for instance in a DataFrame that can contain several dtypes) then", "\n", "# some data must have been converted", "\n", "        ", "msg", "=", "\"Data with input dtype %s were all converted to %s%s.\"", "%", "(", "\n", "\", \"", ".", "join", "(", "map", "(", "str", ",", "sorted", "(", "set", "(", "dtypes_orig", ")", ")", ")", ")", ",", "\n", "array", ".", "dtype", ",", "\n", "context", ",", "\n", ")", "\n", "warnings", ".", "warn", "(", "msg", ",", "DataConversionWarning", ",", "stacklevel", "=", "3", ")", "\n", "\n", "", "return", "array", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._check_large_sparse": [[597, 614], ["X.getformat", "X.getformat", "getattr", "ValueError"], "function", ["None"], ["", "def", "_check_large_sparse", "(", "X", ",", "accept_large_sparse", "=", "False", ")", ":", "\n", "    ", "\"\"\"Raise a ValueError if X has 64bit indices and accept_large_sparse=False\n    \"\"\"", "\n", "if", "not", "accept_large_sparse", ":", "\n", "        ", "supported_indices", "=", "[", "\"int32\"", "]", "\n", "if", "X", ".", "getformat", "(", ")", "==", "\"coo\"", ":", "\n", "            ", "index_keys", "=", "[", "\"col\"", ",", "\"row\"", "]", "\n", "", "elif", "X", ".", "getformat", "(", ")", "in", "[", "\"csr\"", ",", "\"csc\"", ",", "\"bsr\"", "]", ":", "\n", "            ", "index_keys", "=", "[", "\"indices\"", ",", "\"indptr\"", "]", "\n", "", "else", ":", "\n", "            ", "return", "\n", "", "for", "key", "in", "index_keys", ":", "\n", "            ", "indices_datatype", "=", "getattr", "(", "X", ",", "key", ")", ".", "dtype", "\n", "if", "indices_datatype", "not", "in", "supported_indices", ":", "\n", "                ", "raise", "ValueError", "(", "\n", "\"Only sparse matrices with 32-bit integer\"", "\n", "\" indices are accepted. Got %s indices.\"", "%", "indices_datatype", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_X_y": [[617, 761], ["checks.check_array", "checks.check_consistent_length", "ValueError", "checks.check_array", "checks.column_or_1d", "checks._assert_all_finite", "y.astype.astype", "y.astype.astype"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_consistent_length", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.check_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks.column_or_1d", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.checks._assert_all_finite"], ["", "", "", "", "def", "check_X_y", "(", "\n", "X", ",", "\n", "y", ",", "\n", "accept_sparse", "=", "False", ",", "\n", "accept_large_sparse", "=", "True", ",", "\n", "dtype", "=", "\"numeric\"", ",", "\n", "order", "=", "None", ",", "\n", "copy", "=", "False", ",", "\n", "force_all_finite", "=", "True", ",", "\n", "ensure_2d", "=", "True", ",", "\n", "allow_nd", "=", "False", ",", "\n", "multi_output", "=", "False", ",", "\n", "ensure_min_samples", "=", "1", ",", "\n", "ensure_min_features", "=", "1", ",", "\n", "y_numeric", "=", "False", ",", "\n", "warn_on_dtype", "=", "None", ",", "\n", "estimator", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Input validation for standard estimators.\n    Checks X and y for consistent length, enforces X to be 2D and y 1D. By\n    default, X is checked to be non-empty and containing only finite values.\n    Standard input checks are also applied to y, such as checking that y\n    does not have np.nan or np.inf targets. For multi-label y, set\n    multi_output=True to allow 2D and sparse y. If the dtype of X is\n    object, attempt converting to float, raising on failure.\n    Parameters\n    ----------\n    X : nd-array, list or sparse matrix\n        Input data.\n    y : nd-array, list or sparse matrix\n        Labels.\n    accept_sparse : boolean , string or list of string (default=False)\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n    accept_large_sparse : bool (default=True)\n        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by\n        accept_sparse, accept_large_sparse will cause it to be accepted only\n        if its indices are stored with a 32-bit dtype.\n        .. versionadded:: 0.20\n    dtype : string, type, list of types or None (default=\"numeric\")\n        Data type of result. If None, the dtype of the input is preserved.\n        If \"numeric\", dtype is preserved unless array.dtype is object.\n        If dtype is a list of types, conversion on the first type is only\n        performed if the dtype of the input is not in the list.\n    order : 'F', 'C' or None (default=None)\n        Whether an array will be forced to be fortran or c-style.\n    copy : boolean (default=False)\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n    force_all_finite : boolean or 'allow-nan', (default=True)\n        Whether to raise an error on np.inf and np.nan in X. This parameter\n        does not influence whether y can have np.inf or np.nan values.\n        The possibilities are:\n        - True: Force all values of X to be finite.\n        - False: accept both np.inf and np.nan in X.\n        - 'allow-nan': accept only np.nan values in X. Values cannot be\n          infinite.\n        .. versionadded:: 0.20\n           ``force_all_finite`` accepts the string ``'allow-nan'``.\n    ensure_2d : boolean (default=True)\n        Whether to raise a value error if X is not 2D.\n    allow_nd : boolean (default=False)\n        Whether to allow X.ndim > 2.\n    multi_output : boolean (default=False)\n        Whether to allow 2D y (array or sparse matrix). If false, y will be\n        validated as a vector. y cannot have np.nan or np.inf values if\n        multi_output=True.\n    ensure_min_samples : int (default=1)\n        Make sure that X has a minimum number of samples in its first\n        axis (rows for a 2D array).\n    ensure_min_features : int (default=1)\n        Make sure that the 2D array has some minimum number of features\n        (columns). The default value of 1 rejects empty data.\n        This check is only enforced when X has effectively 2 dimensions or\n        is originally 1D and ``ensure_2d`` is True. Setting to 0 disables\n        this check.\n    y_numeric : boolean (default=False)\n        Whether to ensure that y has a numeric type. If dtype of y is object,\n        it is converted to float32. Should only be used for regression\n        algorithms.\n    warn_on_dtype : boolean or None, optional (default=None)\n        Raise DataConversionWarning if the dtype of the input data structure\n        does not match the requested dtype, causing a memory copy.\n        .. deprecated:: 0.21\n            ``warn_on_dtype`` is deprecated in version 0.21 and will be\n             removed in 0.23.\n    estimator : str or estimator instance (default=None)\n        If passed, include the name of the estimator in warning messages.\n    Returns\n    -------\n    X_converted : object\n        The converted and validated X.\n    y_converted : object\n        The converted and validated y.\n    \"\"\"", "\n", "if", "y", "is", "None", ":", "\n", "        ", "raise", "ValueError", "(", "\"y cannot be None\"", ")", "\n", "\n", "", "X", "=", "check_array", "(", "\n", "X", ",", "\n", "accept_sparse", "=", "accept_sparse", ",", "\n", "accept_large_sparse", "=", "accept_large_sparse", ",", "\n", "dtype", "=", "dtype", ",", "\n", "order", "=", "order", ",", "\n", "copy", "=", "copy", ",", "\n", "force_all_finite", "=", "force_all_finite", ",", "\n", "ensure_2d", "=", "ensure_2d", ",", "\n", "allow_nd", "=", "allow_nd", ",", "\n", "ensure_min_samples", "=", "ensure_min_samples", ",", "\n", "ensure_min_features", "=", "ensure_min_features", ",", "\n", "warn_on_dtype", "=", "warn_on_dtype", ",", "\n", "estimator", "=", "estimator", ",", "\n", ")", "\n", "\n", "if", "multi_output", ":", "\n", "        ", "y", "=", "check_array", "(", "y", ",", "\"csr\"", ",", "force_all_finite", "=", "True", ",", "ensure_2d", "=", "False", ",", "dtype", "=", "None", ")", "\n", "", "else", ":", "\n", "# y = column_or_1d(y, warn=True)", "\n", "        ", "y", "=", "column_or_1d", "(", "y", ",", "warn", "=", "True", ")", "\n", "_assert_all_finite", "(", "y", ")", "\n", "\n", "# b\tboolean", "\n", "# i\tsigned integer", "\n", "# u\tunsigned integer", "\n", "# f\tfloating-point", "\n", "# c\tcomplex floating-point", "\n", "# m\ttimedelta", "\n", "# M\tdatetime", "\n", "# O\tobject", "\n", "# S\t(byte-)string", "\n", "# U\tUnicode", "\n", "# V\tvoid", "\n", "# TODO: improve this", "\n", "", "if", "y_numeric", "and", "y", ".", "dtype", ".", "kind", "in", "{", "\"O\"", ",", "\"i\"", ",", "\"b\"", ",", "\"u\"", ",", "\"U\"", ",", "\"S\"", "}", ":", "\n", "        ", "y", "=", "y", ".", "astype", "(", "\"float32\"", ")", "\n", "", "elif", "y", ".", "dtype", "==", "\"float64\"", ":", "\n", "        ", "y", "=", "y", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "", "check_consistent_length", "(", "X", ",", "y", ")", "\n", "\n", "return", "X", ",", "y", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.String.__new__": [[11, 13], ["str.__new__"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.String.__new__"], ["def", "__new__", "(", "cls", ",", "*", "args", ",", "**", "kw", ")", ":", "\n", "        ", "return", "str", ".", "__new__", "(", "cls", ",", "*", "args", ",", "**", "kw", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.String.__call__": [[14, 16], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.types.get_array_2d_type": [[37, 42], ["os.getenv", "types.String"], "function", ["None"], ["def", "get_array_2d_type", "(", "dtype", "=", "None", ")", ":", "\n", "    ", "if", "os", ".", "getenv", "(", "\"NUMBA_DISABLE_JIT\"", ",", "None", ")", "==", "\"1\"", ":", "\n", "        ", "return", "String", "(", "\"\"", ")", "\n", "", "else", ":", "\n", "        ", "return", "dtype", "[", ":", ",", ":", ":", "1", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.__init__": [[23, 48], ["set", "numpy.zeros", "range"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "n_classes", ",", "dirichlet", "=", "None", ")", ":", "\n", "        ", "\"\"\"Instantiates a `OnlineDummyClassifier` instance.\n\n        Parameters\n        ----------\n        n_classes : :obj:`int`\n            Number of expected classes in the labels. This is required since we\n            don't know the number of classes in advance in a online setting.\n\n        dirichlet : :obj:`float` or :obj:`None`, default = `None`\n            Regularization level of the class frequencies used for predictions in each\n            node. Default is dirichlet=0.5 for n_classes=2 and dirichlet=0.01 otherwise.\n\n        \"\"\"", "\n", "self", ".", "iteration", "=", "0", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "_classes", "=", "set", "(", "range", "(", "n_classes", ")", ")", "\n", "if", "dirichlet", "is", "None", ":", "\n", "            ", "if", "self", ".", "n_classes", "==", "2", ":", "\n", "                ", "self", ".", "dirichlet", "=", "0.5", "\n", "", "else", ":", "\n", "                ", "self", ".", "dirichlet", "=", "0.01", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "dirichlet", "=", "dirichlet", "\n", "", "self", ".", "counts", "=", "np", ".", "zeros", "(", "(", "n_classes", ",", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit": [[49, 79], ["y.max", "y.min", "ValueError", "ValueError", "int"], "methods", ["None"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", ",", "classes", "=", "None", ")", ":", "\n", "        ", "\"\"\"Updates the classifier with the given batch of samples.\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray` or :obj:`scipy.sparse.csr_matrix`, shape=(n_samples, n_features)\n            Input features matrix.\n\n        y : :obj:`np.ndarray`\n            Input labels vector.\n\n        classes : :obj:`None`\n            Must not be used, only here for backwards compatibility\n\n        Returns\n        -------\n        output : :obj:`OnlineDummyClassifier`\n            Updated instance of `OnlineDummyClassifier`\n\n        \"\"\"", "\n", "if", "y", ".", "min", "(", ")", "<", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"All the values in `y` must be non-negative\"", ")", "\n", "", "y_max", "=", "y", ".", "max", "(", ")", "\n", "if", "y_max", "not", "in", "self", ".", "_classes", ":", "\n", "            ", "raise", "ValueError", "(", "\"n_classes=%d while y.max()=%d\"", "%", "(", "self", ".", "n_classes", ",", "y_max", ")", ")", "\n", "\n", "", "for", "yi", "in", "y", ":", "\n", "            ", "self", ".", "counts", "[", "int", "(", "yi", ")", "]", "+=", "1", "\n", "self", ".", "iteration", "+=", "1", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba": [[80, 106], ["numpy.tile", "RuntimeError"], "methods", ["None"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predicts the class probabilities for the given features vectors\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray` or :obj:`scipy.sparse.csr_matrix`, shape=(n_samples, n_features)\n            Input features matrix to predict for.\n\n        Returns\n        -------\n        output : :obj:`np.ndarray`, shape=(n_samples, n_classes)\n            Returns the predicted class probabilities for the input features\n\n        \"\"\"", "\n", "if", "self", ".", "iteration", "==", "0", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "\"You must call `partial_fit` before calling `predict_proba`\"", "\n", ")", "\n", "\n", "", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "dirichet", "=", "self", ".", "dirichlet", "\n", "n_classes", "=", "self", ".", "n_classes", "\n", "scores", "=", "(", "self", ".", "counts", "+", "dirichet", ")", "/", "(", "self", ".", "iteration", "+", "n_classes", "*", "dirichet", ")", "\n", "# scores = self.counts / self.n_samples", "\n", "probas", "=", "np", ".", "tile", "(", "scores", ",", "reps", "=", "(", "n_samples", ",", "1", ")", ")", "\n", "return", "probas", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict": [[107, 123], ["dummy.OnlineDummyClassifier.predict_proba", "dummy.OnlineDummyClassifier.argmax"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"Predicts the labels for the given features vectors\n\n        Parameters\n        ----------\n        X : :obj:`np.ndarray` or :obj:`scipy.sparse.csr_matrix`, shape=(n_samples, n_features)\n            Input features matrix to predict for.\n\n        Returns\n        -------\n        output : :obj:`np.ndarray`, shape=(n_samples,)\n            Returns the predicted labels for the input features\n\n        \"\"\"", "\n", "scores", "=", "self", ".", "predict_proba", "(", "X", ")", "\n", "return", "scores", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.n_classes": [[129, 142], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "n_classes", ".", "setter", "\n", "def", "n_classes", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "iteration", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `n_classes` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "int", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_classes` must be of type `int`\"", ")", "\n", "", "elif", "val", "<", "2", ":", "\n", "                ", "raise", "ValueError", "(", "\"`n_classes` must be >= 2\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_n_classes", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.dirichlet": [[149, 162], ["ValueError", "isinstance", "ValueError", "ValueError"], "methods", ["None"], ["", "@", "dirichlet", ".", "setter", "\n", "def", "dirichlet", "(", "self", ",", "val", ")", ":", "\n", "        ", "if", "self", ".", "iteration", ">", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You cannot modify `dirichlet` after calling `partial_fit`\"", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "not", "isinstance", "(", "val", ",", "float", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"`dirichlet` must be of type `float`\"", ")", "\n", "", "elif", "val", "<=", "0", ":", "\n", "                ", "raise", "ValueError", "(", "\"`dirichlet` must be > 0\"", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_dirichlet", "=", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.__repr__": [[163, 168], ["None"], "methods", ["None"], ["", "", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "r", "=", "\"OnlineDummyClassifier\"", "\n", "r", "+=", "\"(n_classes={n_classes}, \"", ".", "format", "(", "n_classes", "=", "self", ".", "n_classes", ")", "\n", "r", "+=", "\"dirichlet={dirichlet})\"", ".", "format", "(", "dirichlet", "=", "self", ".", "dirichlet", ")", "\n", "return", "r", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.NodesClassifier.__init__": [[85, 104], ["node_collection.init_nodes", "node_collection.init_nodes_classifier"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes_classifier"], ["def", "__init__", "(", "\n", "self", ",", "n_features", ",", "n_classes", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", ":", "\n", "        ", "\"\"\"Instantiates a `NodesClassifier` instance.\n\n        Parameters\n        ----------\n        n_features : :obj:`int`\n            Number of features used during training.\n\n        n_classes : :obj:`int`\n            Number of expected classes in the labels.\n\n        n_samples_increment : :obj:`int`\n            The minimum amount of memory which is pre-allocated each time extra memory\n            is required for new nodes.\n        \"\"\"", "\n", "init_nodes", "(", "self", ",", "n_features", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "init_nodes_classifier", "(", "self", ",", "n_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.NodesRegressor.__init__": [[133, 151], ["node_collection.init_nodes", "node_collection.init_nodes_regressor"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes_regressor"], ["def", "__init__", "(", "self", ",", "n_features", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", ")", ":", "\n", "        ", "\"\"\"Instantiates a `NodesClassifier` instance.\n\n        Parameters\n        ----------\n        n_features : :obj:`int`\n            Number of features used during training.\n\n        n_classes : :obj:`int`\n            Number of expected classes in the labels.\n\n        n_samples_increment : :obj:`int`\n            The minimum amount of memory which is pre-allocated each time extra memory\n            is required for new nodes.\n\n        \"\"\"", "\n", "init_nodes", "(", "self", ",", "n_features", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "init_nodes_regressor", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes_arrays": [[153, 187], ["numba.njit", "numpy.zeros", "numpy.ones", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "types.void", "types.void", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "", "@", "njit", "(", "\n", "[", "\n", "void", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ",", "uint32", ")", ",", "\n", "void", "(", "get_type", "(", "NodesRegressor", ")", ",", "uint32", ",", "uint32", ")", ",", "\n", "]", "\n", ")", "\n", "def", "init_nodes_arrays", "(", "nodes", ",", "n_nodes_capacity", ",", "n_features", ")", ":", "\n", "    ", "\"\"\"Initializes the nodes arrays given their capacity\n\n    Parameters\n    ----------\n    nodes : :obj:`NodesClassifier` or :obj:`NodesRegressor`\n        Object to be initialized\n\n    n_nodes_capacity : :obj:`int`\n        Desired nodes capacity\n\n    n_features : :obj:`int`\n        Number of features used during training.\n    \"\"\"", "\n", "nodes", ".", "index", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "is_leaf", "=", "np", ".", "ones", "(", "n_nodes_capacity", ",", "dtype", "=", "boolean", ")", "\n", "nodes", ".", "depth", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint8", ")", "\n", "nodes", ".", "n_samples", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "parent", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "left", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "right", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "feature", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "weight", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "float32", ")", "\n", "nodes", ".", "log_weight_tree", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "float32", ")", "\n", "nodes", ".", "threshold", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "float32", ")", "\n", "nodes", ".", "time", "=", "np", ".", "zeros", "(", "n_nodes_capacity", ",", "dtype", "=", "float32", ")", "\n", "nodes", ".", "memory_range_min", "=", "np", ".", "zeros", "(", "(", "n_nodes_capacity", ",", "n_features", ")", ",", "dtype", "=", "float32", ")", "\n", "nodes", ".", "memory_range_max", "=", "np", ".", "zeros", "(", "(", "n_nodes_capacity", ",", "n_features", ")", ",", "dtype", "=", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes": [[189, 227], ["numba.njit", "node_collection.init_nodes_arrays", "types.void", "types.void", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes_arrays", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "\n", "void", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ",", "uint32", ",", "uint32", ",", "uint32", ")", ",", "\n", "void", "(", "get_type", "(", "NodesRegressor", ")", ",", "uint32", ",", "uint32", ",", "uint32", ",", "uint32", ")", ",", "\n", "]", "\n", ")", "\n", "def", "init_nodes", "(", "nodes", ",", "n_features", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", ")", ":", "\n", "    ", "\"\"\"Initializes a `Nodes` instance.\n\n    Parameters\n    ----------\n    nodes : :obj:`NodesClassifier` or :obj:`NodesRegressor`\n        Object to be initialized\n\n    n_features : :obj:`int`\n        Number of features used during training.\n\n    n_samples_increment : :obj:`int`\n        The minimum amount of memory which is pre-allocated each time extra memory is\n        required for new nodes.\n\n    n_nodes : :obj:`int`\n        Blabla\n\n    n_nodes_capacity : :obj:`int`\n        Initial required node capacity. If 0, we use 2 * n_samples_increment + 1,\n        otherwise we use the given value (useful for serialization).\n    \"\"\"", "\n", "\n", "if", "n_nodes_capacity", "==", "0", ":", "\n", "# One for root + and twice the number of samples", "\n", "        ", "n_nodes_capacity", "=", "2", "*", "n_samples_increment", "+", "1", "\n", "", "nodes", ".", "n_samples_increment", "=", "n_samples_increment", "\n", "nodes", ".", "n_features", "=", "n_features", "\n", "nodes", ".", "n_nodes_capacity", "=", "n_nodes_capacity", "\n", "nodes", ".", "n_nodes", "=", "n_nodes", "\n", "# Initialize node attributes", "\n", "init_nodes_arrays", "(", "nodes", ",", "n_nodes_capacity", ",", "n_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes_classifier": [[229, 241], ["numba.njit", "numpy.zeros", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ")", ")", "\n", "def", "init_nodes_classifier", "(", "nodes", ",", "n_classes", ")", ":", "\n", "    ", "\"\"\"Initializes a `NodesClassifier` instance.\n\n    Parameters\n    ----------\n    n_classes : :obj:`int`\n        Number of expected classes in the labels.\n\n    \"\"\"", "\n", "nodes", ".", "counts", "=", "np", ".", "zeros", "(", "(", "nodes", ".", "n_nodes_capacity", ",", "n_classes", ")", ",", "dtype", "=", "uint32", ")", "\n", "nodes", ".", "n_classes", "=", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.init_nodes_regressor": [[243, 249], ["numba.njit", "numpy.zeros", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "NodesRegressor", ")", ")", ")", "\n", "def", "init_nodes_regressor", "(", "nodes", ")", ":", "\n", "    ", "\"\"\"Initializes a `NodesRegressor` instance.\n\n    \"\"\"", "\n", "nodes", ".", "mean", "=", "np", ".", "zeros", "(", "nodes", ".", "n_nodes_capacity", ",", "dtype", "=", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes": [[251, 290], ["numba.njit", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "utils.resize_array", "types.void", "types.void", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "void", "(", "get_type", "(", "NodesClassifier", ")", ")", ",", "void", "(", "get_type", "(", "NodesRegressor", ")", ")", ",", "]", "\n", ")", "\n", "def", "reserve_nodes", "(", "nodes", ")", ":", "\n", "    ", "\"\"\"Reserves memory for nodes.\n\n    Parameters\n    ----------\n    nodes : :obj:`Nodes`\n        The collection of nodes.\n    \"\"\"", "\n", "n_nodes_capacity", "=", "nodes", ".", "n_nodes_capacity", "+", "2", "*", "nodes", ".", "n_samples_increment", "+", "1", "\n", "n_nodes", "=", "nodes", ".", "n_nodes", "\n", "# TODO: why is this test useful ?", "\n", "if", "n_nodes_capacity", ">", "nodes", ".", "n_nodes_capacity", ":", "\n", "        ", "nodes", ".", "index", "=", "resize_array", "(", "nodes", ".", "index", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "# By default, a node is a leaf when newly created", "\n", "nodes", ".", "is_leaf", "=", "resize_array", "(", "nodes", ".", "is_leaf", ",", "n_nodes", ",", "n_nodes_capacity", ",", "fill", "=", "1", ")", "\n", "nodes", ".", "depth", "=", "resize_array", "(", "nodes", ".", "depth", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "n_samples", "=", "resize_array", "(", "nodes", ".", "n_samples", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "parent", "=", "resize_array", "(", "nodes", ".", "parent", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "left", "=", "resize_array", "(", "nodes", ".", "left", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "right", "=", "resize_array", "(", "nodes", ".", "right", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "feature", "=", "resize_array", "(", "nodes", ".", "feature", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "weight", "=", "resize_array", "(", "nodes", ".", "weight", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "log_weight_tree", "=", "resize_array", "(", "\n", "nodes", ".", "log_weight_tree", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n", "nodes", ".", "threshold", "=", "resize_array", "(", "nodes", ".", "threshold", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "nodes", ".", "time", "=", "resize_array", "(", "nodes", ".", "time", ",", "n_nodes", ",", "n_nodes_capacity", ")", "\n", "\n", "nodes", ".", "memory_range_min", "=", "resize_array", "(", "\n", "nodes", ".", "memory_range_min", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n", "nodes", ".", "memory_range_max", "=", "resize_array", "(", "\n", "nodes", ".", "memory_range_max", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n", "\n", "", "nodes", ".", "n_nodes_capacity", "=", "n_nodes_capacity", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes_classifier": [[292, 304], ["numba.njit", "node_collection.reserve_nodes", "utils.resize_array", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "NodesClassifier", ")", ")", ")", "\n", "def", "reserve_nodes_classifier", "(", "nodes", ")", ":", "\n", "    ", "\"\"\"Reserves memory for classifier nodes.\n\n    Parameters\n    ----------\n    nodes : :obj:`NodesClassifier`\n        The collection of classifier nodes.\n\n    \"\"\"", "\n", "reserve_nodes", "(", "nodes", ")", "\n", "nodes", ".", "counts", "=", "resize_array", "(", "nodes", ".", "counts", ",", "nodes", ".", "n_nodes", ",", "nodes", ".", "n_nodes_capacity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes_regressor": [[306, 318], ["numba.njit", "node_collection.reserve_nodes", "utils.resize_array", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "NodesRegressor", ")", ")", ")", "\n", "def", "reserve_nodes_regressor", "(", "nodes", ")", ":", "\n", "    ", "\"\"\"Reserves memory for regressor nodes.\n\n    Parameters\n    ----------\n    nodes : :obj:`NodesRegressor`\n        The collection of regressor nodes.\n\n    \"\"\"", "\n", "reserve_nodes", "(", "nodes", ")", "\n", "nodes", ".", "mean", "=", "resize_array", "(", "nodes", ".", "mean", ",", "nodes", ".", "n_nodes", ",", "nodes", ".", "n_nodes_capacity", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node": [[320, 354], ["numba.njit", "types.uint32", "types.uint32", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "\n", "uint32", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ",", "float32", ")", ",", "\n", "uint32", "(", "get_type", "(", "NodesRegressor", ")", ",", "uint32", ",", "float32", ")", ",", "\n", "]", "\n", ")", "\n", "def", "add_node", "(", "nodes", ",", "parent", ",", "time", ")", ":", "\n", "    ", "\"\"\"Adds a node with specified parent and creation time. This functions assumes that\n    a node has been already allocated by \"child\" functions `add_node_classifier` and\n    `add_node_regressor`.\n\n    Parameters\n    ----------\n    nodes : :obj:`Nodes`\n        The collection of nodes.\n\n    parent : :obj:`int`\n        The index of the parent of the new node.\n\n    time : :obj:`float`\n        The creation time of the new node.\n\n    Returns\n    -------\n    output : `int`\n        Index of the new node.\n\n    \"\"\"", "\n", "node_index", "=", "nodes", ".", "n_nodes", "\n", "nodes", ".", "index", "[", "node_index", "]", "=", "node_index", "\n", "nodes", ".", "parent", "[", "node_index", "]", "=", "parent", "\n", "nodes", ".", "time", "[", "node_index", "]", "=", "time", "\n", "nodes", ".", "n_nodes", "+=", "1", "\n", "return", "nodes", ".", "n_nodes", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier": [[356, 382], ["numba.njit", "node_collection.add_node", "types.uint32", "node_collection.reserve_nodes_classifier", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "uint32", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ",", "float32", ")", ")", "\n", "def", "add_node_classifier", "(", "nodes", ",", "parent", ",", "time", ")", ":", "\n", "    ", "\"\"\"Adds a node with specified parent and creation time.\n\n    Parameters\n    ----------\n    nodes : :obj:`Nodes`\n        The collection of nodes.\n\n    parent : :obj:`int`\n        The index of the parent of the new node.\n\n    time : :obj:`float`\n        The creation time of the new node.\n\n    Returns\n    -------\n    output : `int`\n        Index of the new node.\n\n    \"\"\"", "\n", "if", "nodes", ".", "n_nodes", ">=", "nodes", ".", "n_nodes_capacity", ":", "\n", "# We don't have memory for this extra node, so let's create some", "\n", "        ", "reserve_nodes_classifier", "(", "nodes", ")", "\n", "\n", "", "return", "add_node", "(", "nodes", ",", "parent", ",", "time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor": [[384, 410], ["numba.njit", "node_collection.add_node", "types.uint32", "node_collection.reserve_nodes_regressor", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.reserve_nodes_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "uint32", "(", "get_type", "(", "NodesRegressor", ")", ",", "uint32", ",", "float32", ")", ")", "\n", "def", "add_node_regressor", "(", "nodes", ",", "parent", ",", "time", ")", ":", "\n", "    ", "\"\"\"Adds a node with specified parent and creation time.\n\n    Parameters\n    ----------\n    nodes : :obj:`Nodes`\n        The collection of nodes.\n\n    parent : :obj:`int`\n        The index of the parent of the new node.\n\n    time : :obj:`float`\n        The creation time of the new node.\n\n    Returns\n    -------\n    output : `int`\n        Index of the new node.\n\n    \"\"\"", "\n", "if", "nodes", ".", "n_nodes", ">=", "nodes", ".", "n_nodes_capacity", ":", "\n", "# We don't have memory for this extra node, so let's create some", "\n", "        ", "reserve_nodes_regressor", "(", "nodes", ")", "\n", "\n", "", "return", "add_node", "(", "nodes", ",", "parent", ",", "time", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node": [[412, 447], ["numba.njit", "types.void", "types.void", "utils.get_type", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "\n", "[", "\n", "void", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ",", "uint32", ")", ",", "\n", "void", "(", "get_type", "(", "NodesRegressor", ")", ",", "uint32", ",", "uint32", ")", ",", "\n", "]", "\n", ")", "\n", "def", "copy_node", "(", "nodes", ",", "first", ",", "second", ")", ":", "\n", "    ", "\"\"\"Copies the node at index ``first`` into the node at index ``second``.\n\n    Parameters\n    ----------\n    nodes : :obj:`Nodes`\n        The collection of nodes.\n\n    first : :obj:`int`\n        The index of the node to be copied in ``second``.\n\n    second : :obj:`int`\n        The index of the node containing the copy of ``first``.\n\n    \"\"\"", "\n", "# We must NOT copy the index", "\n", "nodes", ".", "is_leaf", "[", "second", "]", "=", "nodes", ".", "is_leaf", "[", "first", "]", "\n", "nodes", ".", "depth", "[", "second", "]", "=", "nodes", ".", "depth", "[", "first", "]", "\n", "nodes", ".", "n_samples", "[", "second", "]", "=", "nodes", ".", "n_samples", "[", "first", "]", "\n", "nodes", ".", "parent", "[", "second", "]", "=", "nodes", ".", "parent", "[", "first", "]", "\n", "nodes", ".", "left", "[", "second", "]", "=", "nodes", ".", "left", "[", "first", "]", "\n", "nodes", ".", "right", "[", "second", "]", "=", "nodes", ".", "right", "[", "first", "]", "\n", "nodes", ".", "feature", "[", "second", "]", "=", "nodes", ".", "feature", "[", "first", "]", "\n", "nodes", ".", "weight", "[", "second", "]", "=", "nodes", ".", "weight", "[", "first", "]", "\n", "nodes", ".", "log_weight_tree", "[", "second", "]", "=", "nodes", ".", "log_weight_tree", "[", "first", "]", "\n", "nodes", ".", "threshold", "[", "second", "]", "=", "nodes", ".", "threshold", "[", "first", "]", "\n", "nodes", ".", "time", "[", "second", "]", "=", "nodes", ".", "time", "[", "first", "]", "\n", "nodes", ".", "memory_range_min", "[", "second", ",", ":", "]", "=", "nodes", ".", "memory_range_min", "[", "first", ",", ":", "]", "\n", "nodes", ".", "memory_range_max", "[", "second", ",", ":", "]", "=", "nodes", ".", "memory_range_max", "[", "first", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_classifier": [[449, 467], ["numba.njit", "node_collection.copy_node", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "NodesClassifier", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "copy_node_classifier", "(", "nodes", ",", "first", ",", "second", ")", ":", "\n", "    ", "\"\"\"Copies the node at index `first` into the node at index `second`.\n\n    Parameters\n    ----------\n    nodes : :obj:`NodesClassifier`\n        The collection of nodes\n\n    first : :obj:`int`\n        The index of the node to be copied in ``second``\n\n    second : :obj:`int`\n        The index of the node containing the copy of ``first``\n\n    \"\"\"", "\n", "copy_node", "(", "nodes", ",", "first", ",", "second", ")", "\n", "nodes", ".", "counts", "[", "second", ",", ":", "]", "=", "nodes", ".", "counts", "[", "first", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_regressor": [[469, 487], ["numba.njit", "node_collection.copy_node", "types.void", "utils.get_type"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type"], ["", "@", "njit", "(", "void", "(", "get_type", "(", "NodesRegressor", ")", ",", "uint32", ",", "uint32", ")", ")", "\n", "def", "copy_node_regressor", "(", "nodes", ",", "first", ",", "second", ")", ":", "\n", "    ", "\"\"\"Copies the node at index `first` into the node at index `second`.\n\n    Parameters\n    ----------\n    nodes : :obj:`NodesRegressor`\n        The collection of nodes\n\n    first : :obj:`int`\n        The index of the node to be copied in ``second``\n\n    second : :obj:`int`\n        The index of the node containing the copy of ``first``\n\n    \"\"\"", "\n", "copy_node", "(", "nodes", ",", "first", ",", "second", ")", "\n", "nodes", ".", "mean", "[", "second", "]", "=", "nodes", ".", "mean", "[", "first", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.nodes_classifier_to_dict": [[489, 494], ["getattr"], "function", ["None"], ["", "def", "nodes_classifier_to_dict", "(", "nodes", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "_", "in", "spec_nodes_classifier", ":", "\n", "        ", "d", "[", "key", "]", "=", "getattr", "(", "nodes", ",", "key", ")", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.nodes_regressor_to_dict": [[496, 501], ["getattr"], "function", ["None"], ["", "def", "nodes_regressor_to_dict", "(", "nodes", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "dtype", "in", "spec_nodes_regressor", ":", "\n", "        ", "d", "[", "key", "]", "=", "getattr", "(", "nodes", ",", "key", ")", "\n", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes": [[503, 518], ["None"], "function", ["None"], ["", "def", "dict_to_nodes", "(", "nodes", ",", "nodes_dict", ")", ":", "\n", "    ", "nodes", ".", "index", "[", ":", "]", "=", "nodes_dict", "[", "\"index\"", "]", "\n", "nodes", ".", "is_leaf", "[", ":", "]", "=", "nodes_dict", "[", "\"is_leaf\"", "]", "\n", "nodes", ".", "depth", "[", ":", "]", "=", "nodes_dict", "[", "\"depth\"", "]", "\n", "nodes", ".", "n_samples", "[", ":", "]", "=", "nodes_dict", "[", "\"n_samples\"", "]", "\n", "nodes", ".", "parent", "[", ":", "]", "=", "nodes_dict", "[", "\"parent\"", "]", "\n", "nodes", ".", "left", "[", ":", "]", "=", "nodes_dict", "[", "\"left\"", "]", "\n", "nodes", ".", "right", "[", ":", "]", "=", "nodes_dict", "[", "\"right\"", "]", "\n", "nodes", ".", "feature", "[", ":", "]", "=", "nodes_dict", "[", "\"feature\"", "]", "\n", "nodes", ".", "weight", "[", ":", "]", "=", "nodes_dict", "[", "\"weight\"", "]", "\n", "nodes", ".", "log_weight_tree", "[", ":", "]", "=", "nodes_dict", "[", "\"log_weight_tree\"", "]", "\n", "nodes", ".", "threshold", "[", ":", "]", "=", "nodes_dict", "[", "\"threshold\"", "]", "\n", "nodes", ".", "time", "[", ":", "]", "=", "nodes_dict", "[", "\"time\"", "]", "\n", "nodes", ".", "memory_range_min", "[", ":", "]", "=", "nodes_dict", "[", "\"memory_range_min\"", "]", "\n", "nodes", ".", "memory_range_max", "[", ":", "]", "=", "nodes_dict", "[", "\"memory_range_max\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes_classifier": [[520, 523], ["node_collection.dict_to_nodes"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes"], ["", "def", "dict_to_nodes_classifier", "(", "nodes", ",", "nodes_dict", ")", ":", "\n", "    ", "dict_to_nodes", "(", "nodes", ",", "nodes_dict", ")", "\n", "nodes", ".", "counts", "[", ":", "]", "=", "nodes_dict", "[", "\"counts\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes_regressor": [[525, 528], ["node_collection.dict_to_nodes"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.dict_to_nodes"], ["", "def", "dict_to_nodes_regressor", "(", "nodes", ",", "nodes_dict", ")", ":", "\n", "    ", "dict_to_nodes", "(", "nodes", ",", "nodes_dict", ")", "\n", "nodes", ".", "mean", "[", ":", "]", "=", "nodes_dict", "[", "\"mean\"", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.get_type": [[11, 30], ["getattr"], "function", ["None"], ["def", "get_type", "(", "class_", ")", ":", "\n", "    ", "\"\"\"Gives the numba type of an object is numba.jit decorators are enabled and None\n    otherwise. This helps to get correct coverage of the code\n\n    Parameters\n    ----------\n    class_ : `object`\n        A class\n\n    Returns\n    -------\n    output : `object`\n        A numba type of None\n    \"\"\"", "\n", "class_type", "=", "getattr", "(", "class_", ",", "\"class_type\"", ",", "None", ")", "\n", "if", "class_type", "is", "None", ":", "\n", "        ", "return", "class_type", "\n", "", "else", ":", "\n", "        ", "return", "class_type", ".", "instance_type", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.resize_array": [[32, 81], ["numpy.empty", "ValueError", "numpy.ones", "numpy.zeros", "numpy.empty", "numpy.ones", "numpy.zeros"], "function", ["None"], ["", "", "@", "njit", "\n", "def", "resize_array", "(", "arr", ",", "keep", ",", "size", ",", "fill", "=", "0", ")", ":", "\n", "    ", "\"\"\"Resize the given array along the first axis only, preserving the same\n    dtype and second axis size (if it's two-dimensional)\n\n    Parameters\n    ----------\n    arr : `np.array`\n        Input array\n\n    keep : `int`\n        Keep the first `keep` elements (according to the first axis)\n\n    size : `int`\n        Target size of the first axis of new array (\n\n    fill : {`None`, 0, 1}, default=0\n        Controls the values in the resized array before putting back the first elements\n        * If None, the array is not filled\n        * If 1 the array is filled with ones\n        * If 0 the array is filled with zeros\n\n    Returns\n    -------\n    output : `np.array`\n        New array of shape (size,) or (size, arr.shape[1]) with `keep` first\n        elements preserved (along first axis)\n    \"\"\"", "\n", "if", "arr", ".", "ndim", "==", "1", ":", "\n", "        ", "if", "fill", "is", "None", ":", "\n", "            ", "new", "=", "np", ".", "empty", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "elif", "fill", "==", "1", ":", "\n", "            ", "new", "=", "np", ".", "ones", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "new", "=", "np", ".", "zeros", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "new", "[", ":", "keep", "]", "=", "arr", "[", ":", "keep", "]", "\n", "return", "new", "\n", "", "elif", "arr", ".", "ndim", "==", "2", ":", "\n", "        ", "_", ",", "n_cols", "=", "arr", ".", "shape", "\n", "if", "fill", "is", "None", ":", "\n", "            ", "new", "=", "np", ".", "empty", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "elif", "fill", "==", "1", ":", "\n", "            ", "new", "=", "np", ".", "ones", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "new", "=", "np", ".", "zeros", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "new", "[", ":", "keep", "]", "=", "arr", "[", ":", "keep", "]", "\n", "return", "new", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"resize_array can resize only 1D and 2D arrays\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.sample_discrete": [[84, 120], ["numba.njit", "numpy.random.uniform", "range", "numba.types.uint32"], "function", ["None"], ["", "", "@", "njit", "(", "uint32", "(", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "sample_discrete", "(", "distribution", ")", ":", "\n", "    ", "\"\"\"Samples according to the given discrete distribution.\n\n    Parameters\n    ----------\n    distribution : `np.array', shape=(size,), dtype='float32'\n        The discrete distribution we want to sample from. This must contain\n        non-negative entries that sum to one.\n\n    Returns\n    -------\n    output : `uint32`\n        Output sampled in {0, 1, 2, distribution.size} according to the given\n        distribution\n\n    Notes\n    -----\n    It is useless to np.cumsum and np.searchsorted here, since we want a single\n    sample for this distribution and since it changes at each call. So nothing\n    is better here than simple O(n).\n\n    Warning\n    -------\n    No test is performed here for efficiency: distribution must contain non-\n    negative values that sum to one.\n    \"\"\"", "\n", "# Notes", "\n", "U", "=", "uniform", "(", "0.0", ",", "1.0", ")", "\n", "cumsum", "=", "0.0", "\n", "size", "=", "distribution", ".", "size", "\n", "for", "j", "in", "range", "(", "size", ")", ":", "\n", "        ", "cumsum", "+=", "distribution", "[", "j", "]", "\n", "if", "U", "<=", "cumsum", ":", "\n", "            ", "return", "j", "\n", "", "", "return", "size", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.utils.log_sum_2_exp": [[122, 145], ["numba.njit", "numba.types.float32", "math.log", "math.log", "math.exp", "math.exp"], "function", ["None"], ["", "@", "njit", "(", "float32", "(", "float32", ",", "float32", ")", ")", "\n", "def", "log_sum_2_exp", "(", "a", ",", "b", ")", ":", "\n", "    ", "\"\"\"Computation of log( (e^a + e^b) / 2) in an overflow-proof way\n\n    Parameters\n    ----------\n    a : `float32`\n        First number\n\n    b : `float32`\n        Second number\n\n    Returns\n    -------\n    output : `float32`\n        Value of log( (e^a + e^b) / 2) for the given a and b\n    \"\"\"", "\n", "# TODO: if |a - b| > 50 skip", "\n", "# TODO: try several log and exp implementations", "\n", "if", "a", ">", "b", ":", "\n", "        ", "return", "a", "+", "log", "(", "(", "1", "+", "exp", "(", "b", "-", "a", ")", ")", "/", "2", ")", "\n", "", "else", ":", "\n", "        ", "return", "b", "+", "log", "(", "(", "1", "+", "exp", "(", "a", "-", "b", ")", ")", "/", "2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.TreeClassifier.__init__": [[46, 82], ["numpy.empty", "node_collection.NodesClassifier", "node_collection.add_node_classifier", "node_collection.NodesClassifier"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_classes", ",", "\n", "n_features", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "dirichlet", ",", "\n", "split_pure", ",", "\n", "samples", ",", "\n", "iteration", ",", "\n", "n_nodes", ",", "\n", "n_nodes_capacity", ",", "\n", ")", ":", "\n", "        ", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "n_features", "=", "n_features", "\n", "self", ".", "step", "=", "step", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "use_aggregation", "=", "use_aggregation", "\n", "self", ".", "dirichlet", "=", "dirichlet", "\n", "self", ".", "split_pure", "=", "split_pure", "\n", "self", ".", "samples", "=", "samples", "\n", "n_samples_increment", "=", "self", ".", "samples", ".", "n_samples_increment", "\n", "self", ".", "intensities", "=", "np", ".", "empty", "(", "n_features", ",", "dtype", "=", "float32", ")", "\n", "if", "n_nodes", "==", "0", ":", "\n", "            ", "self", ".", "iteration", "=", "0", "\n", "n_nodes", "=", "0", "\n", "n_nodes_capacity", "=", "0", "\n", "self", ".", "nodes", "=", "NodesClassifier", "(", "\n", "n_features", ",", "n_classes", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n", "add_node_classifier", "(", "self", ".", "nodes", ",", "0", ",", "0.0", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "iteration", "=", "iteration", "\n", "self", ".", "nodes", "=", "NodesClassifier", "(", "\n", "n_features", ",", "n_classes", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.TreeRegressor.__init__": [[102, 134], ["numpy.empty", "node_collection.NodesRegressor", "node_collection.add_node_regressor", "node_collection.NodesRegressor"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "n_features", ",", "\n", "step", ",", "\n", "loss", ",", "\n", "use_aggregation", ",", "\n", "split_pure", ",", "\n", "samples", ",", "\n", "iteration", ",", "\n", "n_nodes", ",", "\n", "n_nodes_capacity", ",", "\n", ")", ":", "\n", "        ", "self", ".", "n_features", "=", "n_features", "\n", "self", ".", "step", "=", "step", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "use_aggregation", "=", "use_aggregation", "\n", "self", ".", "split_pure", "=", "split_pure", "\n", "self", ".", "samples", "=", "samples", "\n", "n_samples_increment", "=", "self", ".", "samples", ".", "n_samples_increment", "\n", "self", ".", "intensities", "=", "np", ".", "empty", "(", "n_features", ",", "dtype", "=", "float32", ")", "\n", "if", "n_nodes", "==", "0", ":", "\n", "            ", "self", ".", "iteration", "=", "0", "\n", "n_nodes", "=", "0", "\n", "n_nodes_capacity", "=", "0", "\n", "self", ".", "nodes", "=", "NodesRegressor", "(", "\n", "n_features", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n", "add_node_regressor", "(", "self", ".", "nodes", ",", "0", ",", "0.0", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "iteration", "=", "iteration", "\n", "self", ".", "nodes", "=", "NodesRegressor", "(", "\n", "n_features", ",", "n_samples_increment", ",", "n_nodes", ",", "n_nodes_capacity", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.tree_classifier_to_dict": [[85, 98], ["node_collection.nodes_classifier_to_dict", "getattr"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.nodes_classifier_to_dict"], ["", "", "", "def", "tree_classifier_to_dict", "(", "tree", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "dtype", "in", "spec_tree_classifier", ":", "\n", "        ", "if", "key", "==", "\"nodes\"", ":", "\n", "            ", "nodes", "=", "nodes_classifier_to_dict", "(", "tree", ".", "nodes", ")", "\n", "d", "[", "\"nodes\"", "]", "=", "nodes", "\n", "", "elif", "key", "==", "\"samples\"", ":", "\n", "# We do not save the samples here. There are saved in the forest", "\n", "# otherwise a copy is made for each tree in the pickle file", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "d", "[", "key", "]", "=", "getattr", "(", "tree", ",", "key", ")", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.tree.tree_regressor_to_dict": [[137, 150], ["node_collection.nodes_regressor_to_dict", "getattr"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.nodes_regressor_to_dict"], ["", "", "", "def", "tree_regressor_to_dict", "(", "tree", ")", ":", "\n", "    ", "d", "=", "{", "}", "\n", "for", "key", ",", "dtype", "in", "spec_tree_regressor", ":", "\n", "        ", "if", "key", "==", "\"nodes\"", ":", "\n", "            ", "nodes", "=", "nodes_regressor_to_dict", "(", "tree", ".", "nodes", ")", "\n", "d", "[", "\"nodes\"", "]", "=", "nodes", "\n", "", "elif", "key", "==", "\"samples\"", ":", "\n", "# We do not save the samples here. There are saved in the forest", "\n", "# otherwise a copy is made for each tree in the pickle file", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "d", "[", "key", "]", "=", "getattr", "(", "tree", ",", "key", ")", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.playground.playground.run_playground_decision": [[5, 13], ["onelearn.__file__.replace", "os.system"], "function", ["None"], ["def", "run_playground_decision", "(", ")", ":", "\n", "    ", "import", "os", "\n", "import", "onelearn", "\n", "\n", "filename", "=", "onelearn", ".", "__file__", ".", "replace", "(", "\n", "\"/onelearn/__init__.py\"", ",", "\"/examples/playground_classification.py\"", "\n", ")", "\n", "os", ".", "system", "(", "\"streamlit run %s\"", "%", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.playground.playground.run_playground_tree": [[15, 23], ["onelearn.__file__.replace", "os.system"], "function", ["None"], ["", "def", "run_playground_tree", "(", ")", ":", "\n", "    ", "import", "os", "\n", "import", "onelearn", "\n", "\n", "filename", "=", "onelearn", ".", "__file__", ".", "replace", "(", "\n", "\"/onelearn/__init__.py\"", ",", "\"/examples/playground_tree.py\"", "\n", ")", "\n", "os", ".", "system", "(", "\"streamlit run %s\"", "%", "filename", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_adult": [[10, 24], ["zipfile.ZipFile", "pd.read_csv.pop", "list", "sklearn.preprocessing.MinMaxScaler().fit_transform", "pandas.get_dummies", "numpy.hstack().astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "data[].astype", "set", "set", "sklearn.preprocessing.MinMaxScaler", "pandas.get_dummies", "numpy.hstack", "sklearn.preprocessing.MinMaxScaler", "range"], "function", ["None"], ["def", "load_adult", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"adult.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"adult.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ",", "header", "=", "None", ")", "\n", "", "y", "=", "data", ".", "pop", "(", "13", ")", "\n", "discrete", "=", "[", "1", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "12", "]", "\n", "continuous", "=", "list", "(", "set", "(", "range", "(", "13", ")", ")", "-", "set", "(", "discrete", ")", ")", "\n", "X_continuous", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", "[", "continuous", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "data_discrete", "=", "pd", ".", "get_dummies", "(", "data", "[", "discrete", "]", ",", "prefix_sep", "=", "\"#\"", ")", "\n", "X_discrete", "=", "data_discrete", ".", "values", "\n", "y", "=", "pd", ".", "get_dummies", "(", "y", ")", ".", "values", "[", ":", ",", "1", "]", "\n", "X", "=", "np", ".", "hstack", "(", "(", "X_continuous", ",", "X_discrete", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"adult\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_bank": [[26, 52], ["zipfile.ZipFile", "pd.read_csv.pop", "sklearn.preprocessing.MinMaxScaler().fit_transform", "pandas.get_dummies", "numpy.hstack().astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "data[].astype", "sklearn.preprocessing.MinMaxScaler", "pandas.get_dummies", "numpy.hstack", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_bank", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"bank.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"bank.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ")", "\n", "", "y", "=", "data", ".", "pop", "(", "\"y\"", ")", "\n", "discrete", "=", "[", "\n", "\"job\"", ",", "\n", "\"marital\"", ",", "\n", "\"education\"", ",", "\n", "\"default\"", ",", "\n", "\"housing\"", ",", "\n", "\"loan\"", ",", "\n", "\"contact\"", ",", "\n", "\"day\"", ",", "\n", "\"month\"", ",", "\n", "\"campaign\"", ",", "\n", "\"poutcome\"", ",", "\n", "]", "\n", "continuous", "=", "[", "\"age\"", ",", "\"balance\"", ",", "\"duration\"", ",", "\"pdays\"", ",", "\"previous\"", "]", "\n", "X_continuous", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", "[", "continuous", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "data_discrete", "=", "pd", ".", "get_dummies", "(", "data", "[", "discrete", "]", ",", "prefix_sep", "=", "\"#\"", ")", "\n", "X_discrete", "=", "data_discrete", ".", "values", "\n", "y", "=", "pd", ".", "get_dummies", "(", "y", ")", ".", "values", "[", ":", ",", "1", "]", "\n", "X", "=", "np", ".", "hstack", "(", "(", "X_continuous", ",", "X_discrete", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"bank\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_car": [[54, 63], ["zipfile.ZipFile", "pd.read_csv.pop", "numpy.argmax", "pandas.get_dummies().values.astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "pandas.get_dummies", "sklearn.preprocessing.MinMaxScaler", "pandas.get_dummies"], "function", ["None"], ["", "def", "load_car", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"car.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"car.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ",", "header", "=", "None", ")", "\n", "", "y", "=", "data", ".", "pop", "(", "6", ")", "\n", "y", "=", "np", ".", "argmax", "(", "pd", ".", "get_dummies", "(", "y", ")", ".", "values", ",", "axis", "=", "1", ")", "\n", "X", "=", "pd", ".", "get_dummies", "(", "data", ",", "prefix_sep", "=", "\"#\"", ")", ".", "values", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"car\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_cardio": [[65, 127], ["zipfile.ZipFile", "pd.read_csv.drop", "sklearn.preprocessing.MinMaxScaler().fit_transform", "pandas.get_dummies", "numpy.hstack().astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "pd.read_csv.pop", "pd.read_csv.pop", "data[].astype", "sklearn.preprocessing.MinMaxScaler", "numpy.hstack", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_cardio", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"cardiotocography.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"cardiotocography.csv\"", ",", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ",", "sep", "=", "\";\"", ",", "decimal", "=", "\",\"", ")", "\n", "\n", "", "data", ".", "drop", "(", "\n", "[", "\n", "\"FileName\"", ",", "\n", "\"Date\"", ",", "\n", "\"SegFile\"", ",", "\n", "\"A\"", ",", "\n", "\"B\"", ",", "\n", "\"C\"", ",", "\n", "\"D\"", ",", "\n", "\"E\"", ",", "\n", "\"AD\"", ",", "\n", "\"DE\"", ",", "\n", "\"LD\"", ",", "\n", "\"FS\"", ",", "\n", "\"SUSP\"", ",", "\n", "]", ",", "\n", "axis", "=", "1", ",", "\n", "inplace", "=", "True", ",", "\n", ")", "\n", "# A 10-class label", "\n", "y_class", "=", "data", ".", "pop", "(", "\"CLASS\"", ")", ".", "values", "\n", "y_class", "-=", "1", "\n", "# A 3-class label", "\n", "y_nsp", "=", "data", ".", "pop", "(", "\"NSP\"", ")", ".", "values", "\n", "y_nsp", "-=", "1", "\n", "continuous", "=", "[", "\n", "\"b\"", ",", "\n", "\"e\"", ",", "\n", "\"LBE\"", ",", "\n", "\"LB\"", ",", "\n", "\"AC\"", ",", "\n", "\"FM\"", ",", "\n", "\"UC\"", ",", "\n", "\"ASTV\"", ",", "\n", "\"MSTV\"", ",", "\n", "\"ALTV\"", ",", "\n", "\"MLTV\"", ",", "\n", "\"DL\"", ",", "\n", "\"DS\"", ",", "\n", "\"DP\"", ",", "\n", "\"Width\"", ",", "\n", "\"Min\"", ",", "\n", "\"Max\"", ",", "\n", "\"Nmax\"", ",", "\n", "\"Nzeros\"", ",", "\n", "\"Mode\"", ",", "\n", "\"Mean\"", ",", "\n", "\"Median\"", ",", "\n", "\"Variance\"", ",", "\n", "]", "\n", "discrete", "=", "[", "\"Tendency\"", "]", "\n", "X_continuous", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", "[", "continuous", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "data_discrete", "=", "pd", ".", "get_dummies", "(", "data", "[", "discrete", "]", ",", "prefix_sep", "=", "\"#\"", ")", "\n", "X_discrete", "=", "data_discrete", ".", "values", "\n", "X", "=", "np", ".", "hstack", "(", "(", "X_continuous", ",", "X_discrete", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y_nsp", ",", "\"cardio\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_churn": [[129, 165], ["zipfile.ZipFile", "pd.read_csv.pop", "sklearn.preprocessing.MinMaxScaler().fit_transform", "pandas.get_dummies", "numpy.hstack().astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "data[].astype", "sklearn.preprocessing.MinMaxScaler", "pandas.get_dummies", "numpy.hstack", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_churn", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"churn.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"churn.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ")", "\n", "", "y", "=", "data", ".", "pop", "(", "\"Churn?\"", ")", "\n", "discrete", "=", "[", "\n", "\"State\"", ",", "\n", "\"Area Code\"", ",", "\n", "\"Int'l Plan\"", ",", "\n", "\"VMail Plan\"", ",", "\n", "]", "\n", "\n", "continuous", "=", "[", "\n", "\"Account Length\"", ",", "\n", "\"Day Mins\"", ",", "\n", "\"Day Calls\"", ",", "\n", "\"Eve Calls\"", ",", "\n", "\"Day Charge\"", ",", "\n", "\"Eve Mins\"", ",", "\n", "\"Eve Charge\"", ",", "\n", "\"Night Mins\"", ",", "\n", "\"Night Calls\"", ",", "\n", "\"Night Charge\"", ",", "\n", "\"Intl Mins\"", ",", "\n", "\"Intl Calls\"", ",", "\n", "\"Intl Charge\"", ",", "\n", "\"CustServ Calls\"", ",", "\n", "\"VMail Message\"", ",", "\n", "]", "\n", "X_continuous", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", "[", "continuous", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "data_discrete", "=", "pd", ".", "get_dummies", "(", "data", "[", "discrete", "]", ",", "prefix_sep", "=", "\"#\"", ")", "\n", "X_discrete", "=", "data_discrete", ".", "values", "\n", "y", "=", "pd", ".", "get_dummies", "(", "y", ")", ".", "values", "[", ":", ",", "1", "]", "\n", "X", "=", "np", ".", "hstack", "(", "(", "X_continuous", ",", "X_discrete", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"churn\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_default_cb": [[167, 207], ["zipfile.ZipFile", "pd.read_csv.pop", "pd.read_csv.pop", "sklearn.preprocessing.MinMaxScaler().fit_transform", "pandas.get_dummies", "numpy.hstack().astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "data[].astype", "sklearn.preprocessing.MinMaxScaler", "pandas.get_dummies", "numpy.hstack", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_default_cb", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"default_cb.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"default_cb.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ")", "\n", "", "continuous", "=", "[", "\n", "\"AGE\"", ",", "\n", "\"BILL_AMT1\"", ",", "\n", "\"BILL_AMT2\"", ",", "\n", "\"BILL_AMT3\"", ",", "\n", "\"LIMIT_BAL\"", ",", "\n", "\"BILL_AMT4\"", ",", "\n", "\"BILL_AMT5\"", ",", "\n", "\"BILL_AMT6\"", ",", "\n", "\"PAY_AMT1\"", ",", "\n", "\"PAY_AMT2\"", ",", "\n", "\"PAY_AMT3\"", ",", "\n", "\"PAY_AMT4\"", ",", "\n", "\"PAY_AMT5\"", ",", "\n", "\"PAY_AMT6\"", ",", "\n", "]", "\n", "discrete", "=", "[", "\n", "\"PAY_0\"", ",", "\n", "\"PAY_2\"", ",", "\n", "\"PAY_3\"", ",", "\n", "\"PAY_4\"", ",", "\n", "\"PAY_5\"", ",", "\n", "\"PAY_6\"", ",", "\n", "\"SEX\"", ",", "\n", "\"EDUCATION\"", ",", "\n", "\"MARRIAGE\"", ",", "\n", "]", "\n", "_", "=", "data", ".", "pop", "(", "\"ID\"", ")", "\n", "y", "=", "data", ".", "pop", "(", "\"default payment next month\"", ")", "\n", "X_continuous", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", "[", "continuous", "]", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "data_discrete", "=", "pd", ".", "get_dummies", "(", "data", "[", "discrete", "]", ",", "prefix_sep", "=", "\"#\"", ")", "\n", "X_discrete", "=", "data_discrete", ".", "values", "\n", "y", "=", "pd", ".", "get_dummies", "(", "y", ")", ".", "values", "[", ":", ",", "1", "]", "\n", "X", "=", "np", ".", "hstack", "(", "(", "X_continuous", ",", "X_discrete", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"default_cb\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_letter": [[209, 218], ["zipfile.ZipFile", "pd.read_csv.drop", "pd.read_csv.values.astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "pd.read_csv.pop", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_letter", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"letter.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"letter.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ")", "\n", "", "data", ".", "drop", "(", "[", "\"Unnamed: 0\"", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "y", "=", "data", ".", "pop", "(", "\"y\"", ")", ".", "values", "\n", "X", "=", "data", ".", "values", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"letter\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_satimage": [[220, 229], ["zipfile.ZipFile", "pd.read_csv.drop", "pd.read_csv.values.astype", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "pd.read_csv.pop", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_satimage", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"satimage.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"satimage.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ")", "\n", "", "data", ".", "drop", "(", "[", "\"Unnamed: 0\"", "]", ",", "axis", "=", "1", ",", "inplace", "=", "True", ")", "\n", "y", "=", "data", ".", "pop", "(", "\"y\"", ")", ".", "values", "\n", "X", "=", "data", ".", "values", ".", "astype", "(", "\"float32\"", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", ",", "\"satimage\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_sensorless": [[231, 239], ["zipfile.ZipFile", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "pd.read_csv.pop", "pd.read_csv.astype", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_sensorless", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"sensorless.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"sensorless.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ",", "sep", "=", "\" \"", ",", "header", "=", "None", ")", "\n", "", "y", "=", "data", ".", "pop", "(", "48", ")", ".", "values", "\n", "y", "-=", "1", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "return", "X", ",", "y", ",", "\"sensorless\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.loaders.load_spambase": [[241, 248], ["zipfile.ZipFile", "sklearn.preprocessing.MinMaxScaler().fit_transform", "os.path.join", "zipfile.ZipFile.open", "pandas.read_csv", "pd.read_csv.pop", "pd.read_csv.astype", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["", "def", "load_spambase", "(", "path", ")", ":", "\n", "    ", "archive", "=", "zipfile", ".", "ZipFile", "(", "os", ".", "path", ".", "join", "(", "path", ",", "\"spambase.csv.zip\"", ")", ",", "\"r\"", ")", "\n", "with", "archive", ".", "open", "(", "\"spambase.csv\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "pd", ".", "read_csv", "(", "f", ",", "header", "=", "None", ")", "\n", "", "y", "=", "data", ".", "pop", "(", "57", ")", ".", "values", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "data", ".", "astype", "(", "\"float32\"", ")", ")", "\n", "return", "X", ",", "y", ",", "\"spambase\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.heavisine": [[13, 33], ["numba.vectorize", "numpy.sign", "numba.types.float32", "numba.types.float64", "numpy.sign", "numpy.sin"], "function", ["None"], ["@", "vectorize", "(", "[", "float32", "(", "float32", ")", ",", "float64", "(", "float64", ")", "]", ",", "nopython", "=", "True", ")", "\n", "def", "heavisine", "(", "x", ")", ":", "\n", "    ", "\"\"\"Computes the \"heavisine\" signal.\n\n    Parameters\n    ----------\n    x : `numpy.array`, shape=(n_samples,)\n        Inputs values\n\n    Returns\n    -------\n    output : `numpy.array`, shape=(n_samples,)\n        The value of the signal at given inputs\n\n    Notes\n    -----\n    Inputs are supposed to belong to [0, 1] and must have dtype `float32` or `float64`\n\n    \"\"\"", "\n", "return", "4", "*", "sin", "(", "4", "*", "pi", "*", "x", ")", "-", "sign", "(", "x", "-", "0.3", ")", "-", "sign", "(", "0.72", "-", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.bumps": [[35, 63], ["numba.vectorize", "numpy.array", "numpy.array", "numpy.array", "range", "numba.types.float32", "numba.types.float64", "numpy.abs"], "function", ["None"], ["", "@", "vectorize", "(", "[", "float32", "(", "float32", ")", ",", "float64", "(", "float64", ")", "]", ",", "nopython", "=", "True", ")", "\n", "def", "bumps", "(", "x", ")", ":", "\n", "    ", "\"\"\"Computes the \"bumps\" signal.\n\n    Parameters\n    ----------\n    x : `numpy.array`, shape=(n_samples,)\n        Inputs values\n\n    Returns\n    -------\n    output : `numpy.array`, shape=(n_samples,)\n        The value of the signal at given inputs\n\n    Notes\n    -----\n    Inputs are supposed to belong to [0, 1] and must have dtype `float32` or `float64`\n\n    \"\"\"", "\n", "pos", "=", "np", ".", "array", "(", "[", "0.1", ",", "0.13", ",", "0.15", ",", "0.23", ",", "0.25", ",", "0.4", ",", "0.44", ",", "0.65", ",", "0.76", ",", "0.78", ",", "0.81", "]", ")", "\n", "hgt", "=", "np", ".", "array", "(", "[", "4", ",", "5", ",", "3", ",", "4", ",", "5", ",", "4.2", ",", "2.1", ",", "4.3", ",", "3.1", ",", "5.1", ",", "4.2", "]", ")", "\n", "wth", "=", "np", ".", "array", "(", "\n", "[", "0.005", ",", "0.005", ",", "0.006", ",", "0.01", ",", "0.01", ",", "0.03", ",", "0.01", ",", "0.01", ",", "0.005", ",", "0.008", ",", "0.005", "]", ",", "\n", ")", "\n", "y", "=", "0", "\n", "for", "j", "in", "range", "(", "pos", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "y", "+=", "hgt", "[", "j", "]", "/", "(", "(", "1", "+", "(", "abs", "(", "x", "-", "pos", "[", "j", "]", ")", "/", "wth", "[", "j", "]", ")", ")", "**", "4", ")", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.blocks": [[65, 90], ["numba.vectorize", "numpy.array", "numpy.array", "range", "numba.types.float32", "numba.types.float64", "numpy.sign"], "function", ["None"], ["", "@", "vectorize", "(", "[", "float32", "(", "float32", ")", ",", "float64", "(", "float64", ")", "]", ",", "nopython", "=", "True", ")", "\n", "def", "blocks", "(", "x", ")", ":", "\n", "    ", "\"\"\"Computes the \"blocks\" signal.\n\n    Parameters\n    ----------\n    x : `numpy.array`, shape=(n_samples,)\n        Inputs values\n\n    Returns\n    -------\n    output : `numpy.array`, shape=(n_samples,)\n        The value of the signal at given inputs\n\n    Notes\n    -----\n    Inputs are supposed to belong to [0, 1] and must have dtype `float32` or `float64`\n\n    \"\"\"", "\n", "pos", "=", "np", ".", "array", "(", "[", "0.1", ",", "0.13", ",", "0.15", ",", "0.23", ",", "0.25", ",", "0.4", ",", "0.44", ",", "0.65", ",", "0.76", ",", "0.78", ",", "0.81", "]", ")", "\n", "hgt", "=", "np", ".", "array", "(", "[", "4", ",", "-", "5", ",", "3", ",", "-", "4", ",", "5", ",", "-", "4.2", ",", "2.1", ",", "4.3", ",", "-", "3.1", ",", "2.1", ",", "-", "4.2", "]", ")", "\n", "y", "=", "2.0", "\n", "for", "j", "in", "range", "(", "pos", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "y", "+=", "(", "1", "+", "sign", "(", "x", "-", "pos", "[", "j", "]", ")", ")", "*", "(", "hgt", "[", "j", "]", "/", "2", ")", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.doppler": [[92, 112], ["numba.vectorize", "numba.types.float32", "numba.types.float64", "numpy.sqrt", "numpy.sin"], "function", ["None"], ["", "@", "vectorize", "(", "[", "float32", "(", "float32", ")", ",", "float64", "(", "float64", ")", "]", ",", "nopython", "=", "True", ")", "\n", "def", "doppler", "(", "x", ")", ":", "\n", "    ", "\"\"\"Computes the \"doppler\" signal.\n\n    Parameters\n    ----------\n    x : `numpy.array`, shape=(n_samples,)\n        Inputs values\n\n    Returns\n    -------\n    output : `numpy.array`, shape=(n_samples,)\n        The value of the signal at given inputs\n\n    Notes\n    -----\n    Inputs are supposed to belong to [0, 1] and must have dtype `float32` or `float64`\n\n    \"\"\"", "\n", "return", "sqrt", "(", "x", "*", "(", "1", "-", "x", ")", ")", "*", "sin", "(", "(", "2", "*", "pi", "*", "1.05", ")", "/", "(", "x", "+", "0.05", ")", ")", "+", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.get_signal": [[114, 148], ["heavisine.min", "heavisine.max", "regression.heavisine", "regression.bumps", "regression.blocks", "regression.doppler", "regression.heavisine"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.heavisine", "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.bumps", "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.blocks", "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.doppler", "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.heavisine"], ["", "def", "get_signal", "(", "x", ",", "signal", "=", "\"heavisine\"", ")", ":", "\n", "    ", "\"\"\"Computes a signal at the given inputs.\n\n    Parameters\n    ----------\n    x : `numpy.array`, shape=(n_samples,)\n        Inputs values\n\n    signal : {\"heavisine\", \"bumps\", \"blocks\", \"doppler\"}, default=\"heavisine\"\n        Type of signal\n\n    Returns\n    -------\n    output : `numpy.array`, shape=(n_samples,)\n        The value of the signal at given inputs\n\n    Notes\n    -----\n    Inputs are supposed to belong to [0, 1] and must have dtype `float32` or `float64`\n\n    \"\"\"", "\n", "if", "signal", "==", "\"heavisine\"", ":", "\n", "        ", "y", "=", "heavisine", "(", "x", ")", "\n", "", "elif", "signal", "==", "\"bumps\"", ":", "\n", "        ", "y", "=", "bumps", "(", "x", ")", "\n", "", "elif", "signal", "==", "\"blocks\"", ":", "\n", "        ", "y", "=", "blocks", "(", "x", ")", "\n", "", "elif", "signal", "==", "\"doppler\"", ":", "\n", "        ", "y", "=", "doppler", "(", "x", ")", "\n", "", "else", ":", "\n", "        ", "y", "=", "heavisine", "(", "x", ")", "\n", "", "y_min", "=", "y", ".", "min", "(", ")", "\n", "y_max", "=", "y", ".", "max", "(", ")", "\n", "return", "(", "y", "-", "y_min", ")", "/", "(", "y_max", "-", "y_min", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.make_regression": [[150, 159], ["numpy.random.uniform", "numpy.sort", "regression.get_signal", "X.reshape.reshape", "numpy.random.seed", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.get_signal"], ["", "def", "make_regression", "(", "n_samples", ",", "signal", "=", "\"heavisine\"", ",", "noise", "=", "0.03", ",", "random_state", "=", "None", ")", ":", "\n", "    ", "if", "random_state", "is", "not", "None", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "random_state", ")", "\n", "", "X", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "n_samples", ")", "\n", "X", "=", "np", ".", "sort", "(", "X", ")", "\n", "y", "=", "get_signal", "(", "X", ",", "signal", ")", "\n", "X", "=", "X", ".", "reshape", "(", "n_samples", ",", "1", ")", "\n", "y", "+=", "noise", "*", "np", ".", "random", ".", "randn", "(", "n_samples", ")", "\n", "return", "X", ",", "y", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification.simulate_data": [[64, 94], ["sklearn.preprocessing.MinMaxScaler().fit_transform", "sklearn.datasets.make_moons", "sklearn.datasets.make_circles", "sklearn.preprocessing.MinMaxScaler", "sklearn.datasets.make_classification", "numpy.random.RandomState", "np.random.RandomState.uniform", "sklearn.datasets.make_blobs", "sklearn.datasets.make_moons"], "function", ["None"], ["", "@", "st", ".", "cache", "\n", "def", "simulate_data", "(", "dataset", "=", "\"moons\"", ")", ":", "\n", "    ", "if", "dataset", "==", "\"moons\"", ":", "\n", "        ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.2", ",", "random_state", "=", "random_state", ")", "\n", "", "elif", "dataset", "==", "\"circles\"", ":", "\n", "        ", "X", ",", "y", "=", "make_circles", "(", "\n", "n_samples", "=", "n_samples", ",", "noise", "=", "0.1", ",", "factor", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "", "elif", "dataset", "==", "\"linear\"", ":", "\n", "        ", "X", ",", "y", "=", "make_classification", "(", "\n", "n_samples", "=", "n_samples", ",", "\n", "n_features", "=", "2", ",", "\n", "n_redundant", "=", "0", ",", "\n", "n_informative", "=", "2", ",", "\n", "random_state", "=", "random_state", ",", "\n", "n_clusters_per_class", "=", "1", ",", "\n", "flip_y", "=", "0.001", ",", "\n", "class_sep", "=", "2.0", ",", "\n", ")", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "random_state", ")", "\n", "X", "+=", "2", "*", "rng", ".", "uniform", "(", "size", "=", "X", ".", "shape", ")", "\n", "", "elif", "dataset", "==", "\"blobs\"", ":", "\n", "        ", "X", ",", "y", "=", "make_blobs", "(", "n_samples", "=", "n_samples", ",", "centers", "=", "5", ",", "random_state", "=", "random_state", ")", "\n", "y", "[", "y", "==", "2", "]", "=", "0", "\n", "y", "[", "y", "==", "3", "]", "=", "1", "\n", "y", "[", "y", "==", "4", "]", "=", "0", "\n", "", "else", ":", "\n", "        ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.2", ",", "random_state", "=", "random_state", ")", "\n", "", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification.build_mesh": [[103, 106], ["experiments.plot.get_mesh"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.get_mesh"], ["@", "st", ".", "cache", "\n", "def", "build_mesh", "(", "X", ")", ":", "\n", "    ", "return", "get_mesh", "(", "X", ",", "h", "=", "h", ",", "padding", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification.get_amf_decision_batch": [[111, 126], ["onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "[].reshape", "onelearn.AMFClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["@", "st", ".", "cache", "\n", "def", "get_amf_decision_batch", "(", "use_aggregation", ",", "n_estimators", ",", "split_pure", ",", "dirichlet", ",", "step", ")", ":", "\n", "# TODO: add a progress bar", "\n", "    ", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "n_classes", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "dirichlet", "=", "dirichlet", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "amf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "zz", "=", "amf", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "return", "zz", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification.get_amf_decisions": [[128, 148], ["streamlit.cache", "onelearn.AMFClassifier", "streamlit.sidebar.progress", "range", "onelearn.AMFClassifier.partial_fit", "[].reshape", "zzs.append", "int", "st.sidebar.progress.progress", "X[].reshape", "numpy.array", "onelearn.AMFClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "@", "st", ".", "cache", "(", "suppress_st_warning", "=", "True", ")", "\n", "def", "get_amf_decisions", "(", "use_aggregation", ",", "n_estimators", ",", "split_pure", ",", "dirichlet", ",", "step", ")", ":", "\n", "    ", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "n_classes", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "dirichlet", "=", "dirichlet", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "zzs", "=", "[", "]", "\n", "progress_bar", "=", "st", ".", "sidebar", ".", "progress", "(", "0", ")", "\n", "for", "it", "in", "range", "(", "1", ",", "n_samples_train", "+", "1", ")", ":", "\n", "        ", "amf", ".", "partial_fit", "(", "X", "[", "it", "-", "1", "]", ".", "reshape", "(", "1", ",", "2", ")", ",", "np", ".", "array", "(", "[", "y", "[", "it", "-", "1", "]", "]", ")", ")", "\n", "zz", "=", "amf", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "zzs", ".", "append", "(", "zz", ")", "\n", "progress", "=", "int", "(", "100", "*", "it", "/", "n_samples_train", ")", "\n", "progress_bar", ".", "progress", "(", "progress", ")", "\n", "", "return", "zzs", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.plot_signals_weighted_depth.plot_weighted_depth": [[44, 120], ["onelearn.datasets.make_regression", "numpy.linspace", "onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "onelearn.AMFRegressor.predict", "onelearn.AMFRegressor.weighted_depth", "matplotlib.subplots", "ax3.plot", "fig.subplots_adjust", "fig.legend", "matplotlib.savefig", "logging.info", "X_train.reshape", "np.linspace.reshape", "np.linspace.reshape", "ax1.plot", "ax1.plot", "ax2.plot", "ax3.plot", "ax3.plot", "onelearn.datasets.get_signal", "np.linspace.ravel", "amf.weighted_depth.mean"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.make_regression", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.weighted_depth", "home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.get_signal"], ["def", "plot_weighted_depth", "(", "signal", ")", ":", "\n", "    ", "X_train", ",", "y_train", "=", "make_regression", "(", "\n", "n_samples", "=", "n_samples_train", ",", "signal", "=", "signal", ",", "noise", "=", "noise", ",", "random_state", "=", "random_state", "\n", ")", "\n", "X_test", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "n_samples_test", ")", "\n", "\n", "amf", "=", "AMFRegressor", "(", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "\n", "amf", ".", "partial_fit", "(", "X_train", ".", "reshape", "(", "n_samples_train", ",", "1", ")", ",", "y_train", ")", "\n", "y_pred", "=", "amf", ".", "predict", "(", "X_test", ".", "reshape", "(", "n_samples_test", ",", "1", ")", ")", "\n", "weighted_depths", "=", "amf", ".", "weighted_depth", "(", "X_test", ".", "reshape", "(", "n_samples_test", ",", "1", ")", ")", "\n", "\n", "fig", ",", "(", "ax1", ",", "ax2", ",", "ax3", ")", "=", "plt", ".", "subplots", "(", "nrows", "=", "3", ",", "ncols", "=", "1", ",", "sharex", "=", "True", ",", "figsize", "=", "(", "6", ",", "5", ")", ")", "\n", "\n", "plot_samples", "=", "ax1", ".", "plot", "(", "\n", "X_train", ",", "y_train", ",", "color", "=", "colormap", ".", "colors", "[", "1", "]", ",", "lw", "=", "2", ",", "label", "=", "\"Samples\"", "\n", ")", "[", "0", "]", "\n", "plot_signal", "=", "ax1", ".", "plot", "(", "\n", "X_test", ",", "\n", "get_signal", "(", "X_test", ",", "signal", ")", ",", "\n", "lw", "=", "2", ",", "\n", "color", "=", "colormap", ".", "colors", "[", "0", "]", ",", "\n", "label", "=", "\"Signal\"", ",", "\n", ")", "[", "0", "]", "\n", "plot_prediction", "=", "ax2", ".", "plot", "(", "\n", "X_test", ".", "ravel", "(", ")", ",", "y_pred", ",", "lw", "=", "2", ",", "color", "=", "colormap", ".", "colors", "[", "2", "]", ",", "label", "=", "\"Prediction\"", "\n", ")", "[", "0", "]", "\n", "ax3", ".", "plot", "(", "\n", "X_test", ",", "\n", "weighted_depths", "[", ":", ",", "1", ":", "]", ",", "\n", "lw", "=", "1", ",", "\n", "color", "=", "colormap", ".", "colors", "[", "5", "]", ",", "\n", "alpha", "=", "0.2", ",", "\n", "label", "=", "\"Weighted depths\"", ",", "\n", ")", "\n", "plot_weighted_depths", "=", "ax3", ".", "plot", "(", "\n", "X_test", ",", "weighted_depths", "[", ":", ",", "0", "]", ",", "lw", "=", "1", ",", "color", "=", "colormap", ".", "colors", "[", "5", "]", ",", "alpha", "=", "0.2", "\n", ")", "[", "0", "]", "\n", "\n", "plot_mean_weighted_depths", "=", "ax3", ".", "plot", "(", "\n", "X_test", ",", "\n", "weighted_depths", ".", "mean", "(", "axis", "=", "1", ")", ",", "\n", "lw", "=", "2", ",", "\n", "color", "=", "colormap", ".", "colors", "[", "4", "]", ",", "\n", "label", "=", "\"Mean weighted depth\"", ",", "\n", ")", "[", "0", "]", "\n", "filename", "=", "\"weighted_depths_%s.pdf\"", "%", "signal", "\n", "fig", ".", "subplots_adjust", "(", "hspace", "=", "0.1", ")", "\n", "fig", ".", "legend", "(", "\n", "(", "\n", "plot_signal", ",", "\n", "plot_samples", ",", "\n", "plot_mean_weighted_depths", ",", "\n", "plot_weighted_depths", ",", "\n", "plot_prediction", ",", "\n", ")", ",", "\n", "(", "\n", "\"Signal\"", ",", "\n", "\"Samples\"", ",", "\n", "\"Average weighted depths\"", ",", "\n", "\"Weighted depths\"", ",", "\n", "\"Prediction\"", ",", "\n", ")", ",", "\n", "fontsize", "=", "12", ",", "\n", "loc", "=", "\"upper center\"", ",", "\n", "bbox_to_anchor", "=", "(", "0.5", ",", "1.0", ")", ",", "\n", "ncol", "=", "3", ",", "\n", ")", "\n", "plt", ".", "savefig", "(", "filename", ")", "\n", "logging", ".", "info", "(", "\"Saved the decision functions in '%s'\"", "%", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_regression.get_test": [[45, 48], ["numpy.linspace"], "function", ["None"], ["@", "st", ".", "cache", "\n", "def", "get_test", "(", "num", ")", ":", "\n", "    ", "return", "np", ".", "linspace", "(", "0", ",", "1", ",", "num", "=", "num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_regression.simulate_data": [[53, 57], ["onelearn.datasets.make_regression"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.make_regression"], ["@", "st", ".", "cache", "\n", "def", "simulate_data", "(", "n_samples", ",", "signal", ",", "noise", ")", ":", "\n", "    ", "return", "make_regression", "(", "\n", "n_samples", "=", "n_samples", ",", "signal", "=", "signal", ",", "noise", "=", "noise", ",", "random_state", "=", "random_state", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_regression.compute_signal": [[60, 63], ["streamlit.cache", "onelearn.datasets.get_signal"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.get_signal"], ["", "@", "st", ".", "cache", "(", ")", "\n", "def", "compute_signal", "(", "x", ",", "dataset", ")", ":", "\n", "    ", "return", "get_signal", "(", "x", ",", "signal", "=", "dataset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_regression.get_amf_prediction": [[68, 81], ["onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "onelearn.AMFRegressor.predict", "onelearn.AMFRegressor.weighted_depth", "X_train.reshape", "X_test.reshape", "X_test.reshape", "amf.weighted_depth.mean"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.weighted_depth"], ["@", "st", ".", "cache", "\n", "def", "get_amf_prediction", "(", "use_aggregation", ",", "n_estimators", ",", "split_pure", ",", "step", ")", ":", "\n", "    ", "amf", "=", "AMFRegressor", "(", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "amf", ".", "partial_fit", "(", "X_train", ".", "reshape", "(", "n_samples_train", ",", "1", ")", ",", "y_train", ")", "\n", "y_pred", "=", "amf", ".", "predict", "(", "X_test", ".", "reshape", "(", "n_samples_test", ",", "1", ")", ")", "\n", "weighted_depths", "=", "amf", ".", "weighted_depth", "(", "X_test", ".", "reshape", "(", "n_samples_test", ",", "1", ")", ")", "\n", "return", "y_pred", ",", "weighted_depths", ",", "weighted_depths", ".", "mean", "(", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.plot_forest_effect.plot_forest_effect": [[38, 62], ["matplotlib.figure", "experiments.plot.get_mesh", "matplotlib.subplot", "experiments.plot.plot_scatter_binary_classif", "forest.partial_fit", "range", "matplotlib.subplot", "[].reshape", "experiments.plot.plot_contour_binary_classif", "matplotlib.tight_layout", "matplotlib.subplot", "[].reshape", "experiments.plot.plot_contour_binary_classif", "forest.predict_proba", "forest.predict_proba_tree"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.get_mesh", "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.plot_scatter_binary_classif", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.plot_contour_binary_classif", "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.plot_contour_binary_classif", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.predict_proba_tree"], ["def", "plot_forest_effect", "(", "forest", ",", "dataset", ")", ":", "\n", "    ", "n_estimators", "=", "forest", ".", "n_estimators", "\n", "_", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "2", "*", "(", "n_estimators", "/", "2", "+", "1", ")", ",", "4", ")", ")", "\n", "\n", "X", ",", "y", "=", "dataset", "\n", "xx", ",", "yy", ",", "X_mesh", "=", "get_mesh", "(", "X", ")", "\n", "\n", "# Plot the training points", "\n", "ax", "=", "plt", ".", "subplot", "(", "2", ",", "n_estimators", "/", "2", "+", "1", ",", "1", ")", "\n", "plot_scatter_binary_classif", "(", "ax", ",", "xx", ",", "yy", ",", "X", ",", "y", ",", "title", "=", "\"Input data\"", ")", "\n", "\n", "forest", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "\n", "for", "idx_tree", "in", "range", "(", "n_estimators", ")", ":", "\n", "        ", "ax", "=", "plt", ".", "subplot", "(", "2", ",", "n_estimators", "/", "2", "+", "1", ",", "idx_tree", "+", "2", ")", "\n", "Z", "=", "forest", ".", "predict_proba_tree", "(", "X_mesh", ",", "idx_tree", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "plot_contour_binary_classif", "(", "\n", "ax", ",", "xx", ",", "yy", ",", "Z", ",", "title", "=", "\"Tree #%d\"", "%", "(", "idx_tree", "+", "1", ")", ",", "norm", "=", "norm", ",", "levels", "=", "levels", "\n", ")", "\n", "\n", "", "ax", "=", "plt", ".", "subplot", "(", "2", ",", "n_estimators", "/", "2", "+", "1", ",", "n_estimators", "+", "2", ")", "\n", "Z", "=", "forest", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "plot_contour_binary_classif", "(", "ax", ",", "xx", ",", "yy", ",", "Z", ",", "title", "=", "\"Forest\"", ",", "norm", "=", "norm", ",", "levels", "=", "levels", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.plot_decisions.simulate_data": [[55, 79], ["sklearn.preprocessing.MinMaxScaler().fit_transform", "sklearn.datasets.make_moons", "sklearn.datasets.make_circles", "sklearn.preprocessing.MinMaxScaler", "sklearn.datasets.make_classification", "numpy.random.RandomState", "sklearn.datasets.make_moons", "np.random.RandomState.uniform"], "function", ["None"], ["def", "simulate_data", "(", "dataset", "=", "\"moons\"", ")", ":", "\n", "    ", "if", "dataset", "==", "\"moons\"", ":", "\n", "        ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.2", ",", "random_state", "=", "random_state", ")", "\n", "", "elif", "dataset", "==", "\"circles\"", ":", "\n", "        ", "X", ",", "y", "=", "make_circles", "(", "\n", "n_samples", "=", "n_samples", ",", "noise", "=", "0.1", ",", "factor", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "", "elif", "dataset", "==", "\"linear\"", ":", "\n", "        ", "X", ",", "y", "=", "make_classification", "(", "\n", "n_samples", "=", "n_samples", ",", "\n", "n_features", "=", "2", ",", "\n", "n_redundant", "=", "0", ",", "\n", "n_informative", "=", "2", ",", "\n", "random_state", "=", "random_state", ",", "\n", "n_clusters_per_class", "=", "1", ",", "\n", "flip_y", "=", "0.001", ",", "\n", "class_sep", "=", "2.0", ",", "\n", ")", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "random_state", ")", "\n", "X", "+=", "2", "*", "rng", ".", "uniform", "(", "size", "=", "X", ".", "shape", ")", "\n", "", "else", ":", "\n", "        ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.2", ",", "random_state", "=", "random_state", ")", "\n", "", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.plot_decisions.get_classifiers": [[88, 125], ["onelearn.AMFClassifier", "onelearn.AMFClassifier", "skgarden.MondrianForestClassifier", "sklearn.ensemble.RandomForestClassifier", "sklearn.ensemble.ExtraTreesClassifier"], "function", ["None"], ["def", "get_classifiers", "(", ")", ":", "\n", "    ", "return", "[", "\n", "(", "\n", "\"AMF\"", ",", "\n", "AMFClassifier", "(", "\n", "n_classes", "=", "2", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "True", ",", "\n", "split_pure", "=", "True", ",", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "\"AMF(no agg)\"", ",", "\n", "AMFClassifier", "(", "\n", "n_classes", "=", "2", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "False", ",", "\n", "split_pure", "=", "True", ",", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "\"MF\"", ",", "\n", "MondrianForestClassifier", "(", "\n", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "\"RF\"", ",", "\n", "RandomForestClassifier", "(", "\n", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", "\n", ")", ",", "\n", ")", ",", "\n", "(", "\n", "\"ET\"", ",", "\n", "ExtraTreesClassifier", "(", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", ")", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_tree.simulate_data": [[45, 50], ["sklearn.datasets.make_moons", "sklearn.preprocessing.MinMaxScaler().fit_transform", "sklearn.preprocessing.MinMaxScaler"], "function", ["None"], ["@", "st", ".", "cache", "\n", "def", "simulate_data", "(", ")", ":", "\n", "    ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.3", ",", "random_state", "=", "random_state", ")", "\n", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_tree.get_data_df": [[57, 65], ["pandas.DataFrame", "df[].map"], "function", ["None"], ["@", "st", ".", "cache", "\n", "def", "get_data_df", "(", "X", ",", "y", ")", ":", "\n", "    ", "y_color", "=", "{", "0", ":", "\"blue\"", ",", "1", ":", "\"red\"", "}", "\n", "df", "=", "pd", ".", "DataFrame", "(", "\n", "{", "\"x1\"", ":", "X", "[", ":", ",", "0", "]", ",", "\"x2\"", ":", "X", "[", ":", ",", "1", "]", ",", "\"y\"", ":", "y", "}", ",", "columns", "=", "[", "\"x1\"", ",", "\"x2\"", ",", "\"y\"", "]", ",", "\n", ")", "\n", "df", "[", "\"y\"", "]", "=", "df", "[", "\"y\"", "]", ".", "map", "(", "lambda", "y", ":", "y_color", "[", "y", "]", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_tree.get_mesh": [[71, 77], ["numpy.meshgrid", "numpy.ascontiguousarray", "numpy.linspace", "numpy.linspace", "numpy.array", "xx.ravel", "yy.ravel"], "function", ["None"], ["@", "st", ".", "cache", "\n", "def", "get_mesh", "(", "grid_size", ")", ":", "\n", "    ", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "grid_size", ")", ",", "np", ".", "linspace", "(", "0", ",", "1", ",", "grid_size", ")", ")", "\n", "xy", "=", "np", ".", "array", "(", "[", "xx", ".", "ravel", "(", ")", ",", "yy", ".", "ravel", "(", ")", "]", ")", ".", "T", "\n", "xy", "=", "np", ".", "ascontiguousarray", "(", "xy", ",", "dtype", "=", "\"float32\"", ")", "\n", "return", "xy", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_tree.get_amf_decision_batch": [[82, 97], ["onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "[].reshape", "onelearn.AMFClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["@", "st", ".", "cache", "\n", "def", "get_amf_decision_batch", "(", "use_aggregation", ",", "n_estimators", ",", "split_pure", ",", "dirichlet", ",", "step", ")", ":", "\n", "# TODO: add a progress bar", "\n", "    ", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "n_classes", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "dirichlet", "=", "dirichlet", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "amf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "zz", "=", "amf", ".", "predict_proba", "(", "xy", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "grid_size", ",", "grid_size", ")", "\n", "return", "zz", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_tree.get_amf_trees_and_decisions": [[99, 167], ["streamlit.cache", "onelearn.AMFClassifier", "streamlit.sidebar.progress", "range", "df_datas.append", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.get_nodes_df", "df_tree[].apply", "df_tree[].apply", "df_tree[].apply", "df_tree[].apply", "df_tree[].apply", "df_tree[].apply", "amf.get_nodes_df.sort_values", "numpy.zeros", "range", "df_tree[].astype", "amf.get_nodes_df.replace", "df_trees.append", "[].reshape", "zzs.append", "int", "st.sidebar.progress.progress", "X_train[].reshape", "numpy.array", "onelearn.AMFClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.get_nodes_df", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "@", "st", ".", "cache", "(", "suppress_st_warning", "=", "True", ",", "allow_output_mutation", "=", "True", ")", "\n", "def", "get_amf_trees_and_decisions", "(", "\n", "use_aggregation", ",", "n_estimators", ",", "split_pure", ",", "dirichlet", ",", "step", "\n", ")", ":", "\n", "    ", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "n_classes", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "dirichlet", "=", "dirichlet", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "zzs", "=", "[", "]", "\n", "df_trees", "=", "[", "]", "\n", "df_datas", "=", "[", "]", "\n", "progress_bar", "=", "st", ".", "sidebar", ".", "progress", "(", "0", ")", "\n", "for", "it", "in", "range", "(", "1", ",", "n_samples_train", "+", "1", ")", ":", "\n", "# Append the current data", "\n", "        ", "df_datas", ".", "append", "(", "df_data", "[", ":", "it", "]", ")", "\n", "\n", "# Partial fit AMFClassifier", "\n", "amf", ".", "partial_fit", "(", "X_train", "[", "it", "-", "1", "]", ".", "reshape", "(", "1", ",", "2", ")", ",", "np", ".", "array", "(", "[", "y_train", "[", "it", "-", "1", "]", "]", ")", ")", "\n", "\n", "# Get the tree", "\n", "df_tree", "=", "amf", ".", "get_nodes_df", "(", "0", ")", "\n", "df_tree", "[", "\"min_x\"", "]", "=", "df_tree", "[", "\"memory_range_min\"", "]", ".", "apply", "(", "lambda", "t", ":", "t", "[", "0", "]", ")", "\n", "df_tree", "[", "\"min_y\"", "]", "=", "df_tree", "[", "\"memory_range_min\"", "]", ".", "apply", "(", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "df_tree", "[", "\"max_x\"", "]", "=", "df_tree", "[", "\"memory_range_max\"", "]", ".", "apply", "(", "lambda", "t", ":", "t", "[", "0", "]", ")", "\n", "df_tree", "[", "\"max_y\"", "]", "=", "df_tree", "[", "\"memory_range_max\"", "]", ".", "apply", "(", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "df_tree", "[", "\"count_0\"", "]", "=", "df_tree", "[", "\"counts\"", "]", ".", "apply", "(", "lambda", "t", ":", "t", "[", "0", "]", ")", "\n", "df_tree", "[", "\"count_1\"", "]", "=", "df_tree", "[", "\"counts\"", "]", ".", "apply", "(", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "df_tree", ".", "sort_values", "(", "by", "=", "[", "\"depth\"", ",", "\"parent\"", ",", "\"id\"", "]", ",", "inplace", "=", "True", ")", "\n", "# max_depth = df.depth.max()", "\n", "max_depth", "=", "10", "\n", "n_nodes", "=", "df_tree", ".", "shape", "[", "0", "]", "\n", "x", "=", "np", ".", "zeros", "(", "n_nodes", ")", "\n", "x", "[", "0", "]", "=", "0.5", "\n", "indexes", "=", "df_tree", "[", "\"id\"", "]", ".", "values", "\n", "df_tree", "[", "\"x\"", "]", "=", "x", "\n", "df_tree", "[", "\"y\"", "]", "=", "max_depth", "-", "df_tree", "[", "\"depth\"", "]", "\n", "df_tree", "[", "\"x0\"", "]", "=", "df_tree", "[", "\"x\"", "]", "\n", "df_tree", "[", "\"y0\"", "]", "=", "df_tree", "[", "\"y\"", "]", "\n", "for", "node", "in", "range", "(", "1", ",", "n_nodes", ")", ":", "\n", "            ", "index", "=", "indexes", "[", "node", "]", "\n", "parent", "=", "df_tree", ".", "at", "[", "index", ",", "\"parent\"", "]", "\n", "depth", "=", "df_tree", ".", "at", "[", "index", ",", "\"depth\"", "]", "\n", "left_parent", "=", "df_tree", ".", "at", "[", "parent", ",", "\"left\"", "]", "\n", "x_parent", "=", "df_tree", ".", "at", "[", "parent", ",", "\"x\"", "]", "\n", "if", "left_parent", "==", "index", ":", "\n", "# It's a left node", "\n", "                ", "df_tree", ".", "at", "[", "index", ",", "\"x\"", "]", "=", "x_parent", "-", "0.5", "**", "(", "depth", "+", "1", ")", "\n", "", "else", ":", "\n", "                ", "df_tree", ".", "at", "[", "index", ",", "\"x\"", "]", "=", "x_parent", "+", "0.5", "**", "(", "depth", "+", "1", ")", "\n", "", "df_tree", ".", "at", "[", "index", ",", "\"x0\"", "]", "=", "x_parent", "\n", "df_tree", ".", "at", "[", "index", ",", "\"y0\"", "]", "=", "df_tree", ".", "at", "[", "parent", ",", "\"y\"", "]", "\n", "\n", "", "df_tree", "[", "\"color\"", "]", "=", "df_tree", "[", "\"is_leaf\"", "]", ".", "astype", "(", "\"str\"", ")", "\n", "df_tree", ".", "replace", "(", "{", "\"color\"", ":", "{", "\"False\"", ":", "\"blue\"", ",", "\"True\"", ":", "\"green\"", "}", "}", ",", "inplace", "=", "True", ")", "\n", "df_trees", ".", "append", "(", "df_tree", ")", "\n", "\n", "# Compute the decision function", "\n", "zz", "=", "amf", ".", "predict_proba", "(", "xy", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "grid_size", ",", "grid_size", ")", "\n", "zzs", ".", "append", "(", "zz", ")", "\n", "progress", "=", "int", "(", "100", "*", "it", "/", "n_samples_train", ")", "\n", "progress_bar", ".", "progress", "(", "progress", ")", "\n", "\n", "", "return", "zzs", ",", "df_datas", ",", "df_trees", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification_comparison.simulate_data": [[69, 99], ["sklearn.preprocessing.MinMaxScaler().fit_transform", "sklearn.datasets.make_moons", "sklearn.datasets.make_circles", "sklearn.preprocessing.MinMaxScaler", "sklearn.datasets.make_classification", "numpy.random.RandomState", "np.random.RandomState.uniform", "sklearn.datasets.make_blobs", "sklearn.datasets.make_moons"], "function", ["None"], ["", "@", "st", ".", "cache", "\n", "def", "simulate_data", "(", "dataset", "=", "\"moons\"", ")", ":", "\n", "    ", "if", "dataset", "==", "\"moons\"", ":", "\n", "        ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.2", ",", "random_state", "=", "random_state", ")", "\n", "", "elif", "dataset", "==", "\"circles\"", ":", "\n", "        ", "X", ",", "y", "=", "make_circles", "(", "\n", "n_samples", "=", "n_samples", ",", "noise", "=", "0.1", ",", "factor", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "", "elif", "dataset", "==", "\"linear\"", ":", "\n", "        ", "X", ",", "y", "=", "make_classification", "(", "\n", "n_samples", "=", "n_samples", ",", "\n", "n_features", "=", "2", ",", "\n", "n_redundant", "=", "0", ",", "\n", "n_informative", "=", "2", ",", "\n", "random_state", "=", "random_state", ",", "\n", "n_clusters_per_class", "=", "1", ",", "\n", "flip_y", "=", "0.001", ",", "\n", "class_sep", "=", "2.0", ",", "\n", ")", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "random_state", ")", "\n", "X", "+=", "2", "*", "rng", ".", "uniform", "(", "size", "=", "X", ".", "shape", ")", "\n", "", "elif", "dataset", "==", "\"blobs\"", ":", "\n", "        ", "X", ",", "y", "=", "make_blobs", "(", "n_samples", "=", "n_samples", ",", "centers", "=", "5", ",", "random_state", "=", "random_state", ")", "\n", "y", "[", "y", "==", "2", "]", "=", "0", "\n", "y", "[", "y", "==", "3", "]", "=", "1", "\n", "y", "[", "y", "==", "4", "]", "=", "0", "\n", "", "else", ":", "\n", "        ", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.2", ",", "random_state", "=", "random_state", ")", "\n", "", "X", "=", "MinMaxScaler", "(", ")", ".", "fit_transform", "(", "X", ")", "\n", "return", "X", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification_comparison.build_mesh": [[106, 109], ["experiments.plot.get_mesh"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.get_mesh"], ["@", "st", ".", "cache", "\n", "def", "build_mesh", "(", "X", ")", ":", "\n", "    ", "return", "get_mesh", "(", "X", ",", "h", "=", "h", ",", "padding", "=", "0.2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification_comparison.get_amf_decision": [[114, 128], ["onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "[].reshape", "onelearn.AMFClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["@", "st", ".", "cache", "\n", "def", "get_amf_decision", "(", "use_aggregation", ",", "n_estimators", ",", "split_pure", ",", "dirichlet", ",", "step", ")", ":", "\n", "    ", "amf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "n_classes", ",", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "dirichlet", "=", "dirichlet", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "amf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "zz", "=", "amf", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "return", "zz", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification_comparison.get_mf_decision": [[130, 136], ["skgarden.MondrianForestClassifier", "skgarden.MondrianForestClassifier.partial_fit", "[].reshape", "skgarden.MondrianForestClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "@", "st", ".", "cache", "\n", "def", "get_mf_decision", "(", "n_estimators", ")", ":", "\n", "    ", "clf", "=", "MondrianForestClassifier", "(", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "zz", "=", "clf", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "return", "zz", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification_comparison.get_rf_decision": [[138, 144], ["sklearn.ensemble.RandomForestClassifier", "sklearn.ensemble.RandomForestClassifier.fit", "[].reshape", "sklearn.ensemble.RandomForestClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "@", "st", ".", "cache", "\n", "def", "get_rf_decision", "(", "n_estimators", ")", ":", "\n", "    ", "clf", "=", "RandomForestClassifier", "(", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", ")", "\n", "clf", ".", "fit", "(", "X", ",", "y", ")", "\n", "zz", "=", "clf", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "return", "zz", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.examples.playground_classification_comparison.get_et_decision": [[146, 152], ["sklearn.ensemble.ExtraTreesClassifier", "sklearn.ensemble.ExtraTreesClassifier.fit", "[].reshape", "sklearn.ensemble.ExtraTreesClassifier.predict_proba"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "@", "st", ".", "cache", "\n", "def", "get_et_decision", "(", "n_estimators", ")", ":", "\n", "    ", "clf", "=", "ExtraTreesClassifier", "(", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", ")", "\n", "clf", ".", "fit", "(", "X", ",", "y", ")", "\n", "zz", "=", "clf", ".", "predict_proba", "(", "X_mesh", ")", "[", ":", ",", "1", "]", ".", "reshape", "(", "xx", ".", "shape", ")", "\n", "return", "zz", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.get_mesh": [[9, 17], ["numpy.meshgrid", "numpy.arange", "numpy.arange", "numpy.array", "X[].min", "X[].max", "X[].min", "X[].max", "xx.ravel", "yy.ravel"], "function", ["None"], ["def", "get_mesh", "(", "X", ",", "h", "=", "0.02", ",", "padding", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"Build a regular meshgrid using the range of the features in X\n    \"\"\"", "\n", "x_min", ",", "x_max", "=", "X", "[", ":", ",", "0", "]", ".", "min", "(", ")", "-", "padding", ",", "X", "[", ":", ",", "0", "]", ".", "max", "(", ")", "+", "padding", "\n", "y_min", ",", "y_max", "=", "X", "[", ":", ",", "1", "]", ".", "min", "(", ")", "-", "padding", ",", "X", "[", ":", ",", "1", "]", ".", "max", "(", ")", "+", "padding", "\n", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "np", ".", "arange", "(", "x_min", ",", "x_max", ",", "h", ")", ",", "np", ".", "arange", "(", "y_min", ",", "y_max", ",", "h", ")", ")", "\n", "X_mesh", "=", "np", ".", "array", "(", "[", "xx", ".", "ravel", "(", ")", ",", "yy", ".", "ravel", "(", ")", "]", ")", ".", "T", "\n", "return", "xx", ",", "yy", ",", "X_mesh", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.plot_scatter_binary_classif": [[19, 48], ["ax.scatter", "ax.set_xlim", "ax.set_ylim", "ax.set_xticks", "ax.set_yticks", "ax.set_xticklabels", "ax.set_yticklabels", "matplotlib.get_cmap", "ax.set_title", "xx.min", "xx.max", "yy.min", "yy.max", "ax.axis"], "function", ["None"], ["", "def", "plot_scatter_binary_classif", "(", "\n", "ax", ",", "\n", "xx", ",", "\n", "yy", ",", "\n", "X", ",", "\n", "y", ",", "\n", "s", "=", "10", ",", "\n", "alpha", "=", "None", ",", "\n", "cm", "=", "None", ",", "\n", "title", "=", "None", ",", "\n", "fontsize", "=", "None", ",", "\n", "lw", "=", "None", ",", "\n", "norm", "=", "None", ",", "\n", "noaxes", "=", "False", ",", "\n", ")", ":", "\n", "    ", "if", "cm", "is", "None", ":", "\n", "        ", "cm", "=", "plt", ".", "get_cmap", "(", "\"RdBu\"", ")", "\n", "\n", "", "ax", ".", "scatter", "(", "X", "[", ":", ",", "0", "]", ",", "X", "[", ":", ",", "1", "]", ",", "c", "=", "y", ",", "s", "=", "s", ",", "cmap", "=", "cm", ",", "alpha", "=", "alpha", ",", "lw", "=", "lw", ",", "norm", "=", "norm", ")", "\n", "if", "title", "is", "not", "None", ":", "\n", "        ", "ax", ".", "set_title", "(", "title", ",", "fontsize", "=", "fontsize", ")", "\n", "", "ax", ".", "set_xlim", "(", "xx", ".", "min", "(", ")", ",", "xx", ".", "max", "(", ")", ")", "\n", "ax", ".", "set_ylim", "(", "yy", ".", "min", "(", ")", ",", "yy", ".", "max", "(", ")", ")", "\n", "ax", ".", "set_xticks", "(", "(", ")", ")", "\n", "ax", ".", "set_yticks", "(", "(", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "ax", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "if", "noaxes", ":", "\n", "        ", "ax", ".", "axis", "(", "\"off\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.plot.plot_contour_binary_classif": [[50, 71], ["ax.contourf", "ax.set_xlim", "ax.set_ylim", "ax.set_xticks", "ax.set_yticks", "ax.set_xticklabels", "ax.set_yticklabels", "matplotlib.get_cmap", "xx.min", "xx.max", "yy.min", "yy.max", "ax.set_title", "ax.text", "xx.max", "yy.min"], "function", ["None"], ["", "", "def", "plot_contour_binary_classif", "(", "\n", "ax", ",", "xx", ",", "yy", ",", "Z", ",", "cm", "=", "None", ",", "alpha", "=", "0.8", ",", "levels", "=", "200", ",", "title", "=", "None", ",", "score", "=", "None", ",", "norm", "=", "None", "\n", ")", ":", "\n", "    ", "if", "cm", "is", "None", ":", "\n", "        ", "cm", "=", "plt", ".", "get_cmap", "(", "\"RdBu\"", ")", "\n", "", "ax", ".", "contourf", "(", "xx", ",", "yy", ",", "Z", ",", "cmap", "=", "cm", ",", "alpha", "=", "alpha", ",", "levels", "=", "levels", ",", "norm", "=", "norm", ")", "\n", "ax", ".", "set_xlim", "(", "xx", ".", "min", "(", ")", ",", "xx", ".", "max", "(", ")", ")", "\n", "ax", ".", "set_ylim", "(", "yy", ".", "min", "(", ")", ",", "yy", ".", "max", "(", ")", ")", "\n", "ax", ".", "set_xticks", "(", "(", ")", ")", "\n", "ax", ".", "set_yticks", "(", "(", ")", ")", "\n", "ax", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "ax", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "if", "title", "is", "not", "None", ":", "\n", "        ", "ax", ".", "set_title", "(", "title", ")", "\n", "", "if", "score", "is", "not", "None", ":", "\n", "        ", "ax", ".", "text", "(", "\n", "xx", ".", "max", "(", ")", "-", "0.3", ",", "\n", "yy", ".", "min", "(", ")", "+", "0.3", ",", "\n", "(", "\"%.2f\"", "%", "score", ")", ".", "lstrip", "(", "\"0\"", ")", ",", "\n", "size", "=", "25", ",", "\n", "horizontalalignment", "=", "\"right\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.n_tree_sensitivity.compute_aucs_n_trees": [[18, 39], ["sklearn.model_selection.train_test_split", "int", "numpy.arange", "utils.get_classifiers_n_trees_comparison", "collections.defaultdict", "logging.info", "hasattr", "clf.predict_proba", "sklearn.metrics.roc_auc_score", "test_aucs[].append", "hasattr", "y.max", "clf.partial_fit", "clf.fit", "clf.clear"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.get_classifiers_n_trees_comparison", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["def", "compute_aucs_n_trees", "(", "X", ",", "y", ",", "random_state", "=", "42", ")", ":", "\n", "    ", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "train_size", "=", "0.7", ",", "random_state", "=", "random_state", ",", "shuffle", "=", "True", ",", "stratify", "=", "y", "\n", ")", "\n", "n_classes", "=", "int", "(", "y", ".", "max", "(", ")", "+", "1", ")", "\n", "classes", "=", "np", ".", "arange", "(", "n_classes", ")", "\n", "classifiers", "=", "get_classifiers_n_trees_comparison", "(", "n_classes", ")", "\n", "test_aucs", "=", "defaultdict", "(", "list", ")", "\n", "for", "clf_name", ",", "clf", "in", "classifiers", ":", "\n", "        ", "logging", ".", "info", "(", "\"  using %s\"", "%", "clf_name", ")", "\n", "if", "hasattr", "(", "clf", ",", "\"partial_fit\"", ")", ":", "\n", "            ", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ",", "classes", "=", "classes", ")", "\n", "", "else", ":", "\n", "            ", "clf", ".", "fit", "(", "X_train", ",", "y_train", ")", "\n", "", "y_pred", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "auc", "=", "roc_auc_score", "(", "y_test", ",", "y_pred", "[", ":", ",", "1", "]", ")", "\n", "test_aucs", "[", "clf_name", "]", ".", "append", "(", "auc", ")", "\n", "if", "hasattr", "(", "clf", ",", "\"clear\"", ")", ":", "\n", "            ", "clf", ".", "clear", "(", ")", "\n", "", "del", "clf", "\n", "", "return", "test_aucs", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.n_tree_sensitivity.read_data_n_trees": [[41, 74], ["pandas.DataFrame", "os.path.join", "pathlib.Path", "open", "pickle.load", "itertools.product", "enumerate", "max", "col_dataset.append", "col_clf.append", "col_n_trees.append", "col_auc.append", "col_x_pos.append"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.load"], ["", "def", "read_data_n_trees", "(", "filenames", ")", ":", "\n", "    ", "n_treess", "=", "[", "1", ",", "2", ",", "5", ",", "10", ",", "20", ",", "50", "]", "\n", "col_clf", "=", "[", "]", "\n", "col_n_trees", "=", "[", "]", "\n", "col_auc", "=", "[", "]", "\n", "col_dataset", "=", "[", "]", "\n", "col_x_pos", "=", "[", "]", "\n", "for", "filename", "in", "filenames", ":", "\n", "        ", "filename_pkl", "=", "os", ".", "path", ".", "join", "(", "filename", ")", "\n", "p", "=", "Path", "(", "filename_pkl", ")", "\n", "with", "open", "(", "p", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "results", "=", "pkl", ".", "load", "(", "f", ")", "\n", "dataset", "=", "results", "[", "\"dataset\"", "]", "\n", "for", "clf_name", ",", "(", "x_pos", ",", "n_trees", ")", "in", "product", "(", "\n", "[", "\"AMF\"", ",", "\"MF\"", ",", "\"RF\"", ",", "\"ET\"", "]", ",", "enumerate", "(", "n_treess", ")", "\n", ")", ":", "\n", "                ", "key", "=", "clf_name", "+", "\"(nt=%d)\"", "%", "n_trees", "\n", "auc", "=", "max", "(", "results", "[", "\"test_aucs\"", "]", "[", "key", "]", ")", "\n", "col_dataset", ".", "append", "(", "dataset", ")", "\n", "col_clf", ".", "append", "(", "clf_name", ")", "\n", "col_n_trees", ".", "append", "(", "n_trees", ")", "\n", "col_auc", ".", "append", "(", "auc", ")", "\n", "col_x_pos", ".", "append", "(", "x_pos", "+", "1", ")", "\n", "", "", "", "df", "=", "pd", ".", "DataFrame", "(", "\n", "{", "\n", "\"dataset\"", ":", "col_dataset", ",", "\n", "\"clf\"", ":", "col_clf", ",", "\n", "\"n_trees\"", ":", "col_n_trees", ",", "\n", "\"auc\"", ":", "col_auc", ",", "\n", "\"x_pos\"", ":", "col_x_pos", ",", "\n", "}", "\n", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.n_tree_sensitivity.plot_comparison_n_trees": [[76, 118], ["df[].unique", "seaborn.FacetGrid", "sns.FacetGrid.map().set", "sns.FacetGrid.axes.flatten", "enumerate", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.tight_layout", "df[].unique", "axes[].set_xticklabels", "axes[].set_title", "matplotlib.legend", "matplotlib.savefig", "logging.info", "matplotlib.show", "sns.FacetGrid.map"], "function", ["None"], ["", "def", "plot_comparison_n_trees", "(", "df", ",", "filename", "=", "None", ",", "legend", "=", "True", ")", ":", "\n", "    ", "df", "[", "\"dataset\"", "]", ".", "unique", "(", ")", "\n", "g", "=", "sns", ".", "FacetGrid", "(", "\n", "df", ",", "col", "=", "\"dataset\"", ",", "col_wrap", "=", "4", ",", "aspect", "=", "1", ",", "height", "=", "4", ",", "sharex", "=", "True", ",", "sharey", "=", "False", "\n", ")", "\n", "g", ".", "map", "(", "\n", "sns", ".", "lineplot", ",", "\n", "\"x_pos\"", ",", "\n", "\"auc\"", ",", "\n", "\"clf\"", ",", "\n", "lw", "=", "4", ",", "\n", "marker", "=", "\"o\"", ",", "\n", "markersize", "=", "10", ",", "\n", "palette", "=", "classifier_colors", ",", "\n", ")", ".", "set", "(", "yscale", "=", "\"log\"", ",", "xlabel", "=", "\"\"", ",", "ylabel", "=", "\"\"", ")", "\n", "\n", "axes", "=", "g", ".", "axes", ".", "flatten", "(", ")", "\n", "\n", "for", "i", ",", "dataset", "in", "enumerate", "(", "df", "[", "\"dataset\"", "]", ".", "unique", "(", ")", ")", ":", "\n", "        ", "axes", "[", "i", "]", ".", "set_xticklabels", "(", "[", "0", ",", "1", ",", "2", ",", "5", ",", "10", ",", "20", ",", "50", "]", ",", "fontsize", "=", "14", ")", "\n", "axes", "[", "i", "]", ".", "set_title", "(", "dataset", ",", "fontsize", "=", "18", ")", "\n", "\n", "", "if", "legend", ":", "\n", "        ", "plt", ".", "legend", "(", "\n", "[", "\"AMF\"", ",", "\"MF\"", ",", "\"RF\"", ",", "\"ET\"", "]", ",", "\n", "bbox_to_anchor", "=", "(", "0.3", ",", "0.7", ",", "1.0", ",", "0.0", ")", ",", "\n", "loc", "=", "\"upper right\"", ",", "\n", "ncol", "=", "1", ",", "\n", "borderaxespad", "=", "0.0", ",", "\n", "fontsize", "=", "14", ",", "\n", ")", "\n", "\n", "", "plt", ".", "xticks", "(", "fontsize", "=", "14", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "14", ")", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "\n", "if", "filename", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", ")", "\n", "logging", ".", "info", "(", "\"Saved figure in \"", "+", "filename", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "show", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.print_datasets": [[28, 57], ["pandas.DataFrame", "logging.info", "print", "loader", "int", "col_n_samples.append", "col_n_features.append", "col_n_classes.append", "col_names.append", "col_sizes.append", "y.max"], "function", ["None"], ["", "else", ":", "\n", "        ", "return", "class_type", ".", "instance_type", "\n", "\n", "\n", "", "", "@", "njit", "\n", "def", "resize_array", "(", "arr", ",", "keep", ",", "size", ",", "fill", "=", "0", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.log_loss": [[59, 79], ["numpy.unique", "numpy.clip", "enumerate", "numpy.array", "numpy.array", "numpy.ones", "enumerate", "enumerate", "numpy.log", "numpy.log"], "function", ["None"], ["\n", "if", "arr", ".", "ndim", "==", "1", ":", "\n", "        ", "if", "fill", "is", "None", ":", "\n", "            ", "new", "=", "np", ".", "empty", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "elif", "fill", "==", "1", ":", "\n", "            ", "new", "=", "np", ".", "ones", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "new", "=", "np", ".", "zeros", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "new", "[", ":", "keep", "]", "=", "arr", "[", ":", "keep", "]", "\n", "return", "new", "\n", "", "elif", "arr", ".", "ndim", "==", "2", ":", "\n", "        ", "_", ",", "n_cols", "=", "arr", ".", "shape", "\n", "if", "fill", "is", "None", ":", "\n", "            ", "new", "=", "np", ".", "empty", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "elif", "fill", "==", "1", ":", "\n", "            ", "new", "=", "np", ".", "ones", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "new", "=", "np", ".", "zeros", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "new", "[", ":", "keep", "]", "=", "arr", "[", ":", "keep", "]", "\n", "return", "new", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.log_loss_single": [[81, 85], ["numpy.clip", "numpy.log", "int"], "function", ["None"], ["\n", "\n", "# Sadly there is no function to sample for a discrete distribution in numba", "\n", "", "", "@", "njit", "(", "uint32", "(", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "sample_discrete", "(", "distribution", ")", ":", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.get_classifiers_online": [[87, 136], ["itertools.product", "onelearn.OnlineDummyClassifier", "onelearn.AMFClassifier", "skgarden.MondrianForestClassifier", "sklearn.linear_model.SGDClassifier"], "function", ["None"], ["\n", "# Notes", "\n", "U", "=", "uniform", "(", "0.0", ",", "1.0", ")", "\n", "cumsum", "=", "0.0", "\n", "size", "=", "distribution", ".", "size", "\n", "for", "j", "in", "range", "(", "size", ")", ":", "\n", "        ", "cumsum", "+=", "distribution", "[", "j", "]", "\n", "if", "U", "<=", "cumsum", ":", "\n", "            ", "return", "j", "\n", "", "", "return", "size", "-", "1", "\n", "\n", "\n", "", "@", "njit", "(", "float32", "(", "float32", ",", "float32", ")", ")", "\n", "def", "log_sum_2_exp", "(", "a", ",", "b", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.get_classifiers_batch": [[140, 212], ["itertools.product", "onelearn.AMFClassifier", "skgarden.MondrianForestClassifier", "sklearn.ensemble.RandomForestClassifier", "sklearn.ensemble.ExtraTreesClassifier", "sklearn.linear_model.SGDClassifier"], "function", ["None"], ["# TODO: try several log and exp implementations", "\n", "if", "a", ">", "b", ":", "\n", "        ", "return", "a", "+", "log", "(", "(", "1", "+", "exp", "(", "b", "-", "a", ")", ")", "/", "2", ")", "\n", "", "else", ":", "\n", "        ", "return", "b", "+", "log", "(", "(", "1", "+", "exp", "(", "a", "-", "b", ")", ")", "/", "2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.get_classifiers_n_trees_comparison": [[216, 264], ["itertools.product", "onelearn.AMFClassifier", "skgarden.MondrianForestClassifier", "sklearn.ensemble.RandomForestClassifier", "sklearn.ensemble.ExtraTreesClassifier", "str", "str", "str", "str"], "function", ["None"], []], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.online_vs_batch.compute_regrets_and_batch": [[12, 58], ["sklearn.model_selection.train_test_split", "collections.defaultdict", "collections.defaultdict", "int", "numpy.arange", "utils.get_classifiers_batch", "collections.defaultdict", "logging.info", "hasattr", "hasattr", "y.max", "range", "clf.fit", "clf.predict_proba", "utils.log_loss", "clf.clear", "X_train[].reshape", "numpy.array", "clf.partial_fit", "sklearn.metrics.roc_auc_score", "test_aucs[].append", "clf.predict_proba", "utils.log_loss", "test_losses[].append", "iterations[].append", "sklearn.metrics.roc_auc_score", "test_aucs[].append"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.get_classifiers_batch", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.log_loss", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.log_loss"], ["def", "compute_regrets_and_batch", "(", "X", ",", "y", ")", ":", "\n", "    ", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "train_size", "=", "0.7", ",", "random_state", "=", "42", ",", "shuffle", "=", "True", ",", "stratify", "=", "y", "\n", ")", "\n", "test_losses", "=", "defaultdict", "(", "list", ")", "\n", "iterations", "=", "defaultdict", "(", "list", ")", "\n", "n_samples", ",", "n_features", "=", "X_train", ".", "shape", "\n", "n_iterations", "=", "n_samples", "-", "1", "\n", "n_classes", "=", "int", "(", "y", ".", "max", "(", ")", "+", "1", ")", "\n", "classes", "=", "np", ".", "arange", "(", "n_classes", ")", "\n", "classifiers", "=", "get_classifiers_batch", "(", "n_classes", ")", "\n", "test_aucs", "=", "defaultdict", "(", "list", ")", "\n", "for", "clf_name", ",", "clf", "in", "classifiers", ":", "\n", "        ", "logging", ".", "info", "(", "\"  using %s\"", "%", "clf_name", ")", "\n", "if", "hasattr", "(", "clf", ",", "\"partial_fit\"", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "n_iterations", ")", ":", "\n", "                ", "xi_train", "=", "X_train", "[", "i", "-", "1", "]", ".", "reshape", "(", "1", ",", "n_features", ")", "\n", "yi_train", "=", "np", ".", "array", "(", "[", "y_train", "[", "i", "-", "1", "]", "]", ")", "\n", "clf", ".", "partial_fit", "(", "xi_train", ",", "yi_train", ",", "classes", "=", "classes", ")", "\n", "if", "i", "%", "100", "==", "0", ":", "\n", "                    ", "y_pred", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "test_loss", "=", "log_loss", "(", "\n", "y_test", ",", "y_pred", ",", "n_classes", "=", "n_classes", ",", "normalize", "=", "True", "\n", ")", "\n", "test_losses", "[", "clf_name", "]", ".", "append", "(", "test_loss", ")", "\n", "iterations", "[", "clf_name", "]", ".", "append", "(", "i", ")", "\n", "if", "n_classes", "==", "2", ":", "\n", "                        ", "auc", "=", "roc_auc_score", "(", "y_test", ",", "y_pred", "[", ":", ",", "1", "]", ")", "\n", "test_aucs", "[", "clf_name", "]", ".", "append", "(", "auc", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "clf", ".", "fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "test_loss", "=", "log_loss", "(", "y_test", ",", "y_pred", ",", "n_classes", "=", "n_classes", ",", "normalize", "=", "True", ")", "\n", "test_losses", "[", "clf_name", "]", "=", "test_loss", "\n", "iterations", "[", "clf_name", "]", "=", "n_iterations", "\n", "if", "n_classes", "==", "2", ":", "\n", "                ", "auc", "=", "roc_auc_score", "(", "y_test", ",", "y_pred", "[", ":", ",", "1", "]", ")", "\n", "test_aucs", "[", "clf_name", "]", ".", "append", "(", "auc", ")", "\n", "", "", "if", "hasattr", "(", "clf", ",", "\"clear\"", ")", ":", "\n", "            ", "clf", ".", "clear", "(", ")", "\n", "", "del", "clf", "\n", "\n", "", "return", "{", "\n", "\"iterations\"", ":", "iterations", ",", "\n", "\"test_losses\"", ":", "test_losses", ",", "\n", "\"test_aucs\"", ":", "test_aucs", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.online_vs_batch.plot_online_vs_batch": [[61, 107], ["matplotlib.figure", "matplotlib.title", "matplotlib.legend", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.tight_layout", "matplotlib.plot", "matplotlib.savefig", "clf_name.startswith", "clf_name.startswith", "numpy.array", "clf_name.split", "clf_name.split"], "function", ["None"], ["", "def", "plot_online_vs_batch", "(", "\n", "results", ",", "\n", "show_classifiers", ",", "\n", "savefig", "=", "None", ",", "\n", "remove_parameters", "=", "True", ",", "\n", "figsize", "=", "(", "4.5", ",", "4", ")", ",", "\n", "type", "=", "\"log\"", ",", "\n", ")", ":", "\n", "    ", "dataset_name", "=", "results", "[", "\"dataset\"", "]", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "if", "type", "==", "\"auc\"", ":", "\n", "        ", "key", "=", "\"test_aucs\"", "\n", "", "else", ":", "\n", "        ", "key", "=", "\"test_losses\"", "\n", "", "offset", "=", "0", "\n", "\n", "for", "clf_name", "in", "show_classifiers", ":", "\n", "        ", "if", "clf_name", ".", "startswith", "(", "\"RF\"", ")", "or", "clf_name", ".", "startswith", "(", "\"ET\"", ")", ":", "\n", "            ", "test_loss", "=", "results", "[", "key", "]", "[", "clf_name", "]", "\n", "test_losses", "=", "[", "test_loss", ",", "test_loss", "]", "\n", "n_iter", "=", "results", "[", "\"iterations\"", "]", "[", "clf_name", "]", "\n", "iterations", "=", "[", "0", ",", "n_iter", "]", "\n", "if", "remove_parameters", ":", "\n", "                ", "label", "=", "clf_name", ".", "split", "(", "\"(\"", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "label", "=", "clf_name", "\n", "", "", "else", ":", "\n", "            ", "test_losses", "=", "np", ".", "array", "(", "results", "[", "key", "]", "[", "clf_name", "]", ")", "\n", "iterations", "=", "results", "[", "\"iterations\"", "]", "[", "clf_name", "]", "\n", "if", "remove_parameters", ":", "\n", "                ", "label", "=", "clf_name", ".", "split", "(", "\"(\"", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "label", "=", "clf_name", "\n", "", "offset", "=", "0", "\n", "\n", "", "col", "=", "classifier_colors", "[", "label", "]", "\n", "plt", ".", "plot", "(", "iterations", "[", "offset", ":", "]", ",", "test_losses", "[", "offset", ":", "]", ",", "label", "=", "label", ",", "lw", "=", "6", ",", "c", "=", "col", ")", "\n", "\n", "", "plt", ".", "title", "(", "dataset_name", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "legend", "(", "fontsize", "=", "16", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "9", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "9", ")", "\n", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "if", "savefig", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savefig", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.regrets.compute_regrets": [[13, 45], ["collections.defaultdict", "collections.defaultdict", "numpy.arange", "int", "numpy.arange", "utils.get_classifiers_online", "sklearn.utils.shuffle", "hasattr", "logging.info", "tqdm.tqdm", "hasattr", "y.max", "range", "X[].reshape", "numpy.array", "X[].reshape", "numpy.array", "time.time", "clf.partial_fit", "time.time", "clf.predict_proba", "utils.log_loss_single", "regrets[].append", "timings[].append", "clf.clear"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.get_classifiers_online", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.utils.log_loss_single"], ["def", "compute_regrets", "(", "X", ",", "y", ",", "shuffle", "=", "True", ",", "random_state", "=", "42", ")", ":", "\n", "    ", "regrets", "=", "defaultdict", "(", "list", ")", "\n", "timings", "=", "defaultdict", "(", "list", ")", "\n", "if", "shuffle", ":", "\n", "        ", "X", ",", "y", "=", "skshuffle", "(", "X", ",", "y", ",", "random_state", "=", "random_state", ")", "\n", "\n", "", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "n_iterations", "=", "n_samples", "-", "1", "\n", "iterations", "=", "np", ".", "arange", "(", "n_iterations", ")", "\n", "n_classes", "=", "int", "(", "y", ".", "max", "(", ")", "+", "1", ")", "\n", "classes", "=", "np", ".", "arange", "(", "n_classes", ")", "\n", "classifiers", "=", "get_classifiers_online", "(", "n_classes", ")", "\n", "\n", "for", "clf_name", ",", "clf", "in", "classifiers", ":", "\n", "        ", "assert", "hasattr", "(", "clf", ",", "\"partial_fit\"", ")", "\n", "logging", ".", "info", "(", "\"  using %s\"", "%", "clf_name", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "1", ",", "n_iterations", ")", ")", ":", "\n", "            ", "x_train", "=", "X", "[", "i", "-", "1", "]", ".", "reshape", "(", "1", ",", "n_features", ")", "\n", "y_train", "=", "np", ".", "array", "(", "[", "y", "[", "i", "-", "1", "]", "]", ")", "\n", "x_test", "=", "X", "[", "i", "]", ".", "reshape", "(", "1", ",", "n_features", ")", "\n", "y_test", "=", "np", ".", "array", "(", "[", "y", "[", "i", "]", "]", ")", "\n", "t1", "=", "time", "(", ")", "\n", "clf", ".", "partial_fit", "(", "x_train", ",", "y_train", ",", "classes", ")", "\n", "t2", "=", "time", "(", ")", "\n", "y_pred", "=", "clf", ".", "predict_proba", "(", "x_test", ")", "\n", "test_loss", "=", "log_loss_single", "(", "y_test", ",", "y_pred", ")", "\n", "regrets", "[", "clf_name", "]", ".", "append", "(", "test_loss", ")", "\n", "timings", "[", "clf_name", "]", ".", "append", "(", "t2", "-", "t1", ")", "\n", "", "if", "hasattr", "(", "clf", ",", "\"clear\"", ")", ":", "\n", "            ", "clf", ".", "clear", "(", ")", "\n", "", "del", "clf", "\n", "", "return", "iterations", ",", "regrets", ",", "timings", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.experiments.regrets.plot_regrets": [[47, 109], ["matplotlib.figure", "matplotlib.title", "matplotlib.legend", "matplotlib.xticks", "matplotlib.yticks", "matplotlib.tight_layout", "numpy.array", "numpy.arange", "matplotlib.plot", "avg_regret.max", "matplotlib.yscale", "matplotlib.ylim", "matplotlib.ylim", "matplotlib.savefig", "numpy.array().cumsum", "clf_name.split", "numpy.array"], "function", ["None"], ["", "def", "plot_regrets", "(", "\n", "results", ",", "\n", "show_classifiers", ",", "\n", "savefig", "=", "None", ",", "\n", "log_scale", "=", "False", ",", "\n", "remove_parameters", "=", "True", ",", "\n", "offset", "=", "0", ",", "\n", "figsize", "=", "(", "4.5", ",", "4", ")", ",", "\n", "ylim", "=", "None", ",", "\n", ")", ":", "\n", "    ", "dataset_name", "=", "results", "[", "\"dataset\"", "]", "\n", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "\n", "ylim_min", "=", "1e15", "\n", "ylim_max", "=", "-", "1e15", "\n", "\n", "for", "clf_name", "in", "show_classifiers", ":", "\n", "        ", "regret", "=", "np", ".", "array", "(", "results", "[", "\"regrets\"", "]", "[", "clf_name", "]", ")", "\n", "n_minibatch", "=", "regret", ".", "shape", "[", "0", "]", "\n", "iterations", "=", "np", ".", "arange", "(", "1", ",", "n_minibatch", "+", "1", ")", "\n", "\n", "if", "remove_parameters", ":", "\n", "            ", "label", "=", "clf_name", ".", "split", "(", "\"(\"", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "label", "=", "clf_name", "\n", "\n", "", "avg_regret", "=", "np", ".", "array", "(", "regret", ")", ".", "cumsum", "(", ")", "/", "iterations", "\n", "col", "=", "classifier_colors", "[", "label", "]", "\n", "\n", "iterations", "=", "iterations", "[", "offset", ":", "]", "\n", "avg_regret", "=", "avg_regret", "[", "offset", ":", "]", "\n", "\n", "plt", ".", "plot", "(", "iterations", ",", "avg_regret", ",", "label", "=", "label", ",", "lw", "=", "6", ",", "c", "=", "col", ")", "\n", "start_regret", "=", "avg_regret", ".", "max", "(", ")", "\n", "\n", "if", "start_regret", ">", "ylim_max", ":", "\n", "            ", "ylim_max", "=", "start_regret", "\n", "\n", "", "end_regret", "=", "avg_regret", "[", "-", "1", "]", "\n", "if", "end_regret", "<", "ylim_min", ":", "\n", "            ", "ylim_min", "=", "end_regret", "\n", "\n", "", "", "ylim_min", "*=", "0.9", "\n", "ylim_max", "*=", "1.1", "\n", "\n", "plt", ".", "title", "(", "dataset_name", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "legend", "(", "fontsize", "=", "16", ",", "loc", "=", "\"upper right\"", ")", "\n", "\n", "if", "log_scale", ":", "\n", "        ", "plt", ".", "yscale", "(", "\"log\"", ")", "\n", "\n", "", "plt", ".", "xticks", "(", "fontsize", "=", "9", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "9", ")", "\n", "\n", "if", "ylim", ":", "\n", "        ", "plt", ".", "ylim", "(", "ylim", ")", "\n", "", "else", ":", "\n", "        ", "plt", ".", "ylim", "(", "(", "ylim_min", ",", "ylim_max", ")", ")", "\n", "\n", "", "plt", ".", "tight_layout", "(", ")", "\n", "if", "savefig", "is", "not", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "savefig", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.sphinx_ext.github_link._get_git_revision": [[11, 18], ["subprocess.check_output().strip.decode", "subprocess.check_output().strip", "print", "subprocess.check_output", "REVISION_CMD.split"], "function", ["None"], ["def", "_get_git_revision", "(", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "revision", "=", "subprocess", ".", "check_output", "(", "REVISION_CMD", ".", "split", "(", ")", ")", ".", "strip", "(", ")", "\n", "", "except", "(", "subprocess", ".", "CalledProcessError", ",", "OSError", ")", ":", "\n", "        ", "print", "(", "\"Failed to execute git to get revision\"", ")", "\n", "return", "None", "\n", "", "return", "revision", ".", "decode", "(", "\"utf-8\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.sphinx_ext.github_link._linkcode_resolve": [[20, 65], ["__import__", "os.path.relpath", "url_fmt.format", "info[].split", "type", "class_name.encode.encode", "operator.attrgetter", "inspect.getsourcefile", "info.get", "info.get", "inspect.getsourcefile", "os.path.dirname", "inspect.getsourcelines", "__import__"], "function", ["None"], ["", "def", "_linkcode_resolve", "(", "domain", ",", "info", ",", "package", ",", "url_fmt", ",", "revision", ")", ":", "\n", "    ", "\"\"\"Determine a link to online source for a class/method/function\n    This is called by sphinx.ext.linkcode\n    An example with a long-untouched module that everyone has\n    >>> _linkcode_resolve('py', {'module': 'tty',\n    ...                          'fullname': 'setraw'},\n    ...                   package='tty',\n    ...                   url_fmt='http://hg.python.org/cpython/file/'\n    ...                           '{revision}/Lib/{package}/{path}#L{lineno}',\n    ...                   revision='xxxx')\n    'http://hg.python.org/cpython/file/xxxx/Lib/tty/tty.py#L18'\n    \"\"\"", "\n", "\n", "if", "revision", "is", "None", ":", "\n", "        ", "return", "\n", "", "if", "domain", "not", "in", "(", "\"py\"", ",", "\"pyx\"", ")", ":", "\n", "        ", "return", "\n", "", "if", "not", "info", ".", "get", "(", "\"module\"", ")", "or", "not", "info", ".", "get", "(", "\"fullname\"", ")", ":", "\n", "        ", "return", "\n", "\n", "", "class_name", "=", "info", "[", "\"fullname\"", "]", ".", "split", "(", "\".\"", ")", "[", "0", "]", "\n", "if", "type", "(", "class_name", ")", "!=", "str", ":", "\n", "# Python 2 only", "\n", "        ", "class_name", "=", "class_name", ".", "encode", "(", "\"utf-8\"", ")", "\n", "", "module", "=", "__import__", "(", "info", "[", "\"module\"", "]", ",", "fromlist", "=", "[", "class_name", "]", ")", "\n", "obj", "=", "attrgetter", "(", "info", "[", "\"fullname\"", "]", ")", "(", "module", ")", "\n", "\n", "try", ":", "\n", "        ", "fn", "=", "inspect", ".", "getsourcefile", "(", "obj", ")", "\n", "", "except", "Exception", ":", "\n", "        ", "fn", "=", "None", "\n", "", "if", "not", "fn", ":", "\n", "        ", "try", ":", "\n", "            ", "fn", "=", "inspect", ".", "getsourcefile", "(", "sys", ".", "modules", "[", "obj", ".", "__module__", "]", ")", "\n", "", "except", "Exception", ":", "\n", "            ", "fn", "=", "None", "\n", "", "", "if", "not", "fn", ":", "\n", "        ", "return", "\n", "\n", "", "fn", "=", "os", ".", "path", ".", "relpath", "(", "fn", ",", "start", "=", "os", ".", "path", ".", "dirname", "(", "__import__", "(", "package", ")", ".", "__file__", ")", ")", "\n", "try", ":", "\n", "        ", "lineno", "=", "inspect", ".", "getsourcelines", "(", "obj", ")", "[", "1", "]", "\n", "", "except", "Exception", ":", "\n", "        ", "lineno", "=", "\"\"", "\n", "", "return", "url_fmt", ".", "format", "(", "revision", "=", "revision", ",", "package", "=", "package", ",", "path", "=", "fn", ",", "lineno", "=", "lineno", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.sphinx_ext.github_link.make_linkcode_resolve": [[67, 78], ["github_link._get_git_revision", "functools.partial"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.sphinx_ext.github_link._get_git_revision"], ["", "def", "make_linkcode_resolve", "(", "package", ",", "url_fmt", ")", ":", "\n", "    ", "\"\"\"Returns a linkcode_resolve function for the given URL format\n    revision is a git commit reference (hash or name)\n    package is the name of the root module of the package\n    url_fmt is along the lines of ('https://github.com/USER/PROJECT/'\n                                   'blob/{revision}/{package}/'\n                                   '{path}#L{lineno}')\n    \"\"\"", "\n", "revision", "=", "_get_git_revision", "(", ")", "\n", "return", "partial", "(", "\n", "_linkcode_resolve", ",", "revision", "=", "revision", ",", "package", "=", "package", ",", "url_fmt", "=", "url_fmt", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_samples_collection.TestSamplesCollection.test_samples_collection": [[6, 58], ["SamplesCollection", "np.zeros", "np.zeros", "add_samples", "add_samples", "add_samples", "add_samples", "np.zeros", "np.zeros", "add_samples", "np.zeros", "np.zeros", "add_samples", "np.zeros", "np.zeros", "add_samples", "add_samples", "add_samples"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.sample.add_samples"], ["    ", "def", "test_samples_collection", "(", "self", ")", ":", "\n", "        ", "import", "numpy", "as", "np", "\n", "from", "onelearn", ".", "sample", "import", "SamplesCollection", ",", "add_samples", "\n", "\n", "n_samples_increment", "=", "10", "\n", "n_features", "=", "3", "\n", "\n", "samples", "=", "SamplesCollection", "(", "n_samples_increment", ",", "n_features", ",", "0", ",", "0", ")", "\n", "X", "=", "np", ".", "zeros", "(", "(", "4", ",", "n_features", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "y", "=", "np", ".", "zeros", "(", "4", ",", "dtype", "=", "\"float32\"", ")", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_increment", "==", "10", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "10", "\n", "assert", "samples", ".", "n_samples", "==", "4", "\n", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "10", "\n", "assert", "samples", ".", "n_samples", "==", "8", "\n", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "20", "\n", "assert", "samples", ".", "n_samples", "==", "12", "\n", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "20", "\n", "assert", "samples", ".", "n_samples", "==", "16", "\n", "\n", "X", "=", "np", ".", "zeros", "(", "(", "8", ",", "n_features", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "y", "=", "np", ".", "zeros", "(", "8", ",", "dtype", "=", "\"float32\"", ")", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "30", "\n", "assert", "samples", ".", "n_samples", "==", "24", "\n", "\n", "X", "=", "np", ".", "zeros", "(", "(", "12", ",", "n_features", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "y", "=", "np", ".", "zeros", "(", "12", ",", "dtype", "=", "\"float32\"", ")", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "40", "\n", "assert", "samples", ".", "n_samples", "==", "36", "\n", "\n", "X", "=", "np", ".", "zeros", "(", "(", "4", ",", "n_features", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "y", "=", "np", ".", "zeros", "(", "4", ",", "dtype", "=", "\"float32\"", ")", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "50", "\n", "assert", "samples", ".", "n_samples", "==", "40", "\n", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "50", "\n", "assert", "samples", ".", "n_samples", "==", "44", "\n", "\n", "add_samples", "(", "samples", ",", "X", ",", "y", ")", "\n", "assert", "samples", ".", "n_samples_capacity", "==", "50", "\n", "assert", "samples", ".", "n_samples", "==", "48", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_nodes_collections.TestNodesCollection.test_nodes_classifier": [[7, 40], ["NodesClassifier", "add_node_classifier", "add_node_classifier", "add_node_classifier", "add_node_classifier", "add_node_classifier", "add_node_classifier", "copy_node_classifier", "approx", "approx"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_classifier", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx"], ["    ", "def", "test_nodes_classifier", "(", "self", ")", ":", "\n", "        ", "from", "onelearn", ".", "node_collection", "import", "(", "\n", "NodesClassifier", ",", "\n", "add_node_classifier", ",", "\n", "copy_node_classifier", ",", "\n", ")", "\n", "\n", "n_features", "=", "3", "\n", "n_classes", "=", "2", "\n", "n_samples_increment", "=", "2", "\n", "\n", "nodes", "=", "NodesClassifier", "(", "n_features", ",", "n_classes", ",", "n_samples_increment", ",", "0", ",", "0", ")", "\n", "assert", "nodes", ".", "n_nodes", "==", "0", "\n", "assert", "nodes", ".", "n_samples_increment", "==", "2", "\n", "assert", "nodes", ".", "n_nodes_capacity", "==", "5", "\n", "\n", "add_node_classifier", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_classifier", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_classifier", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "assert", "nodes", ".", "n_nodes", "==", "3", "\n", "assert", "nodes", ".", "n_nodes_capacity", "==", "5", "\n", "\n", "add_node_classifier", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_classifier", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_classifier", "(", "nodes", ",", "13", ",", "2.78", ")", "\n", "assert", "nodes", ".", "n_nodes", "==", "6", "\n", "assert", "nodes", ".", "n_nodes_capacity", "==", "10", "\n", "assert", "nodes", ".", "parent", "[", "4", "]", "==", "0", "\n", "assert", "nodes", ".", "time", "[", "4", "]", "==", "approx", "(", "3.14", ",", "1e-7", ")", "\n", "\n", "copy_node_classifier", "(", "nodes", ",", "5", ",", "4", ")", "\n", "assert", "nodes", ".", "parent", "[", "4", "]", "==", "13", "\n", "assert", "nodes", ".", "time", "[", "4", "]", "==", "approx", "(", "2.78", ",", "1e-7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_nodes_collections.TestNodesCollection.test_nodes_regressor": [[41, 73], ["NodesRegressor", "add_node_regressor", "add_node_regressor", "add_node_regressor", "add_node_regressor", "add_node_regressor", "add_node_regressor", "copy_node_regressor", "approx", "approx"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.add_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.node_collection.copy_node_regressor", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx"], ["", "def", "test_nodes_regressor", "(", "self", ")", ":", "\n", "        ", "from", "onelearn", ".", "node_collection", "import", "(", "\n", "NodesRegressor", ",", "\n", "add_node_regressor", ",", "\n", "copy_node_regressor", ",", "\n", ")", "\n", "\n", "n_features", "=", "3", "\n", "n_samples_increment", "=", "2", "\n", "\n", "nodes", "=", "NodesRegressor", "(", "n_features", ",", "n_samples_increment", ",", "0", ",", "0", ")", "\n", "assert", "nodes", ".", "n_nodes", "==", "0", "\n", "assert", "nodes", ".", "n_samples_increment", "==", "2", "\n", "assert", "nodes", ".", "n_nodes_capacity", "==", "5", "\n", "\n", "add_node_regressor", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_regressor", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_regressor", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "assert", "nodes", ".", "n_nodes", "==", "3", "\n", "assert", "nodes", ".", "n_nodes_capacity", "==", "5", "\n", "\n", "add_node_regressor", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_regressor", "(", "nodes", ",", "0", ",", "3.14", ")", "\n", "add_node_regressor", "(", "nodes", ",", "13", ",", "2.78", ")", "\n", "assert", "nodes", ".", "n_nodes", "==", "6", "\n", "assert", "nodes", ".", "n_nodes_capacity", "==", "10", "\n", "assert", "nodes", ".", "parent", "[", "4", "]", "==", "0", "\n", "assert", "nodes", ".", "time", "[", "4", "]", "==", "approx", "(", "3.14", ",", "1e-7", ")", "\n", "\n", "copy_node_regressor", "(", "nodes", ",", "5", ",", "4", ")", "\n", "assert", "nodes", ".", "parent", "[", "4", "]", "==", "13", "\n", "assert", "nodes", ".", "time", "[", "4", "]", "==", "approx", "(", "2.78", ",", "1e-7", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_online_dummy_classifier.TestOnlineDummyClassifier.test_n_classes": [[11, 23], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["    ", "def", "test_n_classes", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "OnlineDummyClassifier", ",", "\n", "parameter", "=", "\"n_classes\"", ",", "\n", "valid_val", "=", "3", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "1", ",", "\n", "min_value", "=", "2", ",", "\n", "min_value_str", "=", "\"2\"", ",", "\n", "mandatory", "=", "True", ",", "\n", "fixed_type", "=", "int", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_online_dummy_classifier.TestOnlineDummyClassifier.test_dirichlet": [[25, 37], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_dirichlet", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "OnlineDummyClassifier", ",", "\n", "parameter", "=", "\"dirichlet\"", ",", "\n", "valid_val", "=", "0.1", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "invalid_val", "=", "0.0", ",", "\n", "min_value_strict", "=", "0.0", ",", "\n", "min_value_str", "=", "\"0\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "float", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_online_dummy_classifier.TestOnlineDummyClassifier.test_repr": [[39, 42], ["onelearn.OnlineDummyClassifier", "repr"], "methods", ["None"], ["", "def", "test_repr", "(", "self", ")", ":", "\n", "        ", "dummy", "=", "OnlineDummyClassifier", "(", "n_classes", "=", "3", ")", "\n", "assert", "repr", "(", "dummy", ")", "==", "\"OnlineDummyClassifier(n_classes=3, dirichlet=0.01)\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_online_dummy_classifier.TestOnlineDummyClassifier.test_partial_fit": [[43, 66], ["onelearn.OnlineDummyClassifier", "numpy.random.randn", "numpy.array", "onelearn.OnlineDummyClassifier.partial_fit", "pytest.raises", "onelearn.OnlineDummyClassifier", "numpy.random.randn", "numpy.array", "onelearn.OnlineDummyClassifier.partial_fit", "pytest.raises", "onelearn.OnlineDummyClassifier", "numpy.random.randn", "numpy.array", "onelearn.OnlineDummyClassifier.partial_fit"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["", "def", "test_partial_fit", "(", "self", ")", ":", "\n", "        ", "clf", "=", "OnlineDummyClassifier", "(", "n_classes", "=", "2", ")", "\n", "n_features", "=", "4", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "n_features", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "assert", "clf", ".", "iteration", "==", "2", "\n", "\n", "with", "pytest", ".", "raises", "(", "\n", "ValueError", ",", "match", "=", "\"All the values in `y` must be non-negative\"", ",", "\n", ")", ":", "\n", "            ", "clf", "=", "OnlineDummyClassifier", "(", "n_classes", "=", "2", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "n_features", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "-", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "exc_info", ":", "\n", "            ", "clf", "=", "OnlineDummyClassifier", "(", "n_classes", "=", "2", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "2.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "", "assert", "exc_info", ".", "type", "is", "ValueError", "\n", "assert", "exc_info", ".", "value", ".", "args", "[", "0", "]", "==", "\"n_classes=2 while y.max()=2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_online_dummy_classifier.TestOnlineDummyClassifier.test_predict_proba": [[67, 75], ["onelearn.OnlineDummyClassifier", "pytest.raises", "numpy.random.randn", "onelearn.OnlineDummyClassifier.predict_proba"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "def", "test_predict_proba", "(", "self", ")", ":", "\n", "        ", "clf", "=", "OnlineDummyClassifier", "(", "n_classes", "=", "2", ")", "\n", "with", "pytest", ".", "raises", "(", "\n", "RuntimeError", ",", "\n", "match", "=", "\"You must call `partial_fit` before calling `predict_proba`\"", ",", "\n", ")", ":", "\n", "            ", "X_test", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_n_classes": [[52, 64], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["    ", "def", "test_n_classes", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"n_classes\"", ",", "\n", "valid_val", "=", "3", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "1", ",", "\n", "min_value", "=", "2", ",", "\n", "min_value_str", "=", "\"2\"", ",", "\n", "mandatory", "=", "True", ",", "\n", "fixed_type", "=", "int", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_n_features": [[66, 74], ["onelearn.AMFClassifier", "numpy.random.randn", "numpy.array", "onelearn.AMFClassifier.partial_fit", "pytest.raises"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["", "def", "test_n_features", "(", "self", ")", ":", "\n", "        ", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "2", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "assert", "clf", ".", "n_features", "==", "2", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ",", "match", "=", "\"`n_features` is a readonly attribute\"", ")", ":", "\n", "            ", "clf", ".", "n_features", "=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_n_estimators": [[75, 87], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "", "def", "test_n_estimators", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"n_estimators\"", ",", "\n", "valid_val", "=", "3", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "0", ",", "\n", "min_value", "=", "1", ",", "\n", "min_value_str", "=", "\"1\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_step": [[89, 101], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_step", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"step\"", ",", "\n", "valid_val", "=", "2.0", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "invalid_val", "=", "0.0", ",", "\n", "min_value_strict", "=", "0.0", ",", "\n", "min_value_str", "=", "\"0\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "float", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_loss": [[103, 108], ["onelearn.AMFClassifier"], "methods", ["None"], ["", "def", "test_loss", "(", "self", ")", ":", "\n", "        ", "amf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "assert", "amf", ".", "loss", "==", "\"log\"", "\n", "amf", ".", "loss", "=", "\"other loss\"", "\n", "assert", "amf", ".", "loss", "==", "\"log\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_use_aggregation": [[109, 117], ["parameter_test_with_type"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type"], ["", "def", "test_use_aggregation", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_type", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"step\"", ",", "\n", "valid_val", "=", "False", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "bool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_dirichlet": [[119, 131], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_dirichlet", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"dirichlet\"", ",", "\n", "valid_val", "=", "0.1", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "invalid_val", "=", "0.0", ",", "\n", "min_value_strict", "=", "0.0", ",", "\n", "min_value_str", "=", "\"0\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "float", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_split_pure": [[133, 141], ["parameter_test_with_type"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type"], ["", "def", "test_split_pure", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_type", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"split_pure\"", ",", "\n", "valid_val", "=", "False", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "bool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_random_state": [[143, 162], ["parameter_test_with_min", "onelearn.AMFClassifier"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_random_state", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"random_state\"", ",", "\n", "valid_val", "=", "4", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "-", "1", ",", "\n", "min_value", "=", "0", ",", "\n", "min_value_str", "=", "\"0\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n", "amf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "assert", "amf", ".", "random_state", "is", "None", "\n", "assert", "amf", ".", "_random_state", "==", "-", "1", "\n", "amf", ".", "random_state", "=", "1", "\n", "amf", ".", "random_state", "=", "None", "\n", "assert", "amf", ".", "_random_state", "==", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_n_jobs": [[163, 175], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_n_jobs", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"n_jobs\"", ",", "\n", "valid_val", "=", "4", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "0", ",", "\n", "min_value", "=", "1", ",", "\n", "min_value_str", "=", "\"1\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_n_samples_increment": [[177, 189], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_n_samples_increment", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"n_samples_increment\"", ",", "\n", "valid_val", "=", "128", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "0", ",", "\n", "min_value", "=", "1", ",", "\n", "min_value_str", "=", "\"1\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", "required_args", "=", "{", "\"n_classes\"", ":", "2", "}", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_verbose": [[191, 199], ["parameter_test_with_type"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type"], ["", "def", "test_verbose", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_type", "(", "\n", "AMFClassifier", ",", "\n", "parameter", "=", "\"verbose\"", ",", "\n", "valid_val", "=", "False", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "bool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_repr": [[201, 221], ["onelearn.AMFClassifier", "repr", "repr", "repr"], "methods", ["None"], ["", "def", "test_repr", "(", "self", ")", ":", "\n", "        ", "amf", "=", "AMFClassifier", "(", "n_classes", "=", "3", ")", "\n", "assert", "(", "\n", "repr", "(", "amf", ")", "==", "\"AMFClassifier(n_classes=3, n_estimators=10, \"", "\n", "\"step=1.0, loss='log', use_aggregation=True, \"", "\n", "\"dirichlet=0.01, split_pure=False, n_jobs=1, \"", "\n", "\"random_state=None, verbose=False)\"", "\n", ")", "\n", "\n", "amf", ".", "n_estimators", "=", "42", "\n", "assert", "(", "\n", "repr", "(", "amf", ")", "==", "\"AMFClassifier(n_classes=3, n_estimators=42, \"", "\n", "\"step=1.0, loss='log', use_aggregation=True, \"", "\n", "\"dirichlet=0.01, split_pure=False, n_jobs=1, \"", "\n", "\"random_state=None, verbose=False)\"", "\n", ")", "\n", "\n", "amf", ".", "verbose", "=", "False", "\n", "assert", "(", "\n", "repr", "(", "amf", ")", "==", "\"AMFClassifier(n_classes=3, n_estimators=42, \"", "\n", "\"step=1.0, loss='log', use_aggregation=True, \"", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_partial_fit": [[226, 262], ["onelearn.AMFClassifier", "numpy.random.randn", "numpy.array", "onelearn.AMFClassifier.partial_fit", "pytest.raises", "numpy.random.randn", "numpy.array", "onelearn.AMFClassifier.partial_fit", "pytest.raises", "onelearn.AMFClassifier", "numpy.random.randn", "numpy.array", "onelearn.AMFClassifier.partial_fit", "pytest.raises", "onelearn.AMFClassifier", "numpy.random.randn", "numpy.array", "onelearn.AMFClassifier.partial_fit"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["", "def", "test_partial_fit", "(", "self", ")", ":", "\n", "        ", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "n_features", "=", "4", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "n_features", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "assert", "clf", ".", "n_features", "==", "n_features", "\n", "assert", "clf", ".", "no_python", ".", "iteration", "==", "2", "\n", "assert", "clf", ".", "no_python", ".", "samples", ".", "n_samples", "==", "2", "\n", "assert", "clf", ".", "no_python", ".", "n_features", "==", "n_features", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "exc_info", ":", "\n", "            ", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "", "assert", "exc_info", ".", "type", "is", "ValueError", "\n", "assert", "(", "\n", "exc_info", ".", "value", ".", "args", "[", "0", "]", "==", "\"`partial_fit` was first called with \"", "\n", "\"n_features=4 while n_features=3 in this call\"", "\n", ")", "\n", "\n", "with", "pytest", ".", "raises", "(", "\n", "ValueError", ",", "match", "=", "\"All the values in `y` must be non-negative\"", ",", "\n", ")", ":", "\n", "            ", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "n_features", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "-", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "exc_info", ":", "\n", "            ", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "2.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "", "assert", "exc_info", ".", "type", "is", "ValueError", "\n", "assert", "exc_info", ".", "value", ".", "args", "[", "0", "]", "==", "\"n_classes=2 while y.max()=2\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_predict_proba": [[263, 284], ["onelearn.AMFClassifier", "pytest.raises", "numpy.random.randn", "onelearn.AMFClassifier.predict_proba", "pytest.raises", "numpy.random.randn", "numpy.array", "onelearn.AMFClassifier.partial_fit", "numpy.random.randn", "onelearn.AMFClassifier.predict_proba"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "def", "test_predict_proba", "(", "self", ")", ":", "\n", "        ", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ")", "\n", "with", "pytest", ".", "raises", "(", "\n", "RuntimeError", ",", "\n", "match", "=", "\"You must call `partial_fit` before asking for predictions\"", ",", "\n", ")", ":", "\n", "            ", "X_test", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "exc_info", ":", "\n", "            ", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "2", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "X_test", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "", "assert", "exc_info", ".", "type", "is", "ValueError", "\n", "assert", "exc_info", ".", "value", ".", "args", "[", "\n", "0", "\n", "]", "==", "\"`partial_fit` was called with n_features=%d while predictions are asked with n_features=%d\"", "%", "(", "\n", "clf", ".", "n_features", ",", "\n", "3", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_performance_on_moons": [[286, 299], ["sklearn.datasets.make_moons", "sklearn.model_selection.train_test_split", "onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.predict_proba", "sklearn.metrics.roc_auc_score"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba"], ["", "def", "test_performance_on_moons", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "300", "\n", "random_state", "=", "42", "\n", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.25", ",", "random_state", "=", "random_state", ")", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ",", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "score", "=", "roc_auc_score", "(", "y_test", ",", "y_pred", "[", ":", ",", "1", "]", ")", "\n", "# With this random_state, the score should be exactly 0.9709821428571429", "\n", "assert", "score", ">", "0.97", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_predict_proba_tree_match_predict_proba": [[300, 319], ["sklearn.datasets.make_moons", "sklearn.model_selection.train_test_split", "onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.predict_proba", "numpy.empty", "range", "onelearn.AMFClassifier.predict_proba_tree", "approx", "numpy.empty.mean"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFClassifier.predict_proba_tree", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx"], ["", "def", "test_predict_proba_tree_match_predict_proba", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "300", "\n", "n_classes", "=", "2", "\n", "n_estimators", "=", "10", "\n", "random_state", "=", "42", "\n", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.25", ",", "random_state", "=", "random_state", ")", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf", "=", "AMFClassifier", "(", "\n", "n_classes", "=", "2", ",", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "y_pred_tree", "=", "np", ".", "empty", "(", "(", "y_pred", ".", "shape", "[", "0", "]", ",", "n_classes", ",", "n_estimators", ")", ")", "\n", "for", "idx_tree", "in", "range", "(", "n_estimators", ")", ":", "\n", "            ", "y_pred_tree", "[", ":", ",", ":", ",", "idx_tree", "]", "=", "clf", ".", "predict_proba_tree", "(", "X_test", ",", "idx_tree", ")", "\n", "\n", "", "assert", "y_pred", "==", "approx", "(", "y_pred_tree", ".", "mean", "(", "axis", "=", "2", ")", ",", "1e-6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_classifier.TestAMFClassifier.test_random_state_is_consistant": [[320, 337], ["sklearn.datasets.make_moons", "sklearn.model_selection.train_test_split", "onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.predict_proba", "onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.predict_proba", "approx"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict_proba", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx"], ["", "def", "test_random_state_is_consistant", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "300", "\n", "random_state", "=", "42", "\n", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.25", ",", "random_state", "=", "random_state", ")", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "\n", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ",", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred_1", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "\n", "clf", "=", "AMFClassifier", "(", "n_classes", "=", "2", ",", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred_2", "=", "clf", ".", "predict_proba", "(", "X_test", ")", "\n", "\n", "assert", "y_pred_1", "==", "approx", "(", "y_pred_2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_n_features": [[17, 25], ["onelearn.AMFRegressor", "numpy.random.randn", "numpy.array", "onelearn.AMFRegressor.partial_fit", "pytest.raises"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["    ", "def", "test_n_features", "(", "self", ")", ":", "\n", "        ", "clf", "=", "AMFRegressor", "(", ")", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "2", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "assert", "clf", ".", "n_features", "==", "2", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ",", "match", "=", "\"`n_features` is a readonly attribute\"", ")", ":", "\n", "            ", "clf", ".", "n_features", "=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_n_estimators": [[26, 37], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "", "def", "test_n_estimators", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"n_estimators\"", ",", "\n", "valid_val", "=", "3", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "0", ",", "\n", "min_value", "=", "1", ",", "\n", "min_value_str", "=", "\"1\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_step": [[39, 50], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_step", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"step\"", ",", "\n", "valid_val", "=", "2.0", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "invalid_val", "=", "0.0", ",", "\n", "min_value_strict", "=", "0.0", ",", "\n", "min_value_str", "=", "\"0\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "float", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_loss": [[52, 57], ["onelearn.AMFRegressor"], "methods", ["None"], ["", "def", "test_loss", "(", "self", ")", ":", "\n", "        ", "amf", "=", "AMFRegressor", "(", ")", "\n", "assert", "amf", ".", "loss", "==", "\"least-squares\"", "\n", "amf", ".", "loss", "=", "\"other loss\"", "\n", "assert", "amf", ".", "loss", "==", "\"least-squares\"", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_use_aggregation": [[58, 66], ["parameter_test_with_type"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type"], ["", "def", "test_use_aggregation", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_type", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"step\"", ",", "\n", "valid_val", "=", "False", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "bool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_split_pure": [[68, 76], ["parameter_test_with_type"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type"], ["", "def", "test_split_pure", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_type", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"split_pure\"", ",", "\n", "valid_val", "=", "False", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "bool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_random_state": [[78, 96], ["parameter_test_with_min", "onelearn.AMFRegressor"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_random_state", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"random_state\"", ",", "\n", "valid_val", "=", "4", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "-", "1", ",", "\n", "min_value", "=", "0", ",", "\n", "min_value_str", "=", "\"0\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", ")", "\n", "amf", "=", "AMFRegressor", "(", ")", "\n", "assert", "amf", ".", "random_state", "is", "None", "\n", "assert", "amf", ".", "_random_state", "==", "-", "1", "\n", "amf", ".", "random_state", "=", "1", "\n", "amf", ".", "random_state", "=", "None", "\n", "assert", "amf", ".", "_random_state", "==", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_n_jobs": [[97, 108], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_n_jobs", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"n_jobs\"", ",", "\n", "valid_val", "=", "4", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "0", ",", "\n", "min_value", "=", "1", ",", "\n", "min_value_str", "=", "\"1\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_n_samples_increment": [[110, 121], ["parameter_test_with_min"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min"], ["", "def", "test_n_samples_increment", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_min", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"n_samples_increment\"", ",", "\n", "valid_val", "=", "128", ",", "\n", "invalid_type_val", "=", "2.0", ",", "\n", "invalid_val", "=", "0", ",", "\n", "min_value", "=", "1", ",", "\n", "min_value_str", "=", "\"1\"", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "int", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_verbose": [[123, 131], ["parameter_test_with_type"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type"], ["", "def", "test_verbose", "(", "self", ")", ":", "\n", "        ", "parameter_test_with_type", "(", "\n", "AMFRegressor", ",", "\n", "parameter", "=", "\"verbose\"", ",", "\n", "valid_val", "=", "False", ",", "\n", "invalid_type_val", "=", "0", ",", "\n", "mandatory", "=", "False", ",", "\n", "fixed_type", "=", "bool", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_repr": [[133, 151], ["onelearn.AMFRegressor", "repr", "repr", "repr"], "methods", ["None"], ["", "def", "test_repr", "(", "self", ")", ":", "\n", "        ", "amf", "=", "AMFRegressor", "(", ")", "\n", "assert", "(", "\n", "repr", "(", "amf", ")", "==", "\"AMFRegressor(n_estimators=10, step=1.0, \"", "\n", "\"loss='least-squares', use_aggregation=True, split_pure=False, n_jobs=1, \"", "\n", "\"random_state=None, verbose=False)\"", "\n", ")", "\n", "\n", "amf", ".", "n_estimators", "=", "42", "\n", "assert", "(", "\n", "repr", "(", "amf", ")", "==", "\"AMFRegressor(n_estimators=42, step=1.0, \"", "\n", "\"loss='least-squares', use_aggregation=True, \"", "\n", "\"split_pure=False, n_jobs=1, random_state=None, verbose=False)\"", "\n", ")", "\n", "\n", "amf", ".", "verbose", "=", "False", "\n", "assert", "(", "\n", "repr", "(", "amf", ")", "==", "\"AMFRegressor(n_estimators=42, \"", "\n", "\"step=1.0, loss='least-squares', use_aggregation=True, \"", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_partial_fit": [[155, 173], ["onelearn.AMFRegressor", "numpy.random.randn", "numpy.array", "onelearn.AMFRegressor.partial_fit", "pytest.raises", "numpy.random.randn", "numpy.array", "onelearn.AMFRegressor.partial_fit"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["", "def", "test_partial_fit", "(", "self", ")", ":", "\n", "        ", "clf", "=", "AMFRegressor", "(", ")", "\n", "n_features", "=", "4", "\n", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "n_features", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "assert", "clf", ".", "n_features", "==", "n_features", "\n", "assert", "clf", ".", "no_python", ".", "iteration", "==", "2", "\n", "assert", "clf", ".", "no_python", ".", "samples", ".", "n_samples", "==", "2", "\n", "assert", "clf", ".", "no_python", ".", "n_features", "==", "n_features", "\n", "\n", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "exc_info", ":", "\n", "            ", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "", "assert", "exc_info", ".", "type", "is", "ValueError", "\n", "assert", "(", "\n", "exc_info", ".", "value", ".", "args", "[", "0", "]", "==", "\"`partial_fit` was first called with \"", "\n", "\"n_features=4 while n_features=3 in this call\"", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_predict": [[176, 197], ["onelearn.AMFRegressor", "pytest.raises", "numpy.random.randn", "onelearn.AMFRegressor.predict", "pytest.raises", "numpy.random.randn", "numpy.array", "onelearn.AMFRegressor.partial_fit", "numpy.random.randn", "onelearn.AMFRegressor.predict"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict"], ["", "def", "test_predict", "(", "self", ")", ":", "\n", "        ", "clf", "=", "AMFRegressor", "(", ")", "\n", "with", "pytest", ".", "raises", "(", "\n", "RuntimeError", ",", "\n", "match", "=", "\"You must call `partial_fit` before asking for predictions\"", ",", "\n", ")", ":", "\n", "            ", "X_test", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "clf", ".", "predict", "(", "X_test", ")", "\n", "\n", "", "with", "pytest", ".", "raises", "(", "ValueError", ")", "as", "exc_info", ":", "\n", "            ", "X", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "2", ")", "\n", "y", "=", "np", ".", "array", "(", "[", "0.0", ",", "1.0", "]", ")", "\n", "clf", ".", "partial_fit", "(", "X", ",", "y", ")", "\n", "X_test", "=", "np", ".", "random", ".", "randn", "(", "2", ",", "3", ")", "\n", "clf", ".", "predict", "(", "X_test", ")", "\n", "", "assert", "exc_info", ".", "type", "is", "ValueError", "\n", "assert", "exc_info", ".", "value", ".", "args", "[", "\n", "0", "\n", "]", "==", "\"`partial_fit` was called with n_features=%d while predictions are asked with n_features=%d\"", "%", "(", "\n", "clf", ".", "n_features", ",", "\n", "3", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_performance_on_blocks": [[199, 214], ["onelearn.datasets.make_regression", "sklearn.model_selection.train_test_split", "onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "onelearn.AMFRegressor.predict", "numpy.abs().mean", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.make_regression", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict"], ["", "def", "test_performance_on_blocks", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "2000", "\n", "random_state", "=", "42", "\n", "X", ",", "y", "=", "make_regression", "(", "\n", "n_samples", "=", "n_samples", ",", "signal", "=", "\"blocks\"", ",", "random_state", "=", "random_state", "\n", ")", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf", "=", "AMFRegressor", "(", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred", "=", "clf", ".", "predict", "(", "X_test", ")", "\n", "err", "=", "np", ".", "abs", "(", "y_test", "-", "y_pred", ")", ".", "mean", "(", ")", "\n", "# With this random_state, err should be exactly 0.07848953956518727", "\n", "assert", "err", "<", "0.08", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_random_state_is_consistant": [[215, 232], ["sklearn.datasets.make_moons", "sklearn.model_selection.train_test_split", "onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "onelearn.AMFRegressor.predict", "onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "onelearn.AMFRegressor.predict", "approx"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.predict", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx"], ["", "def", "test_random_state_is_consistant", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "300", "\n", "random_state", "=", "42", "\n", "X", ",", "y", "=", "make_moons", "(", "n_samples", "=", "n_samples", ",", "noise", "=", "0.25", ",", "random_state", "=", "random_state", ")", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.5", ",", "random_state", "=", "random_state", "\n", ")", "\n", "\n", "clf", "=", "AMFRegressor", "(", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred_1", "=", "clf", ".", "predict", "(", "X_test", ")", "\n", "\n", "clf", "=", "AMFRegressor", "(", "random_state", "=", "random_state", ")", "\n", "clf", ".", "partial_fit", "(", "X_train", ",", "y_train", ")", "\n", "y_pred_2", "=", "clf", ".", "predict", "(", "X_test", ")", "\n", "\n", "assert", "y_pred_1", "==", "approx", "(", "y_pred_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_amf_regressor.TestAMFRegressor.test_weighted_depth": [[233, 302], ["onelearn.datasets.make_regression", "onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "numpy.array().reshape", "onelearn.AMFRegressor.weighted_depth().mean", "numpy.array", "X.reshape", "approx", "numpy.array", "onelearn.AMFRegressor.weighted_depth"], "methods", ["home.repos.pwc.inspect_result.onelearn_onelearn.datasets.regression.make_regression", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFRegressor.weighted_depth"], ["", "def", "test_weighted_depth", "(", "self", ")", ":", "\n", "        ", "n_samples", "=", "2000", "\n", "random_state", "=", "42", "\n", "noise", "=", "0.03", "\n", "use_aggregation", "=", "True", "\n", "split_pure", "=", "True", "\n", "n_estimators", "=", "100", "\n", "step", "=", "10.0", "\n", "\n", "X", ",", "y", "=", "make_regression", "(", "\n", "n_samples", "=", "n_samples", ",", "\n", "signal", "=", "\"blocks\"", ",", "\n", "noise", "=", "noise", ",", "\n", "random_state", "=", "random_state", ",", "\n", ")", "\n", "\n", "amf", "=", "AMFRegressor", "(", "\n", "random_state", "=", "random_state", ",", "\n", "use_aggregation", "=", "use_aggregation", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "split_pure", "=", "split_pure", ",", "\n", "step", "=", "step", ",", "\n", ")", "\n", "\n", "amf", ".", "partial_fit", "(", "X", ".", "reshape", "(", "n_samples", ",", "1", ")", ",", "y", ")", "\n", "X_test", "=", "np", ".", "array", "(", "\n", "[", "\n", "0.5", ",", "\n", "0.1", ",", "\n", "0.13", ",", "\n", "0.15", ",", "\n", "0.2", ",", "\n", "0.23", ",", "\n", "0.25", ",", "\n", "0.3", ",", "\n", "0.4", ",", "\n", "0.44", ",", "\n", "0.55", ",", "\n", "0.65", ",", "\n", "0.7", ",", "\n", "0.76", ",", "\n", "0.78", ",", "\n", "0.81", ",", "\n", "0.9", ",", "\n", "]", "\n", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "weighted_depth", "=", "amf", ".", "weighted_depth", "(", "X_test", ")", ".", "mean", "(", "axis", "=", "1", ")", "\n", "weighted_depth_expected", "=", "np", ".", "array", "(", "\n", "[", "\n", "6.8916187", ",", "\n", "11.966855", ",", "\n", "12.637342", ",", "\n", "10.947144", ",", "\n", "7.8675694", ",", "\n", "12.680364", ",", "\n", "12.640211", ",", "\n", "7.3447876", ",", "\n", "12.585537", ",", "\n", "10.4313545", ",", "\n", "6.458374", ",", "\n", "13.874192", ",", "\n", "7.446446", ",", "\n", "11.255474", ",", "\n", "10.093488", ",", "\n", "12.541043", ",", "\n", "4.807294", ",", "\n", "]", "\n", ")", "\n", "assert", "weighted_depth", "==", "approx", "(", "weighted_depth_expected", ",", "1e-5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_serialization.test_amf_classifier_serialization": [[14, 104], ["sklearn.datasets.load_iris", "sklearn.model_selection.train_test_split", "sklearn.model_selection.train_test_split", "onelearn.AMFClassifier", "onelearn.AMFClassifier.partial_fit", "onelearn.AMFClassifier.save", "onelearn.AMFClassifier.load", "os.remove", "test_serialization.test_amf_classifier_serialization.test_forests_are_equal"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.save", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.load"], ["def", "test_amf_classifier_serialization", "(", ")", ":", "\n", "    ", "\"\"\"Trains a AMFClassifier on iris, saves and loads it again. Check that\n    everything is the same between the original and loaded forest\n    \"\"\"", "\n", "random_state", "=", "42", "\n", "n_estimators", "=", "1", "\n", "n_classes", "=", "3", "\n", "\n", "iris", "=", "datasets", ".", "load_iris", "(", ")", "\n", "X", "=", "iris", ".", "data", "\n", "y", "=", "iris", ".", "target", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.2", ",", "random_state", "=", "random_state", "\n", ")", "\n", "X_train_1", ",", "X_train_2", ",", "y_train_1", ",", "y_train_2", "=", "train_test_split", "(", "\n", "X_train", ",", "y_train", ",", "test_size", "=", "0.2", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf1", "=", "AMFClassifier", "(", "\n", "n_estimators", "=", "n_estimators", ",", "n_classes", "=", "n_classes", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf1", ".", "partial_fit", "(", "X_train_1", ",", "y_train_1", ")", "\n", "\n", "filename", "=", "\"amf_on_iris.pkl\"", "\n", "clf1", ".", "save", "(", "filename", ")", "\n", "clf2", "=", "AMFClassifier", ".", "load", "(", "filename", ")", "\n", "os", ".", "remove", "(", "filename", ")", "\n", "\n", "def", "test_forests_are_equal", "(", "clf1", ",", "clf2", ")", ":", "\n", "# Test samples", "\n", "        ", "samples1", "=", "clf1", ".", "no_python", ".", "samples", "\n", "samples2", "=", "clf2", ".", "no_python", ".", "samples", "\n", "assert", "samples1", ".", "n_samples_increment", "==", "samples2", ".", "n_samples_increment", "\n", "n_samples1", "=", "samples1", ".", "n_samples", "\n", "n_samples2", "=", "samples2", ".", "n_samples", "\n", "assert", "n_samples1", "==", "n_samples2", "\n", "assert", "samples1", ".", "n_samples_capacity", "==", "samples2", ".", "n_samples_capacity", "\n", "assert", "np", ".", "all", "(", "samples1", ".", "labels", "[", ":", "n_samples1", "]", "==", "samples2", ".", "labels", "[", ":", "n_samples2", "]", ")", "\n", "assert", "np", ".", "all", "(", "samples1", ".", "features", "[", ":", "n_samples1", "]", "==", "samples2", ".", "features", "[", ":", "n_samples2", "]", ")", "\n", "\n", "# Test nopython.trees", "\n", "for", "n_estimator", "in", "range", "(", "n_estimators", ")", ":", "\n", "            ", "tree1", "=", "clf1", ".", "no_python", ".", "trees", "[", "n_estimator", "]", "\n", "tree2", "=", "clf2", ".", "no_python", ".", "trees", "[", "n_estimator", "]", "\n", "# Test tree attributes", "\n", "assert", "tree1", ".", "n_features", "==", "tree2", ".", "n_features", "\n", "assert", "tree1", ".", "step", "==", "tree2", ".", "step", "\n", "assert", "tree1", ".", "loss", "==", "tree2", ".", "loss", "\n", "assert", "tree1", ".", "use_aggregation", "==", "tree2", ".", "use_aggregation", "\n", "assert", "tree1", ".", "iteration", "==", "tree2", ".", "iteration", "\n", "assert", "tree1", ".", "n_classes", "==", "tree2", ".", "n_classes", "\n", "assert", "tree1", ".", "dirichlet", "==", "tree2", ".", "dirichlet", "\n", "assert", "np", ".", "all", "(", "tree1", ".", "intensities", "==", "tree2", ".", "intensities", ")", "\n", "# Test tree.nodes", "\n", "nodes1", "=", "tree1", ".", "nodes", "\n", "nodes2", "=", "tree2", ".", "nodes", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "index", "==", "nodes2", ".", "index", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "is_leaf", "==", "nodes2", ".", "is_leaf", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "depth", "==", "nodes2", ".", "depth", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "n_samples", "==", "nodes2", ".", "n_samples", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "parent", "==", "nodes2", ".", "parent", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "left", "==", "nodes2", ".", "left", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "right", "==", "nodes2", ".", "right", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "feature", "==", "nodes2", ".", "feature", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "weight", "==", "nodes2", ".", "weight", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "log_weight_tree", "==", "nodes2", ".", "log_weight_tree", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "threshold", "==", "nodes2", ".", "threshold", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "time", "==", "nodes2", ".", "time", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "memory_range_min", "==", "nodes2", ".", "memory_range_min", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "memory_range_max", "==", "nodes2", ".", "memory_range_max", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "n_features", "==", "nodes2", ".", "n_features", ")", "\n", "assert", "nodes1", ".", "n_nodes", "==", "nodes2", ".", "n_nodes", "\n", "assert", "nodes1", ".", "n_samples_increment", "==", "nodes2", ".", "n_samples_increment", "\n", "assert", "nodes1", ".", "n_nodes_capacity", "==", "nodes2", ".", "n_nodes_capacity", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "counts", "==", "nodes2", ".", "counts", ")", "\n", "assert", "nodes1", ".", "n_classes", "==", "nodes2", ".", "n_classes", "\n", "\n", "", "", "test_forests_are_equal", "(", "clf1", ",", "clf2", ")", "\n", "\n", "# Test predict proba", "\n", "y_pred", "=", "clf1", ".", "predict_proba", "(", "X_test", ")", "\n", "y_pred_pkl", "=", "clf2", ".", "predict_proba", "(", "X_test", ")", "\n", "assert", "np", ".", "all", "(", "y_pred", "==", "y_pred_pkl", ")", "\n", "\n", "clf1", ".", "partial_fit", "(", "X_train_2", ",", "y_train_2", ")", "\n", "clf2", ".", "partial_fit", "(", "X_train_2", ",", "y_train_2", ")", "\n", "test_forests_are_equal", "(", "clf1", ",", "clf2", ")", "\n", "\n", "y_pred", "=", "clf1", ".", "predict_proba", "(", "X_test", ")", "\n", "y_pred_pkl", "=", "clf2", ".", "predict_proba", "(", "X_test", ")", "\n", "assert", "np", ".", "all", "(", "y_pred", "==", "y_pred_pkl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.test_serialization.test_amf_regressor_serialization": [[106, 189], ["sklearn.datasets.load_diabetes", "sklearn.model_selection.train_test_split", "sklearn.model_selection.train_test_split", "onelearn.AMFRegressor", "onelearn.AMFRegressor.partial_fit", "onelearn.AMFRegressor.save", "onelearn.AMFRegressor.load", "os.remove", "test_serialization.test_amf_classifier_serialization.test_forests_are_equal"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.save", "home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.forest.AMFLearner.load"], ["", "def", "test_amf_regressor_serialization", "(", ")", ":", "\n", "    ", "\"\"\"Trains a AMFRegressor on diabetes, saves and loads it again. Check that\n    everything is the same between the original and loaded forest\n    \"\"\"", "\n", "random_state", "=", "42", "\n", "n_estimators", "=", "1", "\n", "iris", "=", "datasets", ".", "load_diabetes", "(", ")", "\n", "X", "=", "iris", ".", "data", "\n", "y", "=", "iris", ".", "target", "\n", "X_train", ",", "X_test", ",", "y_train", ",", "y_test", "=", "train_test_split", "(", "\n", "X", ",", "y", ",", "test_size", "=", "0.2", ",", "random_state", "=", "random_state", "\n", ")", "\n", "X_train_1", ",", "X_train_2", ",", "y_train_1", ",", "y_train_2", "=", "train_test_split", "(", "\n", "X_train", ",", "y_train", ",", "test_size", "=", "0.2", ",", "random_state", "=", "random_state", "\n", ")", "\n", "clf1", "=", "AMFRegressor", "(", "n_estimators", "=", "n_estimators", ",", "random_state", "=", "random_state", ")", "\n", "clf1", ".", "partial_fit", "(", "X_train_1", ",", "y_train_1", ")", "\n", "\n", "filename", "=", "\"amf_on_diabetes.pkl\"", "\n", "clf1", ".", "save", "(", "filename", ")", "\n", "clf2", "=", "AMFRegressor", ".", "load", "(", "filename", ")", "\n", "os", ".", "remove", "(", "filename", ")", "\n", "\n", "def", "test_forests_are_equal", "(", "clf1", ",", "clf2", ")", ":", "\n", "# Test samples", "\n", "        ", "samples1", "=", "clf1", ".", "no_python", ".", "samples", "\n", "samples2", "=", "clf2", ".", "no_python", ".", "samples", "\n", "assert", "samples1", ".", "n_samples_increment", "==", "samples2", ".", "n_samples_increment", "\n", "n_samples1", "=", "samples1", ".", "n_samples", "\n", "n_samples2", "=", "samples2", ".", "n_samples", "\n", "assert", "n_samples1", "==", "n_samples2", "\n", "assert", "samples1", ".", "n_samples_capacity", "==", "samples2", ".", "n_samples_capacity", "\n", "assert", "np", ".", "all", "(", "samples1", ".", "labels", "[", ":", "n_samples1", "]", "==", "samples2", ".", "labels", "[", ":", "n_samples2", "]", ")", "\n", "assert", "np", ".", "all", "(", "samples1", ".", "features", "[", ":", "n_samples1", "]", "==", "samples2", ".", "features", "[", ":", "n_samples2", "]", ")", "\n", "\n", "# Test nopython.trees", "\n", "for", "n_estimator", "in", "range", "(", "n_estimators", ")", ":", "\n", "            ", "tree1", "=", "clf1", ".", "no_python", ".", "trees", "[", "n_estimator", "]", "\n", "tree2", "=", "clf2", ".", "no_python", ".", "trees", "[", "n_estimator", "]", "\n", "# Test tree attributes", "\n", "assert", "tree1", ".", "n_features", "==", "tree2", ".", "n_features", "\n", "assert", "tree1", ".", "step", "==", "tree2", ".", "step", "\n", "assert", "tree1", ".", "loss", "==", "tree2", ".", "loss", "\n", "assert", "tree1", ".", "use_aggregation", "==", "tree2", ".", "use_aggregation", "\n", "assert", "tree1", ".", "iteration", "==", "tree2", ".", "iteration", "\n", "assert", "np", ".", "all", "(", "tree1", ".", "intensities", "==", "tree2", ".", "intensities", ")", "\n", "# Test tree.nodes", "\n", "nodes1", "=", "tree1", ".", "nodes", "\n", "nodes2", "=", "tree2", ".", "nodes", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "index", "==", "nodes2", ".", "index", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "is_leaf", "==", "nodes2", ".", "is_leaf", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "depth", "==", "nodes2", ".", "depth", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "n_samples", "==", "nodes2", ".", "n_samples", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "parent", "==", "nodes2", ".", "parent", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "left", "==", "nodes2", ".", "left", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "right", "==", "nodes2", ".", "right", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "feature", "==", "nodes2", ".", "feature", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "weight", "==", "nodes2", ".", "weight", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "log_weight_tree", "==", "nodes2", ".", "log_weight_tree", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "threshold", "==", "nodes2", ".", "threshold", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "time", "==", "nodes2", ".", "time", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "memory_range_min", "==", "nodes2", ".", "memory_range_min", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "memory_range_max", "==", "nodes2", ".", "memory_range_max", ")", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "n_features", "==", "nodes2", ".", "n_features", ")", "\n", "assert", "nodes1", ".", "n_nodes", "==", "nodes2", ".", "n_nodes", "\n", "assert", "nodes1", ".", "n_samples_increment", "==", "nodes2", ".", "n_samples_increment", "\n", "assert", "nodes1", ".", "n_nodes_capacity", "==", "nodes2", ".", "n_nodes_capacity", "\n", "assert", "np", ".", "all", "(", "nodes1", ".", "mean", "==", "nodes2", ".", "mean", ")", "\n", "\n", "", "", "test_forests_are_equal", "(", "clf1", ",", "clf2", ")", "\n", "\n", "# Test predict", "\n", "y_pred", "=", "clf1", ".", "predict", "(", "X_test", ")", "\n", "y_pred_pkl", "=", "clf2", ".", "predict", "(", "X_test", ")", "\n", "assert", "np", ".", "all", "(", "y_pred", "==", "y_pred_pkl", ")", "\n", "\n", "clf1", ".", "partial_fit", "(", "X_train_2", ",", "y_train_2", ")", "\n", "clf2", ".", "partial_fit", "(", "X_train_2", ",", "y_train_2", ")", "\n", "test_forests_are_equal", "(", "clf1", ",", "clf2", ")", "\n", "\n", "y_pred", "=", "clf1", ".", "predict", "(", "X_test", ")", "\n", "y_pred_pkl", "=", "clf2", ".", "predict", "(", "X_test", ")", "\n", "assert", "np", ".", "all", "(", "y_pred", "==", "y_pred_pkl", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx": [[8, 10], ["pytest.approx"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.approx"], ["from", "numba", ".", "types", "import", "float32", ",", "uint32", "\n", "\n", "\n"]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_min": [[12, 124], ["class_tested", "setattr", "getattr", "class_tested", "numpy.random.randn", "numpy.array", "class_tested.partial_fit", "ValueError", "getattr", "pytest.raises", "setattr", "pytest.raises", "class_tested", "pytest.raises", "setattr", "pytest.raises", "class_tested", "utils.parameter_test_with_min.get_params"], "function", ["home.repos.pwc.inspect_result.onelearn_onelearn.onelearn.dummy.OnlineDummyClassifier.partial_fit"], ["    ", "\"\"\"Gives the numba type of an object is numba.jit decorators are enabled and None\n    otherwise. This helps to get correct coverage of the code\n\n    Parameters\n    ----------\n    class_ : `object`\n        A class\n\n    Returns\n    -------\n    output : `object`\n        A numba type of None\n    \"\"\"", "\n", "class_type", "=", "getattr", "(", "class_", ",", "\"class_type\"", ",", "None", ")", "\n", "if", "class_type", "is", "None", ":", "\n", "        ", "return", "class_type", "\n", "", "else", ":", "\n", "        ", "return", "class_type", ".", "instance_type", "\n", "\n", "\n", "", "", "@", "njit", "\n", "def", "resize_array", "(", "arr", ",", "keep", ",", "size", ",", "fill", "=", "0", ")", ":", "\n", "    ", "\"\"\"Resize the given array along the first axis only, preserving the same\n    dtype and second axis size (if it's two-dimensional)\n\n    Parameters\n    ----------\n    arr : `np.array`\n        Input array\n\n    keep : `int`\n        Keep the first `keep` elements (according to the first axis)\n\n    size : `int`\n        Target size of the first axis of new array (\n\n    fill : {`None`, 0, 1}, default=0\n        Controls the values in the resized array before putting back the first elements\n        * If None, the array is not filled\n        * If 1 the array is filled with ones\n        * If 0 the array is filled with zeros\n\n    Returns\n    -------\n    output : `np.array`\n        New array of shape (size,) or (size, arr.shape[1]) with `keep` first\n        elements preserved (along first axis)\n    \"\"\"", "\n", "if", "arr", ".", "ndim", "==", "1", ":", "\n", "        ", "if", "fill", "is", "None", ":", "\n", "            ", "new", "=", "np", ".", "empty", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "elif", "fill", "==", "1", ":", "\n", "            ", "new", "=", "np", ".", "ones", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "new", "=", "np", ".", "zeros", "(", "(", "size", ",", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "new", "[", ":", "keep", "]", "=", "arr", "[", ":", "keep", "]", "\n", "return", "new", "\n", "", "elif", "arr", ".", "ndim", "==", "2", ":", "\n", "        ", "_", ",", "n_cols", "=", "arr", ".", "shape", "\n", "if", "fill", "is", "None", ":", "\n", "            ", "new", "=", "np", ".", "empty", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "elif", "fill", "==", "1", ":", "\n", "            ", "new", "=", "np", ".", "ones", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "else", ":", "\n", "            ", "new", "=", "np", ".", "zeros", "(", "(", "size", ",", "n_cols", ")", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "", "new", "[", ":", "keep", "]", "=", "arr", "[", ":", "keep", "]", "\n", "return", "new", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"resize_array can resize only 1D and 2D arrays\"", ")", "\n", "\n", "\n", "# Sadly there is no function to sample for a discrete distribution in numba", "\n", "", "", "@", "njit", "(", "uint32", "(", "float32", "[", ":", ":", "1", "]", ")", ")", "\n", "def", "sample_discrete", "(", "distribution", ")", ":", "\n", "    ", "\"\"\"Samples according to the given discrete distribution.\n\n    Parameters\n    ----------\n    distribution : `np.array', shape=(size,), dtype='float32'\n        The discrete distribution we want to sample from. This must contain\n        non-negative entries that sum to one.\n\n    Returns\n    -------\n    output : `uint32`\n        Output sampled in {0, 1, 2, distribution.size} according to the given\n        distribution\n\n    Notes\n    -----\n    It is useless to np.cumsum and np.searchsorted here, since we want a single\n    sample for this distribution and since it changes at each call. So nothing\n    is better here than simple O(n).\n\n    Warning\n    -------\n    No test is performed here for efficiency: distribution must contain non-\n    negative values that sum to one.\n    \"\"\"", "\n", "# Notes", "\n", "U", "=", "uniform", "(", "0.0", ",", "1.0", ")", "\n", "cumsum", "=", "0.0", "\n", "size", "=", "distribution", ".", "size", "\n", "for", "j", "in", "range", "(", "size", ")", ":", "\n", "        ", "cumsum", "+=", "distribution", "[", "j", "]", "\n", "if", "U", "<=", "cumsum", ":", "\n", "            ", "return", "j", "\n", "", "", "return", "size", "-", "1", "\n", "\n", "\n", "", "@", "njit", "(", "float32", "(", "float32", ",", "float32", ")", ")", "\n", "def", "log_sum_2_exp", "(", "a", ",", "b", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.onelearn_onelearn.tests.utils.parameter_test_with_type": [[126, 131], ["None"], "function", ["None"], []]}