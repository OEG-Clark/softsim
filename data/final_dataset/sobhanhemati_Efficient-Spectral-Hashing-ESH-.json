{"home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.is_multilabel": [[8, 17], ["len"], "function", ["None"], ["def", "is_multilabel", "(", "y_train", ")", ":", "\n", "    ", "shape_", "=", "y_train", ".", "shape", "\n", "if", "(", "len", "(", "shape_", ")", "==", "1", ")", "or", "shape_", "[", "1", "]", "==", "1", ":", "\n", "        ", "return", "False", "\n", "\n", "#    y_train = y_train>0 ", "\n", "#    n_labels_per_sample = np.sum(y_train, axis=1)", "\n", "#    return np.any(n_labels_per_sample>1)", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.precision_recall": [[19, 103], ["numpy.sort", "numpy.zeros", "numpy.zeros", "numpy.max", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "numpy.mean", "numpy.mean", "numpy.array", "np.tile.flatten", "numpy.sum", "numpy.argsort", "collections.Counter", "numpy.cumsum", "len", "len", "len", "numpy.abs", "isinstance", "numpy.tile", "numpy.sum", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "precision_recall", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "M_set", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x, K) which \n        x is number of observations and K is the number of bits. \n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    M_set contains the (sorted) points in which precision and recall are \n        computed. In other words, if m be the member of M_set, precision@m and \n        recall@m are computed after retrieving m nearest neighbors to the query. \n    weights: have shape (K,)\n    \n    return: Precision and recall for each member of (sorted) M_set.\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "M_set", "=", "np", ".", "sort", "(", "np", ".", "array", "(", "M_set", ",", "dtype", "=", "np", ".", "uint", ")", ")", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "precision", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "recall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "M", "=", "np", ".", "max", "(", "M_set", ")", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "1", "\n", "normalization_term", "=", "K", "\n", "", "else", ":", "\n", "        ", "weights", "=", "weights", ".", "flatten", "(", ")", "\n", "assert", "(", "len", "(", "weights", ")", "==", "K", ")", "\n", "normalization_term", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "weights", ")", ")", "\n", "\n", "# big data flag", "\n", "", "big_flag", "=", "True", "\n", "if", "x_train", ".", "shape", "[", "0", "]", "*", "x_test", ".", "shape", "[", "0", "]", "<=", "0.5e9", ":", "\n", "        ", "big_flag", "=", "False", "\n", "if", "not", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "            ", "weights", "=", "np", ".", "tile", "(", "weights", "[", "None", "]", ",", "[", "n_test", ",", "1", "]", ")", "\n", "\n", "", "", "if", "big_flag", "==", "False", ":", "\n", "        ", "hamm_dist_mat", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "*", "weights", ")", ".", "T", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", ")", "*", "weights", ")", ".", "T", ")", "\n", "arg_dist_mat", "=", "np", ".", "argsort", "(", "hamm_dist_mat", ",", "axis", "=", "0", ")", "\n", "del", "hamm_dist_mat", "\n", "\n", "# compute precision and recall for each query", "\n", "", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "if", "is_multi_label", "==", "False", ":", "\n", "        ", "real_pos_per_class", "=", "Counter", "(", "y_train", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "\n", "        ", "if", "big_flag", "==", "False", ":", "\n", "# top (nearset) M neighbors to the query", "\n", "            ", "arg_dist", "=", "arg_dist_mat", "[", ":", "M", ",", "i", "]", "\n", "", "else", ":", "\n", "# hamming distance between train_data and the query", "\n", "            ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", "*", "weights", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", "*", "weights", ")", ")", "\n", "# top (nearset) M neighbors to the query", "\n", "arg_dist", "=", "np", ".", "argsort", "(", "hamm_dist", ")", "[", ":", "M", "]", "\n", "\n", "", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "            ", "is_correct", "=", "(", "y_train", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "total_Positives", "=", "np", ".", "sum", "(", "is_correct", ")", "# used for recall computation", "\n", "is_correct", "=", "is_correct", "[", "arg_dist", "]", "\n", "", "else", ":", "# multi-class case", "\n", "            ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct", "=", "(", "q_label", "==", "y_train", "[", "arg_dist", "]", ")", "\n", "total_Positives", "=", "real_pos_per_class", "[", "q_label", "]", "\n", "\n", "# compute precision and recall for each m", "\n", "", "is_correct_sum", "=", "np", ".", "cumsum", "(", "is_correct", ")", "\n", "TP", "=", "is_correct_sum", "[", "M_set", "-", "1", "]", "# true positives", "\n", "precision", "[", "i", ",", ":", "]", "=", "TP", "/", "M_set", "\n", "recall", "[", "i", ",", ":", "]", "=", "TP", "/", "total_Positives", "\n", "\n", "# compute average precision and recall", "\n", "", "precision", "=", "np", ".", "mean", "(", "precision", ",", "axis", "=", "0", ")", "\n", "recall", "=", "np", ".", "mean", "(", "recall", ",", "axis", "=", "0", ")", "\n", "\n", "return", "precision", ",", "recall", ",", "M_set", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.precision_radius": [[105, 160], ["numpy.zeros", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "numpy.mean", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "precision_radius", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "Radius", "=", "2", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x, K) which\n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    Radius is the radius of hamming ball for search.\n    \n    return: Precision @ Radius=Radius\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "precision", "=", "np", ".", "zeros", "(", "(", "n_test", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "\n", "normalization_term", "=", "K", "\n", "\n", "# compute precision and recall for each query", "\n", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "# hamming distance between train_data and the query", "\n", "        ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", ")", ")", "\n", "idx_radius", "=", "hamm_dist", "<=", "Radius", "\n", "m", "=", "np", ".", "sum", "(", "idx_radius", ")", "\n", "if", "m", "==", "0", ":", "\n", "            ", "precision", "[", "i", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "y_train_radius", "=", "y_train", "[", "idx_radius", "]", "\n", "\n", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "                ", "is_correct", "=", "(", "y_train_radius", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "\n", "", "else", ":", "# multi-class case", "\n", "                ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct", "=", "(", "q_label", "==", "y_train_radius", ")", "\n", "\n", "# compute precision for images in radius 2", "\n", "\n", "", "TP", "=", "np", ".", "sum", "(", "is_correct", ")", "# true positives", "\n", "precision", "[", "i", "]", "=", "TP", "/", "m", "\n", "\n", "\n", "# compute average precision and recall", "\n", "", "", "precision", "=", "np", ".", "mean", "(", "precision", ",", "axis", "=", "0", ")", "\n", "\n", "return", "precision", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.interpolated_precision_recall": [[162, 176], ["numpy.argsort", "numpy.zeros", "enumerate", "numpy.max", "len"], "function", ["None"], ["", "def", "interpolated_precision_recall", "(", "precisions", ",", "recalls", ")", ":", "\n", "    ", "\"\"\"\n    for ref see the link below:\n    # https://github.com/rafaelpadilla/Object-Detection-Metrics\n    \"\"\"", "\n", "idx", "=", "np", ".", "argsort", "(", "recalls", ")", "\n", "recalls", "=", "recalls", "[", "idx", "]", "\n", "precisions", "=", "precisions", "[", "idx", "]", "\n", "precisions_intp", "=", "np", ".", "zeros", "(", "(", "len", "(", "precisions", ")", ",", ")", ")", "\n", "for", "i", ",", "r", "in", "enumerate", "(", "recalls", ")", ":", "\n", "        ", "bool_index", "=", "recalls", ">=", "r", "\n", "precisions_intp", "[", "i", "]", "=", "np", ".", "max", "(", "precisions", "[", "bool_index", "]", ")", "\n", "\n", "", "return", "precisions_intp", ",", "recalls", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.AP": [[178, 252], ["numpy.zeros", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "np.tile.flatten", "numpy.sum", "numpy.argsort", "len", "len", "numpy.abs", "isinstance", "numpy.tile", "numpy.where", "numpy.argsort", "numpy.arange", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x,K) which\n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    weights: have shape (K,)\n    \n    return: average precision (AP) per query.\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "if", "num_return_NN", "is", "None", ":", "\n", "        ", "num_return_NN", "=", "x_train", ".", "shape", "[", "0", "]", "\n", "", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "APall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", ")", ")", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "1", "\n", "normalization_term", "=", "K", "\n", "", "else", ":", "\n", "        ", "weights", "=", "weights", ".", "flatten", "(", ")", "\n", "assert", "(", "len", "(", "weights", ")", "==", "K", ")", "\n", "normalization_term", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "weights", ")", ")", "\n", "\n", "# big data flag", "\n", "", "big_flag", "=", "True", "\n", "if", "x_train", ".", "shape", "[", "0", "]", "*", "x_test", ".", "shape", "[", "0", "]", "<=", "0.5e9", ":", "\n", "        ", "big_flag", "=", "False", "\n", "if", "not", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "            ", "weights", "=", "np", ".", "tile", "(", "weights", "[", "None", "]", ",", "[", "n_test", ",", "1", "]", ")", "\n", "\n", "", "", "if", "big_flag", "==", "False", ":", "\n", "        ", "hamm_dist_mat", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "*", "weights", ")", ".", "T", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", ")", "*", "weights", ")", ".", "T", ")", "\n", "arg_dist_mat", "=", "np", ".", "argsort", "(", "hamm_dist_mat", ",", "axis", "=", "0", ")", "\n", "del", "hamm_dist_mat", "\n", "\n", "# compute AP for each query", "\n", "", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "\n", "        ", "if", "big_flag", "==", "False", ":", "\n", "# top (nearset) neighbors to the query", "\n", "            ", "arg_dist", "=", "arg_dist_mat", "[", ":", "num_return_NN", ",", "i", "]", "\n", "", "else", ":", "\n", "# hamming distance between train_data and the query", "\n", "            ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", "*", "weights", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", "*", "weights", ")", ")", "\n", "# top (nearset) neighbors to the query", "\n", "arg_dist", "=", "np", ".", "argsort", "(", "hamm_dist", ")", "[", ":", "num_return_NN", "]", "\n", "\n", "", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "            ", "is_correct", "=", "(", "y_train", "[", "arg_dist", ",", ":", "]", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "", "else", ":", "# multi-class case", "\n", "            ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct", "=", "(", "q_label", "==", "y_train", "[", "arg_dist", "]", ")", "\n", "\n", "", "TP_loc", "=", "np", ".", "where", "(", "is_correct", ")", "[", "0", "]", "\n", "n_TP", "=", "len", "(", "TP_loc", ")", "# total number of true positives in num_return_NN", "\n", "if", "n_TP", "==", "0", ":", "\n", "            ", "APall", "[", "i", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "precisions", "=", "(", "np", ".", "arange", "(", "1", ",", "n_TP", "+", "1", ")", ")", "/", "(", "TP_loc", "+", "1", ")", "# calculate precisions ", "\n", "# only at the true positive locations", "\n", "APall", "[", "i", "]", "=", "np", ".", "sum", "(", "precisions", ")", "/", "n_TP", "\n", "\n", "", "", "return", "APall", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.mAP": [[254, 270], ["evaluate.AP", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.AP"], ["", "def", "mAP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x,K) which \n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    weights: have shape (K,)\n    \n    return: mean average precision (mAP).\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "ap_all", "=", "AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", "\n", "return", "np", ".", "mean", "(", "ap_all", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.return_all_metrics": [[272, 389], ["numpy.sort", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.max", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "print", "numpy.array", "weights.flatten.flatten", "numpy.sum", "collections.Counter", "numpy.argsort", "numpy.sum", "len", "numpy.cumsum", "len", "len", "len", "numpy.abs", "numpy.sum", "numpy.where", "numpy.sum", "numpy.arange", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "return_all_metrics", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "M_set", ",", "weights", "=", "None", ",", "\n", "num_return_NN", "=", "None", ",", "Radius", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This function is useful for large datasets as it computes hamming distance \n        between train data and query only once (instead of computing it for each\n        metric seperately).\n    \n    It returns:\n      1- Mean average precision (mAP) \n      2- Precision and recall for each member of (sorted) M_set\n      3- Precision @ Radius=Radius if radius is not None\n    \n    x_train and x_test are of boolean type and have shape (x,K) which\n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    M_set contains the (sorted) points in which precision and recall are \n        computed. In other words, if m be the member of M_set, precision@m and\n        recall@m are computed after retrieving m nearest neighbors to the query. \n    weights: have shape (K,)\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    Radius is the radius of hamming ball for search.\n\n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "if", "(", "weights", "is", "not", "None", ")", "and", "(", "Radius", "is", "not", "None", ")", ":", "\n", "        ", "print", "(", "'You cannot specify \"weights\" argument when you want to compute \\\n              the radious-based percision'", ")", "\n", "return", "None", "\n", "\n", "", "if", "num_return_NN", "is", "None", ":", "\n", "        ", "num_return_NN", "=", "x_train", ".", "shape", "[", "0", "]", "\n", "\n", "", "M_set", "=", "np", ".", "sort", "(", "np", ".", "array", "(", "M_set", ",", "dtype", "=", "np", ".", "uint", ")", ")", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "precision", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "recall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "APall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", ")", ")", "\n", "precision_R", "=", "np", ".", "zeros", "(", "(", "n_test", ")", ",", "dtype", "=", "'float32'", ")", "\n", "M", "=", "np", ".", "max", "(", "M_set", ")", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "1", "\n", "normalization_term", "=", "K", "\n", "", "else", ":", "\n", "        ", "weights", "=", "weights", ".", "flatten", "(", ")", "\n", "assert", "(", "len", "(", "weights", ")", "==", "K", ")", "\n", "normalization_term", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "weights", ")", ")", "\n", "\n", "# compute precision and recall for each query", "\n", "", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "if", "is_multi_label", "==", "False", ":", "\n", "        ", "real_pos_per_class", "=", "Counter", "(", "y_train", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "# hamming distance between train_data and the query", "\n", "        ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", "*", "weights", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", "*", "weights", ")", ")", "\n", "# top (nearset) M neighbors to the query", "\n", "arg_dist", "=", "np", ".", "argsort", "(", "hamm_dist", ")", "\n", "arg_dist_PR", "=", "arg_dist", "[", ":", "M", "]", "\n", "arg_dist_mAP", "=", "arg_dist", "[", ":", "num_return_NN", "]", "\n", "idx_radius", "=", "hamm_dist", "<=", "Radius", "\n", "m_radius", "=", "np", ".", "sum", "(", "idx_radius", ")", "\n", "y_train_radius", "=", "y_train", "[", "idx_radius", "]", "\n", "\n", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "            ", "is_correct", "=", "(", "y_train", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "total_Positives", "=", "np", ".", "sum", "(", "is_correct", ")", "# used for recall computation", "\n", "is_correct_PR", "=", "is_correct", "[", "arg_dist_PR", "]", "\n", "is_correct_mAP", "=", "is_correct", "[", "arg_dist_mAP", "]", "\n", "is_correct_radius", "=", "(", "y_train_radius", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "", "else", ":", "# multi-class case", "\n", "            ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct_PR", "=", "(", "q_label", "==", "y_train", "[", "arg_dist_PR", "]", ")", "\n", "is_correct_mAP", "=", "(", "q_label", "==", "y_train", "[", "arg_dist_mAP", "]", ")", "\n", "is_correct_radius", "=", "(", "q_label", "==", "y_train_radius", ")", "\n", "total_Positives", "=", "real_pos_per_class", "[", "q_label", "]", "\n", "\n", "# compute AP for each query", "\n", "", "TP_loc", "=", "np", ".", "where", "(", "is_correct_mAP", ")", "[", "0", "]", "\n", "n_TP", "=", "len", "(", "TP_loc", ")", "# total number of true positives in num_return_NN", "\n", "if", "n_TP", "!=", "0", ":", "\n", "# calculate precisions only at the true positive locations", "\n", "            ", "precisions", "=", "(", "np", ".", "arange", "(", "1", ",", "n_TP", "+", "1", ")", ")", "/", "(", "TP_loc", "+", "1", ")", "\n", "APall", "[", "i", "]", "=", "np", ".", "sum", "(", "precisions", ")", "/", "n_TP", "\n", "\n", "# compute precision and recall for each m", "\n", "", "is_correct_sum", "=", "np", ".", "cumsum", "(", "is_correct_PR", ")", "\n", "TP", "=", "is_correct_sum", "[", "M_set", "-", "1", "]", "# true positives", "\n", "precision", "[", "i", ",", ":", "]", "=", "TP", "/", "M_set", "\n", "recall", "[", "i", ",", ":", "]", "=", "TP", "/", "total_Positives", "\n", "\n", "# compute precision_radius", "\n", "if", "(", "m_radius", "!=", "0", ")", "and", "(", "Radius", "is", "not", "None", ")", ":", "\n", "# compute precision for images in radius of Radius", "\n", "            ", "TP", "=", "np", ".", "sum", "(", "is_correct_radius", ")", "# true positives", "\n", "precision_R", "[", "i", "]", "=", "TP", "/", "m_radius", "\n", "\n", "# compute average precision and recall", "\n", "", "", "precision", "=", "np", ".", "mean", "(", "precision", ",", "axis", "=", "0", ")", "\n", "recall", "=", "np", ".", "mean", "(", "recall", ",", "axis", "=", "0", ")", "\n", "precision_R", "=", "np", ".", "mean", "(", "precision_R", ",", "axis", "=", "0", ")", "\n", "\n", "# compute mAP", "\n", "mAP", "=", "np", ".", "mean", "(", "APall", ")", "\n", "\n", "if", "Radius", "is", "None", ":", "\n", "        ", "return", "mAP", ",", "precision", ",", "recall", "\n", "", "else", ":", "\n", "        ", "return", "mAP", ",", "precision", ",", "recall", ",", "precision_R", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.evaluate.Macro_AP": [[391, 427], ["evaluate.AP", "evaluate.is_multilabel", "numpy.unique", "len", "numpy.zeros", "range", "numpy.mean", "len", "y_train.flatten", "y_test.flatten", "numpy.all", "numpy.sum", "print", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.AP", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "", "def", "Macro_AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x,K) which \n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    weights: have shape (K,)\n    \n    return: Macro average precision (MacroAP)\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "ap_all", "=", "AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "num_return_NN", ",", "\n", "weights", "=", "weights", ")", "\n", "\n", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "if", "is_multi_label", "==", "False", "and", "len", "(", "y_train", ".", "shape", ")", ">", "1", ":", "\n", "        ", "y_train", ",", "y_test", "=", "y_train", ".", "flatten", "(", ")", ",", "y_test", ".", "flatten", "(", ")", "\n", "", "unique_labels", "=", "np", ".", "unique", "(", "y_train", ",", "axis", "=", "0", ")", "\n", "numclas", "=", "len", "(", "unique_labels", ")", "\n", "class_AP", "=", "np", ".", "zeros", "(", "(", "numclas", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "numclas", ")", ":", "\n", "        ", "if", "is_multi_label", ":", "\n", "            ", "index", "=", "np", ".", "all", "(", "unique_labels", "[", "i", "]", "==", "y_test", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "index", "=", "(", "unique_labels", "[", "i", "]", "==", "y_test", ")", "\n", "", "if", "np", ".", "sum", "(", "index", ")", "==", "0", ":", "\n", "            ", "class_AP", "[", "i", "]", "=", "-", "1", "\n", "print", "(", "f\"there is no test sample with label={unique_labels[i]}\"", ")", "\n", "", "else", ":", "\n", "            ", "class_AP", "[", "i", "]", "=", "np", ".", "sum", "(", "ap_all", "[", "index", "]", ")", "/", "np", ".", "sum", "(", "index", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "class_AP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.utilities.one_hot_encode": [[6, 15], ["len", "numpy.unique", "numpy.eye"], "function", ["None"], ["def", "one_hot_encode", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    One hot encodes a list of sample labels. Return a one-hot encoded vector \n        for each label.\n    : x: List of sample Labels\n    : return: Numpy array of one-hot encoded labels\n     \"\"\"", "\n", "n_classes", "=", "len", "(", "np", ".", "unique", "(", "x", ")", ")", "\n", "return", "np", ".", "eye", "(", "n_classes", ")", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.utilities.normalize_Z": [[17, 21], ["numpy.diag", "numpy.sqrt", "numpy.sum"], "function", ["None"], ["", "def", "normalize_Z", "(", "Z", ")", ":", "\n", "    ", "D", "=", "np", ".", "diag", "(", "1", "/", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "Z", ",", "axis", "=", "0", ")", ")", ")", "\n", "Z_normalized", "=", "Z", "@", "D", "\n", "return", "Z_normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.utilities.RRC": [[24, 50], ["utilities.one_hot_encode", "numpy.linalg.inv", "numpy.linalg.inv", "len", "tr_labels.flatten", "numpy.eye", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["", "def", "RRC", "(", "tr_data", ",", "tr_labels", ",", "lambda_", ",", "testing", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    tr_data: train data. Shape must be (n_samples,n_features)\n    tr_labels: train labels. Shape must be (n_samples,), or (n_samples,1), or \n        (n_samples,n_classes)\n    returns projection matrix\n    \"\"\"", "\n", "\n", "n_samples", ",", "n_features", "=", "tr_data", ".", "shape", "\n", "\n", "# projection matrix computing", "\n", "if", "n_samples", "<", "n_features", ":", "\n", "        ", "Proj_M", "=", "tr_data", ".", "T", "@", "(", "inv", "(", "tr_data", "@", "tr_data", ".", "T", "+", "lambda_", "*", "np", ".", "eye", "(", "n_samples", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "Proj_M", "=", "(", "inv", "(", "tr_data", ".", "T", "@", "tr_data", "+", "lambda_", "*", "np", ".", "eye", "(", "n_features", ")", ")", ")", "@", "tr_data", ".", "T", "\n", "\n", "# label matrix", "\n", "", "if", "len", "(", "tr_labels", ".", "shape", ")", "<", "2", "or", "tr_labels", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "# One-hot coding (only use it for multi-class (single-label) classification)", "\n", "        ", "Y", "=", "one_hot_encode", "(", "tr_labels", ".", "flatten", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "Y", "=", "tr_labels", "\n", "\n", "", "W", "=", "Proj_M", "@", "Y", "\n", "\n", "return", "W", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.utilities.to_Z": [[52, 106], ["numpy.zeros", "numpy.float32", "numpy.zeros", "numpy.zeros", "range", "numpy.exp", "range", "len", "scipy.spatial.distance.cdist", "numpy.argmin", "numpy.mean", "numpy.sum", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["None"], ["", "def", "to_Z", "(", "inputs", ",", "anchors", ",", "Z_spec", ")", ":", "\n", "    ", "\"\"\" \n    This function handles data-to-anchor mapping of inputs data. In other \n    words, the inputs representation is mapped to anchor-based representation.\n    Inputs:\n        inputs: input samples. Shape is (N, n_features) which N is the number of\n                inputs samples.\n        anchors: anchor points. shape is (n_anchors, n_features).\n        Z_spec: a dictionary that specifies how to compute Z. Keys should be\n                'n_anchors', 's', 'sigma', and 'metric'. \n                n_anchors: Number of anchors to compute (sparse) affinity matrix\n                s: number of selection for nearest anchors\n                metric: Distance metric used for computing affinity matrix\n                        It is used in cdist function\n                sigma: bandwitch to normalize distances\n                \n    Output:\n        Z: anchor-based represntation of inputs samples. shape is (N,n_anchors)\n    \"\"\"", "\n", "if", "len", "(", "inputs", ".", "shape", ")", "==", "1", ":", "\n", "        ", "N", "=", "1", "\n", "inputs", "=", "inputs", "[", "None", "]", "\n", "", "else", ":", "\n", "        ", "N", "=", "inputs", ".", "shape", "[", "0", "]", "\n", "\n", "", "n_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "assert", "Z_spec", "[", "'n_anchors'", "]", "==", "n_anchors", "\n", "s", "=", "Z_spec", "[", "'s'", "]", "\n", "sigma", "=", "Z_spec", "[", "'sigma'", "]", "\n", "Z", "=", "np", ".", "zeros", "(", "(", "N", ",", "n_anchors", ")", ",", "dtype", "=", "'float32'", ")", "# the truncated similarities", "\n", "Dis", "=", "np", ".", "float32", "(", "cdist", "(", "inputs", ",", "anchors", ",", "metric", "=", "Z_spec", "[", "'metric'", "]", ")", ")", "\n", "\n", "# select s nearest neighbors of each example", "\n", "min_val", "=", "np", ".", "zeros", "(", "(", "N", ",", "s", ")", ",", "dtype", "=", "'float32'", ")", "\n", "min_pos", "=", "np", ".", "zeros", "(", "(", "N", ",", "s", ")", ",", "dtype", "=", "'int'", ")", "\n", "\n", "for", "i", "in", "range", "(", "s", ")", ":", "\n", "        ", "min_pos", "[", ":", ",", "i", "]", "=", "np", ".", "argmin", "(", "Dis", ",", "axis", "=", "1", ")", "\n", "min_val", "[", ":", ",", "i", "]", "=", "Dis", "[", "np", ".", "arange", "(", "N", ")", ",", "min_pos", "[", ":", ",", "i", "]", "]", "\n", "Dis", "[", "np", ".", "arange", "(", "N", ")", ",", "min_pos", "[", ":", ",", "i", "]", "]", "=", "np", ".", "inf", "\n", "\n", "", "del", "Dis", "\n", "\n", "if", "sigma", "is", "None", ":", "\n", "        ", "sigma", "=", "np", ".", "mean", "(", "min_val", "[", ":", ",", "-", "1", "]", ")", "\n", "\n", "", "min_val", "=", "np", ".", "exp", "(", "-", "(", "(", "min_val", "/", "sigma", ")", "**", "2", ")", ")", "\n", "min_val", "=", "min_val", "/", "np", ".", "sum", "(", "min_val", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "\n", "# fill Z matrix", "\n", "for", "i", "in", "range", "(", "s", ")", ":", "\n", "        ", "Z", "[", "np", ".", "arange", "(", "N", ")", ",", "min_pos", "[", ":", ",", "i", "]", "]", "=", "min_val", "[", ":", ",", "i", "]", "\n", "\n", "", "return", "Z", "", "", ""]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Affinity_matrix.Affinity": [[7, 35], ["numpy.random.RandomState", "utilities.to_Z", "init.lower", "init.lower", "sklearn.cluster.KMeans().fit", "ValueError", "np.random.RandomState.choice", "sklearn.cluster.KMeans"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.to_Z"], ["def", "Affinity", "(", "train_data", ",", "Z_spec", ",", "random_state", "=", "42", ",", "init", "=", "'random'", ")", ":", "\n", "    ", "\"\"\"\n    inputs:\n        train_data shape is (n_samples,n_features)\n        Z_spec: a dictionary that specifies how to compute Z. Keys should be\n                'n_anchors', 's', 'sigma', and 'metric'\n        random_state: Must be integer\n        init: method of anchor initialization. Can be 'random' or 'kmeans'\n    outputs: \n        Z: data-to-anchor mapping of train data. shape is (n_samples, n_anchors)\n        anchors: anchor points. shape is (n_anchors, n_features)\n    \"\"\"", "\n", "\n", "N", "=", "train_data", ".", "shape", "[", "0", "]", "# number of samples", "\n", "n_anchors", "=", "Z_spec", "[", "'n_anchors'", "]", "\n", "R", "=", "np", ".", "random", ".", "RandomState", "(", "random_state", ")", "\n", "if", "init", ".", "lower", "(", ")", "==", "'random'", ":", "\n", "        ", "anchors", "=", "train_data", "[", "R", ".", "choice", "(", "N", ",", "size", "=", "n_anchors", ",", "replace", "=", "False", ")", ",", ":", "]", "\n", "", "elif", "init", ".", "lower", "(", ")", "==", "'kmeans'", ":", "\n", "        ", "kmeans", "=", "KMeans", "(", "n_clusters", "=", "n_anchors", ",", "max_iter", "=", "10", ",", "n_init", "=", "1", ",", "\n", "random_state", "=", "random_state", ")", ".", "fit", "(", "train_data", ")", "\n", "anchors", "=", "kmeans", ".", "cluster_centers_", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'init must be \"random\" or \"kmeans\"'", ")", "\n", "\n", "", "Z", "=", "to_Z", "(", "train_data", ",", "anchors", ",", "Z_spec", ")", "\n", "\n", "return", "Z", ",", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.get_feature_affinity": [[18, 23], ["utilities.normalize_Z"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.normalize_Z"], ["def", "get_feature_affinity", "(", "train_features", ",", "Z", ")", ":", "\n", "    ", "Z", "=", "normalize_Z", "(", "Z", ")", "\n", "L", "=", "train_features", ".", "T", "@", "Z", "\n", "Affinity", "=", "L", "@", "L", ".", "T", "\n", "return", "Affinity", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.initialize_W": [[25, 32], ["scipy.sparse.linalg.eigsh", "tensorflow.Variable", "tensorflow.Variable"], "function", ["None"], ["", "def", "initialize_W", "(", "W", "=", "None", ",", "Affinity", "=", "None", ",", "K", "=", "16", ")", ":", "\n", "    ", "if", "W", "is", "None", ":", "\n", "        ", "eig_val", ",", "eig_vec", "=", "eigsh", "(", "Affinity", ",", "k", "=", "K", ",", "which", "=", "'LA'", ")", "\n", "W", "=", "tf", ".", "Variable", "(", "eig_vec", ",", "dtype", "=", "tf", ".", "float32", ",", "name", "=", "\"W\"", ")", "\n", "", "else", ":", "\n", "        ", "W", "=", "tf", ".", "Variable", "(", "W", ",", "dtype", "=", "tf", ".", "float32", ",", "name", "=", "\"W\"", ")", "\n", "", "return", "W", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.cost_fn": [[34, 42], ["matmul", "tensorflow.math.square", "trace", "tensorflow.norm", "matmul", "tensorflow.math.subtract", "tensorflow.transpose", "matmul", "tensorflow.math.abs"], "function", ["None"], ["", "def", "cost_fn", "(", "train_features", ",", "W", ",", "Affinity", ",", "alpha", "=", "1", ")", ":", "\n", "    ", "main_cost", "=", "-", "1", "*", "trace", "(", "matmul", "(", "tf", ".", "transpose", "(", "W", ")", ",", "matmul", "(", "Affinity", ",", "W", ")", ")", ")", "\n", "projected_values", "=", "matmul", "(", "train_features", ",", "W", ")", "\n", "# ones1 = tf.ones((train_features.shape[0], W.shape[1]), dtype=np.float32)", "\n", "reg", "=", "tf", ".", "math", ".", "square", "(", "tf", ".", "norm", "(", "tf", ".", "math", ".", "subtract", "(", "tf", ".", "math", ".", "abs", "(", "projected_values", ")", ",", "\n", "1", ")", ",", "ord", "=", "'fro'", ",", "axis", "=", "[", "0", ",", "1", "]", ")", ")", "\n", "cost", "=", "(", "main_cost", "+", "0.5", "*", "alpha", "*", "reg", ")", "/", "train_features", ".", "shape", "[", "0", "]", "\n", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.grad_J": [[44, 46], ["matmul", "matmul", "tensorflow.transpose"], "function", ["None"], ["", "def", "grad_J", "(", "grad", ",", "W", ")", ":", "\n", "    ", "return", "(", "grad", "-", "matmul", "(", "matmul", "(", "W", ",", "tf", ".", "transpose", "(", "grad", ")", ")", ",", "W", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.generalized_grad_J": [[48, 53], ["matmul", "matmul", "matmul", "tensorflow.transpose", "matmul", "matmul"], "function", ["None"], ["", "def", "generalized_grad_J", "(", "grad", ",", "W", ",", "M", ",", "K_inv", "=", "None", ")", ":", "\n", "    ", "WGW", "=", "matmul", "(", "matmul", "(", "W", ",", "tf", ".", "transpose", "(", "grad", ")", ")", ",", "W", ")", "\n", "if", "K_inv", "is", "None", ":", "\n", "        ", "return", "grad", "-", "matmul", "(", "M", ",", "WGW", ")", "\n", "", "return", "grad", "-", "matmul", "(", "matmul", "(", "M", ",", "WGW", ")", ",", "K_inv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.compute_alpha": [[55, 62], ["matmul", "tensorflow.math.square", "tensorflow.math.abs", "trace", "tensorflow.norm", "matmul", "tensorflow.math.subtract", "tensorflow.transpose", "matmul", "tensorflow.math.abs"], "function", ["None"], ["", "def", "compute_alpha", "(", "train_features", ",", "W", ",", "Affinity", ")", ":", "\n", "    ", "main_cost", "=", "-", "1", "*", "trace", "(", "matmul", "(", "tf", ".", "transpose", "(", "W", ")", ",", "matmul", "(", "Affinity", ",", "W", ")", ")", ")", "\n", "projected_values", "=", "matmul", "(", "train_features", ",", "W", ")", "\n", "reg", "=", "tf", ".", "math", ".", "square", "(", "tf", ".", "norm", "(", "tf", ".", "math", ".", "subtract", "(", "tf", ".", "math", ".", "abs", "(", "projected_values", ")", ",", "\n", "1", ")", ",", "ord", "=", "'fro'", ",", "axis", "=", "[", "0", ",", "1", "]", ")", ")", "\n", "alpha", "=", "tf", ".", "math", ".", "abs", "(", "2", "*", "main_cost", "/", "reg", ")", "\n", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.ESH_manifold": [[64, 122], ["Efficient_SH_with_manifold_ours.get_feature_affinity", "Efficient_SH_with_manifold_ours.initialize_W", "tensorflow.constant", "tensorflow.constant", "numpy.zeros", "tensorflow.linalg.eye", "range", "Efficient_SH_with_manifold_ours.compute_alpha", "print", "tensorflow.identity", "tape.gradient", "matmul", "matmul", "initialize_W.assign", "tensorflow.abs", "initialize_W.numpy", "tensorflow.GradientTape", "Efficient_SH_with_manifold_ours.cost_fn", "cost_fn.numpy", "tensorflow.transpose", "tensorflow.transpose", "inv", "matmul", "print", "Efficient_SH_with_manifold_ours.grad_J", "Efficient_SH_with_manifold_ours.grad_J", "numpy.abs", "print", "trace", "trace", "matmul", "matmul", "tensorflow.transpose", "tensorflow.transpose"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.get_feature_affinity", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.initialize_W", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.compute_alpha", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.cost_fn", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.grad_J", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.grad_J"], ["", "def", "ESH_manifold", "(", "train_features", ",", "Z", ",", "K", "=", "16", ",", "alpha", "=", "None", ",", "lr", "=", "0.01", ",", "\n", "maxiter", "=", "10000", ",", "W", "=", "None", ")", ":", "\n", "    ", "\"\"\" Efficient Spectral hashing using manifold solver\n    train_features: shape is (n_samples,n_features)\n    Z: data-to-anchor mapping of train data. shape is (n_samples, n_anchors)\n    K: Number of bits for each binary code\n    alpha: the regularization coefficient for binary constraint. If None,\n        compute_alpha function is used.\n    maxiter: maximum number of iterations used for ESH solver\n    W: the initialization matrix used for hash functions.\n\n    Output:\n        W: The learned hash functions. It has shape (n_features, K)\n    \"\"\"", "\n", "# compute feature affinity", "\n", "Affinity", "=", "get_feature_affinity", "(", "train_features", ",", "Z", ")", "\n", "# initialize W", "\n", "W", "=", "initialize_W", "(", "W", "=", "W", ",", "Affinity", "=", "Affinity", ",", "K", "=", "K", ")", "\n", "# setting constants", "\n", "Affinity", "=", "tf", ".", "constant", "(", "Affinity", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "train_features", "=", "tf", ".", "constant", "(", "train_features", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "cost_values", "=", "np", ".", "zeros", "(", "(", "maxiter", ",", ")", ")", "\n", "I", "=", "lin", ".", "eye", "(", "W", ".", "shape", "[", "0", "]", ")", "\n", "if", "alpha", "is", "None", ":", "\n", "        ", "alpha", "=", "compute_alpha", "(", "train_features", ",", "W", ",", "Affinity", ")", "\n", "print", "(", "f\"alpha={alpha} is selected\"", ")", "\n", "\n", "# main loop", "\n", "", "for", "it", "in", "range", "(", "maxiter", ")", ":", "\n", "        ", "W_old", "=", "tf", ".", "identity", "(", "W", ")", "\n", "with", "tf", ".", "GradientTape", "(", "persistent", "=", "True", ")", "as", "tape", ":", "\n", "# define cost", "\n", "            ", "cost", "=", "cost_fn", "(", "train_features", ",", "W", ",", "Affinity", ",", "alpha", "=", "alpha", ")", "\n", "cost_values", "[", "it", "]", "=", "cost", ".", "numpy", "(", ")", "\n", "# compute gradient", "\n", "", "grad", "=", "tape", ".", "gradient", "(", "cost", ",", "W", ")", "\n", "del", "tape", "\n", "# compute F", "\n", "F0", "=", "matmul", "(", "grad", ",", "tf", ".", "transpose", "(", "W", ")", ")", "\n", "F", "=", "F0", "-", "tf", ".", "transpose", "(", "F0", ")", "\n", "# update W", "\n", "Q", "=", "matmul", "(", "inv", "(", "I", "+", "lr", "*", "0.5", "*", "F", ")", ",", "(", "I", "-", "lr", "*", "0.5", "*", "F", ")", ")", "\n", "W", ".", "assign", "(", "matmul", "(", "Q", ",", "W", ")", ",", "read_value", "=", "False", ")", "\n", "# print cost", "\n", "if", "(", "it", "+", "1", ")", "%", "50", "==", "0", ":", "\n", "            ", "print", "(", "f'cost value after {it + 1} iterations: {cost_values[it]}'", ")", "\n", "# convergence check", "\n", "", "if", "it", "%", "10", "==", "0", "and", "it", ">", "0", ":", "\n", "            ", "convg_check", "=", "(", "cost_values", "[", "it", "]", "-", "cost_values", "[", "it", "-", "10", "]", ")", "/", "cost_values", "[", "it", "-", "10", "]", "\n", "if", "np", ".", "abs", "(", "convg_check", ")", "<", "1e-4", ":", "\n", "                ", "print", "(", "f\"The problem converged after {it + 1} iteration\"", ")", "\n", "break", "\n", "# update learning rate", "\n", "", "", "M_it", "=", "W", "-", "W_old", "\n", "Y_it", "=", "grad_J", "(", "grad", ",", "W", ")", "-", "grad_J", "(", "grad", ",", "W_old", ")", "\n", "lr", "=", "tf", ".", "abs", "(", "trace", "(", "matmul", "(", "tf", ".", "transpose", "(", "M_it", ")", ",", "Y_it", ")", ")", "/", "trace", "(", "matmul", "(", "tf", ".", "transpose", "(", "Y_it", ")", ",", "Y_it", ")", ")", ")", "\n", "\n", "", "return", "W", ".", "numpy", "(", ")", ",", "cost_values", "[", ":", "it", "+", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Efficient_SH_with_manifold_ours.ESH_generalized_manifold": [[124, 188], ["Efficient_SH_with_manifold_ours.get_feature_affinity", "scipy.sparse.linalg.eigsh", "tensorflow.Variable", "tensorflow.constant", "tensorflow.constant", "tensorflow.constant", "numpy.zeros", "tensorflow.linalg.eye", "range", "numpy.sqrt", "Efficient_SH_with_manifold_ours.compute_alpha", "print", "tensorflow.identity", "tape.gradient", "matmul", "matmul", "matmul", "tf.Variable.assign", "tf.Variable.numpy", "numpy.eye", "tensorflow.GradientTape", "Efficient_SH_with_manifold_ours.cost_fn", "cost_fn.numpy", "matmul", "tensorflow.transpose", "inv", "matmul", "print", "tensorflow.transpose", "numpy.abs", "print"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.get_feature_affinity", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.compute_alpha", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.cost_fn"], ["", "def", "ESH_generalized_manifold", "(", "train_features", ",", "Z", ",", "K", "=", "16", ",", "alpha", "=", "None", ",", "lr", "=", "0.01", ",", "\n", "maxiter", "=", "10000", ")", ":", "\n", "    ", "\"\"\" Efficient Spectral hashing using manifold solver\n    train_features: shape is (n_samples,n_features)\n    Z: data-to-anchor mapping of train data. shape is (n_samples, n_anchors)\n    K: Number of bits for each binary code\n    alpha: the regularization coefficient for binary constraint. If None,\n        compute_alpha function is used.\n    maxiter: maximum number of iterations used for ESH solver\n\n    Output:\n        W: The learned hash functions. It has shape (n_features, K)\n    \"\"\"", "\n", "# compute feature affinity", "\n", "Affinity", "=", "get_feature_affinity", "(", "train_features", ",", "Z", ")", "\n", "# compute data covariance", "\n", "M", "=", "(", "train_features", ".", "T", "@", "train_features", ")", "/", "train_features", ".", "shape", "[", "0", "]", "\n", "M", "=", "M", "+", "0.01", "*", "np", ".", "eye", "(", "train_features", ".", "shape", "[", "1", "]", ")", "\n", "# initialize W", "\n", "eig_val", ",", "eig_vec", "=", "eigsh", "(", "M", ",", "k", "=", "K", ",", "which", "=", "'LA'", ")", "\n", "W", "=", "eig_vec", "/", "np", ".", "sqrt", "(", "eig_val", ")", "\n", "W", "=", "tf", ".", "Variable", "(", "W", ",", "dtype", "=", "tf", ".", "float32", ",", "name", "=", "\"W\"", ")", "\n", "# setting constants", "\n", "Affinity", "=", "tf", ".", "constant", "(", "Affinity", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "train_features", "=", "tf", ".", "constant", "(", "train_features", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "M", "=", "tf", ".", "constant", "(", "M", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "cost_values", "=", "np", ".", "zeros", "(", "(", "maxiter", ",", ")", ")", "\n", "I", "=", "lin", ".", "eye", "(", "W", ".", "shape", "[", "0", "]", ")", "\n", "if", "alpha", "is", "None", ":", "\n", "        ", "alpha", "=", "compute_alpha", "(", "train_features", ",", "W", ",", "Affinity", ")", "\n", "print", "(", "f\"alpha={alpha} is selected\"", ")", "\n", "\n", "# main loop", "\n", "", "for", "it", "in", "range", "(", "maxiter", ")", ":", "\n", "        ", "W_old", "=", "tf", ".", "identity", "(", "W", ")", "\n", "with", "tf", ".", "GradientTape", "(", "persistent", "=", "True", ")", "as", "tape", ":", "\n", "# define cost", "\n", "            ", "cost", "=", "cost_fn", "(", "train_features", ",", "W", ",", "Affinity", ",", "alpha", "=", "alpha", ")", "\n", "cost_values", "[", "it", "]", "=", "cost", ".", "numpy", "(", ")", "\n", "# compute gradient", "\n", "", "grad", "=", "tape", ".", "gradient", "(", "cost", ",", "W", ")", "\n", "del", "tape", "\n", "# compute F", "\n", "F0", "=", "matmul", "(", "matmul", "(", "grad", ",", "tf", ".", "transpose", "(", "W", ")", ")", ",", "M", ")", "\n", "F", "=", "F0", "-", "tf", ".", "transpose", "(", "F0", ")", "\n", "# update W", "\n", "F", "=", "matmul", "(", "F", ",", "M", ")", "\n", "Q", "=", "matmul", "(", "inv", "(", "I", "+", "lr", "*", "0.5", "*", "F", ")", ",", "(", "I", "-", "lr", "*", "0.5", "*", "F", ")", ")", "\n", "W", ".", "assign", "(", "matmul", "(", "Q", ",", "W", ")", ",", "read_value", "=", "False", ")", "\n", "# print cost", "\n", "if", "(", "it", "+", "1", ")", "%", "50", "==", "0", ":", "\n", "            ", "print", "(", "f'cost value after {it + 1} iterations: {cost_values[it]}'", ")", "\n", "# convergence check", "\n", "", "if", "it", "%", "10", "==", "0", "and", "it", ">", "0", ":", "\n", "            ", "convg_check", "=", "(", "cost_values", "[", "it", "]", "-", "cost_values", "[", "it", "-", "10", "]", ")", "/", "cost_values", "[", "it", "-", "10", "]", "\n", "if", "np", ".", "abs", "(", "convg_check", ")", "<", "1e-4", ":", "\n", "                ", "print", "(", "f\"The problem converged after {it + 1} iteration\"", ")", "\n", "break", "\n", "# update learning rate", "\n", "# M_it = W - W_old", "\n", "# Y_it = generalized_grad_J(grad, W, M) - generalized_grad_J(grad, W_old, M)", "\n", "# lr = tf.abs(trace(matmul(tf.transpose(M_it), Y_it))/trace(matmul(tf.transpose(Y_it), Y_it)))", "\n", "\n", "", "", "", "return", "W", ".", "numpy", "(", ")", ",", "cost_values", "[", ":", "it", "+", "1", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Datasets.cifar10_vggfc7": [[9, 30], ["os.path.join", "os.path.join", "scipy.io.loadmat", "scipy.io.loadmat", "utilities.one_hot_encode", "utilities.one_hot_encode"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["def", "cifar10_vggfc7", "(", "path", ",", "one_hot", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing cifar10_vggfc7 features\n        one_hot: If True, return one hoted labels.\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "train_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'cifar10_vggfc7_train.mat'", ")", "\n", "test_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'cifar10_vggfc7_test.mat'", ")", "\n", "\n", "train_dict", "=", "loadmat", "(", "train_path", ",", "squeeze_me", "=", "True", ")", "\n", "test_dict", "=", "loadmat", "(", "test_path", ",", "squeeze_me", "=", "True", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "train_dict", "[", "'train_features'", "]", ",", "train_dict", "[", "'train_labels'", "]", "\n", "test_features", ",", "test_labels", "=", "test_dict", "[", "'test_features'", "]", ",", "test_dict", "[", "'test_labels'", "]", "\n", "\n", "if", "one_hot", ":", "\n", "        ", "train_labels", ",", "test_labels", "=", "one_hot_encode", "(", "train_labels", ")", ",", "one_hot_encode", "(", "test_labels", ")", "\n", "\n", "", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Datasets.labelme_vggfc7": [[32, 53], ["os.path.join", "os.path.join", "scipy.io.loadmat", "scipy.io.loadmat", "utilities.one_hot_encode", "utilities.one_hot_encode"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["", "def", "labelme_vggfc7", "(", "path", ",", "one_hot", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing labelme_vggfc7 features\n        one_hot: If True, return one hoted labels.\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "train_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'labelme_vggfc7_train.mat'", ")", "\n", "test_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'labelme_vggfc7_test.mat'", ")", "\n", "\n", "train_dict", "=", "loadmat", "(", "train_path", ",", "squeeze_me", "=", "True", ")", "\n", "test_dict", "=", "loadmat", "(", "test_path", ",", "squeeze_me", "=", "True", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "train_dict", "[", "'train_features'", "]", ",", "train_dict", "[", "'train_labels'", "]", "\n", "test_features", ",", "test_labels", "=", "test_dict", "[", "'test_features'", "]", ",", "test_dict", "[", "'test_labels'", "]", "\n", "\n", "if", "one_hot", ":", "\n", "        ", "train_labels", ",", "test_labels", "=", "one_hot_encode", "(", "train_labels", ")", ",", "one_hot_encode", "(", "test_labels", ")", "\n", "\n", "", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Datasets.nuswide_vgg": [[55, 70], ["os.path.join", "numpy.load().item", "numpy.load"], "function", ["None"], ["", "def", "nuswide_vgg", "(", "path", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing nuswide_vgg features (with global avg pooling)\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'deep_features_global_AVG_POOL.npy'", ")", "\n", "\n", "data", "=", "np", ".", "load", "(", "path", ",", "allow_pickle", "=", "True", ")", ".", "item", "(", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "data", "[", "'x_train'", "]", ",", "data", "[", "'y_train'", "]", "\n", "test_features", ",", "test_labels", "=", "data", "[", "'x_test'", "]", ",", "data", "[", "'y_test'", "]", "\n", "\n", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Datasets.colorectal_eff": [[72, 90], ["os.path.join", "numpy.load().item", "numpy.load", "utilities.one_hot_encode", "utilities.one_hot_encode"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["", "def", "colorectal_eff", "(", "path", ",", "one_hot", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing EfficientNet features of colorectal dataset\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'eff_net_colorectal_deep_features_no_tuning.npy'", ")", "\n", "\n", "data", "=", "np", ".", "load", "(", "path", ",", "allow_pickle", "=", "True", ")", ".", "item", "(", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "data", "[", "'x_train'", "]", ",", "data", "[", "'y_train'", "]", "\n", "test_features", ",", "test_labels", "=", "data", "[", "'x_test'", "]", ",", "data", "[", "'y_test'", "]", "\n", "\n", "if", "one_hot", ":", "\n", "        ", "train_labels", ",", "test_labels", "=", "one_hot_encode", "(", "train_labels", ")", ",", "one_hot_encode", "(", "test_labels", ")", "\n", "\n", "", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.Datasets.load_dataset": [[99, 111], ["dataset_loader", "name.lower"], "function", ["None"], ["def", "load_dataset", "(", "name", ",", "path", "=", "'.'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    the name of dataset. It can be one of 'cifar10_vggfc7', \n        nuswide_vgg, labelme_vggfc7, colorectal_efficientnet\n    path: the path containing dataset files (Do not include the filenames of \n        dataset)\n    **kwargs are passed to the function that loads name dataset.\n    \"\"\"", "\n", "dataset_loader", "=", "Dataset_maps", "[", "name", ".", "lower", "(", ")", "]", "\n", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "=", "dataset_loader", "(", "\n", "path", ",", "**", "kwargs", ")", "\n", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "", ""]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.out_of_sample.projection_matrix": [[9, 27], ["numpy.array", "numpy.diag", "np.diag.flatten", "numpy.sum"], "function", ["None"], ["def", "projection_matrix", "(", "B", ",", "Z", ")", ":", "\n", "    ", "\"\"\"\n    Projectetion matrix maps anchor-based represntation of samples to binary\n    codes.\n    Inputs:\n        B: binary codes or approximated binary codes (with real values) of\n           training samples. If B is binary, values must be [-1,1].\n           shape of B is (n_samples, K) which K is number of bits.\n        Z: anchor-based represntation of training samples. shape is \n           (n_samples, n_anchors).\n    Output:\n        Projection matrix. Shape is (K, n_anchors).\n    \"\"\"", "\n", "\n", "D", "=", "np", ".", "array", "(", "1", "/", "(", "np", ".", "sum", "(", "Z", ",", "axis", "=", "0", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "D", "=", "np", ".", "diag", "(", "D", ".", "flatten", "(", ")", ")", "\n", "\n", "return", "B", ".", "T", "@", "Z", "@", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_manifold.out_of_sample.out_of_sample_binary_codes": [[29, 52], ["out_of_sample.projection_matrix", "utilities.to_Z", "numpy.sign"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.out_of_sample.projection_matrix", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.to_Z"], ["", "def", "out_of_sample_binary_codes", "(", "X_test", ",", "B", ",", "Z_train", ",", "anchors", ",", "Z_spec", ")", ":", "\n", "    ", "\"\"\"\n    This function generates binary code for new (unseen) samples.\n    Ref: Discrete Graph Hashing paper 2014. \n    Inputs:\n        X_test: new samples. shape is (n_test, n_features).\n        B: learned binary codes or approximated binary codes (with real values)\n           of training samples. If B is binary, values must be [-1,1].\n           shape of B is (n_train_samples, K) which K is number of bits.\n        Z_train: anchor-based represntation of training samples. shape is \n           (n_train_samples, n_anchors).\n        anchors: anchor points. shape is (n_anchors, n_features).\n        Z_spec: a dictionary that specifies how to compute Z. Keys should be\n                'n_anchors', 's', 'sigma', and 'metric'.\n    Output:\n        B_test: new binary codes for test samples. shape is (n_test, K), which \n                K is the number of bits.\n    \"\"\"", "\n", "\n", "W", "=", "projection_matrix", "(", "B", ",", "Z_train", ")", "\n", "Z", "=", "to_Z", "(", "X_test", ",", "anchors", ",", "Z_spec", ")", "\n", "B_test", "=", "Z", "@", "W", ".", "T", "\n", "return", "np", ".", "sign", "(", "B_test", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel": [[8, 17], ["len"], "function", ["None"], ["def", "is_multilabel", "(", "y_train", ")", ":", "\n", "    ", "shape_", "=", "y_train", ".", "shape", "\n", "if", "(", "len", "(", "shape_", ")", "==", "1", ")", "or", "shape_", "[", "1", "]", "==", "1", ":", "\n", "        ", "return", "False", "\n", "\n", "#    y_train = y_train>0 ", "\n", "#    n_labels_per_sample = np.sum(y_train, axis=1)", "\n", "#    return np.any(n_labels_per_sample>1)", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.precision_recall": [[19, 103], ["numpy.sort", "numpy.zeros", "numpy.zeros", "numpy.max", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "numpy.mean", "numpy.mean", "numpy.array", "np.tile.flatten", "numpy.sum", "numpy.argsort", "collections.Counter", "numpy.cumsum", "len", "len", "len", "numpy.abs", "isinstance", "numpy.tile", "numpy.sum", "numpy.argsort"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "precision_recall", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "M_set", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x, K) which \n        x is number of observations and K is the number of bits. \n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    M_set contains the (sorted) points in which precision and recall are \n        computed. In other words, if m be the member of M_set, precision@m and \n        recall@m are computed after retrieving m nearest neighbors to the query. \n    weights: have shape (K,)\n    \n    return: Precision and recall for each member of (sorted) M_set.\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "M_set", "=", "np", ".", "sort", "(", "np", ".", "array", "(", "M_set", ",", "dtype", "=", "np", ".", "uint", ")", ")", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "precision", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "recall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "M", "=", "np", ".", "max", "(", "M_set", ")", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "1", "\n", "normalization_term", "=", "K", "\n", "", "else", ":", "\n", "        ", "weights", "=", "weights", ".", "flatten", "(", ")", "\n", "assert", "(", "len", "(", "weights", ")", "==", "K", ")", "\n", "normalization_term", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "weights", ")", ")", "\n", "\n", "# big data flag", "\n", "", "big_flag", "=", "True", "\n", "if", "x_train", ".", "shape", "[", "0", "]", "*", "x_test", ".", "shape", "[", "0", "]", "<=", "0.5e9", ":", "\n", "        ", "big_flag", "=", "False", "\n", "if", "not", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "            ", "weights", "=", "np", ".", "tile", "(", "weights", "[", "None", "]", ",", "[", "n_test", ",", "1", "]", ")", "\n", "\n", "", "", "if", "big_flag", "==", "False", ":", "\n", "        ", "hamm_dist_mat", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "*", "weights", ")", ".", "T", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", ")", "*", "weights", ")", ".", "T", ")", "\n", "arg_dist_mat", "=", "np", ".", "argsort", "(", "hamm_dist_mat", ",", "axis", "=", "0", ")", "\n", "del", "hamm_dist_mat", "\n", "\n", "# compute precision and recall for each query", "\n", "", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "if", "is_multi_label", "==", "False", ":", "\n", "        ", "real_pos_per_class", "=", "Counter", "(", "y_train", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "\n", "        ", "if", "big_flag", "==", "False", ":", "\n", "# top (nearset) M neighbors to the query", "\n", "            ", "arg_dist", "=", "arg_dist_mat", "[", ":", "M", ",", "i", "]", "\n", "", "else", ":", "\n", "# hamming distance between train_data and the query", "\n", "            ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", "*", "weights", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", "*", "weights", ")", ")", "\n", "# top (nearset) M neighbors to the query", "\n", "arg_dist", "=", "np", ".", "argsort", "(", "hamm_dist", ")", "[", ":", "M", "]", "\n", "\n", "", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "            ", "is_correct", "=", "(", "y_train", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "total_Positives", "=", "np", ".", "sum", "(", "is_correct", ")", "# used for recall computation", "\n", "is_correct", "=", "is_correct", "[", "arg_dist", "]", "\n", "", "else", ":", "# multi-class case", "\n", "            ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct", "=", "(", "q_label", "==", "y_train", "[", "arg_dist", "]", ")", "\n", "total_Positives", "=", "real_pos_per_class", "[", "q_label", "]", "\n", "\n", "# compute precision and recall for each m", "\n", "", "is_correct_sum", "=", "np", ".", "cumsum", "(", "is_correct", ")", "\n", "TP", "=", "is_correct_sum", "[", "M_set", "-", "1", "]", "# true positives", "\n", "precision", "[", "i", ",", ":", "]", "=", "TP", "/", "M_set", "\n", "recall", "[", "i", ",", ":", "]", "=", "TP", "/", "total_Positives", "\n", "\n", "# compute average precision and recall", "\n", "", "precision", "=", "np", ".", "mean", "(", "precision", ",", "axis", "=", "0", ")", "\n", "recall", "=", "np", ".", "mean", "(", "recall", ",", "axis", "=", "0", ")", "\n", "\n", "return", "precision", ",", "recall", ",", "M_set", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.precision_radius": [[105, 160], ["numpy.zeros", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "numpy.mean", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "precision_radius", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "Radius", "=", "2", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x, K) which\n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    Radius is the radius of hamming ball for search.\n    \n    return: Precision @ Radius=Radius\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "precision", "=", "np", ".", "zeros", "(", "(", "n_test", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "\n", "normalization_term", "=", "K", "\n", "\n", "# compute precision and recall for each query", "\n", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "# hamming distance between train_data and the query", "\n", "        ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", ")", ")", "\n", "idx_radius", "=", "hamm_dist", "<=", "Radius", "\n", "m", "=", "np", ".", "sum", "(", "idx_radius", ")", "\n", "if", "m", "==", "0", ":", "\n", "            ", "precision", "[", "i", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "y_train_radius", "=", "y_train", "[", "idx_radius", "]", "\n", "\n", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "                ", "is_correct", "=", "(", "y_train_radius", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "\n", "", "else", ":", "# multi-class case", "\n", "                ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct", "=", "(", "q_label", "==", "y_train_radius", ")", "\n", "\n", "# compute precision for images in radius 2", "\n", "\n", "", "TP", "=", "np", ".", "sum", "(", "is_correct", ")", "# true positives", "\n", "precision", "[", "i", "]", "=", "TP", "/", "m", "\n", "\n", "\n", "# compute average precision and recall", "\n", "", "", "precision", "=", "np", ".", "mean", "(", "precision", ",", "axis", "=", "0", ")", "\n", "\n", "return", "precision", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.interpolated_precision_recall": [[162, 176], ["numpy.argsort", "numpy.zeros", "enumerate", "numpy.max", "len"], "function", ["None"], ["", "def", "interpolated_precision_recall", "(", "precisions", ",", "recalls", ")", ":", "\n", "    ", "\"\"\"\n    for ref see the link below:\n    # https://github.com/rafaelpadilla/Object-Detection-Metrics\n    \"\"\"", "\n", "idx", "=", "np", ".", "argsort", "(", "recalls", ")", "\n", "recalls", "=", "recalls", "[", "idx", "]", "\n", "precisions", "=", "precisions", "[", "idx", "]", "\n", "precisions_intp", "=", "np", ".", "zeros", "(", "(", "len", "(", "precisions", ")", ",", ")", ")", "\n", "for", "i", ",", "r", "in", "enumerate", "(", "recalls", ")", ":", "\n", "        ", "bool_index", "=", "recalls", ">=", "r", "\n", "precisions_intp", "[", "i", "]", "=", "np", ".", "max", "(", "precisions", "[", "bool_index", "]", ")", "\n", "\n", "", "return", "precisions_intp", ",", "recalls", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.AP": [[178, 252], ["numpy.zeros", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "np.tile.flatten", "numpy.sum", "numpy.argsort", "len", "len", "numpy.abs", "isinstance", "numpy.tile", "numpy.where", "numpy.argsort", "numpy.arange", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x,K) which\n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    weights: have shape (K,)\n    \n    return: average precision (AP) per query.\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "if", "num_return_NN", "is", "None", ":", "\n", "        ", "num_return_NN", "=", "x_train", ".", "shape", "[", "0", "]", "\n", "", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "APall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", ")", ")", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "1", "\n", "normalization_term", "=", "K", "\n", "", "else", ":", "\n", "        ", "weights", "=", "weights", ".", "flatten", "(", ")", "\n", "assert", "(", "len", "(", "weights", ")", "==", "K", ")", "\n", "normalization_term", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "weights", ")", ")", "\n", "\n", "# big data flag", "\n", "", "big_flag", "=", "True", "\n", "if", "x_train", ".", "shape", "[", "0", "]", "*", "x_test", ".", "shape", "[", "0", "]", "<=", "0.5e9", ":", "\n", "        ", "big_flag", "=", "False", "\n", "if", "not", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "            ", "weights", "=", "np", ".", "tile", "(", "weights", "[", "None", "]", ",", "[", "n_test", ",", "1", "]", ")", "\n", "\n", "", "", "if", "big_flag", "==", "False", ":", "\n", "        ", "hamm_dist_mat", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "*", "weights", ")", ".", "T", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", ")", "*", "weights", ")", ".", "T", ")", "\n", "arg_dist_mat", "=", "np", ".", "argsort", "(", "hamm_dist_mat", ",", "axis", "=", "0", ")", "\n", "del", "hamm_dist_mat", "\n", "\n", "# compute AP for each query", "\n", "", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "\n", "        ", "if", "big_flag", "==", "False", ":", "\n", "# top (nearset) neighbors to the query", "\n", "            ", "arg_dist", "=", "arg_dist_mat", "[", ":", "num_return_NN", ",", "i", "]", "\n", "", "else", ":", "\n", "# hamming distance between train_data and the query", "\n", "            ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", "*", "weights", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", "*", "weights", ")", ")", "\n", "# top (nearset) neighbors to the query", "\n", "arg_dist", "=", "np", ".", "argsort", "(", "hamm_dist", ")", "[", ":", "num_return_NN", "]", "\n", "\n", "", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "            ", "is_correct", "=", "(", "y_train", "[", "arg_dist", ",", ":", "]", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "", "else", ":", "# multi-class case", "\n", "            ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct", "=", "(", "q_label", "==", "y_train", "[", "arg_dist", "]", ")", "\n", "\n", "", "TP_loc", "=", "np", ".", "where", "(", "is_correct", ")", "[", "0", "]", "\n", "n_TP", "=", "len", "(", "TP_loc", ")", "# total number of true positives in num_return_NN", "\n", "if", "n_TP", "==", "0", ":", "\n", "            ", "APall", "[", "i", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "precisions", "=", "(", "np", ".", "arange", "(", "1", ",", "n_TP", "+", "1", ")", ")", "/", "(", "TP_loc", "+", "1", ")", "# calculate precisions ", "\n", "# only at the true positive locations", "\n", "APall", "[", "i", "]", "=", "np", ".", "sum", "(", "precisions", ")", "/", "n_TP", "\n", "\n", "", "", "return", "APall", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.mAP": [[254, 270], ["evaluate.AP", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.AP"], ["", "def", "mAP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x,K) which \n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    weights: have shape (K,)\n    \n    return: mean average precision (mAP).\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "ap_all", "=", "AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", "\n", "return", "np", ".", "mean", "(", "ap_all", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.return_all_metrics": [[272, 389], ["numpy.sort", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.max", "numpy.uint16", "numpy.uint16", "evaluate.is_multilabel", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "print", "numpy.array", "weights.flatten.flatten", "numpy.sum", "collections.Counter", "numpy.argsort", "numpy.sum", "len", "numpy.cumsum", "len", "len", "len", "numpy.abs", "numpy.sum", "numpy.where", "numpy.sum", "numpy.arange", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "def", "return_all_metrics", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "M_set", ",", "weights", "=", "None", ",", "\n", "num_return_NN", "=", "None", ",", "Radius", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    This function is useful for large datasets as it computes hamming distance \n        between train data and query only once (instead of computing it for each\n        metric seperately).\n    \n    It returns:\n      1- Mean average precision (mAP) \n      2- Precision and recall for each member of (sorted) M_set\n      3- Precision @ Radius=Radius if radius is not None\n    \n    x_train and x_test are of boolean type and have shape (x,K) which\n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    M_set contains the (sorted) points in which precision and recall are \n        computed. In other words, if m be the member of M_set, precision@m and\n        recall@m are computed after retrieving m nearest neighbors to the query. \n    weights: have shape (K,)\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    Radius is the radius of hamming ball for search.\n\n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "if", "(", "weights", "is", "not", "None", ")", "and", "(", "Radius", "is", "not", "None", ")", ":", "\n", "        ", "print", "(", "'You cannot specify \"weights\" argument when you want to compute \\\n              the radious-based percision'", ")", "\n", "return", "None", "\n", "\n", "", "if", "num_return_NN", "is", "None", ":", "\n", "        ", "num_return_NN", "=", "x_train", ".", "shape", "[", "0", "]", "\n", "\n", "", "M_set", "=", "np", ".", "sort", "(", "np", ".", "array", "(", "M_set", ",", "dtype", "=", "np", ".", "uint", ")", ")", "\n", "n_test", "=", "x_test", ".", "shape", "[", "0", "]", "\n", "K", "=", "x_train", ".", "shape", "[", "1", "]", "# number of bits", "\n", "precision", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "recall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", "len", "(", "M_set", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "APall", "=", "np", ".", "zeros", "(", "(", "n_test", ",", ")", ")", "\n", "precision_R", "=", "np", ".", "zeros", "(", "(", "n_test", ")", ",", "dtype", "=", "'float32'", ")", "\n", "M", "=", "np", ".", "max", "(", "M_set", ")", "\n", "x_train", "=", "np", ".", "uint16", "(", "x_train", ")", "# convert boolean type to uint", "\n", "x_test", "=", "np", ".", "uint16", "(", "x_test", ")", "\n", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "1", "\n", "normalization_term", "=", "K", "\n", "", "else", ":", "\n", "        ", "weights", "=", "weights", ".", "flatten", "(", ")", "\n", "assert", "(", "len", "(", "weights", ")", "==", "K", ")", "\n", "normalization_term", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "weights", ")", ")", "\n", "\n", "# compute precision and recall for each query", "\n", "", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "if", "is_multi_label", "==", "False", ":", "\n", "        ", "real_pos_per_class", "=", "Counter", "(", "y_train", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_test", ")", ":", "\n", "# hamming distance between train_data and the query", "\n", "        ", "hamm_dist", "=", "normalization_term", "-", "(", "x_train", "@", "(", "x_test", "[", "i", ",", "]", "*", "weights", ")", "+", "(", "1", "-", "x_train", ")", "@", "(", "(", "1", "-", "x_test", "[", "i", ",", "]", ")", "*", "weights", ")", ")", "\n", "# top (nearset) M neighbors to the query", "\n", "arg_dist", "=", "np", ".", "argsort", "(", "hamm_dist", ")", "\n", "arg_dist_PR", "=", "arg_dist", "[", ":", "M", "]", "\n", "arg_dist_mAP", "=", "arg_dist", "[", ":", "num_return_NN", "]", "\n", "idx_radius", "=", "hamm_dist", "<=", "Radius", "\n", "m_radius", "=", "np", ".", "sum", "(", "idx_radius", ")", "\n", "y_train_radius", "=", "y_train", "[", "idx_radius", "]", "\n", "\n", "if", "is_multi_label", ":", "# multi-label case", "\n", "### for multi-label case, We define the true neighbors of a query ", "\n", "### as the images sharing at least one labels with the query image.", "\n", "            ", "is_correct", "=", "(", "y_train", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "total_Positives", "=", "np", ".", "sum", "(", "is_correct", ")", "# used for recall computation", "\n", "is_correct_PR", "=", "is_correct", "[", "arg_dist_PR", "]", "\n", "is_correct_mAP", "=", "is_correct", "[", "arg_dist_mAP", "]", "\n", "is_correct_radius", "=", "(", "y_train_radius", "@", "y_test", "[", "i", ",", ":", "]", ".", "T", ")", ">", "0", "\n", "", "else", ":", "# multi-class case", "\n", "            ", "q_label", "=", "y_test", "[", "i", "]", "# query label   ", "\n", "is_correct_PR", "=", "(", "q_label", "==", "y_train", "[", "arg_dist_PR", "]", ")", "\n", "is_correct_mAP", "=", "(", "q_label", "==", "y_train", "[", "arg_dist_mAP", "]", ")", "\n", "is_correct_radius", "=", "(", "q_label", "==", "y_train_radius", ")", "\n", "total_Positives", "=", "real_pos_per_class", "[", "q_label", "]", "\n", "\n", "# compute AP for each query", "\n", "", "TP_loc", "=", "np", ".", "where", "(", "is_correct_mAP", ")", "[", "0", "]", "\n", "n_TP", "=", "len", "(", "TP_loc", ")", "# total number of true positives in num_return_NN", "\n", "if", "n_TP", "!=", "0", ":", "\n", "# calculate precisions only at the true positive locations", "\n", "            ", "precisions", "=", "(", "np", ".", "arange", "(", "1", ",", "n_TP", "+", "1", ")", ")", "/", "(", "TP_loc", "+", "1", ")", "\n", "APall", "[", "i", "]", "=", "np", ".", "sum", "(", "precisions", ")", "/", "n_TP", "\n", "\n", "# compute precision and recall for each m", "\n", "", "is_correct_sum", "=", "np", ".", "cumsum", "(", "is_correct_PR", ")", "\n", "TP", "=", "is_correct_sum", "[", "M_set", "-", "1", "]", "# true positives", "\n", "precision", "[", "i", ",", ":", "]", "=", "TP", "/", "M_set", "\n", "recall", "[", "i", ",", ":", "]", "=", "TP", "/", "total_Positives", "\n", "\n", "# compute precision_radius", "\n", "if", "(", "m_radius", "!=", "0", ")", "and", "(", "Radius", "is", "not", "None", ")", ":", "\n", "# compute precision for images in radius of Radius", "\n", "            ", "TP", "=", "np", ".", "sum", "(", "is_correct_radius", ")", "# true positives", "\n", "precision_R", "[", "i", "]", "=", "TP", "/", "m_radius", "\n", "\n", "# compute average precision and recall", "\n", "", "", "precision", "=", "np", ".", "mean", "(", "precision", ",", "axis", "=", "0", ")", "\n", "recall", "=", "np", ".", "mean", "(", "recall", ",", "axis", "=", "0", ")", "\n", "precision_R", "=", "np", ".", "mean", "(", "precision_R", ",", "axis", "=", "0", ")", "\n", "\n", "# compute mAP", "\n", "mAP", "=", "np", ".", "mean", "(", "APall", ")", "\n", "\n", "if", "Radius", "is", "None", ":", "\n", "        ", "return", "mAP", ",", "precision", ",", "recall", "\n", "", "else", ":", "\n", "        ", "return", "mAP", ",", "precision", ",", "recall", ",", "precision_R", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.Macro_AP": [[391, 427], ["evaluate.AP", "evaluate.is_multilabel", "numpy.unique", "len", "numpy.zeros", "range", "numpy.mean", "len", "y_train.flatten", "y_test.flatten", "numpy.all", "numpy.sum", "print", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.AP", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.evaluate.is_multilabel"], ["", "", "def", "Macro_AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "None", ",", "weights", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    x_train and x_test are of boolean type and have shape (x,K) which \n        x is number of observations and K is the number of bits.\n    y_train and y_test have shape (x,) which x is number of observations. These\n        two vectors contain labels. They can also be matrices (in one-hot or \n        multi-label case).\n    num_return_NN: only compute mAP on returned top num_return_NN neighbours.\n    weights: have shape (K,)\n    \n    return: Macro average precision (MacroAP)\n    \n    Note: x_train and x_test must have (0,1) values not (-1,1) values.\n    \"\"\"", "\n", "ap_all", "=", "AP", "(", "x_train", ",", "y_train", ",", "x_test", ",", "y_test", ",", "num_return_NN", "=", "num_return_NN", ",", "\n", "weights", "=", "weights", ")", "\n", "\n", "is_multi_label", "=", "is_multilabel", "(", "y_train", ")", "\n", "if", "is_multi_label", "==", "False", "and", "len", "(", "y_train", ".", "shape", ")", ">", "1", ":", "\n", "        ", "y_train", ",", "y_test", "=", "y_train", ".", "flatten", "(", ")", ",", "y_test", ".", "flatten", "(", ")", "\n", "", "unique_labels", "=", "np", ".", "unique", "(", "y_train", ",", "axis", "=", "0", ")", "\n", "numclas", "=", "len", "(", "unique_labels", ")", "\n", "class_AP", "=", "np", ".", "zeros", "(", "(", "numclas", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "numclas", ")", ":", "\n", "        ", "if", "is_multi_label", ":", "\n", "            ", "index", "=", "np", ".", "all", "(", "unique_labels", "[", "i", "]", "==", "y_test", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "index", "=", "(", "unique_labels", "[", "i", "]", "==", "y_test", ")", "\n", "", "if", "np", ".", "sum", "(", "index", ")", "==", "0", ":", "\n", "            ", "class_AP", "[", "i", "]", "=", "-", "1", "\n", "print", "(", "f\"there is no test sample with label={unique_labels[i]}\"", ")", "\n", "", "else", ":", "\n", "            ", "class_AP", "[", "i", "]", "=", "np", ".", "sum", "(", "ap_all", "[", "index", "]", ")", "/", "np", ".", "sum", "(", "index", ")", "\n", "\n", "", "", "return", "np", ".", "mean", "(", "class_AP", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode": [[6, 15], ["len", "numpy.unique", "numpy.eye"], "function", ["None"], ["def", "one_hot_encode", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    One hot encodes a list of sample labels. Return a one-hot encoded vector \n        for each label.\n    : x: List of sample Labels\n    : return: Numpy array of one-hot encoded labels\n     \"\"\"", "\n", "n_classes", "=", "len", "(", "np", ".", "unique", "(", "x", ")", ")", "\n", "return", "np", ".", "eye", "(", "n_classes", ")", "[", "x", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.normalize_Z": [[17, 21], ["numpy.diag", "numpy.sqrt", "numpy.sum"], "function", ["None"], ["", "def", "normalize_Z", "(", "Z", ")", ":", "\n", "    ", "D", "=", "np", ".", "diag", "(", "1", "/", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "Z", ",", "axis", "=", "0", ")", ")", ")", "\n", "Z_normalized", "=", "Z", "@", "D", "\n", "return", "Z_normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.RRC": [[24, 50], ["utilities.one_hot_encode", "numpy.linalg.inv", "numpy.linalg.inv", "len", "tr_labels.flatten", "numpy.eye", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["", "def", "RRC", "(", "tr_data", ",", "tr_labels", ",", "lambda_", ",", "testing", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    tr_data: train data. Shape must be (n_samples,n_features)\n    tr_labels: train labels. Shape must be (n_samples,), or (n_samples,1), or \n        (n_samples,n_classes)\n    returns projection matrix\n    \"\"\"", "\n", "\n", "n_samples", ",", "n_features", "=", "tr_data", ".", "shape", "\n", "\n", "# projection matrix computing", "\n", "if", "n_samples", "<", "n_features", ":", "\n", "        ", "Proj_M", "=", "tr_data", ".", "T", "@", "(", "inv", "(", "tr_data", "@", "tr_data", ".", "T", "+", "lambda_", "*", "np", ".", "eye", "(", "n_samples", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "Proj_M", "=", "(", "inv", "(", "tr_data", ".", "T", "@", "tr_data", "+", "lambda_", "*", "np", ".", "eye", "(", "n_features", ")", ")", ")", "@", "tr_data", ".", "T", "\n", "\n", "# label matrix", "\n", "", "if", "len", "(", "tr_labels", ".", "shape", ")", "<", "2", "or", "tr_labels", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "# One-hot coding (only use it for multi-class (single-label) classification)", "\n", "        ", "Y", "=", "one_hot_encode", "(", "tr_labels", ".", "flatten", "(", ")", ")", "\n", "", "else", ":", "\n", "        ", "Y", "=", "tr_labels", "\n", "\n", "", "W", "=", "Proj_M", "@", "Y", "\n", "\n", "return", "W", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.to_Z": [[52, 106], ["numpy.zeros", "numpy.float32", "numpy.zeros", "numpy.zeros", "range", "numpy.exp", "range", "len", "scipy.spatial.distance.cdist", "numpy.argmin", "numpy.mean", "numpy.sum", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["None"], ["", "def", "to_Z", "(", "inputs", ",", "anchors", ",", "Z_spec", ")", ":", "\n", "    ", "\"\"\" \n    This function handles data-to-anchor mapping of inputs data. In other \n    words, the inputs representation is mapped to anchor-based representation.\n    Inputs:\n        inputs: input samples. Shape is (N, n_features) which N is the number of\n                inputs samples.\n        anchors: anchor points. shape is (n_anchors, n_features).\n        Z_spec: a dictionary that specifies how to compute Z. Keys should be\n                'n_anchors', 's', 'sigma', and 'metric'. \n                n_anchors: Number of anchors to compute (sparse) affinity matrix\n                s: number of selection for nearest anchors\n                metric: Distance metric used for computing affinity matrix\n                        It is used in cdist function\n                sigma: bandwitch to normalize distances\n                \n    Output:\n        Z: anchor-based represntation of inputs samples. shape is (N,n_anchors)\n    \"\"\"", "\n", "if", "len", "(", "inputs", ".", "shape", ")", "==", "1", ":", "\n", "        ", "N", "=", "1", "\n", "inputs", "=", "inputs", "[", "None", "]", "\n", "", "else", ":", "\n", "        ", "N", "=", "inputs", ".", "shape", "[", "0", "]", "\n", "\n", "", "n_anchors", "=", "anchors", ".", "shape", "[", "0", "]", "\n", "assert", "Z_spec", "[", "'n_anchors'", "]", "==", "n_anchors", "\n", "s", "=", "Z_spec", "[", "'s'", "]", "\n", "sigma", "=", "Z_spec", "[", "'sigma'", "]", "\n", "Z", "=", "np", ".", "zeros", "(", "(", "N", ",", "n_anchors", ")", ",", "dtype", "=", "'float32'", ")", "# the truncated similarities", "\n", "Dis", "=", "np", ".", "float32", "(", "cdist", "(", "inputs", ",", "anchors", ",", "metric", "=", "Z_spec", "[", "'metric'", "]", ")", ")", "\n", "\n", "# select s nearest neighbors of each example", "\n", "min_val", "=", "np", ".", "zeros", "(", "(", "N", ",", "s", ")", ",", "dtype", "=", "'float32'", ")", "\n", "min_pos", "=", "np", ".", "zeros", "(", "(", "N", ",", "s", ")", ",", "dtype", "=", "'int'", ")", "\n", "\n", "for", "i", "in", "range", "(", "s", ")", ":", "\n", "        ", "min_pos", "[", ":", ",", "i", "]", "=", "np", ".", "argmin", "(", "Dis", ",", "axis", "=", "1", ")", "\n", "min_val", "[", ":", ",", "i", "]", "=", "Dis", "[", "np", ".", "arange", "(", "N", ")", ",", "min_pos", "[", ":", ",", "i", "]", "]", "\n", "Dis", "[", "np", ".", "arange", "(", "N", ")", ",", "min_pos", "[", ":", ",", "i", "]", "]", "=", "np", ".", "inf", "\n", "\n", "", "del", "Dis", "\n", "\n", "if", "sigma", "is", "None", ":", "\n", "        ", "sigma", "=", "np", ".", "mean", "(", "min_val", "[", ":", ",", "-", "1", "]", ")", "\n", "\n", "", "min_val", "=", "np", ".", "exp", "(", "-", "(", "(", "min_val", "/", "sigma", ")", "**", "2", ")", ")", "\n", "min_val", "=", "min_val", "/", "np", ".", "sum", "(", "min_val", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "\n", "# fill Z matrix", "\n", "for", "i", "in", "range", "(", "s", ")", ":", "\n", "        ", "Z", "[", "np", ".", "arange", "(", "N", ")", ",", "min_pos", "[", ":", ",", "i", "]", "]", "=", "min_val", "[", ":", ",", "i", "]", "\n", "\n", "", "return", "Z", "", "", ""]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Affinity_matrix.Affinity": [[7, 35], ["numpy.random.RandomState", "utilities.to_Z", "init.lower", "init.lower", "sklearn.cluster.KMeans().fit", "ValueError", "np.random.RandomState.choice", "sklearn.cluster.KMeans"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.to_Z"], ["def", "Affinity", "(", "train_data", ",", "Z_spec", ",", "random_state", "=", "42", ",", "init", "=", "'random'", ")", ":", "\n", "    ", "\"\"\"\n    inputs:\n        train_data shape is (n_samples,n_features)\n        Z_spec: a dictionary that specifies how to compute Z. Keys should be\n                'n_anchors', 's', 'sigma', and 'metric'\n        random_state: Must be integer\n        init: method of anchor initialization. Can be 'random' or 'kmeans'\n    outputs: \n        Z: data-to-anchor mapping of train data. shape is (n_samples, n_anchors)\n        anchors: anchor points. shape is (n_anchors, n_features)\n    \"\"\"", "\n", "\n", "N", "=", "train_data", ".", "shape", "[", "0", "]", "# number of samples", "\n", "n_anchors", "=", "Z_spec", "[", "'n_anchors'", "]", "\n", "R", "=", "np", ".", "random", ".", "RandomState", "(", "random_state", ")", "\n", "if", "init", ".", "lower", "(", ")", "==", "'random'", ":", "\n", "        ", "anchors", "=", "train_data", "[", "R", ".", "choice", "(", "N", ",", "size", "=", "n_anchors", ",", "replace", "=", "False", ")", ",", ":", "]", "\n", "", "elif", "init", ".", "lower", "(", ")", "==", "'kmeans'", ":", "\n", "        ", "kmeans", "=", "KMeans", "(", "n_clusters", "=", "n_anchors", ",", "max_iter", "=", "10", ",", "n_init", "=", "1", ",", "\n", "random_state", "=", "random_state", ")", ".", "fit", "(", "train_data", ")", "\n", "anchors", "=", "kmeans", ".", "cluster_centers_", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'init must be \"random\" or \"kmeans\"'", ")", "\n", "\n", "", "Z", "=", "to_Z", "(", "train_data", ",", "anchors", ",", "Z_spec", ")", "\n", "\n", "return", "Z", ",", "anchors", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.get_feature_affinity": [[17, 22], ["utilities.normalize_Z"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.normalize_Z"], ["def", "get_feature_affinity", "(", "train_features", ",", "Z", ")", ":", "\n", "    ", "Z", "=", "normalize_Z", "(", "Z", ")", "\n", "L", "=", "train_features", ".", "T", "@", "Z", "\n", "Affinity", "=", "L", "@", "L", ".", "T", "\n", "return", "Affinity", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.initialize_W": [[24, 31], ["scipy.sparse.linalg.eigsh", "tensorflow.Variable", "tensorflow.Variable"], "function", ["None"], ["", "def", "initialize_W", "(", "W", "=", "None", ",", "Affinity", "=", "None", ",", "K", "=", "16", ")", ":", "\n", "    ", "if", "W", "is", "None", ":", "\n", "        ", "eig_val", ",", "eig_vec", "=", "eigsh", "(", "Affinity", ",", "k", "=", "K", ",", "which", "=", "'LA'", ")", "\n", "W", "=", "tf", ".", "Variable", "(", "eig_vec", ",", "dtype", "=", "tf", ".", "float32", ",", "name", "=", "\"W\"", ")", "\n", "", "else", ":", "\n", "        ", "W", "=", "tf", ".", "Variable", "(", "W", ",", "dtype", "=", "tf", ".", "float32", ",", "name", "=", "\"W\"", ")", "\n", "", "return", "W", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.cost_fn": [[33, 41], ["matmul", "tensorflow.math.square", "trace", "tensorflow.norm", "matmul", "tensorflow.math.subtract", "tensorflow.transpose", "matmul", "tensorflow.math.abs"], "function", ["None"], ["", "def", "cost_fn", "(", "train_features", ",", "W", ",", "Affinity", ",", "alpha", "=", "1", ")", ":", "\n", "    ", "main_cost", "=", "-", "1", "*", "trace", "(", "matmul", "(", "tf", ".", "transpose", "(", "W", ")", ",", "matmul", "(", "Affinity", ",", "W", ")", ")", ")", "\n", "projected_values", "=", "matmul", "(", "train_features", ",", "W", ")", "\n", "#ones1 = tf.ones((train_features.shape[0], W.shape[1]), dtype=np.float32)", "\n", "reg", "=", "tf", ".", "math", ".", "square", "(", "tf", ".", "norm", "(", "tf", ".", "math", ".", "subtract", "(", "tf", ".", "math", ".", "abs", "(", "projected_values", ")", ",", "\n", "1", ")", ",", "ord", "=", "'fro'", ",", "axis", "=", "[", "0", ",", "1", "]", ")", ")", "\n", "cost", "=", "(", "main_cost", "+", "0.5", "*", "alpha", "*", "reg", ")", "/", "train_features", ".", "shape", "[", "0", "]", "\n", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.compute_alpha": [[43, 50], ["matmul", "tensorflow.math.square", "tensorflow.math.abs", "trace", "tensorflow.norm", "matmul", "tensorflow.math.subtract", "tensorflow.transpose", "matmul", "tensorflow.math.abs"], "function", ["None"], ["", "def", "compute_alpha", "(", "train_features", ",", "W", ",", "Affinity", ")", ":", "\n", "    ", "main_cost", "=", "-", "1", "*", "trace", "(", "matmul", "(", "tf", ".", "transpose", "(", "W", ")", ",", "matmul", "(", "Affinity", ",", "W", ")", ")", ")", "\n", "projected_values", "=", "matmul", "(", "train_features", ",", "W", ")", "\n", "reg", "=", "tf", ".", "math", ".", "square", "(", "tf", ".", "norm", "(", "tf", ".", "math", ".", "subtract", "(", "tf", ".", "math", ".", "abs", "(", "projected_values", ")", ",", "\n", "1", ")", ",", "ord", "=", "'fro'", ",", "axis", "=", "[", "0", ",", "1", "]", ")", ")", "\n", "alpha", "=", "tf", ".", "math", ".", "abs", "(", "2", "*", "main_cost", "/", "reg", ")", "\n", "return", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.ESH_projected_grad": [[52, 106], ["Efficient_SH.get_feature_affinity", "Efficient_SH.initialize_W", "tensorflow.constant", "tensorflow.constant", "numpy.zeros", "tensorflow.keras.optimizers.SGD", "range", "Efficient_SH.compute_alpha", "print", "tape.gradient", "tf.keras.optimizers.SGD.apply_gradients", "svd", "initialize_W.assign", "initialize_W.numpy", "tensorflow.GradientTape", "Efficient_SH.cost_fn", "cost_fn.numpy", "zip", "matmul", "print", "tensorflow.transpose", "numpy.abs", "print"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.get_feature_affinity", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.initialize_W", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.compute_alpha", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Efficient_SH.cost_fn"], ["", "def", "ESH_projected_grad", "(", "train_features", ",", "Z", ",", "K", "=", "16", ",", "alpha", "=", "None", ",", "lr", "=", "0.01", ",", "\n", "maxiter", "=", "10000", ",", "W", "=", "None", ")", ":", "\n", "    ", "\"\"\" Efficient Spectral hashing using projected gradient solver\n    train_features: shape is (n_samples,n_features)\n    Z: data-to-anchor mapping of train data. shape is (n_samples, n_anchors)\n    K: Number of bits for each binary code\n    alpha: the regularization coefficient for binary constraint. If None,\n        compute_alpha function is used.\n    lr: learning rate for gradient descent\n    maxiter: maximum number of iterations used for ESH solver\n    W: the initialization matrix used for hash functions. If None, eigenvectors\n        of feature affinity matrix is used as initialization of W. \n    \n    Output: \n        W: The learned hash functions. It has shape (n_features,K)\n        cost_values: cost values until last convergence\n    \"\"\"", "\n", "# compute feature affinity", "\n", "Affinity", "=", "get_feature_affinity", "(", "train_features", ",", "Z", ")", "\n", "# initialize W", "\n", "W", "=", "initialize_W", "(", "W", "=", "W", ",", "Affinity", "=", "Affinity", ",", "K", "=", "K", ")", "\n", "# setting constants", "\n", "Affinity", "=", "tf", ".", "constant", "(", "Affinity", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "train_features", "=", "tf", ".", "constant", "(", "train_features", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "cost_values", "=", "np", ".", "zeros", "(", "(", "maxiter", ",", ")", ")", "\n", "optimizer", "=", "tf", ".", "keras", ".", "optimizers", ".", "SGD", "(", "lr", "=", "lr", ")", "\n", "if", "alpha", "is", "None", ":", "\n", "        ", "alpha", "=", "compute_alpha", "(", "train_features", ",", "W", ",", "Affinity", ")", "\n", "print", "(", "f\"alpha={alpha} is selected\"", ")", "\n", "\n", "# main loop", "\n", "", "for", "it", "in", "range", "(", "maxiter", ")", ":", "\n", "        ", "with", "tf", ".", "GradientTape", "(", "persistent", "=", "True", ")", "as", "tape", ":", "\n", "# define cost", "\n", "            ", "cost", "=", "cost_fn", "(", "train_features", ",", "W", ",", "Affinity", ",", "alpha", "=", "alpha", ")", "\n", "cost_values", "[", "it", "]", "=", "cost", ".", "numpy", "(", ")", "\n", "# compute gradient", "\n", "", "grad", "=", "tape", ".", "gradient", "(", "cost", ",", "W", ")", "\n", "del", "tape", "\n", "# apply optimizer", "\n", "optimizer", ".", "apply_gradients", "(", "zip", "(", "[", "grad", "]", ",", "[", "W", "]", ")", ")", "\n", "# apply projection", "\n", "diag_mat", ",", "U", ",", "V", "=", "svd", "(", "W", ",", "full_matrices", "=", "False", ")", "\n", "W", ".", "assign", "(", "matmul", "(", "U", ",", "tf", ".", "transpose", "(", "V", ")", ")", ",", "read_value", "=", "False", ")", "\n", "# print cost", "\n", "if", "(", "it", "+", "1", ")", "%", "50", "==", "0", ":", "\n", "            ", "print", "(", "f'cost value after {it+1} iterations: {cost_values[it]}'", ")", "\n", "# convergence check", "\n", "", "if", "it", "%", "10", "==", "0", "and", "it", ">", "0", ":", "\n", "            ", "convg_check", "=", "(", "cost_values", "[", "it", "]", "-", "cost_values", "[", "it", "-", "10", "]", ")", "/", "cost_values", "[", "it", "-", "10", "]", "\n", "if", "np", ".", "abs", "(", "convg_check", ")", "<", "1e-4", ":", "\n", "                ", "print", "(", "f\"The problem converged after {it+1} iteration\"", ")", "\n", "break", "\n", "", "", "", "return", "W", ".", "numpy", "(", ")", ",", "cost_values", "[", ":", "it", "+", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Datasets.cifar10_vggfc7": [[9, 30], ["os.path.join", "os.path.join", "scipy.io.loadmat", "scipy.io.loadmat", "utilities.one_hot_encode", "utilities.one_hot_encode"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["def", "cifar10_vggfc7", "(", "path", ",", "one_hot", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing cifar10_vggfc7 features\n        one_hot: If True, return one hoted labels.\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "train_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'cifar10_vggfc7_train.mat'", ")", "\n", "test_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'cifar10_vggfc7_test.mat'", ")", "\n", "\n", "train_dict", "=", "loadmat", "(", "train_path", ",", "squeeze_me", "=", "True", ")", "\n", "test_dict", "=", "loadmat", "(", "test_path", ",", "squeeze_me", "=", "True", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "train_dict", "[", "'train_features'", "]", ",", "train_dict", "[", "'train_labels'", "]", "\n", "test_features", ",", "test_labels", "=", "test_dict", "[", "'test_features'", "]", ",", "test_dict", "[", "'test_labels'", "]", "\n", "\n", "if", "one_hot", ":", "\n", "        ", "train_labels", ",", "test_labels", "=", "one_hot_encode", "(", "train_labels", ")", ",", "one_hot_encode", "(", "test_labels", ")", "\n", "\n", "", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Datasets.labelme_vggfc7": [[32, 53], ["os.path.join", "os.path.join", "scipy.io.loadmat", "scipy.io.loadmat", "utilities.one_hot_encode", "utilities.one_hot_encode"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["", "def", "labelme_vggfc7", "(", "path", ",", "one_hot", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing labelme_vggfc7 features\n        one_hot: If True, return one hoted labels.\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "train_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'labelme_vggfc7_train.mat'", ")", "\n", "test_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'labelme_vggfc7_test.mat'", ")", "\n", "\n", "train_dict", "=", "loadmat", "(", "train_path", ",", "squeeze_me", "=", "True", ")", "\n", "test_dict", "=", "loadmat", "(", "test_path", ",", "squeeze_me", "=", "True", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "train_dict", "[", "'train_features'", "]", ",", "train_dict", "[", "'train_labels'", "]", "\n", "test_features", ",", "test_labels", "=", "test_dict", "[", "'test_features'", "]", ",", "test_dict", "[", "'test_labels'", "]", "\n", "\n", "if", "one_hot", ":", "\n", "        ", "train_labels", ",", "test_labels", "=", "one_hot_encode", "(", "train_labels", ")", ",", "one_hot_encode", "(", "test_labels", ")", "\n", "\n", "", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Datasets.nuswide_vgg": [[55, 70], ["os.path.join", "numpy.load().item", "numpy.load"], "function", ["None"], ["", "def", "nuswide_vgg", "(", "path", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing nuswide_vgg features (with global avg pooling)\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'deep_features_global_AVG_POOL.npy'", ")", "\n", "\n", "data", "=", "np", ".", "load", "(", "path", ",", "allow_pickle", "=", "True", ")", ".", "item", "(", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "data", "[", "'x_train'", "]", ",", "data", "[", "'y_train'", "]", "\n", "test_features", ",", "test_labels", "=", "data", "[", "'x_test'", "]", ",", "data", "[", "'y_test'", "]", "\n", "\n", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Datasets.colorectal_eff": [[72, 90], ["os.path.join", "numpy.load().item", "numpy.load", "utilities.one_hot_encode", "utilities.one_hot_encode"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.one_hot_encode"], ["", "def", "colorectal_eff", "(", "path", ",", "one_hot", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Inputs:\n        path: The path containing EfficientNet features of colorectal dataset\n    Outputs:\n        train features, train labels, test features, and test labels.    \n    \"\"\"", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "'eff_net_colorectal_deep_features_no_tuning.npy'", ")", "\n", "\n", "data", "=", "np", ".", "load", "(", "path", ",", "allow_pickle", "=", "True", ")", ".", "item", "(", ")", "\n", "\n", "train_features", ",", "train_labels", "=", "data", "[", "'x_train'", "]", ",", "data", "[", "'y_train'", "]", "\n", "test_features", ",", "test_labels", "=", "data", "[", "'x_test'", "]", ",", "data", "[", "'y_test'", "]", "\n", "\n", "if", "one_hot", ":", "\n", "        ", "train_labels", ",", "test_labels", "=", "one_hot_encode", "(", "train_labels", ")", ",", "one_hot_encode", "(", "test_labels", ")", "\n", "\n", "", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.Datasets.load_dataset": [[99, 111], ["dataset_loader", "name.lower"], "function", ["None"], ["def", "load_dataset", "(", "name", ",", "path", "=", "'.'", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    the name of dataset. It can be one of 'cifar10_vggfc7', \n        nuswide_vgg, labelme_vggfc7, colorectal_efficientnet\n    path: the path containing dataset files (Do not include the filenames of \n        dataset)\n    **kwargs are passed to the function that loads name dataset.\n    \"\"\"", "\n", "dataset_loader", "=", "Dataset_maps", "[", "name", ".", "lower", "(", ")", "]", "\n", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "=", "dataset_loader", "(", "\n", "path", ",", "**", "kwargs", ")", "\n", "return", "train_features", ",", "train_labels", ",", "test_features", ",", "test_labels", "\n", "", ""]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.out_of_sample.projection_matrix": [[9, 27], ["numpy.array", "numpy.diag", "np.diag.flatten", "numpy.sum"], "function", ["None"], ["def", "projection_matrix", "(", "B", ",", "Z", ")", ":", "\n", "    ", "\"\"\"\n    Projectetion matrix maps anchor-based represntation of samples to binary\n    codes.\n    Inputs:\n        B: binary codes or approximated binary codes (with real values) of\n           training samples. If B is binary, values must be [-1,1].\n           shape of B is (n_samples, K) which K is number of bits.\n        Z: anchor-based represntation of training samples. shape is \n           (n_samples, n_anchors).\n    Output:\n        Projection matrix. Shape is (K, n_anchors).\n    \"\"\"", "\n", "\n", "D", "=", "np", ".", "array", "(", "1", "/", "(", "np", ".", "sum", "(", "Z", ",", "axis", "=", "0", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "D", "=", "np", ".", "diag", "(", "D", ".", "flatten", "(", ")", ")", "\n", "\n", "return", "B", ".", "T", "@", "Z", "@", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.out_of_sample.out_of_sample_binary_codes": [[29, 52], ["out_of_sample.projection_matrix", "utilities.to_Z", "numpy.sign"], "function", ["home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.out_of_sample.projection_matrix", "home.repos.pwc.inspect_result.sobhanhemati_Efficient-Spectral-Hashing-ESH-.ESH_projected.utilities.to_Z"], ["", "def", "out_of_sample_binary_codes", "(", "X_test", ",", "B", ",", "Z_train", ",", "anchors", ",", "Z_spec", ")", ":", "\n", "    ", "\"\"\"\n    This function generates binary code for new (unseen) samples.\n    Ref: Discrete Graph Hashing paper 2014. \n    Inputs:\n        X_test: new samples. shape is (n_test, n_features).\n        B: learned binary codes or approximated binary codes (with real values)\n           of training samples. If B is binary, values must be [-1,1].\n           shape of B is (n_train_samples, K) which K is number of bits.\n        Z_train: anchor-based represntation of training samples. shape is \n           (n_train_samples, n_anchors).\n        anchors: anchor points. shape is (n_anchors, n_features).\n        Z_spec: a dictionary that specifies how to compute Z. Keys should be\n                'n_anchors', 's', 'sigma', and 'metric'.\n    Output:\n        B_test: new binary codes for test samples. shape is (n_test, K), which \n                K is the number of bits.\n    \"\"\"", "\n", "\n", "W", "=", "projection_matrix", "(", "B", ",", "Z_train", ")", "\n", "Z", "=", "to_Z", "(", "X_test", ",", "anchors", ",", "Z_spec", ")", "\n", "B_test", "=", "Z", "@", "W", ".", "T", "\n", "return", "np", ".", "sign", "(", "B_test", ")", "\n", "", ""]]}