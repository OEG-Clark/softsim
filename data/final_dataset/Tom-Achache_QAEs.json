{"home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.__init__": [[42, 82], ["len", "range", "range", "numpy.zeros", "Aer.get_backend", "QNN.QNN.create_circuit", "max", "QNN.QNN.mat_basis.append", "QNN.tensor_Paulis"], "methods", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.create_circuit", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.tensor_Paulis"], ["    ", "def", "__init__", "(", "self", ",", "M", ")", ":", "# M : topology of the network ; e.g. M = [4,2,1,2,4]", "\n", "        ", "self", ".", "M", "=", "M", "\n", "self", ".", "num_layers", "=", "len", "(", "M", ")", "\n", "\n", "# Compute the width of the network (nb of qubits used in subroutine 2)", "\n", "w", "=", "0", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "            ", "w", "=", "max", "(", "w", ",", "self", ".", "M", "[", "i", "]", "+", "self", ".", "M", "[", "i", "+", "1", "]", ")", "\n", "", "self", ".", "W", "=", "w", "# width", "\n", "\n", "self", ".", "num_qubits", "=", "1", "+", "self", ".", "M", "[", "0", "]", "+", "self", ".", "W", "# total nb of qubits required", "\n", "\n", "# Creating K (vector of all coefficients to learn)", "\n", "\n", "# First compute the nb of coeffs needed", "\n", "self", ".", "nb_coeffs", "=", "0", "\n", "\n", "# Create and store the \"basis\" of gates' matrices (all the different tensor products of length M[i-1]+1 of Pauli's)", "\n", "# These basis are then multiplied with coeffs K, summed, and transform in a unitary U = e^{iS} then into a gate", "\n", "self", ".", "mat_basis", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "            ", "self", ".", "nb_coeffs", "+=", "self", ".", "M", "[", "i", "]", "*", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", "\n", "self", ".", "mat_basis", ".", "append", "(", "tensor_Paulis", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "\n", "\n", "# Choose required initialization for K", "\n", "", "self", ".", "K", "=", "np", ".", "zeros", "(", "self", ".", "nb_coeffs", ")", "# initialize at 0", "\n", "#self.K = np.random.rand(self.nb_coeffs)    # initialize with random values in [0,1]", "\n", "\n", "# Choose backend and options", "\n", "self", ".", "backend", "=", "Aer", ".", "get_backend", "(", "'qasm_simulator'", ")", "\n", "self", ".", "backend_options", "=", "{", "'max_parallel_experiments'", ":", "0", ",", "'max_parallel_threads'", ":", "0", "}", "\n", "\n", "# Choose nb of shots (S)", "\n", "self", ".", "shots", "=", "1000", "\n", "\n", "self", ".", "circ", "=", "None", "# record current circuit used", "\n", "self", ".", "show_circ", "=", "None", "# record compiled version of circuit (for plotting purpose)", "\n", "\n", "self", ".", "create_circuit", "(", ")", "# create circuit", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.set_K": [[83, 88], ["QNN.QNN.create_circuit", "len"], "methods", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.create_circuit"], ["", "def", "set_K", "(", "self", ",", "K", ")", ":", "# set pre-learned K", "\n", "        ", "assert", "len", "(", "K", ")", "==", "self", ".", "nb_coeffs", "\n", "self", ".", "K", "=", "K", "\n", "self", ".", "create_circuit", "(", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.subroutine_2": [[89, 117], ["QuantumCircuit", "numpy.array", "range", "range", "list", "range", "QuantumCircuit.reset", "numpy.array", "qiskit.extensions.UnitaryGate", "QuantumCircuit.append", "QuantumCircuit.barrier", "range", "scipy.linalg.expm", "numpy.sum"], "methods", ["None"], ["", "def", "subroutine_2", "(", "self", ")", ":", "\n", "        ", "circ", "=", "QuantumCircuit", "(", "self", ".", "W", ",", "name", "=", "'Quantum AE'", ")", "\n", "\n", "free_qubits", "=", "self", ".", "M", "[", "0", "]", "# will allow to see which qubits are \"free\" for the next layer", "\n", "m_new", "=", "np", ".", "array", "(", "range", "(", "free_qubits", ")", ")", "# m_new is the list of \"free\" qubits", "\n", "\n", "cpt", "=", "0", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "            ", "m_old", "=", "list", "(", "m_new", ")", "# m_old is the list of qubits \"taken\" (i.e. used by the current layer)", "\n", "m_new", "=", "np", ".", "array", "(", "range", "(", "free_qubits", ",", "free_qubits", "+", "self", ".", "M", "[", "i", "]", ")", ")", "%", "self", ".", "W", "\n", "free_qubits", "+=", "self", ".", "M", "[", "i", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "M", "[", "i", "]", ")", ":", "\n", "# Create unitary gates by multipliying K with the basis of gates' matrices", "\n", "# self.mat_basis[i-1] : all the basis matrices for layer i", "\n", "# self.K[j*(4**(self.M[i-1]+1)) + cpt : (j+1)*(4**(self.M[i-1]+1)) + cpt] : relevant coeffs", "\n", "# multiply these 2, sum to get a matrix S, perform e^{iS}, then create the gate", "\n", "\n", "                ", "C_U", "=", "UnitaryGate", "(", "linalg", ".", "expm", "(", "1j", "*", "np", ".", "sum", "(", "self", ".", "mat_basis", "[", "i", "-", "1", "]", "*", "self", ".", "K", "[", "j", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", ":", "(", "j", "+", "1", ")", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", ",", "None", ",", "None", "]", ",", "axis", "=", "0", ")", ")", ")", "\n", "circ", ".", "append", "(", "C_U", ",", "m_old", "+", "[", "m_new", "[", "j", "]", "]", ")", "\n", "\n", "", "cpt", "+=", "self", ".", "M", "[", "i", "]", "*", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", "\n", "\n", "circ", ".", "reset", "(", "m_old", ")", "\n", "if", "i", "<", "self", ".", "num_layers", "-", "1", ":", "# don't put barrier at the end since there will be one already", "\n", "                ", "circ", ".", "barrier", "(", ")", "# if we want to set a barrier between each layer (not really useful) ", "\n", "# if we put barriers be careful as the positions of gates in the fit function will change", "\n", "\n", "", "", "return", "circ", ",", "m_new", "# that way we have the final relevant qubits", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.create_circuit": [[118, 143], ["QuantumCircuit", "QuantumCircuit", "QuantumCircuit", "QuantumCircuit.append", "QuantumCircuit.append", "QuantumCircuit.barrier", "QNN.QNN.subroutine_2", "QuantumCircuit.append", "QuantumCircuit.barrier", "QuantumCircuit.h", "range", "QuantumCircuit.h", "QuantumCircuit.barrier", "QuantumCircuit.measure", "QuantumCircuit.decompose", "QuantumCircuit.to_instruction", "range", "QuantumCircuit.to_instruction", "range", "sub.to_instruction", "range", "QuantumCircuit.cswap"], "methods", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.subroutine_2"], ["", "def", "create_circuit", "(", "self", ")", ":", "# create the circuit corresponding to the network", "\n", "        ", "circ", "=", "QuantumCircuit", "(", "self", ".", "num_qubits", ",", "1", ")", "\n", "\n", "# Initialize empty states preparation", "\n", "input_state", "=", "QuantumCircuit", "(", "self", ".", "M", "[", "0", "]", ",", "name", "=", "'Input State Prep'", ")", "\n", "target_state", "=", "QuantumCircuit", "(", "self", ".", "M", "[", "0", "]", ",", "name", "=", "'Target State Prep'", ")", "\n", "circ", ".", "append", "(", "input_state", ".", "to_instruction", "(", ")", ",", "range", "(", "1", "+", "self", ".", "M", "[", "0", "]", ",", "1", "+", "2", "*", "self", ".", "M", "[", "0", "]", ")", ")", "\n", "circ", ".", "append", "(", "target_state", ".", "to_instruction", "(", ")", ",", "range", "(", "1", ",", "1", "+", "self", ".", "M", "[", "0", "]", ")", ")", "\n", "circ", ".", "barrier", "(", ")", "\n", "\n", "# Subroutine 2", "\n", "sub", ",", "out_qubits", "=", "self", ".", "subroutine_2", "(", ")", "\n", "circ", ".", "append", "(", "sub", ".", "to_instruction", "(", ")", ",", "range", "(", "1", "+", "self", ".", "M", "[", "0", "]", ",", "self", ".", "num_qubits", ")", ")", "\n", "circ", ".", "barrier", "(", ")", "\n", "\n", "# Subroutine 1", "\n", "circ", ".", "h", "(", "0", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "M", "[", "0", "]", ")", ":", "\n", "            ", "circ", ".", "cswap", "(", "0", ",", "k", "+", "1", ",", "1", "+", "self", ".", "M", "[", "0", "]", "+", "out_qubits", "[", "k", "]", ")", "\n", "", "circ", ".", "h", "(", "0", ")", "\n", "\n", "circ", ".", "barrier", "(", ")", "\n", "circ", ".", "measure", "(", "0", ",", "0", ")", "\n", "self", ".", "show_circ", "=", "circ", "\n", "self", ".", "circ", "=", "circ", ".", "decompose", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run": [[144, 148], ["execute().result", "execute", "execute().result.get_counts"], "methods", ["None"], ["", "def", "run", "(", "self", ")", ":", "# run the circuit and output the fidelity", "\n", "        ", "result", "=", "execute", "(", "self", ".", "circ", ",", "self", ".", "backend", ",", "shots", "=", "self", ".", "shots", ")", ".", "result", "(", ")", "\n", "#result = execute(self.circ, self.backend, shots = self.shots, backend_options = self.backend_options).result()", "\n", "return", "(", "2", "*", "result", ".", "get_counts", "(", "0", ")", "[", "'0'", "]", "/", "self", ".", "shots", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run_multiple_circs": [[149, 160], ["len", "execute().result", "numpy.mean", "numpy.array", "execute", "range", "range", "range", "execute().result.get_counts", "execute().result.get_counts"], "methods", ["None"], ["", "def", "run_multiple_circs", "(", "self", ",", "circs", ",", "batch_size", ",", "train", "=", "True", ")", ":", "# run multiple circuits in batches", "\n", "        ", "n", "=", "len", "(", "circs", ")", "\n", "result", "=", "execute", "(", "circs", ",", "self", ".", "backend", ",", "shots", "=", "self", ".", "shots", ")", ".", "result", "(", ")", "\n", "#result = execute(circs, self.backend, shots = self.shots, backend_options = self.backend_options).result()", "\n", "\n", "if", "train", ":", "\n", "            ", "assert", "n", "==", "batch_size", "*", "(", "self", ".", "nb_coeffs", "+", "1", ")", "\n", "return", "np", ".", "mean", "(", "[", "[", "2", "*", "result", ".", "get_counts", "(", "i", "*", "batch_size", "+", "j", ")", "[", "'0'", "]", "/", "self", ".", "shots", "-", "1", "for", "j", "in", "range", "(", "batch_size", ")", "]", "for", "i", "in", "range", "(", "self", ".", "nb_coeffs", "+", "1", ")", "]", ",", "axis", "=", "1", ")", "# nb_coeff + 1 to account for the original cost", "\n", "", "else", ":", "# we're calling this function in the test phase", "\n", "            ", "assert", "n", "==", "batch_size", "\n", "return", "np", ".", "array", "(", "[", "2", "*", "result", ".", "get_counts", "(", "i", ")", "[", "'0'", "]", "/", "self", ".", "shots", "-", "1", "for", "i", "in", "range", "(", "n", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.fit": [[161, 336], ["len", "range", "numpy.zeros", "numpy.zeros", "numpy.zeros", "time.time", "numpy.random.choice", "numpy.zeros", "range", "QNN.QNN.create_circuit", "numpy.random.choice", "C.append", "time.time", "print", "range", "QNN.QNN.run_multiple_circs", "len", "range", "numpy.mean", "C_val.append", "circs.append", "QNN.QNN.run", "range", "test_circs.append", "QNN.QNN.run", "QNN.QNN.run_multiple_circs", "numpy.mean", "numpy.save", "int", "QNN.QNN.circ.copy", "scipy.linalg.expm", "numpy.sqrt", "QNN.QNN.circ.copy", "val_circs.append", "QNN.QNN.run", "QNN.QNN.run_multiple_circs", "numpy.max", "QNN.QNN.circ.copy", "numpy.sum", "circs.append", "QNN.QNN.run", "QNN.QNN.circ.copy"], "methods", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.create_circuit", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run_multiple_circs", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run_multiple_circs", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run_multiple_circs", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run"], ["", "", "def", "fit", "(", "self", ",", "training_states", ",", "nb_epochs", ",", "epsilon", ",", "eta", ",", "batch_size_train", "=", "None", ",", "batch_size_test", "=", "None", ",", "\n", "goal_state", "=", "None", ",", "validation_states", "=", "None", ",", "use_Adam", "=", "False", ",", "use_momentum", "=", "False", ",", "\n", "run_in_batch", "=", "False", ",", "save_best_val_fid", "=", "True", ")", ":", "# train the network", "\n", "# training_states : list of pairs of circuit preparing input/target states", "\n", "# nb_epochs : nb of rounds ", "\n", "# epsilon : step used for the derivative approximation", "\n", "# eta : learning rate", "\n", "# batch_size_train/test : nb of states considered at each epoch for the training/testing at the end", "\n", "# goal_state : the 'goal' state we want, when we use the network as an AE (just to see if the network is improving at every step)", "\n", "# For instance, for the AE considered, the training_states will be pairs of noisy GHZ while the goal state is the true GHZ ", "\n", "# validation_states : states similar to input states (come from same noisy distribution), used for validation", "\n", "# use_Adam/momentum : whether to use Adam gradient ascent or SGD with momentum", "\n", "# run_in_batch : whether to run all the circuits in batches (may speed up computation, but not realistic physically)", "\n", "# save_best_val_fid : whether to save weights corresponding to maximum fidelity on validation states", "\n", "\n", "        ", "if", "validation_states", "is", "not", "None", ":", "\n", "            ", "assert", "goal_state", "is", "not", "None", "# validation states are used with the goal state", "\n", "\n", "", "if", "use_Adam", ":", "# Implement Adam gradient descent (ascent here)", "\n", "            ", "beta_1", "=", "0.9", "\n", "beta_2", "=", "0.999", "\n", "eps", "=", "10", "**", "(", "-", "8", ")", "\n", "t", "=", "0", "\n", "m", "=", "np", ".", "zeros", "(", "self", ".", "nb_coeffs", ")", "\n", "v", "=", "np", ".", "zeros", "(", "self", ".", "nb_coeffs", ")", "\n", "", "if", "use_momentum", ":", "# Use SGD with momentum", "\n", "            ", "velocity", "=", "np", ".", "zeros", "(", "self", ".", "nb_coeffs", ")", "\n", "mu", "=", "0.9", "\n", "\n", "", "N", "=", "len", "(", "training_states", ")", "# nb of training pairs", "\n", "\n", "if", "batch_size_train", "is", "None", ":", "\n", "            ", "batch_size_train", "=", "N", "\n", "\n", "", "C", "=", "[", "]", "# will save the cost (i.e. fidelity) after every epoch", "\n", "C_val", "=", "[", "]", "# same for validation states", "\n", "\n", "for", "epoch", "in", "range", "(", "nb_epochs", ")", ":", "\n", "            ", "start", "=", "time", ".", "time", "(", ")", "\n", "\n", "batch", "=", "np", ".", "random", ".", "choice", "(", "N", ",", "batch_size_train", ",", "replace", "=", "False", ")", "# pick the batch", "\n", "\n", "circs", "=", "[", "]", "# will be used in case run_in_batch = True", "\n", "\n", "cost", "=", "0", "\n", "for", "k", "in", "batch", ":", "# replace the states preparations by the current one", "\n", "# target state is the first gate and input is the second one", "\n", "                ", "self", ".", "circ", ".", "data", "[", "1", "]", "=", "(", "training_states", "[", "k", "]", "[", "0", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "2", "]", ")", "\n", "self", ".", "circ", ".", "data", "[", "0", "]", "=", "(", "training_states", "[", "k", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "if", "run_in_batch", ":", "\n", "                    ", "circs", ".", "append", "(", "self", ".", "circ", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "cost", "+=", "self", ".", "run", "(", ")", "\n", "", "", "cost", "/=", "batch_size_train", "\n", "\n", "delta", "=", "np", ".", "zeros", "(", "self", ".", "nb_coeffs", ")", "\n", "\n", "cpt", "=", "0", "\n", "pos_gate", "=", "0", "# record position of the gate we are currently modifying", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "self", ".", "M", "[", "i", "]", ")", ":", "# nb of unitary gate at that layer", "\n", "                    ", "for", "v", "in", "range", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", ":", "# nb of coeff of each gate of the current layer", "\n", "# K is the vector of all coefficients (i.e. coeffs of all unitary matrices)", "\n", "# K[v + j*(4**(self.M[i-1]+1)) + sum_{s = 1}^{i-1} (self.M[i] * 4**(self.M[i-1]+1))] is the v-th coeff of the j-th Unitary of the i-th layer", "\n", "# Total nb of operations for backprop : nb_coeffs = sum_{i=1}^L M[i] * 4**(M[i-1]+1)", "\n", "                        ", "self", ".", "K", "[", "v", "+", "j", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", "]", "+=", "epsilon", "\n", "\n", "# Instead of updating whole circuit : pop 1 gate then recreate it", "\n", "# j-th gate (from 0 to M[i]-1) of the i-th (from 1 to L-1) layer is at position : j + sum_{s = 1}^{i-1} M[s]", "\n", "# (without resets nor barriers)", "\n", "# We have M[i-1] resets at the end of layer i (from 1 to L-1)", "\n", "# So (without barriers) j-th gate of the i-th layer is at position : j + sum_{s = 1}^{i-1} (M[s]+M[s-1])", "\n", "# Create a counter to record the gate's position : pos_gate = sum_{s = 1}^{i-1} (M[s]+M[s-1])", "\n", "# Add + 2 to the position to account for state preparations", "\n", "# + i for barriers", "\n", "\n", "self", ".", "circ", ".", "data", "[", "j", "+", "pos_gate", "+", "2", "+", "i", "]", "[", "0", "]", ".", "params", "[", "0", "]", "=", "linalg", ".", "expm", "(", "1j", "*", "np", ".", "sum", "(", "self", ".", "mat_basis", "[", "i", "-", "1", "]", "*", "self", ".", "K", "[", "j", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", ":", "(", "j", "+", "1", ")", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", ",", "None", ",", "None", "]", ",", "axis", "=", "0", ")", ")", "\n", "\n", "self", ".", "K", "[", "v", "+", "j", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", "]", "-=", "epsilon", "\n", "\n", "# Compute the new avg cost", "\n", "new_cost", "=", "0", "\n", "for", "k", "in", "batch", ":", "# insert the state preparations, run the network, and delete them", "\n", "                            ", "self", ".", "circ", ".", "data", "[", "1", "]", "=", "(", "training_states", "[", "k", "]", "[", "0", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "2", "]", ")", "\n", "self", ".", "circ", ".", "data", "[", "0", "]", "=", "(", "training_states", "[", "k", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "\n", "if", "run_in_batch", ":", "\n", "                                ", "circs", ".", "append", "(", "self", ".", "circ", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "\n", "                                ", "new_cost", "+=", "self", ".", "run", "(", ")", "\n", "", "", "new_cost", "/=", "batch_size_train", "\n", "\n", "delta", "[", "v", "+", "j", "*", "(", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", ")", "+", "cpt", "]", "=", "(", "new_cost", "-", "cost", ")", "/", "epsilon", "\n", "", "", "cpt", "+=", "self", ".", "M", "[", "i", "]", "*", "4", "**", "(", "self", ".", "M", "[", "i", "-", "1", "]", "+", "1", ")", "\n", "pos_gate", "+=", "self", ".", "M", "[", "i", "]", "+", "self", ".", "M", "[", "i", "-", "1", "]", "\n", "\n", "", "if", "run_in_batch", ":", "\n", "                ", "delta_0", "=", "self", ".", "run_multiple_circs", "(", "circs", ",", "batch_size_train", ")", "\n", "delta", "=", "(", "delta_0", "[", "1", ":", "]", "-", "delta_0", "[", "0", "]", ")", "/", "epsilon", "\n", "\n", "", "if", "use_Adam", ":", "\n", "# Adam update rule", "\n", "                ", "m", "=", "beta_1", "*", "m", "+", "(", "1", "-", "beta_1", ")", "*", "delta", "\n", "v", "=", "beta_2", "*", "v", "+", "(", "1", "-", "beta_2", ")", "*", "(", "delta", "**", "2", ")", "\n", "t", "+=", "1", "\n", "self", ".", "K", "+=", "eta", "*", "(", "m", "/", "(", "1", "-", "beta_1", "**", "t", ")", ")", "/", "(", "np", ".", "sqrt", "(", "v", "/", "(", "1", "-", "beta_2", "**", "t", ")", ")", "+", "eps", ")", "\n", "", "elif", "use_momentum", ":", "\n", "# add momentum", "\n", "                ", "velocity", "=", "mu", "*", "velocity", "+", "eta", "*", "delta", "\n", "self", ".", "K", "+=", "velocity", "\n", "", "else", ":", "\n", "# regular update rule", "\n", "                ", "self", ".", "K", "+=", "eta", "*", "delta", "\n", "\n", "# Now we re-create the circuit --> maybe faster to just re-run subroutine 2 and only replace this part", "\n", "", "self", ".", "create_circuit", "(", ")", "\n", "\n", "if", "batch_size_test", "is", "None", ":", "\n", "                ", "batch_size_test", "=", "N", "\n", "\n", "# Do a final run to compute the new cost (for validation purpose)", "\n", "", "batch_test", "=", "np", ".", "random", ".", "choice", "(", "N", ",", "batch_size_test", ",", "replace", "=", "False", ")", "\n", "final_cost", "=", "0", "\n", "test_circs", "=", "[", "]", "\n", "\n", "if", "validation_states", "is", "not", "None", ":", "\n", "                ", "N_val", "=", "len", "(", "validation_states", ")", "\n", "\n", "", "val_cost", "=", "0", "\n", "val_circs", "=", "[", "]", "\n", "for", "k", "in", "batch_test", ":", "# insert the state preparations, run the network, and delete them", "\n", "                ", "self", ".", "circ", ".", "data", "[", "1", "]", "=", "(", "training_states", "[", "k", "]", "[", "0", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "2", "]", ")", "\n", "if", "goal_state", "is", "not", "None", ":", "\n", "                    ", "self", ".", "circ", ".", "data", "[", "0", "]", "=", "(", "goal_state", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "circ", ".", "data", "[", "0", "]", "=", "(", "training_states", "[", "k", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "", "if", "run_in_batch", ":", "\n", "                    ", "test_circs", ".", "append", "(", "self", ".", "circ", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "final_cost", "+=", "self", ".", "run", "(", ")", "\n", "\n", "", "", "if", "validation_states", "is", "not", "None", ":", "\n", "                ", "for", "k", "in", "range", "(", "N_val", ")", ":", "\n", "                    ", "self", ".", "circ", ".", "data", "[", "1", "]", "=", "(", "validation_states", "[", "k", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "2", "]", ")", "\n", "self", ".", "circ", ".", "data", "[", "0", "]", "=", "(", "goal_state", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "if", "run_in_batch", ":", "\n", "                        ", "val_circs", ".", "append", "(", "self", ".", "circ", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "\n", "                        ", "val_cost", "+=", "self", ".", "run", "(", ")", "\n", "\n", "", "", "", "if", "run_in_batch", ":", "\n", "                ", "final_cost", "=", "np", ".", "mean", "(", "self", ".", "run_multiple_circs", "(", "test_circs", ",", "batch_size_test", ",", "train", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                ", "final_cost", "/=", "batch_size_test", "\n", "", "C", ".", "append", "(", "final_cost", ")", "\n", "\n", "if", "validation_states", "is", "not", "None", ":", "\n", "                ", "if", "run_in_batch", ":", "\n", "                    ", "val_cost", "=", "np", ".", "mean", "(", "self", ".", "run_multiple_circs", "(", "val_circs", ",", "N_val", ",", "train", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                    ", "val_cost", "/=", "N_val", "\n", "", "C_val", ".", "append", "(", "val_cost", ")", "\n", "\n", "if", "save_best_val_fid", "and", "val_cost", "==", "np", ".", "max", "(", "C_val", ")", ":", "# save weights corresponding to best epoch on val set", "\n", "                    ", "np", ".", "save", "(", "'K.npy'", ",", "self", ".", "K", ")", "\n", "\n", "", "", "end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "'Epoch {} | Fidelity : {:.3f} | Validation Fidelity : {:.3f} | Time : {} s.'", ".", "\n", "format", "(", "epoch", "+", "1", ",", "final_cost", ",", "val_cost", ",", "int", "(", "end", "-", "start", ")", ")", ")", "\n", "\n", "#if (epoch + 1) % 10 == 0: # allows to stop simulations without loosing everything if they are too long", "\n", "#   np.save('train_fid.npy', np.array(C))", "\n", "#  np.save('val_fid.npy', np.array(C_val))", "\n", "\n", "", "return", "C", ",", "C_val", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.test": [[337, 355], ["len", "range", "QNN.QNN.run_multiple_circs", "numpy.array", "circs.append", "QNN.QNN.circ.copy", "QNN.QNN.run"], "methods", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run_multiple_circs", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.run"], ["", "def", "test", "(", "self", ",", "test_states", ",", "run_in_batch", "=", "False", ")", ":", "# test the network", "\n", "# test_states : list of pairs of circuit preparing input/target states", "\n", "        ", "N", "=", "len", "(", "test_states", ")", "\n", "\n", "cost", "=", "[", "]", "\n", "circs", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "N", ")", ":", "# insert the state preparations, run the network, and delete them", "\n", "            ", "self", ".", "circ", ".", "data", "[", "1", "]", "=", "(", "test_states", "[", "k", "]", "[", "0", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "1", "]", "[", "2", "]", ")", "\n", "self", ".", "circ", ".", "data", "[", "0", "]", "=", "(", "test_states", "[", "k", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "1", "]", ",", "self", ".", "circ", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "if", "run_in_batch", ":", "\n", "                ", "circs", ".", "append", "(", "self", ".", "circ", ".", "copy", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "cost", "+=", "[", "self", ".", "run", "(", ")", "]", "\n", "", "", "if", "run_in_batch", ":", "\n", "            ", "cost", "=", "self", ".", "run_multiple_circs", "(", "circs", ",", "N", ",", "train", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "cost", "=", "np", ".", "array", "(", "cost", ")", "\n", "", "return", "cost", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.create_Pauli": [[18, 25], ["numpy.eye", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["def", "create_Pauli", "(", ")", ":", "\n", "    ", "I", "=", "np", ".", "eye", "(", "2", ")", "\n", "X", "=", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "[", "1", ",", "0", "]", "]", ")", "\n", "Y", "=", "1j", "*", "np", ".", "array", "(", "[", "[", "0", ",", "-", "1", "]", ",", "[", "1", ",", "0", "]", "]", ")", "\n", "Z", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "-", "1", "]", "]", ")", "\n", "\n", "return", "[", "I", ",", "X", ",", "Y", ",", "Z", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.tensor_Paulis": [[28, 38], ["QNN.create_Pauli", "QNN.tensor_Paulis.get_tensors"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.create_Pauli"], ["", "def", "tensor_Paulis", "(", "m", ")", ":", "\n", "    ", "Pauli", "=", "create_Pauli", "(", ")", "\n", "\n", "def", "get_tensors", "(", "m", ",", "U", ")", ":", "\n", "        ", "if", "m", "==", "0", ":", "\n", "            ", "return", "np", ".", "array", "(", "U", ")", "\n", "", "else", ":", "\n", "            ", "return", "get_tensors", "(", "m", "-", "1", ",", "[", "np", ".", "kron", "(", "u", ",", "P", ")", "for", "u", "in", "U", "for", "P", "in", "Pauli", "]", ")", "\n", "\n", "", "", "return", "get_tensors", "(", "m", ",", "[", "np", ".", "eye", "(", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.State_preparation.state_preparation": [[15, 89], ["QuantumCircuit", "QuantumCircuit.h", "range", "QuantumCircuit.cx", "numpy.random.rand", "QuantumCircuit.h", "range", "QuantumCircuit.cx", "QuantumCircuit.x", "numpy.random.choice", "QuantumCircuit.h", "range", "QuantumCircuit.x", "numpy.arange", "QuantumCircuit.cx", "QuantumCircuit.x", "numpy.random.choice", "numpy.random.choice", "numpy.random.choice", "QuantumCircuit.h", "QuantumCircuit.cx", "range", "ValueError", "QuantumCircuit.x", "QuantumCircuit.y", "numpy.arange", "numpy.arange", "numpy.arange", "QuantumCircuit.x", "QuantumCircuit.cx", "QuantumCircuit.x", "QuantumCircuit.y", "QuantumCircuit.z", "QuantumCircuit.y", "QuantumCircuit.x", "QuantumCircuit.y", "QuantumCircuit.z", "QuantumCircuit.z", "QuantumCircuit.y", "QuantumCircuit.z", "QuantumCircuit.z"], "function", ["None"], ["def", "state_preparation", "(", "m", ",", "name", ",", "p", ")", ":", "\n", "# m : nb of qubits ", "\n", "# name : name of the state we want ", "\n", "# p : proba associated with noise", "\n", "\n", "    ", "circ", "=", "QuantumCircuit", "(", "m", ",", "name", "=", "'State prep'", ")", "\n", "\n", "if", "name", "==", "'GHZ'", ":", "\n", "        ", "circ", ".", "h", "(", "0", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "m", ")", ":", "\n", "            ", "circ", ".", "cx", "(", "0", ",", "k", ")", "\n", "\n", "", "", "elif", "name", "==", "'noisy_GHZ_bitflip'", ":", "\n", "        ", "prob", "=", "np", ".", "random", ".", "rand", "(", "m", ")", "\n", "circ", ".", "h", "(", "0", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "m", ")", ":", "\n", "            ", "circ", ".", "cx", "(", "0", ",", "k", ")", "\n", "if", "prob", "[", "k", "]", "<=", "p", ":", "# flips each bit with proba p", "\n", "                ", "circ", ".", "x", "(", "k", ")", "\n", "", "", "if", "prob", "[", "0", "]", "<=", "p", ":", "\n", "            ", "circ", ".", "x", "(", "0", ")", "\n", "\n", "", "", "elif", "name", "==", "'noisy_GHZ_QDC'", ":", "\n", "        ", "probas", "=", "[", "1", "-", "3", "*", "p", "/", "4", ",", "p", "/", "4", ",", "p", "/", "4", ",", "p", "/", "4", "]", "\n", "gate_inds", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "4", ")", ",", "size", "=", "m", ",", "p", "=", "probas", ")", "\n", "circ", ".", "h", "(", "0", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "m", ")", ":", "\n", "            ", "circ", ".", "cx", "(", "0", ",", "k", ")", "\n", "if", "gate_inds", "[", "k", "]", "==", "1", ":", "\n", "                ", "circ", ".", "x", "(", "k", ")", "\n", "", "elif", "gate_inds", "[", "k", "]", "==", "2", ":", "\n", "                ", "circ", ".", "y", "(", "k", ")", "\n", "", "elif", "gate_inds", "[", "k", "]", "==", "3", ":", "\n", "                ", "circ", ".", "z", "(", "k", ")", "\n", "", "", "if", "gate_inds", "[", "0", "]", "==", "1", ":", "\n", "            ", "circ", ".", "x", "(", "0", ")", "\n", "", "elif", "gate_inds", "[", "0", "]", "==", "2", ":", "\n", "            ", "circ", ".", "y", "(", "0", ")", "\n", "", "elif", "gate_inds", "[", "0", "]", "==", "3", ":", "\n", "            ", "circ", ".", "z", "(", "0", ")", "\n", "\n", "", "", "elif", "name", "==", "'rigged_QDC'", ":", "# QDC where 1st and 2nd qubits have different probas", "\n", "        ", "probas_rigged", "=", "[", "1", "-", "p", ",", "p", "/", "2", ",", "p", "/", "2", ",", "0", "]", "\n", "probas_rigged2", "=", "[", "1", "-", "29", "*", "p", "/", "30", ",", "2", "*", "p", "/", "5", ",", "2", "*", "p", "/", "5", ",", "p", "/", "6", "]", "\n", "probas", "=", "[", "1", "-", "3", "*", "p", "/", "4", ",", "p", "/", "4", ",", "p", "/", "4", ",", "p", "/", "4", "]", "\n", "gate_inds", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "4", ")", ",", "size", "=", "m", "-", "1", ",", "p", "=", "probas", ")", "\n", "gate_inds_r", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "4", ")", ",", "p", "=", "probas_rigged", ")", "\n", "gate_inds_r2", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "4", ")", ",", "p", "=", "probas_rigged2", ")", "\n", "circ", ".", "h", "(", "0", ")", "\n", "circ", ".", "cx", "(", "0", ",", "1", ")", "\n", "if", "gate_inds_r2", "==", "1", ":", "\n", "            ", "circ", ".", "x", "(", "1", ")", "\n", "", "elif", "gate_inds_r2", "==", "2", ":", "\n", "            ", "circ", ".", "y", "(", "1", ")", "\n", "", "elif", "gate_inds_r2", "==", "3", ":", "\n", "            ", "circ", ".", "z", "(", "1", ")", "\n", "", "for", "k", "in", "range", "(", "2", ",", "m", ")", ":", "\n", "            ", "circ", ".", "cx", "(", "0", ",", "k", ")", "\n", "if", "gate_inds", "[", "k", "-", "1", "]", "==", "1", ":", "\n", "                ", "circ", ".", "x", "(", "k", ")", "\n", "", "elif", "gate_inds", "[", "k", "-", "1", "]", "==", "2", ":", "\n", "                ", "circ", ".", "y", "(", "k", ")", "\n", "", "elif", "gate_inds", "[", "k", "-", "1", "]", "==", "3", ":", "\n", "                ", "circ", ".", "z", "(", "k", ")", "\n", "", "", "if", "gate_inds_r", "==", "1", ":", "\n", "            ", "circ", ".", "x", "(", "0", ")", "\n", "", "elif", "gate_inds_r", "==", "2", ":", "\n", "            ", "circ", ".", "y", "(", "0", ")", "\n", "", "elif", "gate_inds_r", "==", "3", ":", "\n", "            ", "circ", ".", "z", "(", "0", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unrecognized name.'", ")", "\n", "\n", "", "return", "circ", "\n", "", ""]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noise_robustness.noise_robustness": [[17, 46], ["numpy.mean", "matplotlib.errorbar", "matplotlib.grid", "matplotlib.axhline", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "numpy.random.normal", "QNN.QNN.set_K", "QNN.QNN.test", "mean.append", "std.append", "test.fidelity", "matplotlib.savefig", "len", "numpy.mean", "numpy.std"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.set_K", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.test", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.fidelity"], ["def", "noise_robustness", "(", "QNN", ",", "K", ",", "test_states", ",", "G", ",", "filename", "=", "None", ")", ":", "\n", "# QNN : QNN to use", "\n", "# K : vector of coefficients for the QNN's matrices", "\n", "# test_states : test states to consider", "\n", "# G : noise range", "\n", "# filename : whether to save figure and figure name", "\n", "\n", "    ", "mean", "=", "[", "]", "\n", "std", "=", "[", "]", "\n", "\n", "for", "g", "in", "G", ":", "\n", "        ", "noise", "=", "np", ".", "random", ".", "normal", "(", "0", ",", "g", ",", "len", "(", "K", ")", ")", "\n", "QNN", ".", "set_K", "(", "K", "+", "noise", ")", "\n", "fid", "=", "QNN", ".", "test", "(", "test_states", ")", "\n", "mean", ".", "append", "(", "np", ".", "mean", "(", "fid", ")", ")", "\n", "std", ".", "append", "(", "np", ".", "std", "(", "fid", ")", ")", "\n", "\n", "", "orig_fid", "=", "np", ".", "mean", "(", "fidelity", "(", "test_states", ")", ")", "# original (noisy) fidelity", "\n", "\n", "plt", ".", "errorbar", "(", "G", ",", "mean", ",", "std", ",", "fmt", "=", "'bo'", ",", "capsize", "=", "5", ",", "mfc", "=", "'white'", ",", "label", "=", "'Denoised fidelity'", ")", "\n", "plt", ".", "grid", "(", "lw", "=", "0.5", ",", "ls", "=", "'dotted'", ")", "\n", "plt", ".", "axhline", "(", "orig_fid", ",", "color", "=", "'black'", ",", "linestyle", "=", "'--'", ",", "linewidth", "=", "0.7", ",", "label", "=", "'Mean original fidelity'", ")", "\n", "plt", ".", "xlabel", "(", "'Standard deviation'", ")", "\n", "plt", ".", "ylabel", "(", "'Fidelity with GHZ'", ")", "\n", "#plt.title(\"[3,1,3] QAE. QDC with noise strength $p = 0.3$\")", "\n", "plt", ".", "legend", "(", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Stack_QAE.stacked_QAE_fidelity": [[21, 44], ["Aer.get_backend", "QAE.subroutine_2", "QuantumCircuit", "QuantumCircuit.append", "range", "range", "QuantumCircuit.append", "QuantumCircuit.reset", "qiskit.quantum_info.partial_trace", "execute().result().get_statevector", "fid.append", "range", "list", "execute().result().get_statevector", "list", "qiskit.quantum_info.states.measures.state_fidelity", "execute().result", "set", "set", "execute().result", "set", "set", "range", "range", "execute", "execute"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.subroutine_2"], ["def", "stacked_QAE_fidelity", "(", "QAE", ",", "L", ",", "k", ")", ":", "\n", "# QAE : QAE to use", "\n", "# L : list of test states", "\n", "# k : stacking maximum", "\n", "\n", "    ", "backend", "=", "Aer", ".", "get_backend", "(", "'statevector_simulator'", ")", "\n", "\n", "QAE_circ", ",", "out_qubits", "=", "QAE", ".", "subroutine_2", "(", ")", "\n", "circ_0", "=", "QuantumCircuit", "(", "QAE", ".", "W", ")", "\n", "circ_0", ".", "append", "(", "L", "[", "0", "]", "[", "0", "]", ",", "range", "(", "QAE", ".", "M", "[", "0", "]", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "circ_0", ".", "append", "(", "QAE_circ", ",", "range", "(", "QAE", ".", "W", ")", ")", "\n", "circ_0", ".", "reset", "(", "list", "(", "set", "(", "range", "(", "QAE", ".", "W", ")", ")", "-", "set", "(", "out_qubits", ")", ")", ")", "\n", "\n", "", "fid", "=", "[", "]", "\n", "for", "pair", "in", "L", ":", "\n", "        ", "circ_0", ".", "data", "[", "0", "]", "=", "(", "pair", "[", "0", "]", ",", "circ_0", ".", "data", "[", "0", "]", "[", "1", "]", ",", "circ_0", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "state_0", "=", "partial_trace", "(", "execute", "(", "circ_0", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", ")", ",", "list", "(", "set", "(", "range", "(", "QAE", ".", "W", ")", ")", "-", "set", "(", "out_qubits", ")", ")", ")", "\n", "state_1", "=", "execute", "(", "pair", "[", "1", "]", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", ")", "\n", "fid", ".", "append", "(", "state_fidelity", "(", "state_0", ",", "state_1", ")", ")", "\n", "\n", "", "return", "fid", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Stack_QAE.stacked_QAE_fidelity_range": [[47, 83], ["Aer.get_backend", "QAE.subroutine_2", "QuantumCircuit", "QuantumCircuit.append", "range", "matplotlib.errorbar", "matplotlib.grid", "matplotlib.xlabel", "matplotlib.ylabel", "range", "QuantumCircuit.append", "QuantumCircuit.reset", "all_fid_mean.append", "all_fid_std.append", "range", "matplotlib.savefig", "range", "list", "qiskit.quantum_info.partial_trace", "execute().result().get_statevector", "fid.append", "numpy.mean", "numpy.std", "execute().result().get_statevector", "list", "qiskit.quantum_info.states.measures.state_fidelity", "set", "set", "execute().result", "range", "execute().result", "set", "set", "range", "execute", "execute"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.subroutine_2"], ["", "def", "stacked_QAE_fidelity_range", "(", "QAE", ",", "L", ",", "k", ",", "filename", "=", "None", ")", ":", "\n", "# QAE : QAE to use", "\n", "# L : list of test states", "\n", "# k : stacking maximum", "\n", "# filename : whether to save figure and figure name", "\n", "\n", "    ", "backend", "=", "Aer", ".", "get_backend", "(", "'statevector_simulator'", ")", "\n", "\n", "QAE_circ", ",", "out_qubits", "=", "QAE", ".", "subroutine_2", "(", ")", "\n", "circ_0", "=", "QuantumCircuit", "(", "QAE", ".", "W", ")", "\n", "circ_0", ".", "append", "(", "L", "[", "0", "]", "[", "0", "]", ",", "range", "(", "QAE", ".", "M", "[", "0", "]", ")", ")", "\n", "\n", "all_fid_mean", "=", "[", "]", "\n", "all_fid_std", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "circ_0", ".", "append", "(", "QAE_circ", ",", "range", "(", "QAE", ".", "W", ")", ")", "\n", "circ_0", ".", "reset", "(", "list", "(", "set", "(", "range", "(", "QAE", ".", "W", ")", ")", "-", "set", "(", "out_qubits", ")", ")", ")", "\n", "\n", "fid", "=", "[", "]", "\n", "for", "pair", "in", "L", ":", "\n", "            ", "circ_0", ".", "data", "[", "0", "]", "=", "(", "pair", "[", "0", "]", ",", "circ_0", ".", "data", "[", "0", "]", "[", "1", "]", ",", "circ_0", ".", "data", "[", "0", "]", "[", "2", "]", ")", "\n", "state_0", "=", "partial_trace", "(", "execute", "(", "circ_0", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", ")", ",", "list", "(", "set", "(", "range", "(", "QAE", ".", "W", ")", ")", "-", "set", "(", "out_qubits", ")", ")", ")", "\n", "state_1", "=", "execute", "(", "pair", "[", "1", "]", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", ")", "\n", "fid", ".", "append", "(", "state_fidelity", "(", "state_0", ",", "state_1", ")", ")", "\n", "\n", "", "all_fid_mean", ".", "append", "(", "np", ".", "mean", "(", "fid", ")", ")", "\n", "all_fid_std", ".", "append", "(", "np", ".", "std", "(", "fid", ")", ")", "\n", "\n", "# Plot", "\n", "", "plt", ".", "errorbar", "(", "range", "(", "1", ",", "k", "+", "1", ")", ",", "all_fid_mean", ",", "all_fid_std", ",", "marker", "=", "'D'", ",", "ms", "=", "4", ",", "color", "=", "'#0000CC'", ",", "capsize", "=", "5", ")", "\n", "plt", ".", "grid", "(", "lw", "=", "0.5", ",", "ls", "=", "'dotted'", ")", "\n", "plt", ".", "xlabel", "(", "'Number of QAEs stacked'", ")", "\n", "plt", ".", "ylabel", "(", "'Fidelity with GHZ'", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.train.plot_fid": [[17, 40], ["len", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.grid", "matplotlib.gca().spines[].set_visible", "matplotlib.gca().spines[].set_visible", "matplotlib.plot", "matplotlib.legend", "matplotlib.savefig", "range", "matplotlib.gca", "matplotlib.gca"], "function", ["None"], ["def", "plot_fid", "(", "train_fid", ",", "val_fid", "=", "None", ",", "filename", "=", "None", ")", ":", "\n", "# train_fid : list of training fidelities at each epoch", "\n", "# val_fid : list of validation fidelities at each epoch", "\n", "# filename : whether to save figure and figure name", "\n", "\n", "    ", "nb_epochs", "=", "len", "(", "train_fid", ")", "\n", "E", "=", "[", "k", "+", "1", "for", "k", "in", "range", "(", "nb_epochs", ")", "]", "\n", "\n", "plt", ".", "plot", "(", "E", ",", "train_fid", ",", "'-o'", ",", "color", "=", "'#0000CC'", ",", "ms", "=", "4", ",", "label", "=", "'Training pairs'", ")", "\n", "if", "val_fid", "is", "not", "None", ":", "\n", "        ", "plt", ".", "plot", "(", "E", ",", "val_fid", ",", "'-o'", ",", "color", "=", "'red'", ",", "ms", "=", "4", ",", "label", "=", "'Validation pairs'", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "", "plt", ".", "xlabel", "(", "'Epochs'", ")", "\n", "plt", ".", "ylabel", "(", "'Training Fidelity'", ")", "\n", "plt", ".", "xlim", "(", "1", ",", "nb_epochs", ")", "\n", "plt", ".", "ylim", "(", "ymax", "=", "1", ")", "\n", "plt", ".", "grid", "(", "lw", "=", "0.5", ",", "ls", "=", "'dotted'", ")", "\n", "\n", "plt", ".", "gca", "(", ")", ".", "spines", "[", "'top'", "]", ".", "set_visible", "(", "False", ")", "\n", "plt", ".", "gca", "(", ")", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.QDC": [[18, 35], ["QuantumCircuit", "numpy.random.choice", "range", "numpy.arange", "QuantumCircuit.x", "QuantumCircuit.y", "QuantumCircuit.z"], "function", ["None"], ["def", "QDC", "(", "m", ",", "p", ")", ":", "\n", "# m : nb of qubits", "\n", "# p : noise strength of QDC", "\n", "\n", "    ", "circ", "=", "QuantumCircuit", "(", "m", ",", "name", "=", "'Depolarizing Channel'", ")", "\n", "\n", "probas", "=", "[", "1", "-", "3", "*", "p", "/", "4", ",", "p", "/", "4", ",", "p", "/", "4", ",", "p", "/", "4", "]", "\n", "gate_inds", "=", "np", ".", "random", ".", "choice", "(", "np", ".", "arange", "(", "4", ")", ",", "size", "=", "m", ",", "p", "=", "probas", ")", "\n", "\n", "for", "k", "in", "range", "(", "m", ")", ":", "\n", "        ", "if", "gate_inds", "[", "k", "]", "==", "1", ":", "\n", "            ", "circ", ".", "x", "(", "k", ")", "\n", "", "elif", "gate_inds", "[", "k", "]", "==", "2", ":", "\n", "            ", "circ", ".", "y", "(", "k", ")", "\n", "", "elif", "gate_inds", "[", "k", "]", "==", "3", ":", "\n", "            ", "circ", ".", "z", "(", "k", ")", "\n", "", "", "return", "circ", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.noisy_QSS_circuit": [[38, 82], ["range", "QuantumCircuit.h", "QuantumCircuit.barrier", "QuantumCircuit.append", "QuantumCircuit.barrier", "numpy.random.rand", "QuantumCircuit.barrier", "QuantumCircuit.measure", "QuantumCircuit", "QuantumCircuit", "QuantumCircuit.cx", "QDC().to_instruction", "QAE.subroutine_2", "list", "QuantumCircuit.append", "QuantumCircuit.barrier", "range", "QuantumCircuit.h", "QuantumCircuit.sdg", "QuantumCircuit.h", "Noisy_QSS.QDC"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.subroutine_2", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.QDC"], ["", "def", "noisy_QSS_circuit", "(", "m", "=", "3", ",", "p", "=", "0.2", ",", "QAE", "=", "None", ")", ":", "\n", "# m : nb of qubits", "\n", "# p : noise strength of QDC", "\n", "# QAE : specify whether to denoise and the Quantum Autoencoder to use", "\n", "\n", "    ", "R", "=", "range", "(", "m", ")", "\n", "\n", "if", "QAE", "is", "not", "None", ":", "\n", "        ", "circ", "=", "QuantumCircuit", "(", "QAE", ".", "W", ",", "m", ",", "name", "=", "'QSS'", ")", "\n", "", "else", ":", "\n", "        ", "circ", "=", "QuantumCircuit", "(", "m", ",", "m", ",", "name", "=", "'QSS'", ")", "\n", "\n", "# Initialize the GHZ triplet", "\n", "", "circ", ".", "h", "(", "0", ")", "\n", "for", "k", "in", "R", "[", "1", ":", "]", ":", "\n", "        ", "circ", ".", "cx", "(", "0", ",", "k", ")", "\n", "\n", "# Pass it through QDC", "\n", "", "circ", ".", "barrier", "(", ")", "\n", "circ", ".", "append", "(", "QDC", "(", "m", ",", "p", ")", ".", "to_instruction", "(", ")", ",", "R", ")", "\n", "circ", ".", "barrier", "(", ")", "\n", "\n", "if", "QAE", "is", "not", "None", ":", "# use QAE to denoise", "\n", "        ", "QAE_circ", ",", "out_qubits", "=", "QAE", ".", "subroutine_2", "(", ")", "\n", "R", "=", "list", "(", "out_qubits", ")", "\n", "QAE_circ", ".", "name", "=", "'Quantum Autoencoder'", "\n", "circ", ".", "append", "(", "QAE_circ", ",", "range", "(", "QAE", ".", "W", ")", ")", "\n", "circ", ".", "barrier", "(", ")", "\n", "\n", "# Each participant make a measurement according to the X or Y basis at random", "\n", "", "p", "=", "np", ".", "random", ".", "rand", "(", "m", "+", "1", ")", "\n", "basis", "=", "''", "# will record the basis we chose for measurement", "\n", "for", "k", "in", "R", ":", "\n", "        ", "if", "p", "[", "k", "]", "<", "1", "/", "2", ":", "# make a measurement in the X basis", "\n", "            ", "basis", "+=", "'X'", "\n", "circ", ".", "h", "(", "k", ")", "\n", "", "else", ":", "# make a measurement in the Y basis", "\n", "            ", "basis", "+=", "'Y'", "\n", "circ", ".", "sdg", "(", "k", ")", "\n", "circ", ".", "h", "(", "k", ")", "\n", "", "", "circ", ".", "barrier", "(", ")", "\n", "\n", "circ", ".", "measure", "(", "R", ",", "R", ")", "\n", "return", "circ", ",", "basis", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.noisy_QSS_protocol": [[85, 117], ["range", "Noisy_QSS.noisy_QSS_circuit", "execute().result", "next", "int", "int", "int", "iter", "str", "str", "str", "str", "execute", "execute().result.get_counts", "Aer.get_backend"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.noisy_QSS_circuit"], ["", "def", "noisy_QSS_protocol", "(", "nb_trials", ",", "m", "=", "3", ",", "p", "=", "0.2", ",", "QAE", "=", "None", ")", ":", "\n", "# nb_trials : nb of times we simulate protocol", "\n", "# m : nb of qubits", "\n", "# p : noise strength of QDC", "\n", "# QAE : specify whether to denoise and the Quantum Autoencoder to use", "\n", "\n", "    ", "Valid_basis", "=", "[", "'XXX'", ",", "'YYX'", ",", "'XYY'", ",", "'YXY'", "]", "\n", "\n", "key1", "=", "''", "# final key of Charlie", "\n", "key2", "=", "''", "# final key of Alice and Bob", "\n", "\n", "for", "_", "in", "range", "(", "nb_trials", ")", ":", "\n", "        ", "circ", ",", "basis", "=", "noisy_QSS_circuit", "(", "m", "=", "m", ",", "p", "=", "p", ",", "QAE", "=", "QAE", ")", "# create new noisy QSS circuit", "\n", "\n", "if", "basis", "not", "in", "Valid_basis", ":", "\n", "#print('Invalid basis. Too bad !')", "\n", "            ", "continue", "\n", "", "else", ":", "# Alice, Bob and Charlie are supposed to be able to share a qubit", "\n", "            ", "result", "=", "execute", "(", "circ", ",", "Aer", ".", "get_backend", "(", "'qasm_simulator'", ")", ",", "shots", "=", "1", ")", ".", "result", "(", ")", "\n", "res", "=", "next", "(", "iter", "(", "result", ".", "get_counts", "(", ")", ")", ")", "# get first (and only) key --> resulting bits", "\n", "Alice", "=", "int", "(", "res", "[", "0", "]", ")", "\n", "Bob", "=", "int", "(", "res", "[", "1", "]", ")", "\n", "Charlie", "=", "int", "(", "res", "[", "2", "]", ")", "\n", "\n", "if", "basis", "==", "Valid_basis", "[", "0", "]", ":", "# XXX", "\n", "                ", "key1", "+=", "str", "(", "Charlie", ")", "\n", "key2", "+=", "str", "(", "(", "Alice", "+", "Bob", ")", "%", "2", ")", "\n", "", "else", ":", "# YYX, XYY or YXY", "\n", "                ", "key1", "+=", "str", "(", "Charlie", ")", "\n", "key2", "+=", "str", "(", "(", "Alice", "+", "Bob", "+", "1", ")", "%", "2", ")", "\n", "#print('Found secret key of length {}.'.format(len(key1)))", "\n", "", "", "", "return", "key1", ",", "key2", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.p_diff": [[120, 125], ["len", "len", "numpy.sum", "len", "numpy.array", "numpy.array", "list", "list"], "function", ["None"], ["", "def", "p_diff", "(", "key1", ",", "key2", ")", ":", "\n", "# key1, key2 : strings of bits", "\n", "\n", "    ", "assert", "len", "(", "key1", ")", "==", "len", "(", "key2", ")", ",", "\"Lengths of keys don't match\"", "\n", "return", "np", ".", "sum", "(", "np", ".", "array", "(", "list", "(", "key1", ")", ")", "!=", "np", ".", "array", "(", "list", "(", "key2", ")", ")", ")", "/", "len", "(", "key1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.noise_strength_VS_QSS": [[128, 139], ["numpy.linspace", "Noisy_QSS.noisy_QSS_protocol", "list_diff.append", "Noisy_QSS.p_diff"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.noisy_QSS_protocol", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.p_diff"], ["", "def", "noise_strength_VS_QSS", "(", "nb_trials", ",", "m", "=", "3", ",", "QAE", "=", "None", ",", "P", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "11", ")", ")", ":", "\n", "# nb_trials : nb of times we simulate protocol", "\n", "# m : nb of qubits", "\n", "# QAE : specify whether to denoise and the Quantum Autoencoder to use", "\n", "# P : list of QDC strengths", "\n", "\n", "    ", "list_diff", "=", "[", "]", "\n", "for", "p", "in", "P", ":", "\n", "        ", "key1", ",", "key2", "=", "noisy_QSS_protocol", "(", "nb_trials", "=", "nb_trials", ",", "m", "=", "m", ",", "p", "=", "p", ",", "QAE", "=", "QAE", ")", "\n", "list_diff", ".", "append", "(", "p_diff", "(", "key1", ",", "key2", ")", ")", "\n", "", "return", "list_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.theoretic_fail_proba": [[142, 146], ["None"], "function", ["None"], ["", "def", "theoretic_fail_proba", "(", "p", ")", ":", "\n", "# p : strength of QDC", "\n", "\n", "    ", "return", "p", "/", "2", "*", "(", "p", "**", "2", "-", "3", "*", "p", "+", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Noisy_QSS.plot_noisy_VS_denoised_QSS": [[149, 169], ["matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.grid", "matplotlib.gca().spines[].set_visible", "matplotlib.gca().spines[].set_visible", "matplotlib.legend", "matplotlib.savefig", "matplotlib.gca", "matplotlib.gca"], "function", ["None"], ["", "def", "plot_noisy_VS_denoised_QSS", "(", "P", ",", "list_diff", ",", "list_diff_dn", ",", "theo_p", ",", "filename", "=", "None", ")", ":", "\n", "# P : list of QDC strength", "\n", "# list_diff : list of failure probabilities of noisy QSS protocol", "\n", "# list_diff_dn : list of failure probabilities of denoised QSS protocol", "\n", "# theo_p : theoretic failure probability of noisy QSS protocol", "\n", "# filename : whether to save figure and figure name", "\n", "\n", "    ", "plt", ".", "plot", "(", "P", ",", "list_diff", ",", "'-o'", ",", "color", "=", "'r'", ",", "ms", "=", "4", ",", "label", "=", "'Empirical probability'", ")", "\n", "plt", ".", "plot", "(", "P", ",", "theo_p", ",", "color", "=", "'#0000CC'", ",", "label", "=", "'Theoretical probability'", ")", "\n", "plt", ".", "plot", "(", "P", ",", "list_diff_dn", ",", "'-o'", ",", "color", "=", "'green'", ",", "ms", "=", "4", ",", "label", "=", "'Denoised probability'", ")", "\n", "plt", ".", "xlabel", "(", "'Noise strength'", ")", "\n", "plt", ".", "ylabel", "(", "'Probability of having wrong shared bits'", ")", "\n", "plt", ".", "grid", "(", "lw", "=", "0.5", ",", "ls", "=", "'dotted'", ")", "\n", "\n", "plt", ".", "gca", "(", ")", ".", "spines", "[", "'top'", "]", ".", "set_visible", "(", "False", ")", "\n", "plt", ".", "gca", "(", ")", ".", "spines", "[", "'right'", "]", ".", "set_visible", "(", "False", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.fidelity": [[22, 32], ["Aer.get_backend", "numpy.array", "execute().result().get_statevector", "execute().result().get_statevector", "fid.append", "qiskit.quantum_info.states.measures.state_fidelity", "execute().result", "execute().result", "execute", "execute"], "function", ["None"], ["def", "fidelity", "(", "L", ")", ":", "\n", "# L : list of input/target states", "\n", "\n", "    ", "backend", "=", "Aer", ".", "get_backend", "(", "'statevector_simulator'", ")", "\n", "fid", "=", "[", "]", "\n", "for", "pair", "in", "L", ":", "\n", "        ", "state_0", "=", "execute", "(", "pair", "[", "0", "]", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", "pair", "[", "0", "]", ")", "\n", "state_1", "=", "execute", "(", "pair", "[", "1", "]", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", "pair", "[", "1", "]", ")", "\n", "fid", ".", "append", "(", "state_fidelity", "(", "state_0", ",", "state_1", ")", ")", "\n", "", "return", "np", ".", "array", "(", "fid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.theoretical_fid": [[35, 46], ["ValueError", "numpy.sum", "range", "scipy.special.binom"], "function", ["None"], ["", "def", "theoretical_fid", "(", "m", ",", "p", ",", "noise_type", "=", "'bitflip'", ")", ":", "\n", "# m : nb of qubits", "\n", "# p : noise strength", "\n", "# noise_type : type of noise (bitflip, QDC)", "\n", "\n", "    ", "if", "noise_type", "==", "'bitflip'", ":", "\n", "        ", "return", "(", "1", "-", "p", ")", "**", "m", "+", "p", "**", "m", "\n", "", "elif", "noise_type", "==", "'QDC'", ":", "# Quantum Depolarizing Channel", "\n", "        ", "return", "2", "**", "(", "m", "-", "1", ")", "*", "(", "p", "/", "4", ")", "**", "m", "+", "np", ".", "sum", "(", "[", "special", ".", "binom", "(", "m", ",", "k", ")", "*", "(", "p", "/", "4", ")", "**", "k", "*", "(", "1", "-", "3", "*", "p", "/", "4", ")", "**", "(", "m", "-", "k", ")", "for", "k", "in", "range", "(", "m", "+", "1", ")", "if", "k", "%", "2", "==", "0", "]", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Unrecognized noise type.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.compute_robustness": [[49, 73], ["fid_orig.append", "QAE.test", "fid_mean.append", "fid_std.append", "Stack_QAE.stacked_QAE_fidelity", "fid2_mean.append", "fid2_std.append", "numpy.mean", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "State_preparation.state_preparation", "State_preparation.state_preparation", "range", "test.fidelity"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.test", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Stack_QAE.stacked_QAE_fidelity", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.State_preparation.state_preparation", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.State_preparation.state_preparation", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.fidelity"], ["", "", "def", "compute_robustness", "(", "QAE", ",", "P", ",", "nb_test_states", ",", "noise_name", "=", "'noisy_GHZ_bitflip'", ",", "stack", "=", "1", ")", ":", "\n", "# QAE : QAE to use", "\n", "# P : noise range", "\n", "# nb_test_states : nb of test states", "\n", "# noise_name : name of noise used in state preparation", "\n", "# stack : nb of times we stack the QAE", "\n", "\n", "    ", "fid_orig", "=", "[", "]", "\n", "fid_mean", "=", "[", "]", "\n", "fid_std", "=", "[", "]", "\n", "fid2_mean", "=", "[", "]", "\n", "fid2_std", "=", "[", "]", "\n", "for", "p", "in", "P", ":", "\n", "        ", "test_states", "=", "[", "(", "state_preparation", "(", "QAE", ".", "M", "[", "0", "]", ",", "noise_name", ",", "p", ")", ",", "state_preparation", "(", "QAE", ".", "M", "[", "0", "]", ",", "'GHZ'", ",", "0", ")", ")", "for", "_", "in", "range", "(", "nb_test_states", ")", "]", "\n", "fid_orig", ".", "append", "(", "np", ".", "mean", "(", "fidelity", "(", "test_states", ")", ")", ")", "\n", "fid", "=", "QAE", ".", "test", "(", "test_states", ")", "\n", "fid_mean", ".", "append", "(", "np", ".", "mean", "(", "fid", ")", ")", "\n", "fid_std", ".", "append", "(", "np", ".", "std", "(", "fid", ")", ")", "\n", "\n", "fid2", "=", "stacked_QAE_fidelity", "(", "QAE", ",", "test_states", ",", "stack", ")", "\n", "fid2_mean", ".", "append", "(", "np", ".", "mean", "(", "fid2", ")", ")", "\n", "fid2_std", ".", "append", "(", "np", ".", "std", "(", "fid2", ")", ")", "\n", "\n", "", "return", "fid_orig", ",", "fid_mean", ",", "fid_std", ",", "fid2_mean", ",", "fid2_std", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.plot_fid_VS_noise_strength": [[76, 99], ["test.compute_robustness", "test.theoretical_fid", "matplotlib.plot", "matplotlib.plot", "matplotlib.errorbar", "matplotlib.grid", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.savefig"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.compute_robustness", "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.test.theoretical_fid"], ["", "def", "plot_fid_VS_noise_strength", "(", "QAE", ",", "P", ",", "nb_test_states", ",", "noise_name", "=", "'noisy_GHZ_QDC'", ",", "noise_type", "=", "'QDC'", ",", "stack", "=", "1", ",", "filename", "=", "None", ")", ":", "\n", "# QAE : QAE to use", "\n", "# P : noise range", "\n", "# nb_test_states : nb of test states to use for each noise strength", "\n", "# noise_name : name of noise used in state preparation", "\n", "# noise_type : type of noise (bitflip, QDC) for theoretical fidelity", "\n", "# stack : nb of times we stack the QAE", "\n", "\n", "    ", "fid_orig", ",", "fid_mean", ",", "fid_std", ",", "fid2_mean", ",", "fid2_std", "=", "compute_robustness", "(", "QAE", ",", "P", ",", "nb_test_states", ",", "noise_name", "=", "noise_name", ",", "stack", "=", "stack", ")", "\n", "fid_theo", "=", "theoretical_fid", "(", "QAE", ".", "M", "[", "0", "]", ",", "P", ",", "noise_type", "=", "noise_type", ")", "\n", "\n", "plt", ".", "plot", "(", "P", ",", "fid_theo", ",", "'rx'", ",", "label", "=", "'Noisy theoretical fidelity'", ")", "\n", "plt", ".", "plot", "(", "P", ",", "fid_orig", ",", "'gx'", ",", "label", "=", "'Noisy actual fidelity'", ")", "\n", "#plt.errorbar(P, fid_mean, fid_std, fmt = 'bo', capsize = 5, mfc='white', label = 'Denoised fidelity')", "\n", "plt", ".", "errorbar", "(", "P", ",", "fid2_mean", ",", "fid2_std", ",", "fmt", "=", "'mo'", ",", "capsize", "=", "5", ",", "mfc", "=", "'white'", ",", "label", "=", "'Denoised fidelity {}x'", ".", "format", "(", "stack", ")", ")", "\n", "plt", ".", "grid", "(", "lw", "=", "0.5", ",", "ls", "=", "'dotted'", ")", "\n", "plt", ".", "xlabel", "(", "'Noise strength of QDC'", ")", "\n", "#plt.xlabel('Bit-flip probability')", "\n", "plt", ".", "ylabel", "(", "'Fidelity with GHZ'", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Cool_plots.get_statevectors": [[21, 38], ["Aer.get_backend", "QAE.subroutine_2", "numpy.zeros", "numpy.zeros", "QuantumCircuit", "QuantumCircuit.append", "QuantumCircuit.append", "execute().result().get_statevector", "range", "range", "qiskit.quantum_info.partial_trace", "len", "len", "execute().result().get_statevector", "list", "execute().result", "execute().result", "set", "set", "execute", "range", "execute"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.QNN.QNN.subroutine_2"], ["def", "get_statevectors", "(", "QAE", ",", "noisy_states", ")", ":", "\n", "# QAE : QAE to use", "\n", "# noisy_states : list of noisy states", "\n", "\n", "    ", "backend", "=", "Aer", ".", "get_backend", "(", "'statevector_simulator'", ")", "\n", "QAE_circ", ",", "out_qubits", "=", "QAE", ".", "subroutine_2", "(", ")", "\n", "\n", "state_0", "=", "np", ".", "zeros", "(", "(", "2", "**", "QAE", ".", "M", "[", "0", "]", ",", "2", "**", "QAE", ".", "M", "[", "0", "]", ")", ",", "dtype", "=", "'complex128'", ")", "\n", "state_1", "=", "np", ".", "zeros", "(", "2", "**", "QAE", ".", "M", "[", "0", "]", ",", "dtype", "=", "'complex128'", ")", "\n", "for", "state", "in", "noisy_states", ":", "\n", "        ", "circ_0", "=", "QuantumCircuit", "(", "QAE", ".", "W", ")", "\n", "circ_0", ".", "append", "(", "state", ",", "range", "(", "QAE", ".", "M", "[", "0", "]", ")", ")", "\n", "circ_0", ".", "append", "(", "QAE_circ", ",", "range", "(", "QAE", ".", "W", ")", ")", "\n", "\n", "state_0", "+=", "partial_trace", "(", "execute", "(", "circ_0", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", ")", ",", "list", "(", "set", "(", "range", "(", "QAE", ".", "W", ")", ")", "-", "set", "(", "out_qubits", ")", ")", ")", ".", "data", "\n", "state_1", "+=", "execute", "(", "state", ",", "backend", ")", ".", "result", "(", ")", ".", "get_statevector", "(", ")", "\n", "", "return", "(", "state_0", "/", "len", "(", "noisy_states", ")", ",", "state_1", "/", "len", "(", "noisy_states", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Cool_plots.plot_SC": [[41, 62], ["matplotlib.figure", "matplotlib.title", "matplotlib.axis", "plt.figure.add_subplot", "plt.figure.add_subplot", "plt.figure.add_subplot", "plt.figure.add_subplot", "qiskit.visualization.plot_state_city", "qiskit.visualization.plot_state_city", "fig.add_subplot.set_zlim", "fig.add_subplot.set_zlim", "fig.add_subplot.set_zlim", "fig.add_subplot.set_zlim", "matplotlib.savefig"], "function", ["None"], ["", "def", "plot_SC", "(", "state_0", ",", "state_1", ",", "filename", "=", "None", ")", ":", "\n", "# state_0 : statevector of denoised state", "\n", "# state_1 : statevector of noisy state", "\n", "# filename : whether to save figure and figure name", "\n", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "10", ")", ")", "\n", "plt", ".", "title", "(", "\"States city of noisy (top) and denoised (bottom) states. We used a [2,1,2] QAE, and 200 GHZ states affected by the QDC with noise strength $p = 0.4$. \\n The states city are respectively the average initial state vector and the average density matrix output by the QAE.\"", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "ax1", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "1", ",", "projection", "=", "'3d'", ")", "\n", "ax2", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "2", ",", "projection", "=", "'3d'", ")", "\n", "ax3", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "3", ",", "projection", "=", "'3d'", ")", "\n", "ax4", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "4", ",", "projection", "=", "'3d'", ")", "\n", "plot_state_city", "(", "state_1", ",", "color", "=", "[", "'crimson'", ",", "'crimson'", "]", ",", "ax_real", "=", "ax1", ",", "ax_imag", "=", "ax2", ")", "\n", "plot_state_city", "(", "state_0", ",", "color", "=", "[", "'crimson'", ",", "'crimson'", "]", ",", "ax_real", "=", "ax3", ",", "ax_imag", "=", "ax4", ")", "\n", "ax1", ".", "set_zlim", "(", "0", ",", "0.5", ")", "\n", "ax2", ".", "set_zlim", "(", "0", ",", "0.5", ")", "\n", "ax3", ".", "set_zlim", "(", "0", ",", "0.5", ")", "\n", "ax4", ".", "set_zlim", "(", "0", ",", "0.5", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Cool_plots.plot_SH": [[65, 81], ["matplotlib.figure", "matplotlib.axis", "plt.figure.add_subplot", "plt.figure.add_subplot", "plt.figure.add_subplot", "plt.figure.add_subplot", "qiskit.visualization.plot_state_hinton", "qiskit.visualization.plot_state_hinton", "matplotlib.savefig"], "function", ["None"], ["", "", "def", "plot_SH", "(", "state_0", ",", "state_1", ",", "filename", "=", "None", ")", ":", "\n", "# state_0 : statevector of denoised state", "\n", "# state_1 : statevector of noisy state", "\n", "# filename : whether to save figure and figure name", "\n", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "10", ")", ")", "\n", "plt", ".", "axis", "(", "\"off\"", ")", "\n", "ax1", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "1", ")", "\n", "ax2", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "2", ")", "\n", "ax3", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "3", ")", "\n", "ax4", "=", "fig", ".", "add_subplot", "(", "2", ",", "2", ",", "4", ")", "\n", "plot_state_hinton", "(", "state_1", ",", "ax_real", "=", "ax1", ",", "ax_imag", "=", "ax2", ")", "\n", "plot_state_hinton", "(", "state_0", ",", "ax_real", "=", "ax3", ",", "ax_imag", "=", "ax4", ")", "\n", "\n", "if", "filename", "!=", "None", ":", "\n", "        ", "plt", ".", "savefig", "(", "filename", "+", "'.pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Regular_QSS.QSS_circuit": [[15, 41], ["QuantumCircuit", "QuantumCircuit.h", "range", "QuantumCircuit.barrier", "numpy.random.rand", "range", "QuantumCircuit.barrier", "QuantumCircuit.measure", "QuantumCircuit.cx", "range", "range", "QuantumCircuit.h", "QuantumCircuit.sdg", "QuantumCircuit.h"], "function", ["None"], ["def", "QSS_circuit", "(", "m", "=", "3", ")", ":", "\n", "# m : nb of qubit", "\n", "\n", "    ", "circ", "=", "QuantumCircuit", "(", "m", ",", "m", ",", "name", "=", "'QSS'", ")", "\n", "\n", "# Initialize the GHZ triplet", "\n", "circ", ".", "h", "(", "0", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "m", ")", ":", "\n", "        ", "circ", ".", "cx", "(", "0", ",", "k", ")", "\n", "", "circ", ".", "barrier", "(", ")", "\n", "\n", "# Each participant make a measurement according to the X or Y basis at random", "\n", "p", "=", "np", ".", "random", ".", "rand", "(", "m", ")", "\n", "basis", "=", "''", "# will record the basis we chose for measurement", "\n", "for", "k", "in", "range", "(", "m", ")", ":", "\n", "        ", "if", "p", "[", "k", "]", "<", "1", "/", "2", ":", "# make a measurement in the X basis", "\n", "            ", "basis", "+=", "'X'", "\n", "circ", ".", "h", "(", "k", ")", "\n", "", "else", ":", "# make a measurement in the Y basis", "\n", "            ", "basis", "+=", "'Y'", "\n", "circ", ".", "sdg", "(", "k", ")", "# S^\\dagger", "\n", "circ", ".", "h", "(", "k", ")", "\n", "", "", "circ", ".", "barrier", "(", ")", "\n", "\n", "circ", ".", "measure", "(", "range", "(", "m", ")", ",", "range", "(", "m", ")", ")", "\n", "return", "circ", ",", "basis", "\n", "\n"]], "home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Regular_QSS.QSS_protocol": [[44, 72], ["range", "print", "Regular_QSS.QSS_circuit", "print", "execute().result", "next", "int", "int", "int", "len", "iter", "str", "str", "execute", "execute().result.get_counts", "Aer.get_backend"], "function", ["home.repos.pwc.inspect_result.Tom-Achache_QAEs.None.Regular_QSS.QSS_circuit"], ["", "def", "QSS_protocol", "(", "nb_trials", ",", "m", "=", "3", ")", ":", "\n", "# nb_trials : nb of times we simulate protocol", "\n", "# m : nb of qubits", "\n", "\n", "    ", "Valid_basis", "=", "[", "'XXX'", ",", "'YYX'", ",", "'XYY'", ",", "'YXY'", "]", "\n", "\n", "key", "=", "''", "# final key", "\n", "\n", "for", "_", "in", "range", "(", "nb_trials", ")", ":", "\n", "        ", "circ", ",", "basis", "=", "QSS_circuit", "(", "m", ")", "# create new QSS circuit", "\n", "\n", "if", "basis", "not", "in", "Valid_basis", ":", "\n", "            ", "print", "(", "'Invalid basis. Too bad !'", ")", "\n", "", "else", ":", "# Alice, Bob and Charlie will be able to share a secret bit", "\n", "            ", "result", "=", "execute", "(", "circ", ",", "Aer", ".", "get_backend", "(", "'qasm_simulator'", ")", ",", "shots", "=", "1", ")", ".", "result", "(", ")", "\n", "res", "=", "next", "(", "iter", "(", "result", ".", "get_counts", "(", ")", ")", ")", "# get first (and only) key --> resulting bits", "\n", "Alice", "=", "int", "(", "res", "[", "0", "]", ")", "\n", "Bob", "=", "int", "(", "res", "[", "1", "]", ")", "\n", "Charlie", "=", "int", "(", "res", "[", "2", "]", ")", "\n", "\n", "if", "basis", "==", "Valid_basis", "[", "0", "]", ":", "# XXX ", "\n", "                ", "assert", "(", "Alice", "+", "Bob", ")", "%", "2", "==", "Charlie", "\n", "key", "+=", "str", "(", "Charlie", ")", "\n", "", "else", ":", "# YYX, XYY or YXY", "\n", "                ", "assert", "(", "Alice", "+", "Bob", "+", "1", ")", "%", "2", "==", "Charlie", "\n", "key", "+=", "str", "(", "Charlie", ")", "\n", "", "", "", "print", "(", "'Found secret key of length {}.'", ".", "format", "(", "len", "(", "key", ")", ")", ")", "\n", "return", "key", "\n", "\n"]]}