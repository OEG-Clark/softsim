{"home.repos.pwc.inspect_result.csjliang_dasr.None.setup.readme": [[14, 18], ["open", "f.read"], "function", ["None"], ["def", "readme", "(", ")", ":", "\n", "    ", "with", "open", "(", "'README.md'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "        ", "content", "=", "f", ".", "read", "(", ")", "\n", "", "return", "content", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.None.setup.get_git_hash": [[20, 43], ["setup.get_git_hash._minimal_ext_cmd"], "function", ["None"], ["", "def", "get_git_hash", "(", ")", ":", "\n", "\n", "    ", "def", "_minimal_ext_cmd", "(", "cmd", ")", ":", "\n", "# construct minimal environment", "\n", "        ", "env", "=", "{", "}", "\n", "for", "k", "in", "[", "'SYSTEMROOT'", ",", "'PATH'", ",", "'HOME'", "]", ":", "\n", "            ", "v", "=", "os", ".", "environ", ".", "get", "(", "k", ")", "\n", "if", "v", "is", "not", "None", ":", "\n", "                ", "env", "[", "k", "]", "=", "v", "\n", "# LANGUAGE is used on win32", "\n", "", "", "env", "[", "'LANGUAGE'", "]", "=", "'C'", "\n", "env", "[", "'LANG'", "]", "=", "'C'", "\n", "env", "[", "'LC_ALL'", "]", "=", "'C'", "\n", "out", "=", "subprocess", ".", "Popen", "(", "cmd", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "env", "=", "env", ")", ".", "communicate", "(", ")", "[", "0", "]", "\n", "return", "out", "\n", "\n", "", "try", ":", "\n", "        ", "out", "=", "_minimal_ext_cmd", "(", "[", "'git'", ",", "'rev-parse'", ",", "'HEAD'", "]", ")", "\n", "sha", "=", "out", ".", "strip", "(", ")", ".", "decode", "(", "'ascii'", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.None.setup.get_hash": [[45, 58], ["os.path.exists", "os.path.exists", "setup.get_git_hash", "__version__.split", "ImportError"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.None.setup.get_git_hash"], ["", "def", "get_hash", "(", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "'.git'", ")", ":", "\n", "        ", "sha", "=", "get_git_hash", "(", ")", "[", ":", "7", "]", "\n", "", "elif", "os", ".", "path", ".", "exists", "(", "version_file", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "from", "basicsr", ".", "version", "import", "__version__", "\n", "sha", "=", "__version__", ".", "split", "(", "'+'", ")", "[", "-", "1", "]", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Unable to get git version'", ")", "\n", "", "", "else", ":", "\n", "        ", "sha", "=", "'unknown'", "\n", "\n", "", "return", "sha", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.None.setup.write_version_py": [[60, 75], ["setup.get_hash", "content.format", "open", "f.read().strip", "time.asctime", "open", "f.write", "f.read", "x.isdigit", "f.read().strip.split"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.None.setup.get_hash"], ["", "def", "write_version_py", "(", ")", ":", "\n", "    ", "content", "=", "\"\"\"# GENERATED VERSION FILE\n# TIME: {}\n__version__ = '{}'\n__gitsha__ = '{}'\nversion_info = ({})\n\"\"\"", "\n", "sha", "=", "get_hash", "(", ")", "\n", "with", "open", "(", "'VERSION'", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "SHORT_VERSION", "=", "f", ".", "read", "(", ")", ".", "strip", "(", ")", "\n", "", "VERSION_INFO", "=", "', '", ".", "join", "(", "[", "x", "if", "x", ".", "isdigit", "(", ")", "else", "f'\"{x}\"'", "for", "x", "in", "SHORT_VERSION", ".", "split", "(", "'.'", ")", "]", ")", "\n", "\n", "version_file_str", "=", "content", ".", "format", "(", "time", ".", "asctime", "(", ")", ",", "SHORT_VERSION", ",", "sha", ",", "VERSION_INFO", ")", "\n", "with", "open", "(", "version_file", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "version_file_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.None.setup.get_version": [[77, 81], ["open", "exec", "locals", "compile", "f.read"], "function", ["None"], ["", "", "def", "get_version", "(", ")", ":", "\n", "    ", "with", "open", "(", "version_file", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "exec", "(", "compile", "(", "f", ".", "read", "(", ")", ",", "version_file", ",", "'exec'", ")", ")", "\n", "", "return", "locals", "(", ")", "[", "'__version__'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.None.setup.make_cuda_ext": [[83, 107], ["extension", "torch.cuda.is_available", "print", "os.getenv", "os.path.join", "module.split"], "function", ["None"], ["", "def", "make_cuda_ext", "(", "name", ",", "module", ",", "sources", ",", "sources_cuda", "=", "None", ")", ":", "\n", "    ", "if", "sources_cuda", "is", "None", ":", "\n", "        ", "sources_cuda", "=", "[", "]", "\n", "", "define_macros", "=", "[", "]", "\n", "extra_compile_args", "=", "{", "'cxx'", ":", "[", "]", "}", "\n", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "or", "os", ".", "getenv", "(", "'FORCE_CUDA'", ",", "'0'", ")", "==", "'1'", ":", "\n", "        ", "define_macros", "+=", "[", "(", "'WITH_CUDA'", ",", "None", ")", "]", "\n", "extension", "=", "CUDAExtension", "\n", "extra_compile_args", "[", "'nvcc'", "]", "=", "[", "\n", "'-D__CUDA_NO_HALF_OPERATORS__'", ",", "\n", "'-D__CUDA_NO_HALF_CONVERSIONS__'", ",", "\n", "'-D__CUDA_NO_HALF2_OPERATORS__'", ",", "\n", "]", "\n", "sources", "+=", "sources_cuda", "\n", "", "else", ":", "\n", "        ", "print", "(", "f'Compiling {name} without CUDA'", ")", "\n", "extension", "=", "CppExtension", "\n", "\n", "", "return", "extension", "(", "\n", "name", "=", "f'{module}.{name}'", ",", "\n", "sources", "=", "[", "os", ".", "path", ".", "join", "(", "*", "module", ".", "split", "(", "'.'", ")", ",", "p", ")", "for", "p", "in", "sources", "]", ",", "\n", "define_macros", "=", "define_macros", ",", "\n", "extra_compile_args", "=", "extra_compile_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.None.setup.get_requirements": [[109, 114], ["os.path.dirname", "os.path.realpath", "open", "os.path.join", "line.replace", "f.readlines"], "function", ["None"], ["", "def", "get_requirements", "(", "filename", "=", "'requirements.txt'", ")", ":", "\n", "    ", "here", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "realpath", "(", "__file__", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "here", ",", "filename", ")", ",", "'r'", ")", "as", "f", ":", "\n", "        ", "requires", "=", "[", "line", ".", "replace", "(", "'\\n'", ",", "''", ")", "for", "line", "in", "f", ".", "readlines", "(", ")", "]", "\n", "", "return", "requires", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.init_tb_loggers": [[17, 27], ["basicsr.utils.init_wandb_logger", "opt[].get", "basicsr.utils.init_tb_logger", "opt[].get", "[].get", "opt[].get", "os.path.join"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.init_wandb_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.init_tb_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["def", "init_tb_loggers", "(", "opt", ")", ":", "\n", "# initialize wandb logger before tensorboard logger to allow proper sync", "\n", "    ", "if", "(", "opt", "[", "'logger'", "]", ".", "get", "(", "'wandb'", ")", "is", "not", "None", ")", "and", "(", "opt", "[", "'logger'", "]", "[", "'wandb'", "]", ".", "get", "(", "'project'", ")", "\n", "is", "not", "None", ")", "and", "(", "'debug'", "not", "in", "opt", "[", "'name'", "]", ")", ":", "\n", "        ", "assert", "opt", "[", "'logger'", "]", ".", "get", "(", "'use_tb_logger'", ")", "is", "True", ",", "(", "'should turn on tensorboard when using wandb'", ")", "\n", "init_wandb_logger", "(", "opt", ")", "\n", "", "tb_logger", "=", "None", "\n", "if", "opt", "[", "'logger'", "]", ".", "get", "(", "'use_tb_logger'", ")", "and", "'debug'", "not", "in", "opt", "[", "'name'", "]", ":", "\n", "        ", "tb_logger", "=", "init_tb_logger", "(", "log_dir", "=", "osp", ".", "join", "(", "opt", "[", "'root_path'", "]", ",", "'tb_logger'", ",", "opt", "[", "'name'", "]", ")", ")", "\n", "", "return", "tb_logger", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.create_train_val_dataloader": [[29, 66], ["opt[].items", "dataset_opt.get", "basicsr.data.build_dataset", "basicsr.data.data_sampler.EnlargedSampler", "basicsr.data.build_dataloader", "math.ceil", "int", "math.ceil", "logger.info", "basicsr.data.build_dataset", "basicsr.data.build_dataloader", "logger.info", "ValueError", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataset", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataloader", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataset", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataloader"], ["", "def", "create_train_val_dataloader", "(", "opt", ",", "logger", ")", ":", "\n", "# create train and val dataloaders", "\n", "    ", "train_loader", ",", "val_loader", "=", "None", ",", "None", "\n", "for", "phase", ",", "dataset_opt", "in", "opt", "[", "'datasets'", "]", ".", "items", "(", ")", ":", "\n", "        ", "if", "phase", "==", "'train'", ":", "\n", "            ", "dataset_enlarge_ratio", "=", "dataset_opt", ".", "get", "(", "'dataset_enlarge_ratio'", ",", "1", ")", "\n", "train_set", "=", "build_dataset", "(", "dataset_opt", ")", "\n", "train_sampler", "=", "EnlargedSampler", "(", "train_set", ",", "opt", "[", "'world_size'", "]", ",", "opt", "[", "'rank'", "]", ",", "dataset_enlarge_ratio", ")", "\n", "train_loader", "=", "build_dataloader", "(", "\n", "train_set", ",", "\n", "dataset_opt", ",", "\n", "num_gpu", "=", "opt", "[", "'num_gpu'", "]", ",", "\n", "dist", "=", "opt", "[", "'dist'", "]", ",", "\n", "sampler", "=", "train_sampler", ",", "\n", "seed", "=", "opt", "[", "'manual_seed'", "]", ")", "\n", "\n", "num_iter_per_epoch", "=", "math", ".", "ceil", "(", "\n", "len", "(", "train_set", ")", "*", "dataset_enlarge_ratio", "/", "(", "dataset_opt", "[", "'batch_size_per_gpu'", "]", "*", "opt", "[", "'world_size'", "]", ")", ")", "\n", "total_iters", "=", "int", "(", "opt", "[", "'train'", "]", "[", "'total_iter'", "]", ")", "\n", "total_epochs", "=", "math", ".", "ceil", "(", "total_iters", "/", "(", "num_iter_per_epoch", ")", ")", "\n", "logger", ".", "info", "(", "'Training statistics:'", "\n", "f'\\n\\tNumber of train images: {len(train_set)}'", "\n", "f'\\n\\tDataset enlarge ratio: {dataset_enlarge_ratio}'", "\n", "f'\\n\\tBatch size per gpu: {dataset_opt[\"batch_size_per_gpu\"]}'", "\n", "f'\\n\\tWorld size (gpu number): {opt[\"world_size\"]}'", "\n", "f'\\n\\tRequire iter number per epoch: {num_iter_per_epoch}'", "\n", "f'\\n\\tTotal epochs: {total_epochs}; iters: {total_iters}.'", ")", "\n", "\n", "", "elif", "phase", "==", "'val'", ":", "\n", "            ", "val_set", "=", "build_dataset", "(", "dataset_opt", ")", "\n", "val_loader", "=", "build_dataloader", "(", "\n", "val_set", ",", "dataset_opt", ",", "num_gpu", "=", "opt", "[", "'num_gpu'", "]", ",", "dist", "=", "opt", "[", "'dist'", "]", ",", "sampler", "=", "None", ",", "seed", "=", "opt", "[", "'manual_seed'", "]", ")", "\n", "logger", ".", "info", "(", "f'Number of val images/folders in {dataset_opt[\"name\"]}: '", "f'{len(val_set)}'", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Dataset phase {phase} is not recognized.'", ")", "\n", "\n", "", "", "return", "train_loader", ",", "train_sampler", ",", "val_loader", ",", "total_epochs", ",", "total_iters", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.load_resume_state": [[68, 89], ["os.path.join", "os.path.isdir", "opt[].get", "torch.cuda.current_device", "torch.load", "basicsr.utils.check_resume", "list", "basicsr.utils.scandir", "len", "os.path.join", "float", "storage.cuda", "v.split", "max"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.check_resume", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "load_resume_state", "(", "opt", ")", ":", "\n", "    ", "resume_state_path", "=", "None", "\n", "if", "opt", "[", "'auto_resume'", "]", ":", "\n", "        ", "state_path", "=", "osp", ".", "join", "(", "'experiments'", ",", "opt", "[", "'name'", "]", ",", "'training_states'", ")", "\n", "if", "osp", ".", "isdir", "(", "state_path", ")", ":", "\n", "            ", "states", "=", "list", "(", "scandir", "(", "state_path", ",", "suffix", "=", "'state'", ",", "recursive", "=", "False", ",", "full_path", "=", "False", ")", ")", "\n", "if", "len", "(", "states", ")", "!=", "0", ":", "\n", "                ", "states", "=", "[", "float", "(", "v", ".", "split", "(", "'.state'", ")", "[", "0", "]", ")", "for", "v", "in", "states", "]", "\n", "resume_state_path", "=", "osp", ".", "join", "(", "state_path", ",", "f'{max(states):.0f}.state'", ")", "\n", "opt", "[", "'path'", "]", "[", "'resume_state'", "]", "=", "resume_state_path", "\n", "", "", "", "else", ":", "\n", "        ", "if", "opt", "[", "'path'", "]", ".", "get", "(", "'resume_state'", ")", ":", "\n", "            ", "resume_state_path", "=", "opt", "[", "'path'", "]", "[", "'resume_state'", "]", "\n", "\n", "", "", "if", "resume_state_path", "is", "None", ":", "\n", "        ", "resume_state", "=", "None", "\n", "", "else", ":", "\n", "        ", "device_id", "=", "torch", ".", "cuda", ".", "current_device", "(", ")", "\n", "resume_state", "=", "torch", ".", "load", "(", "resume_state_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ".", "cuda", "(", "device_id", ")", ")", "\n", "check_resume", "(", "opt", ",", "resume_state", "[", "'iter'", "]", ")", "\n", "", "return", "resume_state", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.train_pipeline": [[91, 204], ["basicsr.utils.options.parse_options", "train.load_resume_state", "os.path.join", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "train.init_tb_loggers", "train.create_train_val_dataloader", "basicsr.utils.MessageLogger", "[].get", "basicsr.utils.get_root_logger.info", "time.time", "range", "str", "basicsr.utils.get_root_logger.info", "basicsr.utils.get_root_logger.info", "basicsr.models.build_model.save", "basicsr.utils.make_exp_dirs", "basicsr.utils.options.dict2str", "basicsr.models.build_model", "basicsr.models.build_model.resume_training", "basicsr.utils.get_root_logger.info", "basicsr.models.build_model", "basicsr.data.prefetch_dataloader.CPUPrefetcher", "time.time", "time.time", "train_sampler.set_epoch", "basicsr.data.prefetch_dataloader.CUDAPrefetcher.reset", "basicsr.data.prefetch_dataloader.CUDAPrefetcher.next", "datetime.timedelta", "basicsr.utils.options.parse_options.get", "basicsr.models.build_model.validation", "init_tb_loggers.close", "opt[].get", "basicsr.utils.mkdir_and_rename", "basicsr.data.prefetch_dataloader.CUDAPrefetcher", "basicsr.utils.get_root_logger.info", "ValueError", "basicsr.models.build_model.update_learning_rate", "basicsr.models.build_model.feed_data", "basicsr.models.build_model.optimize_parameters", "time.time", "time.time", "basicsr.data.prefetch_dataloader.CUDAPrefetcher.next", "os.path.join", "basicsr.utils.get_time_str", "[].get", "ValueError", "time.time", "time.time", "log_vars.update", "log_vars.update", "log_vars.update", "basicsr.utils.MessageLogger.", "basicsr.utils.get_root_logger.info", "basicsr.models.build_model.save", "basicsr.models.build_model.validation", "int", "opt[].get", "basicsr.models.build_model.get_current_log", "basicsr.utils.options.parse_options.get", "basicsr.models.build_model.get_current_learning_rate", "time.time"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.options.parse_options", "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.load_resume_state", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.init_tb_loggers", "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.train.create_train_val_dataloader", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.make_exp_dirs", "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.dict2str", "home.repos.pwc.inspect_result.csjliang_dasr.models.__init__.build_model", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.resume_training", "home.repos.pwc.inspect_result.csjliang_dasr.models.__init__.build_model", "home.repos.pwc.inspect_result.csjliang_dasr.data.data_sampler.EnlargedSampler.set_epoch", "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.reset", "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.next", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.validation", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.mkdir_and_rename", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.update_learning_rate", "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.feed_data", "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrgan_model.RealESRGANModel.optimize_parameters", "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.next", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.get_time_str", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.validation", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_log", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_learning_rate"], ["", "def", "train_pipeline", "(", "root_path", ")", ":", "\n", "# parse options, set distributed setting, set ramdom seed", "\n", "    ", "opt", "=", "parse_options", "(", "root_path", ",", "is_train", "=", "True", ")", "\n", "opt", "[", "'root_path'", "]", "=", "root_path", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# torch.backends.cudnn.deterministic = True", "\n", "\n", "# load resume states if necessary", "\n", "resume_state", "=", "load_resume_state", "(", "opt", ")", "\n", "# mkdir for experiments and logger", "\n", "if", "resume_state", "is", "None", ":", "\n", "        ", "make_exp_dirs", "(", "opt", ")", "\n", "if", "opt", "[", "'logger'", "]", ".", "get", "(", "'use_tb_logger'", ")", "and", "'debug'", "not", "in", "opt", "[", "'name'", "]", "and", "opt", "[", "'rank'", "]", "==", "0", ":", "\n", "            ", "mkdir_and_rename", "(", "osp", ".", "join", "(", "opt", "[", "'root_path'", "]", ",", "'tb_logger'", ",", "opt", "[", "'name'", "]", ")", ")", "\n", "\n", "# WARNING: should not use get_root_logger in the above codes, including the called functions", "\n", "# Otherwise the logger will not be properly initialized", "\n", "", "", "log_file", "=", "osp", ".", "join", "(", "opt", "[", "'path'", "]", "[", "'log'", "]", ",", "f\"train_{opt['name']}_{get_time_str()}.log\"", ")", "\n", "logger", "=", "get_root_logger", "(", "logger_name", "=", "'basicsr'", ",", "log_level", "=", "logging", ".", "INFO", ",", "log_file", "=", "log_file", ")", "\n", "# logger.info(get_env_info())", "\n", "logger", ".", "info", "(", "dict2str", "(", "opt", ")", ")", "\n", "# initialize wandb and tb loggers", "\n", "tb_logger", "=", "init_tb_loggers", "(", "opt", ")", "\n", "\n", "# create train and validation dataloaders", "\n", "result", "=", "create_train_val_dataloader", "(", "opt", ",", "logger", ")", "\n", "train_loader", ",", "train_sampler", ",", "val_loader", ",", "total_epochs", ",", "total_iters", "=", "result", "\n", "\n", "# create model", "\n", "if", "resume_state", ":", "# resume training", "\n", "        ", "model", "=", "build_model", "(", "opt", ")", "\n", "model", ".", "resume_training", "(", "resume_state", ")", "# handle optimizers and schedulers", "\n", "logger", ".", "info", "(", "f\"Resuming training from epoch: {resume_state['epoch']}, \"", "f\"iter: {resume_state['iter']}.\"", ")", "\n", "start_epoch", "=", "resume_state", "[", "'epoch'", "]", "\n", "current_iter", "=", "resume_state", "[", "'iter'", "]", "\n", "", "else", ":", "\n", "        ", "model", "=", "build_model", "(", "opt", ")", "\n", "start_epoch", "=", "0", "\n", "current_iter", "=", "0", "\n", "\n", "# create message logger (formatted outputs)", "\n", "", "msg_logger", "=", "MessageLogger", "(", "opt", ",", "current_iter", ",", "tb_logger", ")", "\n", "\n", "# dataloader prefetcher", "\n", "prefetch_mode", "=", "opt", "[", "'datasets'", "]", "[", "'train'", "]", ".", "get", "(", "'prefetch_mode'", ")", "\n", "if", "prefetch_mode", "is", "None", "or", "prefetch_mode", "==", "'cpu'", ":", "\n", "        ", "prefetcher", "=", "CPUPrefetcher", "(", "train_loader", ")", "\n", "", "elif", "prefetch_mode", "==", "'cuda'", ":", "\n", "        ", "prefetcher", "=", "CUDAPrefetcher", "(", "train_loader", ",", "opt", ")", "\n", "logger", ".", "info", "(", "f'Use {prefetch_mode} prefetch dataloader'", ")", "\n", "if", "opt", "[", "'datasets'", "]", "[", "'train'", "]", ".", "get", "(", "'pin_memory'", ")", "is", "not", "True", ":", "\n", "            ", "raise", "ValueError", "(", "'Please set pin_memory=True for CUDAPrefetcher.'", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Wrong prefetch_mode {prefetch_mode}.'", "\"Supported ones are: None, 'cuda', 'cpu'.\"", ")", "\n", "\n", "# training", "\n", "", "logger", ".", "info", "(", "f'Start training from epoch: {start_epoch}, iter: {current_iter}'", ")", "\n", "data_time", ",", "iter_time", "=", "time", ".", "time", "(", ")", ",", "time", ".", "time", "(", ")", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "start_epoch", ",", "total_epochs", "+", "1", ")", ":", "\n", "        ", "train_sampler", ".", "set_epoch", "(", "epoch", ")", "\n", "prefetcher", ".", "reset", "(", ")", "\n", "train_data", "=", "prefetcher", ".", "next", "(", ")", "\n", "\n", "while", "train_data", "is", "not", "None", ":", "\n", "            ", "data_time", "=", "time", ".", "time", "(", ")", "-", "data_time", "\n", "\n", "current_iter", "+=", "1", "\n", "if", "current_iter", ">", "total_iters", ":", "\n", "                ", "break", "\n", "# update learning rate", "\n", "", "model", ".", "update_learning_rate", "(", "current_iter", ",", "warmup_iter", "=", "opt", "[", "'train'", "]", ".", "get", "(", "'warmup_iter'", ",", "-", "1", ")", ")", "\n", "# training", "\n", "model", ".", "feed_data", "(", "train_data", ")", "\n", "model", ".", "optimize_parameters", "(", "current_iter", ")", "\n", "iter_time", "=", "time", ".", "time", "(", ")", "-", "iter_time", "\n", "# log", "\n", "if", "current_iter", "%", "opt", "[", "'logger'", "]", "[", "'print_freq'", "]", "==", "0", ":", "\n", "                ", "log_vars", "=", "{", "'epoch'", ":", "epoch", ",", "'iter'", ":", "current_iter", "}", "\n", "log_vars", ".", "update", "(", "{", "'lrs'", ":", "model", ".", "get_current_learning_rate", "(", ")", "}", ")", "\n", "log_vars", ".", "update", "(", "{", "'time'", ":", "iter_time", ",", "'data_time'", ":", "data_time", "}", ")", "\n", "log_vars", ".", "update", "(", "model", ".", "get_current_log", "(", ")", ")", "\n", "msg_logger", "(", "log_vars", ")", "\n", "\n", "# save models and training states", "\n", "", "if", "current_iter", "%", "opt", "[", "'logger'", "]", "[", "'save_checkpoint_freq'", "]", "==", "0", ":", "\n", "                ", "logger", ".", "info", "(", "'Saving models and training states.'", ")", "\n", "model", ".", "save", "(", "epoch", ",", "current_iter", ")", "\n", "\n", "# validation", "\n", "", "if", "opt", ".", "get", "(", "'val'", ")", "is", "not", "None", "and", "(", "current_iter", "%", "opt", "[", "'val'", "]", "[", "'val_freq'", "]", "==", "0", ")", ":", "\n", "                ", "model", ".", "validation", "(", "val_loader", ",", "current_iter", ",", "tb_logger", ",", "opt", "[", "'val'", "]", "[", "'save_img'", "]", ")", "\n", "\n", "", "data_time", "=", "time", ".", "time", "(", ")", "\n", "iter_time", "=", "time", ".", "time", "(", ")", "\n", "train_data", "=", "prefetcher", ".", "next", "(", ")", "\n", "\n", "# # end of iter", "\n", "# if 'gumble' in opt['network_p']['type']:", "\n", "#     model.update_temperature()", "\n", "\n", "# end of epoch", "\n", "\n", "", "", "consumed_time", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "time", ".", "time", "(", ")", "-", "start_time", ")", ")", ")", "\n", "logger", ".", "info", "(", "f'End of training. Time consumed: {consumed_time}'", ")", "\n", "logger", ".", "info", "(", "'Save the latest model.'", ")", "\n", "model", ".", "save", "(", "epoch", "=", "-", "1", ",", "current_iter", "=", "-", "1", ")", "# -1 stands for the latest", "\n", "if", "opt", ".", "get", "(", "'val'", ")", "is", "not", "None", ":", "\n", "        ", "model", ".", "validation", "(", "val_loader", ",", "current_iter", ",", "tb_logger", ",", "opt", "[", "'val'", "]", "[", "'save_img'", "]", ")", "\n", "", "if", "tb_logger", ":", "\n", "        ", "tb_logger", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.basicsr.test.test_pipeline": [[11, 41], ["basicsr.utils.options.parse_options", "basicsr.utils.make_exp_dirs", "os.path.join", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.get_root_logger.info", "sorted", "basicsr.models.build_model", "basicsr.utils.get_env_info", "basicsr.utils.options.dict2str", "opt[].items", "basicsr.data.build_dataset", "basicsr.data.build_dataloader", "basicsr.utils.get_root_logger.info", "test_loaders.append", "basicsr.utils.get_root_logger.info", "basicsr.models.build_model.validation", "basicsr.utils.get_time_str", "len"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.options.parse_options", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.make_exp_dirs", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.models.__init__.build_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_env_info", "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.dict2str", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataset", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataloader", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.validation", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.get_time_str"], ["def", "test_pipeline", "(", "root_path", ")", ":", "\n", "# parse options, set distributed setting, set ramdom seed", "\n", "    ", "opt", "=", "parse_options", "(", "root_path", ",", "is_train", "=", "False", ")", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# torch.backends.cudnn.deterministic = True", "\n", "\n", "# mkdir and initialize loggers", "\n", "make_exp_dirs", "(", "opt", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "opt", "[", "'path'", "]", "[", "'log'", "]", ",", "f\"test_{opt['name']}_{get_time_str()}.log\"", ")", "\n", "logger", "=", "get_root_logger", "(", "logger_name", "=", "'basicsr'", ",", "log_level", "=", "logging", ".", "INFO", ",", "log_file", "=", "log_file", ")", "\n", "logger", ".", "info", "(", "get_env_info", "(", ")", ")", "\n", "logger", ".", "info", "(", "dict2str", "(", "opt", ")", ")", "\n", "\n", "# create test dataset and dataloader", "\n", "test_loaders", "=", "[", "]", "\n", "for", "phase", ",", "dataset_opt", "in", "sorted", "(", "opt", "[", "'datasets'", "]", ".", "items", "(", ")", ")", ":", "\n", "        ", "test_set", "=", "build_dataset", "(", "dataset_opt", ")", "\n", "test_loader", "=", "build_dataloader", "(", "\n", "test_set", ",", "dataset_opt", ",", "num_gpu", "=", "opt", "[", "'num_gpu'", "]", ",", "dist", "=", "opt", "[", "'dist'", "]", ",", "sampler", "=", "None", ",", "seed", "=", "opt", "[", "'manual_seed'", "]", ")", "\n", "logger", ".", "info", "(", "f\"Number of test images in {dataset_opt['name']}: {len(test_set)}\"", ")", "\n", "test_loaders", ".", "append", "(", "test_loader", ")", "\n", "\n", "# create model", "\n", "", "model", "=", "build_model", "(", "opt", ")", "\n", "\n", "for", "test_loader", "in", "test_loaders", ":", "\n", "        ", "test_set_name", "=", "test_loader", ".", "dataset", ".", "opt", "[", "'name'", "]", "\n", "logger", ".", "info", "(", "f'Testing {test_set_name}...'", ")", "\n", "model", ".", "validation", "(", "test_loader", ",", "current_iter", "=", "opt", "[", "'name'", "]", ",", "tb_logger", "=", "None", ",", "save_img", "=", "opt", "[", "'val'", "]", "[", "'save_img'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.download_util.download_file_from_google_drive": [[8, 37], ["requests.Session", "requests.Session.get", "download_util.get_confirm_token", "requests.Session.get", "download_util.save_response_content", "requests.Session.get", "int", "session.get.headers[].split"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.download_util.get_confirm_token", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.download_util.save_response_content", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["def", "download_file_from_google_drive", "(", "file_id", ",", "save_path", ")", ":", "\n", "    ", "\"\"\"Download files from google drive.\n\n    Ref:\n    https://stackoverflow.com/questions/25010369/wget-curl-large-file-from-google-drive  # noqa E501\n\n    Args:\n        file_id (str): File id.\n        save_path (str): Save path.\n    \"\"\"", "\n", "\n", "session", "=", "requests", ".", "Session", "(", ")", "\n", "URL", "=", "'https://docs.google.com/uc?export=download'", "\n", "params", "=", "{", "'id'", ":", "file_id", "}", "\n", "\n", "response", "=", "session", ".", "get", "(", "URL", ",", "params", "=", "params", ",", "stream", "=", "True", ")", "\n", "token", "=", "get_confirm_token", "(", "response", ")", "\n", "if", "token", ":", "\n", "        ", "params", "[", "'confirm'", "]", "=", "token", "\n", "response", "=", "session", ".", "get", "(", "URL", ",", "params", "=", "params", ",", "stream", "=", "True", ")", "\n", "\n", "# get file size", "\n", "", "response_file_size", "=", "session", ".", "get", "(", "URL", ",", "params", "=", "params", ",", "stream", "=", "True", ",", "headers", "=", "{", "'Range'", ":", "'bytes=0-2'", "}", ")", "\n", "if", "'Content-Range'", "in", "response_file_size", ".", "headers", ":", "\n", "        ", "file_size", "=", "int", "(", "response_file_size", ".", "headers", "[", "'Content-Range'", "]", ".", "split", "(", "'/'", ")", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "file_size", "=", "None", "\n", "\n", "", "save_response_content", "(", "response", ",", "save_path", ",", "file_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.download_util.get_confirm_token": [[39, 44], ["response.cookies.items", "key.startswith"], "function", ["None"], ["", "def", "get_confirm_token", "(", "response", ")", ":", "\n", "    ", "for", "key", ",", "value", "in", "response", ".", "cookies", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", ".", "startswith", "(", "'download_warning'", ")", ":", "\n", "            ", "return", "value", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.download_util.save_response_content": [[46, 65], ["tqdm.tqdm", "misc.sizeof_fmt", "open", "response.iter_content", "tqdm.tqdm.close", "math.ceil", "tqdm.tqdm.update", "tqdm.tqdm.set_description", "f.write", "misc.sizeof_fmt"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.sizeof_fmt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.sizeof_fmt"], ["", "def", "save_response_content", "(", "response", ",", "destination", ",", "file_size", "=", "None", ",", "chunk_size", "=", "32768", ")", ":", "\n", "    ", "if", "file_size", "is", "not", "None", ":", "\n", "        ", "pbar", "=", "tqdm", "(", "total", "=", "math", ".", "ceil", "(", "file_size", "/", "chunk_size", ")", ",", "unit", "=", "'chunk'", ")", "\n", "\n", "readable_file_size", "=", "sizeof_fmt", "(", "file_size", ")", "\n", "", "else", ":", "\n", "        ", "pbar", "=", "None", "\n", "\n", "", "with", "open", "(", "destination", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "downloaded_size", "=", "0", "\n", "for", "chunk", "in", "response", ".", "iter_content", "(", "chunk_size", ")", ":", "\n", "            ", "downloaded_size", "+=", "chunk_size", "\n", "if", "pbar", "is", "not", "None", ":", "\n", "                ", "pbar", ".", "update", "(", "1", ")", "\n", "pbar", ".", "set_description", "(", "f'Download {sizeof_fmt(downloaded_size)} '", "f'/ {readable_file_size}'", ")", "\n", "", "if", "chunk", ":", "# filter out keep-alive new chunks", "\n", "                ", "f", ".", "write", "(", "chunk", ")", "\n", "", "", "if", "pbar", "is", "not", "None", ":", "\n", "            ", "pbar", ".", "close", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.ordered_yaml": [[12, 35], ["Dumper.add_representer", "Loader.add_constructor", "dumper.represent_dict", "collections.OrderedDict", "data.items", "loader.construct_pairs"], "function", ["None"], ["def", "ordered_yaml", "(", ")", ":", "\n", "    ", "\"\"\"Support OrderedDict for yaml.\n\n    Returns:\n        yaml Loader and Dumper.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "from", "yaml", "import", "CDumper", "as", "Dumper", "\n", "from", "yaml", "import", "CLoader", "as", "Loader", "\n", "", "except", "ImportError", ":", "\n", "        ", "from", "yaml", "import", "Dumper", ",", "Loader", "\n", "\n", "", "_mapping_tag", "=", "yaml", ".", "resolver", ".", "BaseResolver", ".", "DEFAULT_MAPPING_TAG", "\n", "\n", "def", "dict_representer", "(", "dumper", ",", "data", ")", ":", "\n", "        ", "return", "dumper", ".", "represent_dict", "(", "data", ".", "items", "(", ")", ")", "\n", "\n", "", "def", "dict_constructor", "(", "loader", ",", "node", ")", ":", "\n", "        ", "return", "OrderedDict", "(", "loader", ".", "construct_pairs", "(", "node", ")", ")", "\n", "\n", "", "Dumper", ".", "add_representer", "(", "OrderedDict", ",", "dict_representer", ")", "\n", "Loader", ".", "add_constructor", "(", "_mapping_tag", ",", "dict_constructor", ")", "\n", "return", "Loader", ",", "Dumper", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.parse": [[37, 96], ["opt[].items", "opt[].items", "open", "options.ordered_yaml", "yaml.load", "torch.cuda.device_count", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "opt[].startswith", "phase.split", "dataset.get", "os.path.expanduser", "dataset.get", "os.path.expanduser", "os.path.expanduser"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.options.ordered_yaml", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "def", "parse", "(", "opt_path", ",", "root_path", ",", "is_train", "=", "True", ",", "debug", "=", "False", ")", ":", "\n", "    ", "\"\"\"Parse option file.\n\n    Args:\n        opt_path (str): Option file path.\n        is_train (str): Indicate whether in training or not. Default: True.\n\n    Returns:\n        (dict): Options.\n    \"\"\"", "\n", "with", "open", "(", "opt_path", ",", "mode", "=", "'r'", ")", "as", "f", ":", "\n", "        ", "Loader", ",", "_", "=", "ordered_yaml", "(", ")", "\n", "opt", "=", "yaml", ".", "load", "(", "f", ",", "Loader", "=", "Loader", ")", "\n", "", "if", "debug", "and", "not", "opt", "[", "'name'", "]", ".", "startswith", "(", "'debug'", ")", ":", "\n", "        ", "opt", "[", "'name'", "]", "=", "'debug_'", "+", "opt", "[", "'name'", "]", "\n", "\n", "", "opt", "[", "'is_train'", "]", "=", "is_train", "\n", "\n", "if", "opt", "[", "'num_gpu'", "]", "==", "'auto'", ":", "\n", "        ", "opt", "[", "'num_gpu'", "]", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "\n", "# datasets", "\n", "", "for", "phase", ",", "dataset", "in", "opt", "[", "'datasets'", "]", ".", "items", "(", ")", ":", "\n", "# for several datasets, e.g., test_1, test_2", "\n", "        ", "phase", "=", "phase", ".", "split", "(", "'_'", ")", "[", "0", "]", "\n", "dataset", "[", "'phase'", "]", "=", "phase", "\n", "if", "'scale'", "in", "opt", ":", "\n", "            ", "dataset", "[", "'scale'", "]", "=", "opt", "[", "'scale'", "]", "\n", "", "if", "dataset", ".", "get", "(", "'dataroot_gt'", ")", "is", "not", "None", ":", "\n", "            ", "dataset", "[", "'dataroot_gt'", "]", "=", "osp", ".", "expanduser", "(", "dataset", "[", "'dataroot_gt'", "]", ")", "\n", "", "if", "dataset", ".", "get", "(", "'dataroot_lq'", ")", "is", "not", "None", ":", "\n", "            ", "dataset", "[", "'dataroot_lq'", "]", "=", "osp", ".", "expanduser", "(", "dataset", "[", "'dataroot_lq'", "]", ")", "\n", "\n", "# paths", "\n", "", "", "for", "key", ",", "val", "in", "opt", "[", "'path'", "]", ".", "items", "(", ")", ":", "\n", "        ", "if", "(", "val", "is", "not", "None", ")", "and", "(", "'resume_state'", "in", "key", "or", "'pretrain_network'", "in", "key", ")", ":", "\n", "            ", "opt", "[", "'path'", "]", "[", "key", "]", "=", "osp", ".", "expanduser", "(", "val", ")", "\n", "\n", "", "", "if", "is_train", ":", "\n", "        ", "experiments_root", "=", "osp", ".", "join", "(", "root_path", ",", "'experiments'", ",", "opt", "[", "'name'", "]", ")", "\n", "opt", "[", "'path'", "]", "[", "'experiments_root'", "]", "=", "experiments_root", "\n", "opt", "[", "'path'", "]", "[", "'models'", "]", "=", "osp", ".", "join", "(", "experiments_root", ",", "'models'", ")", "\n", "opt", "[", "'path'", "]", "[", "'training_states'", "]", "=", "osp", ".", "join", "(", "experiments_root", ",", "'training_states'", ")", "\n", "opt", "[", "'path'", "]", "[", "'log'", "]", "=", "experiments_root", "\n", "opt", "[", "'path'", "]", "[", "'visualization'", "]", "=", "osp", ".", "join", "(", "experiments_root", ",", "'visualization'", ")", "\n", "\n", "# change some options for debug mode", "\n", "if", "'debug'", "in", "opt", "[", "'name'", "]", ":", "\n", "            ", "if", "'val'", "in", "opt", ":", "\n", "                ", "opt", "[", "'val'", "]", "[", "'val_freq'", "]", "=", "8", "\n", "", "opt", "[", "'logger'", "]", "[", "'print_freq'", "]", "=", "1", "\n", "opt", "[", "'logger'", "]", "[", "'save_checkpoint_freq'", "]", "=", "8", "\n", "", "", "else", ":", "# test", "\n", "        ", "results_root", "=", "osp", ".", "join", "(", "root_path", ",", "'results'", ",", "opt", "[", "'name'", "]", ")", "\n", "opt", "[", "'path'", "]", "[", "'results_root'", "]", "=", "results_root", "\n", "opt", "[", "'path'", "]", "[", "'log'", "]", "=", "results_root", "\n", "opt", "[", "'path'", "]", "[", "'visualization'", "]", "=", "osp", ".", "join", "(", "results_root", ",", "'visualization'", ")", "\n", "\n", "", "return", "opt", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.dict2str": [[98, 117], ["opt.items", "isinstance", "options.dict2str", "str"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.options.dict2str"], ["", "def", "dict2str", "(", "opt", ",", "indent_level", "=", "1", ")", ":", "\n", "    ", "\"\"\"dict to string for printing options.\n\n    Args:\n        opt (dict): Option dict.\n        indent_level (int): Indent level. Default: 1.\n\n    Return:\n        (str): Option string for printing.\n    \"\"\"", "\n", "msg", "=", "'\\n'", "\n", "for", "k", ",", "v", "in", "opt", ".", "items", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "v", ",", "dict", ")", ":", "\n", "            ", "msg", "+=", "' '", "*", "(", "indent_level", "*", "2", ")", "+", "k", "+", "':['", "\n", "msg", "+=", "dict2str", "(", "v", ",", "indent_level", "+", "1", ")", "\n", "msg", "+=", "' '", "*", "(", "indent_level", "*", "2", ")", "+", "']\\n'", "\n", "", "else", ":", "\n", "            ", "msg", "+=", "' '", "*", "(", "indent_level", "*", "2", ")", "+", "k", "+", "': '", "+", "str", "(", "v", ")", "+", "'\\n'", "\n", "", "", "return", "msg", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.parse_options": [[119, 151], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "options.parse", "basicsr.utils.dist_util.get_dist_info", "parse.get", "basicsr.utils.set_random_seed", "print", "random.randint", "basicsr.utils.dist_util.init_dist", "basicsr.utils.dist_util.init_dist"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.options.parse", "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.get_dist_info", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.set_random_seed", "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.init_dist", "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.init_dist"], ["", "def", "parse_options", "(", "root_path", ",", "is_train", "=", "True", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-opt'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "help", "=", "'Path to option YAML file.'", ")", "\n", "parser", ".", "add_argument", "(", "'--launcher'", ",", "choices", "=", "[", "'none'", ",", "'pytorch'", ",", "'slurm'", "]", ",", "default", "=", "'none'", ",", "help", "=", "'job launcher'", ")", "\n", "parser", ".", "add_argument", "(", "'--auto_resume'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--debug'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--local_rank'", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "opt", "=", "parse", "(", "args", ".", "opt", ",", "root_path", ",", "is_train", "=", "is_train", ",", "debug", "=", "args", ".", "debug", ")", "\n", "opt", "[", "'auto_resume'", "]", "=", "args", ".", "auto_resume", "\n", "\n", "# distributed settings", "\n", "if", "args", ".", "launcher", "==", "'none'", ":", "\n", "        ", "opt", "[", "'dist'", "]", "=", "False", "\n", "print", "(", "'Disable distributed.'", ",", "flush", "=", "True", ")", "\n", "", "else", ":", "\n", "        ", "opt", "[", "'dist'", "]", "=", "True", "\n", "if", "args", ".", "launcher", "==", "'slurm'", "and", "'dist_params'", "in", "opt", ":", "\n", "            ", "init_dist", "(", "args", ".", "launcher", ",", "**", "opt", "[", "'dist_params'", "]", ")", "\n", "", "else", ":", "\n", "            ", "init_dist", "(", "args", ".", "launcher", ")", "\n", "\n", "", "", "opt", "[", "'rank'", "]", ",", "opt", "[", "'world_size'", "]", "=", "get_dist_info", "(", ")", "\n", "\n", "# random seed", "\n", "seed", "=", "opt", ".", "get", "(", "'manual_seed'", ")", "\n", "if", "seed", "is", "None", ":", "\n", "        ", "seed", "=", "random", ".", "randint", "(", "1", ",", "10000", ")", "\n", "opt", "[", "'manual_seed'", "]", "=", "seed", "\n", "", "set_random_seed", "(", "seed", "+", "opt", "[", "'rank'", "]", ")", "\n", "\n", "return", "opt", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.USMSharp.__init__": [[65, 73], ["super().__init__", "cv2.getGaussianKernel", "torch.FloatTensor().unsqueeze_", "img_process_util.USMSharp.register_buffer", "torch.FloatTensor", "numpy.dot", "torch.FloatTensor().unsqueeze_.transpose"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "radius", "=", "50", ",", "sigma", "=", "0", ")", ":", "\n", "        ", "super", "(", "USMSharp", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "radius", "%", "2", "==", "0", ":", "\n", "            ", "radius", "+=", "1", "\n", "", "self", ".", "radius", "=", "radius", "\n", "kernel", "=", "cv2", ".", "getGaussianKernel", "(", "radius", ",", "sigma", ")", "\n", "kernel", "=", "torch", ".", "FloatTensor", "(", "np", ".", "dot", "(", "kernel", ",", "kernel", ".", "transpose", "(", ")", ")", ")", ".", "unsqueeze_", "(", "0", ")", "\n", "self", ".", "register_buffer", "(", "'kernel'", ",", "kernel", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.USMSharp.forward": [[74, 84], ["img_process_util.filter2D", "mask.float.float.float", "img_process_util.filter2D", "torch.clip", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D"], ["", "def", "forward", "(", "self", ",", "img", ",", "weight", "=", "0.5", ",", "threshold", "=", "10", ")", ":", "\n", "        ", "blur", "=", "filter2D", "(", "img", ",", "self", ".", "kernel", ")", "\n", "residual", "=", "img", "-", "blur", "\n", "\n", "mask", "=", "torch", ".", "abs", "(", "residual", ")", "*", "255", ">", "threshold", "\n", "mask", "=", "mask", ".", "float", "(", ")", "\n", "soft_mask", "=", "filter2D", "(", "mask", ",", "self", ".", "kernel", ")", "\n", "K", "=", "img", "+", "weight", "*", "residual", "\n", "K", "=", "torch", ".", "clip", "(", "K", ",", "0", ",", "1", ")", "\n", "return", "soft_mask", "*", "K", "+", "(", "1", "-", "soft_mask", ")", "*", "img", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D": [[7, 32], ["kernel.view().repeat().view.size", "img.view.size", "torch.nn.functional.pad", "ValueError", "img.view.size", "kernel.view().repeat().view.size", "img.view.view", "kernel.view().repeat().view.view", "torch.nn.functional.conv2d().view", "img.view.view", "kernel.view().repeat().view.view().repeat().view", "torch.nn.functional.conv2d().view", "torch.nn.functional.conv2d", "kernel.view().repeat().view.view().repeat", "torch.nn.functional.conv2d", "kernel.view().repeat().view.view"], "function", ["None"], ["def", "filter2D", "(", "img", ",", "kernel", ")", ":", "\n", "    ", "\"\"\"PyTorch version of cv2.filter2D\n\n    Args:\n        img (Tensor): (b, c, h, w)\n        kernel (Tensor): (b, k, k)\n    \"\"\"", "\n", "k", "=", "kernel", ".", "size", "(", "-", "1", ")", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "img", ".", "size", "(", ")", "\n", "if", "k", "%", "2", "==", "1", ":", "\n", "        ", "img", "=", "F", ".", "pad", "(", "img", ",", "(", "k", "//", "2", ",", "k", "//", "2", ",", "k", "//", "2", ",", "k", "//", "2", ")", ",", "mode", "=", "'reflect'", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wrong kernel size'", ")", "\n", "\n", "", "ph", ",", "pw", "=", "img", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "\n", "if", "kernel", ".", "size", "(", "0", ")", "==", "1", ":", "\n", "# apply the same kenrel to all batch images", "\n", "        ", "img", "=", "img", ".", "view", "(", "b", "*", "c", ",", "1", ",", "ph", ",", "pw", ")", "\n", "kernel", "=", "kernel", ".", "view", "(", "1", ",", "1", ",", "k", ",", "k", ")", "\n", "return", "F", ".", "conv2d", "(", "img", ",", "kernel", ",", "padding", "=", "0", ")", ".", "view", "(", "b", ",", "c", ",", "h", ",", "w", ")", "\n", "", "else", ":", "\n", "        ", "img", "=", "img", ".", "view", "(", "1", ",", "b", "*", "c", ",", "ph", ",", "pw", ")", "\n", "kernel", "=", "kernel", ".", "view", "(", "b", ",", "1", ",", "k", ",", "k", ")", ".", "repeat", "(", "1", ",", "c", ",", "1", ",", "1", ")", ".", "view", "(", "b", "*", "c", ",", "1", ",", "k", ",", "k", ")", "\n", "return", "F", ".", "conv2d", "(", "img", ",", "kernel", ",", "groups", "=", "b", "*", "c", ")", ".", "view", "(", "b", ",", "c", ",", "h", ",", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.usm_sharp": [[34, 61], ["cv2.GaussianBlur", "mask.astype.astype", "cv2.GaussianBlur", "numpy.clip", "numpy.abs"], "function", ["None"], ["", "", "def", "usm_sharp", "(", "img", ",", "weight", "=", "0.5", ",", "radius", "=", "50", ",", "threshold", "=", "10", ")", ":", "\n", "    ", "\"\"\"USM sharpening.\n\n    Input image: I; Blurry image: B.\n    1. K = I + weight * (I - B)\n    2. Mask = 1 if abs(I - B) > threshold, else: 0\n    3. Blur mask:\n    4. Out = Mask * K + (1 - Mask) * I\n\n\n    Args:\n        img (Numpy array): Input image, HWC, BGR; float32, [0, 1].\n        weight (float): Sharp weight. Default: 1.\n        radius (float): Kernel size of Gaussian blur. Default: 50.\n        threshold (int):\n    \"\"\"", "\n", "if", "radius", "%", "2", "==", "0", ":", "\n", "        ", "radius", "+=", "1", "\n", "", "blur", "=", "cv2", ".", "GaussianBlur", "(", "img", ",", "(", "radius", ",", "radius", ")", ",", "0", ")", "\n", "residual", "=", "img", "-", "blur", "\n", "mask", "=", "np", ".", "abs", "(", "residual", ")", "*", "255", ">", "threshold", "\n", "mask", "=", "mask", ".", "astype", "(", "'float32'", ")", "\n", "soft_mask", "=", "cv2", ".", "GaussianBlur", "(", "mask", ",", "(", "radius", ",", "radius", ")", ",", "0", ")", "\n", "\n", "K", "=", "img", "+", "weight", "*", "residual", "\n", "K", "=", "np", ".", "clip", "(", "K", ",", "0", ",", "1", ")", "\n", "return", "soft_mask", "*", "K", "+", "(", "1", "-", "soft_mask", ")", "*", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.init_dist": [[10, 19], ["torch.get_start_method", "torch.set_start_method", "dist_util._init_dist_pytorch", "dist_util._init_dist_slurm", "ValueError"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util._init_dist_pytorch", "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util._init_dist_slurm"], ["def", "init_dist", "(", "launcher", ",", "backend", "=", "'nccl'", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "mp", ".", "get_start_method", "(", "allow_none", "=", "True", ")", "is", "None", ":", "\n", "        ", "mp", ".", "set_start_method", "(", "'spawn'", ")", "\n", "", "if", "launcher", "==", "'pytorch'", ":", "\n", "        ", "_init_dist_pytorch", "(", "backend", ",", "**", "kwargs", ")", "\n", "", "elif", "launcher", "==", "'slurm'", ":", "\n", "        ", "_init_dist_slurm", "(", "backend", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Invalid launcher type: {launcher}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util._init_dist_pytorch": [[21, 26], ["int", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "torch.init_process_group"], "function", ["None"], ["", "", "def", "_init_dist_pytorch", "(", "backend", ",", "**", "kwargs", ")", ":", "\n", "    ", "rank", "=", "int", "(", "os", ".", "environ", "[", "'RANK'", "]", ")", "\n", "num_gpus", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "rank", "%", "num_gpus", ")", "\n", "dist", ".", "init_process_group", "(", "backend", "=", "backend", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util._init_dist_slurm": [[28, 58], ["int", "int", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.device_count", "torch.cuda.set_device", "torch.cuda.set_device", "torch.cuda.set_device", "subprocess.getoutput", "str", "str", "str", "torch.init_process_group", "str"], "function", ["None"], ["", "def", "_init_dist_slurm", "(", "backend", ",", "port", "=", "None", ")", ":", "\n", "    ", "\"\"\"Initialize slurm distributed training environment.\n\n    If argument ``port`` is not specified, then the master port will be system\n    environment variable ``MASTER_PORT``. If ``MASTER_PORT`` is not in system\n    environment variable, then a default port ``29500`` will be used.\n\n    Args:\n        backend (str): Backend of torch.distributed.\n        port (int, optional): Master port. Defaults to None.\n    \"\"\"", "\n", "proc_id", "=", "int", "(", "os", ".", "environ", "[", "'SLURM_PROCID'", "]", ")", "\n", "ntasks", "=", "int", "(", "os", ".", "environ", "[", "'SLURM_NTASKS'", "]", ")", "\n", "node_list", "=", "os", ".", "environ", "[", "'SLURM_NODELIST'", "]", "\n", "num_gpus", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "torch", ".", "cuda", ".", "set_device", "(", "proc_id", "%", "num_gpus", ")", "\n", "addr", "=", "subprocess", ".", "getoutput", "(", "f'scontrol show hostname {node_list} | head -n1'", ")", "\n", "# specify master port", "\n", "if", "port", "is", "not", "None", ":", "\n", "        ", "os", ".", "environ", "[", "'MASTER_PORT'", "]", "=", "str", "(", "port", ")", "\n", "", "elif", "'MASTER_PORT'", "in", "os", ".", "environ", ":", "\n", "        ", "pass", "# use MASTER_PORT in the environment variable", "\n", "", "else", ":", "\n", "# 29500 is torch.distributed default port", "\n", "        ", "os", ".", "environ", "[", "'MASTER_PORT'", "]", "=", "'29500'", "\n", "", "os", ".", "environ", "[", "'MASTER_ADDR'", "]", "=", "addr", "\n", "os", ".", "environ", "[", "'WORLD_SIZE'", "]", "=", "str", "(", "ntasks", ")", "\n", "os", ".", "environ", "[", "'LOCAL_RANK'", "]", "=", "str", "(", "proc_id", "%", "num_gpus", ")", "\n", "os", ".", "environ", "[", "'RANK'", "]", "=", "str", "(", "proc_id", ")", "\n", "dist", ".", "init_process_group", "(", "backend", "=", "backend", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.get_dist_info": [[60, 72], ["torch.is_available", "torch.is_initialized", "torch.get_rank", "torch.get_world_size"], "function", ["None"], ["", "def", "get_dist_info", "(", ")", ":", "\n", "    ", "if", "dist", ".", "is_available", "(", ")", ":", "\n", "        ", "initialized", "=", "dist", ".", "is_initialized", "(", ")", "\n", "", "else", ":", "\n", "        ", "initialized", "=", "False", "\n", "", "if", "initialized", ":", "\n", "        ", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "world_size", "=", "dist", ".", "get_world_size", "(", ")", "\n", "", "else", ":", "\n", "        ", "rank", "=", "0", "\n", "world_size", "=", "1", "\n", "", "return", "rank", ",", "world_size", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.master_only": [[74, 83], ["functools.wraps", "dist_util.get_dist_info", "func"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.get_dist_info"], ["", "def", "master_only", "(", "func", ")", ":", "\n", "\n", "    ", "@", "functools", ".", "wraps", "(", "func", ")", "\n", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "", "", "return", "wrapper", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.flowread": [[7, 43], ["np.fromfile().reshape.astype", "cv2.imread", "numpy.split", "flow_util.dequantize_flow", "IOError", "open", "numpy.fromfile().squeeze", "numpy.fromfile().squeeze", "numpy.fromfile().reshape", "f.read().decode", "IOError", "IOError", "numpy.fromfile", "numpy.fromfile", "numpy.fromfile", "f.read"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.dequantize_flow"], ["def", "flowread", "(", "flow_path", ",", "quantize", "=", "False", ",", "concat_axis", "=", "0", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Read an optical flow map.\n\n    Args:\n        flow_path (ndarray or str): Flow path.\n        quantize (bool): whether to read quantized pair, if set to True,\n            remaining args will be passed to :func:`dequantize_flow`.\n        concat_axis (int): The axis that dx and dy are concatenated,\n            can be either 0 or 1. Ignored if quantize is False.\n\n    Returns:\n        ndarray: Optical flow represented as a (h, w, 2) numpy array\n    \"\"\"", "\n", "if", "quantize", ":", "\n", "        ", "assert", "concat_axis", "in", "[", "0", ",", "1", "]", "\n", "cat_flow", "=", "cv2", ".", "imread", "(", "flow_path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", "\n", "if", "cat_flow", ".", "ndim", "!=", "2", ":", "\n", "            ", "raise", "IOError", "(", "f'{flow_path} is not a valid quantized flow file, '", "f'its dimension is {cat_flow.ndim}.'", ")", "\n", "", "assert", "cat_flow", ".", "shape", "[", "concat_axis", "]", "%", "2", "==", "0", "\n", "dx", ",", "dy", "=", "np", ".", "split", "(", "cat_flow", ",", "2", ",", "axis", "=", "concat_axis", ")", "\n", "flow", "=", "dequantize_flow", "(", "dx", ",", "dy", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "        ", "with", "open", "(", "flow_path", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "try", ":", "\n", "                ", "header", "=", "f", ".", "read", "(", "4", ")", ".", "decode", "(", "'utf-8'", ")", "\n", "", "except", "Exception", ":", "\n", "                ", "raise", "IOError", "(", "f'Invalid flow file: {flow_path}'", ")", "\n", "", "else", ":", "\n", "                ", "if", "header", "!=", "'PIEH'", ":", "\n", "                    ", "raise", "IOError", "(", "f'Invalid flow file: {flow_path}, '", "'header does not contain PIEH'", ")", "\n", "\n", "", "", "w", "=", "np", ".", "fromfile", "(", "f", ",", "np", ".", "int32", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "h", "=", "np", ".", "fromfile", "(", "f", ",", "np", ".", "int32", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "flow", "=", "np", ".", "fromfile", "(", "f", ",", "np", ".", "float32", ",", "w", "*", "h", "*", "2", ")", ".", "reshape", "(", "(", "h", ",", "w", ",", "2", ")", ")", "\n", "\n", "", "", "return", "flow", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.flowwrite": [[45, 74], ["flow_util.quantize_flow", "numpy.concatenate", "os.makedirs", "cv2.imwrite", "open", "f.write", "numpy.array().tofile", "flow.astype.astype", "flow.astype.tofile", "f.flush", "os.path.dirname", "numpy.array"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.quantize_flow", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite"], ["", "def", "flowwrite", "(", "flow", ",", "filename", ",", "quantize", "=", "False", ",", "concat_axis", "=", "0", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Write optical flow to file.\n\n    If the flow is not quantized, it will be saved as a .flo file losslessly,\n    otherwise a jpeg image which is lossy but of much smaller size. (dx and dy\n    will be concatenated horizontally into a single image if quantize is True.)\n\n    Args:\n        flow (ndarray): (h, w, 2) array of optical flow.\n        filename (str): Output filepath.\n        quantize (bool): Whether to quantize the flow and save it to 2 jpeg\n            images. If set to True, remaining args will be passed to\n            :func:`quantize_flow`.\n        concat_axis (int): The axis that dx and dy are concatenated,\n            can be either 0 or 1. Ignored if quantize is False.\n    \"\"\"", "\n", "if", "not", "quantize", ":", "\n", "        ", "with", "open", "(", "filename", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "f", ".", "write", "(", "'PIEH'", ".", "encode", "(", "'utf-8'", ")", ")", "\n", "np", ".", "array", "(", "[", "flow", ".", "shape", "[", "1", "]", ",", "flow", ".", "shape", "[", "0", "]", "]", ",", "dtype", "=", "np", ".", "int32", ")", ".", "tofile", "(", "f", ")", "\n", "flow", "=", "flow", ".", "astype", "(", "np", ".", "float32", ")", "\n", "flow", ".", "tofile", "(", "f", ")", "\n", "f", ".", "flush", "(", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "concat_axis", "in", "[", "0", ",", "1", "]", "\n", "dx", ",", "dy", "=", "quantize_flow", "(", "flow", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "dxdy", "=", "np", ".", "concatenate", "(", "(", "dx", ",", "dy", ")", ",", "axis", "=", "concat_axis", ")", "\n", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "filename", ")", ",", "exist_ok", "=", "True", ")", "\n", "cv2", ".", "imwrite", "(", "filename", ",", "dxdy", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.quantize_flow": [[76, 100], ["tuple", "flow_util.quantize"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.quantize"], ["", "", "def", "quantize_flow", "(", "flow", ",", "max_val", "=", "0.02", ",", "norm", "=", "True", ")", ":", "\n", "    ", "\"\"\"Quantize flow to [0, 255].\n\n    After this step, the size of flow will be much smaller, and can be\n    dumped as jpeg images.\n\n    Args:\n        flow (ndarray): (h, w, 2) array of optical flow.\n        max_val (float): Maximum value of flow, values beyond\n                        [-max_val, max_val] will be truncated.\n        norm (bool): Whether to divide flow values by image width/height.\n\n    Returns:\n        tuple[ndarray]: Quantized dx and dy.\n    \"\"\"", "\n", "h", ",", "w", ",", "_", "=", "flow", ".", "shape", "\n", "dx", "=", "flow", "[", "...", ",", "0", "]", "\n", "dy", "=", "flow", "[", "...", ",", "1", "]", "\n", "if", "norm", ":", "\n", "        ", "dx", "=", "dx", "/", "w", "# avoid inplace operations", "\n", "dy", "=", "dy", "/", "h", "\n", "# use 255 levels instead of 256 to make sure 0 is 0 after dequantization.", "\n", "", "flow_comps", "=", "[", "quantize", "(", "d", ",", "-", "max_val", ",", "max_val", ",", "255", ",", "np", ".", "uint8", ")", "for", "d", "in", "[", "dx", ",", "dy", "]", "]", "\n", "return", "tuple", "(", "flow_comps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.dequantize_flow": [[102, 124], ["numpy.dstack", "flow_util.dequantize"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.dequantize"], ["", "def", "dequantize_flow", "(", "dx", ",", "dy", ",", "max_val", "=", "0.02", ",", "denorm", "=", "True", ")", ":", "\n", "    ", "\"\"\"Recover from quantized flow.\n\n    Args:\n        dx (ndarray): Quantized dx.\n        dy (ndarray): Quantized dy.\n        max_val (float): Maximum value used when quantizing.\n        denorm (bool): Whether to multiply flow values with width/height.\n\n    Returns:\n        ndarray: Dequantized flow.\n    \"\"\"", "\n", "assert", "dx", ".", "shape", "==", "dy", ".", "shape", "\n", "assert", "dx", ".", "ndim", "==", "2", "or", "(", "dx", ".", "ndim", "==", "3", "and", "dx", ".", "shape", "[", "-", "1", "]", "==", "1", ")", "\n", "\n", "dx", ",", "dy", "=", "[", "dequantize", "(", "d", ",", "-", "max_val", ",", "max_val", ",", "255", ")", "for", "d", "in", "[", "dx", ",", "dy", "]", "]", "\n", "\n", "if", "denorm", ":", "\n", "        ", "dx", "*=", "dx", ".", "shape", "[", "1", "]", "\n", "dy", "*=", "dx", ".", "shape", "[", "0", "]", "\n", "", "flow", "=", "np", ".", "dstack", "(", "(", "dx", ",", "dy", ")", ")", "\n", "return", "flow", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.quantize": [[126, 148], ["numpy.minimum", "ValueError", "ValueError", "numpy.clip", "numpy.floor().astype", "isinstance", "numpy.floor", "numpy.np.uint8"], "function", ["None"], ["", "def", "quantize", "(", "arr", ",", "min_val", ",", "max_val", ",", "levels", ",", "dtype", "=", "np", ".", "int64", ")", ":", "\n", "    ", "\"\"\"Quantize an array of (-inf, inf) to [0, levels-1].\n\n    Args:\n        arr (ndarray): Input array.\n        min_val (scalar): Minimum value to be clipped.\n        max_val (scalar): Maximum value to be clipped.\n        levels (int): Quantization levels.\n        dtype (np.type): The type of the quantized array.\n\n    Returns:\n        tuple: Quantized array.\n    \"\"\"", "\n", "if", "not", "(", "isinstance", "(", "levels", ",", "int", ")", "and", "levels", ">", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'levels must be a positive integer, but got {levels}'", ")", "\n", "", "if", "min_val", ">=", "max_val", ":", "\n", "        ", "raise", "ValueError", "(", "f'min_val ({min_val}) must be smaller than max_val ({max_val})'", ")", "\n", "\n", "", "arr", "=", "np", ".", "clip", "(", "arr", ",", "min_val", ",", "max_val", ")", "-", "min_val", "\n", "quantized_arr", "=", "np", ".", "minimum", "(", "np", ".", "floor", "(", "levels", "*", "arr", "/", "(", "max_val", "-", "min_val", ")", ")", ".", "astype", "(", "dtype", ")", ",", "levels", "-", "1", ")", "\n", "\n", "return", "quantized_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.flow_util.dequantize": [[150, 171], ["ValueError", "ValueError", "isinstance"], "function", ["None"], ["", "def", "dequantize", "(", "arr", ",", "min_val", ",", "max_val", ",", "levels", ",", "dtype", "=", "np", ".", "float64", ")", ":", "\n", "    ", "\"\"\"Dequantize an array.\n\n    Args:\n        arr (ndarray): Input array.\n        min_val (scalar): Minimum value to be clipped.\n        max_val (scalar): Maximum value to be clipped.\n        levels (int): Quantization levels.\n        dtype (np.type): The type of the dequantized array.\n\n    Returns:\n        tuple: Dequantized array.\n    \"\"\"", "\n", "if", "not", "(", "isinstance", "(", "levels", ",", "int", ")", "and", "levels", ">", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'levels must be a positive integer, but got {levels}'", ")", "\n", "", "if", "min_val", ">=", "max_val", ":", "\n", "        ", "raise", "ValueError", "(", "f'min_val ({min_val}) must be smaller than max_val ({max_val})'", ")", "\n", "\n", "", "dequantized_arr", "=", "(", "arr", "+", "0.5", ")", ".", "astype", "(", "dtype", ")", "*", "(", "max_val", "-", "min_val", ")", "/", "levels", "+", "min_val", "\n", "\n", "return", "dequantized_arr", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.rgb_to_ycbcr_jpeg.__init__": [[53, 59], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "numpy.array", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "rgb_to_ycbcr_jpeg", ",", "self", ")", ".", "__init__", "(", ")", "\n", "matrix", "=", "np", ".", "array", "(", "[", "[", "0.299", ",", "0.587", ",", "0.114", "]", ",", "[", "-", "0.168736", ",", "-", "0.331264", ",", "0.5", "]", ",", "[", "0.5", ",", "-", "0.418688", ",", "-", "0.081312", "]", "]", ",", "\n", "dtype", "=", "np", ".", "float32", ")", ".", "T", "\n", "self", ".", "shift", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "0.", ",", "128.", ",", "128.", "]", ")", ")", "\n", "self", ".", "matrix", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "matrix", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.rgb_to_ycbcr_jpeg.forward": [[60, 71], ["image.permute.permute.permute", "result.view", "torch.tensordot", "torch.tensordot", "torch.tensordot", "torch.tensordot"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(Tensor): batch x 3 x height x width\n\n        Returns:\n            Tensor: batch x height x width x 3\n        \"\"\"", "\n", "image", "=", "image", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "result", "=", "torch", ".", "tensordot", "(", "image", ",", "self", ".", "matrix", ",", "dims", "=", "1", ")", "+", "self", ".", "shift", "\n", "return", "result", ".", "view", "(", "image", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.chroma_subsampling.__init__": [[77, 79], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "chroma_subsampling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.chroma_subsampling.forward": [[80, 96], ["image.permute().clone", "torch.nn.functional.avg_pool2d", "torch.nn.functional.avg_pool2d", "torch.nn.functional.avg_pool2d", "torch.nn.functional.avg_pool2d", "cb.permute.permute.permute", "cr.permute.permute.permute", "image_2[].unsqueeze", "image_2[].unsqueeze", "cb.permute.permute.squeeze", "cr.permute.permute.squeeze", "image.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width x 3\n\n        Returns:\n            y(tensor): batch x height x width\n            cb(tensor): batch x height/2 x width/2\n            cr(tensor): batch x height/2 x width/2\n        \"\"\"", "\n", "image_2", "=", "image", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "clone", "(", ")", "\n", "cb", "=", "F", ".", "avg_pool2d", "(", "image_2", "[", ":", ",", "1", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "(", "2", ",", "2", ")", ",", "count_include_pad", "=", "False", ")", "\n", "cr", "=", "F", ".", "avg_pool2d", "(", "image_2", "[", ":", ",", "2", ",", ":", ",", ":", "]", ".", "unsqueeze", "(", "1", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "(", "2", ",", "2", ")", ",", "count_include_pad", "=", "False", ")", "\n", "cb", "=", "cb", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "cr", "=", "cr", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "return", "image", "[", ":", ",", ":", ",", ":", ",", "0", "]", ",", "cb", ".", "squeeze", "(", "3", ")", ",", "cr", ".", "squeeze", "(", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.block_splitting.__init__": [[102, 105], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "block_splitting", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "k", "=", "8", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.block_splitting.forward": [[106, 119], ["image.view", "image.view.permute", "image.view.permute.contiguous().view", "image.view.permute.contiguous"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor:  batch x h*w/64 x h x w\n        \"\"\"", "\n", "height", ",", "_", "=", "image", ".", "shape", "[", "1", ":", "3", "]", "\n", "batch_size", "=", "image", ".", "shape", "[", "0", "]", "\n", "image_reshaped", "=", "image", ".", "view", "(", "batch_size", ",", "height", "//", "self", ".", "k", ",", "self", ".", "k", ",", "-", "1", ",", "self", ".", "k", ")", "\n", "image_transposed", "=", "image_reshaped", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ",", "4", ")", "\n", "return", "image_transposed", ".", "contiguous", "(", ")", ".", "view", "(", "batch_size", ",", "-", "1", ",", "self", ".", "k", ",", "self", ".", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.dct_8x8.__init__": [[125, 133], ["torch.Module.__init__", "numpy.zeros", "itertools.product", "numpy.array", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "range", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.cos", "numpy.cos", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.sqrt", "numpy.outer"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "dct_8x8", ",", "self", ")", ".", "__init__", "(", ")", "\n", "tensor", "=", "np", ".", "zeros", "(", "(", "8", ",", "8", ",", "8", ",", "8", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "x", ",", "y", ",", "u", ",", "v", "in", "itertools", ".", "product", "(", "range", "(", "8", ")", ",", "repeat", "=", "4", ")", ":", "\n", "            ", "tensor", "[", "x", ",", "y", ",", "u", ",", "v", "]", "=", "np", ".", "cos", "(", "(", "2", "*", "x", "+", "1", ")", "*", "u", "*", "np", ".", "pi", "/", "16", ")", "*", "np", ".", "cos", "(", "(", "2", "*", "y", "+", "1", ")", "*", "v", "*", "np", ".", "pi", "/", "16", ")", "\n", "", "alpha", "=", "np", ".", "array", "(", "[", "1.", "/", "np", ".", "sqrt", "(", "2", ")", "]", "+", "[", "1", "]", "*", "7", ")", "\n", "self", ".", "tensor", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "tensor", ")", ".", "float", "(", ")", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "np", ".", "outer", "(", "alpha", ",", "alpha", ")", "*", "0.25", ")", ".", "float", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.dct_8x8.forward": [[134, 146], ["result.view", "torch.tensordot", "torch.tensordot", "torch.tensordot", "torch.tensordot"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "image", "=", "image", "-", "128", "\n", "result", "=", "self", ".", "scale", "*", "torch", ".", "tensordot", "(", "image", ",", "self", ".", "tensor", ",", "dims", "=", "2", ")", "\n", "result", ".", "view", "(", "image", ".", "shape", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.y_quantize.__init__": [[155, 159], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "rounding", ")", ":", "\n", "        ", "super", "(", "y_quantize", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rounding", "=", "rounding", "\n", "self", ".", "y_table", "=", "y_table", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.y_quantize.forward": [[160, 176], ["isinstance", "diffjpeg.y_quantize.rounding", "factor.size", "diffjpeg.y_quantize.float", "diffjpeg.y_quantize.y_table.expand", "factor.view", "diffjpeg.y_quantize.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ",", "factor", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "if", "isinstance", "(", "factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "image", "=", "image", ".", "float", "(", ")", "/", "(", "self", ".", "y_table", "*", "factor", ")", "\n", "", "else", ":", "\n", "            ", "b", "=", "factor", ".", "size", "(", "0", ")", "\n", "table", "=", "self", ".", "y_table", ".", "expand", "(", "b", ",", "1", ",", "8", ",", "8", ")", "*", "factor", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "image", "=", "image", ".", "float", "(", ")", "/", "table", "\n", "", "image", "=", "self", ".", "rounding", "(", "image", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.c_quantize.__init__": [[185, 189], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "rounding", ")", ":", "\n", "        ", "super", "(", "c_quantize", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rounding", "=", "rounding", "\n", "self", ".", "c_table", "=", "c_table", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.c_quantize.forward": [[190, 206], ["isinstance", "diffjpeg.c_quantize.rounding", "factor.size", "diffjpeg.c_quantize.float", "diffjpeg.c_quantize.c_table.expand", "factor.view", "diffjpeg.c_quantize.float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ",", "factor", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "if", "isinstance", "(", "factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "image", "=", "image", ".", "float", "(", ")", "/", "(", "self", ".", "c_table", "*", "factor", ")", "\n", "", "else", ":", "\n", "            ", "b", "=", "factor", ".", "size", "(", "0", ")", "\n", "table", "=", "self", ".", "c_table", ".", "expand", "(", "b", ",", "1", ",", "8", ",", "8", ")", "*", "factor", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "image", "=", "image", ".", "float", "(", ")", "/", "table", "\n", "", "image", "=", "self", ".", "rounding", "(", "image", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.compress_jpeg.__init__": [[215, 221], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "diffjpeg.c_quantize", "diffjpeg.y_quantize", "diffjpeg.rgb_to_ycbcr_jpeg", "diffjpeg.chroma_subsampling", "diffjpeg.block_splitting", "diffjpeg.dct_8x8"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "rounding", "=", "torch", ".", "round", ")", ":", "\n", "        ", "super", "(", "compress_jpeg", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "l1", "=", "nn", ".", "Sequential", "(", "rgb_to_ycbcr_jpeg", "(", ")", ",", "chroma_subsampling", "(", ")", ")", "\n", "self", ".", "l2", "=", "nn", ".", "Sequential", "(", "block_splitting", "(", ")", ",", "dct_8x8", "(", ")", ")", "\n", "self", ".", "c_quantize", "=", "c_quantize", "(", "rounding", "=", "rounding", ")", "\n", "self", ".", "y_quantize", "=", "y_quantize", "(", "rounding", "=", "rounding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.compress_jpeg.forward": [[222, 242], ["diffjpeg.compress_jpeg.l1", "components.keys", "diffjpeg.compress_jpeg.l2", "diffjpeg.compress_jpeg.c_quantize", "diffjpeg.compress_jpeg.y_quantize"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "def", "forward", "(", "self", ",", "image", ",", "factor", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x 3 x height x width\n\n        Returns:\n            dict(tensor): Compressed tensor with batch x h*w/64 x 8 x 8.\n        \"\"\"", "\n", "y", ",", "cb", ",", "cr", "=", "self", ".", "l1", "(", "image", "*", "255", ")", "\n", "components", "=", "{", "'y'", ":", "y", ",", "'cb'", ":", "cb", ",", "'cr'", ":", "cr", "}", "\n", "for", "k", "in", "components", ".", "keys", "(", ")", ":", "\n", "            ", "comp", "=", "self", ".", "l2", "(", "components", "[", "k", "]", ")", "\n", "if", "k", "in", "(", "'cb'", ",", "'cr'", ")", ":", "\n", "                ", "comp", "=", "self", ".", "c_quantize", "(", "comp", ",", "factor", "=", "factor", ")", "\n", "", "else", ":", "\n", "                ", "comp", "=", "self", ".", "y_quantize", "(", "comp", ",", "factor", "=", "factor", ")", "\n", "\n", "", "components", "[", "k", "]", "=", "comp", "\n", "\n", "", "return", "components", "[", "'y'", "]", ",", "components", "[", "'cb'", "]", ",", "components", "[", "'cr'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.y_dequantize.__init__": [[251, 254], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "y_dequantize", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "y_table", "=", "y_table", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.y_dequantize.forward": [[255, 270], ["isinstance", "factor.size", "diffjpeg.y_dequantize.y_table.expand", "factor.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ",", "factor", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "if", "isinstance", "(", "factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "out", "=", "image", "*", "(", "self", ".", "y_table", "*", "factor", ")", "\n", "", "else", ":", "\n", "            ", "b", "=", "factor", ".", "size", "(", "0", ")", "\n", "table", "=", "self", ".", "y_table", ".", "expand", "(", "b", ",", "1", ",", "8", ",", "8", ")", "*", "factor", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "out", "=", "image", "*", "table", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.c_dequantize.__init__": [[276, 279], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "c_dequantize", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "c_table", "=", "c_table", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.c_dequantize.forward": [[280, 295], ["isinstance", "factor.size", "diffjpeg.c_dequantize.c_table.expand", "factor.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ",", "factor", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "if", "isinstance", "(", "factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "out", "=", "image", "*", "(", "self", ".", "c_table", "*", "factor", ")", "\n", "", "else", ":", "\n", "            ", "b", "=", "factor", ".", "size", "(", "0", ")", "\n", "table", "=", "self", ".", "c_table", ".", "expand", "(", "b", ",", "1", ",", "8", ",", "8", ")", "*", "factor", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "out", "=", "image", "*", "table", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.idct_8x8.__init__": [[301, 309], ["torch.Module.__init__", "numpy.array", "torch.Parameter", "torch.Parameter", "numpy.zeros", "itertools.product", "torch.Parameter", "torch.Parameter", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "range", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "numpy.cos", "numpy.cos", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.sqrt", "numpy.outer"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "idct_8x8", ",", "self", ")", ".", "__init__", "(", ")", "\n", "alpha", "=", "np", ".", "array", "(", "[", "1.", "/", "np", ".", "sqrt", "(", "2", ")", "]", "+", "[", "1", "]", "*", "7", ")", "\n", "self", ".", "alpha", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "np", ".", "outer", "(", "alpha", ",", "alpha", ")", ")", ".", "float", "(", ")", ")", "\n", "tensor", "=", "np", ".", "zeros", "(", "(", "8", ",", "8", ",", "8", ",", "8", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "x", ",", "y", ",", "u", ",", "v", "in", "itertools", ".", "product", "(", "range", "(", "8", ")", ",", "repeat", "=", "4", ")", ":", "\n", "            ", "tensor", "[", "x", ",", "y", ",", "u", ",", "v", "]", "=", "np", ".", "cos", "(", "(", "2", "*", "u", "+", "1", ")", "*", "x", "*", "np", ".", "pi", "/", "16", ")", "*", "np", ".", "cos", "(", "(", "2", "*", "v", "+", "1", ")", "*", "y", "*", "np", ".", "pi", "/", "16", ")", "\n", "", "self", ".", "tensor", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "tensor", ")", ".", "float", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.idct_8x8.forward": [[310, 322], ["result.view", "torch.tensordot", "torch.tensordot", "torch.tensordot", "torch.tensordot"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "image", "=", "image", "*", "self", ".", "alpha", "\n", "result", "=", "0.25", "*", "torch", ".", "tensordot", "(", "image", ",", "self", ".", "tensor", ",", "dims", "=", "2", ")", "+", "128", "\n", "result", ".", "view", "(", "image", ".", "shape", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.block_merging.__init__": [[328, 330], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "block_merging", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.block_merging.forward": [[331, 346], ["patches.view", "patches.view.permute", "patches.view.permute.contiguous().view", "patches.view.permute.contiguous"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "patches", ",", "height", ",", "width", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            patches(tensor) batch x height*width/64, height x width\n            height(int)\n            width(int)\n\n        Returns:\n            Tensor: batch x height x width\n        \"\"\"", "\n", "k", "=", "8", "\n", "batch_size", "=", "patches", ".", "shape", "[", "0", "]", "\n", "image_reshaped", "=", "patches", ".", "view", "(", "batch_size", ",", "height", "//", "k", ",", "width", "//", "k", ",", "k", ",", "k", ")", "\n", "image_transposed", "=", "image_reshaped", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ",", "4", ")", "\n", "return", "image_transposed", ".", "contiguous", "(", ")", ".", "view", "(", "batch_size", ",", "height", ",", "width", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.chroma_upsampling.__init__": [[352, 354], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "chroma_upsampling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.chroma_upsampling.forward": [[355, 376], ["diffjpeg.chroma_upsampling.forward.repeat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "y", ",", "cb", ",", "cr", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            y(tensor): y channel image\n            cb(tensor): cb channel\n            cr(tensor): cr channel\n\n        Returns:\n            Tensor: batch x height x width x 3\n        \"\"\"", "\n", "\n", "def", "repeat", "(", "x", ",", "k", "=", "2", ")", ":", "\n", "            ", "height", ",", "width", "=", "x", ".", "shape", "[", "1", ":", "3", "]", "\n", "x", "=", "x", ".", "unsqueeze", "(", "-", "1", ")", "\n", "x", "=", "x", ".", "repeat", "(", "1", ",", "1", ",", "k", ",", "k", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "height", "*", "k", ",", "width", "*", "k", ")", "\n", "return", "x", "\n", "\n", "", "cb", "=", "repeat", "(", "cb", ")", "\n", "cr", "=", "repeat", "(", "cr", ")", "\n", "return", "torch", ".", "cat", "(", "[", "y", ".", "unsqueeze", "(", "3", ")", ",", "cb", ".", "unsqueeze", "(", "3", ")", ",", "cr", ".", "unsqueeze", "(", "3", ")", "]", ",", "dim", "=", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.ycbcr_to_rgb_jpeg.__init__": [[382, 388], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "numpy.array", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "ycbcr_to_rgb_jpeg", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "matrix", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.", ",", "1.402", "]", ",", "[", "1", ",", "-", "0.344136", ",", "-", "0.714136", "]", ",", "[", "1", ",", "1.772", ",", "0", "]", "]", ",", "dtype", "=", "np", ".", "float32", ")", ".", "T", "\n", "self", ".", "shift", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "[", "0", ",", "-", "128.", ",", "-", "128.", "]", ")", ")", "\n", "self", ".", "matrix", "=", "nn", ".", "Parameter", "(", "torch", ".", "from_numpy", "(", "matrix", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.ycbcr_to_rgb_jpeg.forward": [[389, 399], ["torch.tensordot", "torch.tensordot", "torch.tensordot", "torch.tensordot", "torch.tensordot.view().permute", "torch.tensordot.view().permute", "torch.tensordot.view", "torch.tensordot.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image(tensor): batch x height x width x 3\n\n        Returns:\n            Tensor: batch x 3 x height x width\n        \"\"\"", "\n", "result", "=", "torch", ".", "tensordot", "(", "image", "+", "self", ".", "shift", ",", "self", ".", "matrix", ",", "dims", "=", "1", ")", "\n", "return", "result", ".", "view", "(", "image", ".", "shape", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.decompress_jpeg.__init__": [[408, 416], ["torch.Module.__init__", "diffjpeg.c_dequantize", "diffjpeg.y_dequantize", "diffjpeg.idct_8x8", "diffjpeg.block_merging", "diffjpeg.chroma_upsampling", "diffjpeg.ycbcr_to_rgb_jpeg"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "rounding", "=", "torch", ".", "round", ")", ":", "\n", "        ", "super", "(", "decompress_jpeg", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "c_dequantize", "=", "c_dequantize", "(", ")", "\n", "self", ".", "y_dequantize", "=", "y_dequantize", "(", ")", "\n", "self", ".", "idct", "=", "idct_8x8", "(", ")", "\n", "self", ".", "merging", "=", "block_merging", "(", ")", "\n", "self", ".", "chroma", "=", "chroma_upsampling", "(", ")", "\n", "self", ".", "colors", "=", "ycbcr_to_rgb_jpeg", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.decompress_jpeg.forward": [[417, 444], ["components.keys", "diffjpeg.decompress_jpeg.chroma", "diffjpeg.decompress_jpeg.colors", "torch.min", "torch.min", "torch.min", "torch.min", "diffjpeg.decompress_jpeg.idct", "diffjpeg.decompress_jpeg.merging", "torch.max", "torch.max", "torch.max", "torch.max", "diffjpeg.decompress_jpeg.c_dequantize", "diffjpeg.decompress_jpeg.y_dequantize", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "int", "int"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "def", "forward", "(", "self", ",", "y", ",", "cb", ",", "cr", ",", "imgh", ",", "imgw", ",", "factor", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            compressed(dict(tensor)): batch x h*w/64 x 8 x 8\n            imgh(int)\n            imgw(int)\n            factor(float)\n\n        Returns:\n            Tensor: batch x 3 x height x width\n        \"\"\"", "\n", "components", "=", "{", "'y'", ":", "y", ",", "'cb'", ":", "cb", ",", "'cr'", ":", "cr", "}", "\n", "for", "k", "in", "components", ".", "keys", "(", ")", ":", "\n", "            ", "if", "k", "in", "(", "'cb'", ",", "'cr'", ")", ":", "\n", "                ", "comp", "=", "self", ".", "c_dequantize", "(", "components", "[", "k", "]", ",", "factor", "=", "factor", ")", "\n", "height", ",", "width", "=", "int", "(", "imgh", "/", "2", ")", ",", "int", "(", "imgw", "/", "2", ")", "\n", "", "else", ":", "\n", "                ", "comp", "=", "self", ".", "y_dequantize", "(", "components", "[", "k", "]", ",", "factor", "=", "factor", ")", "\n", "height", ",", "width", "=", "imgh", ",", "imgw", "\n", "", "comp", "=", "self", ".", "idct", "(", "comp", ")", "\n", "components", "[", "k", "]", "=", "self", ".", "merging", "(", "comp", ",", "height", ",", "width", ")", "\n", "#", "\n", "", "image", "=", "self", ".", "chroma", "(", "components", "[", "'y'", "]", ",", "components", "[", "'cb'", "]", ",", "components", "[", "'cr'", "]", ")", "\n", "image", "=", "self", ".", "colors", "(", "image", ")", "\n", "\n", "image", "=", "torch", ".", "min", "(", "255", "*", "torch", ".", "ones_like", "(", "image", ")", ",", "torch", ".", "max", "(", "torch", ".", "zeros_like", "(", "image", ")", ",", "image", ")", ")", "\n", "return", "image", "/", "255", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.DiffJPEG.__init__": [[457, 466], ["torch.Module.__init__", "diffjpeg.compress_jpeg", "diffjpeg.decompress_jpeg"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "differentiable", "=", "True", ")", ":", "\n", "        ", "super", "(", "DiffJPEG", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "differentiable", ":", "\n", "            ", "rounding", "=", "diff_round", "\n", "", "else", ":", "\n", "            ", "rounding", "=", "torch", ".", "round", "\n", "\n", "", "self", ".", "compress", "=", "compress_jpeg", "(", "rounding", "=", "rounding", ")", "\n", "self", ".", "decompress", "=", "decompress_jpeg", "(", "rounding", "=", "rounding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.DiffJPEG.forward": [[467, 492], ["isinstance", "torch.nn.functional.pad", "torch.nn.functional.pad", "diffjpeg.DiffJPEG.compress", "diffjpeg.DiffJPEG.decompress", "diffjpeg.quality_to_factor", "range", "torch.nn.functional.pad.size", "quality_to_factor.size", "diffjpeg.quality_to_factor"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.quality_to_factor", "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.quality_to_factor"], ["", "def", "forward", "(", "self", ",", "x", ",", "quality", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (Tensor): Input image, bchw, rgb, [0, 1]\n            quality(float): Quality factor for jpeg compression scheme.\n        \"\"\"", "\n", "factor", "=", "quality", "\n", "if", "isinstance", "(", "factor", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "            ", "factor", "=", "quality_to_factor", "(", "factor", ")", "\n", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "factor", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "factor", "[", "i", "]", "=", "quality_to_factor", "(", "factor", "[", "i", "]", ")", "\n", "", "", "h", ",", "w", "=", "x", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "h_pad", ",", "w_pad", "=", "0", ",", "0", "\n", "# why should use 16", "\n", "if", "h", "%", "16", "!=", "0", ":", "\n", "            ", "h_pad", "=", "16", "-", "h", "%", "16", "\n", "", "if", "w", "%", "16", "!=", "0", ":", "\n", "            ", "w_pad", "=", "16", "-", "w", "%", "16", "\n", "", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "w_pad", ",", "0", ",", "h_pad", ")", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "\n", "y", ",", "cb", ",", "cr", "=", "self", ".", "compress", "(", "x", ",", "factor", "=", "factor", ")", "\n", "recovered", "=", "self", ".", "decompress", "(", "y", ",", "cb", ",", "cr", ",", "(", "h", "+", "h_pad", ")", ",", "(", "w", "+", "w_pad", ")", ",", "factor", "=", "factor", ")", "\n", "recovered", "=", "recovered", "[", ":", ",", ":", ",", "0", ":", "h", ",", "0", ":", "w", "]", "\n", "return", "recovered", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.diff_round": [[26, 30], ["torch.round", "torch.round", "torch.round", "torch.round"], "function", ["None"], ["def", "diff_round", "(", "x", ")", ":", "\n", "    ", "\"\"\" Differentiable rounding function\n    \"\"\"", "\n", "return", "torch", ".", "round", "(", "x", ")", "+", "(", "x", "-", "torch", ".", "round", "(", "x", ")", ")", "**", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.diffjpeg.quality_to_factor": [[32, 46], ["None"], "function", ["None"], ["", "def", "quality_to_factor", "(", "quality", ")", ":", "\n", "    ", "\"\"\" Calculate factor corresponding to quality\n\n    Args:\n        quality(float): Quality for jpeg compression.\n\n    Returns:\n        float: Compression factor.\n    \"\"\"", "\n", "if", "quality", "<", "50", ":", "\n", "        ", "quality", "=", "5000.", "/", "quality", "\n", "", "else", ":", "\n", "        ", "quality", "=", "200.", "-", "quality", "*", "2", "\n", "", "return", "quality", "/", "100.", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.BaseStorageBackend.get": [[13, 16], ["None"], "methods", ["None"], ["@", "abstractmethod", "\n", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.BaseStorageBackend.get_text": [[17, 20], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.MemcachedBackend.__init__": [[32, 46], ["mc.MemcachedClient.GetInstance", "mc.pyvector", "sys.path.append", "ImportError"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "server_list_cfg", ",", "client_cfg", ",", "sys_path", "=", "None", ")", ":", "\n", "        ", "if", "sys_path", "is", "not", "None", ":", "\n", "            ", "import", "sys", "\n", "sys", ".", "path", ".", "append", "(", "sys_path", ")", "\n", "", "try", ":", "\n", "            ", "import", "mc", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please install memcached to enable MemcachedBackend.'", ")", "\n", "\n", "", "self", ".", "server_list_cfg", "=", "server_list_cfg", "\n", "self", ".", "client_cfg", "=", "client_cfg", "\n", "self", ".", "_client", "=", "mc", ".", "MemcachedClient", ".", "GetInstance", "(", "self", ".", "server_list_cfg", ",", "self", ".", "client_cfg", ")", "\n", "# mc.pyvector servers as a point which points to a memory cache", "\n", "self", ".", "_mc_buffer", "=", "mc", ".", "pyvector", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.MemcachedBackend.get": [[47, 53], ["str", "file_client.MemcachedBackend._client.Get", "mc.ConvertBuffer"], "methods", ["None"], ["", "def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "import", "mc", "\n", "self", ".", "_client", ".", "Get", "(", "filepath", ",", "self", ".", "_mc_buffer", ")", "\n", "value_buf", "=", "mc", ".", "ConvertBuffer", "(", "self", ".", "_mc_buffer", ")", "\n", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.MemcachedBackend.get_text": [[54, 56], ["None"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.HardDiskBackend.get": [[61, 66], ["str", "open", "f.read"], "methods", ["None"], ["def", "get", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "with", "open", "(", "filepath", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "value_buf", "=", "f", ".", "read", "(", ")", "\n", "", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.HardDiskBackend.get_text": [[67, 72], ["str", "open", "f.read"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "filepath", "=", "str", "(", "filepath", ")", "\n", "with", "open", "(", "filepath", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "value_buf", "=", "f", ".", "read", "(", ")", "\n", "", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.LmdbBackend.__init__": [[94, 113], ["isinstance", "isinstance", "zip", "isinstance", "len", "len", "lmdb.open", "ImportError", "str", "len", "len", "str"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "db_paths", ",", "client_keys", "=", "'default'", ",", "readonly", "=", "True", ",", "lock", "=", "False", ",", "readahead", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "import", "lmdb", "\n", "", "except", "ImportError", ":", "\n", "            ", "raise", "ImportError", "(", "'Please install lmdb to enable LmdbBackend.'", ")", "\n", "\n", "", "if", "isinstance", "(", "client_keys", ",", "str", ")", ":", "\n", "            ", "client_keys", "=", "[", "client_keys", "]", "\n", "\n", "", "if", "isinstance", "(", "db_paths", ",", "list", ")", ":", "\n", "            ", "self", ".", "db_paths", "=", "[", "str", "(", "v", ")", "for", "v", "in", "db_paths", "]", "\n", "", "elif", "isinstance", "(", "db_paths", ",", "str", ")", ":", "\n", "            ", "self", ".", "db_paths", "=", "[", "str", "(", "db_paths", ")", "]", "\n", "", "assert", "len", "(", "client_keys", ")", "==", "len", "(", "self", ".", "db_paths", ")", ",", "(", "'client_keys and db_paths should have the same length, '", "\n", "f'but received {len(client_keys)} and {len(self.db_paths)}.'", ")", "\n", "\n", "self", ".", "_client", "=", "{", "}", "\n", "for", "client", ",", "path", "in", "zip", "(", "client_keys", ",", "self", ".", "db_paths", ")", ":", "\n", "            ", "self", ".", "_client", "[", "client", "]", "=", "lmdb", ".", "open", "(", "path", ",", "readonly", "=", "readonly", ",", "lock", "=", "lock", ",", "readahead", "=", "readahead", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.LmdbBackend.get": [[114, 127], ["str", "client.begin", "txn.get", "str.encode"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "", "def", "get", "(", "self", ",", "filepath", ",", "client_key", ")", ":", "\n", "        ", "\"\"\"Get values according to the filepath from one lmdb named client_key.\n\n        Args:\n            filepath (str | obj:`Path`): Here, filepath is the lmdb key.\n            client_key (str): Used for distinguishing differnet lmdb envs.\n        \"\"\"", "\n", "filepath", "=", "str", "(", "filepath", ")", "\n", "assert", "client_key", "in", "self", ".", "_client", ",", "(", "f'client_key {client_key} is not '", "'in lmdb clients.'", ")", "\n", "client", "=", "self", ".", "_client", "[", "client_key", "]", "\n", "with", "client", ".", "begin", "(", "write", "=", "False", ")", "as", "txn", ":", "\n", "            ", "value_buf", "=", "txn", ".", "get", "(", "filepath", ".", "encode", "(", "'ascii'", ")", ")", "\n", "", "return", "value_buf", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.LmdbBackend.get_text": [[128, 130], ["None"], "methods", ["None"], ["", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.FileClient.__init__": [[151, 157], ["ValueError", "list", "file_client.FileClient._backends.keys"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["def", "__init__", "(", "self", ",", "backend", "=", "'disk'", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "backend", "not", "in", "self", ".", "_backends", ":", "\n", "            ", "raise", "ValueError", "(", "f'Backend {backend} is not supported. Currently supported ones'", "\n", "f' are {list(self._backends.keys())}'", ")", "\n", "", "self", ".", "backend", "=", "backend", "\n", "self", ".", "client", "=", "self", ".", "_backends", "[", "backend", "]", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.FileClient.get": [[158, 165], ["file_client.FileClient.client.get", "file_client.FileClient.client.get"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "def", "get", "(", "self", ",", "filepath", ",", "client_key", "=", "'default'", ")", ":", "\n", "# client_key is used only for lmdb, where different fileclients have", "\n", "# different lmdb environments.", "\n", "        ", "if", "self", ".", "backend", "==", "'lmdb'", ":", "\n", "            ", "return", "self", ".", "client", ".", "get", "(", "filepath", ",", "client_key", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "client", ".", "get", "(", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.FileClient.get_text": [[166, 168], ["file_client.FileClient.client.get_text"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.file_client.FileClient.get_text"], ["", "", "def", "get_text", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "return", "self", ".", "client", ".", "get_text", "(", "filepath", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.cubic": [[6, 14], ["torch.abs"], "function", ["None"], ["def", "cubic", "(", "x", ")", ":", "\n", "    ", "\"\"\"cubic function used for calculate_weights_indices.\"\"\"", "\n", "absx", "=", "torch", ".", "abs", "(", "x", ")", "\n", "absx2", "=", "absx", "**", "2", "\n", "absx3", "=", "absx", "**", "3", "\n", "return", "(", "1.5", "*", "absx3", "-", "2.5", "*", "absx2", "+", "1", ")", "*", "(", "\n", "(", "absx", "<=", "1", ")", ".", "type_as", "(", "absx", ")", ")", "+", "(", "-", "0.5", "*", "absx3", "+", "2.5", "*", "absx2", "-", "4", "*", "absx", "+", "2", ")", "*", "(", "(", "(", "absx", ">", "1", ")", "*", "\n", "(", "absx", "<=", "2", ")", ")", ".", "type_as", "(", "absx", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.calculate_weights_indices": [[16, 83], ["torch.linspace", "torch.floor", "torch.sum().view", "torch.sum", "weights.narrow.contiguous", "indices.narrow.contiguous", "math.ceil", "torch.floor.view().expand", "torch.linspace().view().expand", "u.view().expand", "matlab_functions.cubic", "torch.sum().view.expand", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "indices.narrow.max", "int", "int", "matlab_functions.cubic", "torch.sum", "indices.narrow.min", "torch.floor.view", "torch.linspace().view", "u.view", "torch.linspace"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.cubic", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.cubic"], ["", "def", "calculate_weights_indices", "(", "in_length", ",", "out_length", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", ":", "\n", "    ", "\"\"\"Calculate weights and indices, used for imresize function.\n\n    Args:\n        in_length (int): Input length.\n        out_length (int): Output length.\n        scale (float): Scale factor.\n        kernel_width (int): Kernel width.\n        antialisaing (bool): Whether to apply anti-aliasing when downsampling.\n    \"\"\"", "\n", "\n", "if", "(", "scale", "<", "1", ")", "and", "antialiasing", ":", "\n", "# Use a modified kernel (larger kernel width) to simultaneously", "\n", "# interpolate and antialias", "\n", "        ", "kernel_width", "=", "kernel_width", "/", "scale", "\n", "\n", "# Output-space coordinates", "\n", "", "x", "=", "torch", ".", "linspace", "(", "1", ",", "out_length", ",", "out_length", ")", "\n", "\n", "# Input-space coordinates. Calculate the inverse mapping such that 0.5", "\n", "# in output space maps to 0.5 in input space, and 0.5 + scale in output", "\n", "# space maps to 1.5 in input space.", "\n", "u", "=", "x", "/", "scale", "+", "0.5", "*", "(", "1", "-", "1", "/", "scale", ")", "\n", "\n", "# What is the left-most pixel that can be involved in the computation?", "\n", "left", "=", "torch", ".", "floor", "(", "u", "-", "kernel_width", "/", "2", ")", "\n", "\n", "# What is the maximum number of pixels that can be involved in the", "\n", "# computation?  Note: it's OK to use an extra pixel here; if the", "\n", "# corresponding weights are all zero, it will be eliminated at the end", "\n", "# of this function.", "\n", "p", "=", "math", ".", "ceil", "(", "kernel_width", ")", "+", "2", "\n", "\n", "# The indices of the input pixels involved in computing the k-th output", "\n", "# pixel are in row k of the indices matrix.", "\n", "indices", "=", "left", ".", "view", "(", "out_length", ",", "1", ")", ".", "expand", "(", "out_length", ",", "p", ")", "+", "torch", ".", "linspace", "(", "0", ",", "p", "-", "1", ",", "p", ")", ".", "view", "(", "1", ",", "p", ")", ".", "expand", "(", "\n", "out_length", ",", "p", ")", "\n", "\n", "# The weights used to compute the k-th output pixel are in row k of the", "\n", "# weights matrix.", "\n", "distance_to_center", "=", "u", ".", "view", "(", "out_length", ",", "1", ")", ".", "expand", "(", "out_length", ",", "p", ")", "-", "indices", "\n", "\n", "# apply cubic kernel", "\n", "if", "(", "scale", "<", "1", ")", "and", "antialiasing", ":", "\n", "        ", "weights", "=", "scale", "*", "cubic", "(", "distance_to_center", "*", "scale", ")", "\n", "", "else", ":", "\n", "        ", "weights", "=", "cubic", "(", "distance_to_center", ")", "\n", "\n", "# Normalize the weights matrix so that each row sums to 1.", "\n", "", "weights_sum", "=", "torch", ".", "sum", "(", "weights", ",", "1", ")", ".", "view", "(", "out_length", ",", "1", ")", "\n", "weights", "=", "weights", "/", "weights_sum", ".", "expand", "(", "out_length", ",", "p", ")", "\n", "\n", "# If a column in weights is all zero, get rid of it. only consider the", "\n", "# first and last column.", "\n", "weights_zero_tmp", "=", "torch", ".", "sum", "(", "(", "weights", "==", "0", ")", ",", "0", ")", "\n", "if", "not", "math", ".", "isclose", "(", "weights_zero_tmp", "[", "0", "]", ",", "0", ",", "rel_tol", "=", "1e-6", ")", ":", "\n", "        ", "indices", "=", "indices", ".", "narrow", "(", "1", ",", "1", ",", "p", "-", "2", ")", "\n", "weights", "=", "weights", ".", "narrow", "(", "1", ",", "1", ",", "p", "-", "2", ")", "\n", "", "if", "not", "math", ".", "isclose", "(", "weights_zero_tmp", "[", "-", "1", "]", ",", "0", ",", "rel_tol", "=", "1e-6", ")", ":", "\n", "        ", "indices", "=", "indices", ".", "narrow", "(", "1", ",", "0", ",", "p", "-", "2", ")", "\n", "weights", "=", "weights", ".", "narrow", "(", "1", ",", "0", ",", "p", "-", "2", ")", "\n", "", "weights", "=", "weights", ".", "contiguous", "(", ")", "\n", "indices", "=", "indices", ".", "contiguous", "(", ")", "\n", "sym_len_s", "=", "-", "indices", ".", "min", "(", ")", "+", "1", "\n", "sym_len_e", "=", "indices", ".", "max", "(", ")", "-", "in_length", "\n", "indices", "=", "indices", "+", "sym_len_s", "-", "1", "\n", "return", "weights", ",", "indices", ",", "int", "(", "sym_len_s", ")", ",", "int", "(", "sym_len_e", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.imresize": [[85, 179], ["torch.no_grad", "img.unsqueeze.size", "matlab_functions.calculate_weights_indices", "matlab_functions.calculate_weights_indices", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_h.size", "range", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_w.size", "range", "torch.from_numpy().float", "math.ceil", "math.ceil", "int", "range", "int", "range", "out_2.transpose.squeeze", "out_2.transpose.numpy", "type", "img.unsqueeze.unsqueeze", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "img_aug[].transpose().mv", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "out_1_aug[].mv", "out_2.transpose.transpose", "torch.from_numpy", "img.unsqueeze.transpose", "sym_patch.size", "sym_patch.size", "img_aug[].transpose", "sym_patch.size", "sym_patch.size"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.calculate_weights_indices", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.calculate_weights_indices"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "imresize", "(", "img", ",", "scale", ",", "antialiasing", "=", "True", ")", ":", "\n", "    ", "\"\"\"imresize function same as MATLAB.\n\n    It now only supports bicubic.\n    The same scale applies for both height and width.\n\n    Args:\n        img (Tensor | Numpy array):\n            Tensor: Input image with shape (c, h, w), [0, 1] range.\n            Numpy: Input image with shape (h, w, c), [0, 1] range.\n        scale (float): Scale factor. The same scale applies for both height\n            and width.\n        antialisaing (bool): Whether to apply anti-aliasing when downsampling.\n            Default: True.\n\n    Returns:\n        Tensor: Output image with shape (c, h, w), [0, 1] range, w/o round.\n    \"\"\"", "\n", "squeeze_flag", "=", "False", "\n", "if", "type", "(", "img", ")", ".", "__module__", "==", "np", ".", "__name__", ":", "# numpy type", "\n", "        ", "numpy_type", "=", "True", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "img", "=", "img", "[", ":", ",", ":", ",", "None", "]", "\n", "squeeze_flag", "=", "True", "\n", "", "img", "=", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "        ", "numpy_type", "=", "False", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "img", "=", "img", ".", "unsqueeze", "(", "0", ")", "\n", "squeeze_flag", "=", "True", "\n", "\n", "", "", "in_c", ",", "in_h", ",", "in_w", "=", "img", ".", "size", "(", ")", "\n", "out_h", ",", "out_w", "=", "math", ".", "ceil", "(", "in_h", "*", "scale", ")", ",", "math", ".", "ceil", "(", "in_w", "*", "scale", ")", "\n", "kernel_width", "=", "4", "\n", "kernel", "=", "'cubic'", "\n", "\n", "# get weights and indices", "\n", "weights_h", ",", "indices_h", ",", "sym_len_hs", ",", "sym_len_he", "=", "calculate_weights_indices", "(", "in_h", ",", "out_h", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "\n", "antialiasing", ")", "\n", "weights_w", ",", "indices_w", ",", "sym_len_ws", ",", "sym_len_we", "=", "calculate_weights_indices", "(", "in_w", ",", "out_w", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "\n", "antialiasing", ")", "\n", "# process H dimension", "\n", "# symmetric copying", "\n", "img_aug", "=", "torch", ".", "FloatTensor", "(", "in_c", ",", "in_h", "+", "sym_len_hs", "+", "sym_len_he", ",", "in_w", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "sym_len_hs", ",", "in_h", ")", ".", "copy_", "(", "img", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", ",", ":", "sym_len_hs", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "0", ",", "sym_len_hs", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", ",", "-", "sym_len_he", ":", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "sym_len_hs", "+", "in_h", ",", "sym_len_he", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_1", "=", "torch", ".", "FloatTensor", "(", "in_c", ",", "out_h", ",", "in_w", ")", "\n", "kernel_width", "=", "weights_h", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_h", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_h", "[", "i", "]", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "in_c", ")", ":", "\n", "            ", "out_1", "[", "j", ",", "i", ",", ":", "]", "=", "img_aug", "[", "j", ",", "idx", ":", "idx", "+", "kernel_width", ",", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "mv", "(", "weights_h", "[", "i", "]", ")", "\n", "\n", "# process W dimension", "\n", "# symmetric copying", "\n", "", "", "out_1_aug", "=", "torch", ".", "FloatTensor", "(", "in_c", ",", "out_h", ",", "in_w", "+", "sym_len_ws", "+", "sym_len_we", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "sym_len_ws", ",", "in_w", ")", ".", "copy_", "(", "out_1", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", ",", ":", "sym_len_ws", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "2", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "2", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "0", ",", "sym_len_ws", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", ",", "-", "sym_len_we", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "2", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "2", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "sym_len_ws", "+", "in_w", ",", "sym_len_we", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_2", "=", "torch", ".", "FloatTensor", "(", "in_c", ",", "out_h", ",", "out_w", ")", "\n", "kernel_width", "=", "weights_w", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_w", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_w", "[", "i", "]", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "in_c", ")", ":", "\n", "            ", "out_2", "[", "j", ",", ":", ",", "i", "]", "=", "out_1_aug", "[", "j", ",", ":", ",", "idx", ":", "idx", "+", "kernel_width", "]", ".", "mv", "(", "weights_w", "[", "i", "]", ")", "\n", "\n", "", "", "if", "squeeze_flag", ":", "\n", "        ", "out_2", "=", "out_2", ".", "squeeze", "(", "0", ")", "\n", "", "if", "numpy_type", ":", "\n", "        ", "out_2", "=", "out_2", ".", "numpy", "(", ")", "\n", "if", "not", "squeeze_flag", ":", "\n", "            ", "out_2", "=", "out_2", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "\n", "", "", "return", "out_2", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.rgb2ycbcr": [[181, 212], ["matlab_functions._convert_input_type_range", "matlab_functions._convert_output_type_range", "numpy.dot", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_input_type_range", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_output_type_range"], ["", "def", "rgb2ycbcr", "(", "img", ",", "y_only", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert a RGB image to YCbCr image.\n\n    This function produces the same results as Matlab's `rgb2ycbcr` function.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `RGB <-> YCrCb`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n        y_only (bool): Whether to only return Y channel. Default: False.\n\n    Returns:\n        ndarray: The converted YCbCr image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "\n", "if", "y_only", ":", "\n", "        ", "out_img", "=", "np", ".", "dot", "(", "img", ",", "[", "65.481", ",", "128.553", ",", "24.966", "]", ")", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "out_img", "=", "np", ".", "matmul", "(", "\n", "img", ",", "[", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", "]", ")", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.bgr2ycbcr": [[214, 245], ["matlab_functions._convert_input_type_range", "matlab_functions._convert_output_type_range", "numpy.dot", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_input_type_range", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_output_type_range"], ["", "def", "bgr2ycbcr", "(", "img", ",", "y_only", "=", "False", ")", ":", "\n", "    ", "\"\"\"Convert a BGR image to YCbCr image.\n\n    The bgr version of rgb2ycbcr.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `BGR <-> YCrCb`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n        y_only (bool): Whether to only return Y channel. Default: False.\n\n    Returns:\n        ndarray: The converted YCbCr image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "\n", "if", "y_only", ":", "\n", "        ", "out_img", "=", "np", ".", "dot", "(", "img", ",", "[", "24.966", ",", "128.553", ",", "65.481", "]", ")", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "out_img", "=", "np", ".", "matmul", "(", "\n", "img", ",", "[", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", "]", ")", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.ycbcr2rgb": [[247, 274], ["matlab_functions._convert_output_type_range", "matlab_functions._convert_input_type_range", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_output_type_range", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_input_type_range"], ["", "def", "ycbcr2rgb", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert a YCbCr image to RGB image.\n\n    This function produces the same results as Matlab's ycbcr2rgb function.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `YCrCb <-> RGB`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n\n    Returns:\n        ndarray: The converted RGB image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "*", "255", "\n", "out_img", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "0.00456621", ",", "0.00456621", ",", "0.00456621", "]", ",", "[", "0", ",", "-", "0.00153632", ",", "0.00791071", "]", ",", "\n", "[", "0.00625893", ",", "-", "0.00318811", ",", "0", "]", "]", ")", "*", "255.0", "+", "[", "-", "222.921", ",", "135.576", ",", "-", "276.836", "]", "# noqa: E126", "\n", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.ycbcr2bgr": [[276, 303], ["matlab_functions._convert_output_type_range", "matlab_functions._convert_input_type_range", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_output_type_range", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_input_type_range"], ["", "def", "ycbcr2bgr", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert a YCbCr image to BGR image.\n\n    The bgr version of ycbcr2rgb.\n    It implements the ITU-R BT.601 conversion for standard-definition\n    television. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion.\n\n    It differs from a similar function in cv2.cvtColor: `YCrCb <-> BGR`.\n    In OpenCV, it implements a JPEG conversion. See more details in\n    https://en.wikipedia.org/wiki/YCbCr#JPEG_conversion.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n\n    Returns:\n        ndarray: The converted BGR image. The output image has the same type\n            and range as input image.\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "_convert_input_type_range", "(", "img", ")", "*", "255", "\n", "out_img", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "0.00456621", ",", "0.00456621", ",", "0.00456621", "]", ",", "[", "0.00791071", ",", "-", "0.00153632", ",", "0", "]", ",", "\n", "[", "0", ",", "-", "0.00318811", ",", "0.00625893", "]", "]", ")", "*", "255.0", "+", "[", "-", "276.836", ",", "135.576", ",", "-", "222.921", "]", "# noqa: E126", "\n", "out_img", "=", "_convert_output_type_range", "(", "out_img", ",", "img_type", ")", "\n", "return", "out_img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_input_type_range": [[305, 330], ["img.astype.astype", "TypeError"], "function", ["None"], ["", "def", "_convert_input_type_range", "(", "img", ")", ":", "\n", "    ", "\"\"\"Convert the type and range of the input image.\n\n    It converts the input image to np.float32 type and range of [0, 1].\n    It is mainly used for pre-processing the input image in colorspace\n    convertion functions such as rgb2ycbcr and ycbcr2rgb.\n\n    Args:\n        img (ndarray): The input image. It accepts:\n            1. np.uint8 type with range [0, 255];\n            2. np.float32 type with range [0, 1].\n\n    Returns:\n        (ndarray): The converted image with type of np.float32 and range of\n            [0, 1].\n    \"\"\"", "\n", "img_type", "=", "img", ".", "dtype", "\n", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "img_type", "==", "np", ".", "float32", ":", "\n", "        ", "pass", "\n", "", "elif", "img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "img", "/=", "255.", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "'The img type should be np.float32 or np.uint8, '", "f'but got {img_type}'", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions._convert_output_type_range": [[332, 360], ["img.round.astype", "TypeError", "img.round.round"], "function", ["None"], ["", "def", "_convert_output_type_range", "(", "img", ",", "dst_type", ")", ":", "\n", "    ", "\"\"\"Convert the type and range of the image according to dst_type.\n\n    It converts the image to desired type and range. If `dst_type` is np.uint8,\n    images will be converted to np.uint8 type with range [0, 255]. If\n    `dst_type` is np.float32, it converts the image to np.float32 type with\n    range [0, 1].\n    It is mainly used for post-processing images in colorspace convertion\n    functions such as rgb2ycbcr and ycbcr2rgb.\n\n    Args:\n        img (ndarray): The image to be converted with np.float32 type and\n            range [0, 255].\n        dst_type (np.uint8 | np.float32): If dst_type is np.uint8, it\n            converts the image to np.uint8 type with range [0, 255]. If\n            dst_type is np.float32, it converts the image to np.float32 type\n            with range [0, 1].\n\n    Returns:\n        (ndarray): The converted image with desired type and range.\n    \"\"\"", "\n", "if", "dst_type", "not", "in", "(", "np", ".", "uint8", ",", "np", ".", "float32", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'The dst_type should be np.float32 or np.uint8, '", "f'but got {dst_type}'", ")", "\n", "", "if", "dst_type", "==", "np", ".", "uint8", ":", "\n", "        ", "img", "=", "img", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "img", "/=", "255.", "\n", "", "return", "img", ".", "astype", "(", "dst_type", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.MessageLogger.__init__": [[23, 32], ["time.time", "logger.get_root_logger"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["def", "__init__", "(", "self", ",", "opt", ",", "start_iter", "=", "1", ",", "tb_logger", "=", "None", ")", ":", "\n", "        ", "self", ".", "exp_name", "=", "opt", "[", "'name'", "]", "\n", "self", ".", "interval", "=", "opt", "[", "'logger'", "]", "[", "'print_freq'", "]", "\n", "self", ".", "start_iter", "=", "start_iter", "\n", "self", ".", "max_iters", "=", "opt", "[", "'train'", "]", "[", "'total_iter'", "]", "\n", "self", ".", "use_tb_logger", "=", "opt", "[", "'logger'", "]", "[", "'use_tb_logger'", "]", "\n", "self", ".", "tb_logger", "=", "tb_logger", "\n", "self", ".", "start_time", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "logger", "=", "get_root_logger", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.MessageLogger.__call__": [[33, 78], ["log_vars.pop", "log_vars.pop", "log_vars.pop", "log_vars.items", "logger.MessageLogger.logger.info", "log_vars.keys", "log_vars.pop", "log_vars.pop", "str", "time.time", "datetime.timedelta", "k.startswith", "logger.MessageLogger.tb_logger.add_scalar", "logger.MessageLogger.tb_logger.add_scalar", "int"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "@", "master_only", "\n", "def", "__call__", "(", "self", ",", "log_vars", ")", ":", "\n", "        ", "\"\"\"Format logging message.\n\n        Args:\n            log_vars (dict): It contains the following keys:\n                epoch (int): Epoch number.\n                iter (int): Current iter.\n                lrs (list): List for learning rates.\n\n                time (float): Iter time.\n                data_time (float): Data time for each iter.\n        \"\"\"", "\n", "# epoch, iter, learning rates", "\n", "epoch", "=", "log_vars", ".", "pop", "(", "'epoch'", ")", "\n", "current_iter", "=", "log_vars", ".", "pop", "(", "'iter'", ")", "\n", "lrs", "=", "log_vars", ".", "pop", "(", "'lrs'", ")", "\n", "\n", "message", "=", "(", "f'[{self.exp_name[:5]}..][epoch:{epoch:3d}, '", "f'iter:{current_iter:8,d}, lr:('", ")", "\n", "for", "v", "in", "lrs", ":", "\n", "            ", "message", "+=", "f'{v:.3e},'", "\n", "", "message", "+=", "')] '", "\n", "\n", "# time and estimated time", "\n", "if", "'time'", "in", "log_vars", ".", "keys", "(", ")", ":", "\n", "            ", "iter_time", "=", "log_vars", ".", "pop", "(", "'time'", ")", "\n", "data_time", "=", "log_vars", ".", "pop", "(", "'data_time'", ")", "\n", "\n", "total_time", "=", "time", ".", "time", "(", ")", "-", "self", ".", "start_time", "\n", "time_sec_avg", "=", "total_time", "/", "(", "current_iter", "-", "self", ".", "start_iter", "+", "1", ")", "\n", "eta_sec", "=", "time_sec_avg", "*", "(", "self", ".", "max_iters", "-", "current_iter", "-", "1", ")", "\n", "eta_str", "=", "str", "(", "datetime", ".", "timedelta", "(", "seconds", "=", "int", "(", "eta_sec", ")", ")", ")", "\n", "message", "+=", "f'[eta: {eta_str}, '", "\n", "message", "+=", "f'time (data): {iter_time:.3f} ({data_time:.3f})] '", "\n", "\n", "# other items, especially losses", "\n", "", "for", "k", ",", "v", "in", "log_vars", ".", "items", "(", ")", ":", "\n", "            ", "message", "+=", "f'{k}: {v:.4e} '", "\n", "# tensorboard logger", "\n", "if", "self", ".", "use_tb_logger", "and", "'debug'", "not", "in", "self", ".", "exp_name", ":", "\n", "                ", "if", "k", ".", "startswith", "(", "'l_'", ")", ":", "\n", "                    ", "self", ".", "tb_logger", ".", "add_scalar", "(", "f'losses/{k}'", ",", "v", ",", "current_iter", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "tb_logger", ".", "add_scalar", "(", "k", ",", "v", ",", "current_iter", ")", "\n", "", "", "", "self", ".", "logger", ".", "info", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.init_tb_logger": [[80, 85], ["SummaryWriter"], "function", ["None"], ["", "", "@", "master_only", "\n", "def", "init_tb_logger", "(", "log_dir", ")", ":", "\n", "    ", "from", "torch", ".", "utils", ".", "tensorboard", "import", "SummaryWriter", "\n", "tb_logger", "=", "SummaryWriter", "(", "log_dir", "=", "log_dir", ")", "\n", "return", "tb_logger", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.init_wandb_logger": [[87, 106], ["logger.get_root_logger", "[].get", "wandb.init", "get_root_logger.info", "get_root_logger.warning", "wandb.util.generate_id"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "@", "master_only", "\n", "def", "init_wandb_logger", "(", "opt", ")", ":", "\n", "    ", "\"\"\"We now only use wandb to sync tensorboard log.\"\"\"", "\n", "import", "wandb", "\n", "logger", "=", "get_root_logger", "(", ")", "\n", "\n", "project", "=", "opt", "[", "'logger'", "]", "[", "'wandb'", "]", "[", "'project'", "]", "\n", "resume_id", "=", "opt", "[", "'logger'", "]", "[", "'wandb'", "]", ".", "get", "(", "'resume_id'", ")", "\n", "if", "resume_id", ":", "\n", "        ", "wandb_id", "=", "resume_id", "\n", "resume", "=", "'allow'", "\n", "logger", ".", "warning", "(", "f'Resume wandb logger with id={wandb_id}.'", ")", "\n", "", "else", ":", "\n", "        ", "wandb_id", "=", "wandb", ".", "util", ".", "generate_id", "(", ")", "\n", "resume", "=", "'never'", "\n", "\n", "", "wandb", ".", "init", "(", "id", "=", "wandb_id", ",", "resume", "=", "resume", ",", "name", "=", "opt", "[", "'name'", "]", ",", "config", "=", "opt", ",", "project", "=", "project", ",", "sync_tensorboard", "=", "True", ")", "\n", "\n", "logger", ".", "info", "(", "f'Use wandb logger with id={wandb_id}; project={project}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger": [[108, 148], ["logging.getLogger", "logging.StreamHandler", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "dist_util.get_dist_info", "logging.Formatter", "logging.getLogger.setLevel", "logging.getLogger.setLevel", "logging.FileHandler", "logging.FileHandler.setFormatter", "logging.FileHandler.setLevel", "logging.getLogger.addHandler", "logging.Formatter"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.get_dist_info"], ["", "def", "get_root_logger", "(", "logger_name", "=", "'basicsr'", ",", "log_level", "=", "logging", ".", "INFO", ",", "log_file", "=", "None", ")", ":", "\n", "    ", "\"\"\"Get the root logger.\n\n    The logger will be initialized if it has not been initialized. By default a\n    StreamHandler will be added. If `log_file` is specified, a FileHandler will\n    also be added.\n\n    Args:\n        logger_name (str): root logger name. Default: 'basicsr'.\n        log_file (str | None): The log filename. If specified, a FileHandler\n            will be added to the root logger.\n        log_level (int): The root logger level. Note that only the process of\n            rank 0 is affected, while other processes will set the level to\n            \"Error\" and be silent most of the time.\n\n    Returns:\n        logging.Logger: The root logger.\n    \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "logger_name", ")", "\n", "# if the logger has been initialized, just return it", "\n", "if", "logger_name", "in", "initialized_logger", ":", "\n", "        ", "return", "logger", "\n", "\n", "", "format_str", "=", "'%(asctime)s %(levelname)s: %(message)s'", "\n", "stream_handler", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "stream_handler", ".", "setFormatter", "(", "logging", ".", "Formatter", "(", "format_str", ")", ")", "\n", "logger", ".", "addHandler", "(", "stream_handler", ")", "\n", "logger", ".", "propagate", "=", "False", "\n", "rank", ",", "_", "=", "get_dist_info", "(", ")", "\n", "if", "rank", "!=", "0", ":", "\n", "        ", "logger", ".", "setLevel", "(", "'ERROR'", ")", "\n", "", "elif", "log_file", "is", "not", "None", ":", "\n", "        ", "logger", ".", "setLevel", "(", "log_level", ")", "\n", "# add file handler", "\n", "file_handler", "=", "logging", ".", "FileHandler", "(", "log_file", ",", "'w'", ")", "\n", "file_handler", ".", "setFormatter", "(", "logging", ".", "Formatter", "(", "format_str", ")", ")", "\n", "file_handler", ".", "setLevel", "(", "log_level", ")", "\n", "logger", ".", "addHandler", "(", "file_handler", ")", "\n", "", "initialized_logger", "[", "logger_name", "]", "=", "True", "\n", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_env_info": [[150, 176], ["None"], "function", ["None"], ["", "def", "get_env_info", "(", ")", ":", "\n", "    ", "\"\"\"Get environment information.\n\n    Currently, only log the software version.\n    \"\"\"", "\n", "import", "torch", "\n", "import", "torchvision", "\n", "\n", "from", "basicsr", ".", "version", "import", "__version__", "\n", "msg", "=", "r\"\"\"\n                ____                _       _____  ____\n               / __ ) ____ _ _____ (_)_____/ ___/ / __ \\\n              / __  |/ __ `// ___// // ___/\\__ \\ / /_/ /\n             / /_/ // /_/ /(__  )/ // /__ ___/ // _, _/\n            /_____/ \\__,_//____//_/ \\___//____//_/ |_|\n     ______                   __   __                 __      __\n    / ____/____   ____   ____/ /  / /   __  __ _____ / /__   / /\n   / / __ / __ \\ / __ \\ / __  /  / /   / / / // ___// //_/  / /\n  / /_/ // /_/ // /_/ // /_/ /  / /___/ /_/ // /__ / /<    /_/\n  \\____/ \\____/ \\____/ \\____/  /_____/\\____/ \\___//_/|_|  (_)\n    \"\"\"", "\n", "msg", "+=", "(", "'\\nVersion Information: '", "\n", "f'\\n\\tBasicSR: {__version__}'", "\n", "f'\\n\\tPyTorch: {torch.__version__}'", "\n", "f'\\n\\tTorchVision: {torchvision.__version__}'", ")", "\n", "return", "msg", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.__init__": [[30, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            name (str): the name of this registry\n        \"\"\"", "\n", "self", ".", "_name", "=", "name", "\n", "self", ".", "_obj_map", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry._do_register": [[38, 42], ["None"], "methods", ["None"], ["", "def", "_do_register", "(", "self", ",", "name", ",", "obj", ")", ":", "\n", "        ", "assert", "(", "name", "not", "in", "self", ".", "_obj_map", ")", ",", "(", "f\"An object named '{name}' was already registered \"", "\n", "f\"in '{self._name}' registry!\"", ")", "\n", "self", ".", "_obj_map", "[", "name", "]", "=", "obj", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.register": [[43, 61], ["registry.Registry._do_register", "registry.Registry._do_register"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry._do_register", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry._do_register"], ["", "def", "register", "(", "self", ",", "obj", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Register the given object under the the name `obj.__name__`.\n        Can be used as either a decorator or not.\n        See docstring of this class for usage.\n        \"\"\"", "\n", "if", "obj", "is", "None", ":", "\n", "# used as a decorator", "\n", "            ", "def", "deco", "(", "func_or_class", ")", ":", "\n", "                ", "name", "=", "func_or_class", ".", "__name__", "\n", "self", ".", "_do_register", "(", "name", ",", "func_or_class", ")", "\n", "return", "func_or_class", "\n", "\n", "", "return", "deco", "\n", "\n", "# used as a function call", "\n", "", "name", "=", "obj", ".", "__name__", "\n", "self", ".", "_do_register", "(", "name", ",", "obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get": [[62, 67], ["registry.Registry._obj_map.get", "KeyError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "def", "get", "(", "self", ",", "name", ")", ":", "\n", "        ", "ret", "=", "self", ".", "_obj_map", ".", "get", "(", "name", ")", "\n", "if", "ret", "is", "None", ":", "\n", "            ", "raise", "KeyError", "(", "f\"No object named '{name}' found in '{self._name}' registry!\"", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.__contains__": [[68, 70], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "name", "in", "self", ".", "_obj_map", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.__iter__": [[71, 73], ["iter", "registry.Registry._obj_map.items"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "_obj_map", ".", "items", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys": [[74, 76], ["registry.Registry._obj_map.keys"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "def", "keys", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_obj_map", ".", "keys", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor": [[8, 35], ["isinstance", "torch.from_numpy", "img_util.img2tensor._totensor"], "function", ["None"], ["def", "img2tensor", "(", "imgs", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", ":", "\n", "    ", "\"\"\"Numpy array to tensor.\n\n    Args:\n        imgs (list[ndarray] | ndarray): Input images.\n        bgr2rgb (bool): Whether to change bgr to rgb.\n        float32 (bool): Whether to change to float32.\n\n    Returns:\n        list[tensor] | tensor: Tensor images. If returned results only have\n            one element, just return tensor.\n    \"\"\"", "\n", "\n", "def", "_totensor", "(", "img", ",", "bgr2rgb", ",", "float32", ")", ":", "\n", "        ", "if", "img", ".", "shape", "[", "2", "]", "==", "3", "and", "bgr2rgb", ":", "\n", "            ", "if", "img", ".", "dtype", "==", "'float64'", ":", "\n", "                ", "img", "=", "img", ".", "astype", "(", "'float32'", ")", "\n", "", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2RGB", ")", "\n", "", "img", "=", "torch", ".", "from_numpy", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "if", "float32", ":", "\n", "            ", "img", "=", "img", ".", "float", "(", ")", "\n", "", "return", "img", "\n", "\n", "", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "        ", "return", "[", "_totensor", "(", "img", ",", "bgr2rgb", ",", "float32", ")", "for", "img", "in", "imgs", "]", "\n", "", "else", ":", "\n", "        ", "return", "_totensor", "(", "imgs", ",", "bgr2rgb", ",", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img": [[37, 94], ["torch.is_tensor", "TypeError", "_tensor.squeeze().float().detach().cpu().clamp_.squeeze().float().detach().cpu().clamp_", "_tensor.squeeze().float().detach().cpu().clamp_.dim", "cv2.cvtColor.astype", "result.append", "len", "torch.is_tensor", "torchvision.utils.make_grid().numpy", "cv2.cvtColor.transpose", "isinstance", "all", "_tensor.squeeze().float().detach().cpu().clamp_.squeeze().float().detach().cpu", "cv2.cvtColor", "_tensor.squeeze().float().detach().cpu().clamp_.numpy", "cv2.cvtColor.transpose", "type", "torchvision.utils.make_grid", "numpy.squeeze", "_tensor.squeeze().float().detach().cpu().clamp_.numpy", "TypeError", "torch.is_tensor", "_tensor.squeeze().float().detach().cpu().clamp_.squeeze().float().detach", "cv2.cvtColor", "int", "_tensor.squeeze().float().detach().cpu().clamp_.squeeze().float", "math.sqrt", "_tensor.squeeze().float().detach().cpu().clamp_.size", "_tensor.squeeze().float().detach().cpu().clamp_.squeeze"], "function", ["None"], ["", "", "def", "tensor2img", "(", "tensor", ",", "rgb2bgr", "=", "True", ",", "out_type", "=", "np", ".", "uint8", ",", "min_max", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "\"\"\"Convert torch Tensors into image numpy arrays.\n\n    After clamping to [min, max], values will be normalized to [0, 1].\n\n    Args:\n        tensor (Tensor or list[Tensor]): Accept shapes:\n            1) 4D mini-batch Tensor of shape (B x 3/1 x H x W);\n            2) 3D Tensor of shape (3/1 x H x W);\n            3) 2D Tensor of shape (H x W).\n            Tensor channel should be in RGB order.\n        rgb2bgr (bool): Whether to change rgb to bgr.\n        out_type (numpy type): output types. If ``np.uint8``, transform outputs\n            to uint8 type with range [0, 255]; otherwise, float type with\n            range [0, 1]. Default: ``np.uint8``.\n        min_max (tuple[int]): min and max values for clamp.\n\n    Returns:\n        (Tensor or list): 3D ndarray of shape (H x W x C) OR 2D ndarray of\n        shape (H x W). The channel order is BGR.\n    \"\"\"", "\n", "if", "not", "(", "torch", ".", "is_tensor", "(", "tensor", ")", "or", "(", "isinstance", "(", "tensor", ",", "list", ")", "and", "all", "(", "torch", ".", "is_tensor", "(", "t", ")", "for", "t", "in", "tensor", ")", ")", ")", ":", "\n", "        ", "raise", "TypeError", "(", "f'tensor or list of tensors expected, got {type(tensor)}'", ")", "\n", "\n", "", "if", "torch", ".", "is_tensor", "(", "tensor", ")", ":", "\n", "        ", "tensor", "=", "[", "tensor", "]", "\n", "", "result", "=", "[", "]", "\n", "for", "_tensor", "in", "tensor", ":", "\n", "        ", "_tensor", "=", "_tensor", ".", "squeeze", "(", "0", ")", ".", "float", "(", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "clamp_", "(", "*", "min_max", ")", "\n", "_tensor", "=", "(", "_tensor", "-", "min_max", "[", "0", "]", ")", "/", "(", "min_max", "[", "1", "]", "-", "min_max", "[", "0", "]", ")", "\n", "\n", "n_dim", "=", "_tensor", ".", "dim", "(", ")", "\n", "if", "n_dim", "==", "4", ":", "\n", "            ", "img_np", "=", "make_grid", "(", "_tensor", ",", "nrow", "=", "int", "(", "math", ".", "sqrt", "(", "_tensor", ".", "size", "(", "0", ")", ")", ")", ",", "normalize", "=", "False", ")", ".", "numpy", "(", ")", "\n", "img_np", "=", "img_np", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "if", "rgb2bgr", ":", "\n", "                ", "img_np", "=", "cv2", ".", "cvtColor", "(", "img_np", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "", "", "elif", "n_dim", "==", "3", ":", "\n", "            ", "img_np", "=", "_tensor", ".", "numpy", "(", ")", "\n", "img_np", "=", "img_np", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "if", "img_np", ".", "shape", "[", "2", "]", "==", "1", ":", "# gray image", "\n", "                ", "img_np", "=", "np", ".", "squeeze", "(", "img_np", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "if", "rgb2bgr", ":", "\n", "                    ", "img_np", "=", "cv2", ".", "cvtColor", "(", "img_np", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "", "", "", "elif", "n_dim", "==", "2", ":", "\n", "            ", "img_np", "=", "_tensor", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'Only support 4D, 3D or 2D tensor. '", "f'But received with dimension: {n_dim}'", ")", "\n", "", "if", "out_type", "==", "np", ".", "uint8", ":", "\n", "# Unlike MATLAB, numpy.unit8() WILL NOT round by default.", "\n", "            ", "img_np", "=", "(", "img_np", "*", "255.0", ")", ".", "round", "(", ")", "\n", "", "img_np", "=", "img_np", ".", "astype", "(", "out_type", ")", "\n", "result", ".", "append", "(", "img_np", ")", "\n", "", "if", "len", "(", "result", ")", "==", "1", ":", "\n", "        ", "result", "=", "result", "[", "0", "]", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img_fast": [[96, 111], ["tensor.squeeze().detach().clamp_().permute", "cv2.cvtColor.type().cpu().numpy", "cv2.cvtColor", "tensor.squeeze().detach().clamp_", "cv2.cvtColor.type().cpu", "tensor.squeeze().detach", "cv2.cvtColor.type", "tensor.squeeze"], "function", ["None"], ["", "def", "tensor2img_fast", "(", "tensor", ",", "rgb2bgr", "=", "True", ",", "min_max", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "\"\"\"This implementation is slightly faster than tensor2img.\n    It now only supports torch tensor with shape (1, c, h, w).\n\n    Args:\n        tensor (Tensor): Now only support torch tensor with (1, c, h, w).\n        rgb2bgr (bool): Whether to change rgb to bgr. Default: True.\n        min_max (tuple[int]): min and max values for clamp.\n    \"\"\"", "\n", "output", "=", "tensor", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "clamp_", "(", "*", "min_max", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "output", "=", "(", "output", "-", "min_max", "[", "0", "]", ")", "/", "(", "min_max", "[", "1", "]", "-", "min_max", "[", "0", "]", ")", "*", "255", "\n", "output", "=", "output", ".", "type", "(", "torch", ".", "uint8", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "rgb2bgr", ":", "\n", "        ", "output", "=", "cv2", ".", "cvtColor", "(", "output", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes": [[113, 132], ["numpy.frombuffer", "cv2.imdecode", "cv2.imdecode.astype"], "function", ["None"], ["", "def", "imfrombytes", "(", "content", ",", "flag", "=", "'color'", ",", "float32", "=", "False", ")", ":", "\n", "    ", "\"\"\"Read an image from bytes.\n\n    Args:\n        content (bytes): Image bytes got from files or other streams.\n        flag (str): Flags specifying the color type of a loaded image,\n            candidates are `color`, `grayscale` and `unchanged`.\n        float32 (bool): Whether to change to float32., If True, will also norm\n            to [0, 1]. Default: False.\n\n    Returns:\n        ndarray: Loaded image array.\n    \"\"\"", "\n", "img_np", "=", "np", ".", "frombuffer", "(", "content", ",", "np", ".", "uint8", ")", "\n", "imread_flags", "=", "{", "'color'", ":", "cv2", ".", "IMREAD_COLOR", ",", "'grayscale'", ":", "cv2", ".", "IMREAD_GRAYSCALE", ",", "'unchanged'", ":", "cv2", ".", "IMREAD_UNCHANGED", "}", "\n", "img", "=", "cv2", ".", "imdecode", "(", "img_np", ",", "imread_flags", "[", "flag", "]", ")", "\n", "if", "float32", ":", "\n", "        ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite": [[134, 151], ["cv2.imwrite", "os.path.abspath", "os.makedirs", "os.path.dirname"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite"], ["", "def", "imwrite", "(", "img", ",", "file_path", ",", "params", "=", "None", ",", "auto_mkdir", "=", "True", ")", ":", "\n", "    ", "\"\"\"Write image to file.\n\n    Args:\n        img (ndarray): Image array to be written.\n        file_path (str): Image file path.\n        params (None or list): Same as opencv's :func:`imwrite` interface.\n        auto_mkdir (bool): If the parent folder of `file_path` does not exist,\n            whether to create it automatically.\n\n    Returns:\n        bool: Successful or not.\n    \"\"\"", "\n", "if", "auto_mkdir", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "dirname", "(", "file_path", ")", ")", "\n", "os", ".", "makedirs", "(", "dir_name", ",", "exist_ok", "=", "True", ")", "\n", "", "return", "cv2", ".", "imwrite", "(", "file_path", ",", "img", ",", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.crop_border": [[153, 170], ["isinstance"], "function", ["None"], ["", "def", "crop_border", "(", "imgs", ",", "crop_border", ")", ":", "\n", "    ", "\"\"\"Crop borders of images.\n\n    Args:\n        imgs (list[ndarray] | ndarray): Images with shape (h, w, c).\n        crop_border (int): Crop border for each end of height and weight.\n\n    Returns:\n        list[ndarray]: Cropped images.\n    \"\"\"", "\n", "if", "crop_border", "==", "0", ":", "\n", "        ", "return", "imgs", "\n", "", "else", ":", "\n", "        ", "if", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "            ", "return", "[", "v", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", ",", "...", "]", "for", "v", "in", "imgs", "]", "\n", "", "else", ":", "\n", "            ", "return", "imgs", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", ",", "...", "]", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.set_random_seed": [[11, 18], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed_all"], "function", ["None"], ["def", "set_random_seed", "(", "seed", ")", ":", "\n", "    ", "\"\"\"Set random seeds.\"\"\"", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed_all", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.get_time_str": [[20, 22], ["time.strftime", "time.localtime"], "function", ["None"], ["", "def", "get_time_str", "(", ")", ":", "\n", "    ", "return", "time", ".", "strftime", "(", "'%Y%m%d_%H%M%S'", ",", "time", ".", "localtime", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.mkdir_and_rename": [[24, 35], ["os.path.exists", "os.makedirs", "print", "os.rename", "misc.get_time_str"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.get_time_str"], ["", "def", "mkdir_and_rename", "(", "path", ")", ":", "\n", "    ", "\"\"\"mkdirs. If path exists, rename it with timestamp and create a new one.\n\n    Args:\n        path (str): Folder path.\n    \"\"\"", "\n", "if", "osp", ".", "exists", "(", "path", ")", ":", "\n", "        ", "new_name", "=", "path", "+", "'_archived_'", "+", "get_time_str", "(", ")", "\n", "print", "(", "f'Path already exists. Rename it to {new_name}'", ",", "flush", "=", "True", ")", "\n", "os", ".", "rename", "(", "path", ",", "new_name", ")", "\n", "", "os", ".", "makedirs", "(", "path", ",", "exist_ok", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.make_exp_dirs": [[37, 50], ["opt[].copy", "opt[].copy.items", "misc.mkdir_and_rename", "misc.mkdir_and_rename", "opt[].copy.pop", "opt[].copy.pop", "os.makedirs"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.mkdir_and_rename", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.mkdir_and_rename"], ["", "@", "master_only", "\n", "def", "make_exp_dirs", "(", "opt", ")", ":", "\n", "    ", "\"\"\"Make dirs for experiments.\"\"\"", "\n", "path_opt", "=", "opt", "[", "'path'", "]", ".", "copy", "(", ")", "\n", "if", "opt", "[", "'is_train'", "]", ":", "\n", "        ", "mkdir_and_rename", "(", "path_opt", ".", "pop", "(", "'experiments_root'", ")", ")", "\n", "", "else", ":", "\n", "        ", "mkdir_and_rename", "(", "path_opt", ".", "pop", "(", "'results_root'", ")", ")", "\n", "", "for", "key", ",", "path", "in", "path_opt", ".", "items", "(", ")", ":", "\n", "        ", "if", "(", "'strict_load'", "in", "key", ")", "or", "(", "'pretrain_network'", "in", "key", ")", "or", "(", "'resume'", "in", "key", ")", "or", "(", "'param_key'", "in", "key", ")", ":", "\n", "            ", "continue", "\n", "", "else", ":", "\n", "            ", "os", ".", "makedirs", "(", "path", ",", "exist_ok", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir": [[52, 92], ["misc.scandir._scandir"], "function", ["None"], ["", "", "", "def", "scandir", "(", "dir_path", ",", "suffix", "=", "None", ",", "recursive", "=", "False", ",", "full_path", "=", "False", ")", ":", "\n", "    ", "\"\"\"Scan a directory to find the interested files.\n\n    Args:\n        dir_path (str): Path of the directory.\n        suffix (str | tuple(str), optional): File suffix that we are\n            interested in. Default: None.\n        recursive (bool, optional): If set to True, recursively scan the\n            directory. Default: False.\n        full_path (bool, optional): If set to True, include the dir_path.\n            Default: False.\n\n    Returns:\n        A generator for all the interested files with relative pathes.\n    \"\"\"", "\n", "\n", "if", "(", "suffix", "is", "not", "None", ")", "and", "not", "isinstance", "(", "suffix", ",", "(", "str", ",", "tuple", ")", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'\"suffix\" must be a string or tuple of strings'", ")", "\n", "\n", "", "root", "=", "dir_path", "\n", "\n", "def", "_scandir", "(", "dir_path", ",", "suffix", ",", "recursive", ")", ":", "\n", "        ", "for", "entry", "in", "os", ".", "scandir", "(", "dir_path", ")", ":", "\n", "            ", "if", "not", "entry", ".", "name", ".", "startswith", "(", "'.'", ")", "and", "entry", ".", "is_file", "(", ")", ":", "\n", "                ", "if", "full_path", ":", "\n", "                    ", "return_path", "=", "entry", ".", "path", "\n", "", "else", ":", "\n", "                    ", "return_path", "=", "osp", ".", "relpath", "(", "entry", ".", "path", ",", "root", ")", "\n", "\n", "", "if", "suffix", "is", "None", ":", "\n", "                    ", "yield", "return_path", "\n", "", "elif", "return_path", ".", "endswith", "(", "suffix", ")", ":", "\n", "                    ", "yield", "return_path", "\n", "", "", "else", ":", "\n", "                ", "if", "recursive", ":", "\n", "                    ", "yield", "from", "_scandir", "(", "entry", ".", "path", ",", "suffix", "=", "suffix", ",", "recursive", "=", "recursive", ")", "\n", "", "else", ":", "\n", "                    ", "continue", "\n", "\n", "", "", "", "", "return", "_scandir", "(", "dir_path", ",", "suffix", "=", "suffix", ",", "recursive", "=", "recursive", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.check_resume": [[94, 118], ["print", "network.replace", "opt.keys", "key.startswith", "opt[].get", "os.path.join", "print", "opt[].get"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "def", "check_resume", "(", "opt", ",", "resume_iter", ")", ":", "\n", "    ", "\"\"\"Check resume states and pretrain_network paths.\n\n    Args:\n        opt (dict): Options.\n        resume_iter (int): Resume iteration.\n    \"\"\"", "\n", "if", "opt", "[", "'path'", "]", "[", "'resume_state'", "]", ":", "\n", "# get all the networks", "\n", "        ", "networks", "=", "[", "key", "for", "key", "in", "opt", ".", "keys", "(", ")", "if", "key", ".", "startswith", "(", "'network_'", ")", "]", "\n", "flag_pretrain", "=", "False", "\n", "for", "network", "in", "networks", ":", "\n", "            ", "if", "opt", "[", "'path'", "]", ".", "get", "(", "f'pretrain_{network}'", ")", "is", "not", "None", ":", "\n", "                ", "flag_pretrain", "=", "True", "\n", "", "", "if", "flag_pretrain", ":", "\n", "            ", "print", "(", "'pretrain_network path will be ignored during resuming.'", ")", "\n", "# set pretrained model paths", "\n", "", "for", "network", "in", "networks", ":", "\n", "            ", "name", "=", "f'pretrain_{network}'", "\n", "basename", "=", "network", ".", "replace", "(", "'network_'", ",", "''", ")", "\n", "if", "opt", "[", "'path'", "]", ".", "get", "(", "'ignore_resume_networks'", ")", "is", "None", "or", "(", "network", "\n", "not", "in", "opt", "[", "'path'", "]", "[", "'ignore_resume_networks'", "]", ")", ":", "\n", "                ", "opt", "[", "'path'", "]", "[", "name", "]", "=", "osp", ".", "join", "(", "opt", "[", "'path'", "]", "[", "'models'", "]", ",", "f'net_{basename}_{resume_iter}.pth'", ")", "\n", "print", "(", "f\"Set {name} to {opt['path'][name]}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.sizeof_fmt": [[120, 135], ["abs"], "function", ["None"], ["", "", "", "", "def", "sizeof_fmt", "(", "size", ",", "suffix", "=", "'B'", ")", ":", "\n", "    ", "\"\"\"Get human readable file size.\n\n    Args:\n        size (int): File size.\n        suffix (str): Suffix. Default: 'B'.\n\n    Return:\n        str: Formated file siz.\n    \"\"\"", "\n", "for", "unit", "in", "[", "''", ",", "'K'", ",", "'M'", ",", "'G'", ",", "'T'", ",", "'P'", ",", "'E'", ",", "'Z'", "]", ":", "\n", "        ", "if", "abs", "(", "size", ")", "<", "1024.0", ":", "\n", "            ", "return", "f'{size:3.1f} {unit}{suffix}'", "\n", "", "size", "/=", "1024.0", "\n", "", "return", "f'{size:3.1f} Y{suffix}'", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.__init__": [[167, 181], ["os.path.exists", "lmdb.open", "lmdb_util.LmdbMaker.env.begin", "open", "lmdb_path.endswith", "ValueError", "print", "sys.exit", "os.path.join"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "lmdb_path", ",", "map_size", "=", "1024", "**", "4", ",", "batch", "=", "5000", ",", "compress_level", "=", "1", ")", ":", "\n", "        ", "if", "not", "lmdb_path", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"lmdb_path must end with '.lmdb'.\"", ")", "\n", "", "if", "osp", ".", "exists", "(", "lmdb_path", ")", ":", "\n", "            ", "print", "(", "f'Folder {lmdb_path} already exists. Exit.'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "self", ".", "lmdb_path", "=", "lmdb_path", "\n", "self", ".", "batch", "=", "batch", "\n", "self", ".", "compress_level", "=", "compress_level", "\n", "self", ".", "env", "=", "lmdb", ".", "open", "(", "lmdb_path", ",", "map_size", "=", "map_size", ")", "\n", "self", ".", "txn", "=", "self", ".", "env", ".", "begin", "(", "write", "=", "True", ")", "\n", "self", ".", "txt_file", "=", "open", "(", "osp", ".", "join", "(", "lmdb_path", ",", "'meta_info.txt'", ")", ",", "'w'", ")", "\n", "self", ".", "counter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.put": [[182, 192], ["key.encode", "lmdb_util.LmdbMaker.txn.put", "lmdb_util.LmdbMaker.txt_file.write", "lmdb_util.LmdbMaker.txn.commit", "lmdb_util.LmdbMaker.env.begin"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.put"], ["", "def", "put", "(", "self", ",", "img_byte", ",", "key", ",", "img_shape", ")", ":", "\n", "        ", "self", ".", "counter", "+=", "1", "\n", "key_byte", "=", "key", ".", "encode", "(", "'ascii'", ")", "\n", "self", ".", "txn", ".", "put", "(", "key_byte", ",", "img_byte", ")", "\n", "# write meta information", "\n", "h", ",", "w", ",", "c", "=", "img_shape", "\n", "self", ".", "txt_file", ".", "write", "(", "f'{key}.png ({h},{w},{c}) {self.compress_level}\\n'", ")", "\n", "if", "self", ".", "counter", "%", "self", ".", "batch", "==", "0", ":", "\n", "            ", "self", ".", "txn", ".", "commit", "(", ")", "\n", "self", ".", "txn", "=", "self", ".", "env", ".", "begin", "(", "write", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close": [[193, 197], ["lmdb_util.LmdbMaker.txn.commit", "lmdb_util.LmdbMaker.env.close", "lmdb_util.LmdbMaker.txt_file.close"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close"], ["", "", "def", "close", "(", "self", ")", ":", "\n", "        ", "self", ".", "txn", ".", "commit", "(", ")", "\n", "self", ".", "env", ".", "close", "(", ")", "\n", "self", ".", "txt_file", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.make_lmdb_from_imgs": [[9, 130], ["print", "print", "os.path.exists", "lmdb.open", "tqdm.tqdm", "lmdb.open.begin", "open", "enumerate", "tqdm.tqdm.close", "env.begin.commit", "lmdb.open.close", "open.close", "print", "len", "len", "lmdb_path.endswith", "ValueError", "print", "sys.exit", "print", "tqdm.tqdm", "multiprocessing.Pool", "zip", "multiprocessing.Pool.close", "multiprocessing.Pool.join", "tqdm.tqdm.close", "print", "cv2.imread", "cv2.imencode", "print", "os.path.join", "zip", "tqdm.tqdm.update", "tqdm.tqdm.set_description", "key.encode", "env.begin.put", "open.write", "len", "len", "tqdm.tqdm.update", "tqdm.tqdm.set_description", "multiprocessing.Pool.apply_async", "os.path.join", "len", "len", "lmdb_util.read_img_worker", "env.begin.commit", "lmdb.open.begin", "len", "len", "os.path.join", "len", "os.path.join"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.put", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.read_img_worker"], ["def", "make_lmdb_from_imgs", "(", "data_path", ",", "\n", "lmdb_path", ",", "\n", "img_path_list", ",", "\n", "keys", ",", "\n", "batch", "=", "5000", ",", "\n", "compress_level", "=", "1", ",", "\n", "multiprocessing_read", "=", "False", ",", "\n", "n_thread", "=", "40", ",", "\n", "map_size", "=", "None", ")", ":", "\n", "    ", "\"\"\"Make lmdb from images.\n\n    Contents of lmdb. The file structure is:\n    example.lmdb\n    \u251c\u2500\u2500 data.mdb\n    \u251c\u2500\u2500 lock.mdb\n    \u251c\u2500\u2500 meta_info.txt\n\n    The data.mdb and lock.mdb are standard lmdb files and you can refer to\n    https://lmdb.readthedocs.io/en/release/ for more details.\n\n    The meta_info.txt is a specified txt file to record the meta information\n    of our datasets. It will be automatically created when preparing\n    datasets by our provided dataset tools.\n    Each line in the txt file records 1)image name (with extension),\n    2)image shape, and 3)compression level, separated by a white space.\n\n    For example, the meta information could be:\n    `000_00000000.png (720,1280,3) 1`, which means:\n    1) image name (with extension): 000_00000000.png;\n    2) image shape: (720,1280,3);\n    3) compression level: 1\n\n    We use the image name without extension as the lmdb key.\n\n    If `multiprocessing_read` is True, it will read all the images to memory\n    using multiprocessing. Thus, your server needs to have enough memory.\n\n    Args:\n        data_path (str): Data path for reading images.\n        lmdb_path (str): Lmdb save path.\n        img_path_list (str): Image path list.\n        keys (str): Used for lmdb keys.\n        batch (int): After processing batch images, lmdb commits.\n            Default: 5000.\n        compress_level (int): Compress level when encoding images. Default: 1.\n        multiprocessing_read (bool): Whether use multiprocessing to read all\n            the images to memory. Default: False.\n        n_thread (int): For multiprocessing.\n        map_size (int | None): Map size for lmdb env. If None, use the\n            estimated size from images. Default: None\n    \"\"\"", "\n", "\n", "assert", "len", "(", "img_path_list", ")", "==", "len", "(", "keys", ")", ",", "(", "'img_path_list and keys should have the same length, '", "\n", "f'but got {len(img_path_list)} and {len(keys)}'", ")", "\n", "print", "(", "f'Create lmdb for {data_path}, save to {lmdb_path}...'", ")", "\n", "print", "(", "f'Totoal images: {len(img_path_list)}'", ")", "\n", "if", "not", "lmdb_path", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"lmdb_path must end with '.lmdb'.\"", ")", "\n", "", "if", "osp", ".", "exists", "(", "lmdb_path", ")", ":", "\n", "        ", "print", "(", "f'Folder {lmdb_path} already exists. Exit.'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "if", "multiprocessing_read", ":", "\n", "# read all the images to memory (multiprocessing)", "\n", "        ", "dataset", "=", "{", "}", "# use dict to keep the order for multiprocessing", "\n", "shapes", "=", "{", "}", "\n", "print", "(", "f'Read images with multiprocessing, #thread: {n_thread} ...'", ")", "\n", "pbar", "=", "tqdm", "(", "total", "=", "len", "(", "img_path_list", ")", ",", "unit", "=", "'image'", ")", "\n", "\n", "def", "callback", "(", "arg", ")", ":", "\n", "            ", "\"\"\"get the image data and update pbar.\"\"\"", "\n", "key", ",", "dataset", "[", "key", "]", ",", "shapes", "[", "key", "]", "=", "arg", "\n", "pbar", ".", "update", "(", "1", ")", "\n", "pbar", ".", "set_description", "(", "f'Read {key}'", ")", "\n", "\n", "", "pool", "=", "Pool", "(", "n_thread", ")", "\n", "for", "path", ",", "key", "in", "zip", "(", "img_path_list", ",", "keys", ")", ":", "\n", "            ", "pool", ".", "apply_async", "(", "read_img_worker", ",", "args", "=", "(", "osp", ".", "join", "(", "data_path", ",", "path", ")", ",", "key", ",", "compress_level", ")", ",", "callback", "=", "callback", ")", "\n", "", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "pbar", ".", "close", "(", ")", "\n", "print", "(", "f'Finish reading {len(img_path_list)} images.'", ")", "\n", "\n", "# create lmdb environment", "\n", "", "if", "map_size", "is", "None", ":", "\n", "# obtain data size for one image", "\n", "        ", "img", "=", "cv2", ".", "imread", "(", "osp", ".", "join", "(", "data_path", ",", "img_path_list", "[", "0", "]", ")", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", "\n", "_", ",", "img_byte", "=", "cv2", ".", "imencode", "(", "'.png'", ",", "img", ",", "[", "cv2", ".", "IMWRITE_PNG_COMPRESSION", ",", "compress_level", "]", ")", "\n", "data_size_per_img", "=", "img_byte", ".", "nbytes", "\n", "print", "(", "'Data size per image is: '", ",", "data_size_per_img", ")", "\n", "data_size", "=", "data_size_per_img", "*", "len", "(", "img_path_list", ")", "\n", "map_size", "=", "data_size", "*", "10", "\n", "\n", "", "env", "=", "lmdb", ".", "open", "(", "lmdb_path", ",", "map_size", "=", "map_size", ")", "\n", "\n", "# write data to lmdb", "\n", "pbar", "=", "tqdm", "(", "total", "=", "len", "(", "img_path_list", ")", ",", "unit", "=", "'chunk'", ")", "\n", "txn", "=", "env", ".", "begin", "(", "write", "=", "True", ")", "\n", "txt_file", "=", "open", "(", "osp", ".", "join", "(", "lmdb_path", ",", "'meta_info.txt'", ")", ",", "'w'", ")", "\n", "for", "idx", ",", "(", "path", ",", "key", ")", "in", "enumerate", "(", "zip", "(", "img_path_list", ",", "keys", ")", ")", ":", "\n", "        ", "pbar", ".", "update", "(", "1", ")", "\n", "pbar", ".", "set_description", "(", "f'Write {key}'", ")", "\n", "key_byte", "=", "key", ".", "encode", "(", "'ascii'", ")", "\n", "if", "multiprocessing_read", ":", "\n", "            ", "img_byte", "=", "dataset", "[", "key", "]", "\n", "h", ",", "w", ",", "c", "=", "shapes", "[", "key", "]", "\n", "", "else", ":", "\n", "            ", "_", ",", "img_byte", ",", "img_shape", "=", "read_img_worker", "(", "osp", ".", "join", "(", "data_path", ",", "path", ")", ",", "key", ",", "compress_level", ")", "\n", "h", ",", "w", ",", "c", "=", "img_shape", "\n", "\n", "", "txn", ".", "put", "(", "key_byte", ",", "img_byte", ")", "\n", "# write meta information", "\n", "txt_file", ".", "write", "(", "f'{key}.png ({h},{w},{c}) {compress_level}\\n'", ")", "\n", "if", "idx", "%", "batch", "==", "0", ":", "\n", "            ", "txn", ".", "commit", "(", ")", "\n", "txn", "=", "env", ".", "begin", "(", "write", "=", "True", ")", "\n", "", "", "pbar", ".", "close", "(", ")", "\n", "txn", ".", "commit", "(", ")", "\n", "env", ".", "close", "(", ")", "\n", "txt_file", ".", "close", "(", ")", "\n", "print", "(", "'\\nFinish writing lmdb.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.read_img_worker": [[132, 154], ["cv2.imread", "cv2.imencode"], "function", ["None"], ["", "def", "read_img_worker", "(", "path", ",", "key", ",", "compress_level", ")", ":", "\n", "    ", "\"\"\"Read image worker.\n\n    Args:\n        path (str): Image path.\n        key (str): Image key.\n        compress_level (int): Compress level when encoding images.\n\n    Returns:\n        str: Image key.\n        byte: Image byte.\n        tuple[int]: Image shape.\n    \"\"\"", "\n", "\n", "img", "=", "cv2", ".", "imread", "(", "path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "\n", "c", "=", "1", "\n", "", "else", ":", "\n", "        ", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "", "_", ",", "img_byte", "=", "cv2", ".", "imencode", "(", "'.png'", ",", "img", ",", "[", "cv2", ".", "IMWRITE_PNG_COMPRESSION", ",", "compress_level", "]", ")", "\n", "return", "(", "key", ",", "img_byte", ",", "(", "h", ",", "w", ",", "c", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.vgg_arch.VGGFeatureExtractor.__init__": [[78, 140], ["torch.nn.Module.__init__", "os.path.exists", "collections.OrderedDict", "zip", "torch.nn.Sequential", "vgg_arch.insert_bn", "vgg_arch.VGGFeatureExtractor.names.index", "torch.load", "vgg_net.load_state_dict", "vgg_arch.VGGFeatureExtractor.vgg_net.eval", "vgg_arch.VGGFeatureExtractor.parameters", "vgg_arch.VGGFeatureExtractor.vgg_net.train", "vgg_arch.VGGFeatureExtractor.parameters", "vgg_arch.VGGFeatureExtractor.register_buffer", "vgg_arch.VGGFeatureExtractor.register_buffer", "vgg_type.replace", "getattr", "getattr", "torch.Tensor().view", "torch.Tensor().view", "torch.nn.MaxPool2d", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.vgg_arch.insert_bn"], ["def", "__init__", "(", "self", ",", "\n", "layer_name_list", ",", "\n", "vgg_type", "=", "'vgg19'", ",", "\n", "use_input_norm", "=", "True", ",", "\n", "range_norm", "=", "False", ",", "\n", "requires_grad", "=", "False", ",", "\n", "remove_pooling", "=", "False", ",", "\n", "pooling_stride", "=", "2", ")", ":", "\n", "        ", "super", "(", "VGGFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "layer_name_list", "=", "layer_name_list", "\n", "self", ".", "use_input_norm", "=", "use_input_norm", "\n", "self", ".", "range_norm", "=", "range_norm", "\n", "\n", "self", ".", "names", "=", "NAMES", "[", "vgg_type", ".", "replace", "(", "'_bn'", ",", "''", ")", "]", "\n", "if", "'bn'", "in", "vgg_type", ":", "\n", "            ", "self", ".", "names", "=", "insert_bn", "(", "self", ".", "names", ")", "\n", "\n", "# only borrow layers that will be used to avoid unused params", "\n", "", "max_idx", "=", "0", "\n", "for", "v", "in", "layer_name_list", ":", "\n", "            ", "idx", "=", "self", ".", "names", ".", "index", "(", "v", ")", "\n", "if", "idx", ">", "max_idx", ":", "\n", "                ", "max_idx", "=", "idx", "\n", "\n", "", "", "if", "os", ".", "path", ".", "exists", "(", "VGG_PRETRAIN_PATH", ")", ":", "\n", "            ", "vgg_net", "=", "getattr", "(", "vgg", ",", "vgg_type", ")", "(", "pretrained", "=", "False", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "VGG_PRETRAIN_PATH", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "vgg_net", ".", "load_state_dict", "(", "state_dict", ")", "\n", "", "else", ":", "\n", "            ", "vgg_net", "=", "getattr", "(", "vgg", ",", "vgg_type", ")", "(", "pretrained", "=", "True", ")", "\n", "\n", "", "features", "=", "vgg_net", ".", "features", "[", ":", "max_idx", "+", "1", "]", "\n", "\n", "modified_net", "=", "OrderedDict", "(", ")", "\n", "for", "k", ",", "v", "in", "zip", "(", "self", ".", "names", ",", "features", ")", ":", "\n", "            ", "if", "'pool'", "in", "k", ":", "\n", "# if remove_pooling is true, pooling operation will be removed", "\n", "                ", "if", "remove_pooling", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "# in some cases, we may want to change the default stride", "\n", "                    ", "modified_net", "[", "k", "]", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "pooling_stride", ")", "\n", "", "", "else", ":", "\n", "                ", "modified_net", "[", "k", "]", "=", "v", "\n", "\n", "", "", "self", ".", "vgg_net", "=", "nn", ".", "Sequential", "(", "modified_net", ")", "\n", "\n", "if", "not", "requires_grad", ":", "\n", "            ", "self", ".", "vgg_net", ".", "eval", "(", ")", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "vgg_net", ".", "train", "(", ")", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "True", "\n", "\n", "", "", "if", "self", ".", "use_input_norm", ":", "\n", "# the mean is for image with range [0, 1]", "\n", "            ", "self", ".", "register_buffer", "(", "'mean'", ",", "torch", ".", "Tensor", "(", "[", "0.485", ",", "0.456", ",", "0.406", "]", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "# the std is for image with range [0, 1]", "\n", "self", ".", "register_buffer", "(", "'std'", ",", "torch", ".", "Tensor", "(", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.vgg_arch.VGGFeatureExtractor.forward": [[141, 162], ["vgg_arch.VGGFeatureExtractor.vgg_net._modules.items", "layer", "layer.clone"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            x (Tensor): Input tensor with shape (n, c, h, w).\n\n        Returns:\n            Tensor: Forward results.\n        \"\"\"", "\n", "if", "self", ".", "range_norm", ":", "\n", "            ", "x", "=", "(", "x", "+", "1", ")", "/", "2", "\n", "", "if", "self", ".", "use_input_norm", ":", "\n", "            ", "x", "=", "(", "x", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "\n", "", "output", "=", "{", "}", "\n", "for", "key", ",", "layer", "in", "self", ".", "vgg_net", ".", "_modules", ".", "items", "(", ")", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "if", "key", "in", "self", ".", "layer_name_list", ":", "\n", "                ", "output", "[", "key", "]", "=", "x", ".", "clone", "(", ")", "\n", "\n", "", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.vgg_arch.insert_bn": [[36, 52], ["names_bn.append", "name.replace", "names_bn.append"], "function", ["None"], ["def", "insert_bn", "(", "names", ")", ":", "\n", "    ", "\"\"\"Insert bn layer after each conv.\n\n    Args:\n        names (list): The list of layer names.\n\n    Returns:\n        list: The list of layer names with bn layers.\n    \"\"\"", "\n", "names_bn", "=", "[", "]", "\n", "for", "name", "in", "names", ":", "\n", "        ", "names_bn", ".", "append", "(", "name", ")", "\n", "if", "'conv'", "in", "name", ":", "\n", "            ", "position", "=", "name", ".", "replace", "(", "'conv'", ",", "''", ")", "\n", "names_bn", ".", "append", "(", "'bn'", "+", "position", ")", "\n", "", "", "return", "names_bn", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.InceptionV3.__init__": [[32, 123], ["torch.Module.__init__", "sorted", "max", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "models.inception_v3.InceptionV3.blocks.append", "models.inception_v3.InceptionV3.parameters", "inception.fid_inception_v3", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "models.inception_v3.InceptionV3.blocks.append", "models.inception_v3.InceptionV3.blocks.append", "models.inception_v3.InceptionV3.blocks.append", "torchvision.models.inception_v3", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torchvision.models.inception_v3"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.fid_inception_v3"], ["def", "__init__", "(", "self", ",", "\n", "output_blocks", "=", "(", "DEFAULT_BLOCK_INDEX", ")", ",", "\n", "resize_input", "=", "True", ",", "\n", "normalize_input", "=", "True", ",", "\n", "requires_grad", "=", "False", ",", "\n", "use_fid_inception", "=", "True", ")", ":", "\n", "        ", "\"\"\"Build pretrained InceptionV3.\n\n        Args:\n            output_blocks (list[int]): Indices of blocks to return features of.\n                Possible values are:\n                - 0: corresponds to output of first max pooling\n                - 1: corresponds to output of second max pooling\n                - 2: corresponds to output which is fed to aux classifier\n                - 3: corresponds to output of final average pooling\n            resize_input (bool): If true, bilinearly resizes input to width and\n                height 299 before feeding input to model. As the network\n                without fully connected layers is fully convolutional, it\n                should be able to handle inputs of arbitrary size, so resizing\n                might not be strictly needed. Default: True.\n            normalize_input (bool): If true, scales the input from range (0, 1)\n                to the range the pretrained Inception network expects,\n                namely (-1, 1). Default: True.\n            requires_grad (bool): If true, parameters of the model require\n                gradients. Possibly useful for finetuning the network.\n                Default: False.\n            use_fid_inception (bool): If true, uses the pretrained Inception\n                model used in Tensorflow's FID implementation.\n                If false, uses the pretrained Inception model available in\n                torchvision. The FID Inception model has different weights\n                and a slightly different structure from torchvision's\n                Inception model. If you want to compute FID scores, you are\n                strongly advised to set this parameter to true to get\n                comparable results. Default: True.\n        \"\"\"", "\n", "super", "(", "InceptionV3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "resize_input", "=", "resize_input", "\n", "self", ".", "normalize_input", "=", "normalize_input", "\n", "self", ".", "output_blocks", "=", "sorted", "(", "output_blocks", ")", "\n", "self", ".", "last_needed_block", "=", "max", "(", "output_blocks", ")", "\n", "\n", "assert", "self", ".", "last_needed_block", "<=", "3", ",", "(", "'Last possible output block index is 3'", ")", "\n", "\n", "self", ".", "blocks", "=", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "if", "use_fid_inception", ":", "\n", "            ", "inception", "=", "fid_inception_v3", "(", ")", "\n", "", "else", ":", "\n", "            ", "try", ":", "\n", "                ", "inception", "=", "models", ".", "inception_v3", "(", "pretrained", "=", "True", ",", "init_weights", "=", "False", ")", "\n", "", "except", "TypeError", ":", "\n", "# pytorch < 1.5 does not have init_weights for inception_v3", "\n", "                ", "inception", "=", "models", ".", "inception_v3", "(", "pretrained", "=", "True", ")", "\n", "\n", "# Block 0: input to maxpool1", "\n", "", "", "block0", "=", "[", "\n", "inception", ".", "Conv2d_1a_3x3", ",", "inception", ".", "Conv2d_2a_3x3", ",", "inception", ".", "Conv2d_2b_3x3", ",", "\n", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ")", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block0", ")", ")", "\n", "\n", "# Block 1: maxpool1 to maxpool2", "\n", "if", "self", ".", "last_needed_block", ">=", "1", ":", "\n", "            ", "block1", "=", "[", "inception", ".", "Conv2d_3b_1x1", ",", "inception", ".", "Conv2d_4a_3x3", ",", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ")", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block1", ")", ")", "\n", "\n", "# Block 2: maxpool2 to aux classifier", "\n", "", "if", "self", ".", "last_needed_block", ">=", "2", ":", "\n", "            ", "block2", "=", "[", "\n", "inception", ".", "Mixed_5b", ",", "\n", "inception", ".", "Mixed_5c", ",", "\n", "inception", ".", "Mixed_5d", ",", "\n", "inception", ".", "Mixed_6a", ",", "\n", "inception", ".", "Mixed_6b", ",", "\n", "inception", ".", "Mixed_6c", ",", "\n", "inception", ".", "Mixed_6d", ",", "\n", "inception", ".", "Mixed_6e", ",", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block2", ")", ")", "\n", "\n", "# Block 3: aux classifier to final avgpool", "\n", "", "if", "self", ".", "last_needed_block", ">=", "3", ":", "\n", "            ", "block3", "=", "[", "\n", "inception", ".", "Mixed_7a", ",", "inception", ".", "Mixed_7b", ",", "inception", ".", "Mixed_7c", ",", "\n", "nn", ".", "AdaptiveAvgPool2d", "(", "output_size", "=", "(", "1", ",", "1", ")", ")", "\n", "]", "\n", "self", ".", "blocks", ".", "append", "(", "nn", ".", "Sequential", "(", "*", "block3", ")", ")", "\n", "\n", "", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "requires_grad", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.InceptionV3.forward": [[124, 153], ["enumerate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "block", "output.append"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Get Inception feature maps.\n\n        Args:\n            x (Tensor): Input tensor of shape (b, 3, h, w).\n                Values are expected to be in range (-1, 1). You can also input\n                (0, 1) with setting normalize_input = True.\n\n        Returns:\n            list[Tensor]: Corresponding to the selected output block, sorted\n            ascending by index.\n        \"\"\"", "\n", "output", "=", "[", "]", "\n", "\n", "if", "self", ".", "resize_input", ":", "\n", "            ", "x", "=", "F", ".", "interpolate", "(", "x", ",", "size", "=", "(", "299", ",", "299", ")", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "\n", "", "if", "self", ".", "normalize_input", ":", "\n", "            ", "x", "=", "2", "*", "x", "-", "1", "# Scale from range (0, 1) to range (-1, 1)", "\n", "\n", "", "for", "idx", ",", "block", "in", "enumerate", "(", "self", ".", "blocks", ")", ":", "\n", "            ", "x", "=", "block", "(", "x", ")", "\n", "if", "idx", "in", "self", ".", "output_blocks", ":", "\n", "                ", "output", ".", "append", "(", "x", ")", "\n", "\n", "", "if", "idx", "==", "self", ".", "last_needed_block", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionA.__init__": [[192, 194], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "pool_features", ")", ":", "\n", "        ", "super", "(", "FIDInceptionA", ",", "self", ")", ".", "__init__", "(", "in_channels", ",", "pool_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionA.forward": [[195, 212], ["inception.FIDInceptionA.branch1x1", "inception.FIDInceptionA.branch5x5_1", "inception.FIDInceptionA.branch5x5_2", "inception.FIDInceptionA.branch3x3dbl_1", "inception.FIDInceptionA.branch3x3dbl_2", "inception.FIDInceptionA.branch3x3dbl_3", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "inception.FIDInceptionA.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch5x5", "=", "self", ".", "branch5x5_1", "(", "x", ")", "\n", "branch5x5", "=", "self", ".", "branch5x5_2", "(", "branch5x5", ")", "\n", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_1", "(", "x", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_2", "(", "branch3x3dbl", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_3", "(", "branch3x3dbl", ")", "\n", "\n", "# Patch: Tensorflow's average pool does not use the padded zero's in", "\n", "# its average calculation", "\n", "branch_pool", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "count_include_pad", "=", "False", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch5x5", ",", "branch3x3dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionC.__init__": [[217, 219], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "channels_7x7", ")", ":", "\n", "        ", "super", "(", "FIDInceptionC", ",", "self", ")", ".", "__init__", "(", "in_channels", ",", "channels_7x7", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionC.forward": [[220, 240], ["inception.FIDInceptionC.branch1x1", "inception.FIDInceptionC.branch7x7_1", "inception.FIDInceptionC.branch7x7_2", "inception.FIDInceptionC.branch7x7_3", "inception.FIDInceptionC.branch7x7dbl_1", "inception.FIDInceptionC.branch7x7dbl_2", "inception.FIDInceptionC.branch7x7dbl_3", "inception.FIDInceptionC.branch7x7dbl_4", "inception.FIDInceptionC.branch7x7dbl_5", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "inception.FIDInceptionC.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch7x7", "=", "self", ".", "branch7x7_1", "(", "x", ")", "\n", "branch7x7", "=", "self", ".", "branch7x7_2", "(", "branch7x7", ")", "\n", "branch7x7", "=", "self", ".", "branch7x7_3", "(", "branch7x7", ")", "\n", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_1", "(", "x", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_2", "(", "branch7x7dbl", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_3", "(", "branch7x7dbl", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_4", "(", "branch7x7dbl", ")", "\n", "branch7x7dbl", "=", "self", ".", "branch7x7dbl_5", "(", "branch7x7dbl", ")", "\n", "\n", "# Patch: Tensorflow's average pool does not use the padded zero's in", "\n", "# its average calculation", "\n", "branch_pool", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "count_include_pad", "=", "False", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch7x7", ",", "branch7x7dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionE_1.__init__": [[245, 247], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FIDInceptionE_1", ",", "self", ")", ".", "__init__", "(", "in_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionE_1.forward": [[248, 273], ["inception.FIDInceptionE_1.branch1x1", "inception.FIDInceptionE_1.branch3x3_1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_1.branch3x3dbl_1", "inception.FIDInceptionE_1.branch3x3dbl_2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "inception.FIDInceptionE_1.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_1.branch3x3_2a", "inception.FIDInceptionE_1.branch3x3_2b", "inception.FIDInceptionE_1.branch3x3dbl_3a", "inception.FIDInceptionE_1.branch3x3dbl_3b"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch3x3", "=", "self", ".", "branch3x3_1", "(", "x", ")", "\n", "branch3x3", "=", "[", "\n", "self", ".", "branch3x3_2a", "(", "branch3x3", ")", ",", "\n", "self", ".", "branch3x3_2b", "(", "branch3x3", ")", ",", "\n", "]", "\n", "branch3x3", "=", "torch", ".", "cat", "(", "branch3x3", ",", "1", ")", "\n", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_1", "(", "x", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_2", "(", "branch3x3dbl", ")", "\n", "branch3x3dbl", "=", "[", "\n", "self", ".", "branch3x3dbl_3a", "(", "branch3x3dbl", ")", ",", "\n", "self", ".", "branch3x3dbl_3b", "(", "branch3x3dbl", ")", ",", "\n", "]", "\n", "branch3x3dbl", "=", "torch", ".", "cat", "(", "branch3x3dbl", ",", "1", ")", "\n", "\n", "# Patch: Tensorflow's average pool does not use the padded zero's in", "\n", "# its average calculation", "\n", "branch_pool", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "count_include_pad", "=", "False", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch3x3", ",", "branch3x3dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionE_2.__init__": [[278, 280], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ")", ":", "\n", "        ", "super", "(", "FIDInceptionE_2", ",", "self", ")", ".", "__init__", "(", "in_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.FIDInceptionE_2.forward": [[281, 308], ["inception.FIDInceptionE_2.branch1x1", "inception.FIDInceptionE_2.branch3x3_1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_2.branch3x3dbl_1", "inception.FIDInceptionE_2.branch3x3dbl_2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max_pool2d", "torch.max_pool2d", "torch.max_pool2d", "inception.FIDInceptionE_2.branch_pool", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "inception.FIDInceptionE_2.branch3x3_2a", "inception.FIDInceptionE_2.branch3x3_2b", "inception.FIDInceptionE_2.branch3x3dbl_3a", "inception.FIDInceptionE_2.branch3x3dbl_3b"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "branch1x1", "=", "self", ".", "branch1x1", "(", "x", ")", "\n", "\n", "branch3x3", "=", "self", ".", "branch3x3_1", "(", "x", ")", "\n", "branch3x3", "=", "[", "\n", "self", ".", "branch3x3_2a", "(", "branch3x3", ")", ",", "\n", "self", ".", "branch3x3_2b", "(", "branch3x3", ")", ",", "\n", "]", "\n", "branch3x3", "=", "torch", ".", "cat", "(", "branch3x3", ",", "1", ")", "\n", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_1", "(", "x", ")", "\n", "branch3x3dbl", "=", "self", ".", "branch3x3dbl_2", "(", "branch3x3dbl", ")", "\n", "branch3x3dbl", "=", "[", "\n", "self", ".", "branch3x3dbl_3a", "(", "branch3x3dbl", ")", ",", "\n", "self", ".", "branch3x3dbl_3b", "(", "branch3x3dbl", ")", ",", "\n", "]", "\n", "branch3x3dbl", "=", "torch", ".", "cat", "(", "branch3x3dbl", ",", "1", ")", "\n", "\n", "# Patch: The FID Inception model uses max pooling instead of average", "\n", "# pooling. This is likely an error in this specific Inception", "\n", "# implementation, as other Inception models use average pooling here", "\n", "# (which matches the description in the paper).", "\n", "branch_pool", "=", "F", ".", "max_pool2d", "(", "x", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "branch_pool", "=", "self", ".", "branch_pool", "(", "branch_pool", ")", "\n", "\n", "outputs", "=", "[", "branch1x1", ",", "branch3x3", ",", "branch3x3dbl", ",", "branch_pool", "]", "\n", "return", "torch", ".", "cat", "(", "outputs", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.inception.fid_inception_v3": [[155, 187], ["inception.FIDInceptionA", "inception.FIDInceptionA", "inception.FIDInceptionA", "inception.FIDInceptionC", "inception.FIDInceptionC", "inception.FIDInceptionC", "inception.FIDInceptionC", "inception.FIDInceptionE_1", "inception.FIDInceptionE_2", "os.path.exists", "models.inception_v3.load_state_dict", "torchvision.models.inception_v3", "torch.load", "torch.load", "torch.load", "torch.utils.model_zoo.load_url", "torchvision.models.inception_v3"], "function", ["None"], ["", "", "def", "fid_inception_v3", "(", ")", ":", "\n", "    ", "\"\"\"Build pretrained Inception model for FID computation.\n\n    The Inception model for FID computation uses a different set of weights\n    and has a slightly different structure than torchvision's Inception.\n\n    This method first constructs torchvision's Inception and then patches the\n    necessary parts that are different in the FID Inception model.\n    \"\"\"", "\n", "try", ":", "\n", "        ", "inception", "=", "models", ".", "inception_v3", "(", "num_classes", "=", "1008", ",", "aux_logits", "=", "False", ",", "pretrained", "=", "False", ",", "init_weights", "=", "False", ")", "\n", "", "except", "TypeError", ":", "\n", "# pytorch < 1.5 does not have init_weights for inception_v3", "\n", "        ", "inception", "=", "models", ".", "inception_v3", "(", "num_classes", "=", "1008", ",", "aux_logits", "=", "False", ",", "pretrained", "=", "False", ")", "\n", "\n", "", "inception", ".", "Mixed_5b", "=", "FIDInceptionA", "(", "192", ",", "pool_features", "=", "32", ")", "\n", "inception", ".", "Mixed_5c", "=", "FIDInceptionA", "(", "256", ",", "pool_features", "=", "64", ")", "\n", "inception", ".", "Mixed_5d", "=", "FIDInceptionA", "(", "288", ",", "pool_features", "=", "64", ")", "\n", "inception", ".", "Mixed_6b", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "128", ")", "\n", "inception", ".", "Mixed_6c", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "160", ")", "\n", "inception", ".", "Mixed_6d", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "160", ")", "\n", "inception", ".", "Mixed_6e", "=", "FIDInceptionC", "(", "768", ",", "channels_7x7", "=", "192", ")", "\n", "inception", ".", "Mixed_7b", "=", "FIDInceptionE_1", "(", "1280", ")", "\n", "inception", ".", "Mixed_7c", "=", "FIDInceptionE_2", "(", "2048", ")", "\n", "\n", "if", "os", ".", "path", ".", "exists", "(", "LOCAL_FID_WEIGHTS", ")", ":", "\n", "        ", "state_dict", "=", "torch", ".", "load", "(", "LOCAL_FID_WEIGHTS", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "", "else", ":", "\n", "        ", "state_dict", "=", "load_url", "(", "FID_WEIGHTS_URL", ",", "progress", "=", "True", ")", "\n", "\n", "", "inception", ".", "load_state_dict", "(", "state_dict", ")", "\n", "return", "inception", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.srresnet_arch.MSRResNet.__init__": [[29, 55], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "arch_util.make_layer", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "arch_util.default_init_weights", "torch.nn.Conv2d", "torch.nn.PixelShuffle", "arch_util.default_init_weights", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PixelShuffle"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.make_layer", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights"], ["def", "__init__", "(", "self", ",", "num_in_ch", "=", "3", ",", "num_out_ch", "=", "3", ",", "num_feat", "=", "64", ",", "num_block", "=", "16", ",", "upscale", "=", "4", ")", ":", "\n", "        ", "super", "(", "MSRResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "upscale", "=", "upscale", "\n", "\n", "self", ".", "conv_first", "=", "nn", ".", "Conv2d", "(", "num_in_ch", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "body", "=", "make_layer", "(", "ResidualBlockNoBN", ",", "num_block", ",", "num_feat", "=", "num_feat", ")", "\n", "\n", "# upsampling", "\n", "if", "self", ".", "upscale", "in", "[", "2", ",", "3", "]", ":", "\n", "            ", "self", ".", "upconv1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", "*", "self", ".", "upscale", "*", "self", ".", "upscale", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "pixel_shuffle", "=", "nn", ".", "PixelShuffle", "(", "self", ".", "upscale", ")", "\n", "", "elif", "self", ".", "upscale", "==", "4", ":", "\n", "            ", "self", ".", "upconv1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", "*", "4", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "upconv2", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", "*", "4", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "pixel_shuffle", "=", "nn", ".", "PixelShuffle", "(", "2", ")", "\n", "\n", "", "self", ".", "conv_hr", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_last", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "\n", "# activation function", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.1", ",", "inplace", "=", "True", ")", "\n", "\n", "# initialization", "\n", "default_init_weights", "(", "[", "self", ".", "conv_first", ",", "self", ".", "upconv1", ",", "self", ".", "conv_hr", ",", "self", ".", "conv_last", "]", ",", "0.1", ")", "\n", "if", "self", ".", "upscale", "==", "4", ":", "\n", "            ", "default_init_weights", "(", "self", ".", "upconv2", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.srresnet_arch.MSRResNet.forward": [[56, 70], ["srresnet_arch.MSRResNet.lrelu", "srresnet_arch.MSRResNet.body", "srresnet_arch.MSRResNet.conv_last", "torch.nn.functional.interpolate", "srresnet_arch.MSRResNet.conv_first", "srresnet_arch.MSRResNet.lrelu", "srresnet_arch.MSRResNet.lrelu", "srresnet_arch.MSRResNet.lrelu", "srresnet_arch.MSRResNet.pixel_shuffle", "srresnet_arch.MSRResNet.pixel_shuffle", "srresnet_arch.MSRResNet.lrelu", "srresnet_arch.MSRResNet.conv_hr", "srresnet_arch.MSRResNet.upconv1", "srresnet_arch.MSRResNet.upconv2", "srresnet_arch.MSRResNet.pixel_shuffle", "srresnet_arch.MSRResNet.upconv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "conv_first", "(", "x", ")", ")", "\n", "out", "=", "self", ".", "body", "(", "feat", ")", "\n", "\n", "if", "self", ".", "upscale", "==", "4", ":", "\n", "            ", "out", "=", "self", ".", "lrelu", "(", "self", ".", "pixel_shuffle", "(", "self", ".", "upconv1", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "self", ".", "pixel_shuffle", "(", "self", ".", "upconv2", "(", "out", ")", ")", ")", "\n", "", "elif", "self", ".", "upscale", "in", "[", "2", ",", "3", "]", ":", "\n", "            ", "out", "=", "self", ".", "lrelu", "(", "self", ".", "pixel_shuffle", "(", "self", ".", "upconv1", "(", "out", ")", ")", ")", "\n", "\n", "", "out", "=", "self", ".", "conv_last", "(", "self", ".", "lrelu", "(", "self", ".", "conv_hr", "(", "out", ")", ")", ")", "\n", "base", "=", "F", ".", "interpolate", "(", "x", ",", "scale_factor", "=", "self", ".", "upscale", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "out", "+=", "base", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.degradation_prediction_arch.Degradation_Predictor.__init__": [[6, 29], ["torch.Module.__init__", "torch.Sequential", "torch.AdaptiveAvgPool2d", "torch.Sequential", "torch.Conv2d", "torch.LeakyReLU", "torch.Conv2d", "torch.LeakyReLU", "torch.Conv2d", "torch.LeakyReLU", "torch.Conv2d", "torch.LeakyReLU", "torch.Conv2d", "torch.LeakyReLU", "torch.Conv2d", "torch.LeakyReLU", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_nc", "=", "3", ",", "nf", "=", "64", ",", "num_params", "=", "100", ",", "num_networks", "=", "5", ",", "use_bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "Degradation_Predictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "ConvNet", "=", "nn", ".", "Sequential", "(", "*", "[", "\n", "nn", ".", "Conv2d", "(", "in_nc", ",", "nf", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "nf", ",", "nf", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "use_bias", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "nf", ",", "nf", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "use_bias", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "nf", ",", "nf", ",", "kernel_size", "=", "5", ",", "stride", "=", "2", ",", "padding", "=", "2", ",", "bias", "=", "use_bias", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "nf", ",", "nf", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "use_bias", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "nf", ",", "num_params", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "use_bias", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "]", ")", "\n", "\n", "self", ".", "globalPooling", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "\n", "self", ".", "MappingNet", "=", "nn", ".", "Sequential", "(", "*", "[", "\n", "nn", ".", "Linear", "(", "num_params", ",", "15", ")", ",", "\n", "nn", ".", "Linear", "(", "15", ",", "num_networks", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.degradation_prediction_arch.Degradation_Predictor.forward": [[31, 37], ["degradation_prediction_arch.Degradation_Predictor.ConvNet", "degradation_prediction_arch.Degradation_Predictor.globalPooling", "degradation_prediction_arch.Degradation_Predictor.view", "degradation_prediction_arch.Degradation_Predictor.MappingNet", "degradation_prediction_arch.Degradation_Predictor.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "conv", "=", "self", ".", "ConvNet", "(", "input", ")", "\n", "flat", "=", "self", ".", "globalPooling", "(", "conv", ")", "\n", "out_params", "=", "flat", ".", "view", "(", "flat", ".", "size", "(", ")", "[", ":", "2", "]", ")", "\n", "mapped_weights", "=", "self", ".", "MappingNet", "(", "out_params", ")", "\n", "return", "out_params", ",", "mapped_weights", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.srresnetdynamic_arch.MSRResNetDynamic.__init__": [[11, 32], ["torch.nn.Module.__init__", "arch_util.Dynamic_conv2d", "arch_util.make_layer", "arch_util.Dynamic_conv2d", "arch_util.Dynamic_conv2d", "torch.nn.LeakyReLU", "arch_util.Dynamic_conv2d", "torch.nn.PixelShuffle", "arch_util.Dynamic_conv2d", "arch_util.Dynamic_conv2d", "torch.nn.PixelShuffle"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.make_layer"], ["    ", "def", "__init__", "(", "self", ",", "num_in_ch", "=", "3", ",", "num_out_ch", "=", "3", ",", "num_feat", "=", "64", ",", "num_block", "=", "16", ",", "num_models", "=", "5", ",", "upscale", "=", "4", ")", ":", "\n", "        ", "super", "(", "MSRResNetDynamic", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "upscale", "=", "upscale", "\n", "\n", "self", ".", "conv_first", "=", "Dynamic_conv2d", "(", "num_in_ch", ",", "num_feat", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "body", "=", "make_layer", "(", "ResidualBlockNoBNDynamic", ",", "num_block", ",", "num_feat", "=", "num_feat", ",", "num_models", "=", "num_models", ")", "\n", "\n", "# upsampling", "\n", "if", "self", ".", "upscale", "in", "[", "2", ",", "3", "]", ":", "\n", "            ", "self", ".", "upconv1", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_feat", "*", "self", ".", "upscale", "*", "self", ".", "upscale", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "pixel_shuffle", "=", "nn", ".", "PixelShuffle", "(", "self", ".", "upscale", ")", "\n", "", "elif", "self", ".", "upscale", "==", "4", ":", "\n", "            ", "self", ".", "upconv1", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_feat", "*", "4", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "upconv2", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_feat", "*", "4", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "pixel_shuffle", "=", "nn", ".", "PixelShuffle", "(", "2", ")", "\n", "\n", "", "self", ".", "conv_hr", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "conv_last", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_out_ch", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "\n", "# activation function", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.1", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.srresnetdynamic_arch.MSRResNetDynamic.forward": [[34, 49], ["srresnetdynamic_arch.MSRResNetDynamic.lrelu", "srresnetdynamic_arch.MSRResNetDynamic.lrelu", "srresnetdynamic_arch.MSRResNetDynamic.conv_last", "torch.nn.functional.interpolate", "srresnetdynamic_arch.MSRResNetDynamic.conv_first", "srresnetdynamic_arch.MSRResNetDynamic.body", "srresnetdynamic_arch.MSRResNetDynamic.lrelu", "srresnetdynamic_arch.MSRResNetDynamic.lrelu", "srresnetdynamic_arch.MSRResNetDynamic.conv_hr", "srresnetdynamic_arch.MSRResNetDynamic.pixel_shuffle", "srresnetdynamic_arch.MSRResNetDynamic.pixel_shuffle", "srresnetdynamic_arch.MSRResNetDynamic.lrelu", "srresnetdynamic_arch.MSRResNetDynamic.upconv1", "srresnetdynamic_arch.MSRResNetDynamic.upconv2", "srresnetdynamic_arch.MSRResNetDynamic.pixel_shuffle", "srresnetdynamic_arch.MSRResNetDynamic.upconv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "weights", ")", ":", "\n", "        ", "out", "=", "self", ".", "lrelu", "(", "self", ".", "conv_first", "(", "{", "'x'", ":", "x", ",", "'weights'", ":", "weights", "}", ")", ")", "\n", "out", "=", "self", ".", "body", "(", "{", "'x'", ":", "out", ",", "'weights'", ":", "weights", "}", ")", "[", "'x'", "]", "\n", "\n", "if", "self", ".", "upscale", "==", "4", ":", "\n", "            ", "out", "=", "self", ".", "lrelu", "(", "self", ".", "pixel_shuffle", "(", "self", ".", "upconv1", "(", "{", "'x'", ":", "out", ",", "'weights'", ":", "weights", "}", ")", ")", ")", "\n", "out", "=", "self", ".", "lrelu", "(", "self", ".", "pixel_shuffle", "(", "self", ".", "upconv2", "(", "{", "'x'", ":", "out", ",", "'weights'", ":", "weights", "}", ")", ")", ")", "\n", "", "elif", "self", ".", "upscale", "in", "[", "2", ",", "3", "]", ":", "\n", "            ", "out", "=", "self", ".", "lrelu", "(", "self", ".", "pixel_shuffle", "(", "self", ".", "upconv1", "(", "{", "'x'", ":", "out", ",", "'weights'", ":", "weights", "}", ")", ")", ")", "\n", "\n", "", "out", "=", "self", ".", "lrelu", "(", "self", ".", "conv_hr", "(", "{", "'x'", ":", "out", ",", "'weights'", ":", "weights", "}", ")", ")", "\n", "out", "=", "self", ".", "conv_last", "(", "{", "'x'", ":", "out", ",", "'weights'", ":", "weights", "}", ")", "\n", "base", "=", "F", ".", "interpolate", "(", "x", ",", "scale_factor", "=", "self", ".", "upscale", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "out", "+=", "base", "\n", "return", "out", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.ResidualBlockNoBN.__init__": [[73, 82], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "arch_util.default_init_weights"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights"], ["def", "__init__", "(", "self", ",", "num_feat", "=", "64", ",", "res_scale", "=", "1", ",", "pytorch_init", "=", "False", ")", ":", "\n", "        ", "super", "(", "ResidualBlockNoBN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "res_scale", "=", "res_scale", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "if", "not", "pytorch_init", ":", "\n", "            ", "default_init_weights", "(", "[", "self", ".", "conv1", ",", "self", ".", "conv2", "]", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.ResidualBlockNoBN.forward": [[83, 87], ["arch_util.ResidualBlockNoBN.conv2", "arch_util.ResidualBlockNoBN.relu", "arch_util.ResidualBlockNoBN.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "out", "=", "self", ".", "conv2", "(", "self", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "return", "identity", "+", "out", "*", "self", ".", "res_scale", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Hsigmoid.__init__": [[94, 97], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ")", ":", "\n", "        ", "super", "(", "Hsigmoid", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inplace", "=", "inplace", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Hsigmoid.forward": [[98, 100], ["torch.nn.functional.relu6"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "F", ".", "relu6", "(", "x", "+", "3.", ",", "inplace", "=", "self", ".", "inplace", ")", "/", "3.", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.SEModule_small.__init__": [[102, 107], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Linear", "arch_util.Hsigmoid"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ")", ":", "\n", "        ", "super", "(", "SEModule_small", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "channel", ",", "channel", ",", "bias", "=", "False", ")", ",", "\n", "Hsigmoid", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.SEModule_small.forward": [[109, 112], ["arch_util.SEModule_small.fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "y", "=", "self", ".", "fc", "(", "x", ")", "\n", "return", "x", "*", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.ResidualBlockdyNoBN.__init__": [[128, 137], ["torch.nn.Module.__init__", "conv_basic_dy_nobn", "conv_basic_dy_nobn", "torch.nn.ReLU", "arch_util.default_init_weights"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights"], ["def", "__init__", "(", "self", ",", "num_feat", "=", "64", ",", "res_scale", "=", "1", ",", "pytorch_init", "=", "False", ")", ":", "\n", "        ", "super", "(", "ResidualBlockdyNoBN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "res_scale", "=", "res_scale", "\n", "self", ".", "conv1", "=", "conv_basic_dy_nobn", "(", "num_feat", ",", "num_feat", ",", "1", ")", "\n", "self", ".", "conv2", "=", "conv_basic_dy_nobn", "(", "num_feat", ",", "num_feat", ",", "1", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "if", "not", "pytorch_init", ":", "\n", "            ", "default_init_weights", "(", "[", "self", ".", "conv1", ",", "self", ".", "conv2", "]", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.ResidualBlockdyNoBN.forward": [[138, 148], ["inputs[].clone", "arch_util.ResidualBlockdyNoBN.relu", "arch_util.ResidualBlockdyNoBN.conv2", "arch_util.ResidualBlockdyNoBN.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "# identity = x", "\n", "# out = self.conv2(self.relu(self.conv1(x)))", "\n", "# return identity + out * self.res_scale", "\n", "        ", "identity", "=", "inputs", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "conv1", "(", "inputs", ")", ")", "\n", "conv2_input", "=", "{", "'x'", ":", "out", ",", "'weights'", ":", "inputs", "[", "'weights'", "]", "}", "\n", "out", "=", "self", ".", "conv2", "(", "conv2_input", ")", "\n", "out", "=", "identity", "+", "out", "*", "self", ".", "res_scale", "\n", "return", "{", "'x'", ":", "out", ",", "'weights'", ":", "inputs", "[", "'weights'", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Dynamic_conv2d.__init__": [[150, 170], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.randn", "torch.nn.Parameter", "arch_util.Dynamic_conv2d._initialize_weights", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Dynamic_conv2d._initialize_weights"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "out_planes", ",", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "dilation", "=", "1", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "5", ",", "init_weight", "=", "False", ")", ":", "\n", "        ", "super", "(", "Dynamic_conv2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "in_planes", "%", "groups", "==", "0", "\n", "self", ".", "in_planes", "=", "in_planes", "\n", "self", ".", "out_planes", "=", "out_planes", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "groups", "=", "groups", "\n", "self", ".", "if_bias", "=", "if_bias", "\n", "self", ".", "K", "=", "K", "\n", "\n", "self", ".", "weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "K", ",", "out_planes", ",", "in_planes", "//", "groups", ",", "kernel_size", ",", "kernel_size", ")", ",", "requires_grad", "=", "True", ")", "\n", "if", "self", ".", "if_bias", ":", "\n", "            ", "self", ".", "bias", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "K", ",", "out_planes", ")", ",", "requires_grad", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "bias", "=", "None", "\n", "", "if", "init_weight", ":", "\n", "            ", "self", ".", "_initialize_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Dynamic_conv2d._initialize_weights": [[171, 176], ["range", "torch.nn.init.kaiming_uniform_", "torch.nn.init.constant_"], "methods", ["None"], ["", "", "def", "_initialize_weights", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "K", ")", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "self", ".", "weight", "[", "i", "]", ")", "\n", "if", "self", ".", "if_bias", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "bias", "[", "i", "]", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Dynamic_conv2d.forward": [[177, 195], ["x.contiguous().view.contiguous().view.size", "x.contiguous().view.contiguous().view.contiguous().view", "arch_util.Dynamic_conv2d.weight.view", "torch.mm().view", "torch.nn.functional.conv2d.view", "torch.mm().view", "torch.nn.functional.conv2d", "torch.nn.functional.conv2d", "torch.nn.functional.conv2d.size", "torch.nn.functional.conv2d.size", "x.contiguous().view.contiguous().view.contiguous", "torch.mm", "torch.mm"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "x", "=", "inputs", "[", "'x'", "]", "\n", "softmax_attention", "=", "inputs", "[", "'weights'", "]", "\n", "batch_size", ",", "in_planes", ",", "height", ",", "width", "=", "x", ".", "size", "(", ")", "\n", "x", "=", "x", ".", "contiguous", "(", ")", ".", "view", "(", "1", ",", "-", "1", ",", "height", ",", "width", ")", "\n", "weight", "=", "self", ".", "weight", ".", "view", "(", "self", ".", "K", ",", "-", "1", ")", "\n", "\n", "aggregate_weight", "=", "torch", ".", "mm", "(", "softmax_attention", ",", "weight", ")", ".", "view", "(", "-", "1", ",", "self", ".", "in_planes", ",", "self", ".", "kernel_size", ",", "self", ".", "kernel_size", ")", "\n", "if", "self", ".", "bias", "is", "not", "None", ":", "\n", "            ", "aggregate_bias", "=", "torch", ".", "mm", "(", "softmax_attention", ",", "self", ".", "bias", ")", ".", "view", "(", "-", "1", ")", "\n", "output", "=", "F", ".", "conv2d", "(", "x", ",", "weight", "=", "aggregate_weight", ",", "bias", "=", "aggregate_bias", ",", "stride", "=", "self", ".", "stride", ",", "padding", "=", "self", ".", "padding", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "groups", "=", "self", ".", "groups", "*", "batch_size", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "F", ".", "conv2d", "(", "x", ",", "weight", "=", "aggregate_weight", ",", "bias", "=", "None", ",", "stride", "=", "self", ".", "stride", ",", "padding", "=", "self", ".", "padding", ",", "\n", "dilation", "=", "self", ".", "dilation", ",", "groups", "=", "self", ".", "groups", "*", "batch_size", ")", "\n", "\n", "", "output", "=", "output", ".", "view", "(", "batch_size", ",", "self", ".", "out_planes", ",", "output", ".", "size", "(", "-", "2", ")", ",", "output", ".", "size", "(", "-", "1", ")", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.ResidualBlockNoBNDynamic.__init__": [[211, 219], ["torch.nn.Module.__init__", "arch_util.Dynamic_conv2d", "arch_util.Dynamic_conv2d", "torch.nn.ReLU", "arch_util.default_init_weights"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights"], ["def", "__init__", "(", "self", ",", "num_feat", "=", "64", ",", "res_scale", "=", "1", ",", "num_models", "=", "5", ")", ":", "\n", "        ", "super", "(", "ResidualBlockNoBNDynamic", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "res_scale", "=", "res_scale", "\n", "self", ".", "conv1", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "conv2", "=", "Dynamic_conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "groups", "=", "1", ",", "if_bias", "=", "True", ",", "K", "=", "num_models", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "default_init_weights", "(", "[", "self", ".", "conv1", ",", "self", ".", "conv2", "]", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.ResidualBlockNoBNDynamic.forward": [[220, 227], ["inputs[].clone", "arch_util.ResidualBlockNoBNDynamic.relu", "arch_util.ResidualBlockNoBNDynamic.conv2", "arch_util.ResidualBlockNoBNDynamic.conv1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inputs", ")", ":", "\n", "        ", "identity", "=", "inputs", "[", "'x'", "]", ".", "clone", "(", ")", "\n", "out", "=", "self", ".", "relu", "(", "self", ".", "conv1", "(", "inputs", ")", ")", "\n", "conv2_input", "=", "{", "'x'", ":", "out", ",", "'weights'", ":", "inputs", "[", "'weights'", "]", "}", "\n", "out", "=", "self", ".", "conv2", "(", "conv2_input", ")", "\n", "out", "=", "identity", "+", "out", "*", "self", ".", "res_scale", "\n", "return", "{", "'x'", ":", "out", ",", "'weights'", ":", "inputs", "[", "'weights'", "]", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.Upsample.__init__": [[236, 248], ["torch.nn.Sequential.__init__", "range", "int", "m.append", "m.append", "m.append", "m.append", "ValueError", "math.log", "torch.nn.Conv2d", "torch.nn.PixelShuffle", "torch.nn.Conv2d", "torch.nn.PixelShuffle"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "scale", ",", "num_feat", ")", ":", "\n", "        ", "m", "=", "[", "]", "\n", "if", "(", "scale", "&", "(", "scale", "-", "1", ")", ")", "==", "0", ":", "# scale = 2^n", "\n", "            ", "for", "_", "in", "range", "(", "int", "(", "math", ".", "log", "(", "scale", ",", "2", ")", ")", ")", ":", "\n", "                ", "m", ".", "append", "(", "nn", ".", "Conv2d", "(", "num_feat", ",", "4", "*", "num_feat", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "m", ".", "append", "(", "nn", ".", "PixelShuffle", "(", "2", ")", ")", "\n", "", "", "elif", "scale", "==", "3", ":", "\n", "            ", "m", ".", "append", "(", "nn", ".", "Conv2d", "(", "num_feat", ",", "9", "*", "num_feat", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "m", ".", "append", "(", "nn", ".", "PixelShuffle", "(", "3", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'scale {scale} is not supported. '", "'Supported scales: 2^n and 3.'", ")", "\n", "", "super", "(", "Upsample", ",", "self", ")", ".", "__init__", "(", "*", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights": [[11, 40], ["torch.no_grad", "isinstance", "module.modules", "isinstance", "torch.nn.init.kaiming_normal_", "isinstance", "m.bias.data.fill_", "torch.nn.init.kaiming_normal_", "isinstance", "m.bias.data.fill_", "torch.nn.init.constant_", "m.bias.data.fill_"], "function", ["None"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "default_init_weights", "(", "module_list", ",", "scale", "=", "1", ",", "bias_fill", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Initialize network weights.\n\n    Args:\n        module_list (list[nn.Module] | nn.Module): Modules to be initialized.\n        scale (float): Scale initialized weights, especially for residual\n            blocks. Default: 1.\n        bias_fill (float): The value to fill bias. Default: 0\n        kwargs (dict): Other arguments for initialization function.\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "module_list", ",", "list", ")", ":", "\n", "        ", "module_list", "=", "[", "module_list", "]", "\n", "", "for", "module", "in", "module_list", ":", "\n", "        ", "for", "m", "in", "module", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "**", "kwargs", ")", "\n", "m", ".", "weight", ".", "data", "*=", "scale", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "bias_fill", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "**", "kwargs", ")", "\n", "m", ".", "weight", ".", "data", "*=", "scale", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "bias_fill", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "_BatchNorm", ")", ":", "\n", "                ", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "bias_fill", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.make_layer": [[42, 56], ["range", "torch.nn.Sequential", "layers.append", "basic_block"], "function", ["None"], ["", "", "", "", "", "def", "make_layer", "(", "basic_block", ",", "num_basic_block", ",", "**", "kwarg", ")", ":", "\n", "    ", "\"\"\"Make layers by stacking the same blocks.\n\n    Args:\n        basic_block (nn.module): nn.module class for basic block.\n        num_basic_block (int): number of blocks.\n\n    Returns:\n        nn.Sequential: Stacked blocks in nn.Sequential.\n    \"\"\"", "\n", "layers", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_basic_block", ")", ":", "\n", "        ", "layers", ".", "append", "(", "basic_block", "(", "**", "kwarg", ")", ")", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.conv3x3": [[88, 92], ["torch.nn.Conv2d"], "function", ["None"], ["", "", "def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.flow_warp": [[250, 282], ["x.size", "torch.meshgrid", "torch.stack().float", "torch.stack", "torch.nn.functional.grid_sample", "torch.arange().type_as", "torch.arange().type_as", "x.size", "flow.size", "torch.stack", "max", "max", "torch.arange", "torch.arange"], "function", ["None"], ["", "", "def", "flow_warp", "(", "x", ",", "flow", ",", "interp_mode", "=", "'bilinear'", ",", "padding_mode", "=", "'zeros'", ",", "align_corners", "=", "True", ")", ":", "\n", "    ", "\"\"\"Warp an image or feature map with optical flow.\n\n    Args:\n        x (Tensor): Tensor with size (n, c, h, w).\n        flow (Tensor): Tensor with size (n, h, w, 2), normal value.\n        interp_mode (str): 'nearest' or 'bilinear'. Default: 'bilinear'.\n        padding_mode (str): 'zeros' or 'border' or 'reflection'.\n            Default: 'zeros'.\n        align_corners (bool): Before pytorch 1.3, the default value is\n            align_corners=True. After pytorch 1.3, the default value is\n            align_corners=False. Here, we use the True as default.\n\n    Returns:\n        Tensor: Warped image or feature map.\n    \"\"\"", "\n", "assert", "x", ".", "size", "(", ")", "[", "-", "2", ":", "]", "==", "flow", ".", "size", "(", ")", "[", "1", ":", "3", "]", "\n", "_", ",", "_", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "# create mesh grid", "\n", "grid_y", ",", "grid_x", "=", "torch", ".", "meshgrid", "(", "torch", ".", "arange", "(", "0", ",", "h", ")", ".", "type_as", "(", "x", ")", ",", "torch", ".", "arange", "(", "0", ",", "w", ")", ".", "type_as", "(", "x", ")", ")", "\n", "grid", "=", "torch", ".", "stack", "(", "(", "grid_x", ",", "grid_y", ")", ",", "2", ")", ".", "float", "(", ")", "# W(x), H(y), 2", "\n", "grid", ".", "requires_grad", "=", "False", "\n", "\n", "vgrid", "=", "grid", "+", "flow", "\n", "# scale grid to [-1,1]", "\n", "vgrid_x", "=", "2.0", "*", "vgrid", "[", ":", ",", ":", ",", ":", ",", "0", "]", "/", "max", "(", "w", "-", "1", ",", "1", ")", "-", "1.0", "\n", "vgrid_y", "=", "2.0", "*", "vgrid", "[", ":", ",", ":", ",", ":", ",", "1", "]", "/", "max", "(", "h", "-", "1", ",", "1", ")", "-", "1.0", "\n", "vgrid_scaled", "=", "torch", ".", "stack", "(", "(", "vgrid_x", ",", "vgrid_y", ")", ",", "dim", "=", "3", ")", "\n", "output", "=", "F", ".", "grid_sample", "(", "x", ",", "vgrid_scaled", ",", "mode", "=", "interp_mode", ",", "padding_mode", "=", "padding_mode", ",", "align_corners", "=", "align_corners", ")", "\n", "\n", "# TODO, what if align_corners=False", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.resize_flow": [[284, 320], ["flow.size", "flow.clone", "torch.nn.functional.interpolate", "int", "int", "ValueError"], "function", ["None"], ["", "def", "resize_flow", "(", "flow", ",", "size_type", ",", "sizes", ",", "interp_mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", ":", "\n", "    ", "\"\"\"Resize a flow according to ratio or shape.\n\n    Args:\n        flow (Tensor): Precomputed flow. shape [N, 2, H, W].\n        size_type (str): 'ratio' or 'shape'.\n        sizes (list[int | float]): the ratio for resizing or the final output\n            shape.\n            1) The order of ratio should be [ratio_h, ratio_w]. For\n            downsampling, the ratio should be smaller than 1.0 (i.e., ratio\n            < 1.0). For upsampling, the ratio should be larger than 1.0 (i.e.,\n            ratio > 1.0).\n            2) The order of output_size should be [out_h, out_w].\n        interp_mode (str): The mode of interpolation for resizing.\n            Default: 'bilinear'.\n        align_corners (bool): Whether align corners. Default: False.\n\n    Returns:\n        Tensor: Resized flow.\n    \"\"\"", "\n", "_", ",", "_", ",", "flow_h", ",", "flow_w", "=", "flow", ".", "size", "(", ")", "\n", "if", "size_type", "==", "'ratio'", ":", "\n", "        ", "output_h", ",", "output_w", "=", "int", "(", "flow_h", "*", "sizes", "[", "0", "]", ")", ",", "int", "(", "flow_w", "*", "sizes", "[", "1", "]", ")", "\n", "", "elif", "size_type", "==", "'shape'", ":", "\n", "        ", "output_h", ",", "output_w", "=", "sizes", "[", "0", "]", ",", "sizes", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Size type should be ratio or shape, but got type {size_type}.'", ")", "\n", "\n", "", "input_flow", "=", "flow", ".", "clone", "(", ")", "\n", "ratio_h", "=", "output_h", "/", "flow_h", "\n", "ratio_w", "=", "output_w", "/", "flow_w", "\n", "input_flow", "[", ":", ",", "0", ",", ":", ",", ":", "]", "*=", "ratio_w", "\n", "input_flow", "[", ":", ",", "1", ",", ":", ",", ":", "]", "*=", "ratio_h", "\n", "resized_flow", "=", "F", ".", "interpolate", "(", "\n", "input", "=", "input_flow", ",", "size", "=", "(", "output_h", ",", "output_w", ")", ",", "mode", "=", "interp_mode", ",", "align_corners", "=", "align_corners", ")", "\n", "return", "resized_flow", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.pixel_unshuffle": [[323, 345], ["x.size", "x.size", "x.view", "x.view.permute().reshape", "x.view.permute"], "function", ["None"], ["", "def", "pixel_unshuffle", "(", "x", ",", "scale", ")", ":", "\n", "    ", "\"\"\" Pixel unshuffle.\n\n    Args:\n        x (Tensor): Input feature with shape (b, c, hh, hw).\n        scale (int): Downsample ratio.\n\n    Returns:\n        Tensor: the pixel unshuffled feature.\n    \"\"\"", "\n", "b", ",", "c", ",", "hh", ",", "hw", "=", "x", ".", "size", "(", ")", "\n", "out_channel", "=", "c", "*", "(", "scale", "**", "2", ")", "\n", "if", "hh", "%", "scale", "!=", "0", ":", "\n", "        ", "x", "=", "x", "[", ":", ",", ":", ",", ":", "-", "(", "hh", "%", "scale", ")", ",", ":", "]", "\n", "", "if", "hw", "%", "scale", "!=", "0", ":", "\n", "        ", "x", "=", "x", "[", ":", ",", ":", ",", ":", ",", ":", "-", "(", "hw", "%", "scale", ")", "]", "\n", "", "b", ",", "c", ",", "hh", ",", "hw", "=", "x", ".", "size", "(", ")", "\n", "assert", "hh", "%", "scale", "==", "0", "and", "hw", "%", "scale", "==", "0", "\n", "h", "=", "hh", "//", "scale", "\n", "w", "=", "hw", "//", "scale", "\n", "x_view", "=", "x", ".", "view", "(", "b", ",", "c", ",", "h", ",", "scale", ",", "w", ",", "scale", ")", "\n", "return", "x_view", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "5", ",", "2", ",", "4", ")", ".", "reshape", "(", "b", ",", "out_channel", ",", "h", ",", "w", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.rrdbnet_arch.ResidualDenseBlock.__init__": [[19, 31], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "arch_util.default_init_weights"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.default_init_weights"], ["def", "__init__", "(", "self", ",", "num_feat", "=", "64", ",", "num_grow_ch", "=", "32", ")", ":", "\n", "        ", "super", "(", "ResidualDenseBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_grow_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "num_feat", "+", "num_grow_ch", ",", "num_grow_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "num_feat", "+", "2", "*", "num_grow_ch", ",", "num_grow_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "num_feat", "+", "3", "*", "num_grow_ch", ",", "num_grow_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv2d", "(", "num_feat", "+", "4", "*", "num_grow_ch", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "\n", "# initialization", "\n", "default_init_weights", "(", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "conv4", ",", "self", ".", "conv5", "]", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.rrdbnet_arch.ResidualDenseBlock.forward": [[32, 40], ["rrdbnet_arch.ResidualDenseBlock.lrelu", "rrdbnet_arch.ResidualDenseBlock.lrelu", "rrdbnet_arch.ResidualDenseBlock.lrelu", "rrdbnet_arch.ResidualDenseBlock.lrelu", "rrdbnet_arch.ResidualDenseBlock.conv5", "rrdbnet_arch.ResidualDenseBlock.conv1", "rrdbnet_arch.ResidualDenseBlock.conv2", "rrdbnet_arch.ResidualDenseBlock.conv3", "rrdbnet_arch.ResidualDenseBlock.conv4", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "self", ".", "lrelu", "(", "self", ".", "conv1", "(", "x", ")", ")", "\n", "x2", "=", "self", ".", "lrelu", "(", "self", ".", "conv2", "(", "torch", ".", "cat", "(", "(", "x", ",", "x1", ")", ",", "1", ")", ")", ")", "\n", "x3", "=", "self", ".", "lrelu", "(", "self", ".", "conv3", "(", "torch", ".", "cat", "(", "(", "x", ",", "x1", ",", "x2", ")", ",", "1", ")", ")", ")", "\n", "x4", "=", "self", ".", "lrelu", "(", "self", ".", "conv4", "(", "torch", ".", "cat", "(", "(", "x", ",", "x1", ",", "x2", ",", "x3", ")", ",", "1", ")", ")", ")", "\n", "x5", "=", "self", ".", "conv5", "(", "torch", ".", "cat", "(", "(", "x", ",", "x1", ",", "x2", ",", "x3", ",", "x4", ")", ",", "1", ")", ")", "\n", "# Emperically, we use 0.2 to scale the residual for better performance", "\n", "return", "x5", "*", "0.2", "+", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.rrdbnet_arch.RRDB.__init__": [[52, 57], ["torch.nn.Module.__init__", "rrdbnet_arch.ResidualDenseBlock", "rrdbnet_arch.ResidualDenseBlock", "rrdbnet_arch.ResidualDenseBlock"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "num_feat", ",", "num_grow_ch", "=", "32", ")", ":", "\n", "        ", "super", "(", "RRDB", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "rdb1", "=", "ResidualDenseBlock", "(", "num_feat", ",", "num_grow_ch", ")", "\n", "self", ".", "rdb2", "=", "ResidualDenseBlock", "(", "num_feat", ",", "num_grow_ch", ")", "\n", "self", ".", "rdb3", "=", "ResidualDenseBlock", "(", "num_feat", ",", "num_grow_ch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.rrdbnet_arch.RRDB.forward": [[58, 64], ["rrdbnet_arch.RRDB.rdb1", "rrdbnet_arch.RRDB.rdb2", "rrdbnet_arch.RRDB.rdb3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "rdb1", "(", "x", ")", "\n", "out", "=", "self", ".", "rdb2", "(", "out", ")", "\n", "out", "=", "self", ".", "rdb3", "(", "out", ")", "\n", "# Emperically, we use 0.2 to scale the residual for better performance", "\n", "return", "out", "*", "0.2", "+", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.rrdbnet_arch.RRDBNet.__init__": [[87, 106], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "arch_util.make_layer", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.make_layer"], ["def", "__init__", "(", "self", ",", "num_in_ch", ",", "num_out_ch", ",", "scale", "=", "4", ",", "num_feat", "=", "64", ",", "num_block", "=", "23", ",", "num_grow_ch", "=", "32", ")", ":", "\n", "        ", "super", "(", "RRDBNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "scale", "\n", "if", "scale", "==", "2", ":", "\n", "            ", "num_in_ch", "=", "num_in_ch", "*", "4", "\n", "", "elif", "scale", "==", "1", ":", "\n", "            ", "num_in_ch", "=", "num_in_ch", "*", "16", "\n", "", "self", ".", "conv_first", "=", "nn", ".", "Conv2d", "(", "num_in_ch", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "body", "=", "make_layer", "(", "RRDB", ",", "num_block", ",", "num_feat", "=", "num_feat", ",", "num_grow_ch", "=", "num_grow_ch", ")", "\n", "self", ".", "conv_body", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "# upsample", "\n", "self", ".", "conv_up1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_up2", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "if", "scale", "==", "8", ":", "\n", "            ", "self", ".", "conv_up3", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "", "self", ".", "conv_hr", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_last", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.rrdbnet_arch.RRDBNet.forward": [[107, 124], ["rrdbnet_arch.RRDBNet.conv_first", "rrdbnet_arch.RRDBNet.conv_body", "rrdbnet_arch.RRDBNet.lrelu", "rrdbnet_arch.RRDBNet.lrelu", "rrdbnet_arch.RRDBNet.conv_last", "arch_util.pixel_unshuffle", "rrdbnet_arch.RRDBNet.body", "rrdbnet_arch.RRDBNet.conv_up1", "rrdbnet_arch.RRDBNet.conv_up2", "rrdbnet_arch.RRDBNet.lrelu", "arch_util.pixel_unshuffle", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "rrdbnet_arch.RRDBNet.conv_hr"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.pixel_unshuffle", "home.repos.pwc.inspect_result.csjliang_dasr.archs.arch_util.pixel_unshuffle"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "scale", "==", "2", ":", "\n", "            ", "feat", "=", "pixel_unshuffle", "(", "x", ",", "scale", "=", "2", ")", "\n", "", "elif", "self", ".", "scale", "==", "1", ":", "\n", "            ", "feat", "=", "pixel_unshuffle", "(", "x", ",", "scale", "=", "4", ")", "\n", "", "else", ":", "\n", "            ", "feat", "=", "x", "\n", "", "feat", "=", "self", ".", "conv_first", "(", "feat", ")", "\n", "body_feat", "=", "self", ".", "conv_body", "(", "self", ".", "body", "(", "feat", ")", ")", "\n", "feat", "=", "feat", "+", "body_feat", "\n", "# upsample", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "conv_up1", "(", "F", ".", "interpolate", "(", "feat", ",", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "conv_up2", "(", "F", ".", "interpolate", "(", "feat", ",", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ")", ")", "\n", "# if self.scale == 8:", "\n", "#     feat = self.lrelu(self.conv_up3(F.interpolate(feat, scale_factor=2, mode='nearest')))", "\n", "out", "=", "self", ".", "conv_last", "(", "self", ".", "lrelu", "(", "self", ".", "conv_hr", "(", "feat", ")", ")", ")", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.Mlp.__init__": [[15, 23], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "act_layer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_features", ",", "hidden_features", "=", "None", ",", "out_features", "=", "None", ",", "act_layer", "=", "nn", ".", "GELU", ",", "drop", "=", "0.", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "out_features", "=", "out_features", "or", "in_features", "\n", "hidden_features", "=", "hidden_features", "or", "in_features", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "in_features", ",", "hidden_features", ")", "\n", "self", ".", "act", "=", "act_layer", "(", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "hidden_features", ",", "out_features", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "drop", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.Mlp.forward": [[24, 31], ["swinir_arch.Mlp.fc1", "swinir_arch.Mlp.act", "swinir_arch.Mlp.drop", "swinir_arch.Mlp.fc2", "swinir_arch.Mlp.drop"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "fc1", "(", "x", ")", "\n", "x", "=", "self", ".", "act", "(", "x", ")", "\n", "x", "=", "self", ".", "drop", "(", "x", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "x", "=", "self", ".", "drop", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.WindowAttention.__init__": [[79, 113], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "torch.flatten", "relative_coords.permute().contiguous.permute().contiguous.permute().contiguous", "relative_coords.permute().contiguous.permute().contiguous.sum", "swinir_arch.WindowAttention.register_buffer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "timm.models.layers.trunc_normal_", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.Softmax", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "torch.meshgrid", "relative_coords.permute().contiguous.permute().contiguous.permute"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "dim", ",", "window_size", ",", "num_heads", ",", "qkv_bias", "=", "True", ",", "qk_scale", "=", "None", ",", "attn_drop", "=", "0.", ",", "proj_drop", "=", "0.", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "window_size", "=", "window_size", "# Wh, Ww", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "head_dim", "=", "dim", "//", "num_heads", "\n", "self", ".", "scale", "=", "qk_scale", "or", "head_dim", "**", "-", "0.5", "\n", "\n", "# define a parameter table of relative position bias", "\n", "self", ".", "relative_position_bias_table", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "zeros", "(", "(", "2", "*", "window_size", "[", "0", "]", "-", "1", ")", "*", "(", "2", "*", "window_size", "[", "1", "]", "-", "1", ")", ",", "num_heads", ")", ")", "# 2*Wh-1 * 2*Ww-1, nH", "\n", "\n", "# get pair-wise relative position index for each token inside the window", "\n", "coords_h", "=", "torch", ".", "arange", "(", "self", ".", "window_size", "[", "0", "]", ")", "\n", "coords_w", "=", "torch", ".", "arange", "(", "self", ".", "window_size", "[", "1", "]", ")", "\n", "coords", "=", "torch", ".", "stack", "(", "torch", ".", "meshgrid", "(", "[", "coords_h", ",", "coords_w", "]", ")", ")", "# 2, Wh, Ww", "\n", "coords_flatten", "=", "torch", ".", "flatten", "(", "coords", ",", "1", ")", "# 2, Wh*Ww", "\n", "relative_coords", "=", "coords_flatten", "[", ":", ",", ":", ",", "None", "]", "-", "coords_flatten", "[", ":", ",", "None", ",", ":", "]", "# 2, Wh*Ww, Wh*Ww", "\n", "relative_coords", "=", "relative_coords", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "contiguous", "(", ")", "# Wh*Ww, Wh*Ww, 2", "\n", "relative_coords", "[", ":", ",", ":", ",", "0", "]", "+=", "self", ".", "window_size", "[", "0", "]", "-", "1", "# shift to start from 0", "\n", "relative_coords", "[", ":", ",", ":", ",", "1", "]", "+=", "self", ".", "window_size", "[", "1", "]", "-", "1", "\n", "relative_coords", "[", ":", ",", ":", ",", "0", "]", "*=", "2", "*", "self", ".", "window_size", "[", "1", "]", "-", "1", "\n", "relative_position_index", "=", "relative_coords", ".", "sum", "(", "-", "1", ")", "# Wh*Ww, Wh*Ww", "\n", "self", ".", "register_buffer", "(", "\"relative_position_index\"", ",", "relative_position_index", ")", "\n", "\n", "self", ".", "qkv", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", "*", "3", ",", "bias", "=", "qkv_bias", ")", "\n", "self", ".", "attn_drop", "=", "nn", ".", "Dropout", "(", "attn_drop", ")", "\n", "self", ".", "proj", "=", "nn", ".", "Linear", "(", "dim", ",", "dim", ")", "\n", "\n", "self", ".", "proj_drop", "=", "nn", ".", "Dropout", "(", "proj_drop", ")", "\n", "\n", "trunc_normal_", "(", "self", ".", "relative_position_bias_table", ",", "std", "=", ".02", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.WindowAttention.forward": [[114, 146], ["swinir_arch.WindowAttention.qkv().reshape().permute", "swinir_arch.WindowAttention.relative_position_bias_table[].view", "relative_position_bias.permute().contiguous.permute().contiguous.permute().contiguous", "swinir_arch.WindowAttention.attn_drop", "swinir_arch.WindowAttention.proj", "swinir_arch.WindowAttention.proj_drop", "k.transpose", "relative_position_bias.permute().contiguous.permute().contiguous.unsqueeze", "swinir_arch.WindowAttention.view", "swinir_arch.WindowAttention.softmax", "swinir_arch.WindowAttention.softmax", "swinir_arch.WindowAttention.qkv().reshape", "relative_position_bias.permute().contiguous.permute().contiguous.permute", "swinir_arch.WindowAttention.view", "mask.unsqueeze().unsqueeze", "swinir_arch.WindowAttention.qkv", "swinir_arch.WindowAttention.relative_position_index.view", "mask.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: input features with shape of (num_windows*B, N, C)\n            mask: (0/-inf) mask with shape of (num_windows, Wh*Ww, Wh*Ww) or None\n        \"\"\"", "\n", "B_", ",", "N", ",", "C", "=", "x", ".", "shape", "\n", "qkv", "=", "self", ".", "qkv", "(", "x", ")", ".", "reshape", "(", "B_", ",", "N", ",", "3", ",", "self", ".", "num_heads", ",", "C", "//", "self", ".", "num_heads", ")", ".", "permute", "(", "2", ",", "0", ",", "3", ",", "1", ",", "4", ")", "\n", "q", ",", "k", ",", "v", "=", "qkv", "[", "0", "]", ",", "qkv", "[", "1", "]", ",", "qkv", "[", "2", "]", "# make torchscript happy (cannot use tensor as tuple)", "\n", "\n", "q", "=", "q", "*", "self", ".", "scale", "\n", "attn", "=", "(", "q", "@", "k", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "\n", "\n", "relative_position_bias", "=", "self", ".", "relative_position_bias_table", "[", "self", ".", "relative_position_index", ".", "view", "(", "-", "1", ")", "]", ".", "view", "(", "\n", "self", ".", "window_size", "[", "0", "]", "*", "self", ".", "window_size", "[", "1", "]", ",", "self", ".", "window_size", "[", "0", "]", "*", "self", ".", "window_size", "[", "1", "]", ",", "-", "1", ")", "# Wh*Ww,Wh*Ww,nH", "\n", "relative_position_bias", "=", "relative_position_bias", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "contiguous", "(", ")", "# nH, Wh*Ww, Wh*Ww", "\n", "attn", "=", "attn", "+", "relative_position_bias", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "nW", "=", "mask", ".", "shape", "[", "0", "]", "\n", "attn", "=", "attn", ".", "view", "(", "B_", "//", "nW", ",", "nW", ",", "self", ".", "num_heads", ",", "N", ",", "N", ")", "+", "mask", ".", "unsqueeze", "(", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "attn", "=", "attn", ".", "view", "(", "-", "1", ",", "self", ".", "num_heads", ",", "N", ",", "N", ")", "\n", "attn", "=", "self", ".", "softmax", "(", "attn", ")", "\n", "", "else", ":", "\n", "            ", "attn", "=", "self", ".", "softmax", "(", "attn", ")", "\n", "\n", "", "attn", "=", "self", ".", "attn_drop", "(", "attn", ")", "\n", "\n", "x", "=", "(", "attn", "@", "v", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "reshape", "(", "B_", ",", "N", ",", "C", ")", "\n", "x", "=", "self", ".", "proj", "(", "x", ")", "\n", "x", "=", "self", ".", "proj_drop", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.WindowAttention.extra_repr": [[147, 149], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f'dim={self.dim}, window_size={self.window_size}, num_heads={self.num_heads}'", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.WindowAttention.flops": [[150, 162], ["None"], "methods", ["None"], ["", "def", "flops", "(", "self", ",", "N", ")", ":", "\n", "# calculate flops for 1 window with token length of N", "\n", "        ", "flops", "=", "0", "\n", "# qkv = self.qkv(x)", "\n", "flops", "+=", "N", "*", "self", ".", "dim", "*", "3", "*", "self", ".", "dim", "\n", "# attn = (q @ k.transpose(-2, -1))", "\n", "flops", "+=", "self", ".", "num_heads", "*", "N", "*", "(", "self", ".", "dim", "//", "self", ".", "num_heads", ")", "*", "N", "\n", "#  x = (attn @ v)", "\n", "flops", "+=", "self", ".", "num_heads", "*", "N", "*", "N", "*", "(", "self", ".", "dim", "//", "self", ".", "num_heads", ")", "\n", "# x = self.proj(x)", "\n", "flops", "+=", "N", "*", "self", ".", "dim", "*", "self", ".", "dim", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.__init__": [[183, 215], ["torch.Module.__init__", "norm_layer", "swinir_arch.WindowAttention", "norm_layer", "int", "swinir_arch.Mlp", "swinir_arch.SwinTransformerBlock.register_buffer", "min", "min", "timm.models.layers.DropPath", "torch.Identity", "torch.Identity", "torch.Identity", "torch.Identity", "swinir_arch.SwinTransformerBlock.calculate_mask", "timm.models.layers.to_2tuple"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.calculate_mask"], ["def", "__init__", "(", "self", ",", "dim", ",", "input_resolution", ",", "num_heads", ",", "window_size", "=", "7", ",", "shift_size", "=", "0", ",", "\n", "mlp_ratio", "=", "4.", ",", "qkv_bias", "=", "True", ",", "qk_scale", "=", "None", ",", "drop", "=", "0.", ",", "attn_drop", "=", "0.", ",", "drop_path", "=", "0.", ",", "\n", "act_layer", "=", "nn", ".", "GELU", ",", "norm_layer", "=", "nn", ".", "LayerNorm", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "self", ".", "num_heads", "=", "num_heads", "\n", "self", ".", "window_size", "=", "window_size", "\n", "self", ".", "shift_size", "=", "shift_size", "\n", "self", ".", "mlp_ratio", "=", "mlp_ratio", "\n", "if", "min", "(", "self", ".", "input_resolution", ")", "<=", "self", ".", "window_size", ":", "\n", "# if window size is larger than input resolution, we don't partition windows", "\n", "            ", "self", ".", "shift_size", "=", "0", "\n", "self", ".", "window_size", "=", "min", "(", "self", ".", "input_resolution", ")", "\n", "", "assert", "0", "<=", "self", ".", "shift_size", "<", "self", ".", "window_size", ",", "\"shift_size must in 0-window_size\"", "\n", "\n", "self", ".", "norm1", "=", "norm_layer", "(", "dim", ")", "\n", "self", ".", "attn", "=", "WindowAttention", "(", "\n", "dim", ",", "window_size", "=", "to_2tuple", "(", "self", ".", "window_size", ")", ",", "num_heads", "=", "num_heads", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "qk_scale", "=", "qk_scale", ",", "attn_drop", "=", "attn_drop", ",", "proj_drop", "=", "drop", ")", "\n", "\n", "self", ".", "drop_path", "=", "DropPath", "(", "drop_path", ")", "if", "drop_path", ">", "0.", "else", "nn", ".", "Identity", "(", ")", "\n", "self", ".", "norm2", "=", "norm_layer", "(", "dim", ")", "\n", "mlp_hidden_dim", "=", "int", "(", "dim", "*", "mlp_ratio", ")", "\n", "self", ".", "mlp", "=", "Mlp", "(", "in_features", "=", "dim", ",", "hidden_features", "=", "mlp_hidden_dim", ",", "act_layer", "=", "act_layer", ",", "drop", "=", "drop", ")", "\n", "\n", "if", "self", ".", "shift_size", ">", "0", ":", "\n", "            ", "attn_mask", "=", "self", ".", "calculate_mask", "(", "self", ".", "input_resolution", ")", "\n", "", "else", ":", "\n", "            ", "attn_mask", "=", "None", "\n", "\n", "", "self", ".", "register_buffer", "(", "\"attn_mask\"", ",", "attn_mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.calculate_mask": [[216, 238], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "swinir_arch.window_partition", "mask_windows.view.view.view", "attn_mask.masked_fill().masked_fill.masked_fill().masked_fill.masked_fill().masked_fill", "slice", "slice", "slice", "slice", "slice", "slice", "mask_windows.view.view.unsqueeze", "mask_windows.view.view.unsqueeze", "float", "attn_mask.masked_fill().masked_fill.masked_fill().masked_fill.masked_fill", "float"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.window_partition"], ["", "def", "calculate_mask", "(", "self", ",", "x_size", ")", ":", "\n", "# calculate attention mask for SW-MSA", "\n", "        ", "H", ",", "W", "=", "x_size", "\n", "img_mask", "=", "torch", ".", "zeros", "(", "(", "1", ",", "H", ",", "W", ",", "1", ")", ")", "# 1 H W 1", "\n", "h_slices", "=", "(", "slice", "(", "0", ",", "-", "self", ".", "window_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "window_size", ",", "-", "self", ".", "shift_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "shift_size", ",", "None", ")", ")", "\n", "w_slices", "=", "(", "slice", "(", "0", ",", "-", "self", ".", "window_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "window_size", ",", "-", "self", ".", "shift_size", ")", ",", "\n", "slice", "(", "-", "self", ".", "shift_size", ",", "None", ")", ")", "\n", "cnt", "=", "0", "\n", "for", "h", "in", "h_slices", ":", "\n", "            ", "for", "w", "in", "w_slices", ":", "\n", "                ", "img_mask", "[", ":", ",", "h", ",", "w", ",", ":", "]", "=", "cnt", "\n", "cnt", "+=", "1", "\n", "\n", "", "", "mask_windows", "=", "window_partition", "(", "img_mask", ",", "self", ".", "window_size", ")", "# nW, window_size, window_size, 1", "\n", "mask_windows", "=", "mask_windows", ".", "view", "(", "-", "1", ",", "self", ".", "window_size", "*", "self", ".", "window_size", ")", "\n", "attn_mask", "=", "mask_windows", ".", "unsqueeze", "(", "1", ")", "-", "mask_windows", ".", "unsqueeze", "(", "2", ")", "\n", "attn_mask", "=", "attn_mask", ".", "masked_fill", "(", "attn_mask", "!=", "0", ",", "float", "(", "-", "100.0", ")", ")", ".", "masked_fill", "(", "attn_mask", "==", "0", ",", "float", "(", "0.0", ")", ")", "\n", "\n", "return", "attn_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.forward": [[239, 280], ["swinir_arch.SwinTransformerBlock.norm1", "torch.roll.view", "torch.roll.view", "torch.roll.view", "torch.roll.view", "swinir_arch.window_partition", "x_windows.view.view.view", "swinir_arch.SwinTransformerBlock.view", "swinir_arch.window_reverse", "torch.roll.view", "torch.roll.view", "torch.roll.view", "torch.roll.view", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "swinir_arch.SwinTransformerBlock.attn", "swinir_arch.SwinTransformerBlock.attn", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "torch.roll", "swinir_arch.SwinTransformerBlock.drop_path", "swinir_arch.SwinTransformerBlock.drop_path", "swinir_arch.SwinTransformerBlock.mlp", "swinir_arch.SwinTransformerBlock.calculate_mask().to", "swinir_arch.SwinTransformerBlock.norm2", "swinir_arch.SwinTransformerBlock.calculate_mask"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.window_partition", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.window_reverse", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.calculate_mask"], ["", "def", "forward", "(", "self", ",", "x", ",", "x_size", ")", ":", "\n", "        ", "H", ",", "W", "=", "x_size", "\n", "B", ",", "L", ",", "C", "=", "x", ".", "shape", "\n", "# assert L == H * W, \"input feature has wrong size\"", "\n", "\n", "shortcut", "=", "x", "\n", "x", "=", "self", ".", "norm1", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "H", ",", "W", ",", "C", ")", "\n", "\n", "# cyclic shift", "\n", "if", "self", ".", "shift_size", ">", "0", ":", "\n", "            ", "shifted_x", "=", "torch", ".", "roll", "(", "x", ",", "shifts", "=", "(", "-", "self", ".", "shift_size", ",", "-", "self", ".", "shift_size", ")", ",", "dims", "=", "(", "1", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "shifted_x", "=", "x", "\n", "\n", "# partition windows", "\n", "", "x_windows", "=", "window_partition", "(", "shifted_x", ",", "self", ".", "window_size", ")", "# nW*B, window_size, window_size, C", "\n", "x_windows", "=", "x_windows", ".", "view", "(", "-", "1", ",", "self", ".", "window_size", "*", "self", ".", "window_size", ",", "C", ")", "# nW*B, window_size*window_size, C", "\n", "\n", "# W-MSA/SW-MSA (to be compatible for testing on images whose shapes are the multiple of window size", "\n", "if", "self", ".", "input_resolution", "==", "x_size", ":", "\n", "            ", "attn_windows", "=", "self", ".", "attn", "(", "x_windows", ",", "mask", "=", "self", ".", "attn_mask", ")", "# nW*B, window_size*window_size, C", "\n", "", "else", ":", "\n", "            ", "attn_windows", "=", "self", ".", "attn", "(", "x_windows", ",", "mask", "=", "self", ".", "calculate_mask", "(", "x_size", ")", ".", "to", "(", "x", ".", "device", ")", ")", "\n", "\n", "# merge windows", "\n", "", "attn_windows", "=", "attn_windows", ".", "view", "(", "-", "1", ",", "self", ".", "window_size", ",", "self", ".", "window_size", ",", "C", ")", "\n", "shifted_x", "=", "window_reverse", "(", "attn_windows", ",", "self", ".", "window_size", ",", "H", ",", "W", ")", "# B H' W' C", "\n", "\n", "# reverse cyclic shift", "\n", "if", "self", ".", "shift_size", ">", "0", ":", "\n", "            ", "x", "=", "torch", ".", "roll", "(", "shifted_x", ",", "shifts", "=", "(", "self", ".", "shift_size", ",", "self", ".", "shift_size", ")", ",", "dims", "=", "(", "1", ",", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "shifted_x", "\n", "", "x", "=", "x", ".", "view", "(", "B", ",", "H", "*", "W", ",", "C", ")", "\n", "\n", "# FFN", "\n", "x", "=", "shortcut", "+", "self", ".", "drop_path", "(", "x", ")", "\n", "x", "=", "x", "+", "self", ".", "drop_path", "(", "self", ".", "mlp", "(", "self", ".", "norm2", "(", "x", ")", ")", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.extra_repr": [[281, 283], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f\"dim={self.dim}, input_resolution={self.input_resolution}, num_heads={self.num_heads}, \"", "f\"window_size={self.window_size}, shift_size={self.shift_size}, mlp_ratio={self.mlp_ratio}\"", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinTransformerBlock.flops": [[285, 298], ["swinir_arch.SwinTransformerBlock.attn.flops"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "flops", "=", "0", "\n", "H", ",", "W", "=", "self", ".", "input_resolution", "\n", "# norm1", "\n", "flops", "+=", "self", ".", "dim", "*", "H", "*", "W", "\n", "# W-MSA/SW-MSA", "\n", "nW", "=", "H", "*", "W", "/", "self", ".", "window_size", "/", "self", ".", "window_size", "\n", "flops", "+=", "nW", "*", "self", ".", "attn", ".", "flops", "(", "self", ".", "window_size", "*", "self", ".", "window_size", ")", "\n", "# mlp", "\n", "flops", "+=", "2", "*", "H", "*", "W", "*", "self", ".", "dim", "*", "self", ".", "dim", "*", "self", ".", "mlp_ratio", "\n", "# norm2", "\n", "flops", "+=", "self", ".", "dim", "*", "H", "*", "W", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchMerging.__init__": [[309, 315], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "norm_layer"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "input_resolution", ",", "dim", ",", "norm_layer", "=", "nn", ".", "LayerNorm", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "reduction", "=", "nn", ".", "Linear", "(", "4", "*", "dim", ",", "2", "*", "dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "norm", "=", "norm_layer", "(", "4", "*", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchMerging.forward": [[316, 338], ["swinir_arch.PatchMerging.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "swinir_arch.PatchMerging.view", "swinir_arch.PatchMerging.norm", "swinir_arch.PatchMerging.reduction"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        x: B, H*W, C\n        \"\"\"", "\n", "H", ",", "W", "=", "self", ".", "input_resolution", "\n", "B", ",", "L", ",", "C", "=", "x", ".", "shape", "\n", "assert", "L", "==", "H", "*", "W", ",", "\"input feature has wrong size\"", "\n", "assert", "H", "%", "2", "==", "0", "and", "W", "%", "2", "==", "0", ",", "f\"x size ({H}*{W}) are not even.\"", "\n", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "H", ",", "W", ",", "C", ")", "\n", "\n", "x0", "=", "x", "[", ":", ",", "0", ":", ":", "2", ",", "0", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x1", "=", "x", "[", ":", ",", "1", ":", ":", "2", ",", "0", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x2", "=", "x", "[", ":", ",", "0", ":", ":", "2", ",", "1", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x3", "=", "x", "[", ":", ",", "1", ":", ":", "2", ",", "1", ":", ":", "2", ",", ":", "]", "# B H/2 W/2 C", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x0", ",", "x1", ",", "x2", ",", "x3", "]", ",", "-", "1", ")", "# B H/2 W/2 4*C", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "-", "1", ",", "4", "*", "C", ")", "# B H/2*W/2 4*C", "\n", "\n", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "x", "=", "self", ".", "reduction", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchMerging.extra_repr": [[339, 341], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f\"input_resolution={self.input_resolution}, dim={self.dim}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchMerging.flops": [[342, 347], ["None"], "methods", ["None"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "self", ".", "input_resolution", "\n", "flops", "=", "H", "*", "W", "*", "self", ".", "dim", "\n", "flops", "+=", "(", "H", "//", "2", ")", "*", "(", "W", "//", "2", ")", "*", "4", "*", "self", ".", "dim", "*", "2", "*", "self", ".", "dim", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.BasicLayer.__init__": [[369, 396], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "downsample", "swinir_arch.SwinTransformerBlock", "range", "isinstance"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "dim", ",", "input_resolution", ",", "depth", ",", "num_heads", ",", "window_size", ",", "\n", "mlp_ratio", "=", "4.", ",", "qkv_bias", "=", "True", ",", "qk_scale", "=", "None", ",", "drop", "=", "0.", ",", "attn_drop", "=", "0.", ",", "\n", "drop_path", "=", "0.", ",", "norm_layer", "=", "nn", ".", "LayerNorm", ",", "downsample", "=", "None", ",", "use_checkpoint", "=", "False", ")", ":", "\n", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "self", ".", "depth", "=", "depth", "\n", "self", ".", "use_checkpoint", "=", "use_checkpoint", "\n", "\n", "# build blocks", "\n", "self", ".", "blocks", "=", "nn", ".", "ModuleList", "(", "[", "\n", "SwinTransformerBlock", "(", "dim", "=", "dim", ",", "input_resolution", "=", "input_resolution", ",", "\n", "num_heads", "=", "num_heads", ",", "window_size", "=", "window_size", ",", "\n", "shift_size", "=", "0", "if", "(", "i", "%", "2", "==", "0", ")", "else", "window_size", "//", "2", ",", "\n", "mlp_ratio", "=", "mlp_ratio", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "qk_scale", "=", "qk_scale", ",", "\n", "drop", "=", "drop", ",", "attn_drop", "=", "attn_drop", ",", "\n", "drop_path", "=", "drop_path", "[", "i", "]", "if", "isinstance", "(", "drop_path", ",", "list", ")", "else", "drop_path", ",", "\n", "norm_layer", "=", "norm_layer", ")", "\n", "for", "i", "in", "range", "(", "depth", ")", "]", ")", "\n", "\n", "# patch merging layer", "\n", "if", "downsample", "is", "not", "None", ":", "\n", "            ", "self", ".", "downsample", "=", "downsample", "(", "input_resolution", ",", "dim", "=", "dim", ",", "norm_layer", "=", "norm_layer", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "downsample", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.BasicLayer.forward": [[397, 406], ["swinir_arch.BasicLayer.downsample", "torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "torch.checkpoint", "blk"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "x_size", ")", ":", "\n", "        ", "for", "blk", "in", "self", ".", "blocks", ":", "\n", "            ", "if", "self", ".", "use_checkpoint", ":", "\n", "                ", "x", "=", "checkpoint", ".", "checkpoint", "(", "blk", ",", "x", ",", "x_size", ")", "\n", "", "else", ":", "\n", "                ", "x", "=", "blk", "(", "x", ",", "x_size", ")", "\n", "", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "downsample", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.BasicLayer.extra_repr": [[407, 409], ["None"], "methods", ["None"], ["", "def", "extra_repr", "(", "self", ")", "->", "str", ":", "\n", "        ", "return", "f\"dim={self.dim}, input_resolution={self.input_resolution}, depth={self.depth}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.BasicLayer.flops": [[410, 417], ["blk.flops", "swinir_arch.BasicLayer.downsample.flops"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "flops", "=", "0", "\n", "for", "blk", "in", "self", ".", "blocks", ":", "\n", "            ", "flops", "+=", "blk", ".", "flops", "(", ")", "\n", "", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "flops", "+=", "self", ".", "downsample", ".", "flops", "(", ")", "\n", "", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.RSTB.__init__": [[442, 480], ["torch.Module.__init__", "swinir_arch.BasicLayer", "swinir_arch.PatchEmbed", "swinir_arch.PatchUnEmbed", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "dim", ",", "input_resolution", ",", "depth", ",", "num_heads", ",", "window_size", ",", "\n", "mlp_ratio", "=", "4.", ",", "qkv_bias", "=", "True", ",", "qk_scale", "=", "None", ",", "drop", "=", "0.", ",", "attn_drop", "=", "0.", ",", "\n", "drop_path", "=", "0.", ",", "norm_layer", "=", "nn", ".", "LayerNorm", ",", "downsample", "=", "None", ",", "use_checkpoint", "=", "False", ",", "\n", "img_size", "=", "224", ",", "patch_size", "=", "4", ",", "resi_connection", "=", "'1conv'", ")", ":", "\n", "        ", "super", "(", "RSTB", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "dim", "=", "dim", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "\n", "self", ".", "residual_group", "=", "BasicLayer", "(", "dim", "=", "dim", ",", "\n", "input_resolution", "=", "input_resolution", ",", "\n", "depth", "=", "depth", ",", "\n", "num_heads", "=", "num_heads", ",", "\n", "window_size", "=", "window_size", ",", "\n", "mlp_ratio", "=", "mlp_ratio", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "qk_scale", "=", "qk_scale", ",", "\n", "drop", "=", "drop", ",", "attn_drop", "=", "attn_drop", ",", "\n", "drop_path", "=", "drop_path", ",", "\n", "norm_layer", "=", "norm_layer", ",", "\n", "downsample", "=", "downsample", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ")", "\n", "\n", "if", "resi_connection", "==", "'1conv'", ":", "\n", "            ", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "dim", ",", "dim", ",", "3", ",", "1", ",", "1", ")", "\n", "", "elif", "resi_connection", "==", "'3conv'", ":", "\n", "# to save parameters and memory", "\n", "            ", "self", ".", "conv", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "dim", ",", "dim", "//", "4", ",", "3", ",", "1", ",", "1", ")", ",", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "dim", "//", "4", ",", "dim", "//", "4", ",", "1", ",", "1", ",", "0", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "dim", "//", "4", ",", "dim", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "\n", "", "self", ".", "patch_embed", "=", "PatchEmbed", "(", "\n", "img_size", "=", "img_size", ",", "patch_size", "=", "patch_size", ",", "in_chans", "=", "0", ",", "embed_dim", "=", "dim", ",", "\n", "norm_layer", "=", "None", ")", "\n", "\n", "self", ".", "patch_unembed", "=", "PatchUnEmbed", "(", "\n", "img_size", "=", "img_size", ",", "patch_size", "=", "patch_size", ",", "in_chans", "=", "0", ",", "embed_dim", "=", "dim", ",", "\n", "norm_layer", "=", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.RSTB.forward": [[481, 483], ["swinir_arch.RSTB.patch_embed", "swinir_arch.RSTB.conv", "swinir_arch.RSTB.patch_unembed", "swinir_arch.RSTB.residual_group"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "x_size", ")", ":", "\n", "        ", "return", "self", ".", "patch_embed", "(", "self", ".", "conv", "(", "self", ".", "patch_unembed", "(", "self", ".", "residual_group", "(", "x", ",", "x_size", ")", ",", "x_size", ")", ")", ")", "+", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.RSTB.flops": [[484, 493], ["swinir_arch.RSTB.residual_group.flops", "swinir_arch.RSTB.patch_embed.flops", "swinir_arch.RSTB.patch_unembed.flops"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "flops", "=", "0", "\n", "flops", "+=", "self", ".", "residual_group", ".", "flops", "(", ")", "\n", "H", ",", "W", "=", "self", ".", "input_resolution", "\n", "flops", "+=", "H", "*", "W", "*", "self", ".", "dim", "*", "self", ".", "dim", "*", "9", "\n", "flops", "+=", "self", ".", "patch_embed", ".", "flops", "(", ")", "\n", "flops", "+=", "self", ".", "patch_unembed", ".", "flops", "(", ")", "\n", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchEmbed.__init__": [[506, 523], ["torch.Module.__init__", "timm.models.layers.to_2tuple", "timm.models.layers.to_2tuple", "norm_layer"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "img_size", "=", "224", ",", "patch_size", "=", "4", ",", "in_chans", "=", "3", ",", "embed_dim", "=", "96", ",", "norm_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "img_size", "=", "to_2tuple", "(", "img_size", ")", "\n", "patch_size", "=", "to_2tuple", "(", "patch_size", ")", "\n", "patches_resolution", "=", "[", "img_size", "[", "0", "]", "//", "patch_size", "[", "0", "]", ",", "img_size", "[", "1", "]", "//", "patch_size", "[", "1", "]", "]", "\n", "self", ".", "img_size", "=", "img_size", "\n", "self", ".", "patch_size", "=", "patch_size", "\n", "self", ".", "patches_resolution", "=", "patches_resolution", "\n", "self", ".", "num_patches", "=", "patches_resolution", "[", "0", "]", "*", "patches_resolution", "[", "1", "]", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "\n", "if", "norm_layer", "is", "not", "None", ":", "\n", "            ", "self", ".", "norm", "=", "norm_layer", "(", "embed_dim", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "norm", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchEmbed.forward": [[524, 529], ["swinir_arch.PatchEmbed.flatten().transpose", "swinir_arch.PatchEmbed.norm", "swinir_arch.PatchEmbed.flatten"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "x", ".", "flatten", "(", "2", ")", ".", "transpose", "(", "1", ",", "2", ")", "# B Ph*Pw C", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchEmbed.flops": [[530, 536], ["None"], "methods", ["None"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "flops", "=", "0", "\n", "H", ",", "W", "=", "self", ".", "img_size", "\n", "if", "self", ".", "norm", "is", "not", "None", ":", "\n", "            ", "flops", "+=", "H", "*", "W", "*", "self", ".", "embed_dim", "\n", "", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchUnEmbed.__init__": [[549, 561], ["torch.Module.__init__", "timm.models.layers.to_2tuple", "timm.models.layers.to_2tuple"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "img_size", "=", "224", ",", "patch_size", "=", "4", ",", "in_chans", "=", "3", ",", "embed_dim", "=", "96", ",", "norm_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "img_size", "=", "to_2tuple", "(", "img_size", ")", "\n", "patch_size", "=", "to_2tuple", "(", "patch_size", ")", "\n", "patches_resolution", "=", "[", "img_size", "[", "0", "]", "//", "patch_size", "[", "0", "]", ",", "img_size", "[", "1", "]", "//", "patch_size", "[", "1", "]", "]", "\n", "self", ".", "img_size", "=", "img_size", "\n", "self", ".", "patch_size", "=", "patch_size", "\n", "self", ".", "patches_resolution", "=", "patches_resolution", "\n", "self", ".", "num_patches", "=", "patches_resolution", "[", "0", "]", "*", "patches_resolution", "[", "1", "]", "\n", "\n", "self", ".", "in_chans", "=", "in_chans", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchUnEmbed.forward": [[562, 566], ["x.transpose().view.transpose().view.transpose().view", "x.transpose().view.transpose().view.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "x_size", ")", ":", "\n", "        ", "B", ",", "HW", ",", "C", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "view", "(", "B", ",", "self", ".", "embed_dim", ",", "x_size", "[", "0", "]", ",", "x_size", "[", "1", "]", ")", "# B Ph*Pw C", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.PatchUnEmbed.flops": [[567, 570], ["None"], "methods", ["None"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "flops", "=", "0", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.Upsample.__init__": [[580, 592], ["torch.Sequential.__init__", "range", "int", "m.append", "m.append", "m.append", "m.append", "ValueError", "math.log", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.PixelShuffle", "torch.PixelShuffle", "torch.PixelShuffle", "torch.PixelShuffle", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.PixelShuffle", "torch.PixelShuffle", "torch.PixelShuffle", "torch.PixelShuffle"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "scale", ",", "num_feat", ")", ":", "\n", "        ", "m", "=", "[", "]", "\n", "if", "(", "scale", "&", "(", "scale", "-", "1", ")", ")", "==", "0", ":", "# scale = 2^n", "\n", "            ", "for", "_", "in", "range", "(", "int", "(", "math", ".", "log", "(", "scale", ",", "2", ")", ")", ")", ":", "\n", "                ", "m", ".", "append", "(", "nn", ".", "Conv2d", "(", "num_feat", ",", "4", "*", "num_feat", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "m", ".", "append", "(", "nn", ".", "PixelShuffle", "(", "2", ")", ")", "\n", "", "", "elif", "scale", "==", "3", ":", "\n", "            ", "m", ".", "append", "(", "nn", ".", "Conv2d", "(", "num_feat", ",", "9", "*", "num_feat", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "m", ".", "append", "(", "nn", ".", "PixelShuffle", "(", "3", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'scale {scale} is not supported. '", "'Supported scales: 2^n and 3.'", ")", "\n", "", "super", "(", "Upsample", ",", "self", ")", ".", "__init__", "(", "*", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.UpsampleOneStep.__init__": [[604, 611], ["m.append", "m.append", "torch.Sequential.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.PixelShuffle", "torch.PixelShuffle", "torch.PixelShuffle", "torch.PixelShuffle"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "scale", ",", "num_feat", ",", "num_out_ch", ",", "input_resolution", "=", "None", ")", ":", "\n", "        ", "self", ".", "num_feat", "=", "num_feat", "\n", "self", ".", "input_resolution", "=", "input_resolution", "\n", "m", "=", "[", "]", "\n", "m", ".", "append", "(", "nn", ".", "Conv2d", "(", "num_feat", ",", "(", "scale", "**", "2", ")", "*", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "m", ".", "append", "(", "nn", ".", "PixelShuffle", "(", "scale", ")", ")", "\n", "super", "(", "UpsampleOneStep", ",", "self", ")", ".", "__init__", "(", "*", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.UpsampleOneStep.flops": [[612, 616], ["None"], "methods", ["None"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "H", ",", "W", "=", "self", ".", "input_resolution", "\n", "flops", "=", "H", "*", "W", "*", "self", ".", "num_feat", "*", "3", "*", "9", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.__init__": [[646, 774], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "len", "swinir_arch.PatchEmbed", "swinir_arch.PatchUnEmbed", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "range", "norm_layer", "swinir_arch.SwinIR.apply", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "timm.models.layers.trunc_normal_", "x.item", "swinir_arch.RSTB", "swinir_arch.SwinIR.layers.append", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "swinir_arch.Upsample", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.linspace", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "swinir_arch.UpsampleOneStep", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "sum", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "sum", "sum", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "img_size", "=", "64", ",", "patch_size", "=", "1", ",", "in_chans", "=", "3", ",", "\n", "embed_dim", "=", "96", ",", "depths", "=", "[", "6", ",", "6", ",", "6", ",", "6", "]", ",", "num_heads", "=", "[", "6", ",", "6", ",", "6", ",", "6", "]", ",", "\n", "window_size", "=", "7", ",", "mlp_ratio", "=", "4.", ",", "qkv_bias", "=", "True", ",", "qk_scale", "=", "None", ",", "\n", "drop_rate", "=", "0.", ",", "attn_drop_rate", "=", "0.", ",", "drop_path_rate", "=", "0.1", ",", "\n", "norm_layer", "=", "nn", ".", "LayerNorm", ",", "ape", "=", "False", ",", "patch_norm", "=", "True", ",", "\n", "use_checkpoint", "=", "False", ",", "upscale", "=", "2", ",", "img_range", "=", "1.", ",", "upsampler", "=", "''", ",", "resi_connection", "=", "'1conv'", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "SwinIR", ",", "self", ")", ".", "__init__", "(", ")", "\n", "num_in_ch", "=", "in_chans", "\n", "num_out_ch", "=", "in_chans", "\n", "num_feat", "=", "64", "\n", "self", ".", "img_range", "=", "img_range", "\n", "if", "in_chans", "==", "3", ":", "\n", "            ", "rgb_mean", "=", "(", "0.4488", ",", "0.4371", ",", "0.4040", ")", "\n", "self", ".", "mean", "=", "torch", ".", "Tensor", "(", "rgb_mean", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "mean", "=", "torch", ".", "zeros", "(", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "", "self", ".", "upscale", "=", "upscale", "\n", "self", ".", "upsampler", "=", "upsampler", "\n", "self", ".", "window_size", "=", "window_size", "\n", "\n", "#####################################################################################################", "\n", "################################### 1, shallow feature extraction ###################################", "\n", "self", ".", "conv_first", "=", "nn", ".", "Conv2d", "(", "num_in_ch", ",", "embed_dim", ",", "3", ",", "1", ",", "1", ")", "\n", "\n", "#####################################################################################################", "\n", "################################### 2, deep feature extraction ######################################", "\n", "self", ".", "num_layers", "=", "len", "(", "depths", ")", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "ape", "=", "ape", "\n", "self", ".", "patch_norm", "=", "patch_norm", "\n", "self", ".", "num_features", "=", "embed_dim", "\n", "self", ".", "mlp_ratio", "=", "mlp_ratio", "\n", "\n", "# split image into non-overlapping patches", "\n", "self", ".", "patch_embed", "=", "PatchEmbed", "(", "\n", "img_size", "=", "img_size", ",", "patch_size", "=", "patch_size", ",", "in_chans", "=", "embed_dim", ",", "embed_dim", "=", "embed_dim", ",", "\n", "norm_layer", "=", "norm_layer", "if", "self", ".", "patch_norm", "else", "None", ")", "\n", "num_patches", "=", "self", ".", "patch_embed", ".", "num_patches", "\n", "patches_resolution", "=", "self", ".", "patch_embed", ".", "patches_resolution", "\n", "self", ".", "patches_resolution", "=", "patches_resolution", "\n", "\n", "# merge non-overlapping patches into image", "\n", "self", ".", "patch_unembed", "=", "PatchUnEmbed", "(", "\n", "img_size", "=", "img_size", ",", "patch_size", "=", "patch_size", ",", "in_chans", "=", "embed_dim", ",", "embed_dim", "=", "embed_dim", ",", "\n", "norm_layer", "=", "norm_layer", "if", "self", ".", "patch_norm", "else", "None", ")", "\n", "\n", "# absolute position embedding", "\n", "if", "self", ".", "ape", ":", "\n", "            ", "self", ".", "absolute_pos_embed", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "1", ",", "num_patches", ",", "embed_dim", ")", ")", "\n", "trunc_normal_", "(", "self", ".", "absolute_pos_embed", ",", "std", "=", ".02", ")", "\n", "\n", "", "self", ".", "pos_drop", "=", "nn", ".", "Dropout", "(", "p", "=", "drop_rate", ")", "\n", "\n", "# stochastic depth", "\n", "dpr", "=", "[", "x", ".", "item", "(", ")", "for", "x", "in", "torch", ".", "linspace", "(", "0", ",", "drop_path_rate", ",", "sum", "(", "depths", ")", ")", "]", "# stochastic depth decay rule", "\n", "\n", "# build Residual Swin Transformer blocks (RSTB)", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i_layer", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "layer", "=", "RSTB", "(", "dim", "=", "embed_dim", ",", "\n", "input_resolution", "=", "(", "patches_resolution", "[", "0", "]", ",", "\n", "patches_resolution", "[", "1", "]", ")", ",", "\n", "depth", "=", "depths", "[", "i_layer", "]", ",", "\n", "num_heads", "=", "num_heads", "[", "i_layer", "]", ",", "\n", "window_size", "=", "window_size", ",", "\n", "mlp_ratio", "=", "self", ".", "mlp_ratio", ",", "\n", "qkv_bias", "=", "qkv_bias", ",", "qk_scale", "=", "qk_scale", ",", "\n", "drop", "=", "drop_rate", ",", "attn_drop", "=", "attn_drop_rate", ",", "\n", "drop_path", "=", "dpr", "[", "sum", "(", "depths", "[", ":", "i_layer", "]", ")", ":", "sum", "(", "depths", "[", ":", "i_layer", "+", "1", "]", ")", "]", ",", "# no impact on SR results", "\n", "norm_layer", "=", "norm_layer", ",", "\n", "downsample", "=", "None", ",", "\n", "use_checkpoint", "=", "use_checkpoint", ",", "\n", "img_size", "=", "img_size", ",", "\n", "patch_size", "=", "patch_size", ",", "\n", "resi_connection", "=", "resi_connection", "\n", "\n", ")", "\n", "self", ".", "layers", ".", "append", "(", "layer", ")", "\n", "", "self", ".", "norm", "=", "norm_layer", "(", "self", ".", "num_features", ")", "\n", "\n", "# build the last conv layer in deep feature extraction", "\n", "if", "resi_connection", "==", "'1conv'", ":", "\n", "            ", "self", ".", "conv_after_body", "=", "nn", ".", "Conv2d", "(", "embed_dim", ",", "embed_dim", ",", "3", ",", "1", ",", "1", ")", "\n", "", "elif", "resi_connection", "==", "'3conv'", ":", "\n", "# to save parameters and memory", "\n", "            ", "self", ".", "conv_after_body", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "embed_dim", ",", "embed_dim", "//", "4", ",", "3", ",", "1", ",", "1", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "embed_dim", "//", "4", ",", "embed_dim", "//", "4", ",", "1", ",", "1", ",", "0", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "embed_dim", "//", "4", ",", "embed_dim", ",", "3", ",", "1", ",", "1", ")", ")", "\n", "\n", "#####################################################################################################", "\n", "################################ 3, high quality image reconstruction ################################", "\n", "", "if", "self", ".", "upsampler", "==", "'pixelshuffle'", ":", "\n", "# for classical SR", "\n", "            ", "self", ".", "conv_before_upsample", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "embed_dim", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "upsample", "=", "Upsample", "(", "upscale", ",", "num_feat", ")", "\n", "self", ".", "conv_last", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "", "elif", "self", ".", "upsampler", "==", "'pixelshuffledirect'", ":", "\n", "# for lightweight SR (to save parameters)", "\n", "            ", "self", ".", "upsample", "=", "UpsampleOneStep", "(", "upscale", ",", "embed_dim", ",", "num_out_ch", ",", "\n", "(", "patches_resolution", "[", "0", "]", ",", "patches_resolution", "[", "1", "]", ")", ")", "\n", "", "elif", "self", ".", "upsampler", "==", "'nearest+conv'", ":", "\n", "# for real-world SR (less artifacts)", "\n", "            ", "assert", "self", ".", "upscale", "==", "4", ",", "'only support x4 now.'", "\n", "self", ".", "conv_before_upsample", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "embed_dim", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "conv_up1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_up2", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_hr", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_last", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "", "elif", "self", ".", "upsampler", "==", "'nearest+conv_NoUp'", ":", "\n", "# for real-world SR (less artifacts)", "\n", "            ", "self", ".", "conv_before_upsample", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "embed_dim", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "inplace", "=", "True", ")", ")", "\n", "self", ".", "conv_up1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_up2", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_hr", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv_last", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "", "else", ":", "\n", "# for image denoising and JPEG compression artifact reduction", "\n", "            ", "self", ".", "conv_last", "=", "nn", ".", "Conv2d", "(", "embed_dim", ",", "num_out_ch", ",", "3", ",", "1", ",", "1", ")", "\n", "\n", "", "self", ".", "apply", "(", "self", ".", "_init_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR._init_weights": [[775, 783], ["isinstance", "timm.models.layers.trunc_normal_", "isinstance", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["None"], ["", "def", "_init_weights", "(", "self", ",", "m", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "trunc_normal_", "(", "m", ".", "weight", ",", "std", "=", ".02", ")", "\n", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", "and", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "LayerNorm", ")", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.no_weight_decay": [[784, 787], ["None"], "methods", ["None"], ["", "", "@", "torch", ".", "jit", ".", "ignore", "\n", "def", "no_weight_decay", "(", "self", ")", ":", "\n", "        ", "return", "{", "'absolute_pos_embed'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.no_weight_decay_keywords": [[788, 791], ["None"], "methods", ["None"], ["", "@", "torch", ".", "jit", ".", "ignore", "\n", "def", "no_weight_decay_keywords", "(", "self", ")", ":", "\n", "        ", "return", "{", "'relative_position_bias_table'", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.check_image_size": [[792, 798], ["torch.pad.size", "torch.pad", "torch.pad", "torch.pad", "torch.pad"], "methods", ["None"], ["", "def", "check_image_size", "(", "self", ",", "x", ")", ":", "\n", "        ", "_", ",", "_", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "mod_pad_h", "=", "(", "self", ".", "window_size", "-", "h", "%", "self", ".", "window_size", ")", "%", "self", ".", "window_size", "\n", "mod_pad_w", "=", "(", "self", ".", "window_size", "-", "w", "%", "self", ".", "window_size", ")", "%", "self", ".", "window_size", "\n", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "mod_pad_w", ",", "0", ",", "mod_pad_h", ")", ",", "'reflect'", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward_features": [[799, 813], ["swinir_arch.SwinIR.patch_embed", "swinir_arch.SwinIR.pos_drop", "swinir_arch.SwinIR.norm", "swinir_arch.SwinIR.patch_unembed", "layer"], "methods", ["None"], ["", "def", "forward_features", "(", "self", ",", "x", ")", ":", "\n", "        ", "x_size", "=", "(", "x", ".", "shape", "[", "2", "]", ",", "x", ".", "shape", "[", "3", "]", ")", "\n", "x", "=", "self", ".", "patch_embed", "(", "x", ")", "\n", "if", "self", ".", "ape", ":", "\n", "            ", "x", "=", "x", "+", "self", ".", "absolute_pos_embed", "\n", "", "x", "=", "self", ".", "pos_drop", "(", "x", ")", "\n", "\n", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ",", "x_size", ")", "\n", "\n", "", "x", "=", "self", ".", "norm", "(", "x", ")", "# B L C", "\n", "x", "=", "self", ".", "patch_unembed", "(", "x", ",", "x_size", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward": [[814, 857], ["swinir_arch.SwinIR.check_image_size", "swinir_arch.SwinIR.mean.type_as", "swinir_arch.SwinIR.conv_first", "swinir_arch.SwinIR.conv_before_upsample", "swinir_arch.SwinIR.conv_last", "swinir_arch.SwinIR.conv_after_body", "swinir_arch.SwinIR.upsample", "swinir_arch.SwinIR.conv_first", "swinir_arch.SwinIR.upsample", "swinir_arch.SwinIR.forward_features", "swinir_arch.SwinIR.conv_after_body", "swinir_arch.SwinIR.conv_first", "swinir_arch.SwinIR.conv_before_upsample", "swinir_arch.SwinIR.lrelu", "swinir_arch.SwinIR.lrelu", "swinir_arch.SwinIR.conv_last", "swinir_arch.SwinIR.forward_features", "swinir_arch.SwinIR.conv_after_body", "swinir_arch.SwinIR.conv_up1", "swinir_arch.SwinIR.conv_up2", "swinir_arch.SwinIR.lrelu", "swinir_arch.SwinIR.conv_first", "swinir_arch.SwinIR.conv_before_upsample", "swinir_arch.SwinIR.lrelu", "swinir_arch.SwinIR.lrelu", "swinir_arch.SwinIR.conv_last", "swinir_arch.SwinIR.conv_first", "swinir_arch.SwinIR.forward_features", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "swinir_arch.SwinIR.conv_hr", "swinir_arch.SwinIR.conv_after_body", "swinir_arch.SwinIR.conv_up1", "swinir_arch.SwinIR.conv_up2", "swinir_arch.SwinIR.lrelu", "swinir_arch.SwinIR.conv_after_body", "swinir_arch.SwinIR.conv_last", "swinir_arch.SwinIR.forward_features", "swinir_arch.SwinIR.conv_hr", "swinir_arch.SwinIR.forward_features"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.check_image_size", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward_features", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward_features", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward_features", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward_features", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.forward_features"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "H", ",", "W", "=", "x", ".", "shape", "[", "2", ":", "]", "\n", "x", "=", "self", ".", "check_image_size", "(", "x", ")", "\n", "\n", "self", ".", "mean", "=", "self", ".", "mean", ".", "type_as", "(", "x", ")", "\n", "x", "=", "(", "x", "-", "self", ".", "mean", ")", "*", "self", ".", "img_range", "\n", "\n", "if", "self", ".", "upsampler", "==", "'pixelshuffle'", ":", "\n", "# for classical SR", "\n", "            ", "x", "=", "self", ".", "conv_first", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_after_body", "(", "self", ".", "forward_features", "(", "x", ")", ")", "+", "x", "\n", "x", "=", "self", ".", "conv_before_upsample", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_last", "(", "self", ".", "upsample", "(", "x", ")", ")", "\n", "", "elif", "self", ".", "upsampler", "==", "'pixelshuffledirect'", ":", "\n", "# for lightweight SR", "\n", "            ", "x", "=", "self", ".", "conv_first", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_after_body", "(", "self", ".", "forward_features", "(", "x", ")", ")", "+", "x", "\n", "x", "=", "self", ".", "upsample", "(", "x", ")", "\n", "", "elif", "self", ".", "upsampler", "==", "'nearest+conv'", ":", "\n", "# for real-world SR", "\n", "            ", "x", "=", "self", ".", "conv_first", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_after_body", "(", "self", ".", "forward_features", "(", "x", ")", ")", "+", "x", "\n", "x", "=", "self", ".", "conv_before_upsample", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", "(", "self", ".", "conv_up1", "(", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "x", ",", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ")", ")", "\n", "x", "=", "self", ".", "lrelu", "(", "self", ".", "conv_up2", "(", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "x", ",", "scale_factor", "=", "2", ",", "mode", "=", "'nearest'", ")", ")", ")", "\n", "x", "=", "self", ".", "conv_last", "(", "self", ".", "lrelu", "(", "self", ".", "conv_hr", "(", "x", ")", ")", ")", "\n", "", "elif", "self", ".", "upsampler", "==", "'nearest+conv_NoUp'", ":", "\n", "# for real-world SR No up", "\n", "            ", "x", "=", "self", ".", "conv_first", "(", "x", ")", "\n", "x", "=", "self", ".", "conv_after_body", "(", "self", ".", "forward_features", "(", "x", ")", ")", "+", "x", "\n", "x", "=", "self", ".", "conv_before_upsample", "(", "x", ")", "\n", "x", "=", "self", ".", "lrelu", "(", "self", ".", "conv_up1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "lrelu", "(", "self", ".", "conv_up2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "conv_last", "(", "self", ".", "lrelu", "(", "self", ".", "conv_hr", "(", "x", ")", ")", ")", "\n", "", "else", ":", "\n", "# for image denoising and JPEG compression artifact reduction", "\n", "            ", "x_first", "=", "self", ".", "conv_first", "(", "x", ")", "\n", "res", "=", "self", ".", "conv_after_body", "(", "self", ".", "forward_features", "(", "x_first", ")", ")", "+", "x_first", "\n", "x", "=", "x", "+", "self", ".", "conv_last", "(", "res", ")", "\n", "\n", "", "x", "=", "x", "/", "self", ".", "img_range", "+", "self", ".", "mean", "\n", "\n", "return", "x", "[", ":", ",", ":", ",", ":", "H", "*", "self", ".", "upscale", ",", ":", "W", "*", "self", ".", "upscale", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops": [[858, 868], ["swinir_arch.SwinIR.patch_embed.flops", "enumerate", "swinir_arch.SwinIR.upsample.flops", "layer.flops"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops", "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.SwinIR.flops"], ["", "def", "flops", "(", "self", ")", ":", "\n", "        ", "flops", "=", "0", "\n", "H", ",", "W", "=", "self", ".", "patches_resolution", "\n", "flops", "+=", "H", "*", "W", "*", "3", "*", "self", ".", "embed_dim", "*", "9", "\n", "flops", "+=", "self", ".", "patch_embed", ".", "flops", "(", ")", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "            ", "flops", "+=", "layer", ".", "flops", "(", ")", "\n", "", "flops", "+=", "H", "*", "W", "*", "3", "*", "self", ".", "embed_dim", "*", "self", ".", "embed_dim", "\n", "flops", "+=", "self", ".", "upsample", ".", "flops", "(", ")", "\n", "return", "flops", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.window_partition": [[33, 46], ["x.view.view", "x.view.permute().contiguous().view", "x.view.permute().contiguous", "x.view.permute"], "function", ["None"], ["", "", "def", "window_partition", "(", "x", ",", "window_size", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        x: (B, H, W, C)\n        window_size (int): window size\n\n    Returns:\n        windows: (num_windows*B, window_size, window_size, C)\n    \"\"\"", "\n", "B", ",", "H", ",", "W", ",", "C", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "B", ",", "H", "//", "window_size", ",", "window_size", ",", "W", "//", "window_size", ",", "window_size", ",", "C", ")", "\n", "windows", "=", "x", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ",", "4", ",", "5", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "window_size", ",", "window_size", ",", "C", ")", "\n", "return", "windows", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.swinir_arch.window_reverse": [[48, 63], ["int", "windows.view", "x.permute().contiguous().view.permute().contiguous().view", "x.permute().contiguous().view.permute().contiguous", "x.permute().contiguous().view.permute"], "function", ["None"], ["", "def", "window_reverse", "(", "windows", ",", "window_size", ",", "H", ",", "W", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        windows: (num_windows*B, window_size, window_size, C)\n        window_size (int): Window size\n        H (int): Height of image\n        W (int): Width of image\n\n    Returns:\n        x: (B, H, W, C)\n    \"\"\"", "\n", "B", "=", "int", "(", "windows", ".", "shape", "[", "0", "]", "/", "(", "H", "*", "W", "/", "window_size", "/", "window_size", ")", ")", "\n", "x", "=", "windows", ".", "view", "(", "B", ",", "H", "//", "window_size", ",", "W", "//", "window_size", ",", "window_size", ",", "window_size", ",", "-", "1", ")", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ",", "4", ",", "5", ")", ".", "contiguous", "(", ")", ".", "view", "(", "B", ",", "H", ",", "W", ",", "-", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network": [[19, 26], ["copy.deepcopy", "copy.deepcopy.pop", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.registry.ARCH_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], []], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.__init__": [[14, 53], ["torch.nn.Module.__init__", "discriminator_arch.Discriminator_PatchGAN.get_norm_layer", "int", "range", "min", "torch.nn.Sequential", "range", "discriminator_arch.Discriminator_PatchGAN.model.apply", "numpy.ceil", "min", "len", "discriminator_arch.Discriminator_PatchGAN.model.add_module", "discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "torch.nn.LeakyReLU", "discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "discriminator_arch.Discriminator_PatchGAN.", "torch.nn.LeakyReLU", "discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "torch.nn.Sequential", "torch.nn.Conv2d", "discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "discriminator_arch.Discriminator_PatchGAN.", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "str", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.get_norm_layer", "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.use_spectral_norm", "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.use_spectral_norm"], ["    ", "def", "__init__", "(", "self", ",", "input_nc", "=", "3", ",", "ndf", "=", "64", ",", "n_layers", "=", "3", ",", "norm_type", "=", "'spectral'", ")", ":", "\n", "        ", "'''PatchGAN discriminator, receptive field = 70x70 if n_layers = 3\n        Args:\n            input_nc: number of input channels\n            ndf: base channel number\n            n_layers: number of conv layer with stride 2\n            norm_type:  'batch', 'instance', 'spectral', 'batchspectral', instancespectral'\n        Returns:\n            tensor: score\n        '''", "\n", "super", "(", "Discriminator_PatchGAN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "norm_layer", "=", "self", ".", "get_norm_layer", "(", "norm_type", "=", "norm_type", ")", "\n", "\n", "kw", "=", "4", "\n", "padw", "=", "int", "(", "np", ".", "ceil", "(", "(", "kw", "-", "1.0", ")", "/", "2", ")", ")", "\n", "sequence", "=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "input_nc", ",", "ndf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "2", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", ",", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "]", "\n", "\n", "nf", "=", "ndf", "\n", "for", "n", "in", "range", "(", "1", ",", "n_layers", ")", ":", "\n", "            ", "nf_prev", "=", "nf", "\n", "nf", "=", "min", "(", "nf", "*", "2", ",", "512", ")", "\n", "sequence", "+=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "nf_prev", ",", "nf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "2", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", ",", "\n", "norm_layer", "(", "nf", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "]", "\n", "\n", "", "nf_prev", "=", "nf", "\n", "nf", "=", "min", "(", "nf", "*", "2", ",", "512", ")", "\n", "sequence", "+=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "nf_prev", ",", "nf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "1", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", ",", "\n", "norm_layer", "(", "nf", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "]", "\n", "\n", "sequence", "+=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "nf", ",", "1", ",", "kernel_size", "=", "kw", ",", "stride", "=", "1", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", "]", "]", "\n", "\n", "self", ".", "model", "=", "nn", ".", "Sequential", "(", ")", "\n", "for", "n", "in", "range", "(", "len", "(", "sequence", ")", ")", ":", "\n", "            ", "self", ".", "model", ".", "add_module", "(", "'child'", "+", "str", "(", "n", ")", ",", "nn", ".", "Sequential", "(", "*", "sequence", "[", "n", "]", ")", ")", "\n", "\n", "", "self", ".", "model", ".", "apply", "(", "self", ".", "weights_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.use_spectral_norm": [[54, 58], ["torch.nn.utils.spectral_norm"], "methods", ["None"], ["", "def", "use_spectral_norm", "(", "self", ",", "module", ",", "norm_type", "=", "'spectral'", ")", ":", "\n", "        ", "if", "'spectral'", "in", "norm_type", ":", "\n", "            ", "return", "spectral_norm", "(", "module", ")", "\n", "", "return", "module", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.get_norm_layer": [[59, 67], ["functools.partial", "functools.partial", "functools.partial"], "methods", ["None"], ["", "def", "get_norm_layer", "(", "self", ",", "norm_type", "=", "'instance'", ")", ":", "\n", "        ", "if", "'batch'", "in", "norm_type", ":", "\n", "            ", "norm_layer", "=", "functools", ".", "partial", "(", "nn", ".", "BatchNorm2d", ",", "affine", "=", "True", ")", "\n", "", "elif", "'instance'", "in", "norm_type", ":", "\n", "            ", "norm_layer", "=", "functools", ".", "partial", "(", "nn", ".", "InstanceNorm2d", ",", "affine", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "norm_layer", "=", "functools", ".", "partial", "(", "nn", ".", "Identity", ")", "\n", "", "return", "norm_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.weights_init": [[68, 75], ["classname.find", "m.weight.data.normal_", "classname.find", "m.weight.data.normal_", "m.bias.data.fill_"], "methods", ["None"], ["", "def", "weights_init", "(", "self", ",", "m", ")", ":", "\n", "        ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'Conv'", ")", "!=", "-", "1", ":", "\n", "            ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0.0", ",", "0.02", ")", "\n", "", "elif", "classname", ".", "find", "(", "'BatchNorm2d'", ")", "!=", "-", "1", ":", "\n", "            ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "1.0", ",", "0.02", ")", "\n", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.Discriminator_PatchGAN.forward": [[76, 78], ["discriminator_arch.Discriminator_PatchGAN.model"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "model", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.VGGStyleDiscriminator128.__init__": [[91, 123], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "num_in_ch", ",", "num_feat", ")", ":", "\n", "        ", "super", "(", "VGGStyleDiscriminator128", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv0_0", "=", "nn", ".", "Conv2d", "(", "num_in_ch", ",", "num_feat", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv0_1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn0_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv1_0", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", "*", "2", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "2", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv1_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "2", ",", "num_feat", "*", "2", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "2", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv2_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "2", ",", "num_feat", "*", "4", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "4", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv2_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "4", ",", "num_feat", "*", "4", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "4", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv3_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "4", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv3_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv4_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv4_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "num_feat", "*", "8", "*", "4", "*", "4", ",", "100", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "100", ",", "1", ")", "\n", "\n", "# activation function", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.VGGStyleDiscriminator128.forward": [[124, 146], ["discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.view", "discriminator_arch.VGGStyleDiscriminator128.lrelu", "discriminator_arch.VGGStyleDiscriminator128.linear2", "discriminator_arch.VGGStyleDiscriminator128.conv0_0", "discriminator_arch.VGGStyleDiscriminator128.bn0_1", "discriminator_arch.VGGStyleDiscriminator128.bn1_0", "discriminator_arch.VGGStyleDiscriminator128.bn1_1", "discriminator_arch.VGGStyleDiscriminator128.bn2_0", "discriminator_arch.VGGStyleDiscriminator128.bn2_1", "discriminator_arch.VGGStyleDiscriminator128.bn3_0", "discriminator_arch.VGGStyleDiscriminator128.bn3_1", "discriminator_arch.VGGStyleDiscriminator128.bn4_0", "discriminator_arch.VGGStyleDiscriminator128.bn4_1", "discriminator_arch.VGGStyleDiscriminator128.size", "discriminator_arch.VGGStyleDiscriminator128.linear1", "x.size", "x.size", "x.size", "discriminator_arch.VGGStyleDiscriminator128.conv0_1", "discriminator_arch.VGGStyleDiscriminator128.conv1_0", "discriminator_arch.VGGStyleDiscriminator128.conv1_1", "discriminator_arch.VGGStyleDiscriminator128.conv2_0", "discriminator_arch.VGGStyleDiscriminator128.conv2_1", "discriminator_arch.VGGStyleDiscriminator128.conv3_0", "discriminator_arch.VGGStyleDiscriminator128.conv3_1", "discriminator_arch.VGGStyleDiscriminator128.conv4_0", "discriminator_arch.VGGStyleDiscriminator128.conv4_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "size", "(", "2", ")", "==", "128", "and", "x", ".", "size", "(", "3", ")", "==", "128", ",", "(", "f'Input spatial size must be 128x128, but received {x.size()}.'", ")", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "conv0_0", "(", "x", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn0_1", "(", "self", ".", "conv0_1", "(", "feat", ")", ")", ")", "# output spatial size: (64, 64)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_0", "(", "self", ".", "conv1_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_1", "(", "self", ".", "conv1_1", "(", "feat", ")", ")", ")", "# output spatial size: (32, 32)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_0", "(", "self", ".", "conv2_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_1", "(", "self", ".", "conv2_1", "(", "feat", ")", ")", ")", "# output spatial size: (16, 16)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_0", "(", "self", ".", "conv3_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_1", "(", "self", ".", "conv3_1", "(", "feat", ")", ")", ")", "# output spatial size: (8, 8)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_0", "(", "self", ".", "conv4_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_1", "(", "self", ".", "conv4_1", "(", "feat", ")", ")", ")", "# output spatial size: (4, 4)", "\n", "\n", "feat", "=", "feat", ".", "view", "(", "feat", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "linear1", "(", "feat", ")", ")", "\n", "out", "=", "self", ".", "linear2", "(", "feat", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.VGGStyleDiscriminator192.__init__": [[159, 191], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "num_in_ch", ",", "num_feat", ")", ":", "\n", "        ", "super", "(", "VGGStyleDiscriminator192", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv0_0", "=", "nn", ".", "Conv2d", "(", "num_in_ch", ",", "num_feat", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv0_1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn0_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv1_0", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", "*", "2", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "2", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv1_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "2", ",", "num_feat", "*", "2", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "2", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv2_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "2", ",", "num_feat", "*", "4", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "4", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv2_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "4", ",", "num_feat", "*", "4", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "4", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv3_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "4", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv3_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv4_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_0", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv4_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_1", "=", "nn", ".", "BatchNorm2d", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "num_feat", "*", "8", "*", "6", "*", "6", ",", "100", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "100", ",", "1", ")", "\n", "\n", "# activation function", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.VGGStyleDiscriminator192.forward": [[192, 214], ["discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.view", "discriminator_arch.VGGStyleDiscriminator192.lrelu", "discriminator_arch.VGGStyleDiscriminator192.linear2", "discriminator_arch.VGGStyleDiscriminator192.conv0_0", "discriminator_arch.VGGStyleDiscriminator192.bn0_1", "discriminator_arch.VGGStyleDiscriminator192.bn1_0", "discriminator_arch.VGGStyleDiscriminator192.bn1_1", "discriminator_arch.VGGStyleDiscriminator192.bn2_0", "discriminator_arch.VGGStyleDiscriminator192.bn2_1", "discriminator_arch.VGGStyleDiscriminator192.bn3_0", "discriminator_arch.VGGStyleDiscriminator192.bn3_1", "discriminator_arch.VGGStyleDiscriminator192.bn4_0", "discriminator_arch.VGGStyleDiscriminator192.bn4_1", "discriminator_arch.VGGStyleDiscriminator192.size", "discriminator_arch.VGGStyleDiscriminator192.linear1", "x.size", "x.size", "x.size", "discriminator_arch.VGGStyleDiscriminator192.conv0_1", "discriminator_arch.VGGStyleDiscriminator192.conv1_0", "discriminator_arch.VGGStyleDiscriminator192.conv1_1", "discriminator_arch.VGGStyleDiscriminator192.conv2_0", "discriminator_arch.VGGStyleDiscriminator192.conv2_1", "discriminator_arch.VGGStyleDiscriminator192.conv3_0", "discriminator_arch.VGGStyleDiscriminator192.conv3_1", "discriminator_arch.VGGStyleDiscriminator192.conv4_0", "discriminator_arch.VGGStyleDiscriminator192.conv4_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "size", "(", "2", ")", "==", "192", "and", "x", ".", "size", "(", "3", ")", "==", "192", ",", "(", "f'Input spatial size must be 192x192, but received {x.size()}.'", ")", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "conv0_0", "(", "x", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn0_1", "(", "self", ".", "conv0_1", "(", "feat", ")", ")", ")", "# output spatial size: (96, 96)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_0", "(", "self", ".", "conv1_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_1", "(", "self", ".", "conv1_1", "(", "feat", ")", ")", ")", "# output spatial size: (48, 48)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_0", "(", "self", ".", "conv2_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_1", "(", "self", ".", "conv2_1", "(", "feat", ")", ")", ")", "# output spatial size: (24, 24)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_0", "(", "self", ".", "conv3_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_1", "(", "self", ".", "conv3_1", "(", "feat", ")", ")", ")", "# output spatial size: (12, 12)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_0", "(", "self", ".", "conv4_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_1", "(", "self", ".", "conv4_1", "(", "feat", ")", ")", ")", "# output spatial size: (6, 6)", "\n", "\n", "feat", "=", "feat", ".", "view", "(", "feat", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "linear1", "(", "feat", ")", ")", "\n", "out", "=", "self", ".", "linear2", "(", "feat", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.VGGStyleDiscriminator256.__init__": [[227, 264], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Conv2d", "torch.nn.SyncBatchNorm", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "num_in_ch", ",", "num_feat", ")", ":", "\n", "        ", "super", "(", "VGGStyleDiscriminator256", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv0_0", "=", "nn", ".", "Conv2d", "(", "num_in_ch", ",", "num_feat", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv0_1", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn0_1", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv1_0", "=", "nn", ".", "Conv2d", "(", "num_feat", ",", "num_feat", "*", "2", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_0", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "2", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv1_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "2", ",", "num_feat", "*", "2", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "2", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv2_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "2", ",", "num_feat", "*", "4", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_0", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "4", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv2_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "4", ",", "num_feat", "*", "4", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "4", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv3_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "4", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_0", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv3_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_1", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv4_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_0", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv4_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_1", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "conv5_0", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn5_0", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv5_1", "=", "nn", ".", "Conv2d", "(", "num_feat", "*", "8", ",", "num_feat", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn5_1", "=", "nn", ".", "SyncBatchNorm", "(", "num_feat", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "num_feat", "*", "8", "*", "4", "*", "4", ",", "100", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "100", ",", "1", ")", "\n", "\n", "# activation function", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.VGGStyleDiscriminator256.forward": [[265, 290], ["discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.view", "discriminator_arch.VGGStyleDiscriminator256.lrelu", "discriminator_arch.VGGStyleDiscriminator256.linear2", "discriminator_arch.VGGStyleDiscriminator256.conv0_0", "discriminator_arch.VGGStyleDiscriminator256.bn0_1", "discriminator_arch.VGGStyleDiscriminator256.bn1_0", "discriminator_arch.VGGStyleDiscriminator256.bn1_1", "discriminator_arch.VGGStyleDiscriminator256.bn2_0", "discriminator_arch.VGGStyleDiscriminator256.bn2_1", "discriminator_arch.VGGStyleDiscriminator256.bn3_0", "discriminator_arch.VGGStyleDiscriminator256.bn3_1", "discriminator_arch.VGGStyleDiscriminator256.bn4_0", "discriminator_arch.VGGStyleDiscriminator256.bn4_1", "discriminator_arch.VGGStyleDiscriminator256.bn5_0", "discriminator_arch.VGGStyleDiscriminator256.bn5_1", "discriminator_arch.VGGStyleDiscriminator256.size", "discriminator_arch.VGGStyleDiscriminator256.linear1", "x.size", "x.size", "x.size", "discriminator_arch.VGGStyleDiscriminator256.conv0_1", "discriminator_arch.VGGStyleDiscriminator256.conv1_0", "discriminator_arch.VGGStyleDiscriminator256.conv1_1", "discriminator_arch.VGGStyleDiscriminator256.conv2_0", "discriminator_arch.VGGStyleDiscriminator256.conv2_1", "discriminator_arch.VGGStyleDiscriminator256.conv3_0", "discriminator_arch.VGGStyleDiscriminator256.conv3_1", "discriminator_arch.VGGStyleDiscriminator256.conv4_0", "discriminator_arch.VGGStyleDiscriminator256.conv4_1", "discriminator_arch.VGGStyleDiscriminator256.conv5_0", "discriminator_arch.VGGStyleDiscriminator256.conv5_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "size", "(", "2", ")", "==", "256", "and", "x", ".", "size", "(", "3", ")", "==", "256", ",", "(", "f'Input spatial size must be 256x256, but received {x.size()}.'", ")", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "conv0_0", "(", "x", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn0_1", "(", "self", ".", "conv0_1", "(", "feat", ")", ")", ")", "# output spatial size: (128, 128)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_0", "(", "self", ".", "conv1_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_1", "(", "self", ".", "conv1_1", "(", "feat", ")", ")", ")", "# output spatial size: (64, 64)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_0", "(", "self", ".", "conv2_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_1", "(", "self", ".", "conv2_1", "(", "feat", ")", ")", ")", "# output spatial size: (32, 32)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_0", "(", "self", ".", "conv3_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_1", "(", "self", ".", "conv3_1", "(", "feat", ")", ")", ")", "# output spatial size: (16, 16)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_0", "(", "self", ".", "conv4_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_1", "(", "self", ".", "conv4_1", "(", "feat", ")", ")", ")", "# output spatial size: (8, 8)", "\n", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn5_0", "(", "self", ".", "conv5_0", "(", "feat", ")", ")", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "bn5_1", "(", "self", ".", "conv5_1", "(", "feat", ")", ")", ")", "# output spatial size: (4, 4)", "\n", "\n", "feat", "=", "feat", ".", "view", "(", "feat", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "feat", "=", "self", ".", "lrelu", "(", "self", ".", "linear1", "(", "feat", ")", ")", "\n", "out", "=", "self", ".", "linear2", "(", "feat", ")", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.UNetDiscriminatorSN.__init__": [[11, 31], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "norm", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["# --------------------------------------------", "\n", "@", "ARCH_REGISTRY", ".", "register", "(", ")", "\n", "class", "Discriminator_PatchGAN", "(", "nn", ".", "Module", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "input_nc", "=", "3", ",", "ndf", "=", "64", ",", "n_layers", "=", "3", ",", "norm_type", "=", "'spectral'", ")", ":", "\n", "        ", "'''PatchGAN discriminator, receptive field = 70x70 if n_layers = 3\n        Args:\n            input_nc: number of input channels\n            ndf: base channel number\n            n_layers: number of conv layer with stride 2\n            norm_type:  'batch', 'instance', 'spectral', 'batchspectral', instancespectral'\n        Returns:\n            tensor: score\n        '''", "\n", "super", "(", "Discriminator_PatchGAN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "norm_layer", "=", "self", ".", "get_norm_layer", "(", "norm_type", "=", "norm_type", ")", "\n", "\n", "kw", "=", "4", "\n", "padw", "=", "int", "(", "np", ".", "ceil", "(", "(", "kw", "-", "1.0", ")", "/", "2", ")", ")", "\n", "sequence", "=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "input_nc", ",", "ndf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "2", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", ",", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.archs.discriminator_arch.UNetDiscriminatorSN.forward": [[32, 61], ["torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "torch.nn.functional.interpolate", "torch.nn.functional.leaky_relu", "torch.nn.functional.interpolate", "torch.nn.functional.leaky_relu", "torch.nn.functional.interpolate", "torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "torch.nn.functional.leaky_relu", "discriminator_arch.UNetDiscriminatorSN.conv9", "discriminator_arch.UNetDiscriminatorSN.conv0", "discriminator_arch.UNetDiscriminatorSN.conv1", "discriminator_arch.UNetDiscriminatorSN.conv2", "discriminator_arch.UNetDiscriminatorSN.conv3", "discriminator_arch.UNetDiscriminatorSN.conv4", "discriminator_arch.UNetDiscriminatorSN.conv5", "discriminator_arch.UNetDiscriminatorSN.conv6", "discriminator_arch.UNetDiscriminatorSN.conv7", "discriminator_arch.UNetDiscriminatorSN.conv8"], "methods", ["None"], ["nf", "=", "ndf", "\n", "for", "n", "in", "range", "(", "1", ",", "n_layers", ")", ":", "\n", "            ", "nf_prev", "=", "nf", "\n", "nf", "=", "min", "(", "nf", "*", "2", ",", "512", ")", "\n", "sequence", "+=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "nf_prev", ",", "nf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "2", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", ",", "\n", "norm_layer", "(", "nf", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "]", "\n", "\n", "", "nf_prev", "=", "nf", "\n", "nf", "=", "min", "(", "nf", "*", "2", ",", "512", ")", "\n", "sequence", "+=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "nf_prev", ",", "nf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "1", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", ",", "\n", "norm_layer", "(", "nf", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "]", "\n", "\n", "sequence", "+=", "[", "[", "self", ".", "use_spectral_norm", "(", "nn", ".", "Conv2d", "(", "nf", ",", "1", ",", "kernel_size", "=", "kw", ",", "stride", "=", "1", ",", "padding", "=", "padw", ")", ",", "norm_type", ")", "]", "]", "\n", "\n", "self", ".", "model", "=", "nn", ".", "Sequential", "(", ")", "\n", "for", "n", "in", "range", "(", "len", "(", "sequence", ")", ")", ":", "\n", "            ", "self", ".", "model", ".", "add_module", "(", "'child'", "+", "str", "(", "n", ")", ",", "nn", ".", "Sequential", "(", "*", "sequence", "[", "n", "]", ")", ")", "\n", "\n", "", "self", ".", "model", ".", "apply", "(", "self", ".", "weights_init", ")", "\n", "\n", "", "def", "use_spectral_norm", "(", "self", ",", "module", ",", "norm_type", "=", "'spectral'", ")", ":", "\n", "        ", "if", "'spectral'", "in", "norm_type", ":", "\n", "            ", "return", "spectral_norm", "(", "module", ")", "\n", "", "return", "module", "\n", "\n", "", "def", "get_norm_layer", "(", "self", ",", "norm_type", "=", "'instance'", ")", ":", "\n", "        ", "if", "'batch'", "in", "norm_type", ":", "\n", "            ", "norm_layer", "=", "functools", ".", "partial", "(", "nn", ".", "BatchNorm2d", ",", "affine", "=", "True", ")", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.__init__": [[22, 57], ["base_model.BaseModel.__init__", "basicsr.archs.build_network", "srgan_dynamic_model.SRGANDynamicModel.model_to_device", "basicsr.archs.build_network", "srgan_dynamic_model.SRGANDynamicModel.model_to_device", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "basicsr.archs.build_network", "srgan_dynamic_model.SRGANDynamicModel.model_to_device", "srgan_dynamic_model.SRGANDynamicModel.load_network", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.init_training_settings", "srgan_dynamic_model.SRGANDynamicModel.load_network_init_alldynamic", "srgan_dynamic_model.SRGANDynamicModel.load_network", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.load_network", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.opt[].get"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_to_device", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_to_device", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_to_device", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.init_training_settings", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network_init_alldynamic", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "SRGANDynamicModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "\n", "# define network", "\n", "self", ".", "net_g", "=", "build_network", "(", "opt", "[", "'network_g'", "]", ")", "\n", "self", ".", "net_g", "=", "self", ".", "model_to_device", "(", "self", ".", "net_g", ")", "\n", "\n", "self", ".", "net_p", "=", "build_network", "(", "opt", "[", "'network_p'", "]", ")", "\n", "self", ".", "net_p", "=", "self", ".", "model_to_device", "(", "self", ".", "net_p", ")", "\n", "\n", "if", "self", ".", "is_train", ":", "\n", "            ", "self", ".", "net_d", "=", "build_network", "(", "self", ".", "opt", "[", "'network_d'", "]", ")", "\n", "self", ".", "net_d", "=", "self", ".", "model_to_device", "(", "self", ".", "net_d", ")", "\n", "\n", "# load pretrained models", "\n", "", "load_path", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_g'", ",", "None", ")", "\n", "load_key", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'param_key_g'", ",", "None", ")", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "            ", "if", "'pretrained_models'", "in", "load_path", "and", "self", ".", "is_train", ":", "\n", "                ", "self", ".", "load_network_init_alldynamic", "(", "self", ".", "net_g", ",", "load_path", ",", "self", ".", "opt", "[", "'num_networks'", "]", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "load_key", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "load_network", "(", "self", ".", "net_g", ",", "load_path", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "load_key", ")", "\n", "\n", "", "", "load_path_p", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_p'", ",", "None", ")", "\n", "if", "load_path_p", "is", "not", "None", ":", "\n", "            ", "self", ".", "load_network", "(", "self", ".", "net_p", ",", "load_path_p", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ")", "\n", "\n", "", "if", "self", ".", "is_train", ":", "\n", "            ", "load_path_d", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_d'", ",", "None", ")", "\n", "load_key", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'param_key_g'", ",", "None", ")", "\n", "if", "load_path_d", "is", "not", "None", ":", "\n", "                ", "self", ".", "load_network", "(", "self", ".", "net_d", ",", "load_path_d", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_d'", ",", "True", ")", ",", "load_key", ")", "\n", "\n", "", "", "if", "self", ".", "is_train", ":", "\n", "            ", "self", ".", "init_training_settings", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.init_training_settings": [[58, 110], ["srgan_dynamic_model.SRGANDynamicModel.net_g.train", "srgan_dynamic_model.SRGANDynamicModel.net_p.train", "srgan_dynamic_model.SRGANDynamicModel.net_d.train", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "srgan_dynamic_model.SRGANDynamicModel.setup_optimizers", "srgan_dynamic_model.SRGANDynamicModel.setup_schedulers", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.archs.build_network().to", "srgan_dynamic_model.SRGANDynamicModel.net_g_ema.parameters", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.net_g_ema.eval", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "ValueError", "srgan_dynamic_model.SRGANDynamicModel.model_ema", "basicsr.archs.build_network", "srgan_dynamic_model.SRGANDynamicModel.load_network_init_alldynamic", "srgan_dynamic_model.SRGANDynamicModel.load_network", "basicsr.losses.build_loss", "basicsr.losses.build_loss", "basicsr.losses.build_loss", "basicsr.losses.build_loss", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.opt[].get"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.setup_optimizers", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.setup_schedulers", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network_init_alldynamic", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "", "def", "init_training_settings", "(", "self", ")", ":", "\n", "        ", "self", ".", "net_g", ".", "train", "(", ")", "\n", "self", ".", "net_p", ".", "train", "(", ")", "\n", "self", ".", "net_d", ".", "train", "(", ")", "\n", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "\n", "self", ".", "ema_decay", "=", "train_opt", ".", "get", "(", "'ema_decay'", ",", "0", ")", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "info", "(", "f'Use Exponential Moving Average with decay: {self.ema_decay}'", ")", "\n", "self", ".", "net_g_ema", "=", "build_network", "(", "self", ".", "opt", "[", "'network_g'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "for", "p", "in", "self", ".", "net_g_ema", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "# load pretrained model", "\n", "", "load_path", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_g'", ",", "None", ")", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "                ", "if", "'pretrained_models'", "in", "load_path", ":", "\n", "                    ", "self", ".", "load_network_init_alldynamic", "(", "self", ".", "net_g_ema", ",", "load_path", ",", "self", ".", "opt", "[", "'num_networks'", "]", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "'params_ema'", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "load_network", "(", "self", ".", "net_g_ema", ",", "load_path", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "'params_ema'", ")", "\n", "", "", "else", ":", "\n", "                ", "self", ".", "model_ema", "(", "0", ")", "\n", "", "self", ".", "net_g_ema", ".", "eval", "(", ")", "\n", "\n", "# define losses", "\n", "", "if", "train_opt", ".", "get", "(", "'pixel_opt'", ")", ":", "\n", "            ", "self", ".", "cri_pix", "=", "build_loss", "(", "train_opt", "[", "'pixel_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_pix", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'regress_opt'", ")", ":", "\n", "            ", "self", ".", "cri_regress", "=", "build_loss", "(", "train_opt", "[", "'regress_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_regress", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'perceptual_opt'", ")", ":", "\n", "            ", "self", ".", "cri_perceptual", "=", "build_loss", "(", "train_opt", "[", "'perceptual_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_perceptual", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'gan_opt'", ")", ":", "\n", "            ", "self", ".", "cri_gan", "=", "build_loss", "(", "train_opt", "[", "'gan_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "net_d_iters", "=", "train_opt", ".", "get", "(", "'net_d_iters'", ",", "1", ")", "\n", "self", ".", "net_d_init_iters", "=", "train_opt", ".", "get", "(", "'net_d_init_iters'", ",", "0", ")", "\n", "\n", "if", "self", ".", "cri_pix", "is", "None", "and", "self", ".", "cri_perceptual", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Both pixel and perceptual losses are None.'", ")", "\n", "\n", "# set up optimizers and schedulers", "\n", "", "self", ".", "setup_optimizers", "(", ")", "\n", "self", ".", "setup_schedulers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.setup_optimizers": [[111, 133], ["train_opt[].pop", "srgan_dynamic_model.SRGANDynamicModel.net_g.named_parameters", "srgan_dynamic_model.SRGANDynamicModel.net_p.named_parameters", "srgan_dynamic_model.SRGANDynamicModel.get_optimizer", "srgan_dynamic_model.SRGANDynamicModel.optimizers.append", "train_opt[].pop", "srgan_dynamic_model.SRGANDynamicModel.get_optimizer", "srgan_dynamic_model.SRGANDynamicModel.optimizers.append", "srgan_dynamic_model.SRGANDynamicModel.net_d.parameters", "optim_params.append", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warning", "optim_params.append", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warning"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_optimizer", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_optimizer", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "def", "setup_optimizers", "(", "self", ")", ":", "\n", "        ", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "optim_type", "=", "train_opt", "[", "'optim_g'", "]", ".", "pop", "(", "'type'", ")", "\n", "optim_params", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "self", ".", "net_g", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "v", ".", "requires_grad", ":", "\n", "                ", "optim_params", ".", "append", "(", "v", ")", "\n", "", "else", ":", "\n", "                ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warning", "(", "f'Params {k} will not be optimized.'", ")", "\n", "", "", "for", "k", ",", "v", "in", "self", ".", "net_p", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "v", ".", "requires_grad", ":", "\n", "                ", "optim_params", ".", "append", "(", "v", ")", "\n", "", "else", ":", "\n", "                ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warning", "(", "f'Params {k} will not be optimized.'", ")", "\n", "", "", "self", ".", "optimizer_g", "=", "self", ".", "get_optimizer", "(", "optim_type", ",", "optim_params", ",", "**", "train_opt", "[", "'optim_g'", "]", ")", "\n", "self", ".", "optimizers", ".", "append", "(", "self", ".", "optimizer_g", ")", "\n", "\n", "optim_type", "=", "train_opt", "[", "'optim_d'", "]", ".", "pop", "(", "'type'", ")", "\n", "self", ".", "optimizer_d", "=", "self", ".", "get_optimizer", "(", "optim_type", ",", "self", ".", "net_d", ".", "parameters", "(", ")", ",", "**", "train_opt", "[", "'optim_d'", "]", ")", "\n", "self", ".", "optimizers", ".", "append", "(", "self", ".", "optimizer_d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.feed_data": [[134, 139], ["data[].to", "data[].to"], "methods", ["None"], ["", "def", "feed_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "lq", "=", "data", "[", "'lq'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "lq_path", "=", "data", "[", "'lq_path'", "]", "\n", "if", "'gt'", "in", "data", ":", "\n", "            ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.optimize_parameters": [[140, 203], ["srgan_dynamic_model.SRGANDynamicModel.net_d.parameters", "srgan_dynamic_model.SRGANDynamicModel.optimizer_g.zero_grad", "srgan_dynamic_model.SRGANDynamicModel.net_p", "srgan_dynamic_model.SRGANDynamicModel.net_g", "collections.OrderedDict", "srgan_dynamic_model.SRGANDynamicModel.net_d.parameters", "srgan_dynamic_model.SRGANDynamicModel.optimizer_d.zero_grad", "srgan_dynamic_model.SRGANDynamicModel.net_d", "srgan_dynamic_model.SRGANDynamicModel.cri_gan", "torch.mean", "srgan_dynamic_model.SRGANDynamicModel.backward", "srgan_dynamic_model.SRGANDynamicModel.net_d", "srgan_dynamic_model.SRGANDynamicModel.cri_gan", "torch.mean", "srgan_dynamic_model.SRGANDynamicModel.backward", "srgan_dynamic_model.SRGANDynamicModel.optimizer_d.step", "srgan_dynamic_model.SRGANDynamicModel.reduce_loss_dict", "srgan_dynamic_model.SRGANDynamicModel.lq.contiguous", "srgan_dynamic_model.SRGANDynamicModel.net_d", "srgan_dynamic_model.SRGANDynamicModel.cri_gan", "l_g_total.backward", "srgan_dynamic_model.SRGANDynamicModel.optimizer_g.step", "srgan_dynamic_model.SRGANDynamicModel.detach", "srgan_dynamic_model.SRGANDynamicModel.output.detach", "srgan_dynamic_model.SRGANDynamicModel.detach", "srgan_dynamic_model.SRGANDynamicModel.model_ema", "srgan_dynamic_model.SRGANDynamicModel.cri_pix", "srgan_dynamic_model.SRGANDynamicModel.cri_regress", "srgan_dynamic_model.SRGANDynamicModel.cri_perceptual"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.reduce_loss_dict", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema"], ["", "", "def", "optimize_parameters", "(", "self", ",", "current_iter", ")", ":", "\n", "\n", "# optimize net_g", "\n", "        ", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "optimizer_g", ".", "zero_grad", "(", ")", "\n", "predicted_params", ",", "weights", "=", "self", ".", "net_p", "(", "self", ".", "lq", ")", "\n", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ".", "contiguous", "(", ")", ",", "weights", ")", "\n", "\n", "l_g_total", "=", "0", "\n", "loss_dict", "=", "OrderedDict", "(", ")", "\n", "if", "(", "current_iter", "%", "self", ".", "net_d_iters", "==", "0", "and", "current_iter", ">", "self", ".", "net_d_init_iters", ")", ":", "\n", "# pixel loss", "\n", "            ", "if", "self", ".", "cri_pix", ":", "\n", "                ", "l_pix", "=", "self", ".", "cri_pix", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "l_g_total", "+=", "l_pix", "\n", "loss_dict", "[", "'l_pix'", "]", "=", "l_pix", "\n", "", "if", "self", ".", "cri_regress", ":", "\n", "                ", "l_regression", "=", "self", ".", "cri_regress", "(", "predicted_params", ",", "self", ".", "degradation_params", ")", "\n", "l_g_total", "+=", "l_regression", "\n", "loss_dict", "[", "'l_regression'", "]", "=", "l_regression", "\n", "# perceptual loss", "\n", "", "if", "self", ".", "cri_perceptual", ":", "\n", "                ", "l_percep", ",", "l_style", "=", "self", ".", "cri_perceptual", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "if", "l_percep", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_percep", "\n", "loss_dict", "[", "'l_percep'", "]", "=", "l_percep", "\n", "", "if", "l_style", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_style", "\n", "loss_dict", "[", "'l_style'", "]", "=", "l_style", "\n", "# gan loss", "\n", "", "", "fake_g_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ")", "\n", "l_g_gan", "=", "self", ".", "cri_gan", "(", "fake_g_pred", ",", "True", ",", "is_disc", "=", "False", ")", "\n", "l_g_total", "+=", "l_g_gan", "\n", "loss_dict", "[", "'l_g_gan'", "]", "=", "l_g_gan", "\n", "\n", "l_g_total", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_g", ".", "step", "(", ")", "\n", "\n", "# optimize net_d", "\n", "", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "self", ".", "optimizer_d", ".", "zero_grad", "(", ")", "\n", "# real", "\n", "real_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "gt", ")", "\n", "l_d_real", "=", "self", ".", "cri_gan", "(", "real_d_pred", ",", "True", ",", "is_disc", "=", "True", ")", "\n", "loss_dict", "[", "'l_d_real'", "]", "=", "l_d_real", "\n", "loss_dict", "[", "'out_d_real'", "]", "=", "torch", ".", "mean", "(", "real_d_pred", ".", "detach", "(", ")", ")", "\n", "l_d_real", ".", "backward", "(", ")", "\n", "# fake", "\n", "fake_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ".", "detach", "(", ")", ")", "\n", "l_d_fake", "=", "self", ".", "cri_gan", "(", "fake_d_pred", ",", "False", ",", "is_disc", "=", "True", ")", "\n", "loss_dict", "[", "'l_d_fake'", "]", "=", "l_d_fake", "\n", "loss_dict", "[", "'out_d_fake'", "]", "=", "torch", ".", "mean", "(", "fake_d_pred", ".", "detach", "(", ")", ")", "\n", "l_d_fake", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_d", ".", "step", "(", ")", "\n", "\n", "self", ".", "log_dict", "=", "self", ".", "reduce_loss_dict", "(", "loss_dict", ")", "\n", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "self", ".", "model_ema", "(", "decay", "=", "self", ".", "ema_decay", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.test": [[204, 219], ["srgan_dynamic_model.SRGANDynamicModel.net_p.eval", "srgan_dynamic_model.SRGANDynamicModel.net_p.train", "hasattr", "torch.no_grad", "srgan_dynamic_model.SRGANDynamicModel.net_p", "srgan_dynamic_model.SRGANDynamicModel.net_g_ema.eval", "srgan_dynamic_model.SRGANDynamicModel.net_g.eval", "srgan_dynamic_model.SRGANDynamicModel.net_g.train", "torch.no_grad", "srgan_dynamic_model.SRGANDynamicModel.net_g_ema", "torch.no_grad", "srgan_dynamic_model.SRGANDynamicModel.net_g", "srgan_dynamic_model.SRGANDynamicModel.lq.contiguous"], "methods", ["None"], ["", "", "def", "test", "(", "self", ")", ":", "\n", "        ", "self", ".", "net_p", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "predicted_params", ",", "weights", "=", "self", ".", "net_p", "(", "self", ".", "lq", ")", "\n", "", "self", ".", "net_p", ".", "train", "(", ")", "\n", "\n", "if", "hasattr", "(", "self", ",", "'net_g_ema'", ")", ":", "\n", "            ", "self", ".", "net_g_ema", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "self", ".", "output", "=", "self", ".", "net_g_ema", "(", "self", ".", "lq", ",", "weights", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "net_g", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ".", "contiguous", "(", ")", ",", "weights", ")", "\n", "", "self", ".", "net_g", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.dist_validation": [[220, 223], ["srgan_dynamic_model.SRGANDynamicModel.nondist_validation"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation"], ["", "", "def", "dist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "        ", "if", "self", ".", "opt", "[", "'rank'", "]", "==", "0", ":", "\n", "            ", "self", ".", "nondist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.nondist_validation": [[224, 275], ["tqdm.tqdm.tqdm", "enumerate", "tqdm.tqdm.tqdm.close", "srgan_dynamic_model.SRGANDynamicModel.opt[].get", "srgan_dynamic_model.SRGANDynamicModel.feed_data", "srgan_dynamic_model.SRGANDynamicModel.test", "srgan_dynamic_model.SRGANDynamicModel.get_current_visuals", "basicsr.utils.tensor2img", "torch.cuda.empty_cache", "tqdm.tqdm.tqdm.update", "tqdm.tqdm.tqdm.set_description", "srgan_dynamic_model.SRGANDynamicModel.metric_results.keys", "srgan_dynamic_model.SRGANDynamicModel._log_validation_metric_values", "len", "os.path.splitext", "basicsr.utils.tensor2img", "basicsr.utils.imwrite", "[].items", "[].keys", "os.path.basename", "os.path.join", "dict", "basicsr.metrics.calculate_metric", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.feed_data", "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.test", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_visuals", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel._log_validation_metric_values", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.__init__.calculate_metric"], ["", "", "def", "nondist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "        ", "dataset_name", "=", "dataloader", ".", "dataset", ".", "opt", "[", "'name'", "]", "\n", "with_metrics", "=", "self", ".", "opt", "[", "'val'", "]", ".", "get", "(", "'metrics'", ")", "is", "not", "None", "\n", "if", "with_metrics", ":", "\n", "            ", "self", ".", "metric_results", "=", "{", "metric", ":", "0", "for", "metric", "in", "self", ".", "opt", "[", "'val'", "]", "[", "'metrics'", "]", ".", "keys", "(", ")", "}", "\n", "", "pbar", "=", "tqdm", "(", "total", "=", "len", "(", "dataloader", ")", ",", "unit", "=", "'image'", ")", "\n", "\n", "for", "idx", ",", "val_data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "img_name", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "val_data", "[", "'lq_path'", "]", "[", "0", "]", ")", ")", "[", "0", "]", "\n", "self", ".", "feed_data", "(", "val_data", ")", "\n", "self", ".", "test", "(", ")", "\n", "\n", "visuals", "=", "self", ".", "get_current_visuals", "(", ")", "\n", "sr_img", "=", "tensor2img", "(", "[", "visuals", "[", "'result'", "]", "]", ")", "\n", "if", "'gt'", "in", "visuals", ":", "\n", "                ", "gt_img", "=", "tensor2img", "(", "[", "visuals", "[", "'gt'", "]", "]", ")", "\n", "del", "self", ".", "gt", "\n", "\n", "# tentative for out of GPU memory", "\n", "", "del", "self", ".", "lq", "\n", "del", "self", ".", "output", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "if", "save_img", ":", "\n", "                ", "if", "self", ".", "opt", "[", "'is_train'", "]", ":", "\n", "                    ", "save_img_path", "=", "osp", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'visualization'", "]", ",", "img_name", ",", "f'{img_name}_{current_iter}.png'", ")", "\n", "", "else", ":", "\n", "                    ", "if", "self", ".", "opt", "[", "'val'", "]", "[", "'suffix'", "]", ":", "\n", "                        ", "save_img_path", "=", "osp", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'visualization'", "]", ",", "dataset_name", ",", "\n", "f'{img_name}_{self.opt[\"val\"][\"suffix\"]}.png'", ")", "\n", "", "else", ":", "\n", "                        ", "save_img_path", "=", "osp", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'visualization'", "]", ",", "dataset_name", ",", "\n", "f'{img_name}_{self.opt[\"name\"]}.png'", ")", "\n", "\n", "", "", "imwrite", "(", "sr_img", ",", "save_img_path", ")", "\n", "\n", "\n", "", "if", "with_metrics", ":", "\n", "# calculate metrics", "\n", "                ", "for", "name", ",", "opt_", "in", "self", ".", "opt", "[", "'val'", "]", "[", "'metrics'", "]", ".", "items", "(", ")", ":", "\n", "                    ", "metric_data", "=", "dict", "(", "img1", "=", "sr_img", ",", "img2", "=", "gt_img", ")", "\n", "self", ".", "metric_results", "[", "name", "]", "+=", "calculate_metric", "(", "metric_data", ",", "opt_", ")", "\n", "", "", "pbar", ".", "update", "(", "1", ")", "\n", "pbar", ".", "set_description", "(", "f'Test {img_name}'", ")", "\n", "", "pbar", ".", "close", "(", ")", "\n", "\n", "if", "with_metrics", ":", "\n", "            ", "for", "metric", "in", "self", ".", "metric_results", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "metric_results", "[", "metric", "]", "/=", "(", "idx", "+", "1", ")", "\n", "\n", "", "self", ".", "_log_validation_metric_values", "(", "current_iter", ",", "dataset_name", ",", "tb_logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel._log_validation_metric_values": [[276, 285], ["srgan_dynamic_model.SRGANDynamicModel.metric_results.items", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "srgan_dynamic_model.SRGANDynamicModel.metric_results.items", "tb_logger.add_scalar"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "", "def", "_log_validation_metric_values", "(", "self", ",", "current_iter", ",", "dataset_name", ",", "tb_logger", ")", ":", "\n", "        ", "log_str", "=", "f'Validation {dataset_name}\\n'", "\n", "for", "metric", ",", "value", "in", "self", ".", "metric_results", ".", "items", "(", ")", ":", "\n", "            ", "log_str", "+=", "f'\\t # {metric}: {value:.4f}\\n'", "\n", "", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "info", "(", "log_str", ")", "\n", "if", "tb_logger", ":", "\n", "            ", "for", "metric", ",", "value", "in", "self", ".", "metric_results", ".", "items", "(", ")", ":", "\n", "                ", "tb_logger", ".", "add_scalar", "(", "f'metrics/{metric}'", ",", "value", ",", "current_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.get_current_visuals": [[286, 293], ["collections.OrderedDict", "srgan_dynamic_model.SRGANDynamicModel.lq.detach().cpu", "srgan_dynamic_model.SRGANDynamicModel.output.detach().cpu", "hasattr", "srgan_dynamic_model.SRGANDynamicModel.gt.detach().cpu", "srgan_dynamic_model.SRGANDynamicModel.lq.detach", "srgan_dynamic_model.SRGANDynamicModel.output.detach", "srgan_dynamic_model.SRGANDynamicModel.gt.detach"], "methods", ["None"], ["", "", "", "def", "get_current_visuals", "(", "self", ")", ":", "\n", "        ", "out_dict", "=", "OrderedDict", "(", ")", "\n", "out_dict", "[", "'lq'", "]", "=", "self", ".", "lq", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "out_dict", "[", "'result'", "]", "=", "self", ".", "output", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "if", "hasattr", "(", "self", ",", "'gt'", ")", ":", "\n", "            ", "out_dict", "[", "'gt'", "]", "=", "self", ".", "gt", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "", "return", "out_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_dynamic_model.SRGANDynamicModel.save": [[294, 302], ["hasattr", "srgan_dynamic_model.SRGANDynamicModel.save_network", "srgan_dynamic_model.SRGANDynamicModel.save_network", "srgan_dynamic_model.SRGANDynamicModel.save_training_state", "srgan_dynamic_model.SRGANDynamicModel.save_network", "srgan_dynamic_model.SRGANDynamicModel.save_network"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_training_state", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network"], ["", "def", "save", "(", "self", ",", "epoch", ",", "current_iter", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "'net_g_ema'", ")", ":", "\n", "            ", "self", ".", "save_network", "(", "[", "self", ".", "net_g", ",", "self", ".", "net_g_ema", "]", ",", "'net_g'", ",", "current_iter", ",", "param_key", "=", "[", "'params'", ",", "'params_ema'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "save_network", "(", "self", ".", "net_g", ",", "'net_g'", ",", "current_iter", ")", "\n", "", "self", ".", "save_network", "(", "self", ".", "net_p", ",", "'net_p'", ",", "current_iter", ")", "\n", "self", ".", "save_network", "(", "self", ".", "net_d", ",", "'net_d'", ",", "current_iter", ")", "\n", "self", ".", "save_training_state", "(", "epoch", ",", "current_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.__init__": [[20, 36], ["base_model.BaseModel.__init__", "basicsr.archs.build_network", "sr_model.SRModel.model_to_device", "sr_model.SRModel.opt[].get", "sr_model.SRModel.opt[].get", "sr_model.SRModel.load_network", "sr_model.SRModel.init_training_settings", "sr_model.SRModel.opt[].get"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_to_device", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.init_training_settings", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "SRModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "\n", "# define network", "\n", "self", ".", "net_g", "=", "build_network", "(", "opt", "[", "'network_g'", "]", ")", "\n", "self", ".", "net_g", "=", "self", ".", "model_to_device", "(", "self", ".", "net_g", ")", "\n", "# self.print_network(self.net_g)", "\n", "\n", "# load pretrained models", "\n", "load_path", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_g'", ",", "None", ")", "\n", "load_key", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'param_key_g'", ",", "None", ")", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "            ", "self", ".", "load_network", "(", "self", ".", "net_g", ",", "load_path", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "load_key", ")", "\n", "\n", "", "if", "self", ".", "is_train", ":", "\n", "            ", "self", ".", "init_training_settings", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.init_training_settings": [[37, 73], ["sr_model.SRModel.net_g.train", "train_opt.get", "train_opt.get", "train_opt.get", "sr_model.SRModel.setup_optimizers", "sr_model.SRModel.setup_schedulers", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.archs.build_network().to", "sr_model.SRModel.net_g_ema.parameters", "sr_model.SRModel.opt[].get", "sr_model.SRModel.net_g_ema.eval", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "ValueError", "sr_model.SRModel.load_network", "sr_model.SRModel.model_ema", "basicsr.archs.build_network", "sr_model.SRModel.opt[].get", "basicsr.losses.build_loss", "basicsr.losses.build_loss"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.setup_optimizers", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.setup_schedulers", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss"], ["", "", "def", "init_training_settings", "(", "self", ")", ":", "\n", "        ", "self", ".", "net_g", ".", "train", "(", ")", "\n", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "\n", "self", ".", "ema_decay", "=", "train_opt", ".", "get", "(", "'ema_decay'", ",", "0", ")", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "info", "(", "f'Use Exponential Moving Average with decay: {self.ema_decay}'", ")", "\n", "self", ".", "net_g_ema", "=", "build_network", "(", "self", ".", "opt", "[", "'network_g'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "for", "p", "in", "self", ".", "net_g_ema", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "# load pretrained model", "\n", "", "load_path", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_g'", ",", "None", ")", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "                ", "self", ".", "load_network", "(", "self", ".", "net_g_ema", ",", "load_path", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "'params_ema'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "model_ema", "(", "0", ")", "# copy net_g weight", "\n", "", "self", ".", "net_g_ema", ".", "eval", "(", ")", "\n", "\n", "# define losses", "\n", "", "if", "train_opt", ".", "get", "(", "'pixel_opt'", ")", ":", "\n", "            ", "self", ".", "cri_pix", "=", "build_loss", "(", "train_opt", "[", "'pixel_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_pix", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'perceptual_opt'", ")", ":", "\n", "            ", "self", ".", "cri_perceptual", "=", "build_loss", "(", "train_opt", "[", "'perceptual_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_perceptual", "=", "None", "\n", "\n", "", "if", "self", ".", "cri_pix", "is", "None", "and", "self", ".", "cri_perceptual", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Both pixel and perceptual losses are None.'", ")", "\n", "\n", "# set up optimizers and schedulers", "\n", "", "self", ".", "setup_optimizers", "(", ")", "\n", "self", ".", "setup_schedulers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.setup_optimizers": [[74, 87], ["sr_model.SRModel.net_g.named_parameters", "train_opt[].pop", "sr_model.SRModel.get_optimizer", "sr_model.SRModel.optimizers.append", "optim_params.append", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warning"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_optimizer", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "def", "setup_optimizers", "(", "self", ")", ":", "\n", "        ", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "optim_params", "=", "[", "]", "\n", "for", "k", ",", "v", "in", "self", ".", "net_g", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "v", ".", "requires_grad", ":", "\n", "                ", "optim_params", ".", "append", "(", "v", ")", "\n", "", "else", ":", "\n", "                ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warning", "(", "f'Params {k} will not be optimized.'", ")", "\n", "\n", "", "", "optim_type", "=", "train_opt", "[", "'optim_g'", "]", ".", "pop", "(", "'type'", ")", "\n", "self", ".", "optimizer_g", "=", "self", ".", "get_optimizer", "(", "optim_type", ",", "optim_params", ",", "**", "train_opt", "[", "'optim_g'", "]", ")", "\n", "self", ".", "optimizers", ".", "append", "(", "self", ".", "optimizer_g", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.feed_data": [[88, 92], ["data[].to", "data[].to"], "methods", ["None"], ["", "def", "feed_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "lq", "=", "data", "[", "'lq'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'gt'", "in", "data", ":", "\n", "            ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.optimize_parameters": [[93, 122], ["sr_model.SRModel.optimizer_g.zero_grad", "sr_model.SRModel.net_g", "sr_model.SRModel.cycle_degredation", "collections.OrderedDict", "l_total.backward", "sr_model.SRModel.optimizer_g.step", "sr_model.SRModel.reduce_loss_dict", "sr_model.SRModel.cri_pix", "sr_model.SRModel.cri_perceptual", "sr_model.SRModel.model_ema"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.reduce_loss_dict", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema"], ["", "", "def", "optimize_parameters", "(", "self", ",", "current_iter", ")", ":", "\n", "        ", "self", ".", "optimizer_g", ".", "zero_grad", "(", ")", "\n", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ")", "\n", "self", ".", "cycle_degredation", "(", ")", "\n", "\n", "l_total", "=", "0", "\n", "loss_dict", "=", "OrderedDict", "(", ")", "\n", "# pixel loss", "\n", "if", "self", ".", "cri_pix", ":", "\n", "            ", "l_pix", "=", "self", ".", "cri_pix", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "l_total", "+=", "l_pix", "\n", "loss_dict", "[", "'l_pix'", "]", "=", "l_pix", "\n", "# perceptual loss", "\n", "", "if", "self", ".", "cri_perceptual", ":", "\n", "            ", "l_percep", ",", "l_style", "=", "self", ".", "cri_perceptual", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "if", "l_percep", "is", "not", "None", ":", "\n", "                ", "l_total", "+=", "l_percep", "\n", "loss_dict", "[", "'l_percep'", "]", "=", "l_percep", "\n", "", "if", "l_style", "is", "not", "None", ":", "\n", "                ", "l_total", "+=", "l_style", "\n", "loss_dict", "[", "'l_style'", "]", "=", "l_style", "\n", "\n", "", "", "l_total", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_g", ".", "step", "(", ")", "\n", "\n", "self", ".", "log_dict", "=", "self", ".", "reduce_loss_dict", "(", "loss_dict", ")", "\n", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "self", ".", "model_ema", "(", "decay", "=", "self", ".", "ema_decay", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.test": [[123, 133], ["hasattr", "sr_model.SRModel.net_g_ema.eval", "sr_model.SRModel.net_g.eval", "sr_model.SRModel.net_g.train", "torch.no_grad", "sr_model.SRModel.net_g_ema", "torch.no_grad", "sr_model.SRModel.net_g"], "methods", ["None"], ["", "", "def", "test", "(", "self", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "'net_g_ema'", ")", ":", "\n", "            ", "self", ".", "net_g_ema", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "self", ".", "output", "=", "self", ".", "net_g_ema", "(", "self", ".", "lq", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "net_g", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ")", "\n", "", "self", ".", "net_g", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.dist_validation": [[134, 137], ["sr_model.SRModel.nondist_validation"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation"], ["", "", "def", "dist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "        ", "if", "self", ".", "opt", "[", "'rank'", "]", "==", "0", ":", "\n", "            ", "self", ".", "nondist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.nondist_validation": [[138, 188], ["tqdm.tqdm.tqdm", "enumerate", "tqdm.tqdm.tqdm.close", "sr_model.SRModel.opt[].get", "sr_model.SRModel.feed_data", "sr_model.SRModel.test", "sr_model.SRModel.get_current_visuals", "basicsr.utils.tensor2img", "torch.cuda.empty_cache", "tqdm.tqdm.tqdm.update", "tqdm.tqdm.tqdm.set_description", "sr_model.SRModel.metric_results.keys", "sr_model.SRModel._log_validation_metric_values", "len", "os.path.splitext", "basicsr.utils.tensor2img", "basicsr.utils.imwrite", "[].items", "[].keys", "os.path.basename", "os.path.join", "dict", "basicsr.metrics.calculate_metric", "str", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.feed_data", "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.test", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_visuals", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel._log_validation_metric_values", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.__init__.calculate_metric"], ["", "", "def", "nondist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "        ", "dataset_name", "=", "dataloader", ".", "dataset", ".", "opt", "[", "'name'", "]", "\n", "with_metrics", "=", "self", ".", "opt", "[", "'val'", "]", ".", "get", "(", "'metrics'", ")", "is", "not", "None", "\n", "if", "with_metrics", ":", "\n", "            ", "self", ".", "metric_results", "=", "{", "metric", ":", "0", "for", "metric", "in", "self", ".", "opt", "[", "'val'", "]", "[", "'metrics'", "]", ".", "keys", "(", ")", "}", "\n", "", "pbar", "=", "tqdm", "(", "total", "=", "len", "(", "dataloader", ")", ",", "unit", "=", "'image'", ")", "\n", "\n", "for", "idx", ",", "val_data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "img_name", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "val_data", "[", "'lq_path'", "]", "[", "0", "]", ")", ")", "[", "0", "]", "\n", "self", ".", "feed_data", "(", "val_data", ")", "\n", "self", ".", "test", "(", ")", "\n", "\n", "visuals", "=", "self", ".", "get_current_visuals", "(", ")", "\n", "sr_img", "=", "tensor2img", "(", "[", "visuals", "[", "'result'", "]", "]", ")", "\n", "if", "'gt'", "in", "visuals", ":", "\n", "                ", "gt_img", "=", "tensor2img", "(", "[", "visuals", "[", "'gt'", "]", "]", ")", "\n", "del", "self", ".", "gt", "\n", "\n", "# tentative for out of GPU memory", "\n", "", "del", "self", ".", "lq", "\n", "del", "self", ".", "output", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "if", "save_img", ":", "\n", "                ", "if", "self", ".", "opt", "[", "'is_train'", "]", ":", "\n", "                    ", "save_img_path", "=", "osp", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'visualization'", "]", ",", "str", "(", "current_iter", ")", ",", "\n", "f'{img_name}_{current_iter}.png'", ")", "\n", "", "else", ":", "\n", "                    ", "if", "self", ".", "opt", "[", "'val'", "]", "[", "'suffix'", "]", ":", "\n", "                        ", "save_img_path", "=", "osp", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'visualization'", "]", ",", "dataset_name", ",", "\n", "f'{img_name}_{self.opt[\"val\"][\"suffix\"]}.png'", ")", "\n", "", "else", ":", "\n", "                        ", "save_img_path", "=", "osp", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'visualization'", "]", ",", "dataset_name", ",", "\n", "f'{img_name}_{self.opt[\"name\"]}.png'", ")", "\n", "", "", "imwrite", "(", "sr_img", ",", "save_img_path", ")", "\n", "\n", "", "if", "with_metrics", ":", "\n", "# calculate metrics", "\n", "                ", "for", "name", ",", "opt_", "in", "self", ".", "opt", "[", "'val'", "]", "[", "'metrics'", "]", ".", "items", "(", ")", ":", "\n", "                    ", "metric_data", "=", "dict", "(", "img1", "=", "sr_img", ",", "img2", "=", "gt_img", ")", "\n", "self", ".", "metric_results", "[", "name", "]", "+=", "calculate_metric", "(", "metric_data", ",", "opt_", ")", "\n", "", "", "pbar", ".", "update", "(", "1", ")", "\n", "pbar", ".", "set_description", "(", "f'Test {img_name}'", ")", "\n", "", "pbar", ".", "close", "(", ")", "\n", "\n", "if", "with_metrics", ":", "\n", "            ", "for", "metric", "in", "self", ".", "metric_results", ".", "keys", "(", ")", ":", "\n", "                ", "self", ".", "metric_results", "[", "metric", "]", "/=", "(", "idx", "+", "1", ")", "\n", "\n", "", "self", ".", "_log_validation_metric_values", "(", "current_iter", ",", "dataset_name", ",", "tb_logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel._log_validation_metric_values": [[189, 198], ["sr_model.SRModel.metric_results.items", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "sr_model.SRModel.metric_results.items", "tb_logger.add_scalar"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "", "def", "_log_validation_metric_values", "(", "self", ",", "current_iter", ",", "dataset_name", ",", "tb_logger", ")", ":", "\n", "        ", "log_str", "=", "f'Validation {dataset_name}\\n'", "\n", "for", "metric", ",", "value", "in", "self", ".", "metric_results", ".", "items", "(", ")", ":", "\n", "            ", "log_str", "+=", "f'\\t # {metric}: {value:.4f}\\n'", "\n", "", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "info", "(", "log_str", ")", "\n", "if", "tb_logger", ":", "\n", "            ", "for", "metric", ",", "value", "in", "self", ".", "metric_results", ".", "items", "(", ")", ":", "\n", "                ", "tb_logger", ".", "add_scalar", "(", "f'metrics/{metric}'", ",", "value", ",", "current_iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.get_current_visuals": [[199, 206], ["collections.OrderedDict", "sr_model.SRModel.lq.detach().cpu", "sr_model.SRModel.output.detach().cpu", "hasattr", "sr_model.SRModel.gt.detach().cpu", "sr_model.SRModel.lq.detach", "sr_model.SRModel.output.detach", "sr_model.SRModel.gt.detach"], "methods", ["None"], ["", "", "", "def", "get_current_visuals", "(", "self", ")", ":", "\n", "        ", "out_dict", "=", "OrderedDict", "(", ")", "\n", "out_dict", "[", "'lq'", "]", "=", "self", ".", "lq", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "out_dict", "[", "'result'", "]", "=", "self", ".", "output", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "if", "hasattr", "(", "self", ",", "'gt'", ")", ":", "\n", "            ", "out_dict", "[", "'gt'", "]", "=", "self", ".", "gt", ".", "detach", "(", ")", ".", "cpu", "(", ")", "\n", "", "return", "out_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.save": [[207, 213], ["hasattr", "sr_model.SRModel.save_training_state", "sr_model.SRModel.save_network", "sr_model.SRModel.save_network"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_training_state", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network"], ["", "def", "save", "(", "self", ",", "epoch", ",", "current_iter", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "'net_g_ema'", ")", ":", "\n", "            ", "self", ".", "save_network", "(", "[", "self", ".", "net_g", ",", "self", ".", "net_g_ema", "]", ",", "'net_g'", ",", "current_iter", ",", "param_key", "=", "[", "'params'", ",", "'params_ema'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "save_network", "(", "self", ".", "net_g", ",", "'net_g'", ",", "current_iter", ")", "\n", "", "self", ".", "save_training_state", "(", "epoch", ",", "current_iter", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.models.lr_scheduler.MultiStepRestartLR.__init__": [[19, 26], ["collections.Counter", "torch.optim.lr_scheduler._LRScheduler.__init__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "milestones", ",", "gamma", "=", "0.1", ",", "restarts", "=", "(", "0", ",", ")", ",", "restart_weights", "=", "(", "1", ",", ")", ",", "last_epoch", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "milestones", "=", "Counter", "(", "milestones", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "restarts", "=", "restarts", "\n", "self", ".", "restart_weights", "=", "restart_weights", "\n", "assert", "len", "(", "self", ".", "restarts", ")", "==", "len", "(", "self", ".", "restart_weights", ")", ",", "'restarts and their weights do not match.'", "\n", "super", "(", "MultiStepRestartLR", ",", "self", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.lr_scheduler.MultiStepRestartLR.get_lr": [[27, 34], ["lr_scheduler.MultiStepRestartLR.restarts.index"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "last_epoch", "in", "self", ".", "restarts", ":", "\n", "            ", "weight", "=", "self", ".", "restart_weights", "[", "self", ".", "restarts", ".", "index", "(", "self", ".", "last_epoch", ")", "]", "\n", "return", "[", "group", "[", "'initial_lr'", "]", "*", "weight", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "", "if", "self", ".", "last_epoch", "not", "in", "self", ".", "milestones", ":", "\n", "            ", "return", "[", "group", "[", "'lr'", "]", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "", "return", "[", "group", "[", "'lr'", "]", "*", "self", ".", "gamma", "**", "self", ".", "milestones", "[", "self", ".", "last_epoch", "]", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.lr_scheduler.CosineAnnealingRestartLR.__init__": [[77, 85], ["torch.optim.lr_scheduler._LRScheduler.__init__", "len", "len", "sum", "range", "len"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "optimizer", ",", "periods", ",", "restart_weights", "=", "(", "1", ",", ")", ",", "eta_min", "=", "0", ",", "last_epoch", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "periods", "=", "periods", "\n", "self", ".", "restart_weights", "=", "restart_weights", "\n", "self", ".", "eta_min", "=", "eta_min", "\n", "assert", "(", "len", "(", "self", ".", "periods", ")", "==", "len", "(", "\n", "self", ".", "restart_weights", ")", ")", ",", "'periods and restart_weights should have the same length.'", "\n", "self", ".", "cumulative_period", "=", "[", "sum", "(", "self", ".", "periods", "[", "0", ":", "i", "+", "1", "]", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "periods", ")", ")", "]", "\n", "super", "(", "CosineAnnealingRestartLR", ",", "self", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.lr_scheduler.CosineAnnealingRestartLR.get_lr": [[86, 96], ["lr_scheduler.get_position_from_periods", "math.cos"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.lr_scheduler.get_position_from_periods"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "        ", "idx", "=", "get_position_from_periods", "(", "self", ".", "last_epoch", ",", "self", ".", "cumulative_period", ")", "\n", "current_weight", "=", "self", ".", "restart_weights", "[", "idx", "]", "\n", "nearest_restart", "=", "0", "if", "idx", "==", "0", "else", "self", ".", "cumulative_period", "[", "idx", "-", "1", "]", "\n", "current_period", "=", "self", ".", "periods", "[", "idx", "]", "\n", "\n", "return", "[", "\n", "self", ".", "eta_min", "+", "current_weight", "*", "0.5", "*", "(", "base_lr", "-", "self", ".", "eta_min", ")", "*", "\n", "(", "1", "+", "math", ".", "cos", "(", "math", ".", "pi", "*", "(", "(", "self", ".", "last_epoch", "-", "nearest_restart", ")", "/", "current_period", ")", ")", ")", "\n", "for", "base_lr", "in", "self", ".", "base_lrs", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.lr_scheduler.get_position_from_periods": [[36, 55], ["enumerate"], "function", ["None"], ["", "", "def", "get_position_from_periods", "(", "iteration", ",", "cumulative_period", ")", ":", "\n", "    ", "\"\"\"Get the position from a period list.\n\n    It will return the index of the right-closest number in the period list.\n    For example, the cumulative_period = [100, 200, 300, 400],\n    if iteration == 50, return 0;\n    if iteration == 210, return 2;\n    if iteration == 300, return 2.\n\n    Args:\n        iteration (int): Current iteration.\n        cumulative_period (list[int]): Cumulative period list.\n\n    Returns:\n        int: The position of the right-closest number in the period list.\n    \"\"\"", "\n", "for", "i", ",", "period", "in", "enumerate", "(", "cumulative_period", ")", ":", "\n", "        ", "if", "iteration", "<=", "period", ":", "\n", "            ", "return", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.init_training_settings": [[14, 70], ["train_opt.get", "basicsr.archs.build_network", "srgan_model.SRGANModel.model_to_device", "srgan_model.SRGANModel.opt[].get", "srgan_model.SRGANModel.opt[].get", "srgan_model.SRGANModel.net_g.train", "srgan_model.SRGANModel.net_d.train", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "train_opt.get", "srgan_model.SRGANModel.setup_optimizers", "srgan_model.SRGANModel.setup_schedulers", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.archs.build_network().to", "srgan_model.SRGANModel.net_g_ema.parameters", "srgan_model.SRGANModel.opt[].get", "srgan_model.SRGANModel.net_g_ema.eval", "srgan_model.SRGANModel.load_network", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "basicsr.losses.build_loss().to", "srgan_model.SRGANModel.load_network", "srgan_model.SRGANModel.model_ema", "srgan_model.SRGANModel.opt[].get", "basicsr.archs.build_network", "srgan_model.SRGANModel.opt[].get", "basicsr.losses.build_loss", "basicsr.losses.build_loss", "basicsr.losses.build_loss", "basicsr.losses.build_loss"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_to_device", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.setup_optimizers", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.setup_schedulers", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.archs.__init__.build_network", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss", "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss"], ["    ", "def", "init_training_settings", "(", "self", ")", ":", "\n", "        ", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "\n", "self", ".", "ema_decay", "=", "train_opt", ".", "get", "(", "'ema_decay'", ",", "0", ")", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "info", "(", "f'Use Exponential Moving Average with decay: {self.ema_decay}'", ")", "\n", "self", ".", "net_g_ema", "=", "build_network", "(", "self", ".", "opt", "[", "'network_g'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "for", "p", "in", "self", ".", "net_g_ema", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "# load pretrained model", "\n", "", "load_path", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_g'", ",", "None", ")", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "                ", "self", ".", "load_network", "(", "self", ".", "net_g_ema", ",", "load_path", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_g'", ",", "True", ")", ",", "'params_ema'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "model_ema", "(", "0", ")", "# copy net_g weight", "\n", "", "self", ".", "net_g_ema", ".", "eval", "(", ")", "\n", "\n", "# define network net_d", "\n", "", "self", ".", "net_d", "=", "build_network", "(", "self", ".", "opt", "[", "'network_d'", "]", ")", "\n", "self", ".", "net_d", "=", "self", ".", "model_to_device", "(", "self", ".", "net_d", ")", "\n", "\n", "# load pretrained models", "\n", "load_path", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'pretrain_network_d'", ",", "None", ")", "\n", "load_key", "=", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'param_key_g'", ",", "None", ")", "\n", "if", "load_path", "is", "not", "None", ":", "\n", "            ", "self", ".", "load_network", "(", "self", ".", "net_d", ",", "load_path", ",", "self", ".", "opt", "[", "'path'", "]", ".", "get", "(", "'strict_load_d'", ",", "True", ")", ",", "load_key", ")", "\n", "\n", "", "self", ".", "net_g", ".", "train", "(", ")", "\n", "self", ".", "net_d", ".", "train", "(", ")", "\n", "\n", "# define losses", "\n", "if", "train_opt", ".", "get", "(", "'pixel_opt'", ")", ":", "\n", "            ", "self", ".", "cri_pix", "=", "build_loss", "(", "train_opt", "[", "'pixel_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_pix", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'artifacts_opt'", ")", ":", "\n", "            ", "self", ".", "cri_artifacts", "=", "build_loss", "(", "train_opt", "[", "'artifacts_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_artifacts", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'perceptual_opt'", ")", ":", "\n", "            ", "self", ".", "cri_perceptual", "=", "build_loss", "(", "train_opt", "[", "'perceptual_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cri_perceptual", "=", "None", "\n", "\n", "", "if", "train_opt", ".", "get", "(", "'gan_opt'", ")", ":", "\n", "            ", "self", ".", "cri_gan", "=", "build_loss", "(", "train_opt", "[", "'gan_opt'", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "net_d_iters", "=", "train_opt", ".", "get", "(", "'net_d_iters'", ",", "1", ")", "\n", "self", ".", "net_d_init_iters", "=", "train_opt", ".", "get", "(", "'net_d_init_iters'", ",", "0", ")", "\n", "\n", "# set up optimizers and schedulers", "\n", "self", ".", "setup_optimizers", "(", ")", "\n", "self", ".", "setup_schedulers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.setup_optimizers": [[71, 81], ["train_opt[].pop", "srgan_model.SRGANModel.get_optimizer", "srgan_model.SRGANModel.optimizers.append", "train_opt[].pop", "srgan_model.SRGANModel.get_optimizer", "srgan_model.SRGANModel.optimizers.append", "srgan_model.SRGANModel.net_g.parameters", "srgan_model.SRGANModel.net_d.parameters"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_optimizer", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_optimizer"], ["", "def", "setup_optimizers", "(", "self", ")", ":", "\n", "        ", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "# optimizer g", "\n", "optim_type", "=", "train_opt", "[", "'optim_g'", "]", ".", "pop", "(", "'type'", ")", "\n", "self", ".", "optimizer_g", "=", "self", ".", "get_optimizer", "(", "optim_type", ",", "self", ".", "net_g", ".", "parameters", "(", ")", ",", "**", "train_opt", "[", "'optim_g'", "]", ")", "\n", "self", ".", "optimizers", ".", "append", "(", "self", ".", "optimizer_g", ")", "\n", "# optimizer d", "\n", "optim_type", "=", "train_opt", "[", "'optim_d'", "]", ".", "pop", "(", "'type'", ")", "\n", "self", ".", "optimizer_d", "=", "self", ".", "get_optimizer", "(", "optim_type", ",", "self", ".", "net_d", ".", "parameters", "(", ")", ",", "**", "train_opt", "[", "'optim_d'", "]", ")", "\n", "self", ".", "optimizers", ".", "append", "(", "self", ".", "optimizer_d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.optimize_parameters": [[82, 139], ["srgan_model.SRGANModel.net_d.parameters", "srgan_model.SRGANModel.optimizer_g.zero_grad", "srgan_model.SRGANModel.net_g", "collections.OrderedDict", "srgan_model.SRGANModel.net_d.parameters", "srgan_model.SRGANModel.optimizer_d.zero_grad", "srgan_model.SRGANModel.net_d", "srgan_model.SRGANModel.cri_gan", "torch.mean", "srgan_model.SRGANModel.backward", "srgan_model.SRGANModel.net_d", "srgan_model.SRGANModel.cri_gan", "torch.mean", "srgan_model.SRGANModel.backward", "srgan_model.SRGANModel.optimizer_d.step", "srgan_model.SRGANModel.reduce_loss_dict", "srgan_model.SRGANModel.net_d", "srgan_model.SRGANModel.cri_gan", "l_g_total.backward", "srgan_model.SRGANModel.optimizer_g.step", "srgan_model.SRGANModel.detach", "srgan_model.SRGANModel.output.detach", "srgan_model.SRGANModel.detach", "srgan_model.SRGANModel.model_ema", "srgan_model.SRGANModel.cri_pix", "srgan_model.SRGANModel.cri_perceptual"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.reduce_loss_dict", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema"], ["", "def", "optimize_parameters", "(", "self", ",", "current_iter", ")", ":", "\n", "# optimize net_g", "\n", "        ", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "optimizer_g", ".", "zero_grad", "(", ")", "\n", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ")", "\n", "\n", "l_g_total", "=", "0", "\n", "loss_dict", "=", "OrderedDict", "(", ")", "\n", "if", "(", "current_iter", "%", "self", ".", "net_d_iters", "==", "0", "and", "current_iter", ">", "self", ".", "net_d_init_iters", ")", ":", "\n", "# pixel loss", "\n", "            ", "if", "self", ".", "cri_pix", ":", "\n", "                ", "l_g_pix", "=", "self", ".", "cri_pix", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "l_g_total", "+=", "l_g_pix", "\n", "loss_dict", "[", "'l_g_pix'", "]", "=", "l_g_pix", "\n", "# perceptual loss", "\n", "", "if", "self", ".", "cri_perceptual", ":", "\n", "                ", "l_g_percep", ",", "l_g_style", "=", "self", ".", "cri_perceptual", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "if", "l_g_percep", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_g_percep", "\n", "loss_dict", "[", "'l_g_percep'", "]", "=", "l_g_percep", "\n", "", "if", "l_g_style", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_g_style", "\n", "loss_dict", "[", "'l_g_style'", "]", "=", "l_g_style", "\n", "# gan loss", "\n", "", "", "fake_g_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ")", "\n", "l_g_gan", "=", "self", ".", "cri_gan", "(", "fake_g_pred", ",", "True", ",", "is_disc", "=", "False", ")", "\n", "l_g_total", "+=", "l_g_gan", "\n", "loss_dict", "[", "'l_g_gan'", "]", "=", "l_g_gan", "\n", "\n", "l_g_total", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_g", ".", "step", "(", ")", "\n", "\n", "# optimize net_d", "\n", "", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "self", ".", "optimizer_d", ".", "zero_grad", "(", ")", "\n", "# real", "\n", "real_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "gt", ")", "\n", "l_d_real", "=", "self", ".", "cri_gan", "(", "real_d_pred", ",", "True", ",", "is_disc", "=", "True", ")", "\n", "loss_dict", "[", "'l_d_real'", "]", "=", "l_d_real", "\n", "loss_dict", "[", "'out_d_real'", "]", "=", "torch", ".", "mean", "(", "real_d_pred", ".", "detach", "(", ")", ")", "\n", "l_d_real", ".", "backward", "(", ")", "\n", "# fake", "\n", "fake_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ".", "detach", "(", ")", ")", "\n", "l_d_fake", "=", "self", ".", "cri_gan", "(", "fake_d_pred", ",", "False", ",", "is_disc", "=", "True", ")", "\n", "loss_dict", "[", "'l_d_fake'", "]", "=", "l_d_fake", "\n", "loss_dict", "[", "'out_d_fake'", "]", "=", "torch", ".", "mean", "(", "fake_d_pred", ".", "detach", "(", ")", ")", "\n", "l_d_fake", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_d", ".", "step", "(", ")", "\n", "\n", "self", ".", "log_dict", "=", "self", ".", "reduce_loss_dict", "(", "loss_dict", ")", "\n", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "self", ".", "model_ema", "(", "decay", "=", "self", ".", "ema_decay", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.srgan_model.SRGANModel.save": [[140, 147], ["hasattr", "srgan_model.SRGANModel.save_network", "srgan_model.SRGANModel.save_training_state", "srgan_model.SRGANModel.save_network", "srgan_model.SRGANModel.save_network"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_training_state", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network"], ["", "", "def", "save", "(", "self", ",", "epoch", ",", "current_iter", ")", ":", "\n", "        ", "if", "hasattr", "(", "self", ",", "'net_g_ema'", ")", ":", "\n", "            ", "self", ".", "save_network", "(", "[", "self", ".", "net_g", ",", "self", ".", "net_g_ema", "]", ",", "'net_g'", ",", "current_iter", ",", "param_key", "=", "[", "'params'", ",", "'params_ema'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "save_network", "(", "self", ".", "net_g", ",", "'net_g'", ",", "current_iter", ")", "\n", "", "self", ".", "save_network", "(", "self", ".", "net_d", ",", "'net_d'", ",", "current_iter", ")", "\n", "self", ".", "save_training_state", "(", "epoch", ",", "current_iter", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.models.__init__.build_model": [[19, 31], ["copy.deepcopy", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.registry.MODEL_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], []], "home.repos.pwc.inspect_result.csjliang_dasr.models.esrgan_model.ESRGANModel.optimize_parameters": [[12, 84], ["esrgan_model.ESRGANModel.net_d.parameters", "esrgan_model.ESRGANModel.optimizer_g.zero_grad", "esrgan_model.ESRGANModel.net_g", "collections.OrderedDict", "esrgan_model.ESRGANModel.net_d.parameters", "esrgan_model.ESRGANModel.optimizer_d.zero_grad", "esrgan_model.ESRGANModel.net_d().detach", "esrgan_model.ESRGANModel.net_d", "l_d_real.backward", "esrgan_model.ESRGANModel.net_d", "l_d_fake.backward", "esrgan_model.ESRGANModel.optimizer_d.step", "torch.mean", "torch.mean", "esrgan_model.ESRGANModel.reduce_loss_dict", "esrgan_model.ESRGANModel.net_d().detach", "esrgan_model.ESRGANModel.net_d", "esrgan_model.ESRGANModel.cri_gan", "esrgan_model.ESRGANModel.cri_gan", "l_g_total.backward", "esrgan_model.ESRGANModel.optimizer_g.step", "esrgan_model.ESRGANModel.cri_gan", "esrgan_model.ESRGANModel.output.detach", "esrgan_model.ESRGANModel.cri_gan", "esrgan_model.ESRGANModel.detach", "esrgan_model.ESRGANModel.detach", "esrgan_model.ESRGANModel.model_ema", "esrgan_model.ESRGANModel.cri_pix", "esrgan_model.ESRGANModel.cri_perceptual", "esrgan_model.ESRGANModel.net_d", "esrgan_model.ESRGANModel.net_d", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "esrgan_model.ESRGANModel.detach"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.reduce_loss_dict", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema"], ["def", "optimize_parameters", "(", "self", ",", "current_iter", ")", ":", "\n", "# optimize net_g", "\n", "        ", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "optimizer_g", ".", "zero_grad", "(", ")", "\n", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ")", "\n", "\n", "l_g_total", "=", "0", "\n", "loss_dict", "=", "OrderedDict", "(", ")", "\n", "if", "(", "current_iter", "%", "self", ".", "net_d_iters", "==", "0", "and", "current_iter", ">", "self", ".", "net_d_init_iters", ")", ":", "\n", "# pixel loss", "\n", "            ", "if", "self", ".", "cri_pix", ":", "\n", "                ", "l_g_pix", "=", "self", ".", "cri_pix", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "l_g_total", "+=", "l_g_pix", "\n", "loss_dict", "[", "'l_g_pix'", "]", "=", "l_g_pix", "\n", "# perceptual loss", "\n", "", "if", "self", ".", "cri_perceptual", ":", "\n", "                ", "l_g_percep", ",", "l_g_style", "=", "self", ".", "cri_perceptual", "(", "self", ".", "output", ",", "self", ".", "gt", ")", "\n", "if", "l_g_percep", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_g_percep", "\n", "loss_dict", "[", "'l_g_percep'", "]", "=", "l_g_percep", "\n", "", "if", "l_g_style", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_g_style", "\n", "loss_dict", "[", "'l_g_style'", "]", "=", "l_g_style", "\n", "# gan loss (relativistic gan)", "\n", "", "", "real_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "gt", ")", ".", "detach", "(", ")", "\n", "fake_g_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ")", "\n", "l_g_real", "=", "self", ".", "cri_gan", "(", "real_d_pred", "-", "torch", ".", "mean", "(", "fake_g_pred", ")", ",", "False", ",", "is_disc", "=", "False", ")", "\n", "l_g_fake", "=", "self", ".", "cri_gan", "(", "fake_g_pred", "-", "torch", ".", "mean", "(", "real_d_pred", ")", ",", "True", ",", "is_disc", "=", "False", ")", "\n", "l_g_gan", "=", "(", "l_g_real", "+", "l_g_fake", ")", "/", "2", "\n", "\n", "l_g_total", "+=", "l_g_gan", "\n", "loss_dict", "[", "'l_g_gan'", "]", "=", "l_g_gan", "\n", "\n", "l_g_total", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_g", ".", "step", "(", ")", "\n", "\n", "# optimize net_d", "\n", "", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "self", ".", "optimizer_d", ".", "zero_grad", "(", ")", "\n", "# gan loss (relativistic gan)", "\n", "\n", "# In order to avoid the error in distributed training:", "\n", "# \"Error detected in CudnnBatchNormBackward: RuntimeError: one of", "\n", "# the variables needed for gradient computation has been modified by", "\n", "# an inplace operation\",", "\n", "# we separate the backwards for real and fake, and also detach the", "\n", "# tensor for calculating mean.", "\n", "\n", "# real", "\n", "fake_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ")", ".", "detach", "(", ")", "\n", "real_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "gt", ")", "\n", "l_d_real", "=", "self", ".", "cri_gan", "(", "real_d_pred", "-", "torch", ".", "mean", "(", "fake_d_pred", ")", ",", "True", ",", "is_disc", "=", "True", ")", "*", "0.5", "\n", "l_d_real", ".", "backward", "(", ")", "\n", "# fake", "\n", "fake_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ".", "detach", "(", ")", ")", "\n", "l_d_fake", "=", "self", ".", "cri_gan", "(", "fake_d_pred", "-", "torch", ".", "mean", "(", "real_d_pred", ".", "detach", "(", ")", ")", ",", "False", ",", "is_disc", "=", "True", ")", "*", "0.5", "\n", "l_d_fake", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_d", ".", "step", "(", ")", "\n", "\n", "loss_dict", "[", "'l_d_real'", "]", "=", "l_d_real", "\n", "loss_dict", "[", "'l_d_fake'", "]", "=", "l_d_fake", "\n", "loss_dict", "[", "'out_d_real'", "]", "=", "torch", ".", "mean", "(", "real_d_pred", ".", "detach", "(", ")", ")", "\n", "loss_dict", "[", "'out_d_fake'", "]", "=", "torch", ".", "mean", "(", "fake_d_pred", ".", "detach", "(", ")", ")", "\n", "\n", "self", ".", "log_dict", "=", "self", ".", "reduce_loss_dict", "(", "loss_dict", ")", "\n", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "self", ".", "model_ema", "(", "decay", "=", "self", ".", "ema_decay", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.__init__": [[16, 22], ["torch.device"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "self", ".", "opt", "=", "opt", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "opt", "[", "'num_gpu'", "]", "!=", "0", "else", "'cpu'", ")", "\n", "self", ".", "is_train", "=", "opt", "[", "'is_train'", "]", "\n", "self", ".", "schedulers", "=", "[", "]", "\n", "self", ".", "optimizers", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.feed_data": [[23, 25], ["None"], "methods", ["None"], ["", "def", "feed_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.optimize_parameters": [[26, 28], ["None"], "methods", ["None"], ["", "def", "optimize_parameters", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_visuals": [[29, 31], ["None"], "methods", ["None"], ["", "def", "get_current_visuals", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save": [[32, 35], ["None"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "epoch", ",", "current_iter", ")", ":", "\n", "        ", "\"\"\"Save networks and training state.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.validation": [[36, 49], ["base_model.BaseModel.dist_validation", "base_model.BaseModel.nondist_validation"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.sr_model.SRModel.dist_validation", "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation"], ["", "def", "validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", "=", "False", ")", ":", "\n", "        ", "\"\"\"Validation function.\n\n        Args:\n            dataloader (torch.utils.data.DataLoader): Validation dataloader.\n            current_iter (int): Current iteration.\n            tb_logger (tensorboard logger): Tensorboard logger.\n            save_img (bool): Whether to save images. Default: False.\n        \"\"\"", "\n", "if", "self", ".", "opt", "[", "'dist'", "]", ":", "\n", "            ", "self", ".", "dist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "nondist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema": [[62, 68], ["base_model.BaseModel.get_bare_model", "dict", "dict", "dict.keys", "base_model.BaseModel.named_parameters", "base_model.BaseModel.net_g_ema.named_parameters", "net_g_ema_params[].data.mul_().add_", "net_g_ema_params[].data.mul_"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "", "def", "model_ema", "(", "self", ",", "decay", "=", "0.999", ")", ":", "\n", "        ", "net_g", "=", "self", ".", "get_bare_model", "(", "self", ".", "net_g", ")", "\n", "net_g_params", "=", "dict", "(", "net_g", ".", "named_parameters", "(", ")", ")", "\n", "net_g_ema_params", "=", "dict", "(", "self", ".", "net_g_ema", ".", "named_parameters", "(", ")", ")", "\n", "for", "k", "in", "net_g_ema_params", ".", "keys", "(", ")", ":", "\n", "            ", "net_g_ema_params", "[", "k", "]", ".", "data", ".", "mul_", "(", "decay", ")", ".", "add_", "(", "net_g_params", "[", "k", "]", ".", "data", ",", "alpha", "=", "1", "-", "decay", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.iqa_model_ema": [[69, 75], ["base_model.BaseModel.get_bare_model", "dict", "dict", "dict.keys", "base_model.BaseModel.named_parameters", "base_model.BaseModel.net_iqa_ema.named_parameters", "net_g_ema_params[].data.mul_().add_", "net_g_ema_params[].data.mul_"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "", "def", "iqa_model_ema", "(", "self", ",", "decay", "=", "0.999", ")", ":", "\n", "        ", "net_g", "=", "self", ".", "get_bare_model", "(", "self", ".", "net_iqa", ")", "\n", "net_g_params", "=", "dict", "(", "net_g", ".", "named_parameters", "(", ")", ")", "\n", "net_g_ema_params", "=", "dict", "(", "self", ".", "net_iqa_ema", ".", "named_parameters", "(", ")", ")", "\n", "for", "k", "in", "net_g_ema_params", ".", "keys", "(", ")", ":", "\n", "            ", "net_g_ema_params", "[", "k", "]", ".", "data", ".", "mul_", "(", "decay", ")", ".", "add_", "(", "net_g_params", "[", "k", "]", ".", "data", ",", "alpha", "=", "1", "-", "decay", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_interpolation": [[76, 90], ["base_model.BaseModel.get_bare_model", "dict", "dict.keys", "range", "base_model.BaseModel.net_g_interp.named_parameters", "net_g_interp_params[].data.mul_", "getattr", "base_model.BaseModel.get_bare_model", "dict", "dict.keys", "base_model.BaseModel.named_parameters", "net_g_interp_params[].data.add_", "str", "factor[].detach().cpu", "factor[].detach"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "", "def", "model_interpolation", "(", "self", ",", "factor", ")", ":", "\n", "        ", "net_g_interp", "=", "self", ".", "get_bare_model", "(", "self", ".", "net_g_interp", ")", "\n", "net_g_interp_params", "=", "dict", "(", "self", ".", "net_g_interp", ".", "named_parameters", "(", ")", ")", "\n", "for", "k", "in", "net_g_interp_params", ".", "keys", "(", ")", ":", "\n", "            ", "net_g_interp_params", "[", "k", "]", ".", "data", ".", "mul_", "(", "0", ")", "\n", "", "for", "i", "in", "range", "(", "self", ".", "opt", "[", "'num_networks'", "]", ")", ":", "\n", "            ", "net_g", "=", "getattr", "(", "self", ",", "'net_g_{}'", ".", "format", "(", "str", "(", "i", ")", ")", ")", "\n", "net_g", "=", "self", ".", "get_bare_model", "(", "net_g", ")", "\n", "net_g_params", "=", "dict", "(", "net_g", ".", "named_parameters", "(", ")", ")", "\n", "# for k1, k2 in zip(net_g_interp_params.keys(), net_g_params.keys()):", "\n", "#     print(k1, k2)", "\n", "for", "k", "in", "net_g_interp_params", ".", "keys", "(", ")", ":", "\n", "# self.net_g_interp[k] += net_g_params[k] * factor[i]", "\n", "                ", "net_g_interp_params", "[", "k", "]", ".", "data", ".", "add_", "(", "net_g_params", "[", "k", "]", ".", "data", ",", "alpha", "=", "factor", "[", "i", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ")", "\n", "# return net_g_interp", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_log": [[92, 94], ["None"], "methods", ["None"], ["", "", "", "def", "get_current_log", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "log_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_to_device": [[95, 111], ["torch.nn.parallel.DataParallel.to", "base_model.BaseModel.opt.get", "torch.nn.parallel.DistributedDataParallel", "torch.nn.parallel.DataParallel", "torch.cuda.current_device"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "def", "model_to_device", "(", "self", ",", "net", ")", ":", "\n", "        ", "\"\"\"Model to device. It also warps models with DistributedDataParallel\n        or DataParallel.\n\n        Args:\n            net (nn.Module)\n        \"\"\"", "\n", "net", "=", "net", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "self", ".", "opt", "[", "'dist'", "]", ":", "\n", "            ", "find_unused_parameters", "=", "self", ".", "opt", ".", "get", "(", "'find_unused_parameters'", ",", "False", ")", "\n", "# find_unused_parameters = True", "\n", "net", "=", "DistributedDataParallel", "(", "\n", "net", ",", "device_ids", "=", "[", "torch", ".", "cuda", ".", "current_device", "(", ")", "]", ",", "find_unused_parameters", "=", "find_unused_parameters", ")", "\n", "", "elif", "self", ".", "opt", "[", "'num_gpu'", "]", ">", "1", ":", "\n", "            ", "net", "=", "DataParallel", "(", "net", ")", "\n", "", "return", "net", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_optimizer": [[112, 118], ["torch.optim.Adam", "NotImplementedError"], "methods", ["None"], ["", "def", "get_optimizer", "(", "self", ",", "optim_type", ",", "params", ",", "lr", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "optim_type", "==", "'Adam'", ":", "\n", "            ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "params", ",", "lr", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'optimizer {optim_type} is not supperted yet.'", ")", "\n", "", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.setup_schedulers": [[119, 131], ["train_opt[].pop", "base_model.BaseModel.schedulers.append", "NotImplementedError", "basicsr.models.lr_scheduler.MultiStepRestartLR", "base_model.BaseModel.schedulers.append", "basicsr.models.lr_scheduler.CosineAnnealingRestartLR"], "methods", ["None"], ["", "def", "setup_schedulers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set up schedulers.\"\"\"", "\n", "train_opt", "=", "self", ".", "opt", "[", "'train'", "]", "\n", "scheduler_type", "=", "train_opt", "[", "'scheduler'", "]", ".", "pop", "(", "'type'", ")", "\n", "if", "scheduler_type", "in", "[", "'MultiStepLR'", ",", "'MultiStepRestartLR'", "]", ":", "\n", "            ", "for", "optimizer", "in", "self", ".", "optimizers", ":", "\n", "                ", "self", ".", "schedulers", ".", "append", "(", "lr_scheduler", ".", "MultiStepRestartLR", "(", "optimizer", ",", "**", "train_opt", "[", "'scheduler'", "]", ")", ")", "\n", "", "", "elif", "scheduler_type", "==", "'CosineAnnealingRestartLR'", ":", "\n", "            ", "for", "optimizer", "in", "self", ".", "optimizers", ":", "\n", "                ", "self", ".", "schedulers", ".", "append", "(", "lr_scheduler", ".", "CosineAnnealingRestartLR", "(", "optimizer", ",", "**", "train_opt", "[", "'scheduler'", "]", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'Scheduler {scheduler_type} is not implemented yet.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model": [[132, 139], ["isinstance"], "methods", ["None"], ["", "", "def", "get_bare_model", "(", "self", ",", "net", ")", ":", "\n", "        ", "\"\"\"Get bare model, especially under wrapping with\n        DistributedDataParallel or DataParallel.\n        \"\"\"", "\n", "if", "isinstance", "(", "net", ",", "(", "DataParallel", ",", "DistributedDataParallel", ")", ")", ":", "\n", "            ", "net", "=", "net", ".", "module", "\n", "", "return", "net", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.print_network": [[140, 159], ["isinstance", "base_model.BaseModel.get_bare_model", "str", "sum", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.get_root_logger.info", "map", "base_model.BaseModel.parameters", "x.numel"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "@", "master_only", "\n", "def", "print_network", "(", "self", ",", "net", ")", ":", "\n", "        ", "\"\"\"Print the str and parameter number of a network.\n\n        Args:\n            net (nn.Module)\n        \"\"\"", "\n", "if", "isinstance", "(", "net", ",", "(", "DataParallel", ",", "DistributedDataParallel", ")", ")", ":", "\n", "            ", "net_cls_str", "=", "(", "f'{net.__class__.__name__} - '", "f'{net.module.__class__.__name__}'", ")", "\n", "", "else", ":", "\n", "            ", "net_cls_str", "=", "f'{net.__class__.__name__}'", "\n", "\n", "", "net", "=", "self", ".", "get_bare_model", "(", "net", ")", "\n", "net_str", "=", "str", "(", "net", ")", "\n", "net_params", "=", "sum", "(", "map", "(", "lambda", "x", ":", "x", ".", "numel", "(", ")", ",", "net", ".", "parameters", "(", ")", ")", ")", "\n", "\n", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "info", "(", "f'Network: {net_cls_str}, with parameters: {net_params:,d}'", ")", "\n", "logger", ".", "info", "(", "net_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._set_lr": [[160, 169], ["zip", "zip"], "methods", ["None"], ["", "def", "_set_lr", "(", "self", ",", "lr_groups_l", ")", ":", "\n", "        ", "\"\"\"Set learning rate for warmup.\n\n        Args:\n            lr_groups_l (list): List for lr_groups, each for an optimizer.\n        \"\"\"", "\n", "for", "optimizer", ",", "lr_groups", "in", "zip", "(", "self", ".", "optimizers", ",", "lr_groups_l", ")", ":", "\n", "            ", "for", "param_group", ",", "lr", "in", "zip", "(", "optimizer", ".", "param_groups", ",", "lr_groups", ")", ":", "\n", "                ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._get_init_lr": [[170, 177], ["init_lr_groups_l.append"], "methods", ["None"], ["", "", "", "def", "_get_init_lr", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the initial lr, which is set by the scheduler.\n        \"\"\"", "\n", "init_lr_groups_l", "=", "[", "]", "\n", "for", "optimizer", "in", "self", ".", "optimizers", ":", "\n", "            ", "init_lr_groups_l", ".", "append", "(", "[", "v", "[", "'initial_lr'", "]", "for", "v", "in", "optimizer", ".", "param_groups", "]", ")", "\n", "", "return", "init_lr_groups_l", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.update_learning_rate": [[178, 200], ["base_model.BaseModel._get_init_lr", "base_model.BaseModel._set_lr", "scheduler.step", "warm_up_lr_l.append"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._get_init_lr", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._set_lr"], ["", "def", "update_learning_rate", "(", "self", ",", "current_iter", ",", "warmup_iter", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"Update learning rate.\n\n        Args:\n            current_iter (int): Current iteration.\n            warmup_iter (int)\uff1a Warmup iter numbers. -1 for no warmup.\n                Default\uff1a -1.\n        \"\"\"", "\n", "if", "current_iter", ">", "1", ":", "\n", "            ", "for", "scheduler", "in", "self", ".", "schedulers", ":", "\n", "                ", "scheduler", ".", "step", "(", ")", "\n", "# set up warm-up learning rate", "\n", "", "", "if", "current_iter", "<", "warmup_iter", ":", "\n", "# get initial lr for each group", "\n", "            ", "init_lr_g_l", "=", "self", ".", "_get_init_lr", "(", ")", "\n", "# modify warming-up learning rates", "\n", "# currently only support linearly warm up", "\n", "warm_up_lr_l", "=", "[", "]", "\n", "for", "init_lr_g", "in", "init_lr_g_l", ":", "\n", "                ", "warm_up_lr_l", ".", "append", "(", "[", "v", "/", "warmup_iter", "*", "current_iter", "for", "v", "in", "init_lr_g", "]", ")", "\n", "# set learning rate", "\n", "", "self", ".", "_set_lr", "(", "warm_up_lr_l", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_current_learning_rate": [[201, 203], ["None"], "methods", ["None"], ["", "", "def", "get_current_learning_rate", "(", "self", ")", ":", "\n", "        ", "return", "[", "param_group", "[", "'lr'", "]", "for", "param_group", "in", "self", ".", "optimizers", "[", "0", "]", ".", "param_groups", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_network": [[204, 249], ["os.path.join", "zip", "isinstance", "isinstance", "len", "len", "base_model.BaseModel.get_bare_model", "base_model.BaseModel.state_dict", "base_model.BaseModel.state_dict.items", "IOError", "key.startswith", "param.cpu", "torch.save", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warn", "time.sleep"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "@", "master_only", "\n", "def", "save_network", "(", "self", ",", "net", ",", "net_label", ",", "current_iter", ",", "param_key", "=", "'params'", ")", ":", "\n", "        ", "\"\"\"Save networks.\n\n        Args:\n            net (nn.Module | list[nn.Module]): Network(s) to be saved.\n            net_label (str): Network label.\n            current_iter (int): Current iter number.\n            param_key (str | list[str]): The parameter key(s) to save network.\n                Default: 'params'.\n        \"\"\"", "\n", "if", "current_iter", "==", "-", "1", ":", "\n", "            ", "current_iter", "=", "'latest'", "\n", "", "save_filename", "=", "f'{net_label}_{current_iter}.pth'", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'models'", "]", ",", "save_filename", ")", "\n", "\n", "net", "=", "net", "if", "isinstance", "(", "net", ",", "list", ")", "else", "[", "net", "]", "\n", "param_key", "=", "param_key", "if", "isinstance", "(", "param_key", ",", "list", ")", "else", "[", "param_key", "]", "\n", "assert", "len", "(", "net", ")", "==", "len", "(", "param_key", ")", ",", "'The lengths of net and param_key should be the same.'", "\n", "\n", "save_dict", "=", "{", "}", "\n", "for", "net_", ",", "param_key_", "in", "zip", "(", "net", ",", "param_key", ")", ":", "\n", "            ", "net_", "=", "self", ".", "get_bare_model", "(", "net_", ")", "\n", "state_dict", "=", "net_", ".", "state_dict", "(", ")", "\n", "for", "key", ",", "param", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "                ", "if", "key", ".", "startswith", "(", "'module.'", ")", ":", "# remove unnecessary 'module.'", "\n", "                    ", "key", "=", "key", "[", "7", ":", "]", "\n", "", "state_dict", "[", "key", "]", "=", "param", ".", "cpu", "(", ")", "\n", "", "save_dict", "[", "param_key_", "]", "=", "state_dict", "\n", "\n", "# avoid occasional writing errors", "\n", "", "retry", "=", "3", "\n", "while", "retry", ">", "0", ":", "\n", "            ", "try", ":", "\n", "                ", "torch", ".", "save", "(", "save_dict", ",", "save_path", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warn", "(", "f'Save model error: {e}, remaining retry times: {retry - 1}'", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "finally", ":", "\n", "                ", "retry", "-=", "1", "\n", "", "", "if", "retry", "==", "0", ":", "# still cannot save", "\n", "            ", "raise", "IOError", "(", "f'Cannot save {save_path}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._print_different_keys_loading": [[250, 284], ["base_model.BaseModel.get_bare_model", "crt_net.state_dict.state_dict.state_dict", "set", "set", "basicsr.utils.get_root_logger", "crt_net.state_dict.state_dict.keys", "load_net.keys", "basicsr.utils.get_root_logger.warning", "sorted", "basicsr.utils.get_root_logger.warning", "sorted", "list", "basicsr.utils.get_root_logger.warning", "list", "basicsr.utils.get_root_logger.warning", "crt_net[].size", "load_net[].size", "basicsr.utils.get_root_logger.warning", "load_net.pop"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["", "", "def", "_print_different_keys_loading", "(", "self", ",", "crt_net", ",", "load_net", ",", "strict", "=", "True", ")", ":", "\n", "        ", "\"\"\"Print keys with differnet name or different size when loading models.\n\n        1. Print keys with differnet names.\n        2. If strict=False, print the same key but with different tensor size.\n            It also ignore these keys with different sizes (not load).\n\n        Args:\n            crt_net (torch model): Current network.\n            load_net (dict): Loaded network.\n            strict (bool): Whether strictly loaded. Default: True.\n        \"\"\"", "\n", "crt_net", "=", "self", ".", "get_bare_model", "(", "crt_net", ")", "\n", "crt_net", "=", "crt_net", ".", "state_dict", "(", ")", "\n", "crt_net_keys", "=", "set", "(", "crt_net", ".", "keys", "(", ")", ")", "\n", "load_net_keys", "=", "set", "(", "load_net", ".", "keys", "(", ")", ")", "\n", "\n", "logger", "=", "get_root_logger", "(", ")", "\n", "if", "crt_net_keys", "!=", "load_net_keys", ":", "\n", "            ", "logger", ".", "warning", "(", "'Current net - loaded net:'", ")", "\n", "for", "v", "in", "sorted", "(", "list", "(", "crt_net_keys", "-", "load_net_keys", ")", ")", ":", "\n", "                ", "logger", ".", "warning", "(", "f'  {v}'", ")", "\n", "", "logger", ".", "warning", "(", "'Loaded net - current net:'", ")", "\n", "for", "v", "in", "sorted", "(", "list", "(", "load_net_keys", "-", "crt_net_keys", ")", ")", ":", "\n", "                ", "logger", ".", "warning", "(", "f'  {v}'", ")", "\n", "\n", "# check the size for the same keys", "\n", "", "", "if", "not", "strict", ":", "\n", "            ", "common_keys", "=", "crt_net_keys", "&", "load_net_keys", "\n", "for", "k", "in", "common_keys", ":", "\n", "                ", "if", "crt_net", "[", "k", "]", ".", "size", "(", ")", "!=", "load_net", "[", "k", "]", ".", "size", "(", ")", ":", "\n", "                    ", "logger", ".", "warning", "(", "f'Size different, ignore [{k}]: crt_net: '", "\n", "f'{crt_net[k].shape}; load_net: {load_net[k].shape}'", ")", "\n", "load_net", "[", "k", "+", "'.ignore'", "]", "=", "load_net", ".", "pop", "(", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network": [[285, 316], ["basicsr.utils.get_root_logger", "base_model.BaseModel.get_bare_model", "basicsr.utils.get_root_logger.info", "torch.load", "copy.deepcopy().items", "base_model.BaseModel._print_different_keys_loading", "base_model.BaseModel.load_state_dict", "k.startswith", "basicsr.utils.get_root_logger.info", "copy.deepcopy", "torch.load.pop"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._print_different_keys_loading"], ["", "", "", "", "def", "load_network", "(", "self", ",", "net", ",", "load_path", ",", "strict", "=", "True", ",", "param_key", "=", "'params'", ")", ":", "\n", "        ", "\"\"\"Load network.\n\n        Args:\n            load_path (str): The path of networks to be loaded.\n            net (nn.Module): Network.\n            strict (bool): Whether strictly loaded.\n            param_key (str): The parameter key of loaded network. If set to\n                None, use the root 'path'.\n                Default: 'params'.\n        \"\"\"", "\n", "logger", "=", "get_root_logger", "(", ")", "\n", "net", "=", "self", ".", "get_bare_model", "(", "net", ")", "\n", "logger", ".", "info", "(", "f'Loading {net.__class__.__name__} model from {load_path}.'", ")", "\n", "load_net", "=", "torch", ".", "load", "(", "load_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "if", "param_key", "is", "not", "None", ":", "\n", "            ", "if", "param_key", "not", "in", "load_net", "and", "'params'", "in", "load_net", ":", "\n", "                ", "param_key", "=", "'params'", "\n", "logger", ".", "info", "(", "'Loading: params_ema does not exist, use params.'", ")", "\n", "", "if", "'BSRGAN.pth'", "not", "in", "load_path", "and", "'BSRNet.pth'", "not", "in", "load_path", ":", "\n", "                ", "try", ":", "\n", "                    ", "load_net", "=", "load_net", "[", "param_key", "]", "\n", "", "except", ":", "\n", "                    ", "pass", "\n", "# remove unnecessary 'module.'", "\n", "", "", "", "for", "k", ",", "v", "in", "deepcopy", "(", "load_net", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", ".", "startswith", "(", "'module.'", ")", ":", "\n", "                ", "load_net", "[", "k", "[", "7", ":", "]", "]", "=", "v", "\n", "load_net", ".", "pop", "(", "k", ")", "\n", "", "", "self", ".", "_print_different_keys_loading", "(", "net", ",", "load_net", ",", "strict", ")", "\n", "net", ".", "load_state_dict", "(", "load_net", ",", "strict", "=", "strict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network_init": [[317, 352], ["basicsr.utils.get_root_logger", "base_model.BaseModel.get_bare_model", "basicsr.utils.get_root_logger.info", "torch.load", "torch.load.items", "base_model.BaseModel._print_different_keys_loading", "base_model.BaseModel.load_state_dict", "basicsr.utils.get_root_logger.info", "v.unsqueeze().repeat", "v.unsqueeze().repeat", "v.unsqueeze", "v.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._print_different_keys_loading"], ["", "def", "load_network_init", "(", "self", ",", "net", ",", "load_path", ",", "num_networks", ",", "strict", "=", "True", ",", "param_key", "=", "'params'", ")", ":", "\n", "        ", "\"\"\"Load network.\n\n        Args:\n            load_path (str): The path of networks to be loaded.\n            net (nn.Module): Network.\n            strict (bool): Whether strictly loaded.\n            param_key (str): The parameter key of loaded network. If set to\n                None, use the root 'path'.\n                Default: 'params'.\n        \"\"\"", "\n", "logger", "=", "get_root_logger", "(", ")", "\n", "net", "=", "self", ".", "get_bare_model", "(", "net", ")", "\n", "logger", ".", "info", "(", "f'Loading {net.__class__.__name__} model from {load_path}.'", ")", "\n", "load_net", "=", "torch", ".", "load", "(", "load_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "if", "param_key", "is", "not", "None", ":", "\n", "            ", "if", "param_key", "not", "in", "load_net", "and", "'params'", "in", "load_net", ":", "\n", "                ", "param_key", "=", "'params'", "\n", "logger", ".", "info", "(", "'Loading: params_ema does not exist, use params.'", ")", "\n", "", "load_net", "=", "load_net", "[", "param_key", "]", "\n", "", "load_net_repeated", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "load_net", ".", "items", "(", ")", ":", "\n", "            ", "if", "'body'", "in", "k", "and", "'weight'", "in", "k", "and", "'_body'", "not", "in", "k", ":", "\n", "                ", "load_net_repeated", "[", "k", "]", "=", "v", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "num_networks", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "", "elif", "'body'", "in", "k", "and", "'bias'", "in", "k", "and", "'_body'", "not", "in", "k", ":", "\n", "                ", "load_net_repeated", "[", "k", "]", "=", "v", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "num_networks", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "load_net_repeated", "[", "k", "]", "=", "v", "\n", "# # # remove unnecessary 'module.'", "\n", "# for k, v in deepcopy(load_net).items():", "\n", "#     if k.startswith('module.'):", "\n", "#         load_net[k[7:]] = v", "\n", "#         load_net.pop(k)", "\n", "", "", "self", ".", "_print_different_keys_loading", "(", "net", ",", "load_net_repeated", ",", "strict", ")", "\n", "net", ".", "load_state_dict", "(", "load_net_repeated", ",", "strict", "=", "strict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.load_network_init_alldynamic": [[353, 388], ["basicsr.utils.get_root_logger", "base_model.BaseModel.get_bare_model", "basicsr.utils.get_root_logger.info", "torch.load", "torch.load.items", "base_model.BaseModel._print_different_keys_loading", "base_model.BaseModel.load_state_dict", "basicsr.utils.get_root_logger.info", "v.unsqueeze().repeat", "v.unsqueeze().repeat", "v.unsqueeze", "v.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.get_bare_model", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel._print_different_keys_loading"], ["", "def", "load_network_init_alldynamic", "(", "self", ",", "net", ",", "load_path", ",", "num_networks", ",", "strict", "=", "True", ",", "param_key", "=", "'params'", ")", ":", "\n", "        ", "\"\"\"Load network.\n\n        Args:\n            load_path (str): The path of networks to be loaded.\n            net (nn.Module): Network.\n            strict (bool): Whether strictly loaded.\n            param_key (str): The parameter key of loaded network. If set to\n                None, use the root 'path'.\n                Default: 'params'.\n        \"\"\"", "\n", "logger", "=", "get_root_logger", "(", ")", "\n", "net", "=", "self", ".", "get_bare_model", "(", "net", ")", "\n", "logger", ".", "info", "(", "f'Loading {net.__class__.__name__} model from {load_path}.'", ")", "\n", "load_net", "=", "torch", ".", "load", "(", "load_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "if", "param_key", "is", "not", "None", ":", "\n", "            ", "if", "param_key", "not", "in", "load_net", "and", "'params'", "in", "load_net", ":", "\n", "                ", "param_key", "=", "'params'", "\n", "logger", ".", "info", "(", "'Loading: params_ema does not exist, use params.'", ")", "\n", "", "load_net", "=", "load_net", "[", "param_key", "]", "\n", "", "load_net_repeated", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "load_net", ".", "items", "(", ")", ":", "\n", "            ", "if", "'weight'", "in", "k", ":", "\n", "                ", "load_net_repeated", "[", "k", "]", "=", "v", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "num_networks", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "", "elif", "'bias'", "in", "k", ":", "\n", "                ", "load_net_repeated", "[", "k", "]", "=", "v", ".", "unsqueeze", "(", "0", ")", ".", "repeat", "(", "num_networks", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "load_net_repeated", "[", "k", "]", "=", "v", "\n", "# # # remove unnecessary 'module.'", "\n", "# for k, v in deepcopy(load_net).items():", "\n", "#     if k.startswith('module.'):", "\n", "#         load_net[k[7:]] = v", "\n", "#         load_net.pop(k)", "\n", "", "", "self", ".", "_print_different_keys_loading", "(", "net", ",", "load_net_repeated", ",", "strict", ")", "\n", "net", ".", "load_state_dict", "(", "load_net_repeated", ",", "strict", "=", "strict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save_training_state": [[389, 422], ["os.path.join", "state[].append", "state[].append", "IOError", "o.state_dict", "s.state_dict", "torch.save", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warn", "time.sleep"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.save", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], ["", "@", "master_only", "\n", "def", "save_training_state", "(", "self", ",", "epoch", ",", "current_iter", ")", ":", "\n", "        ", "\"\"\"Save training states during training, which will be used for\n        resuming.\n\n        Args:\n            epoch (int): Current epoch.\n            current_iter (int): Current iteration.\n        \"\"\"", "\n", "if", "current_iter", "!=", "-", "1", ":", "\n", "            ", "state", "=", "{", "'epoch'", ":", "epoch", ",", "'iter'", ":", "current_iter", ",", "'optimizers'", ":", "[", "]", ",", "'schedulers'", ":", "[", "]", "}", "\n", "for", "o", "in", "self", ".", "optimizers", ":", "\n", "                ", "state", "[", "'optimizers'", "]", ".", "append", "(", "o", ".", "state_dict", "(", ")", ")", "\n", "", "for", "s", "in", "self", ".", "schedulers", ":", "\n", "                ", "state", "[", "'schedulers'", "]", ".", "append", "(", "s", ".", "state_dict", "(", ")", ")", "\n", "", "save_filename", "=", "f'{current_iter}.state'", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opt", "[", "'path'", "]", "[", "'training_states'", "]", ",", "save_filename", ")", "\n", "\n", "# avoid occasional writing errors", "\n", "retry", "=", "3", "\n", "while", "retry", ">", "0", ":", "\n", "                ", "try", ":", "\n", "                    ", "torch", ".", "save", "(", "state", ",", "save_path", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                    ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warn", "(", "f'Save training state error: {e}, remaining retry times: {retry - 1}'", ")", "\n", "time", ".", "sleep", "(", "1", ")", "\n", "", "else", ":", "\n", "                    ", "break", "\n", "", "finally", ":", "\n", "                    ", "retry", "-=", "1", "\n", "", "", "if", "retry", "==", "0", ":", "# still cannot save", "\n", "                ", "raise", "IOError", "(", "f'Cannot save {save_path}.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.resume_training": [[423, 437], ["enumerate", "enumerate", "len", "len", "len", "len", "base_model.BaseModel.optimizers[].load_state_dict", "base_model.BaseModel.schedulers[].load_state_dict"], "methods", ["None"], ["", "", "", "def", "resume_training", "(", "self", ",", "resume_state", ")", ":", "\n", "        ", "\"\"\"Reload the optimizers and schedulers for resumed training.\n\n        Args:\n            resume_state (dict): Resume state.\n        \"\"\"", "\n", "resume_optimizers", "=", "resume_state", "[", "'optimizers'", "]", "\n", "resume_schedulers", "=", "resume_state", "[", "'schedulers'", "]", "\n", "assert", "len", "(", "resume_optimizers", ")", "==", "len", "(", "self", ".", "optimizers", ")", ",", "'Wrong lengths of optimizers'", "\n", "assert", "len", "(", "resume_schedulers", ")", "==", "len", "(", "self", ".", "schedulers", ")", ",", "'Wrong lengths of schedulers'", "\n", "for", "i", ",", "o", "in", "enumerate", "(", "resume_optimizers", ")", ":", "\n", "            ", "self", ".", "optimizers", "[", "i", "]", ".", "load_state_dict", "(", "o", ")", "\n", "", "for", "i", ",", "s", "in", "enumerate", "(", "resume_schedulers", ")", ":", "\n", "            ", "self", ".", "schedulers", "[", "i", "]", ".", "load_state_dict", "(", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.reduce_loss_dict": [[438, 464], ["torch.no_grad", "collections.OrderedDict", "loss_dict.items", "loss_dict.items", "torch.stack", "torch.distributed.reduce", "value.mean().item", "keys.append", "torch.stack.append", "zip", "value.mean"], "methods", ["None"], ["", "", "def", "reduce_loss_dict", "(", "self", ",", "loss_dict", ")", ":", "\n", "        ", "\"\"\"reduce loss dict.\n\n        In distributed training, it averages the losses among different GPUs .\n\n        Args:\n            loss_dict (OrderedDict): Loss dict.\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "if", "self", ".", "opt", "[", "'dist'", "]", ":", "\n", "                ", "keys", "=", "[", "]", "\n", "losses", "=", "[", "]", "\n", "for", "name", ",", "value", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "                    ", "keys", ".", "append", "(", "name", ")", "\n", "losses", ".", "append", "(", "value", ")", "\n", "", "losses", "=", "torch", ".", "stack", "(", "losses", ",", "0", ")", "\n", "torch", ".", "distributed", ".", "reduce", "(", "losses", ",", "dst", "=", "0", ")", "\n", "if", "self", ".", "opt", "[", "'rank'", "]", "==", "0", ":", "\n", "                    ", "losses", "/=", "self", ".", "opt", "[", "'world_size'", "]", "\n", "", "loss_dict", "=", "{", "key", ":", "loss", "for", "key", ",", "loss", "in", "zip", "(", "keys", ",", "losses", ")", "}", "\n", "\n", "", "log_dict", "=", "OrderedDict", "(", ")", "\n", "for", "name", ",", "value", "in", "loss_dict", ".", "items", "(", ")", ":", "\n", "                ", "log_dict", "[", "name", "]", "=", "value", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n", "", "return", "log_dict", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrgan_model.RealESRGANModel.__init__": [[18, 23], ["basicsr.models.srgan_model.SRGANModel.__init__", "basicsr.utils.DiffJPEG().cuda", "basicsr.utils.USMSharp().cuda", "basicsr.utils.DiffJPEG", "basicsr.utils.USMSharp"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "RealESRGANModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "jpeger", "=", "DiffJPEG", "(", "differentiable", "=", "False", ")", ".", "cuda", "(", ")", "\n", "self", ".", "usm_sharpener", "=", "USMSharp", "(", ")", ".", "cuda", "(", ")", "\n", "self", ".", "queue_size", "=", "opt", "[", "'queue_size'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrgan_model.RealESRGANModel._dequeue_and_enqueue": [[24, 55], ["torch.no_grad", "realesrgan_model.RealESRGANModel.lq.size", "hasattr", "torch.zeros().cuda", "realesrgan_model.RealESRGANModel.gt.size", "torch.zeros().cuda", "torch.randperm", "realesrgan_model.RealESRGANModel.queue_lr[].clone", "realesrgan_model.RealESRGANModel.queue_gt[].clone", "realesrgan_model.RealESRGANModel.lq.clone", "realesrgan_model.RealESRGANModel.gt.clone", "realesrgan_model.RealESRGANModel.lq.clone", "realesrgan_model.RealESRGANModel.gt.clone", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_dequeue_and_enqueue", "(", "self", ")", ":", "\n", "# training pair pool", "\n", "# initialize", "\n", "        ", "b", ",", "c", ",", "h", ",", "w", "=", "self", ".", "lq", ".", "size", "(", ")", "\n", "if", "not", "hasattr", "(", "self", ",", "'queue_lr'", ")", ":", "\n", "            ", "assert", "self", ".", "queue_size", "%", "b", "==", "0", ",", "'queue size should be divisible by batch size'", "\n", "self", ".", "queue_lr", "=", "torch", ".", "zeros", "(", "self", ".", "queue_size", ",", "c", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "_", ",", "c", ",", "h", ",", "w", "=", "self", ".", "gt", ".", "size", "(", ")", "\n", "self", ".", "queue_gt", "=", "torch", ".", "zeros", "(", "self", ".", "queue_size", ",", "c", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "self", ".", "queue_ptr", "=", "0", "\n", "", "if", "self", ".", "queue_ptr", "==", "self", ".", "queue_size", ":", "# full", "\n", "# do dequeue and enqueue", "\n", "# shuffle", "\n", "            ", "idx", "=", "torch", ".", "randperm", "(", "self", ".", "queue_size", ")", "\n", "self", ".", "queue_lr", "=", "self", ".", "queue_lr", "[", "idx", "]", "\n", "self", ".", "queue_gt", "=", "self", ".", "queue_gt", "[", "idx", "]", "\n", "# get", "\n", "lq_dequeue", "=", "self", ".", "queue_lr", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", ".", "clone", "(", ")", "\n", "gt_dequeue", "=", "self", ".", "queue_gt", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", ".", "clone", "(", ")", "\n", "# update", "\n", "self", ".", "queue_lr", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "lq", ".", "clone", "(", ")", "\n", "self", ".", "queue_gt", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "\n", "self", ".", "lq", "=", "lq_dequeue", "\n", "self", ".", "gt", "=", "gt_dequeue", "\n", "", "else", ":", "\n", "# only do enqueue", "\n", "            ", "self", ".", "queue_lr", "[", "self", ".", "queue_ptr", ":", "self", ".", "queue_ptr", "+", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "lq", ".", "clone", "(", ")", "\n", "self", ".", "queue_gt", "[", "self", ".", "queue_ptr", ":", "self", ".", "queue_ptr", "+", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "self", ".", "queue_ptr", "=", "self", ".", "queue_ptr", "+", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrgan_model.RealESRGANModel.feed_data": [[56, 169], ["torch.no_grad", "data[].to", "realesrgan_model.RealESRGANModel.usm_sharpener", "data[].to", "data[].to", "data[].to", "basicsr.utils.img_process_util.filter2D", "random.choice", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "realesrgan_model.RealESRGANModel.jpeger", "random.choice", "torch.nn.functional.interpolate", "basicsr.data.transforms.paired_random_crop", "realesrgan_model.RealESRGANModel._dequeue_and_enqueue", "realesrgan_model.RealESRGANModel.usm_sharpener", "data[].to", "realesrgan_model.RealESRGANModel.gt.size", "random.choices", "numpy.random.uniform", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D", "random.choices", "numpy.random.uniform", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "numpy.random.uniform", "random.choice", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "realesrgan_model.RealESRGANModel.jpeger", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "realesrgan_model.RealESRGANModel.jpeger", "random.choice", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "torch.clamp", "data[].to", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D.new_zeros", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D.size", "int", "int", "basicsr.utils.img_process_util.filter2D.new_zeros", "basicsr.utils.img_process_util.filter2D.new_zeros", "basicsr.utils.img_process_util.filter2D.size", "basicsr.utils.img_process_util.filter2D.size"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop", "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel._dequeue_and_enqueue", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "feed_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "if", "self", ".", "is_train", ":", "\n", "# training data synthesis", "\n", "            ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "gt_usm", "=", "self", ".", "usm_sharpener", "(", "self", ".", "gt", ")", "\n", "\n", "self", ".", "kernel1", "=", "data", "[", "'kernel1'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "kernel2", "=", "data", "[", "'kernel2'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "sinc_kernel", "=", "data", "[", "'sinc_kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "self", ".", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# ----------------------- The first degradation process ----------------------- #", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "self", ".", "gt_usm", ",", "self", ".", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "# noise", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob'", "]", ":", "\n", "                ", "out", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "\n", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range'", "]", ",", "\n", "gray_prob", "=", "gray_noise_prob", ",", "\n", "clip", "=", "True", ",", "\n", "rounds", "=", "False", ")", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range'", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "\n", "# ----------------------- The second degradation process ----------------------- #", "\n", "# blur", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'second_blur_prob'", "]", ":", "\n", "                ", "out", "=", "filter2D", "(", "out", ",", "self", ".", "kernel2", ")", "\n", "# random resize", "\n", "", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob2'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "\n", "out", ",", "size", "=", "(", "int", "(", "ori_h", "/", "self", ".", "opt", "[", "'scale'", "]", "*", "scale", ")", ",", "int", "(", "ori_w", "/", "self", ".", "opt", "[", "'scale'", "]", "*", "scale", ")", ")", ",", "mode", "=", "mode", ")", "\n", "# noise", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob2'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob2'", "]", ":", "\n", "                ", "out", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range2'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "\n", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", ",", "\n", "gray_prob", "=", "gray_noise_prob", ",", "\n", "clip", "=", "True", ",", "\n", "rounds", "=", "False", ")", "\n", "\n", "# JPEG compression + the final sinc filter", "\n", "# We also need to resize images to desired sizes. We group [resize back + sinc filter] together", "\n", "# as one operation.", "\n", "# We consider two orders:", "\n", "#   1. [resize back + sinc filter] + JPEG compression", "\n", "#   2. JPEG compression + [resize back + sinc filter]", "\n", "# Empirically, we find other combinations (sinc + JPEG + Resize) will introduce twisted lines.", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "# resize back + the final sinc filter", "\n", "                ", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "self", ".", "sinc_kernel", ")", "\n", "# JPEG compression", "\n", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range2'", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "", "else", ":", "\n", "# JPEG compression", "\n", "                ", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range2'", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "# resize back + the final sinc filter", "\n", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "self", ".", "sinc_kernel", ")", "\n", "\n", "# clamp and round", "\n", "", "self", ".", "lq", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "# random crop", "\n", "gt_size", "=", "self", ".", "opt", "[", "'gt_size'", "]", "\n", "(", "self", ".", "gt", ",", "self", ".", "gt_usm", ")", ",", "self", ".", "lq", "=", "paired_random_crop", "(", "[", "self", ".", "gt", ",", "self", ".", "gt_usm", "]", ",", "self", ".", "lq", ",", "gt_size", ",", "\n", "self", ".", "opt", "[", "'scale'", "]", ")", "\n", "\n", "# training pair pool", "\n", "self", ".", "_dequeue_and_enqueue", "(", ")", "\n", "# sharpen self.gt again, as we have changed the self.gt with self._dequeue_and_enqueue", "\n", "self", ".", "gt_usm", "=", "self", ".", "usm_sharpener", "(", "self", ".", "gt", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "lq", "=", "data", "[", "'lq'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'gt'", "in", "data", ":", "\n", "                ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrgan_model.RealESRGANModel.nondist_validation": [[170, 175], ["super().nondist_validation"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation"], ["", "", "", "def", "nondist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "# do not use the synthetic process during validation", "\n", "        ", "self", ".", "is_train", "=", "False", "\n", "super", "(", "RealESRGANModel", ",", "self", ")", ".", "nondist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "self", ".", "is_train", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrgan_model.RealESRGANModel.optimize_parameters": [[176, 243], ["realesrgan_model.RealESRGANModel.net_d.parameters", "realesrgan_model.RealESRGANModel.optimizer_g.zero_grad", "realesrgan_model.RealESRGANModel.net_g", "collections.OrderedDict", "realesrgan_model.RealESRGANModel.net_d.parameters", "realesrgan_model.RealESRGANModel.optimizer_d.zero_grad", "realesrgan_model.RealESRGANModel.net_d", "realesrgan_model.RealESRGANModel.cri_gan", "torch.mean", "realesrgan_model.RealESRGANModel.backward", "realesrgan_model.RealESRGANModel.net_d", "realesrgan_model.RealESRGANModel.cri_gan", "torch.mean", "realesrgan_model.RealESRGANModel.backward", "realesrgan_model.RealESRGANModel.optimizer_d.step", "realesrgan_model.RealESRGANModel.reduce_loss_dict", "realesrgan_model.RealESRGANModel.net_d", "realesrgan_model.RealESRGANModel.cri_gan", "l_g_total.backward", "realesrgan_model.RealESRGANModel.optimizer_g.step", "realesrgan_model.RealESRGANModel.detach", "realesrgan_model.RealESRGANModel.output.detach().clone", "realesrgan_model.RealESRGANModel.detach", "realesrgan_model.RealESRGANModel.model_ema", "realesrgan_model.RealESRGANModel.cri_pix", "realesrgan_model.RealESRGANModel.cri_perceptual", "realesrgan_model.RealESRGANModel.output.detach"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.reduce_loss_dict", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.model_ema"], ["", "def", "optimize_parameters", "(", "self", ",", "current_iter", ")", ":", "\n", "        ", "l1_gt", "=", "self", ".", "gt_usm", "\n", "percep_gt", "=", "self", ".", "gt_usm", "\n", "gan_gt", "=", "self", ".", "gt_usm", "\n", "if", "self", ".", "opt", "[", "'l1_gt_usm'", "]", "is", "False", ":", "\n", "            ", "l1_gt", "=", "self", ".", "gt", "\n", "", "if", "self", ".", "opt", "[", "'percep_gt_usm'", "]", "is", "False", ":", "\n", "            ", "percep_gt", "=", "self", ".", "gt", "\n", "", "if", "self", ".", "opt", "[", "'gan_gt_usm'", "]", "is", "False", ":", "\n", "            ", "gan_gt", "=", "self", ".", "gt", "\n", "\n", "# optimize net_g", "\n", "", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "optimizer_g", ".", "zero_grad", "(", ")", "\n", "self", ".", "output", "=", "self", ".", "net_g", "(", "self", ".", "lq", ")", "\n", "\n", "l_g_total", "=", "0", "\n", "loss_dict", "=", "OrderedDict", "(", ")", "\n", "if", "(", "current_iter", "%", "self", ".", "net_d_iters", "==", "0", "and", "current_iter", ">", "self", ".", "net_d_init_iters", ")", ":", "\n", "# pixel loss", "\n", "            ", "if", "self", ".", "cri_pix", ":", "\n", "                ", "l_g_pix", "=", "self", ".", "cri_pix", "(", "self", ".", "output", ",", "l1_gt", ")", "\n", "l_g_total", "+=", "l_g_pix", "\n", "loss_dict", "[", "'l_g_pix'", "]", "=", "l_g_pix", "\n", "# perceptual loss", "\n", "", "if", "self", ".", "cri_perceptual", ":", "\n", "                ", "l_g_percep", ",", "l_g_style", "=", "self", ".", "cri_perceptual", "(", "self", ".", "output", ",", "percep_gt", ")", "\n", "if", "l_g_percep", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_g_percep", "\n", "loss_dict", "[", "'l_g_percep'", "]", "=", "l_g_percep", "\n", "", "if", "l_g_style", "is", "not", "None", ":", "\n", "                    ", "l_g_total", "+=", "l_g_style", "\n", "loss_dict", "[", "'l_g_style'", "]", "=", "l_g_style", "\n", "# gan loss", "\n", "", "", "fake_g_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ")", "\n", "l_g_gan", "=", "self", ".", "cri_gan", "(", "fake_g_pred", ",", "True", ",", "is_disc", "=", "False", ")", "\n", "l_g_total", "+=", "l_g_gan", "\n", "loss_dict", "[", "'l_g_gan'", "]", "=", "l_g_gan", "\n", "\n", "l_g_total", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_g", ".", "step", "(", ")", "\n", "\n", "# optimize net_d", "\n", "", "for", "p", "in", "self", ".", "net_d", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "self", ".", "optimizer_d", ".", "zero_grad", "(", ")", "\n", "# real", "\n", "real_d_pred", "=", "self", ".", "net_d", "(", "gan_gt", ")", "\n", "l_d_real", "=", "self", ".", "cri_gan", "(", "real_d_pred", ",", "True", ",", "is_disc", "=", "True", ")", "\n", "loss_dict", "[", "'l_d_real'", "]", "=", "l_d_real", "\n", "loss_dict", "[", "'out_d_real'", "]", "=", "torch", ".", "mean", "(", "real_d_pred", ".", "detach", "(", ")", ")", "\n", "l_d_real", ".", "backward", "(", ")", "\n", "# fake", "\n", "fake_d_pred", "=", "self", ".", "net_d", "(", "self", ".", "output", ".", "detach", "(", ")", ".", "clone", "(", ")", ")", "# clone for pt1.9", "\n", "l_d_fake", "=", "self", ".", "cri_gan", "(", "fake_d_pred", ",", "False", ",", "is_disc", "=", "True", ")", "\n", "loss_dict", "[", "'l_d_fake'", "]", "=", "l_d_fake", "\n", "loss_dict", "[", "'out_d_fake'", "]", "=", "torch", ".", "mean", "(", "fake_d_pred", ".", "detach", "(", ")", ")", "\n", "l_d_fake", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_d", ".", "step", "(", ")", "\n", "\n", "if", "self", ".", "ema_decay", ">", "0", ":", "\n", "            ", "self", ".", "model_ema", "(", "decay", "=", "self", ".", "ema_decay", ")", "\n", "\n", "", "self", ".", "log_dict", "=", "self", ".", "reduce_loss_dict", "(", "loss_dict", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrnet_model.RealESRNetModel.__init__": [[17, 22], ["basicsr.models.sr_model.SRModel.__init__", "basicsr.utils.DiffJPEG().cuda", "basicsr.utils.USMSharp().cuda", "basicsr.utils.DiffJPEG", "basicsr.utils.USMSharp"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "RealESRNetModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "jpeger", "=", "DiffJPEG", "(", "differentiable", "=", "False", ")", ".", "cuda", "(", ")", "\n", "self", ".", "usm_sharpener", "=", "USMSharp", "(", ")", ".", "cuda", "(", ")", "\n", "self", ".", "queue_size", "=", "opt", "[", "'queue_size'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrnet_model.RealESRNetModel._dequeue_and_enqueue": [[23, 54], ["torch.no_grad", "realesrnet_model.RealESRNetModel.lq.size", "hasattr", "torch.zeros().cuda", "realesrnet_model.RealESRNetModel.gt.size", "torch.zeros().cuda", "torch.randperm", "realesrnet_model.RealESRNetModel.queue_lr[].clone", "realesrnet_model.RealESRNetModel.queue_gt[].clone", "realesrnet_model.RealESRNetModel.lq.clone", "realesrnet_model.RealESRNetModel.gt.clone", "realesrnet_model.RealESRNetModel.lq.clone", "realesrnet_model.RealESRNetModel.gt.clone", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_dequeue_and_enqueue", "(", "self", ")", ":", "\n", "# training pair pool", "\n", "# initialize", "\n", "        ", "b", ",", "c", ",", "h", ",", "w", "=", "self", ".", "lq", ".", "size", "(", ")", "\n", "if", "not", "hasattr", "(", "self", ",", "'queue_lr'", ")", ":", "\n", "            ", "assert", "self", ".", "queue_size", "%", "b", "==", "0", ",", "'queue size should be divisible by batch size'", "\n", "self", ".", "queue_lr", "=", "torch", ".", "zeros", "(", "self", ".", "queue_size", ",", "c", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "_", ",", "c", ",", "h", ",", "w", "=", "self", ".", "gt", ".", "size", "(", ")", "\n", "self", ".", "queue_gt", "=", "torch", ".", "zeros", "(", "self", ".", "queue_size", ",", "c", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "self", ".", "queue_ptr", "=", "0", "\n", "", "if", "self", ".", "queue_ptr", "==", "self", ".", "queue_size", ":", "# full", "\n", "# do dequeue and enqueue", "\n", "# shuffle", "\n", "            ", "idx", "=", "torch", ".", "randperm", "(", "self", ".", "queue_size", ")", "\n", "self", ".", "queue_lr", "=", "self", ".", "queue_lr", "[", "idx", "]", "\n", "self", ".", "queue_gt", "=", "self", ".", "queue_gt", "[", "idx", "]", "\n", "# get", "\n", "lq_dequeue", "=", "self", ".", "queue_lr", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", ".", "clone", "(", ")", "\n", "gt_dequeue", "=", "self", ".", "queue_gt", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", ".", "clone", "(", ")", "\n", "# update", "\n", "self", ".", "queue_lr", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "lq", ".", "clone", "(", ")", "\n", "self", ".", "queue_gt", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "\n", "self", ".", "lq", "=", "lq_dequeue", "\n", "self", ".", "gt", "=", "gt_dequeue", "\n", "", "else", ":", "\n", "# only do enqueue", "\n", "            ", "self", ".", "queue_lr", "[", "self", ".", "queue_ptr", ":", "self", ".", "queue_ptr", "+", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "lq", ".", "clone", "(", ")", "\n", "self", ".", "queue_gt", "[", "self", ".", "queue_ptr", ":", "self", ".", "queue_ptr", "+", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "self", ".", "queue_ptr", "=", "self", ".", "queue_ptr", "+", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrnet_model.RealESRNetModel.feed_data": [[55, 167], ["torch.no_grad", "data[].to", "data[].to", "data[].to", "data[].to", "basicsr.utils.img_process_util.filter2D", "random.choice", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "realesrnet_model.RealESRNetModel.jpeger", "random.choice", "torch.nn.functional.interpolate", "basicsr.data.transforms.paired_random_crop", "realesrnet_model.RealESRNetModel._dequeue_and_enqueue", "data[].to", "realesrnet_model.RealESRNetModel.usm_sharpener", "realesrnet_model.RealESRNetModel.gt.size", "random.choices", "numpy.random.uniform", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D", "random.choices", "numpy.random.uniform", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "numpy.random.uniform", "random.choice", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "realesrnet_model.RealESRNetModel.jpeger", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "realesrnet_model.RealESRNetModel.jpeger", "random.choice", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "torch.clamp", "data[].to", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D.new_zeros", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D.size", "int", "int", "basicsr.utils.img_process_util.filter2D.new_zeros", "basicsr.utils.img_process_util.filter2D.new_zeros", "basicsr.utils.img_process_util.filter2D.size", "basicsr.utils.img_process_util.filter2D.size"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop", "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel._dequeue_and_enqueue", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "feed_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "if", "self", ".", "is_train", ":", "\n", "# training data synthesis", "\n", "            ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "# USM the GT images", "\n", "if", "self", ".", "opt", "[", "'gt_usm'", "]", "is", "True", ":", "\n", "                ", "self", ".", "gt", "=", "self", ".", "usm_sharpener", "(", "self", ".", "gt", ")", "\n", "\n", "", "self", ".", "kernel1", "=", "data", "[", "'kernel1'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "kernel2", "=", "data", "[", "'kernel2'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "sinc_kernel", "=", "data", "[", "'sinc_kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "self", ".", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# ----------------------- The first degradation process ----------------------- #", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "self", ".", "gt", ",", "self", ".", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "# noise", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob'", "]", ":", "\n", "                ", "out", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "\n", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range'", "]", ",", "\n", "gray_prob", "=", "gray_noise_prob", ",", "\n", "clip", "=", "True", ",", "\n", "rounds", "=", "False", ")", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range'", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "\n", "# ----------------------- The second degradation process ----------------------- #", "\n", "# blur", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'second_blur_prob'", "]", ":", "\n", "                ", "out", "=", "filter2D", "(", "out", ",", "self", ".", "kernel2", ")", "\n", "# random resize", "\n", "", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob2'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "\n", "out", ",", "size", "=", "(", "int", "(", "ori_h", "/", "self", ".", "opt", "[", "'scale'", "]", "*", "scale", ")", ",", "int", "(", "ori_w", "/", "self", ".", "opt", "[", "'scale'", "]", "*", "scale", ")", ")", ",", "mode", "=", "mode", ")", "\n", "# noise", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob2'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob2'", "]", ":", "\n", "                ", "out", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range2'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                ", "out", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "\n", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", ",", "\n", "gray_prob", "=", "gray_noise_prob", ",", "\n", "clip", "=", "True", ",", "\n", "rounds", "=", "False", ")", "\n", "\n", "# JPEG compression + the final sinc filter", "\n", "# We also need to resize images to desired sizes. We group [resize back + sinc filter] together", "\n", "# as one operation.", "\n", "# We consider two orders:", "\n", "#   1. [resize back + sinc filter] + JPEG compression", "\n", "#   2. JPEG compression + [resize back + sinc filter]", "\n", "# Empirically, we find other combinations (sinc + JPEG + Resize) will introduce twisted lines.", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "# resize back + the final sinc filter", "\n", "                ", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "self", ".", "sinc_kernel", ")", "\n", "# JPEG compression", "\n", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range2'", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "", "else", ":", "\n", "# JPEG compression", "\n", "                ", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range2'", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "# resize back + the final sinc filter", "\n", "mode", "=", "random", ".", "choice", "(", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "self", ".", "sinc_kernel", ")", "\n", "\n", "# clamp and round", "\n", "", "self", ".", "lq", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "# random crop", "\n", "gt_size", "=", "self", ".", "opt", "[", "'gt_size'", "]", "\n", "self", ".", "gt", ",", "self", ".", "lq", "=", "paired_random_crop", "(", "self", ".", "gt", ",", "self", ".", "lq", ",", "gt_size", ",", "self", ".", "opt", "[", "'scale'", "]", ")", "\n", "\n", "# training pair pool", "\n", "self", ".", "_dequeue_and_enqueue", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "lq", "=", "data", "[", "'lq'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'gt'", "in", "data", ":", "\n", "                ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.realesrnet_model.RealESRNetModel.nondist_validation": [[168, 173], ["super().nondist_validation"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation"], ["", "", "", "def", "nondist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "# do not use the synthetic process during validation", "\n", "        ", "self", ".", "is_train", "=", "False", "\n", "super", "(", "RealESRNetModel", ",", "self", ")", ".", "nondist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "self", ".", "is_train", "=", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.__init__": [[19, 36], ["basicsr.models.srgan_dynamic_model.SRGANDynamicModel.__init__", "basicsr.utils.DiffJPEG().cuda", "basicsr.utils.USMSharp().cuda", "basicsr.utils.DiffJPEG", "basicsr.utils.USMSharp"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "DASRModel", ",", "self", ")", ".", "__init__", "(", "opt", ")", "\n", "self", ".", "jpeger", "=", "DiffJPEG", "(", "differentiable", "=", "False", ")", ".", "cuda", "(", ")", "\n", "self", ".", "usm_sharpener", "=", "USMSharp", "(", ")", ".", "cuda", "(", ")", "\n", "self", ".", "queue_size", "=", "opt", "[", "'queue_size'", "]", "\n", "self", ".", "resize_mode_list", "=", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", "\n", "self", ".", "opt_train", "=", "opt", "[", "'datasets'", "]", "[", "'train'", "]", "\n", "num_degradation_params", "=", "4", "*", "2", "+", "2", "# kernel", "\n", "num_degradation_params", "+=", "4", "*", "2", "# resize", "\n", "num_degradation_params", "+=", "4", "*", "2", "# noise", "\n", "num_degradation_params", "+=", "3", "+", "2", "+", "2", "# jpeg", "\n", "self", ".", "num_degradation_params", "=", "num_degradation_params", "\n", "self", ".", "road_map", "=", "[", "0", ",", "\n", "10", ",", "\n", "10", "+", "8", ",", "\n", "10", "+", "8", "+", "8", ",", "\n", "10", "+", "8", "+", "8", "+", "7", "]", "\n", "# [0, 10, 18, 26, 33]", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel._dequeue_and_enqueue": [[38, 69], ["torch.no_grad", "DASR_model.DASRModel.lq.size", "hasattr", "torch.zeros().cuda", "DASR_model.DASRModel.gt.size", "torch.zeros().cuda", "torch.randperm", "DASR_model.DASRModel.queue_lr[].clone", "DASR_model.DASRModel.queue_gt[].clone", "DASR_model.DASRModel.lq.clone", "DASR_model.DASRModel.gt.clone", "DASR_model.DASRModel.lq.clone", "DASR_model.DASRModel.gt.clone", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "_dequeue_and_enqueue", "(", "self", ")", ":", "\n", "# training pair pool", "\n", "# initialize", "\n", "        ", "b", ",", "c", ",", "h", ",", "w", "=", "self", ".", "lq", ".", "size", "(", ")", "\n", "if", "not", "hasattr", "(", "self", ",", "'queue_lr'", ")", ":", "\n", "            ", "assert", "self", ".", "queue_size", "%", "b", "==", "0", ",", "'queue size should be divisible by batch size'", "\n", "self", ".", "queue_lr", "=", "torch", ".", "zeros", "(", "self", ".", "queue_size", ",", "c", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "_", ",", "c", ",", "h", ",", "w", "=", "self", ".", "gt", ".", "size", "(", ")", "\n", "self", ".", "queue_gt", "=", "torch", ".", "zeros", "(", "self", ".", "queue_size", ",", "c", ",", "h", ",", "w", ")", ".", "cuda", "(", ")", "\n", "self", ".", "queue_ptr", "=", "0", "\n", "", "if", "self", ".", "queue_ptr", "==", "self", ".", "queue_size", ":", "# full", "\n", "# do dequeue and enqueue", "\n", "# shuffle", "\n", "            ", "idx", "=", "torch", ".", "randperm", "(", "self", ".", "queue_size", ")", "\n", "self", ".", "queue_lr", "=", "self", ".", "queue_lr", "[", "idx", "]", "\n", "self", ".", "queue_gt", "=", "self", ".", "queue_gt", "[", "idx", "]", "\n", "# get", "\n", "lq_dequeue", "=", "self", ".", "queue_lr", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", ".", "clone", "(", ")", "\n", "gt_dequeue", "=", "self", ".", "queue_gt", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", ".", "clone", "(", ")", "\n", "# update", "\n", "self", ".", "queue_lr", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "lq", ".", "clone", "(", ")", "\n", "self", ".", "queue_gt", "[", "0", ":", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "\n", "self", ".", "lq", "=", "lq_dequeue", "\n", "self", ".", "gt", "=", "gt_dequeue", "\n", "", "else", ":", "\n", "# only do enqueue", "\n", "            ", "self", ".", "queue_lr", "[", "self", ".", "queue_ptr", ":", "self", ".", "queue_ptr", "+", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "lq", ".", "clone", "(", ")", "\n", "self", ".", "queue_gt", "[", "self", ".", "queue_ptr", ":", "self", ".", "queue_ptr", "+", "b", ",", ":", ",", ":", ",", ":", "]", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "self", ".", "queue_ptr", "=", "self", ".", "queue_ptr", "+", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.update_temperature": [[70, 73], ["torch.no_grad", "DASR_model.DASRModel.net_p.module.update_temperature"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.update_temperature"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "update_temperature", "(", "self", ")", ":", "\n", "        ", "self", ".", "net_p", ".", "module", ".", "update_temperature", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.feed_data": [[74, 418], ["torch.no_grad", "data[].to", "DASR_model.DASRModel.usm_sharpener", "DASR_model.DASRModel.gt.clone", "DASR_model.DASRModel._dequeue_and_enqueue", "data[].to", "random.choices", "torch.zeros", "[].to", "[].to", "[].to", "basicsr.utils.img_process_util.filter2D", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.zeros.expand", "torch.nn.functional.interpolate.new_zeros().uniform_", "torch.clamp", "DASR_model.DASRModel.jpeger", "normalized_jpeg_p.unsqueeze", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.zeros.expand", "DASR_model.DASRModel.degradation_params.to", "basicsr.data.transforms.paired_random_crop_return_indexes", "data[].to", "DASR_model.DASRModel.gt.size", "random.choices", "numpy.random.uniform", "len", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_poisson_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_gaussian_noise_pt", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D", "torch.tensor().expand", "random.choices", "numpy.random.uniform", "len", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_poisson_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_gaussian_noise_pt", "numpy.random.uniform", "random.choice", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "torch.nn.functional.interpolate.new_zeros().uniform_", "torch.clamp", "DASR_model.DASRModel.jpeger", "normalized_jpeg_p.unsqueeze", "torch.tensor().expand", "torch.zeros.expand", "torch.nn.functional.interpolate.new_zeros().uniform_", "torch.clamp", "DASR_model.DASRModel.jpeger", "random.choice", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "normalized_jpeg_p.unsqueeze", "torch.tensor().expand", "torch.zeros.expand", "torch.clamp", "torch.zeros", "[].to", "basicsr.utils.img_process_util.filter2D", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.zeros.expand", "torch.nn.functional.interpolate.new_zeros().uniform_", "torch.clamp", "DASR_model.DASRModel.jpeger", "normalized_jpeg_p.unsqueeze", "random.choice", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "torch.zeros.expand", "DASR_model.DASRModel.degradation_params.to", "basicsr.data.transforms.paired_random_crop_return_indexes", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "numpy.random.uniform", "torch.tensor", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "torch.nn.functional.interpolate.new_zeros", "DASR_model.DASRModel.gt.size", "numpy.random.uniform", "torch.tensor", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "len", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "DASR_model.DASRModel.gt.size", "random.choices", "numpy.random.uniform", "len", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_poisson_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_gaussian_noise_pt", "len", "DASR_model.DASRModel.gt.size", "len", "torch.clamp", "torch.zeros", "[].to", "basicsr.utils.img_process_util.filter2D", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.zeros.expand", "torch.nn.functional.interpolate.new_zeros().uniform_", "torch.clamp", "DASR_model.DASRModel.jpeger", "normalized_jpeg_p.unsqueeze", "random.choice", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "torch.zeros.expand", "DASR_model.DASRModel.degradation_params.to", "basicsr.data.transforms.paired_random_crop_return_indexes", "print", "torch.tensor", "torch.tensor", "torch.nn.functional.interpolate.size", "torch.tensor", "int", "int", "torch.tensor", "torch.tensor", "torch.nn.functional.interpolate.new_zeros", "torch.tensor", "torch.nn.functional.interpolate.new_zeros", "torch.tensor", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "numpy.random.uniform", "torch.tensor", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "torch.nn.functional.interpolate.new_zeros", "DASR_model.DASRModel.gt.size", "random.choices", "numpy.random.uniform", "len", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_poisson_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "basicsr.data.degradations.only_generate_gaussian_noise_pt", "len", "DASR_model.DASRModel.gt.size", "len", "torch.clamp", "torch.nn.functional.interpolate.size", "torch.nn.functional.interpolate.size", "torch.tensor", "torch.tensor", "torch.nn.functional.interpolate.size", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "numpy.random.uniform", "torch.tensor", "DASR_model.DASRModel.gt.size", "DASR_model.DASRModel.gt.size", "torch.nn.functional.interpolate.new_zeros", "torch.tensor", "torch.tensor", "torch.nn.functional.interpolate.size"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel._dequeue_and_enqueue", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop_return_indexes", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop_return_indexes", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop_return_indexes", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "feed_data", "(", "self", ",", "data_all", ")", ":", "\n", "        ", "if", "self", ".", "is_train", ":", "\n", "# training data synthesis", "\n", "            ", "self", ".", "degradation_degree", "=", "random", ".", "choices", "(", "self", ".", "opt", "[", "'degree_list'", "]", ",", "self", ".", "opt", "[", "'degree_prob'", "]", ")", "[", "0", "]", "\n", "data", "=", "data_all", "[", "self", ".", "degradation_degree", "]", "\n", "# data = data_all", "\n", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "gt", "=", "self", ".", "usm_sharpener", "(", "self", ".", "gt", ")", "\n", "\n", "self", ".", "gt_for_cycle", "=", "self", ".", "gt", ".", "clone", "(", ")", "\n", "\n", "if", "self", ".", "degradation_degree", "==", "'severe_degrade_two_stage'", ":", "\n", "\n", "                ", "self", ".", "degradation_params", "=", "torch", ".", "zeros", "(", "self", ".", "opt_train", "[", "'batch_size_per_gpu'", "]", ",", "self", ".", "num_degradation_params", ")", "# [B, 33]", "\n", "\n", "self", ".", "kernel1", "=", "data", "[", "'kernel1'", "]", "[", "'kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "kernel2", "=", "data", "[", "'kernel2'", "]", "[", "'kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "sinc_kernel", "=", "data", "[", "'sinc_kernel'", "]", "[", "'kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "kernel_size_range1", "=", "[", "self", ".", "opt_train", "[", "'blur_kernel_size_minimum'", "]", ",", "self", ".", "opt_train", "[", "'blur_kernel_size'", "]", "]", "\n", "kernel_size_range2", "=", "[", "self", ".", "opt_train", "[", "'blur_kernel_size2_minimum'", "]", ",", "self", ".", "opt_train", "[", "'blur_kernel_size2'", "]", "]", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", "\n", "omega_c_range", "=", "[", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", "]", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", ":", "self", ".", "road_map", "[", "0", "]", "+", "1", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'kernel_size'", "]", ".", "unsqueeze", "(", "1", ")", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "4", ":", "self", ".", "road_map", "[", "0", "]", "+", "5", "]", "=", "(", "data", "[", "'kernel2'", "]", "[", "'kernel_size'", "]", ".", "unsqueeze", "(", "1", ")", "-", "kernel_size_range2", "[", "0", "]", ")", "/", "(", "kernel_size_range2", "[", "1", "]", "-", "kernel_size_range2", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "1", ":", "self", ".", "road_map", "[", "0", "]", "+", "2", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'sigma_x'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "5", ":", "self", ".", "road_map", "[", "0", "]", "+", "6", "]", "=", "(", "data", "[", "'kernel2'", "]", "[", "'sigma_x'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma2'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma2'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "2", ":", "self", ".", "road_map", "[", "0", "]", "+", "3", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'sigma_y'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "6", ":", "self", ".", "road_map", "[", "0", "]", "+", "7", "]", "=", "(", "data", "[", "'kernel2'", "]", "[", "'sigma_y'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma2'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma2'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "3", ":", "self", ".", "road_map", "[", "0", "]", "+", "4", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'rotation'", "]", ".", "unsqueeze", "(", "1", ")", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "7", ":", "self", ".", "road_map", "[", "0", "]", "+", "8", "]", "=", "(", "data", "[", "'kernel2'", "]", "[", "'rotation'", "]", ".", "unsqueeze", "(", "1", ")", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "8", ":", "self", ".", "road_map", "[", "0", "]", "+", "9", "]", "=", "(", "data", "[", "'sinc_kernel'", "]", "[", "'kernel_size'", "]", ".", "unsqueeze", "(", "1", ")", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "9", ":", "self", ".", "road_map", "[", "1", "]", "]", "=", "(", "data", "[", "'sinc_kernel'", "]", "[", "'omega_c'", "]", ".", "unsqueeze", "(", "1", ")", "-", "omega_c_range", "[", "0", "]", ")", "/", "(", "omega_c_range", "[", "1", "]", "-", "omega_c_range", "[", "0", "]", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "self", ".", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# ----------------------- The first degradation process ----------------------- #", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "self", ".", "gt", ",", "self", ".", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                    ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'resize_range'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'resize_range'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'resize_range'", "]", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                    ", "if", "mode_current", "==", "mode", ":", "\n", "                        ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", ":", "self", ".", "road_map", "[", "1", "]", "+", "1", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", "+", "1", ":", "self", ".", "road_map", "[", "1", "]", "+", "4", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "# noise # noise_range: [1, 30] poisson_scale_range: [0.05, 3]", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob'", "]", ":", "\n", "                    ", "sigma", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_g_first", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "normalized_sigma", "=", "(", "sigma", "-", "self", ".", "opt", "[", "'noise_range'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'noise_range'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'noise_range'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", ":", "self", ".", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "1", ":", "self", ".", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "2", ":", "self", ".", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_p_first", "=", "only_generate_poisson_noise_pt", "(", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                    ", "scale", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_p_first", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range'", "]", ",", "gray_prob", "=", "gray_noise_prob", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'poisson_scale_range'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'poisson_scale_range'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'poisson_scale_range'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", ":", "self", ".", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "1", ":", "self", ".", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "2", ":", "self", ".", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_g_first", "=", "only_generate_gaussian_noise_pt", "(", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range'", "]", ")", "# tensor([61.6463, 94.2723, 37.1205, 34.9564], device='cuda:0')]", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "self", ".", "opt", "[", "'jpeg_range'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'jpeg_range'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'jpeg_range'", "]", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", ":", "self", ".", "road_map", "[", "3", "]", "+", "1", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# ----------------------- The second degradation process ----------------------- #", "\n", "# blur", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'second_blur_prob'", "]", ":", "\n", "                    ", "out", "=", "filter2D", "(", "out", ",", "self", ".", "kernel2", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", "-", "1", ":", "self", ".", "road_map", "[", "1", "]", "]", "=", "torch", ".", "tensor", "(", "[", "1", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "# random resize", "\n", "", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob2'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                    ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "int", "(", "ori_h", "/", "self", ".", "opt", "[", "'scale'", "]", "*", "scale", ")", ",", "int", "(", "ori_w", "/", "self", ".", "opt", "[", "'scale'", "]", "*", "scale", ")", ")", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'resize_range2'", "]", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                    ", "if", "mode_current", "==", "mode", ":", "\n", "                        ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", "+", "4", ":", "self", ".", "road_map", "[", "1", "]", "+", "5", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", "+", "5", ":", "self", ".", "road_map", "[", "2", "]", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "# noise", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob2'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob2'", "]", ":", "\n", "                    ", "sigma", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_g_second", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range2'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "normalized_sigma", "=", "(", "sigma", "-", "self", ".", "opt", "[", "'noise_range2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'noise_range2'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'noise_range2'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "4", ":", "self", ".", "road_map", "[", "2", "]", "+", "5", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "5", ":", "self", ".", "road_map", "[", "2", "]", "+", "6", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "6", ":", "self", ".", "road_map", "[", "3", "]", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_p_second", "=", "only_generate_poisson_noise_pt", "(", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                    ", "scale", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_p_second", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "\n", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", ",", "\n", "gray_prob", "=", "gray_noise_prob", ",", "\n", "clip", "=", "True", ",", "\n", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'poisson_scale_range2'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "4", ":", "self", ".", "road_map", "[", "2", "]", "+", "5", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "5", ":", "self", ".", "road_map", "[", "2", "]", "+", "6", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "6", ":", "self", ".", "road_map", "[", "3", "]", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_g_second", "=", "only_generate_gaussian_noise_pt", "(", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range2'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "# JPEG compression + the final sinc filter", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "# resize back + the final sinc filter", "\n", "                    ", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                        ", "if", "mode_current", "==", "mode", ":", "\n", "                            ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "self", ".", "sinc_kernel", ")", "\n", "# JPEG compression", "\n", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range2'", "]", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "self", ".", "opt", "[", "'jpeg_range2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'jpeg_range2'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'jpeg_range2'", "]", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "1", ":", "self", ".", "road_map", "[", "3", "]", "+", "2", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "2", ":", "self", ".", "road_map", "[", "3", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "", "else", ":", "\n", "# JPEG compression", "\n", "                    ", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range2'", "]", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "self", ".", "opt", "[", "'jpeg_range2'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'jpeg_range2'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'jpeg_range2'", "]", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "# resize back + the final sinc filter", "\n", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                        ", "if", "mode_current", "==", "mode", ":", "\n", "                            ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "self", ".", "sinc_kernel", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "1", ":", "self", ".", "road_map", "[", "3", "]", "+", "2", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "2", ":", "self", ".", "road_map", "[", "3", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "# print(self.degradation_params)", "\n", "\n", "", "self", ".", "degradation_params", "=", "self", ".", "degradation_params", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# clamp and round", "\n", "self", ".", "lq", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "# random crop", "\n", "gt_size", "=", "self", ".", "opt", "[", "'gt_size'", "]", "\n", "self", ".", "gt", ",", "self", ".", "lq", ",", "self", ".", "top", ",", "self", ".", "left", "=", "paired_random_crop_return_indexes", "(", "self", ".", "gt", ",", "self", ".", "lq", ",", "gt_size", ",", "self", ".", "opt", "[", "'scale'", "]", ")", "\n", "\n", "", "elif", "self", ".", "degradation_degree", "==", "'standard_degrade_one_stage'", ":", "\n", "\n", "                ", "self", ".", "degradation_params", "=", "torch", ".", "zeros", "(", "self", ".", "opt_train", "[", "'batch_size_per_gpu'", "]", ",", "self", ".", "num_degradation_params", ")", "# [B, 33]", "\n", "\n", "self", ".", "kernel1", "=", "data", "[", "'kernel1'", "]", "[", "'kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "kernel_size_range1", "=", "[", "self", ".", "opt_train", "[", "'blur_kernel_size_minimum_standard1'", "]", ",", "self", ".", "opt_train", "[", "'blur_kernel_size_standard1'", "]", "]", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", ":", "self", ".", "road_map", "[", "0", "]", "+", "1", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'kernel_size'", "]", ".", "unsqueeze", "(", "1", ")", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "1", ":", "self", ".", "road_map", "[", "0", "]", "+", "2", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'sigma_x'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma_standard1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma_standard1'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma_standard1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "2", ":", "self", ".", "road_map", "[", "0", "]", "+", "3", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'sigma_y'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma_standard1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma_standard1'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma_standard1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "3", ":", "self", ".", "road_map", "[", "0", "]", "+", "4", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'rotation'", "]", ".", "unsqueeze", "(", "1", ")", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "self", ".", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "self", ".", "gt", ",", "self", ".", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob_standard1'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range_standard1'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range_standard1'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                    ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'resize_range_standard1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'resize_range_standard1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'resize_range_standard1'", "]", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                    ", "if", "mode_current", "==", "mode", ":", "\n", "                        ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", ":", "self", ".", "road_map", "[", "1", "]", "+", "1", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", "+", "1", ":", "self", ".", "road_map", "[", "1", "]", "+", "4", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "# noise # noise_range: [1, 30] poisson_scale_range: [0.05, 3]", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob_standard1'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob_standard1'", "]", ":", "\n", "                    ", "sigma", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_g_first", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range_standard1'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "normalized_sigma", "=", "(", "sigma", "-", "self", ".", "opt", "[", "'noise_range_standard1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'noise_range_standard1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'noise_range_standard1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", ":", "self", ".", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "1", ":", "self", ".", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "2", ":", "self", ".", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_p_first", "=", "only_generate_poisson_noise_pt", "(", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range_standard1'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                    ", "scale", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_p_first", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range_standard1'", "]", ",", "gray_prob", "=", "gray_noise_prob", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'poisson_scale_range_standard1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'poisson_scale_range_standard1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'poisson_scale_range_standard1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", ":", "self", ".", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "1", ":", "self", ".", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "2", ":", "self", ".", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_g_first", "=", "only_generate_gaussian_noise_pt", "(", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range_standard1'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range_standard1'", "]", ")", "# tensor([61.6463, 94.2723, 37.1205, 34.9564], device='cuda:0')]", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "self", ".", "opt", "[", "'jpeg_range_standard1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'jpeg_range_standard1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'jpeg_range_standard1'", "]", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", ":", "self", ".", "road_map", "[", "3", "]", "+", "1", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# resize back", "\n", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                    ", "if", "mode_current", "==", "mode", ":", "\n", "                        ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "\n", "self", ".", "degradation_params", "=", "self", ".", "degradation_params", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# clamp and round", "\n", "self", ".", "lq", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "# random crop", "\n", "gt_size", "=", "self", ".", "opt", "[", "'gt_size'", "]", "\n", "self", ".", "gt", ",", "self", ".", "lq", ",", "self", ".", "top", ",", "self", ".", "left", "=", "paired_random_crop_return_indexes", "(", "self", ".", "gt", ",", "self", ".", "lq", ",", "gt_size", ",", "\n", "self", ".", "opt", "[", "'scale'", "]", ")", "\n", "\n", "", "elif", "self", ".", "degradation_degree", "==", "'weak_degrade_one_stage'", ":", "\n", "\n", "                ", "self", ".", "degradation_params", "=", "torch", ".", "zeros", "(", "self", ".", "opt_train", "[", "'batch_size_per_gpu'", "]", ",", "self", ".", "num_degradation_params", ")", "# [B, 33]", "\n", "\n", "self", ".", "kernel1", "=", "data", "[", "'kernel1'", "]", "[", "'kernel'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "kernel_size_range1", "=", "[", "self", ".", "opt_train", "[", "'blur_kernel_size_minimum_weak1'", "]", ",", "self", ".", "opt_train", "[", "'blur_kernel_size_weak1'", "]", "]", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", ":", "self", ".", "road_map", "[", "0", "]", "+", "1", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'kernel_size'", "]", ".", "unsqueeze", "(", "1", ")", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "1", ":", "self", ".", "road_map", "[", "0", "]", "+", "2", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'sigma_x'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma_weak1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma_weak1'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma_weak1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "2", ":", "self", ".", "road_map", "[", "0", "]", "+", "3", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'sigma_y'", "]", ".", "unsqueeze", "(", "1", ")", "-", "self", ".", "opt_train", "[", "'blur_sigma_weak1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt_train", "[", "'blur_sigma_weak1'", "]", "[", "1", "]", "-", "self", ".", "opt_train", "[", "'blur_sigma_weak1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "0", "]", "+", "3", ":", "self", ".", "road_map", "[", "0", "]", "+", "4", "]", "=", "(", "data", "[", "'kernel1'", "]", "[", "'rotation'", "]", ".", "unsqueeze", "(", "1", ")", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "self", ".", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "self", ".", "gt", ",", "self", ".", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "self", ".", "opt", "[", "'resize_prob_weak1'", "]", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "self", ".", "opt", "[", "'resize_range_weak1'", "]", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "                    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "self", ".", "opt", "[", "'resize_range_weak1'", "]", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "                    ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'resize_range_weak1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'resize_range_weak1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'resize_range_weak1'", "]", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                    ", "if", "mode_current", "==", "mode", ":", "\n", "                        ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", ":", "self", ".", "road_map", "[", "1", "]", "+", "1", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "1", "]", "+", "1", ":", "self", ".", "road_map", "[", "1", "]", "+", "4", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "# noise # noise_range: [1, 30] poisson_scale_range: [0.05, 3]", "\n", "gray_noise_prob", "=", "self", ".", "opt", "[", "'gray_noise_prob_weak1'", "]", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'gaussian_noise_prob_weak1'", "]", ":", "\n", "                    ", "sigma", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_g_first", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range_weak1'", "]", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "normalized_sigma", "=", "(", "sigma", "-", "self", ".", "opt", "[", "'noise_range_weak1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'noise_range_weak1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'noise_range_weak1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", ":", "self", ".", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "1", ":", "self", ".", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "2", ":", "self", ".", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_p_first", "=", "only_generate_poisson_noise_pt", "(", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range_weak1'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "                    ", "scale", ",", "gray_noise", ",", "out", ",", "self", ".", "noise_p_first", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "scale_range", "=", "self", ".", "opt", "[", "'poisson_scale_range_weak1'", "]", ",", "gray_prob", "=", "gray_noise_prob", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "self", ".", "opt", "[", "'poisson_scale_range_weak1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'poisson_scale_range_weak1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'poisson_scale_range_weak1'", "]", "[", "0", "]", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", ":", "self", ".", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "1", ":", "self", ".", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "2", "]", "+", "2", ":", "self", ".", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "self", ".", "noise_g_first", "=", "only_generate_gaussian_noise_pt", "(", "out", ",", "sigma_range", "=", "self", ".", "opt", "[", "'noise_range_weak1'", "]", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "self", ".", "opt", "[", "'jpeg_range_weak1'", "]", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "self", ".", "opt", "[", "'jpeg_range_weak1'", "]", "[", "0", "]", ")", "/", "(", "self", ".", "opt", "[", "'jpeg_range_weak1'", "]", "[", "1", "]", "-", "self", ".", "opt", "[", "'jpeg_range_weak1'", "]", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "self", ".", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", ":", "self", ".", "road_map", "[", "3", "]", "+", "1", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# resize back", "\n", "mode", "=", "random", ".", "choice", "(", "self", ".", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "self", ".", "resize_mode_list", ")", ":", "\n", "                    ", "if", "mode_current", "==", "mode", ":", "\n", "                        ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "self", ".", "opt", "[", "'scale'", "]", ",", "ori_w", "//", "self", ".", "opt", "[", "'scale'", "]", ")", ",", "mode", "=", "mode", ")", "\n", "self", ".", "degradation_params", "[", ":", ",", "self", ".", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "self", ".", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "self", ".", "resize_mode_list", ")", ")", "\n", "\n", "self", ".", "degradation_params", "=", "self", ".", "degradation_params", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# clamp and round", "\n", "self", ".", "lq", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "# random crop", "\n", "gt_size", "=", "self", ".", "opt", "[", "'gt_size'", "]", "\n", "self", ".", "gt", ",", "self", ".", "lq", ",", "self", ".", "top", ",", "self", ".", "left", "=", "paired_random_crop_return_indexes", "(", "self", ".", "gt", ",", "self", ".", "lq", ",", "gt_size", ",", "self", ".", "opt", "[", "'scale'", "]", ")", "\n", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Degree Mode Mismatch.'", ")", "\n", "\n", "# print(self.degradation_params)", "\n", "\n", "", "self", ".", "_dequeue_and_enqueue", "(", ")", "\n", "", "else", ":", "\n", "            ", "data", "=", "data_all", "\n", "self", ".", "lq", "=", "data", "[", "'lq'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "'gt'", "in", "data", ":", "\n", "                ", "self", ".", "gt", "=", "data", "[", "'gt'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation": [[419, 424], ["super().nondist_validation"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.models.DASR_model.DASRModel.nondist_validation"], ["", "", "", "def", "nondist_validation", "(", "self", ",", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", ":", "\n", "# do not use the synthetic process during validation", "\n", "        ", "self", ".", "is_train", "=", "False", "\n", "super", "(", "DASRModel", ",", "self", ")", ".", "nondist_validation", "(", "dataloader", ",", "current_iter", ",", "tb_logger", ",", "save_img", ")", "\n", "self", ".", "is_train", "=", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.SSIMLoss.__init__": [[155, 173], ["torch.nn.modules.loss._Loss.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "kernel_size", ":", "int", "=", "11", ",", "kernel_sigma", ":", "float", "=", "1.5", ",", "k1", ":", "float", "=", "0.01", ",", "k2", ":", "float", "=", "0.03", ",", "\n", "downsample", ":", "bool", "=", "True", ",", "reduction", ":", "str", "=", "'mean'", ",", "data_range", ":", "Union", "[", "int", ",", "float", "]", "=", "1.", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# Generic loss parameters.", "\n", "self", ".", "reduction", "=", "reduction", "\n", "\n", "# Loss-specific parameters.", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "\n", "# This check might look redundant because kernel size is checked within the ssim function anyway.", "\n", "# However, this check allows to fail fast when the loss is being initialised and training has not been started.", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "f'Kernel size must be odd, got [{kernel_size}]'", "\n", "self", ".", "kernel_sigma", "=", "kernel_sigma", "\n", "self", ".", "k1", "=", "k1", "\n", "self", ".", "k2", "=", "k2", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "data_range", "=", "data_range", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.SSIMLoss.forward": [[174, 187], ["ssim_pytorch.ssim", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.ssim"], ["", "def", "forward", "(", "self", ",", "x", ":", "torch", ".", "Tensor", ",", "y", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "r\"\"\"Computation of Structural Similarity (SSIM) index as a loss function.\n        Args:\n            x: An input tensor. Shape :math:`(N, C, H, W)` or :math:`(N, C, H, W, 2)`.\n            y: A target tensor. Shape :math:`(N, C, H, W)` or :math:`(N, C, H, W, 2)`.\n        Returns:\n            Value of SSIM loss to be minimized, i.e ``1 - ssim`` in [0, 1] range. In case of 5D input tensors,\n            complex value is returned as a tensor of size 2.\n        \"\"\"", "\n", "\n", "score", "=", "ssim", "(", "x", "=", "x", ",", "y", "=", "y", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "kernel_sigma", "=", "self", ".", "kernel_sigma", ",", "downsample", "=", "self", ".", "downsample", ",", "\n", "data_range", "=", "self", ".", "data_range", ",", "reduction", "=", "self", ".", "reduction", ",", "full", "=", "False", ",", "k1", "=", "self", ".", "k1", ",", "k2", "=", "self", ".", "k2", ")", "\n", "return", "torch", ".", "ones_like", "(", "score", ")", "-", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.gaussian_filter": [[14, 30], ["torch.arange().to", "torch.arange().to", "g.sum", "g.unsqueeze", "torch.arange", "torch.arange", "g.unsqueeze", "g.unsqueeze"], "function", ["None"], ["def", "gaussian_filter", "(", "kernel_size", ":", "int", ",", "sigma", ":", "float", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "r\"\"\"Returns 2D Gaussian kernel N(0,`sigma`^2)\n    Args:\n        size: Size of the kernel\n        sigma: Std of the distribution\n    Returns:\n        gaussian_kernel: Tensor with shape (1, kernel_size, kernel_size)\n    \"\"\"", "\n", "coords", "=", "torch", ".", "arange", "(", "kernel_size", ")", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", "\n", "coords", "-=", "(", "kernel_size", "-", "1", ")", "/", "2.", "\n", "\n", "g", "=", "coords", "**", "2", "\n", "g", "=", "(", "-", "(", "g", ".", "unsqueeze", "(", "0", ")", "+", "g", ".", "unsqueeze", "(", "1", ")", ")", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", ".", "exp", "(", ")", "\n", "\n", "g", "/=", "g", ".", "sum", "(", ")", "\n", "return", "g", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch._reduce": [[31, 46], ["x.mean", "x.sum", "ValueError"], "function", ["None"], ["", "def", "_reduce", "(", "x", ":", "torch", ".", "Tensor", ",", "reduction", ":", "str", "=", "'mean'", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "r\"\"\"Reduce input in batch dimension if needed.\n    Args:\n        x: Tensor with shape (N, *).\n        reduction: Specifies the reduction type:\n            ``'none'`` | ``'mean'`` | ``'sum'``. Default: ``'mean'``\n    \"\"\"", "\n", "if", "reduction", "==", "'none'", ":", "\n", "        ", "return", "x", "\n", "", "elif", "reduction", "==", "'mean'", ":", "\n", "        ", "return", "x", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "elif", "reduction", "==", "'sum'", ":", "\n", "        ", "return", "x", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Uknown reduction. Expected one of {'none', 'mean', 'sum'}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.ssim": [[48, 105], ["F.avg_pool2d.type", "F.avg_pool2d.type", "max", "gaussian_filter().repeat().to", "_compute_ssim_per_channel", "ssim_map.mean", "cs_map.mean", "ssim_pytorch._reduce", "ssim_pytorch._reduce", "round", "torch.avg_pool2d", "torch.avg_pool2d", "gaussian_filter().repeat", "F.avg_pool2d.dim", "min", "F.avg_pool2d.size", "ssim_pytorch.gaussian_filter", "F.avg_pool2d.size"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_pytorch._reduce", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_pytorch._reduce", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.gaussian_filter"], ["", "", "def", "ssim", "(", "x", ":", "torch", ".", "Tensor", ",", "y", ":", "torch", ".", "Tensor", ",", "kernel_size", ":", "int", "=", "11", ",", "kernel_sigma", ":", "float", "=", "1.5", ",", "\n", "data_range", ":", "Union", "[", "int", ",", "float", "]", "=", "1.", ",", "reduction", ":", "str", "=", "'mean'", ",", "full", ":", "bool", "=", "False", ",", "\n", "downsample", ":", "bool", "=", "True", ",", "k1", ":", "float", "=", "0.01", ",", "k2", ":", "float", "=", "0.03", ")", "->", "List", "[", "torch", ".", "Tensor", "]", ":", "\n", "    ", "r\"\"\"Interface of Structural Similarity (SSIM) index.\n    Inputs supposed to be in range ``[0, data_range]``.\n    To match performance with skimage and tensorflow set ``'downsample' = True``.\n    Args:\n        x: An input tensor. Shape :math:`(N, C, H, W)` or :math:`(N, C, H, W, 2)`.\n        y: A target tensor. Shape :math:`(N, C, H, W)` or :math:`(N, C, H, W, 2)`.\n        kernel_size: The side-length of the sliding window used in comparison. Must be an odd value.\n        kernel_sigma: Sigma of normal distribution.\n        data_range: Maximum value range of images (usually 1.0 or 255).\n        reduction: Specifies the reduction type:\n            ``'none'`` | ``'mean'`` | ``'sum'``. Default:``'mean'``\n        full: Return cs map or not.\n        downsample: Perform average pool before SSIM computation. Default: True\n        k1: Algorithm parameter, K1 (small constant).\n        k2: Algorithm parameter, K2 (small constant).\n            Try a larger K2 constant (e.g. 0.4) if you get a negative or NaN results.\n    Returns:\n        Value of Structural Similarity (SSIM) index. In case of 5D input tensors, complex value is returned\n        as a tensor of size 2.\n    References:\n        Wang, Z., Bovik, A. C., Sheikh, H. R., & Simoncelli, E. P. (2004).\n        Image quality assessment: From error visibility to structural similarity.\n        IEEE Transactions on Image Processing, 13, 600-612.\n        https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf,\n        DOI: `10.1109/TIP.2003.819861`\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "f'Kernel size must be odd, got [{kernel_size}]'", "\n", "# _validate_input([x, y], dim_range=(4, 5), data_range=(0, data_range))", "\n", "\n", "x", "=", "x", ".", "type", "(", "torch", ".", "float32", ")", "\n", "y", "=", "y", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "x", "=", "x", "/", "data_range", "\n", "y", "=", "y", "/", "data_range", "\n", "\n", "# Averagepool image if the size is large enough", "\n", "f", "=", "max", "(", "1", ",", "round", "(", "min", "(", "x", ".", "size", "(", ")", "[", "-", "2", ":", "]", ")", "/", "256", ")", ")", "\n", "if", "(", "f", ">", "1", ")", "and", "downsample", ":", "\n", "        ", "x", "=", "F", ".", "avg_pool2d", "(", "x", ",", "kernel_size", "=", "f", ")", "\n", "y", "=", "F", ".", "avg_pool2d", "(", "y", ",", "kernel_size", "=", "f", ")", "\n", "\n", "", "kernel", "=", "gaussian_filter", "(", "kernel_size", ",", "kernel_sigma", ")", ".", "repeat", "(", "x", ".", "size", "(", "1", ")", ",", "1", ",", "1", ",", "1", ")", ".", "to", "(", "y", ")", "\n", "_compute_ssim_per_channel", "=", "_ssim_per_channel_complex", "if", "x", ".", "dim", "(", ")", "==", "5", "else", "_ssim_per_channel", "\n", "ssim_map", ",", "cs_map", "=", "_compute_ssim_per_channel", "(", "x", "=", "x", ",", "y", "=", "y", ",", "kernel", "=", "kernel", ",", "data_range", "=", "data_range", ",", "k1", "=", "k1", ",", "k2", "=", "k2", ")", "\n", "ssim_val", "=", "ssim_map", ".", "mean", "(", "1", ")", "\n", "cs", "=", "cs_map", ".", "mean", "(", "1", ")", "\n", "\n", "ssim_val", "=", "_reduce", "(", "ssim_val", ",", "reduction", ")", "\n", "cs", "=", "_reduce", "(", "cs", ",", "reduction", ")", "\n", "\n", "if", "full", ":", "\n", "        ", "return", "[", "ssim_val", ",", "cs", "]", "\n", "\n", "", "return", "ssim_val", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch._ssim_per_channel": [[189, 231], ["x.size", "torch.conv2d", "torch.conv2d", "ss.mean", "cs.mean.mean", "ValueError", "torch.conv2d", "torch.conv2d", "torch.conv2d", "x.size", "kernel.size", "x.size", "kernel.size", "x.size", "kernel.size"], "function", ["None"], ["", "", "def", "_ssim_per_channel", "(", "x", ":", "torch", ".", "Tensor", ",", "y", ":", "torch", ".", "Tensor", ",", "kernel", ":", "torch", ".", "Tensor", ",", "\n", "data_range", ":", "Union", "[", "float", ",", "int", "]", "=", "1.", ",", "k1", ":", "float", "=", "0.01", ",", "\n", "k2", ":", "float", "=", "0.03", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "    ", "r\"\"\"Calculate Structural Similarity (SSIM) index for X and Y per channel.\n    Args:\n        x: An input tensor. Shape :math:`(N, C, H, W)`.\n        y: A target tensor. Shape :math:`(N, C, H, W)`.\n        kernel: 2D Gaussian kernel.\n        data_range: Maximum value range of images (usually 1.0 or 255).\n        k1: Algorithm parameter, K1 (small constant, see [1]).\n        k2: Algorithm parameter, K2 (small constant, see [1]).\n            Try a larger K2 constant (e.g. 0.4) if you get a negative or NaN results.\n    Returns:\n        Full Value of Structural Similarity (SSIM) index.\n    \"\"\"", "\n", "if", "x", ".", "size", "(", "-", "1", ")", "<", "kernel", ".", "size", "(", "-", "1", ")", "or", "x", ".", "size", "(", "-", "2", ")", "<", "kernel", ".", "size", "(", "-", "2", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'Kernel size can\\'t be greater than actual input size. Input size: {x.size()}. '", "\n", "f'Kernel size: {kernel.size()}'", ")", "\n", "\n", "", "c1", "=", "k1", "**", "2", "\n", "c2", "=", "k2", "**", "2", "\n", "n_channels", "=", "x", ".", "size", "(", "1", ")", "\n", "mu_x", "=", "F", ".", "conv2d", "(", "x", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "\n", "mu_y", "=", "F", ".", "conv2d", "(", "y", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "\n", "\n", "mu_xx", "=", "mu_x", "**", "2", "\n", "mu_yy", "=", "mu_y", "**", "2", "\n", "mu_xy", "=", "mu_x", "*", "mu_y", "\n", "\n", "sigma_xx", "=", "F", ".", "conv2d", "(", "x", "**", "2", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu_xx", "\n", "sigma_yy", "=", "F", ".", "conv2d", "(", "y", "**", "2", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu_yy", "\n", "sigma_xy", "=", "F", ".", "conv2d", "(", "x", "*", "y", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu_xy", "\n", "\n", "# Contrast sensitivity (CS) with alpha = beta = gamma = 1.", "\n", "cs", "=", "(", "2.", "*", "sigma_xy", "+", "c2", ")", "/", "(", "sigma_xx", "+", "sigma_yy", "+", "c2", ")", "\n", "\n", "# Structural similarity (SSIM)", "\n", "ss", "=", "(", "2.", "*", "mu_xy", "+", "c1", ")", "/", "(", "mu_xx", "+", "mu_yy", "+", "c1", ")", "*", "cs", "\n", "\n", "ssim_val", "=", "ss", ".", "mean", "(", "dim", "=", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "cs", "=", "cs", ".", "mean", "(", "dim", "=", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "return", "ssim_val", ",", "cs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch._ssim_per_channel_complex": [[233, 293], ["x.size", "torch.conv2d", "torch.conv2d", "torch.conv2d", "torch.conv2d", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "ssim_map.mean", "cs_map.mean", "ValueError", "F.conv2d.pow", "F.conv2d.pow", "F.conv2d.pow", "F.conv2d.pow", "x_real.pow", "x_imag.pow", "y_real.pow", "y_imag.pow", "torch.conv2d", "torch.conv2d", "torch.conv2d", "torch.conv2d", "x.size", "kernel.size", "x.size", "kernel.size", "sigma1_sq.unsqueeze", "sigma2_sq.unsqueeze", "mu1_sq.unsqueeze", "mu2_sq.unsqueeze", "x.size", "kernel.size"], "function", ["None"], ["", "def", "_ssim_per_channel_complex", "(", "x", ":", "torch", ".", "Tensor", ",", "y", ":", "torch", ".", "Tensor", ",", "kernel", ":", "torch", ".", "Tensor", ",", "\n", "data_range", ":", "Union", "[", "float", ",", "int", "]", "=", "1.", ",", "k1", ":", "float", "=", "0.01", ",", "\n", "k2", ":", "float", "=", "0.03", ")", "->", "Union", "[", "torch", ".", "Tensor", ",", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "    ", "r\"\"\"Calculate Structural Similarity (SSIM) index for Complex X and Y per channel.\n    Args:\n        x: An input tensor. Shape :math:`(N, C, H, W, 2)`.\n        y: A target tensor. Shape :math:`(N, C, H, W, 2)`.\n        kernel: 2-D gauss kernel.\n        data_range: Maximum value range of images (usually 1.0 or 255).\n        k1: Algorithm parameter, K1 (small constant, see [1]).\n        k2: Algorithm parameter, K2 (small constant, see [1]).\n            Try a larger K2 constant (e.g. 0.4) if you get a negative or NaN results.\n    Returns:\n        Full Value of Complex Structural Similarity (SSIM) index.\n    \"\"\"", "\n", "n_channels", "=", "x", ".", "size", "(", "1", ")", "\n", "if", "x", ".", "size", "(", "-", "2", ")", "<", "kernel", ".", "size", "(", "-", "1", ")", "or", "x", ".", "size", "(", "-", "3", ")", "<", "kernel", ".", "size", "(", "-", "2", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'Kernel size can\\'t be greater than actual input size. Input size: {x.size()}. '", "\n", "f'Kernel size: {kernel.size()}'", ")", "\n", "\n", "", "c1", "=", "k1", "**", "2", "\n", "c2", "=", "k2", "**", "2", "\n", "\n", "x_real", "=", "x", "[", "...", ",", "0", "]", "\n", "x_imag", "=", "x", "[", "...", ",", "1", "]", "\n", "y_real", "=", "y", "[", "...", ",", "0", "]", "\n", "y_imag", "=", "y", "[", "...", ",", "1", "]", "\n", "\n", "mu1_real", "=", "F", ".", "conv2d", "(", "x_real", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "\n", "mu1_imag", "=", "F", ".", "conv2d", "(", "x_imag", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "\n", "mu2_real", "=", "F", ".", "conv2d", "(", "y_real", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "\n", "mu2_imag", "=", "F", ".", "conv2d", "(", "y_imag", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "\n", "\n", "mu1_sq", "=", "mu1_real", ".", "pow", "(", "2", ")", "+", "mu1_imag", ".", "pow", "(", "2", ")", "\n", "mu2_sq", "=", "mu2_real", ".", "pow", "(", "2", ")", "+", "mu2_imag", ".", "pow", "(", "2", ")", "\n", "mu1_mu2_real", "=", "mu1_real", "*", "mu2_real", "-", "mu1_imag", "*", "mu2_imag", "\n", "mu1_mu2_imag", "=", "mu1_real", "*", "mu2_imag", "+", "mu1_imag", "*", "mu2_real", "\n", "\n", "compensation", "=", "1.0", "\n", "\n", "x_sq", "=", "x_real", ".", "pow", "(", "2", ")", "+", "x_imag", ".", "pow", "(", "2", ")", "\n", "y_sq", "=", "y_real", ".", "pow", "(", "2", ")", "+", "y_imag", ".", "pow", "(", "2", ")", "\n", "x_y_real", "=", "x_real", "*", "y_real", "-", "x_imag", "*", "y_imag", "\n", "x_y_imag", "=", "x_real", "*", "y_imag", "+", "x_imag", "*", "y_real", "\n", "\n", "sigma1_sq", "=", "F", ".", "conv2d", "(", "x_sq", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu1_sq", "\n", "sigma2_sq", "=", "F", ".", "conv2d", "(", "y_sq", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu2_sq", "\n", "sigma12_real", "=", "F", ".", "conv2d", "(", "x_y_real", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu1_mu2_real", "\n", "sigma12_imag", "=", "F", ".", "conv2d", "(", "x_y_imag", ",", "weight", "=", "kernel", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "groups", "=", "n_channels", ")", "-", "mu1_mu2_imag", "\n", "sigma12", "=", "torch", ".", "stack", "(", "(", "sigma12_imag", ",", "sigma12_real", ")", ",", "dim", "=", "-", "1", ")", "\n", "mu1_mu2", "=", "torch", ".", "stack", "(", "(", "mu1_mu2_real", ",", "mu1_mu2_imag", ")", ",", "dim", "=", "-", "1", ")", "\n", "# Set alpha = beta = gamma = 1.", "\n", "cs_map", "=", "(", "sigma12", "*", "2", "+", "c2", "*", "compensation", ")", "/", "(", "sigma1_sq", ".", "unsqueeze", "(", "-", "1", ")", "+", "sigma2_sq", ".", "unsqueeze", "(", "-", "1", ")", "+", "c2", "*", "compensation", ")", "\n", "ssim_map", "=", "(", "mu1_mu2", "*", "2", "+", "c1", "*", "compensation", ")", "/", "(", "mu1_sq", ".", "unsqueeze", "(", "-", "1", ")", "+", "mu2_sq", ".", "unsqueeze", "(", "-", "1", ")", "+", "c1", "*", "compensation", ")", "\n", "ssim_map", "=", "ssim_map", "*", "cs_map", "\n", "\n", "ssim_val", "=", "ssim_map", ".", "mean", "(", "dim", "=", "(", "-", "2", ",", "-", "3", ")", ")", "\n", "cs", "=", "cs_map", ".", "mean", "(", "dim", "=", "(", "-", "2", ",", "-", "3", ")", ")", "\n", "\n", "return", "ssim_val", ",", "cs", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_pytorch._validate_input": [[7, 48], ["torch.is_tensor", "type", "t.size", "x.size", "t.dim", "t.min", "t.max", "t.size", "x.size", "t.size", "x.size", "t.size", "x.size", "t.dim", "t.dim", "t.min", "t.max", "t.dim"], "function", ["None"], ["def", "_validate_input", "(", "\n", "tensors", ":", "List", "[", "torch", ".", "Tensor", "]", ",", "\n", "dim_range", ":", "Tuple", "[", "int", ",", "int", "]", "=", "(", "0", ",", "-", "1", ")", ",", "\n", "data_range", ":", "Tuple", "[", "float", ",", "float", "]", "=", "(", "0.", ",", "-", "1.", ")", ",", "\n", "# size_dim_range: Tuple[float, float] = (0., -1.),", "\n", "size_range", ":", "Optional", "[", "Tuple", "[", "int", ",", "int", "]", "]", "=", "None", ",", "\n", ")", "->", "None", ":", "\n", "    ", "r\"\"\"Check that input(-s)  satisfies the requirements\n    Args:\n        tensors: Tensors to check\n        dim_range: Allowed number of dimensions. (min, max)\n        data_range: Allowed range of values in tensors. (min, max)\n        size_range: Dimensions to include in size comparison. (start_dim, end_dim + 1)\n    \"\"\"", "\n", "\n", "if", "not", "__debug__", ":", "\n", "        ", "return", "\n", "\n", "", "x", "=", "tensors", "[", "0", "]", "\n", "\n", "for", "t", "in", "tensors", ":", "\n", "        ", "assert", "torch", ".", "is_tensor", "(", "t", ")", ",", "f'Expected torch.Tensor, got {type(t)}'", "\n", "assert", "t", ".", "device", "==", "x", ".", "device", ",", "f'Expected tensors to be on {x.device}, got {t.device}'", "\n", "\n", "if", "size_range", "is", "None", ":", "\n", "            ", "assert", "t", ".", "size", "(", ")", "==", "x", ".", "size", "(", ")", ",", "f'Expected tensors with same size, got {t.size()} and {x.size()}'", "\n", "", "else", ":", "\n", "            ", "assert", "t", ".", "size", "(", ")", "[", "size_range", "[", "0", "]", ":", "size_range", "[", "1", "]", "]", "==", "x", ".", "size", "(", ")", "[", "size_range", "[", "0", "]", ":", "size_range", "[", "1", "]", "]", ",", "f'Expected tensors with same size at given dimensions, got {t.size()} and {x.size()}'", "\n", "\n", "", "if", "dim_range", "[", "0", "]", "==", "dim_range", "[", "1", "]", ":", "\n", "            ", "assert", "t", ".", "dim", "(", ")", "==", "dim_range", "[", "0", "]", ",", "f'Expected number of dimensions to be {dim_range[0]}, got {t.dim()}'", "\n", "", "elif", "dim_range", "[", "0", "]", "<", "dim_range", "[", "1", "]", ":", "\n", "            ", "assert", "dim_range", "[", "0", "]", "<=", "t", ".", "dim", "(", ")", "<=", "dim_range", "[", "1", "]", ",", "f'Expected number of dimensions to be between {dim_range[0]} and {dim_range[1]}, got {t.dim()}'", "\n", "\n", "", "if", "data_range", "[", "0", "]", "<", "data_range", "[", "1", "]", ":", "\n", "            ", "assert", "data_range", "[", "0", "]", "<=", "t", ".", "min", "(", ")", ",", "f'Expected values to be greater or equal to {data_range[0]}, got {t.min()}'", "\n", "assert", "t", ".", "max", "(", ")", "<=", "data_range", "[", "1", "]", ",", "f'Expected values to be lower or equal to {data_range[1]}, got {t.max()}'", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_pytorch._reduce": [[50, 65], ["x.mean", "x.sum", "ValueError"], "function", ["None"], ["", "", "", "def", "_reduce", "(", "x", ":", "torch", ".", "Tensor", ",", "reduction", ":", "str", "=", "'mean'", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "r\"\"\"Reduce input in batch dimension if needed.\n    Args:\n        x: Tensor with shape (N, *).\n        reduction: Specifies the reduction type:\n            ``'none'`` | ``'mean'`` | ``'sum'``. Default: ``'mean'``\n    \"\"\"", "\n", "if", "reduction", "==", "'none'", ":", "\n", "        ", "return", "x", "\n", "", "elif", "reduction", "==", "'mean'", ":", "\n", "        ", "return", "x", ".", "mean", "(", "dim", "=", "0", ")", "\n", "", "elif", "reduction", "==", "'sum'", ":", "\n", "        ", "return", "x", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"Uknown reduction. Expected one of {'none', 'mean', 'sum'}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_pytorch.psnr": [[67, 102], ["torch.mean", "psnr_pytorch._reduce", "float", "float", "torch.tensor().view().to", "torch.sum", "torch.sum", "torch.log10", "torch.sum.size", "torch.tensor().view", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_pytorch._reduce"], ["", "", "def", "psnr", "(", "x", ":", "torch", ".", "Tensor", ",", "y", ":", "torch", ".", "Tensor", ",", "data_range", ":", "Union", "[", "int", ",", "float", "]", "=", "1.0", ",", "\n", "reduction", ":", "str", "=", "'mean'", ",", "convert_to_greyscale", ":", "bool", "=", "False", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "r\"\"\"Compute Peak Signal-to-Noise Ratio for a batch of images.\n    Supports both greyscale and color images with RGB channel order.\n    Args:\n        x: An input tensor. Shape :math:`(N, C, H, W)`.\n        y: A target tensor. Shape :math:`(N, C, H, W)`.\n        data_range: Maximum value range of images (usually 1.0 or 255).\n        reduction: Specifies the reduction type:\n            ``'none'`` | ``'mean'`` | ``'sum'``. Default:``'mean'``\n        convert_to_greyscale: Convert RGB image to YCbCr format and computes PSNR\n            only on luminance channel if `True`. Compute on all 3 channels otherwise.\n    Returns:\n        PSNR Index of similarity betwen two images.\n    References:\n        https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio\n    \"\"\"", "\n", "# _validate_input([x, y], dim_range=(4, 5), data_range=(0, data_range))", "\n", "\n", "# Constant for numerical stability", "\n", "EPS", "=", "1e-8", "\n", "\n", "x", "=", "x", "/", "float", "(", "data_range", ")", "\n", "y", "=", "y", "/", "float", "(", "data_range", ")", "\n", "\n", "if", "(", "x", ".", "size", "(", "1", ")", "==", "3", ")", "and", "convert_to_greyscale", ":", "\n", "# Convert RGB image to YCbCr and take luminance: Y = 0.299 R + 0.587 G + 0.114 B", "\n", "        ", "rgb_to_grey", "=", "torch", ".", "tensor", "(", "[", "0.299", ",", "0.587", ",", "0.114", "]", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ".", "to", "(", "x", ")", "\n", "x", "=", "torch", ".", "sum", "(", "x", "*", "rgb_to_grey", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "y", "=", "torch", ".", "sum", "(", "y", "*", "rgb_to_grey", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "", "mse", "=", "torch", ".", "mean", "(", "(", "x", "-", "y", ")", "**", "2", ",", "dim", "=", "[", "1", ",", "2", ",", "3", "]", ")", "\n", "score", ":", "torch", ".", "Tensor", "=", "-", "10", "*", "torch", ".", "log10", "(", "mse", "+", "EPS", ")", "\n", "\n", "return", "_reduce", "(", "score", ",", "reduction", ")", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.reorder_image": [[6, 30], ["ValueError", "len", "img.transpose.transpose"], "function", ["None"], ["def", "reorder_image", "(", "img", ",", "input_order", "=", "'HWC'", ")", ":", "\n", "    ", "\"\"\"Reorder images to 'HWC' order.\n\n    If the input_order is (h, w), return (h, w, 1);\n    If the input_order is (c, h, w), return (h, w, c);\n    If the input_order is (h, w, c), return as it is.\n\n    Args:\n        img (ndarray): Input image.\n        input_order (str): Whether the input order is 'HWC' or 'CHW'.\n            If the input image shape is (h, w), input_order will not have\n            effects. Default: 'HWC'.\n\n    Returns:\n        ndarray: reordered image.\n    \"\"\"", "\n", "\n", "if", "input_order", "not", "in", "[", "'HWC'", ",", "'CHW'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "f'Wrong input_order {input_order}. Supported input_orders are '", "\"'HWC' and 'CHW'\"", ")", "\n", "", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "\n", "        ", "img", "=", "img", "[", "...", ",", "None", "]", "\n", "", "if", "input_order", "==", "'CHW'", ":", "\n", "        ", "img", "=", "img", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.to_y_channel": [[32, 46], ["basicsr.utils.matlab_functions.bgr2ycbcr.astype", "basicsr.utils.matlab_functions.bgr2ycbcr"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.bgr2ycbcr"], ["", "def", "to_y_channel", "(", "img", ")", ":", "\n", "    ", "\"\"\"Change to Y channel of YCbCr.\n\n    Args:\n        img (ndarray): Images with range [0, 255].\n\n    Returns:\n        (ndarray): Images with range [0, 255] (float type) without round.\n    \"\"\"", "\n", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "\n", "if", "img", ".", "ndim", "==", "3", "and", "img", ".", "shape", "[", "2", "]", "==", "3", ":", "\n", "        ", "img", "=", "bgr2ycbcr", "(", "img", ",", "y_only", "=", "True", ")", "\n", "img", "=", "img", "[", "...", ",", "None", "]", "\n", "", "return", "img", "*", "255.", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_ssim.calculate_psnr": [[8, 47], ["basicsr.utils.registry.METRIC_REGISTRY.register", "basicsr.metrics.metric_util.reorder_image", "basicsr.metrics.metric_util.reorder_image", "basicsr.metrics.metric_util.to_y_channel.astype", "basicsr.metrics.metric_util.to_y_channel.astype", "numpy.mean", "ValueError", "basicsr.metrics.metric_util.to_y_channel", "basicsr.metrics.metric_util.to_y_channel", "float", "numpy.log10", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.register", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.reorder_image", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.reorder_image", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.to_y_channel", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.to_y_channel"], ["@", "METRIC_REGISTRY", ".", "register", "(", ")", "\n", "def", "calculate_psnr", "(", "img1", ",", "img2", ",", "crop_border", ",", "input_order", "=", "'HWC'", ",", "test_y_channel", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculate PSNR (Peak Signal-to-Noise Ratio).\n\n    Ref: https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio\n\n    Args:\n        img1 (ndarray): Images with range [0, 255].\n        img2 (ndarray): Images with range [0, 255].\n        crop_border (int): Cropped pixels in each edge of an image. These\n            pixels are not involved in the PSNR calculation.\n        input_order (str): Whether the input order is 'HWC' or 'CHW'.\n            Default: 'HWC'.\n        test_y_channel (bool): Test on Y channel of YCbCr. Default: False.\n\n    Returns:\n        float: psnr result.\n    \"\"\"", "\n", "\n", "assert", "img1", ".", "shape", "==", "img2", ".", "shape", ",", "(", "f'Image shapes are differnet: {img1.shape}, {img2.shape}.'", ")", "\n", "if", "input_order", "not", "in", "[", "'HWC'", ",", "'CHW'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "f'Wrong input_order {input_order}. Supported input_orders are '", "'\"HWC\" and \"CHW\"'", ")", "\n", "", "img1", "=", "reorder_image", "(", "img1", ",", "input_order", "=", "input_order", ")", "\n", "img2", "=", "reorder_image", "(", "img2", ",", "input_order", "=", "input_order", ")", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "if", "crop_border", "!=", "0", ":", "\n", "        ", "img1", "=", "img1", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", ",", "...", "]", "\n", "img2", "=", "img2", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", ",", "...", "]", "\n", "\n", "", "if", "test_y_channel", ":", "\n", "        ", "img1", "=", "to_y_channel", "(", "img1", ")", "\n", "img2", "=", "to_y_channel", "(", "img2", ")", "\n", "\n", "", "mse", "=", "np", ".", "mean", "(", "(", "img1", "-", "img2", ")", "**", "2", ")", "\n", "if", "mse", "==", "0", ":", "\n", "        ", "return", "float", "(", "'inf'", ")", "\n", "", "return", "20.", "*", "np", ".", "log10", "(", "255.", "/", "np", ".", "sqrt", "(", "mse", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_ssim._ssim": [[49, 81], ["img1.astype.astype", "img2.astype.astype", "cv2.getGaussianKernel", "numpy.outer", "ssim_map.mean", "cv2.getGaussianKernel.transpose", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D"], ["", "def", "_ssim", "(", "img1", ",", "img2", ")", ":", "\n", "    ", "\"\"\"Calculate SSIM (structural similarity) for one channel images.\n\n    It is called by func:`calculate_ssim`.\n\n    Args:\n        img1 (ndarray): Images with range [0, 255] with order 'HWC'.\n        img2 (ndarray): Images with range [0, 255] with order 'HWC'.\n\n    Returns:\n        float: ssim result.\n    \"\"\"", "\n", "\n", "C1", "=", "(", "0.01", "*", "255", ")", "**", "2", "\n", "C2", "=", "(", "0.03", "*", "255", ")", "**", "2", "\n", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "kernel", "=", "cv2", ".", "getGaussianKernel", "(", "11", ",", "1.5", ")", "\n", "window", "=", "np", ".", "outer", "(", "kernel", ",", "kernel", ".", "transpose", "(", ")", ")", "\n", "\n", "mu1", "=", "cv2", ".", "filter2D", "(", "img1", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "\n", "mu2", "=", "cv2", ".", "filter2D", "(", "img2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "\n", "mu1_sq", "=", "mu1", "**", "2", "\n", "mu2_sq", "=", "mu2", "**", "2", "\n", "mu1_mu2", "=", "mu1", "*", "mu2", "\n", "sigma1_sq", "=", "cv2", ".", "filter2D", "(", "img1", "**", "2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu1_sq", "\n", "sigma2_sq", "=", "cv2", ".", "filter2D", "(", "img2", "**", "2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu2_sq", "\n", "sigma12", "=", "cv2", ".", "filter2D", "(", "img1", "*", "img2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu1_mu2", "\n", "\n", "ssim_map", "=", "(", "(", "2", "*", "mu1_mu2", "+", "C1", ")", "*", "(", "2", "*", "sigma12", "+", "C2", ")", ")", "/", "(", "(", "mu1_sq", "+", "mu2_sq", "+", "C1", ")", "*", "(", "sigma1_sq", "+", "sigma2_sq", "+", "C2", ")", ")", "\n", "return", "ssim_map", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_ssim.calculate_ssim": [[83, 129], ["basicsr.utils.registry.METRIC_REGISTRY.register", "basicsr.metrics.metric_util.reorder_image", "basicsr.metrics.metric_util.reorder_image", "basicsr.metrics.metric_util.to_y_channel.astype", "basicsr.metrics.metric_util.to_y_channel.astype", "range", "numpy.array().mean", "ValueError", "basicsr.metrics.metric_util.to_y_channel", "basicsr.metrics.metric_util.to_y_channel", "ssims.append", "psnr_ssim._ssim", "numpy.array"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.register", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.reorder_image", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.reorder_image", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.to_y_channel", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.to_y_channel", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_ssim._ssim"], ["", "@", "METRIC_REGISTRY", ".", "register", "(", ")", "\n", "def", "calculate_ssim", "(", "img1", ",", "img2", ",", "crop_border", ",", "input_order", "=", "'HWC'", ",", "test_y_channel", "=", "False", ")", ":", "\n", "    ", "\"\"\"Calculate SSIM (structural similarity).\n\n    Ref:\n    Image quality assessment: From error visibility to structural similarity\n\n    The results are the same as that of the official released MATLAB code in\n    https://ece.uwaterloo.ca/~z70wang/research/ssim/.\n\n    For three-channel images, SSIM is calculated for each channel and then\n    averaged.\n\n    Args:\n        img1 (ndarray): Images with range [0, 255].\n        img2 (ndarray): Images with range [0, 255].\n        crop_border (int): Cropped pixels in each edge of an image. These\n            pixels are not involved in the SSIM calculation.\n        input_order (str): Whether the input order is 'HWC' or 'CHW'.\n            Default: 'HWC'.\n        test_y_channel (bool): Test on Y channel of YCbCr. Default: False.\n\n    Returns:\n        float: ssim result.\n    \"\"\"", "\n", "\n", "assert", "img1", ".", "shape", "==", "img2", ".", "shape", ",", "(", "f'Image shapes are differnet: {img1.shape}, {img2.shape}.'", ")", "\n", "if", "input_order", "not", "in", "[", "'HWC'", ",", "'CHW'", "]", ":", "\n", "        ", "raise", "ValueError", "(", "f'Wrong input_order {input_order}. Supported input_orders are '", "'\"HWC\" and \"CHW\"'", ")", "\n", "", "img1", "=", "reorder_image", "(", "img1", ",", "input_order", "=", "input_order", ")", "\n", "img2", "=", "reorder_image", "(", "img2", ",", "input_order", "=", "input_order", ")", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "if", "crop_border", "!=", "0", ":", "\n", "        ", "img1", "=", "img1", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", ",", "...", "]", "\n", "img2", "=", "img2", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", ",", "...", "]", "\n", "\n", "", "if", "test_y_channel", ":", "\n", "        ", "img1", "=", "to_y_channel", "(", "img1", ")", "\n", "img2", "=", "to_y_channel", "(", "img2", ")", "\n", "\n", "", "ssims", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "img1", ".", "shape", "[", "2", "]", ")", ":", "\n", "        ", "ssims", ".", "append", "(", "_ssim", "(", "img1", "[", "...", ",", "i", "]", ",", "img2", "[", "...", ",", "i", "]", ")", ")", "\n", "", "return", "np", ".", "array", "(", "ssims", ")", ".", "mean", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.estimate_aggd_param": [[11, 37], ["block.flatten.flatten", "numpy.arange", "numpy.reciprocal", "numpy.sqrt", "numpy.sqrt", "numpy.argmin", "numpy.square", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.sqrt", "numpy.sqrt", "scipy.special.gamma", "scipy.special.gamma", "scipy.special.gamma", "numpy.mean", "numpy.abs", "scipy.special.gamma", "scipy.special.gamma", "scipy.special.gamma", "scipy.special.gamma"], "function", ["None"], ["def", "estimate_aggd_param", "(", "block", ")", ":", "\n", "    ", "\"\"\"Estimate AGGD (Asymmetric Generalized Gaussian Distribution) paramters.\n\n    Args:\n        block (ndarray): 2D Image block.\n\n    Returns:\n        tuple: alpha (float), beta_l (float) and beta_r (float) for the AGGD\n            distribution (Estimating the parames in Equation 7 in the paper).\n    \"\"\"", "\n", "block", "=", "block", ".", "flatten", "(", ")", "\n", "gam", "=", "np", ".", "arange", "(", "0.2", ",", "10.001", ",", "0.001", ")", "# len = 9801", "\n", "gam_reciprocal", "=", "np", ".", "reciprocal", "(", "gam", ")", "\n", "r_gam", "=", "np", ".", "square", "(", "gamma", "(", "gam_reciprocal", "*", "2", ")", ")", "/", "(", "gamma", "(", "gam_reciprocal", ")", "*", "gamma", "(", "gam_reciprocal", "*", "3", ")", ")", "\n", "\n", "left_std", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "block", "[", "block", "<", "0", "]", "**", "2", ")", ")", "\n", "right_std", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "block", "[", "block", ">", "0", "]", "**", "2", ")", ")", "\n", "gammahat", "=", "left_std", "/", "right_std", "\n", "rhat", "=", "(", "np", ".", "mean", "(", "np", ".", "abs", "(", "block", ")", ")", ")", "**", "2", "/", "np", ".", "mean", "(", "block", "**", "2", ")", "\n", "rhatnorm", "=", "(", "rhat", "*", "(", "gammahat", "**", "3", "+", "1", ")", "*", "(", "gammahat", "+", "1", ")", ")", "/", "(", "(", "gammahat", "**", "2", "+", "1", ")", "**", "2", ")", "\n", "array_position", "=", "np", ".", "argmin", "(", "(", "r_gam", "-", "rhatnorm", ")", "**", "2", ")", "\n", "\n", "alpha", "=", "gam", "[", "array_position", "]", "\n", "beta_l", "=", "left_std", "*", "np", ".", "sqrt", "(", "gamma", "(", "1", "/", "alpha", ")", "/", "gamma", "(", "3", "/", "alpha", ")", ")", "\n", "beta_r", "=", "right_std", "*", "np", ".", "sqrt", "(", "gamma", "(", "1", "/", "alpha", ")", "/", "gamma", "(", "3", "/", "alpha", ")", ")", "\n", "return", "(", "alpha", ",", "beta_l", ",", "beta_r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.compute_feature": [[39, 64], ["niqe.estimate_aggd_param", "feat.extend", "range", "len", "numpy.roll", "niqe.estimate_aggd_param", "feat.extend", "scipy.special.gamma", "scipy.special.gamma"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.estimate_aggd_param", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.estimate_aggd_param"], ["", "def", "compute_feature", "(", "block", ")", ":", "\n", "    ", "\"\"\"Compute features.\n\n    Args:\n        block (ndarray): 2D Image block.\n\n    Returns:\n        list: Features with length of 18.\n    \"\"\"", "\n", "feat", "=", "[", "]", "\n", "alpha", ",", "beta_l", ",", "beta_r", "=", "estimate_aggd_param", "(", "block", ")", "\n", "feat", ".", "extend", "(", "[", "alpha", ",", "(", "beta_l", "+", "beta_r", ")", "/", "2", "]", ")", "\n", "\n", "# distortions disturb the fairly regular structure of natural images.", "\n", "# This deviation can be captured by analyzing the sample distribution of", "\n", "# the products of pairs of adjacent coefficients computed along", "\n", "# horizontal, vertical and diagonal orientations.", "\n", "shifts", "=", "[", "[", "0", ",", "1", "]", ",", "[", "1", ",", "0", "]", ",", "[", "1", ",", "1", "]", ",", "[", "1", ",", "-", "1", "]", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "shifts", ")", ")", ":", "\n", "        ", "shifted_block", "=", "np", ".", "roll", "(", "block", ",", "shifts", "[", "i", "]", ",", "axis", "=", "(", "0", ",", "1", ")", ")", "\n", "alpha", ",", "beta_l", ",", "beta_r", "=", "estimate_aggd_param", "(", "block", "*", "shifted_block", ")", "\n", "# Eq. 8", "\n", "mean", "=", "(", "beta_r", "-", "beta_l", ")", "*", "(", "gamma", "(", "2", "/", "alpha", ")", "/", "gamma", "(", "1", "/", "alpha", ")", ")", "\n", "feat", ".", "extend", "(", "[", "alpha", ",", "mean", ",", "beta_l", ",", "beta_r", "]", ")", "\n", "", "return", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.niqe": [[66, 139], ["math.floor", "math.floor", "numpy.concatenate", "numpy.nanmean", "numpy.cov", "numpy.linalg.pinv", "numpy.matmul", "numpy.sqrt", "numpy.squeeze", "scipy.ndimage.filters.convolve", "numpy.sqrt", "range", "np.concatenate.append", "numpy.matmul", "numpy.transpose", "numpy.abs", "range", "numpy.array", "basicsr.utils.matlab_functions.imresize", "feat.append", "numpy.isnan().any", "scipy.ndimage.filters.convolve", "numpy.square", "niqe.compute_feature", "numpy.square", "numpy.isnan"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.imresize", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.compute_feature"], ["", "def", "niqe", "(", "img", ",", "mu_pris_param", ",", "cov_pris_param", ",", "gaussian_window", ",", "block_size_h", "=", "96", ",", "block_size_w", "=", "96", ")", ":", "\n", "    ", "\"\"\"Calculate NIQE (Natural Image Quality Evaluator) metric.\n\n    Ref: Making a \"Completely Blind\" Image Quality Analyzer.\n    This implementation could produce almost the same results as the official\n    MATLAB codes: http://live.ece.utexas.edu/research/quality/niqe_release.zip\n\n    Note that we do not include block overlap height and width, since they are\n    always 0 in the official implementation.\n\n    For good performance, it is advisable by the official implemtation to\n    divide the distorted image in to the same size patched as used for the\n    construction of multivariate Gaussian model.\n\n    Args:\n        img (ndarray): Input image whose quality needs to be computed. The\n            image must be a gray or Y (of YCbCr) image with shape (h, w).\n            Range [0, 255] with float type.\n        mu_pris_param (ndarray): Mean of a pre-defined multivariate Gaussian\n            model calculated on the pristine dataset.\n        cov_pris_param (ndarray): Covariance of a pre-defined multivariate\n            Gaussian model calculated on the pristine dataset.\n        gaussian_window (ndarray): A 7x7 Gaussian window used for smoothing the\n            image.\n        block_size_h (int): Height of the blocks in to which image is divided.\n            Default: 96 (the official recommended value).\n        block_size_w (int): Width of the blocks in to which image is divided.\n            Default: 96 (the official recommended value).\n    \"\"\"", "\n", "assert", "img", ".", "ndim", "==", "2", ",", "(", "'Input image must be a gray or Y (of YCbCr) image with shape (h, w).'", ")", "\n", "# crop image", "\n", "h", ",", "w", "=", "img", ".", "shape", "\n", "num_block_h", "=", "math", ".", "floor", "(", "h", "/", "block_size_h", ")", "\n", "num_block_w", "=", "math", ".", "floor", "(", "w", "/", "block_size_w", ")", "\n", "img", "=", "img", "[", "0", ":", "num_block_h", "*", "block_size_h", ",", "0", ":", "num_block_w", "*", "block_size_w", "]", "\n", "\n", "distparam", "=", "[", "]", "# dist param is actually the multiscale features", "\n", "for", "scale", "in", "(", "1", ",", "2", ")", ":", "# perform on two scales (1, 2)", "\n", "        ", "mu", "=", "convolve", "(", "img", ",", "gaussian_window", ",", "mode", "=", "'nearest'", ")", "\n", "sigma", "=", "np", ".", "sqrt", "(", "np", ".", "abs", "(", "convolve", "(", "np", ".", "square", "(", "img", ")", ",", "gaussian_window", ",", "mode", "=", "'nearest'", ")", "-", "np", ".", "square", "(", "mu", ")", ")", ")", "\n", "# normalize, as in Eq. 1 in the paper", "\n", "img_nomalized", "=", "(", "img", "-", "mu", ")", "/", "(", "sigma", "+", "1", ")", "\n", "\n", "feat", "=", "[", "]", "\n", "for", "idx_w", "in", "range", "(", "num_block_w", ")", ":", "\n", "            ", "for", "idx_h", "in", "range", "(", "num_block_h", ")", ":", "\n", "# process ecah block", "\n", "                ", "block", "=", "img_nomalized", "[", "idx_h", "*", "block_size_h", "//", "scale", ":", "(", "idx_h", "+", "1", ")", "*", "block_size_h", "//", "scale", ",", "\n", "idx_w", "*", "block_size_w", "//", "scale", ":", "(", "idx_w", "+", "1", ")", "*", "block_size_w", "//", "scale", "]", "\n", "feat", ".", "append", "(", "compute_feature", "(", "block", ")", ")", "\n", "\n", "", "", "distparam", ".", "append", "(", "np", ".", "array", "(", "feat", ")", ")", "\n", "\n", "if", "scale", "==", "1", ":", "\n", "            ", "img", "=", "imresize", "(", "img", "/", "255.", ",", "scale", "=", "0.5", ",", "antialiasing", "=", "True", ")", "\n", "img", "=", "img", "*", "255.", "\n", "\n", "", "", "distparam", "=", "np", ".", "concatenate", "(", "distparam", ",", "axis", "=", "1", ")", "\n", "\n", "# fit a MVG (multivariate Gaussian) model to distorted patch features", "\n", "mu_distparam", "=", "np", ".", "nanmean", "(", "distparam", ",", "axis", "=", "0", ")", "\n", "# use nancov. ref: https://ww2.mathworks.cn/help/stats/nancov.html", "\n", "distparam_no_nan", "=", "distparam", "[", "~", "np", ".", "isnan", "(", "distparam", ")", ".", "any", "(", "axis", "=", "1", ")", "]", "\n", "cov_distparam", "=", "np", ".", "cov", "(", "distparam_no_nan", ",", "rowvar", "=", "False", ")", "\n", "\n", "# compute niqe quality, Eq. 10 in the paper", "\n", "invcov_param", "=", "np", ".", "linalg", ".", "pinv", "(", "(", "cov_pris_param", "+", "cov_distparam", ")", "/", "2", ")", "\n", "quality", "=", "np", ".", "matmul", "(", "\n", "np", ".", "matmul", "(", "(", "mu_pris_param", "-", "mu_distparam", ")", ",", "invcov_param", ")", ",", "np", ".", "transpose", "(", "(", "mu_pris_param", "-", "mu_distparam", ")", ")", ")", "\n", "\n", "quality", "=", "np", ".", "sqrt", "(", "quality", ")", "\n", "quality", "=", "np", ".", "squeeze", "(", "quality", ")", "\n", "return", "quality", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.calculate_niqe": [[141, 195], ["numpy.load", "basicsr.metrics.metric_util.to_y_channel.astype", "basicsr.metrics.metric_util.to_y_channel.round", "niqe.niqe", "basicsr.metrics.metric_util.reorder_image", "numpy.squeeze", "basicsr.metrics.metric_util.to_y_channel", "cv2.cvtColor"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.niqe.niqe", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.reorder_image", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.metric_util.to_y_channel"], ["", "def", "calculate_niqe", "(", "img", ",", "crop_border", ",", "input_order", "=", "'HWC'", ",", "convert_to", "=", "'y'", ")", ":", "\n", "    ", "\"\"\"Calculate NIQE (Natural Image Quality Evaluator) metric.\n\n    Ref: Making a \"Completely Blind\" Image Quality Analyzer.\n    This implementation could produce almost the same results as the official\n    MATLAB codes: http://live.ece.utexas.edu/research/quality/niqe_release.zip\n\n    > MATLAB R2021a result for tests/data/baboon.png: 5.72957338 (5.7296)\n    > Our re-implementation result for tests/data/baboon.png: 5.7295763 (5.7296)\n\n    We use the official params estimated from the pristine dataset.\n    We use the recommended block size (96, 96) without overlaps.\n\n    Args:\n        img (ndarray): Input image whose quality needs to be computed.\n            The input image must be in range [0, 255] with float/int type.\n            The input_order of image can be 'HW' or 'HWC' or 'CHW'. (BGR order)\n            If the input order is 'HWC' or 'CHW', it will be converted to gray\n            or Y (of YCbCr) image according to the ``convert_to`` argument.\n        crop_border (int): Cropped pixels in each edge of an image. These\n            pixels are not involved in the metric calculation.\n        input_order (str): Whether the input order is 'HW', 'HWC' or 'CHW'.\n            Default: 'HWC'.\n        convert_to (str): Whether coverted to 'y' (of MATLAB YCbCr) or 'gray'.\n            Default: 'y'.\n\n    Returns:\n        float: NIQE result.\n    \"\"\"", "\n", "\n", "# we use the official params estimated from the pristine dataset.", "\n", "niqe_pris_params", "=", "np", ".", "load", "(", "'basicsr/metrics/niqe_pris_params.npz'", ")", "\n", "mu_pris_param", "=", "niqe_pris_params", "[", "'mu_pris_param'", "]", "\n", "cov_pris_param", "=", "niqe_pris_params", "[", "'cov_pris_param'", "]", "\n", "gaussian_window", "=", "niqe_pris_params", "[", "'gaussian_window'", "]", "\n", "\n", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "input_order", "!=", "'HW'", ":", "\n", "        ", "img", "=", "reorder_image", "(", "img", ",", "input_order", "=", "input_order", ")", "\n", "if", "convert_to", "==", "'y'", ":", "\n", "            ", "img", "=", "to_y_channel", "(", "img", ")", "\n", "", "elif", "convert_to", "==", "'gray'", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", "/", "255.", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "*", "255.", "\n", "", "img", "=", "np", ".", "squeeze", "(", "img", ")", "\n", "\n", "", "if", "crop_border", "!=", "0", ":", "\n", "        ", "img", "=", "img", "[", "crop_border", ":", "-", "crop_border", ",", "crop_border", ":", "-", "crop_border", "]", "\n", "\n", "# round is necessary for being consistent with MATLAB's result", "\n", "", "img", "=", "img", ".", "round", "(", ")", "\n", "\n", "niqe_result", "=", "niqe", "(", "img", ",", "mu_pris_param", ",", "cov_pris_param", ",", "gaussian_window", ")", "\n", "\n", "return", "niqe_result", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.L2pooling.__init__": [[9, 18], ["torch.Module.__init__", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "dists_pytorch.L2pooling.register_buffer", "numpy.hanning", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "g[].repeat"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "filter_size", "=", "5", ",", "stride", "=", "2", ",", "channels", "=", "None", ",", "pad_off", "=", "0", ")", ":", "\n", "        ", "super", "(", "L2pooling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "padding", "=", "(", "filter_size", "-", "2", ")", "//", "2", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "channels", "=", "channels", "\n", "a", "=", "np", ".", "hanning", "(", "filter_size", ")", "[", "1", ":", "-", "1", "]", "\n", "g", "=", "torch", ".", "Tensor", "(", "a", "[", ":", ",", "None", "]", "*", "a", "[", "None", ",", ":", "]", ")", "\n", "g", "=", "g", "/", "torch", ".", "sum", "(", "g", ")", "\n", "self", ".", "register_buffer", "(", "'filter'", ",", "g", "[", "None", ",", "None", ",", ":", ",", ":", "]", ".", "repeat", "(", "(", "self", ".", "channels", ",", "1", ",", "1", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.L2pooling.forward": [[19, 23], ["torch.conv2d", "torch.conv2d", "torch.conv2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "input", "=", "input", "**", "2", "\n", "out", "=", "F", ".", "conv2d", "(", "input", ",", "self", ".", "filter", ",", "stride", "=", "self", ".", "stride", ",", "padding", "=", "self", ".", "padding", ",", "groups", "=", "input", ".", "shape", "[", "1", "]", ")", "\n", "return", "(", "out", "+", "1e-12", ")", ".", "sqrt", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.__init__": [[26, 65], ["super().__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "range", "dists_pytorch.DISTS.stage2.add_module", "range", "dists_pytorch.DISTS.stage3.add_module", "range", "dists_pytorch.DISTS.stage4.add_module", "range", "dists_pytorch.DISTS.stage5.add_module", "range", "dists_pytorch.DISTS.parameters", "dists_pytorch.DISTS.register_buffer", "dists_pytorch.DISTS.register_buffer", "dists_pytorch.DISTS.register_parameter", "dists_pytorch.DISTS.register_parameter", "dists_pytorch.DISTS.alpha.data.normal_", "dists_pytorch.DISTS.beta.data.normal_", "torchvision.models.vgg16", "dists_pytorch.DISTS.stage1.add_module", "str", "dists_pytorch.L2pooling", "dists_pytorch.DISTS.stage2.add_module", "str", "dists_pytorch.L2pooling", "dists_pytorch.DISTS.stage3.add_module", "str", "dists_pytorch.L2pooling", "dists_pytorch.DISTS.stage4.add_module", "str", "dists_pytorch.L2pooling", "dists_pytorch.DISTS.stage5.add_module", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.tensor().view", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "str", "str", "str", "str", "str", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "sum", "sum"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "load_weights", "=", "True", ")", ":", "\n", "        ", "super", "(", "DISTS", ",", "self", ")", ".", "__init__", "(", ")", "\n", "vgg_pretrained_features", "=", "models", ".", "vgg16", "(", "pretrained", "=", "True", ")", ".", "features", "\n", "self", ".", "stage1", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "stage2", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "stage3", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "stage4", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "stage5", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "for", "x", "in", "range", "(", "0", ",", "4", ")", ":", "\n", "            ", "self", ".", "stage1", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "self", ".", "stage2", ".", "add_module", "(", "str", "(", "4", ")", ",", "L2pooling", "(", "channels", "=", "64", ")", ")", "\n", "for", "x", "in", "range", "(", "5", ",", "9", ")", ":", "\n", "            ", "self", ".", "stage2", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "self", ".", "stage3", ".", "add_module", "(", "str", "(", "9", ")", ",", "L2pooling", "(", "channels", "=", "128", ")", ")", "\n", "for", "x", "in", "range", "(", "10", ",", "16", ")", ":", "\n", "            ", "self", ".", "stage3", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "self", ".", "stage4", ".", "add_module", "(", "str", "(", "16", ")", ",", "L2pooling", "(", "channels", "=", "256", ")", ")", "\n", "for", "x", "in", "range", "(", "17", ",", "23", ")", ":", "\n", "            ", "self", ".", "stage4", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "self", ".", "stage5", ".", "add_module", "(", "str", "(", "23", ")", ",", "L2pooling", "(", "channels", "=", "512", ")", ")", "\n", "for", "x", "in", "range", "(", "24", ",", "30", ")", ":", "\n", "            ", "self", ".", "stage5", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "\n", "", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "register_buffer", "(", "\"mean\"", ",", "torch", ".", "tensor", "(", "[", "0.485", ",", "0.456", ",", "0.406", "]", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "self", ".", "register_buffer", "(", "\"std\"", ",", "torch", ".", "tensor", "(", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ".", "view", "(", "1", ",", "-", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "self", ".", "chns", "=", "[", "3", ",", "64", ",", "128", ",", "256", ",", "512", ",", "512", "]", "\n", "self", ".", "register_parameter", "(", "\"alpha\"", ",", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "1", ",", "sum", "(", "self", ".", "chns", ")", ",", "1", ",", "1", ")", ")", ")", "\n", "self", ".", "register_parameter", "(", "\"beta\"", ",", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "1", ",", "sum", "(", "self", ".", "chns", ")", ",", "1", ",", "1", ")", ")", ")", "\n", "self", ".", "alpha", ".", "data", ".", "normal_", "(", "0.1", ",", "0.01", ")", "\n", "self", ".", "beta", ".", "data", ".", "normal_", "(", "0.1", ",", "0.01", ")", "\n", "if", "load_weights", ":", "\n", "# weights = torch.load(os.path.join(sys.prefix, 'weights.pt'))", "\n", "            ", "weights", "=", "torch", ".", "load", "(", "'/raid/liangjie/BasicSR_ALL_/scripts/metrics/DISTS/DISTS_pytorch/weights.pt'", ")", "\n", "self", ".", "alpha", ".", "data", "=", "weights", "[", "'alpha'", "]", "\n", "self", ".", "beta", ".", "data", "=", "weights", "[", "'beta'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.forward_once": [[66, 79], ["dists_pytorch.DISTS.stage1", "dists_pytorch.DISTS.stage2", "dists_pytorch.DISTS.stage3", "dists_pytorch.DISTS.stage4", "dists_pytorch.DISTS.stage5"], "methods", ["None"], ["", "", "def", "forward_once", "(", "self", ",", "x", ")", ":", "\n", "        ", "h", "=", "(", "x", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "h", "=", "self", ".", "stage1", "(", "h", ")", "\n", "h_relu1_2", "=", "h", "\n", "h", "=", "self", ".", "stage2", "(", "h", ")", "\n", "h_relu2_2", "=", "h", "\n", "h", "=", "self", ".", "stage3", "(", "h", ")", "\n", "h_relu3_3", "=", "h", "\n", "h", "=", "self", ".", "stage4", "(", "h", ")", "\n", "h_relu4_3", "=", "h", "\n", "h", "=", "self", ".", "stage5", "(", "h", ")", "\n", "h_relu5_3", "=", "h", "\n", "return", "[", "x", ",", "h_relu1_2", ",", "h_relu2_2", ",", "h_relu3_3", ",", "h_relu4_3", ",", "h_relu5_3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.forward": [[80, 112], ["torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "torch.split", "range", "dists_pytorch.DISTS.forward_once", "dists_pytorch.DISTS.forward_once", "dists_pytorch.DISTS.alpha.sum", "dists_pytorch.DISTS.beta.sum", "len", "feats0[].mean", "feats1[].mean", "score.mean", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "dists_pytorch.DISTS.forward_once", "dists_pytorch.DISTS.forward_once"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.forward_once", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.forward_once", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.forward_once", "home.repos.pwc.inspect_result.csjliang_dasr.metrics.dists_pytorch.DISTS.forward_once"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ",", "require_grad", "=", "False", ",", "batch_average", "=", "False", ")", ":", "\n", "        ", "if", "require_grad", ":", "\n", "            ", "feats0", "=", "self", ".", "forward_once", "(", "x", ")", "\n", "feats1", "=", "self", ".", "forward_once", "(", "y", ")", "\n", "", "else", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "feats0", "=", "self", ".", "forward_once", "(", "x", ")", "\n", "feats1", "=", "self", ".", "forward_once", "(", "y", ")", "\n", "", "", "dist1", "=", "0", "\n", "dist2", "=", "0", "\n", "c1", "=", "1e-6", "\n", "c2", "=", "1e-6", "\n", "w_sum", "=", "self", ".", "alpha", ".", "sum", "(", ")", "+", "self", ".", "beta", ".", "sum", "(", ")", "\n", "alpha", "=", "torch", ".", "split", "(", "self", ".", "alpha", "/", "w_sum", ",", "self", ".", "chns", ",", "dim", "=", "1", ")", "\n", "beta", "=", "torch", ".", "split", "(", "self", ".", "beta", "/", "w_sum", ",", "self", ".", "chns", ",", "dim", "=", "1", ")", "\n", "for", "k", "in", "range", "(", "len", "(", "self", ".", "chns", ")", ")", ":", "\n", "            ", "x_mean", "=", "feats0", "[", "k", "]", ".", "mean", "(", "[", "2", ",", "3", "]", ",", "keepdim", "=", "True", ")", "\n", "y_mean", "=", "feats1", "[", "k", "]", ".", "mean", "(", "[", "2", ",", "3", "]", ",", "keepdim", "=", "True", ")", "\n", "S1", "=", "(", "2", "*", "x_mean", "*", "y_mean", "+", "c1", ")", "/", "(", "x_mean", "**", "2", "+", "y_mean", "**", "2", "+", "c1", ")", "\n", "dist1", "=", "dist1", "+", "(", "alpha", "[", "k", "]", "*", "S1", ")", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "x_var", "=", "(", "(", "feats0", "[", "k", "]", "-", "x_mean", ")", "**", "2", ")", ".", "mean", "(", "[", "2", ",", "3", "]", ",", "keepdim", "=", "True", ")", "\n", "y_var", "=", "(", "(", "feats1", "[", "k", "]", "-", "y_mean", ")", "**", "2", ")", ".", "mean", "(", "[", "2", ",", "3", "]", ",", "keepdim", "=", "True", ")", "\n", "xy_cov", "=", "(", "feats0", "[", "k", "]", "*", "feats1", "[", "k", "]", ")", ".", "mean", "(", "[", "2", ",", "3", "]", ",", "keepdim", "=", "True", ")", "-", "x_mean", "*", "y_mean", "\n", "S2", "=", "(", "2", "*", "xy_cov", "+", "c2", ")", "/", "(", "x_var", "+", "y_var", "+", "c2", ")", "\n", "dist2", "=", "dist2", "+", "(", "beta", "[", "k", "]", "*", "S2", ")", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "", "score", "=", "1", "-", "(", "dist1", "+", "dist2", ")", ".", "squeeze", "(", ")", "\n", "if", "batch_average", ":", "\n", "            ", "return", "score", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "score", "", "", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.__init__.calculate_metric": [[10, 21], ["copy.deepcopy", "copy.deepcopy.pop", "basicsr.utils.registry.METRIC_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["from", ".", "train", "import", "*", "\n", "from", ".", "utils", "import", "*", "\n", "# from .version import __gitsha__, __version__", "\n", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.fid.load_patched_inception_v3": [[10, 16], ["basicsr.archs.inception.InceptionV3", "torch.DataParallel().eval().to", "torch.DataParallel().eval", "torch.DataParallel"], "function", ["None"], ["def", "load_patched_inception_v3", "(", "device", "=", "'cuda'", ",", "resize_input", "=", "True", ",", "normalize_input", "=", "False", ")", ":", "\n", "# we may not resize the input, but in [rosinality/stylegan2-pytorch] it", "\n", "# does resize the input.", "\n", "    ", "inception", "=", "InceptionV3", "(", "[", "3", "]", ",", "resize_input", "=", "resize_input", ",", "normalize_input", "=", "normalize_input", ")", "\n", "inception", "=", "nn", ".", "DataParallel", "(", "inception", ")", ".", "eval", "(", ")", ".", "to", "(", "device", ")", "\n", "return", "inception", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.fid.extract_inception_features": [[18, 48], ["torch.no_grad", "torch.no_grad", "torch.cat", "torch.cat", "tqdm.tqdm", "data.to.to", "[].view", "torch.cat.append", "tqdm.tqdm.close", "tqdm.tqdm.update", "[].view.to", "inception"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "extract_inception_features", "(", "data_generator", ",", "inception", ",", "len_generator", "=", "None", ",", "device", "=", "'cuda'", ")", ":", "\n", "    ", "\"\"\"Extract inception features.\n\n    Args:\n        data_generator (generator): A data generator.\n        inception (nn.Module): Inception model.\n        len_generator (int): Length of the data_generator to show the\n            progressbar. Default: None.\n        device (str): Device. Default: cuda.\n\n    Returns:\n        Tensor: Extracted features.\n    \"\"\"", "\n", "if", "len_generator", "is", "not", "None", ":", "\n", "        ", "pbar", "=", "tqdm", "(", "total", "=", "len_generator", ",", "unit", "=", "'batch'", ",", "desc", "=", "'Extract'", ")", "\n", "", "else", ":", "\n", "        ", "pbar", "=", "None", "\n", "", "features", "=", "[", "]", "\n", "\n", "for", "data", "in", "data_generator", ":", "\n", "        ", "if", "pbar", ":", "\n", "            ", "pbar", ".", "update", "(", "1", ")", "\n", "", "data", "=", "data", ".", "to", "(", "device", ")", "\n", "feature", "=", "inception", "(", "data", ")", "[", "0", "]", ".", "view", "(", "data", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "features", ".", "append", "(", "feature", ".", "to", "(", "'cpu'", ")", ")", "\n", "", "if", "pbar", ":", "\n", "        ", "pbar", ".", "close", "(", ")", "\n", "", "features", "=", "torch", ".", "cat", "(", "features", ",", "0", ")", "\n", "return", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.fid.calculate_fid": [[50, 94], ["scipy.linalg.sqrtm", "numpy.iscomplexobj", "numpy.isfinite().all", "print", "scipy.linalg.sqrtm", "numpy.eye", "numpy.allclose", "numpy.max", "ValueError", "numpy.trace", "numpy.trace", "numpy.trace", "numpy.isfinite", "numpy.abs", "numpy.diagonal"], "function", ["None"], ["", "def", "calculate_fid", "(", "mu1", ",", "sigma1", ",", "mu2", ",", "sigma2", ",", "eps", "=", "1e-6", ")", ":", "\n", "    ", "\"\"\"Numpy implementation of the Frechet Distance.\n\n    The Frechet distance between two multivariate Gaussians X_1 ~ N(mu_1, C_1)\n    and X_2 ~ N(mu_2, C_2) is\n        d^2 = ||mu_1 - mu_2||^2 + Tr(C_1 + C_2 - 2*sqrt(C_1*C_2)).\n    Stable version by Dougal J. Sutherland.\n\n    Args:\n        mu1 (np.array): The sample mean over activations.\n        sigma1 (np.array): The covariance matrix over activations for\n            generated samples.\n        mu2 (np.array): The sample mean over activations, precalculated on an\n               representative data set.\n        sigma2 (np.array): The covariance matrix over activations,\n            precalculated on an representative data set.\n\n    Returns:\n        float: The Frechet Distance.\n    \"\"\"", "\n", "assert", "mu1", ".", "shape", "==", "mu2", ".", "shape", ",", "'Two mean vectors have different lengths'", "\n", "assert", "sigma1", ".", "shape", "==", "sigma2", ".", "shape", ",", "(", "'Two covariances have different dimensions'", ")", "\n", "\n", "cov_sqrt", ",", "_", "=", "linalg", ".", "sqrtm", "(", "sigma1", "@", "sigma2", ",", "disp", "=", "False", ")", "\n", "\n", "# Product might be almost singular", "\n", "if", "not", "np", ".", "isfinite", "(", "cov_sqrt", ")", ".", "all", "(", ")", ":", "\n", "        ", "print", "(", "'Product of cov matrices is singular. Adding {eps} to diagonal '", "'of cov estimates'", ")", "\n", "offset", "=", "np", ".", "eye", "(", "sigma1", ".", "shape", "[", "0", "]", ")", "*", "eps", "\n", "cov_sqrt", "=", "linalg", ".", "sqrtm", "(", "(", "sigma1", "+", "offset", ")", "@", "(", "sigma2", "+", "offset", ")", ")", "\n", "\n", "# Numerical error might give slight imaginary component", "\n", "", "if", "np", ".", "iscomplexobj", "(", "cov_sqrt", ")", ":", "\n", "        ", "if", "not", "np", ".", "allclose", "(", "np", ".", "diagonal", "(", "cov_sqrt", ")", ".", "imag", ",", "0", ",", "atol", "=", "1e-3", ")", ":", "\n", "            ", "m", "=", "np", ".", "max", "(", "np", ".", "abs", "(", "cov_sqrt", ".", "imag", ")", ")", "\n", "raise", "ValueError", "(", "f'Imaginary component {m}'", ")", "\n", "", "cov_sqrt", "=", "cov_sqrt", ".", "real", "\n", "\n", "", "mean_diff", "=", "mu1", "-", "mu2", "\n", "mean_norm", "=", "mean_diff", "@", "mean_diff", "\n", "trace", "=", "np", ".", "trace", "(", "sigma1", ")", "+", "np", ".", "trace", "(", "sigma2", ")", "-", "2", "*", "np", ".", "trace", "(", "cov_sqrt", ")", "\n", "fid", "=", "mean_norm", "+", "trace", "\n", "\n", "return", "fid", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.table_calculate_psnr_all.main": [[12, 129], ["range", "len", "os.path.join", "os.path.join", "print", "sorted", "os.makedirs", "glob.glob", "os.path.exists", "enumerate", "print", "os.path.join", "print", "print", "os.path.splitext", "open", "f.write", "open", "f.write", "os.path.basename", "basicsr.metrics.calculate_psnr", "psnr_all.append", "cv2.imread().astype", "img_path.split", "os.path.join", "cv2.imread().astype", "range", "range", "basicsr.utils.matlab_functions.bgr2ycbcr", "basicsr.utils.matlab_functions.bgr2ycbcr", "open", "f.write", "sum", "len", "os.path.join", "mean_l.append", "std_l.append", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "cv2.imread", "os.path.join", "cv2.imread", "numpy.mean", "numpy.std", "os.path.join", "os.path.join", "os.path.join", "file_name.split", "file_name.split", "file_name.split", "file_name.split"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.psnr_ssim.calculate_psnr", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.bgr2ycbcr", "home.repos.pwc.inspect_result.csjliang_dasr.utils.matlab_functions.bgr2ycbcr"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Calculate PSNR and SSIM for images.\n\n    Configurations:\n        folder_gt (str): Path to gt (Ground-Truth).\n        folder_restored (str): Path to restored images.\n        crop_border (int): Crop border for each side.\n        suffix (str): Suffix for restored images.\n        test_y_channel (bool): If True, test Y channel (In MatLab YCbCr format)\n            If False, test RGB channels.\n    \"\"\"", "\n", "\n", "log_save_path", "=", "'results/table_logs_all/'", "\n", "\n", "data_root", "=", "'results/Compare'", "\n", "ref_root", "=", "'datasets/'", "\n", "ref_dirs", "=", "[", "'DIV2K/DIV2K_valid_HR/'", "]", "\n", "datasets", "=", "[", "'DIV2K100'", "]", "\n", "methods", "=", "[", "'LDL'", "]", "\n", "\n", "logoverall_path", "=", "log_save_path", "+", "'all_avgs/PSNR_all_avgs.txt'", "\n", "\n", "for", "index", "in", "range", "(", "len", "(", "ref_dirs", ")", ")", ":", "\n", "        ", "ref_dir", "=", "os", ".", "path", ".", "join", "(", "ref_root", ",", "ref_dirs", "[", "index", "]", ")", "\n", "for", "method", "in", "methods", ":", "\n", "            ", "img_dir", "=", "os", ".", "path", ".", "join", "(", "data_root", ",", "method", ",", "datasets", "[", "index", "]", ")", "\n", "print", "(", "img_dir", ")", "\n", "\n", "img_list", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "img_dir", ",", "'*'", ")", ")", ")", "\n", "\n", "os", ".", "makedirs", "(", "log_save_path", ",", "exist_ok", "=", "True", ")", "\n", "log_path", "=", "log_save_path", "+", "'PSNR__'", "+", "method", "+", "'__'", "+", "datasets", "[", "index", "]", "+", "'.txt'", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "log_path", ")", ":", "\n", "\n", "                ", "crop_border", "=", "4", "\n", "suffix", "=", "''", "\n", "test_y_channel", "=", "True", "\n", "correct_mean_var", "=", "False", "\n", "# -------------------------------------------------------------------------", "\n", "\n", "psnr_all", "=", "[", "]", "\n", "\n", "if", "test_y_channel", ":", "\n", "                    ", "print", "(", "'Testing Y channel.'", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "'Testing RGB channels.'", ")", "\n", "\n", "", "for", "i", ",", "img_path", "in", "enumerate", "(", "img_list", ")", ":", "\n", "                    ", "basename", ",", "ext", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "img_path", ")", ")", "\n", "try", ":", "\n", "                        ", "img_restored", "=", "cv2", ".", "imread", "(", "img_path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", ".", "astype", "(", "\n", "np", ".", "float32", ")", "/", "255.", "\n", "\n", "file_name", "=", "img_path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "if", "'DIV2K100'", "in", "img_dir", "and", "'SFTGAN'", "not", "in", "img_dir", ":", "\n", "                            ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", "[", ":", "4", "]", "+", "'.png'", ")", "\n", "", "elif", "'Urban100'", "in", "img_dir", "and", "'SFTGAN'", "not", "in", "img_dir", ":", "\n", "                            ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", "[", ":", "7", "]", "+", "'.png'", ")", "\n", "", "elif", "'SFTGAN'", "in", "img_dir", ":", "\n", "                            ", "ref_dir_SFTGAN", "=", "'/data1/liangjie/BasicSR_ALL/results/Compare/SFTGAN_official/GT'", "\n", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir_SFTGAN", ",", "file_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'_gt.png'", ")", "\n", "if", "'Urban100'", "in", "img_dir", ":", "\n", "                                ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir_SFTGAN", ",", "\n", "file_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'_'", "+", "file_name", ".", "split", "(", "'_'", ")", "[", "\n", "1", "]", "+", "'_gt.png'", ")", "\n", "", "", "else", ":", "\n", "                            ", "if", "'_'", "in", "file_name", ":", "\n", "                                ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'.png'", ")", "\n", "", "else", ":", "\n", "                                ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", ")", "\n", "\n", "", "", "img_gt", "=", "cv2", ".", "imread", "(", "gt_path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "\n", "\n", "if", "correct_mean_var", ":", "\n", "                            ", "mean_l", "=", "[", "]", "\n", "std_l", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "                                ", "mean_l", ".", "append", "(", "np", ".", "mean", "(", "img_gt", "[", ":", ",", ":", ",", "j", "]", ")", ")", "\n", "std_l", ".", "append", "(", "np", ".", "std", "(", "img_gt", "[", ":", ",", ":", ",", "j", "]", ")", ")", "\n", "", "for", "j", "in", "range", "(", "3", ")", ":", "\n", "# correct twice", "\n", "                                ", "mean", "=", "np", ".", "mean", "(", "img_restored", "[", ":", ",", ":", ",", "j", "]", ")", "\n", "img_restored", "[", ":", ",", ":", ",", "\n", "j", "]", "=", "img_restored", "[", ":", ",", ":", ",", "j", "]", "-", "mean", "+", "mean_l", "[", "j", "]", "\n", "std", "=", "np", ".", "std", "(", "img_restored", "[", ":", ",", ":", ",", "j", "]", ")", "\n", "img_restored", "[", ":", ",", ":", ",", "j", "]", "=", "img_restored", "[", ":", ",", ":", ",", "j", "]", "/", "std", "*", "std_l", "[", "j", "]", "\n", "\n", "mean", "=", "np", ".", "mean", "(", "img_restored", "[", ":", ",", ":", ",", "j", "]", ")", "\n", "img_restored", "[", ":", ",", ":", ",", "\n", "j", "]", "=", "img_restored", "[", ":", ",", ":", ",", "j", "]", "-", "mean", "+", "mean_l", "[", "j", "]", "\n", "std", "=", "np", ".", "std", "(", "img_restored", "[", ":", ",", ":", ",", "j", "]", ")", "\n", "img_restored", "[", ":", ",", ":", ",", "j", "]", "=", "img_restored", "[", ":", ",", ":", ",", "j", "]", "/", "std", "*", "std_l", "[", "j", "]", "\n", "\n", "", "", "if", "test_y_channel", "and", "img_gt", ".", "ndim", "==", "3", "and", "img_gt", ".", "shape", "[", "2", "]", "==", "3", ":", "\n", "                            ", "img_gt", "=", "bgr2ycbcr", "(", "img_gt", ",", "y_only", "=", "True", ")", "\n", "img_restored", "=", "bgr2ycbcr", "(", "img_restored", ",", "y_only", "=", "True", ")", "\n", "\n", "# calculate PSNR", "\n", "", "psnr", "=", "calculate_psnr", "(", "\n", "img_gt", "*", "255", ",", "\n", "img_restored", "*", "255", ",", "\n", "crop_border", "=", "crop_border", ",", "\n", "input_order", "=", "'HWC'", ")", "\n", "psnr_all", ".", "append", "(", "psnr", ")", "\n", "log", "=", "f'{i + 1:3d}: {file_name:25}. \\tPSNR: {psnr:.6f}.'", "\n", "with", "open", "(", "log_path", ",", "'a'", ")", "as", "f", ":", "\n", "                            ", "f", ".", "write", "(", "log", "+", "'\\n'", ")", "\n", "", "", "except", ":", "\n", "                        ", "pass", "\n", "", "", "log", "=", "f'Average: PSNR: {sum(psnr_all) / len(psnr_all):.6f}'", "\n", "with", "open", "(", "log_path", ",", "'a'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "log", "+", "'\\n'", ")", "\n", "", "log_overall", "=", "method", "+", "'__'", "+", "datasets", "[", "index", "]", "+", "'__'", "+", "log", "\n", "with", "open", "(", "logoverall_path", ",", "'a'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "log_overall", "+", "'\\n'", ")", "\n", "", "print", "(", "log_overall", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.metrics.table_calculate_lpips_all.main": [[17, 87], ["range", "len", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "sorted", "os.makedirs", "os.makedirs", "glob.glob", "os.path.exists", "os.path.exists", "lpips.LPIPS().cuda", "enumerate", "print", "os.path.join", "os.path.join", "basicsr.utils.img2tensor", "torchvision.transforms.functional.normalize", "torchvision.transforms.functional.normalize", "lpips.LPIPS().cuda.", "print", "lpips_all.append", "open", "f.write", "open", "f.write", "lpips.LPIPS", "img_path.split", "os.path.join", "os.path.join", "cv2.imread().astype", "cv2.imread().astype", "img_restored.unsqueeze().cuda", "img_gt.unsqueeze().cuda", "open", "f.write", "loss_fn_vgg.item", "os.path.join", "os.path.join", "loss_fn_vgg.item", "sum", "len", "os.path.join", "os.path.join", "cv2.imread", "cv2.imread", "img_restored.unsqueeze", "img_gt.unsqueeze", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "file_name.split", "file_name.split", "file_name.split", "file_name.split"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor"], ["def", "main", "(", ")", ":", "\n", "\n", "    ", "log_save_path", "=", "'results/table_logs_all/'", "\n", "\n", "data_root", "=", "'results/Compare'", "\n", "ref_root", "=", "'datasets/'", "\n", "ref_dirs", "=", "[", "'DIV2K/DIV2K_valid_HR/'", "]", "\n", "datasets", "=", "[", "'DIV2K100'", "]", "\n", "methods", "=", "[", "'LDL'", "]", "\n", "\n", "logoverall_path", "=", "log_save_path", "+", "'all_avgs/lpips_all_avgs.txt'", "\n", "\n", "for", "index", "in", "range", "(", "len", "(", "ref_dirs", ")", ")", ":", "\n", "        ", "ref_dir", "=", "os", ".", "path", ".", "join", "(", "ref_root", ",", "ref_dirs", "[", "index", "]", ")", "\n", "for", "method", "in", "methods", ":", "\n", "            ", "img_dir", "=", "os", ".", "path", ".", "join", "(", "data_root", ",", "method", ",", "datasets", "[", "index", "]", ")", "\n", "\n", "img_list", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "img_dir", ",", "'*'", ")", ")", ")", "\n", "\n", "os", ".", "makedirs", "(", "log_save_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "log_path", "=", "log_save_path", "+", "'lpips__'", "+", "method", "+", "'__'", "+", "datasets", "[", "index", "]", "+", "'.txt'", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "log_path", ")", ":", "\n", "\n", "                ", "loss_fn_vgg", "=", "lpips", ".", "LPIPS", "(", "net", "=", "'alex'", ")", ".", "cuda", "(", ")", "# RGB, normalized to [-1,1]", "\n", "lpips_all", "=", "[", "]", "\n", "\n", "mean", "=", "[", "0.5", ",", "0.5", ",", "0.5", "]", "\n", "std", "=", "[", "0.5", ",", "0.5", ",", "0.5", "]", "\n", "for", "i", ",", "img_path", "in", "enumerate", "(", "img_list", ")", ":", "\n", "                    ", "file_name", "=", "img_path", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "if", "'DIV2K100'", "in", "img_dir", "and", "'SFTGAN'", "not", "in", "img_dir", ":", "\n", "                        ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", "[", ":", "4", "]", "+", "'.png'", ")", "\n", "", "elif", "'Urban100'", "in", "img_dir", "and", "'SFTGAN'", "not", "in", "img_dir", ":", "\n", "                        ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", "[", ":", "7", "]", "+", "'.png'", ")", "\n", "", "elif", "'SFTGAN'", "in", "img_dir", ":", "\n", "                        ", "ref_dir_SFTGAN", "=", "'results/Compare/SFTGAN_official/GT'", "\n", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir_SFTGAN", ",", "file_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'_gt.png'", ")", "\n", "if", "'Urban100'", "in", "img_dir", ":", "\n", "                            ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir_SFTGAN", ",", "file_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'_'", "+", "file_name", ".", "split", "(", "'_'", ")", "[", "1", "]", "+", "'_gt.png'", ")", "\n", "", "", "else", ":", "\n", "                        ", "if", "'_'", "in", "file_name", ":", "\n", "                            ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", ".", "split", "(", "'_'", ")", "[", "0", "]", "+", "'.png'", ")", "\n", "", "else", ":", "\n", "                            ", "gt_path", "=", "os", ".", "path", ".", "join", "(", "ref_dir", ",", "file_name", ")", "\n", "\n", "", "", "img_restored", "=", "cv2", ".", "imread", "(", "img_path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "\n", "img_gt", "=", "cv2", ".", "imread", "(", "gt_path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "\n", "\n", "img_gt", ",", "img_restored", "=", "img2tensor", "(", "[", "img_gt", ",", "img_restored", "]", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "\n", "# norm to [-1, 1]", "\n", "normalize", "(", "img_gt", ",", "mean", ",", "std", ",", "inplace", "=", "True", ")", "\n", "normalize", "(", "img_restored", ",", "mean", ",", "std", ",", "inplace", "=", "True", ")", "\n", "\n", "# calculate lpips", "\n", "lpips_val", "=", "loss_fn_vgg", "(", "img_restored", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ",", "img_gt", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ")", "\n", "log", "=", "f'{i+1:3d}: {file_name:25}. \\tLPIPS: {lpips_val.item():.6f}.'", "\n", "with", "open", "(", "log_path", ",", "'a'", ")", "as", "f", ":", "\n", "                        ", "f", ".", "write", "(", "log", "+", "'\\n'", ")", "\n", "", "print", "(", "log", ")", "\n", "lpips_all", ".", "append", "(", "lpips_val", ".", "item", "(", ")", ")", "\n", "\n", "", "log", "=", "f'Average: LPIPS: {sum(lpips_all) / len(lpips_all):.6f}'", "\n", "with", "open", "(", "log_path", ",", "'a'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "log", "+", "'\\n'", ")", "\n", "", "log_overall", "=", "method", "+", "'__'", "+", "datasets", "[", "index", "]", "+", "'__'", "+", "log", "\n", "with", "open", "(", "logoverall_path", ",", "'a'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "log_overall", "+", "'\\n'", ")", "\n", "", "print", "(", "log_overall", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.PrefetchGenerator.__init__": [[18, 24], ["threading.Thread.__init__", "queue.Queue", "prefetch_dataloader.PrefetchGenerator.start"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "generator", ",", "num_prefetch_queue", ")", ":", "\n", "        ", "threading", ".", "Thread", ".", "__init__", "(", "self", ")", "\n", "self", ".", "queue", "=", "Queue", ".", "Queue", "(", "num_prefetch_queue", ")", "\n", "self", ".", "generator", "=", "generator", "\n", "self", ".", "daemon", "=", "True", "\n", "self", ".", "start", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.PrefetchGenerator.run": [[25, 29], ["prefetch_dataloader.PrefetchGenerator.queue.put", "prefetch_dataloader.PrefetchGenerator.queue.put"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.put", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.put"], ["", "def", "run", "(", "self", ")", ":", "\n", "        ", "for", "item", "in", "self", ".", "generator", ":", "\n", "            ", "self", ".", "queue", ".", "put", "(", "item", ")", "\n", "", "self", ".", "queue", ".", "put", "(", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.PrefetchGenerator.__next__": [[30, 35], ["prefetch_dataloader.PrefetchGenerator.queue.get"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "next_item", "=", "self", ".", "queue", ".", "get", "(", ")", "\n", "if", "next_item", "is", "None", ":", "\n", "            ", "raise", "StopIteration", "\n", "", "return", "next_item", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.PrefetchGenerator.__iter__": [[36, 38], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.PrefetchDataLoader.__init__": [[55, 58], ["torch.utils.data.DataLoader.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "num_prefetch_queue", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "num_prefetch_queue", "=", "num_prefetch_queue", "\n", "super", "(", "PrefetchDataLoader", ",", "self", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.PrefetchDataLoader.__iter__": [[59, 61], ["prefetch_dataloader.PrefetchGenerator", "torch.utils.data.DataLoader.__iter__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.data.data_sampler.EnlargedSampler.__iter__"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "PrefetchGenerator", "(", "super", "(", ")", ".", "__iter__", "(", ")", ",", "self", ".", "num_prefetch_queue", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CPUPrefetcher.__init__": [[70, 73], ["iter"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "loader", ")", ":", "\n", "        ", "self", ".", "ori_loader", "=", "loader", "\n", "self", ".", "loader", "=", "iter", "(", "loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CPUPrefetcher.next": [[74, 79], ["prefetch_dataloader.CPUPrefetcher.next"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.next"], ["", "def", "next", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "return", "next", "(", "self", ".", "loader", ")", "\n", "", "except", "StopIteration", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CPUPrefetcher.reset": [[80, 82], ["iter"], "methods", ["None"], ["", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "loader", "=", "iter", "(", "self", ".", "ori_loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.__init__": [[97, 104], ["iter", "torch.cuda.Stream", "torch.device", "prefetch_dataloader.CUDAPrefetcher.preload"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.preload"], ["def", "__init__", "(", "self", ",", "loader", ",", "opt", ")", ":", "\n", "        ", "self", ".", "ori_loader", "=", "loader", "\n", "self", ".", "loader", "=", "iter", "(", "loader", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "self", ".", "stream", "=", "torch", ".", "cuda", ".", "Stream", "(", ")", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "opt", "[", "'num_gpu'", "]", "!=", "0", "else", "'cpu'", ")", "\n", "self", ".", "preload", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.preload": [[105, 116], ["prefetch_dataloader.CUDAPrefetcher.next"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.next"], ["", "def", "preload", "(", "self", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "self", ".", "batch", "=", "next", "(", "self", ".", "loader", ")", "# self.batch is a dict", "\n", "", "except", "StopIteration", ":", "\n", "            ", "self", ".", "batch", "=", "None", "\n", "return", "None", "\n", "# put tensors to gpu", "\n", "", "with", "torch", ".", "cuda", ".", "stream", "(", "self", ".", "stream", ")", ":", "\n", "            ", "for", "k", ",", "v", "in", "self", ".", "batch", ".", "items", "(", ")", ":", "\n", "                ", "if", "torch", ".", "is_tensor", "(", "v", ")", ":", "\n", "                    ", "self", ".", "batch", "[", "k", "]", "=", "self", ".", "batch", "[", "k", "]", ".", "to", "(", "device", "=", "self", ".", "device", ",", "non_blocking", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.next": [[117, 122], ["torch.cuda.current_stream().wait_stream", "prefetch_dataloader.CUDAPrefetcher.preload", "torch.cuda.current_stream"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.preload"], ["", "", "", "", "def", "next", "(", "self", ")", ":", "\n", "        ", "torch", ".", "cuda", ".", "current_stream", "(", ")", ".", "wait_stream", "(", "self", ".", "stream", ")", "\n", "batch", "=", "self", ".", "batch", "\n", "self", ".", "preload", "(", ")", "\n", "return", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.reset": [[123, 126], ["iter", "prefetch_dataloader.CUDAPrefetcher.preload"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.data.prefetch_dataloader.CUDAPrefetcher.preload"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "loader", "=", "iter", "(", "self", ".", "ori_loader", ")", "\n", "self", ".", "preload", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.mod_crop": [[7, 25], ["img.copy.copy", "ValueError"], "function", ["None"], ["def", "mod_crop", "(", "img", ",", "scale", ")", ":", "\n", "    ", "\"\"\"Mod crop images, used during testing.\n\n    Args:\n        img (ndarray): Input image.\n        scale (int): Scale factor.\n\n    Returns:\n        ndarray: Result image.\n    \"\"\"", "\n", "img", "=", "img", ".", "copy", "(", ")", "\n", "if", "img", ".", "ndim", "in", "(", "2", ",", "3", ")", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", "\n", "h_remainder", ",", "w_remainder", "=", "h", "%", "scale", ",", "w", "%", "scale", "\n", "img", "=", "img", "[", ":", "h", "-", "h_remainder", ",", ":", "w", "-", "w_remainder", ",", "...", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Wrong img ndim: {img.ndim}.'", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop": [[27, 93], ["random.randint", "random.randint", "isinstance", "isinstance", "torch.is_tensor", "ValueError", "ValueError", "int", "int", "len", "len", "img_lqs[].size", "img_gts[].size"], "function", ["None"], ["", "def", "paired_random_crop", "(", "img_gts", ",", "img_lqs", ",", "gt_patch_size", ",", "scale", ",", "gt_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"Paired random crop. Support Numpy array and Tensor inputs.\n\n    It crops lists of lq and gt images with corresponding locations.\n\n    Args:\n        img_gts (list[ndarray] | ndarray | list[Tensor] | Tensor): GT images. Note that all images\n            should have the same shape. If the input is an ndarray, it will\n            be transformed to a list containing itself.\n        img_lqs (list[ndarray] | ndarray): LQ images. Note that all images\n            should have the same shape. If the input is an ndarray, it will\n            be transformed to a list containing itself.\n        gt_patch_size (int): GT patch size.\n        scale (int): Scale factor.\n        gt_path (str): Path to ground-truth. Default: None.\n\n    Returns:\n        list[ndarray] | ndarray: GT images and LQ images. If returned results\n            only have one element, just return ndarray.\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "img_gts", ",", "list", ")", ":", "\n", "        ", "img_gts", "=", "[", "img_gts", "]", "\n", "", "if", "not", "isinstance", "(", "img_lqs", ",", "list", ")", ":", "\n", "        ", "img_lqs", "=", "[", "img_lqs", "]", "\n", "\n", "# determine input type: Numpy array or Tensor", "\n", "", "input_type", "=", "'Tensor'", "if", "torch", ".", "is_tensor", "(", "img_gts", "[", "0", "]", ")", "else", "'Numpy'", "\n", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "h_lq", ",", "w_lq", "=", "img_lqs", "[", "0", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "h_gt", ",", "w_gt", "=", "img_gts", "[", "0", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "", "else", ":", "\n", "        ", "h_lq", ",", "w_lq", "=", "img_lqs", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "h_gt", ",", "w_gt", "=", "img_gts", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "", "lq_patch_size", "=", "gt_patch_size", "//", "scale", "\n", "\n", "if", "h_gt", "!=", "h_lq", "*", "scale", "or", "w_gt", "!=", "w_lq", "*", "scale", ":", "\n", "        ", "raise", "ValueError", "(", "f'Scale mismatches. GT ({h_gt}, {w_gt}) is not {scale}x '", ",", "\n", "f'multiplication of LQ ({h_lq}, {w_lq}).'", ")", "\n", "", "if", "h_lq", "<", "lq_patch_size", "or", "w_lq", "<", "lq_patch_size", ":", "\n", "        ", "raise", "ValueError", "(", "f'LQ ({h_lq}, {w_lq}) is smaller than patch size '", "\n", "f'({lq_patch_size}, {lq_patch_size}). '", "\n", "f'Please remove {gt_path}.'", ")", "\n", "\n", "# randomly choose top and left coordinates for lq patch", "\n", "", "top", "=", "random", ".", "randint", "(", "0", ",", "h_lq", "-", "lq_patch_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_lq", "-", "lq_patch_size", ")", "\n", "\n", "# crop lq patch", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "img_lqs", "=", "[", "v", "[", ":", ",", ":", ",", "top", ":", "top", "+", "lq_patch_size", ",", "left", ":", "left", "+", "lq_patch_size", "]", "for", "v", "in", "img_lqs", "]", "\n", "", "else", ":", "\n", "        ", "img_lqs", "=", "[", "v", "[", "top", ":", "top", "+", "lq_patch_size", ",", "left", ":", "left", "+", "lq_patch_size", ",", "...", "]", "for", "v", "in", "img_lqs", "]", "\n", "\n", "# crop corresponding gt patch", "\n", "", "top_gt", ",", "left_gt", "=", "int", "(", "top", "*", "scale", ")", ",", "int", "(", "left", "*", "scale", ")", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "img_gts", "=", "[", "v", "[", ":", ",", ":", ",", "top_gt", ":", "top_gt", "+", "gt_patch_size", ",", "left_gt", ":", "left_gt", "+", "gt_patch_size", "]", "for", "v", "in", "img_gts", "]", "\n", "", "else", ":", "\n", "        ", "img_gts", "=", "[", "v", "[", "top_gt", ":", "top_gt", "+", "gt_patch_size", ",", "left_gt", ":", "left_gt", "+", "gt_patch_size", ",", "...", "]", "for", "v", "in", "img_gts", "]", "\n", "", "if", "len", "(", "img_gts", ")", "==", "1", ":", "\n", "        ", "img_gts", "=", "img_gts", "[", "0", "]", "\n", "", "if", "len", "(", "img_lqs", ")", "==", "1", ":", "\n", "        ", "img_lqs", "=", "img_lqs", "[", "0", "]", "\n", "", "return", "img_gts", ",", "img_lqs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop_return_indexes": [[94, 160], ["random.randint", "random.randint", "isinstance", "isinstance", "torch.is_tensor", "ValueError", "ValueError", "int", "int", "len", "len", "img_lqs[].size", "img_gts[].size"], "function", ["None"], ["", "def", "paired_random_crop_return_indexes", "(", "img_gts", ",", "img_lqs", ",", "gt_patch_size", ",", "scale", ",", "gt_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"Paired random crop. Support Numpy array and Tensor inputs.\n\n    It crops lists of lq and gt images with corresponding locations.\n\n    Args:\n        img_gts (list[ndarray] | ndarray | list[Tensor] | Tensor): GT images. Note that all images\n            should have the same shape. If the input is an ndarray, it will\n            be transformed to a list containing itself.\n        img_lqs (list[ndarray] | ndarray): LQ images. Note that all images\n            should have the same shape. If the input is an ndarray, it will\n            be transformed to a list containing itself.\n        gt_patch_size (int): GT patch size.\n        scale (int): Scale factor.\n        gt_path (str): Path to ground-truth. Default: None.\n\n    Returns:\n        list[ndarray] | ndarray: GT images and LQ images. If returned results\n            only have one element, just return ndarray.\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "img_gts", ",", "list", ")", ":", "\n", "        ", "img_gts", "=", "[", "img_gts", "]", "\n", "", "if", "not", "isinstance", "(", "img_lqs", ",", "list", ")", ":", "\n", "        ", "img_lqs", "=", "[", "img_lqs", "]", "\n", "\n", "# determine input type: Numpy array or Tensor", "\n", "", "input_type", "=", "'Tensor'", "if", "torch", ".", "is_tensor", "(", "img_gts", "[", "0", "]", ")", "else", "'Numpy'", "\n", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "h_lq", ",", "w_lq", "=", "img_lqs", "[", "0", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "h_gt", ",", "w_gt", "=", "img_gts", "[", "0", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "", "else", ":", "\n", "        ", "h_lq", ",", "w_lq", "=", "img_lqs", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "h_gt", ",", "w_gt", "=", "img_gts", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "", "lq_patch_size", "=", "gt_patch_size", "//", "scale", "\n", "\n", "if", "h_gt", "!=", "h_lq", "*", "scale", "or", "w_gt", "!=", "w_lq", "*", "scale", ":", "\n", "        ", "raise", "ValueError", "(", "f'Scale mismatches. GT ({h_gt}, {w_gt}) is not {scale}x '", ",", "\n", "f'multiplication of LQ ({h_lq}, {w_lq}).'", ")", "\n", "", "if", "h_lq", "<", "lq_patch_size", "or", "w_lq", "<", "lq_patch_size", ":", "\n", "        ", "raise", "ValueError", "(", "f'LQ ({h_lq}, {w_lq}) is smaller than patch size '", "\n", "f'({lq_patch_size}, {lq_patch_size}). '", "\n", "f'Please remove {gt_path}.'", ")", "\n", "\n", "# randomly choose top and left coordinates for lq patch", "\n", "", "top", "=", "random", ".", "randint", "(", "0", ",", "h_lq", "-", "lq_patch_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_lq", "-", "lq_patch_size", ")", "\n", "\n", "# crop lq patch", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "img_lqs", "=", "[", "v", "[", ":", ",", ":", ",", "top", ":", "top", "+", "lq_patch_size", ",", "left", ":", "left", "+", "lq_patch_size", "]", "for", "v", "in", "img_lqs", "]", "\n", "", "else", ":", "\n", "        ", "img_lqs", "=", "[", "v", "[", "top", ":", "top", "+", "lq_patch_size", ",", "left", ":", "left", "+", "lq_patch_size", ",", "...", "]", "for", "v", "in", "img_lqs", "]", "\n", "\n", "# crop corresponding gt patch", "\n", "", "top_gt", ",", "left_gt", "=", "int", "(", "top", "*", "scale", ")", ",", "int", "(", "left", "*", "scale", ")", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "img_gts", "=", "[", "v", "[", ":", ",", ":", ",", "top_gt", ":", "top_gt", "+", "gt_patch_size", ",", "left_gt", ":", "left_gt", "+", "gt_patch_size", "]", "for", "v", "in", "img_gts", "]", "\n", "", "else", ":", "\n", "        ", "img_gts", "=", "[", "v", "[", "top_gt", ":", "top_gt", "+", "gt_patch_size", ",", "left_gt", ":", "left_gt", "+", "gt_patch_size", ",", "...", "]", "for", "v", "in", "img_gts", "]", "\n", "", "if", "len", "(", "img_gts", ")", "==", "1", ":", "\n", "        ", "img_gts", "=", "img_gts", "[", "0", "]", "\n", "", "if", "len", "(", "img_lqs", ")", "==", "1", ":", "\n", "        ", "img_lqs", "=", "img_lqs", "[", "0", "]", "\n", "", "return", "img_gts", ",", "img_lqs", ",", "top", ",", "left", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop_by_indexes": [[161, 227], ["isinstance", "isinstance", "torch.is_tensor", "ValueError", "ValueError", "int", "int", "len", "len", "img_lqs[].size", "img_gts[].size"], "function", ["None"], ["", "def", "paired_random_crop_by_indexes", "(", "img_gts", ",", "img_lqs", ",", "gt_patch_size", ",", "scale", ",", "top", ",", "left", ",", "gt_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"Paired random crop. Support Numpy array and Tensor inputs.\n\n    It crops lists of lq and gt images with corresponding locations.\n\n    Args:\n        img_gts (list[ndarray] | ndarray | list[Tensor] | Tensor): GT images. Note that all images\n            should have the same shape. If the input is an ndarray, it will\n            be transformed to a list containing itself.\n        img_lqs (list[ndarray] | ndarray): LQ images. Note that all images\n            should have the same shape. If the input is an ndarray, it will\n            be transformed to a list containing itself.\n        gt_patch_size (int): GT patch size.\n        scale (int): Scale factor.\n        gt_path (str): Path to ground-truth. Default: None.\n\n    Returns:\n        list[ndarray] | ndarray: GT images and LQ images. If returned results\n            only have one element, just return ndarray.\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "img_gts", ",", "list", ")", ":", "\n", "        ", "img_gts", "=", "[", "img_gts", "]", "\n", "", "if", "not", "isinstance", "(", "img_lqs", ",", "list", ")", ":", "\n", "        ", "img_lqs", "=", "[", "img_lqs", "]", "\n", "\n", "# determine input type: Numpy array or Tensor", "\n", "", "input_type", "=", "'Tensor'", "if", "torch", ".", "is_tensor", "(", "img_gts", "[", "0", "]", ")", "else", "'Numpy'", "\n", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "h_lq", ",", "w_lq", "=", "img_lqs", "[", "0", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "h_gt", ",", "w_gt", "=", "img_gts", "[", "0", "]", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "", "else", ":", "\n", "        ", "h_lq", ",", "w_lq", "=", "img_lqs", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "h_gt", ",", "w_gt", "=", "img_gts", "[", "0", "]", ".", "shape", "[", "0", ":", "2", "]", "\n", "", "lq_patch_size", "=", "gt_patch_size", "//", "scale", "\n", "\n", "if", "h_gt", "!=", "h_lq", "*", "scale", "or", "w_gt", "!=", "w_lq", "*", "scale", ":", "\n", "        ", "raise", "ValueError", "(", "f'Scale mismatches. GT ({h_gt}, {w_gt}) is not {scale}x '", ",", "\n", "f'multiplication of LQ ({h_lq}, {w_lq}).'", ")", "\n", "", "if", "h_lq", "<", "lq_patch_size", "or", "w_lq", "<", "lq_patch_size", ":", "\n", "        ", "raise", "ValueError", "(", "f'LQ ({h_lq}, {w_lq}) is smaller than patch size '", "\n", "f'({lq_patch_size}, {lq_patch_size}). '", "\n", "f'Please remove {gt_path}.'", ")", "\n", "\n", "# # randomly choose top and left coordinates for lq patch", "\n", "# top = random.randint(0, h_lq - lq_patch_size)", "\n", "# left = random.randint(0, w_lq - lq_patch_size)", "\n", "\n", "# crop lq patch", "\n", "", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "img_lqs", "=", "[", "v", "[", ":", ",", ":", ",", "top", ":", "top", "+", "lq_patch_size", ",", "left", ":", "left", "+", "lq_patch_size", "]", "for", "v", "in", "img_lqs", "]", "\n", "", "else", ":", "\n", "        ", "img_lqs", "=", "[", "v", "[", "top", ":", "top", "+", "lq_patch_size", ",", "left", ":", "left", "+", "lq_patch_size", ",", "...", "]", "for", "v", "in", "img_lqs", "]", "\n", "\n", "# crop corresponding gt patch", "\n", "", "top_gt", ",", "left_gt", "=", "int", "(", "top", "*", "scale", ")", ",", "int", "(", "left", "*", "scale", ")", "\n", "if", "input_type", "==", "'Tensor'", ":", "\n", "        ", "img_gts", "=", "[", "v", "[", ":", ",", ":", ",", "top_gt", ":", "top_gt", "+", "gt_patch_size", ",", "left_gt", ":", "left_gt", "+", "gt_patch_size", "]", "for", "v", "in", "img_gts", "]", "\n", "", "else", ":", "\n", "        ", "img_gts", "=", "[", "v", "[", "top_gt", ":", "top_gt", "+", "gt_patch_size", ",", "left_gt", ":", "left_gt", "+", "gt_patch_size", ",", "...", "]", "for", "v", "in", "img_gts", "]", "\n", "", "if", "len", "(", "img_gts", ")", "==", "1", ":", "\n", "        ", "img_gts", "=", "img_gts", "[", "0", "]", "\n", "", "if", "len", "(", "img_lqs", ")", "==", "1", ":", "\n", "        ", "img_lqs", "=", "img_lqs", "[", "0", "]", "\n", "", "return", "img_gts", ",", "img_lqs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.unpaired_random_crop": [[228, 267], ["isinstance", "isinstance", "ValueError", "random.randint", "random.randint", "random.randint", "random.randint", "numpy.random.uniform", "numpy.random.uniform", "round", "round", "random.randint", "random.randint", "random.randint", "random.randint", "len", "len", "min", "min"], "function", ["None"], ["", "def", "unpaired_random_crop", "(", "img_lqs", ",", "img_refs", ",", "if_fix", ",", "patch_size", ")", ":", "\n", "\n", "    ", "if", "not", "isinstance", "(", "img_lqs", ",", "list", ")", ":", "\n", "        ", "img_lqs", "=", "[", "img_lqs", "]", "\n", "", "if", "not", "isinstance", "(", "img_refs", ",", "list", ")", ":", "\n", "        ", "img_refs", "=", "[", "img_refs", "]", "\n", "\n", "", "h_lq", ",", "w_lq", ",", "_", "=", "img_lqs", "[", "0", "]", ".", "shape", "\n", "h_ref", ",", "w_ref", ",", "_", "=", "img_refs", "[", "0", "]", ".", "shape", "\n", "\n", "if", "h_lq", "<", "patch_size", "or", "w_lq", "<", "patch_size", ":", "\n", "        ", "raise", "ValueError", "(", "f'LQ ({h_lq}, {w_lq}) is smaller than patch size '", "\n", "f'({patch_size}, {patch_size}). '", ")", "\n", "\n", "# randomly choose top and left coordinates for lq patch", "\n", "", "if", "if_fix", ":", "\n", "        ", "top", "=", "random", ".", "randint", "(", "0", ",", "h_lq", "-", "patch_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_lq", "-", "patch_size", ")", "\n", "img_lqs", "=", "[", "v", "[", "top", ":", "top", "+", "patch_size", ",", "left", ":", "left", "+", "patch_size", ",", "...", "]", "for", "v", "in", "img_lqs", "]", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h_ref", "-", "patch_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_ref", "-", "patch_size", ")", "\n", "img_refs", "=", "[", "v", "[", "top", ":", "top", "+", "patch_size", ",", "left", ":", "left", "+", "patch_size", ",", "...", "]", "for", "v", "in", "img_refs", "]", "\n", "", "else", ":", "\n", "        ", "ratio_h", "=", "np", ".", "random", ".", "uniform", "(", "0.6", ",", "1.0", ")", "\n", "ratio_w", "=", "np", ".", "random", ".", "uniform", "(", "0.6", ",", "1.0", ")", "\n", "size_h", "=", "round", "(", "min", "(", "h_lq", ",", "h_ref", ")", "*", "ratio_h", ")", "\n", "size_w", "=", "round", "(", "min", "(", "w_lq", ",", "w_ref", ")", "*", "ratio_w", ")", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h_lq", "-", "size_h", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_lq", "-", "size_w", ")", "\n", "img_lqs", "=", "[", "v", "[", "top", ":", "top", "+", "size_h", ",", "left", ":", "left", "+", "size_w", ",", "...", "]", "for", "v", "in", "img_lqs", "]", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h_ref", "-", "size_h", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_ref", "-", "size_w", ")", "\n", "img_refs", "=", "[", "v", "[", "top", ":", "top", "+", "size_h", ",", "left", ":", "left", "+", "size_w", ",", "...", "]", "for", "v", "in", "img_refs", "]", "\n", "\n", "", "if", "len", "(", "img_lqs", ")", "==", "1", ":", "\n", "        ", "img_lqs", "=", "img_lqs", "[", "0", "]", "\n", "", "if", "len", "(", "img_refs", ")", "==", "1", ":", "\n", "        ", "img_refs", "=", "img_refs", "[", "0", "]", "\n", "", "return", "img_lqs", ",", "img_refs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.random_crop": [[269, 300], ["print", "isinstance", "ValueError", "random.randint", "random.randint", "numpy.random.uniform", "numpy.random.uniform", "round", "round", "random.randint", "random.randint", "len"], "function", ["None"], ["", "def", "random_crop", "(", "imgs", ",", "if_fix", ",", "patch_size", ")", ":", "\n", "\n", "    ", "if", "not", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "        ", "imgs", "=", "[", "imgs", "]", "\n", "\n", "", "print", "(", "imgs", "[", "0", "]", ".", "shape", ")", "\n", "\n", "h_lq", ",", "w_lq", ",", "_", "=", "imgs", "[", "0", "]", ".", "shape", "\n", "\n", "if", "h_lq", "<", "patch_size", "or", "w_lq", "<", "patch_size", ":", "\n", "        ", "raise", "ValueError", "(", "f'LQ ({h_lq}, {w_lq}) is smaller than patch size '", "\n", "f'({patch_size}, {patch_size}). '", ")", "\n", "\n", "# randomly choose top and left coordinates for lq patch", "\n", "", "if", "if_fix", ":", "\n", "        ", "top", "=", "random", ".", "randint", "(", "0", ",", "h_lq", "-", "patch_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_lq", "-", "patch_size", ")", "\n", "imgs", "=", "[", "v", "[", "top", ":", "top", "+", "patch_size", ",", "left", ":", "left", "+", "patch_size", ",", "...", "]", "for", "v", "in", "imgs", "]", "\n", "", "else", ":", "\n", "        ", "ratio_h", "=", "np", ".", "random", ".", "uniform", "(", "0.6", ",", "1.0", ")", "\n", "ratio_w", "=", "np", ".", "random", ".", "uniform", "(", "0.6", ",", "1.0", ")", "\n", "size_h", "=", "round", "(", "h_lq", "*", "ratio_h", ")", "\n", "size_w", "=", "round", "(", "w_lq", "*", "ratio_w", ")", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h_lq", "-", "size_h", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w_lq", "-", "size_w", ")", "\n", "imgs", "=", "[", "v", "[", "top", ":", "top", "+", "size_h", ",", "left", ":", "left", "+", "size_w", ",", "...", "]", "for", "v", "in", "imgs", "]", "\n", "\n", "", "if", "len", "(", "imgs", ")", "==", "1", ":", "\n", "        ", "imgs", "=", "imgs", "[", "0", "]", "\n", "\n", "", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.distort_visual_style": [[301, 315], ["torchvision.to_pil_image", "torchvision.adjust_brightness", "torchvision.adjust_contrast", "torchvision.adjust_hue", "torchvision.adjust_saturation", "torchvision.to_tensor", "random.uniform", "random.uniform", "random.uniform", "random.uniform"], "function", ["None"], ["", "def", "distort_visual_style", "(", "img", ")", ":", "\n", "\n", "#TODO: move the transform parameters to the yml file", "\n", "\n", "    ", "img", "=", "TF", ".", "to_pil_image", "(", "img", ")", "\n", "\n", "img", "=", "TF", ".", "adjust_brightness", "(", "img", ",", "random", ".", "uniform", "(", "0.7", ",", "1.3", ")", ")", "# How much to adjust the brightness. Can be any non negative number. 0 gives a black image, 1 gives the original image while 2 increases the brightness by a factor of 2.", "\n", "img", "=", "TF", ".", "adjust_contrast", "(", "img", ",", "random", ".", "uniform", "(", "0.7", ",", "1.3", ")", ")", "# How much to adjust the contrast. Can be any non negative number. 0 gives a solid gray image, 1 gives the original image while 2 increases the contrast by a factor of 2.", "\n", "img", "=", "TF", ".", "adjust_hue", "(", "img", ",", "random", ".", "uniform", "(", "-", "0.1", ",", "0.1", ")", ")", "# How much to shift the hue channel. Should be in [-0.5, 0.5]. 0.5 and -0.5 give complete reversal of hue channel in HSV space in positive and negative direction respectively. 0 means no shift. Therefore, both -0.5 and 0.5 will give an image with complementary colors while 0 gives the original image.", "\n", "img", "=", "TF", ".", "adjust_saturation", "(", "img", ",", "random", ".", "uniform", "(", "0.9", ",", "1.1", ")", ")", "# How much to adjust the saturation. 0 will give a black and white image, 1 will give the original image while 2 will enhance the saturation by a factor of 2", "\n", "\n", "img", "=", "TF", ".", "to_tensor", "(", "img", ")", "\n", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.augment": [[317, 382], ["isinstance", "transforms.augment._augment"], "function", ["None"], ["", "def", "augment", "(", "imgs", ",", "hflip", "=", "True", ",", "rotation", "=", "True", ",", "flows", "=", "None", ",", "return_status", "=", "False", ")", ":", "\n", "    ", "\"\"\"Augment: horizontal flips OR rotate (0, 90, 180, 270 degrees).\n\n    We use vertical flip and transpose for rotation implementation.\n    All the images in the list use the same augmentation.\n\n    Args:\n        imgs (list[ndarray] | ndarray): Images to be augmented. If the input\n            is an ndarray, it will be transformed to a list.\n        hflip (bool): Horizontal flip. Default: True.\n        rotation (bool): Ratotation. Default: True.\n        flows (list[ndarray]: Flows to be augmented. If the input is an\n            ndarray, it will be transformed to a list.\n            Dimension is (h, w, 2). Default: None.\n        return_status (bool): Return the status of flip and rotation.\n            Default: False.\n\n    Returns:\n        list[ndarray] | ndarray: Augmented images and flows. If returned\n            results only have one element, just return ndarray.\n\n    \"\"\"", "\n", "hflip", "=", "hflip", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "vflip", "=", "rotation", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "rot90", "=", "rotation", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "\n", "def", "_augment", "(", "img", ")", ":", "\n", "        ", "if", "hflip", ":", "# horizontal", "\n", "            ", "cv2", ".", "flip", "(", "img", ",", "1", ",", "img", ")", "\n", "", "if", "vflip", ":", "# vertical", "\n", "            ", "cv2", ".", "flip", "(", "img", ",", "0", ",", "img", ")", "\n", "", "if", "rot90", ":", "\n", "            ", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "", "return", "img", "\n", "\n", "", "def", "_augment_flow", "(", "flow", ")", ":", "\n", "        ", "if", "hflip", ":", "# horizontal", "\n", "            ", "cv2", ".", "flip", "(", "flow", ",", "1", ",", "flow", ")", "\n", "flow", "[", ":", ",", ":", ",", "0", "]", "*=", "-", "1", "\n", "", "if", "vflip", ":", "# vertical", "\n", "            ", "cv2", ".", "flip", "(", "flow", ",", "0", ",", "flow", ")", "\n", "flow", "[", ":", ",", ":", ",", "1", "]", "*=", "-", "1", "\n", "", "if", "rot90", ":", "\n", "            ", "flow", "=", "flow", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "flow", "=", "flow", "[", ":", ",", ":", ",", "[", "1", ",", "0", "]", "]", "\n", "", "return", "flow", "\n", "\n", "", "if", "not", "isinstance", "(", "imgs", ",", "list", ")", ":", "\n", "        ", "imgs", "=", "[", "imgs", "]", "\n", "", "imgs", "=", "[", "_augment", "(", "img", ")", "for", "img", "in", "imgs", "]", "\n", "if", "len", "(", "imgs", ")", "==", "1", ":", "\n", "        ", "imgs", "=", "imgs", "[", "0", "]", "\n", "\n", "", "if", "flows", "is", "not", "None", ":", "\n", "        ", "if", "not", "isinstance", "(", "flows", ",", "list", ")", ":", "\n", "            ", "flows", "=", "[", "flows", "]", "\n", "", "flows", "=", "[", "_augment_flow", "(", "flow", ")", "for", "flow", "in", "flows", "]", "\n", "if", "len", "(", "flows", ")", "==", "1", ":", "\n", "            ", "flows", "=", "flows", "[", "0", "]", "\n", "", "return", "imgs", ",", "flows", "\n", "", "else", ":", "\n", "        ", "if", "return_status", ":", "\n", "            ", "return", "imgs", ",", "(", "hflip", ",", "vflip", ",", "rot90", ")", "\n", "", "else", ":", "\n", "            ", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.img_rotate": [[384, 403], ["cv2.getRotationMatrix2D", "cv2.warpAffine"], "function", ["None"], ["", "", "", "def", "img_rotate", "(", "img", ",", "angle", ",", "center", "=", "None", ",", "scale", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Rotate image.\n\n    Args:\n        img (ndarray): Image to be rotated.\n        angle (float): Rotation angle in degrees. Positive values mean\n            counter-clockwise rotation.\n        center (tuple[int]): Rotation center. If the center is None,\n            initialize it as the center of the image. Default: None.\n        scale (float): Isotropic scale factor. Default: 1.0.\n    \"\"\"", "\n", "(", "h", ",", "w", ")", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "\n", "if", "center", "is", "None", ":", "\n", "        ", "center", "=", "(", "w", "//", "2", ",", "h", "//", "2", ")", "\n", "\n", "", "matrix", "=", "cv2", ".", "getRotationMatrix2D", "(", "center", ",", "angle", ",", "scale", ")", "\n", "rotated_img", "=", "cv2", ".", "warpAffine", "(", "img", ",", "matrix", ",", "(", "w", ",", "h", ")", ")", "\n", "return", "rotated_img", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_sampler.EnlargedSampler.__init__": [[21, 28], ["math.ceil", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "num_replicas", ",", "rank", ",", "ratio", "=", "1", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "num_replicas", "=", "num_replicas", "\n", "self", ".", "rank", "=", "rank", "\n", "self", ".", "epoch", "=", "0", "\n", "self", ".", "num_samples", "=", "math", ".", "ceil", "(", "len", "(", "self", ".", "dataset", ")", "*", "ratio", "/", "self", ".", "num_replicas", ")", "\n", "self", ".", "total_size", "=", "self", ".", "num_samples", "*", "self", ".", "num_replicas", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_sampler.EnlargedSampler.__iter__": [[29, 43], ["torch.Generator", "torch.Generator.manual_seed", "torch.randperm().tolist", "len", "iter", "len", "torch.randperm"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "# deterministically shuffle based on epoch", "\n", "        ", "g", "=", "torch", ".", "Generator", "(", ")", "\n", "g", ".", "manual_seed", "(", "self", ".", "epoch", ")", "\n", "indices", "=", "torch", ".", "randperm", "(", "self", ".", "total_size", ",", "generator", "=", "g", ")", ".", "tolist", "(", ")", "\n", "\n", "dataset_size", "=", "len", "(", "self", ".", "dataset", ")", "\n", "indices", "=", "[", "v", "%", "dataset_size", "for", "v", "in", "indices", "]", "\n", "\n", "# subsample", "\n", "indices", "=", "indices", "[", "self", ".", "rank", ":", "self", ".", "total_size", ":", "self", ".", "num_replicas", "]", "\n", "assert", "len", "(", "indices", ")", "==", "self", ".", "num_samples", "\n", "\n", "return", "iter", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_sampler.EnlargedSampler.__len__": [[44, 46], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_sampler.EnlargedSampler.set_epoch": [[47, 49], ["None"], "methods", ["None"], ["", "def", "set_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "epoch", "=", "epoch", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.read_img_seq": [[11, 41], ["isinstance", "basicsr.utils.img2tensor", "torch.stack", "sorted", "list", "cv2.imread().astype", "basicsr.data.transforms.mod_crop", "basicsr.utils.scandir", "os.path.splitext", "cv2.imread", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.mod_crop", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["def", "read_img_seq", "(", "path", ",", "require_mod_crop", "=", "False", ",", "scale", "=", "1", ",", "return_imgname", "=", "False", ")", ":", "\n", "    ", "\"\"\"Read a sequence of images from a given folder path.\n\n    Args:\n        path (list[str] | str): List of image paths or image folder path.\n        require_mod_crop (bool): Require mod crop for each image.\n            Default: False.\n        scale (int): Scale factor for mod_crop. Default: 1.\n        return_imgname(bool): Whether return image names. Defalt False.\n\n    Returns:\n        Tensor: size (t, c, h, w), RGB, [0, 1].\n        list[str]: Returned image name list.\n    \"\"\"", "\n", "if", "isinstance", "(", "path", ",", "list", ")", ":", "\n", "        ", "img_paths", "=", "path", "\n", "", "else", ":", "\n", "        ", "img_paths", "=", "sorted", "(", "list", "(", "scandir", "(", "path", ",", "full_path", "=", "True", ")", ")", ")", "\n", "", "imgs", "=", "[", "cv2", ".", "imread", "(", "v", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "for", "v", "in", "img_paths", "]", "\n", "\n", "if", "require_mod_crop", ":", "\n", "        ", "imgs", "=", "[", "mod_crop", "(", "img", ",", "scale", ")", "for", "img", "in", "imgs", "]", "\n", "", "imgs", "=", "img2tensor", "(", "imgs", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "\n", "imgs", "=", "torch", ".", "stack", "(", "imgs", ",", "dim", "=", "0", ")", "\n", "\n", "if", "return_imgname", ":", "\n", "        ", "imgnames", "=", "[", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "path", ")", ")", "[", "0", "]", "for", "path", "in", "img_paths", "]", "\n", "return", "imgs", ",", "imgnames", "\n", "", "else", ":", "\n", "        ", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.generate_frame_indices": [[43, 93], ["range", "indices.append"], "function", ["None"], ["", "", "def", "generate_frame_indices", "(", "crt_idx", ",", "max_frame_num", ",", "num_frames", ",", "padding", "=", "'reflection'", ")", ":", "\n", "    ", "\"\"\"Generate an index list for reading `num_frames` frames from a sequence\n    of images.\n\n    Args:\n        crt_idx (int): Current center index.\n        max_frame_num (int): Max number of the sequence of images (from 1).\n        num_frames (int): Reading num_frames frames.\n        padding (str): Padding mode, one of\n            'replicate' | 'reflection' | 'reflection_circle' | 'circle'\n            Examples: current_idx = 0, num_frames = 5\n            The generated frame indices under different padding mode:\n            replicate: [0, 0, 0, 1, 2]\n            reflection: [2, 1, 0, 1, 2]\n            reflection_circle: [4, 3, 0, 1, 2]\n            circle: [3, 4, 0, 1, 2]\n\n    Returns:\n        list[int]: A list of indices.\n    \"\"\"", "\n", "assert", "num_frames", "%", "2", "==", "1", ",", "'num_frames should be an odd number.'", "\n", "assert", "padding", "in", "(", "'replicate'", ",", "'reflection'", ",", "'reflection_circle'", ",", "'circle'", ")", ",", "f'Wrong padding mode: {padding}.'", "\n", "\n", "max_frame_num", "=", "max_frame_num", "-", "1", "# start from 0", "\n", "num_pad", "=", "num_frames", "//", "2", "\n", "\n", "indices", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "crt_idx", "-", "num_pad", ",", "crt_idx", "+", "num_pad", "+", "1", ")", ":", "\n", "        ", "if", "i", "<", "0", ":", "\n", "            ", "if", "padding", "==", "'replicate'", ":", "\n", "                ", "pad_idx", "=", "0", "\n", "", "elif", "padding", "==", "'reflection'", ":", "\n", "                ", "pad_idx", "=", "-", "i", "\n", "", "elif", "padding", "==", "'reflection_circle'", ":", "\n", "                ", "pad_idx", "=", "crt_idx", "+", "num_pad", "-", "i", "\n", "", "else", ":", "\n", "                ", "pad_idx", "=", "num_frames", "+", "i", "\n", "", "", "elif", "i", ">", "max_frame_num", ":", "\n", "            ", "if", "padding", "==", "'replicate'", ":", "\n", "                ", "pad_idx", "=", "max_frame_num", "\n", "", "elif", "padding", "==", "'reflection'", ":", "\n", "                ", "pad_idx", "=", "max_frame_num", "*", "2", "-", "i", "\n", "", "elif", "padding", "==", "'reflection_circle'", ":", "\n", "                ", "pad_idx", "=", "(", "crt_idx", "-", "num_pad", ")", "-", "(", "i", "-", "max_frame_num", ")", "\n", "", "else", ":", "\n", "                ", "pad_idx", "=", "i", "-", "num_frames", "\n", "", "", "else", ":", "\n", "            ", "pad_idx", "=", "i", "\n", "", "indices", ".", "append", "(", "pad_idx", ")", "\n", "", "return", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paired_paths_from_lmdb": [[95, 152], ["len", "len", "ValueError", "open", "open", "set", "set", "ValueError", "sorted", "len", "len", "input_folder.endswith", "gt_folder.endswith", "os.path.join", "os.path.join", "paths.append", "line.split", "line.split", "dict"], "function", ["None"], ["", "def", "paired_paths_from_lmdb", "(", "folders", ",", "keys", ")", ":", "\n", "    ", "\"\"\"Generate paired paths from lmdb files.\n\n    Contents of lmdb. Taking the `lq.lmdb` for example, the file structure is:\n\n    lq.lmdb\n    \u251c\u2500\u2500 data.mdb\n    \u251c\u2500\u2500 lock.mdb\n    \u251c\u2500\u2500 meta_info.txt\n\n    The data.mdb and lock.mdb are standard lmdb files and you can refer to\n    https://lmdb.readthedocs.io/en/release/ for more details.\n\n    The meta_info.txt is a specified txt file to record the meta information\n    of our datasets. It will be automatically created when preparing\n    datasets by our provided dataset tools.\n    Each line in the txt file records\n    1)image name (with extension),\n    2)image shape,\n    3)compression level, separated by a white space.\n    Example: `baboon.png (120,125,3) 1`\n\n    We use the image name without extension as the lmdb key.\n    Note that we use the same key for the corresponding lq and gt images.\n\n    Args:\n        folders (list[str]): A list of folder path. The order of list should\n            be [input_folder, gt_folder].\n        keys (list[str]): A list of keys identifying folders. The order should\n            be in consistent with folders, e.g., ['lq', 'gt'].\n            Note that this key is different from lmdb keys.\n\n    Returns:\n        list[str]: Returned path list.\n    \"\"\"", "\n", "assert", "len", "(", "folders", ")", "==", "2", ",", "(", "'The len of folders should be 2 with [input_folder, gt_folder]. '", "\n", "f'But got {len(folders)}'", ")", "\n", "assert", "len", "(", "keys", ")", "==", "2", ",", "(", "'The len of keys should be 2 with [input_key, gt_key]. '", "f'But got {len(keys)}'", ")", "\n", "input_folder", ",", "gt_folder", "=", "folders", "\n", "input_key", ",", "gt_key", "=", "keys", "\n", "\n", "if", "not", "(", "input_folder", ".", "endswith", "(", "'.lmdb'", ")", "and", "gt_folder", ".", "endswith", "(", "'.lmdb'", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'{input_key} folder and {gt_key} folder should both in lmdb '", "\n", "f'formats. But received {input_key}: {input_folder}; '", "\n", "f'{gt_key}: {gt_folder}'", ")", "\n", "# ensure that the two meta_info files are the same", "\n", "", "with", "open", "(", "osp", ".", "join", "(", "input_folder", ",", "'meta_info.txt'", ")", ")", "as", "fin", ":", "\n", "        ", "input_lmdb_keys", "=", "[", "line", ".", "split", "(", "'.'", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "", "with", "open", "(", "osp", ".", "join", "(", "gt_folder", ",", "'meta_info.txt'", ")", ")", "as", "fin", ":", "\n", "        ", "gt_lmdb_keys", "=", "[", "line", ".", "split", "(", "'.'", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "", "if", "set", "(", "input_lmdb_keys", ")", "!=", "set", "(", "gt_lmdb_keys", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'Keys in {input_key}_folder and {gt_key}_folder are different.'", ")", "\n", "", "else", ":", "\n", "        ", "paths", "=", "[", "]", "\n", "for", "lmdb_key", "in", "sorted", "(", "input_lmdb_keys", ")", ":", "\n", "            ", "paths", ".", "append", "(", "dict", "(", "[", "(", "f'{input_key}_path'", ",", "lmdb_key", ")", ",", "(", "f'{gt_key}_path'", ",", "lmdb_key", ")", "]", ")", ")", "\n", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paired_paths_from_meta_info_file": [[154, 196], ["len", "len", "open", "os.path.splitext", "os.path.join", "os.path.join", "paths.append", "len", "len", "os.path.basename", "dict", "line.split", "filename_tmpl.format"], "function", ["None"], ["", "", "def", "paired_paths_from_meta_info_file", "(", "folders", ",", "keys", ",", "meta_info_file", ",", "filename_tmpl", ")", ":", "\n", "    ", "\"\"\"Generate paired paths from an meta information file.\n\n    Each line in the meta information file contains the image names and\n    image shape (usually for gt), separated by a white space.\n\n    Example of an meta information file:\n    ```\n    0001_s001.png (480,480,3)\n    0001_s002.png (480,480,3)\n    ```\n\n    Args:\n        folders (list[str]): A list of folder path. The order of list should\n            be [input_folder, gt_folder].\n        keys (list[str]): A list of keys identifying folders. The order should\n            be in consistent with folders, e.g., ['lq', 'gt'].\n        meta_info_file (str): Path to the meta information file.\n        filename_tmpl (str): Template for each filename. Note that the\n            template excludes the file extension. Usually the filename_tmpl is\n            for files in the input folder.\n\n    Returns:\n        list[str]: Returned path list.\n    \"\"\"", "\n", "assert", "len", "(", "folders", ")", "==", "2", ",", "(", "'The len of folders should be 2 with [input_folder, gt_folder]. '", "\n", "f'But got {len(folders)}'", ")", "\n", "assert", "len", "(", "keys", ")", "==", "2", ",", "(", "'The len of keys should be 2 with [input_key, gt_key]. '", "f'But got {len(keys)}'", ")", "\n", "input_folder", ",", "gt_folder", "=", "folders", "\n", "input_key", ",", "gt_key", "=", "keys", "\n", "\n", "with", "open", "(", "meta_info_file", ",", "'r'", ")", "as", "fin", ":", "\n", "        ", "gt_names", "=", "[", "line", ".", "split", "(", "' '", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "\n", "", "paths", "=", "[", "]", "\n", "for", "gt_name", "in", "gt_names", ":", "\n", "        ", "basename", ",", "ext", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "gt_name", ")", ")", "\n", "input_name", "=", "f'{filename_tmpl.format(basename)}{ext}'", "\n", "input_path", "=", "osp", ".", "join", "(", "input_folder", ",", "input_name", ")", "\n", "gt_path", "=", "osp", ".", "join", "(", "gt_folder", ",", "gt_name", ")", "\n", "paths", ".", "append", "(", "dict", "(", "[", "(", "f'{input_key}_path'", ",", "input_path", ")", ",", "(", "f'{gt_key}_path'", ",", "gt_path", ")", "]", ")", ")", "\n", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paired_paths_from_folder": [[198, 232], ["list", "list", "len", "len", "basicsr.utils.scandir", "basicsr.utils.scandir", "len", "len", "os.path.splitext", "os.path.join", "os.path.join", "paths.append", "len", "len", "len", "len", "os.path.basename", "dict", "filename_tmpl.format"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "paired_paths_from_folder", "(", "folders", ",", "keys", ",", "filename_tmpl", ")", ":", "\n", "    ", "\"\"\"Generate paired paths from folders.\n\n    Args:\n        folders (list[str]): A list of folder path. The order of list should\n            be [input_folder, gt_folder].\n        keys (list[str]): A list of keys identifying folders. The order should\n            be in consistent with folders, e.g., ['lq', 'gt'].\n        filename_tmpl (str): Template for each filename. Note that the\n            template excludes the file extension. Usually the filename_tmpl is\n            for files in the input folder.\n\n    Returns:\n        list[str]: Returned path list.\n    \"\"\"", "\n", "assert", "len", "(", "folders", ")", "==", "2", ",", "(", "'The len of folders should be 2 with [input_folder, gt_folder]. '", "\n", "f'But got {len(folders)}'", ")", "\n", "assert", "len", "(", "keys", ")", "==", "2", ",", "(", "'The len of keys should be 2 with [input_key, gt_key]. '", "f'But got {len(keys)}'", ")", "\n", "input_folder", ",", "gt_folder", "=", "folders", "\n", "input_key", ",", "gt_key", "=", "keys", "\n", "\n", "input_paths", "=", "list", "(", "scandir", "(", "input_folder", ")", ")", "\n", "gt_paths", "=", "list", "(", "scandir", "(", "gt_folder", ")", ")", "\n", "assert", "len", "(", "input_paths", ")", "==", "len", "(", "gt_paths", ")", ",", "(", "f'{input_key} and {gt_key} datasets have different number of images: '", "\n", "f'{len(input_paths)}, {len(gt_paths)}.'", ")", "\n", "paths", "=", "[", "]", "\n", "for", "gt_path", "in", "gt_paths", ":", "\n", "        ", "basename", ",", "ext", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "gt_path", ")", ")", "\n", "input_name", "=", "f'{filename_tmpl.format(basename)}{ext}'", "\n", "input_path", "=", "osp", ".", "join", "(", "input_folder", ",", "input_name", ")", "\n", "assert", "input_name", "in", "input_paths", ",", "(", "f'{input_name} is not in '", "f'{input_key}_paths.'", ")", "\n", "gt_path", "=", "osp", ".", "join", "(", "gt_folder", ",", "gt_path", ")", "\n", "paths", ".", "append", "(", "dict", "(", "[", "(", "f'{input_key}_path'", ",", "input_path", ")", ",", "(", "f'{gt_key}_path'", ",", "gt_path", ")", "]", ")", ")", "\n", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paths_from_folder": [[234, 247], ["list", "basicsr.utils.scandir", "os.path.join"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "paths_from_folder", "(", "folder", ")", ":", "\n", "    ", "\"\"\"Generate paths from folder.\n\n    Args:\n        folder (str): Folder path.\n\n    Returns:\n        list[str]: Returned path list.\n    \"\"\"", "\n", "\n", "paths", "=", "list", "(", "scandir", "(", "folder", ")", ")", "\n", "paths", "=", "[", "osp", ".", "join", "(", "folder", ",", "path", ")", "for", "path", "in", "paths", "]", "\n", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paths_from_lmdb": [[249, 263], ["folder.endswith", "ValueError", "open", "os.path.join", "line.split"], "function", ["None"], ["", "def", "paths_from_lmdb", "(", "folder", ")", ":", "\n", "    ", "\"\"\"Generate paths from lmdb.\n\n    Args:\n        folder (str): Folder path.\n\n    Returns:\n        list[str]: Returned path list.\n    \"\"\"", "\n", "if", "not", "folder", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "        ", "raise", "ValueError", "(", "f'Folder {folder}folder should in lmdb format.'", ")", "\n", "", "with", "open", "(", "osp", ".", "join", "(", "folder", ",", "'meta_info.txt'", ")", ")", "as", "fin", ":", "\n", "        ", "paths", "=", "[", "line", ".", "split", "(", "'.'", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.generate_gaussian_kernel": [[265, 281], ["numpy.zeros", "filters.gaussian_filter"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.metrics.ssim_pytorch.gaussian_filter"], ["", "def", "generate_gaussian_kernel", "(", "kernel_size", "=", "13", ",", "sigma", "=", "1.6", ")", ":", "\n", "    ", "\"\"\"Generate Gaussian kernel used in `duf_downsample`.\n\n    Args:\n        kernel_size (int): Kernel size. Default: 13.\n        sigma (float): Sigma of the Gaussian kernel. Default: 1.6.\n\n    Returns:\n        np.array: The Gaussian kernel.\n    \"\"\"", "\n", "from", "scipy", ".", "ndimage", "import", "filters", "as", "filters", "\n", "kernel", "=", "np", ".", "zeros", "(", "(", "kernel_size", ",", "kernel_size", ")", ")", "\n", "# set element at the middle to one, a dirac delta", "\n", "kernel", "[", "kernel_size", "//", "2", ",", "kernel_size", "//", "2", "]", "=", "1", "\n", "# gaussian-smooth the dirac, resulting in a gaussian filter", "\n", "return", "filters", ".", "gaussian_filter", "(", "kernel", ",", "sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.duf_downsample": [[283, 314], ["x.squeeze.size", "x.squeeze.view", "torch.nn.functional.pad", "data_util.generate_gaussian_kernel", "torch.from_numpy().type_as().unsqueeze().unsqueeze", "torch.nn.functional.conv2d", "x.squeeze.view", "x.squeeze.unsqueeze", "x.squeeze.size", "x.squeeze.size", "x.squeeze.squeeze", "torch.from_numpy().type_as().unsqueeze", "torch.from_numpy().type_as", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.generate_gaussian_kernel"], ["", "def", "duf_downsample", "(", "x", ",", "kernel_size", "=", "13", ",", "scale", "=", "4", ")", ":", "\n", "    ", "\"\"\"Downsamping with Gaussian kernel used in the DUF official code.\n\n    Args:\n        x (Tensor): Frames to be downsampled, with shape (b, t, c, h, w).\n        kernel_size (int): Kernel size. Default: 13.\n        scale (int): Downsampling factor. Supported scale: (2, 3, 4).\n            Default: 4.\n\n    Returns:\n        Tensor: DUF downsampled frames.\n    \"\"\"", "\n", "assert", "scale", "in", "(", "2", ",", "3", ",", "4", ")", ",", "f'Only support scale (2, 3, 4), but got {scale}.'", "\n", "\n", "squeeze_flag", "=", "False", "\n", "if", "x", ".", "ndim", "==", "4", ":", "\n", "        ", "squeeze_flag", "=", "True", "\n", "x", "=", "x", ".", "unsqueeze", "(", "0", ")", "\n", "", "b", ",", "t", ",", "c", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "1", ",", "h", ",", "w", ")", "\n", "pad_w", ",", "pad_h", "=", "kernel_size", "//", "2", "+", "scale", "*", "2", ",", "kernel_size", "//", "2", "+", "scale", "*", "2", "\n", "x", "=", "F", ".", "pad", "(", "x", ",", "(", "pad_w", ",", "pad_w", ",", "pad_h", ",", "pad_h", ")", ",", "'reflect'", ")", "\n", "\n", "gaussian_filter", "=", "generate_gaussian_kernel", "(", "kernel_size", ",", "0.4", "*", "scale", ")", "\n", "gaussian_filter", "=", "torch", ".", "from_numpy", "(", "gaussian_filter", ")", ".", "type_as", "(", "x", ")", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", "\n", "x", "=", "F", ".", "conv2d", "(", "x", ",", "gaussian_filter", ",", "stride", "=", "scale", ")", "\n", "x", "=", "x", "[", ":", ",", ":", ",", "2", ":", "-", "2", ",", "2", ":", "-", "2", "]", "\n", "x", "=", "x", ".", "view", "(", "b", ",", "t", ",", "c", ",", "x", ".", "size", "(", "2", ")", ",", "x", ".", "size", "(", "3", ")", ")", "\n", "if", "squeeze_flag", ":", "\n", "        ", "x", "=", "x", ".", "squeeze", "(", "0", ")", "\n", "", "return", "x", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.single_image_fixsize_dataset.SingleImageFixSizeDataset.__init__": [[27, 46], ["torch.utils.data.Dataset.__init__", "basicsr.data.data_util.paths_from_lmdb", "sorted", "open", "list", "os.path.join", "basicsr.utils.scandir", "line.split"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paths_from_lmdb", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "SingleImageFixSizeDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "# file client (io backend)", "\n", "self", ".", "file_client", "=", "None", "\n", "self", ".", "io_backend_opt", "=", "opt", "[", "'io_backend'", "]", "\n", "self", ".", "mean", "=", "opt", "[", "'mean'", "]", "if", "'mean'", "in", "opt", "else", "None", "\n", "self", ".", "std", "=", "opt", "[", "'std'", "]", "if", "'std'", "in", "opt", "else", "None", "\n", "self", ".", "lq_folder", "=", "opt", "[", "'dataroot_lq'", "]", "\n", "\n", "if", "self", ".", "io_backend_opt", "[", "'type'", "]", "==", "'lmdb'", ":", "\n", "            ", "self", ".", "io_backend_opt", "[", "'db_paths'", "]", "=", "[", "self", ".", "lq_folder", "]", "\n", "self", ".", "io_backend_opt", "[", "'client_keys'", "]", "=", "[", "'lq'", "]", "\n", "self", ".", "paths", "=", "paths_from_lmdb", "(", "self", ".", "lq_folder", ")", "\n", "", "elif", "'meta_info_file'", "in", "self", ".", "opt", ":", "\n", "            ", "with", "open", "(", "self", ".", "opt", "[", "'meta_info_file'", "]", ",", "'r'", ")", "as", "fin", ":", "\n", "                ", "self", ".", "paths", "=", "[", "osp", ".", "join", "(", "self", ".", "lq_folder", ",", "line", ".", "split", "(", "' '", ")", "[", "0", "]", ")", "for", "line", "in", "fin", "]", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "paths", "=", "sorted", "(", "list", "(", "scandir", "(", "self", ".", "lq_folder", ",", "full_path", "=", "True", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.single_image_fixsize_dataset.SingleImageFixSizeDataset.__getitem__": [[47, 70], ["single_image_fixsize_dataset.SingleImageFixSizeDataset.file_client.get", "basicsr.utils.imfrombytes", "basicsr.utils.img2tensor", "print", "basicsr.utils.FileClient", "basicsr.utils.img2tensor.size", "basicsr.utils.img2tensor.size", "torchvision.transforms.functional.normalize", "single_image_fixsize_dataset.SingleImageFixSizeDataset.io_backend_opt.pop", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "FileClient", "(", "self", ".", "io_backend_opt", ".", "pop", "(", "'type'", ")", ",", "**", "self", ".", "io_backend_opt", ")", "\n", "\n", "# load lq image", "\n", "", "lq_path", "=", "self", ".", "paths", "[", "index", "]", "\n", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "lq_path", ",", "'lq'", ")", "\n", "img_lq", "=", "imfrombytes", "(", "img_bytes", ",", "float32", "=", "True", ")", "\n", "\n", "# TODO: color space transform", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "img_lq", "=", "img2tensor", "(", "img_lq", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "\n", "h", ",", "w", "=", "img_lq", ".", "size", "(", "1", ")", ",", "img_lq", ".", "size", "(", "2", ")", "\n", "max_size_per_side", "=", "1000", "\n", "if", "h", ">", "max_size_per_side", "*", "2", ":", "\n", "            ", "img_lq", "=", "img_lq", "[", ":", ",", "int", "(", "h", "/", "2", ")", "-", "max_size_per_side", ":", "int", "(", "h", "/", "2", ")", "+", "max_size_per_side", ",", ":", "]", "\n", "", "if", "w", ">", "max_size_per_side", "*", "2", ":", "\n", "            ", "img_lq", "=", "img_lq", "[", ":", ",", ":", ",", "int", "(", "w", "/", "2", ")", "-", "max_size_per_side", ":", "int", "(", "w", "/", "2", ")", "+", "max_size_per_side", "]", "\n", "", "print", "(", "img_lq", ".", "shape", ")", "\n", "# normalize", "\n", "if", "self", ".", "mean", "is", "not", "None", "or", "self", ".", "std", "is", "not", "None", ":", "\n", "            ", "normalize", "(", "img_lq", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "inplace", "=", "True", ")", "\n", "", "return", "{", "'lq'", ":", "img_lq", ",", "'lq_path'", ":", "lq_path", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.single_image_fixsize_dataset.SingleImageFixSizeDataset.__len__": [[71, 73], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "paths", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.single_image_dataset.SingleImageDataset.__init__": [[27, 46], ["torch.utils.data.Dataset.__init__", "basicsr.data.data_util.paths_from_lmdb", "sorted", "open", "list", "os.path.join", "basicsr.utils.scandir", "line.split"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paths_from_lmdb", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "SingleImageDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "# file client (io backend)", "\n", "self", ".", "file_client", "=", "None", "\n", "self", ".", "io_backend_opt", "=", "opt", "[", "'io_backend'", "]", "\n", "self", ".", "mean", "=", "opt", "[", "'mean'", "]", "if", "'mean'", "in", "opt", "else", "None", "\n", "self", ".", "std", "=", "opt", "[", "'std'", "]", "if", "'std'", "in", "opt", "else", "None", "\n", "self", ".", "lq_folder", "=", "opt", "[", "'dataroot_lq'", "]", "\n", "\n", "if", "self", ".", "io_backend_opt", "[", "'type'", "]", "==", "'lmdb'", ":", "\n", "            ", "self", ".", "io_backend_opt", "[", "'db_paths'", "]", "=", "[", "self", ".", "lq_folder", "]", "\n", "self", ".", "io_backend_opt", "[", "'client_keys'", "]", "=", "[", "'lq'", "]", "\n", "self", ".", "paths", "=", "paths_from_lmdb", "(", "self", ".", "lq_folder", ")", "\n", "", "elif", "'meta_info_file'", "in", "self", ".", "opt", ":", "\n", "            ", "with", "open", "(", "self", ".", "opt", "[", "'meta_info_file'", "]", ",", "'r'", ")", "as", "fin", ":", "\n", "                ", "self", ".", "paths", "=", "[", "osp", ".", "join", "(", "self", ".", "lq_folder", ",", "line", ".", "split", "(", "' '", ")", "[", "0", "]", ")", "for", "line", "in", "fin", "]", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "paths", "=", "sorted", "(", "list", "(", "scandir", "(", "self", ".", "lq_folder", ",", "full_path", "=", "True", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.single_image_dataset.SingleImageDataset.__getitem__": [[47, 63], ["single_image_dataset.SingleImageDataset.file_client.get", "basicsr.utils.imfrombytes", "basicsr.utils.img2tensor", "basicsr.utils.FileClient", "torchvision.transforms.functional.normalize", "single_image_dataset.SingleImageDataset.io_backend_opt.pop"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "FileClient", "(", "self", ".", "io_backend_opt", ".", "pop", "(", "'type'", ")", ",", "**", "self", ".", "io_backend_opt", ")", "\n", "\n", "# load lq image", "\n", "", "lq_path", "=", "self", ".", "paths", "[", "index", "]", "\n", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "lq_path", ",", "'lq'", ")", "\n", "img_lq", "=", "imfrombytes", "(", "img_bytes", ",", "float32", "=", "True", ")", "\n", "\n", "# TODO: color space transform", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "img_lq", "=", "img2tensor", "(", "img_lq", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "\n", "# normalize", "\n", "if", "self", ".", "mean", "is", "not", "None", "or", "self", ".", "std", "is", "not", "None", ":", "\n", "            ", "normalize", "(", "img_lq", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "inplace", "=", "True", ")", "\n", "", "return", "{", "'lq'", ":", "img_lq", ",", "'lq_path'", ":", "lq_path", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.single_image_dataset.SingleImageDataset.__len__": [[64, 66], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "paths", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.paired_image_dataset.PairedImageDataset.__init__": [[42, 66], ["torch.utils.data.Dataset.__init__", "basicsr.data.data_util.paired_paths_from_lmdb", "basicsr.data.data_util.paired_paths_from_meta_info_file", "basicsr.data.data_util.paired_paths_from_folder"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paired_paths_from_lmdb", "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paired_paths_from_meta_info_file", "home.repos.pwc.inspect_result.csjliang_dasr.data.data_util.paired_paths_from_folder"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "PairedImageDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "# file client (io backend)", "\n", "self", ".", "file_client", "=", "None", "\n", "self", ".", "io_backend_opt", "=", "opt", "[", "'io_backend'", "]", "\n", "self", ".", "mean", "=", "opt", "[", "'mean'", "]", "if", "'mean'", "in", "opt", "else", "None", "\n", "self", ".", "std", "=", "opt", "[", "'std'", "]", "if", "'std'", "in", "opt", "else", "None", "\n", "\n", "self", ".", "gt_folder", ",", "self", ".", "lq_folder", "=", "opt", "[", "'dataroot_gt'", "]", ",", "opt", "[", "'dataroot_lq'", "]", "\n", "if", "'filename_tmpl'", "in", "opt", ":", "\n", "            ", "self", ".", "filename_tmpl", "=", "opt", "[", "'filename_tmpl'", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "filename_tmpl", "=", "'{}'", "\n", "\n", "", "if", "self", ".", "io_backend_opt", "[", "'type'", "]", "==", "'lmdb'", ":", "\n", "            ", "self", ".", "io_backend_opt", "[", "'db_paths'", "]", "=", "[", "self", ".", "lq_folder", ",", "self", ".", "gt_folder", "]", "\n", "self", ".", "io_backend_opt", "[", "'client_keys'", "]", "=", "[", "'lq'", ",", "'gt'", "]", "\n", "self", ".", "paths", "=", "paired_paths_from_lmdb", "(", "[", "self", ".", "lq_folder", ",", "self", ".", "gt_folder", "]", ",", "[", "'lq'", ",", "'gt'", "]", ")", "\n", "", "elif", "'meta_info_file'", "in", "self", ".", "opt", "and", "self", ".", "opt", "[", "'meta_info_file'", "]", "is", "not", "None", ":", "\n", "            ", "self", ".", "paths", "=", "paired_paths_from_meta_info_file", "(", "[", "self", ".", "lq_folder", ",", "self", ".", "gt_folder", "]", ",", "[", "'lq'", ",", "'gt'", "]", ",", "\n", "self", ".", "opt", "[", "'meta_info_file'", "]", ",", "self", ".", "filename_tmpl", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "paths", "=", "paired_paths_from_folder", "(", "[", "self", ".", "lq_folder", ",", "self", ".", "gt_folder", "]", ",", "[", "'lq'", ",", "'gt'", "]", ",", "self", ".", "filename_tmpl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.paired_image_dataset.PairedImageDataset.__getitem__": [[67, 99], ["paired_image_dataset.PairedImageDataset.file_client.get", "basicsr.utils.imfrombytes", "paired_image_dataset.PairedImageDataset.file_client.get", "basicsr.utils.imfrombytes", "basicsr.utils.img2tensor", "basicsr.utils.FileClient", "basicsr.data.transforms.paired_random_crop", "basicsr.data.transforms.augment", "torchvision.transforms.functional.normalize", "torchvision.transforms.functional.normalize", "paired_image_dataset.PairedImageDataset.io_backend_opt.pop"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.paired_random_crop", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.augment"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "FileClient", "(", "self", ".", "io_backend_opt", ".", "pop", "(", "'type'", ")", ",", "**", "self", ".", "io_backend_opt", ")", "\n", "\n", "", "scale", "=", "self", ".", "opt", "[", "'scale'", "]", "\n", "\n", "# Load gt and lq images. Dimension order: HWC; channel order: BGR;", "\n", "# image range: [0, 1], float32.", "\n", "gt_path", "=", "self", ".", "paths", "[", "index", "]", "[", "'gt_path'", "]", "\n", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "gt_path", ",", "'gt'", ")", "\n", "img_gt", "=", "imfrombytes", "(", "img_bytes", ",", "float32", "=", "True", ")", "\n", "lq_path", "=", "self", ".", "paths", "[", "index", "]", "[", "'lq_path'", "]", "\n", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "lq_path", ",", "'lq'", ")", "\n", "img_lq", "=", "imfrombytes", "(", "img_bytes", ",", "float32", "=", "True", ")", "\n", "\n", "# augmentation for training", "\n", "if", "self", ".", "opt", "[", "'phase'", "]", "==", "'train'", ":", "\n", "            ", "gt_size", "=", "self", ".", "opt", "[", "'gt_size'", "]", "\n", "# random crop", "\n", "img_gt", ",", "img_lq", "=", "paired_random_crop", "(", "img_gt", ",", "img_lq", ",", "gt_size", ",", "scale", ",", "gt_path", ")", "\n", "# flip, rotation", "\n", "img_gt", ",", "img_lq", "=", "augment", "(", "[", "img_gt", ",", "img_lq", "]", ",", "self", ".", "opt", "[", "'use_flip'", "]", ",", "self", ".", "opt", "[", "'use_rot'", "]", ")", "\n", "\n", "# TODO: color space transform", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "", "img_gt", ",", "img_lq", "=", "img2tensor", "(", "[", "img_gt", ",", "img_lq", "]", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "\n", "# normalize", "\n", "if", "self", ".", "mean", "is", "not", "None", "or", "self", ".", "std", "is", "not", "None", ":", "\n", "            ", "normalize", "(", "img_lq", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "inplace", "=", "True", ")", "\n", "normalize", "(", "img_gt", ",", "self", ".", "mean", ",", "self", ".", "std", ",", "inplace", "=", "True", ")", "\n", "\n", "", "return", "{", "'lq'", ":", "img_lq", ",", "'gt'", ":", "img_gt", ",", "'lq_path'", ":", "lq_path", ",", "'gt_path'", ":", "gt_path", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.paired_image_dataset.PairedImageDataset.__len__": [[100, 102], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "paths", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataset": [[25, 38], ["copy.deepcopy", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.registry.DATASET_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], []], "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataloader": [[40, 94], ["basicsr.utils.dist_util.get_dist_info", "dataset_opt.get", "dataset_opt.get", "dict", "dataset_opt.get", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.data.prefetch_dataloader.PrefetchDataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "functools.partial", "dict", "ValueError"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.dist_util.get_dist_info", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger"], []], "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.worker_init_fn": [[96, 101], ["numpy.random.seed", "random.seed"], "function", ["None"], []], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.sigma_matrix2": [[17, 31], ["numpy.array", "numpy.array", "numpy.dot", "numpy.dot", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin"], "function", ["None"], ["def", "sigma_matrix2", "(", "sig_x", ",", "sig_y", ",", "theta", ")", ":", "\n", "    ", "\"\"\"Calculate the rotated sigma matrix (two dimensional matrix).\n\n    Args:\n        sig_x (float):\n        sig_y (float):\n        theta (float): Radian measurement.\n\n    Returns:\n        ndarray: Rotated sigma matrix.\n    \"\"\"", "\n", "D", "=", "np", ".", "array", "(", "[", "[", "sig_x", "**", "2", ",", "0", "]", ",", "[", "0", ",", "sig_y", "**", "2", "]", "]", ")", "\n", "U", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "-", "np", ".", "sin", "(", "theta", ")", "]", ",", "[", "np", ".", "sin", "(", "theta", ")", ",", "np", ".", "cos", "(", "theta", ")", "]", "]", ")", "\n", "return", "np", ".", "dot", "(", "U", ",", "np", ".", "dot", "(", "D", ",", "U", ".", "T", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.mesh_grid": [[33, 49], ["numpy.arange", "numpy.meshgrid", "numpy.hstack().reshape", "numpy.hstack", "xx.reshape", "yy.reshape"], "function", ["None"], ["", "def", "mesh_grid", "(", "kernel_size", ")", ":", "\n", "    ", "\"\"\"Generate the mesh grid, centering at zero.\n\n    Args:\n        kernel_size (int):\n\n    Returns:\n        xy (ndarray): with the shape (kernel_size, kernel_size, 2)\n        xx (ndarray): with the shape (kernel_size, kernel_size)\n        yy (ndarray): with the shape (kernel_size, kernel_size)\n    \"\"\"", "\n", "ax", "=", "np", ".", "arange", "(", "-", "kernel_size", "//", "2", "+", "1.", ",", "kernel_size", "//", "2", "+", "1.", ")", "\n", "xx", ",", "yy", "=", "np", ".", "meshgrid", "(", "ax", ",", "ax", ")", "\n", "xy", "=", "np", ".", "hstack", "(", "(", "xx", ".", "reshape", "(", "(", "kernel_size", "*", "kernel_size", ",", "1", ")", ")", ",", "yy", ".", "reshape", "(", "kernel_size", "*", "kernel_size", ",", "\n", "1", ")", ")", ")", ".", "reshape", "(", "kernel_size", ",", "kernel_size", ",", "2", ")", "\n", "return", "xy", ",", "xx", ",", "yy", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.pdf2": [[51, 65], ["numpy.linalg.inv", "numpy.exp", "numpy.sum", "numpy.dot"], "function", ["None"], ["", "def", "pdf2", "(", "sigma_matrix", ",", "grid", ")", ":", "\n", "    ", "\"\"\"Calculate PDF of the bivariate Gaussian distribution.\n\n    Args:\n        sigma_matrix (ndarray): with the shape (2, 2)\n        grid (ndarray): generated by :func:`mesh_grid`,\n            with the shape (K, K, 2), K is the kernel size.\n\n    Returns:\n        kernel (ndarrray): un-normalized kernel.\n    \"\"\"", "\n", "inverse_sigma", "=", "np", ".", "linalg", ".", "inv", "(", "sigma_matrix", ")", "\n", "kernel", "=", "np", ".", "exp", "(", "-", "0.5", "*", "np", ".", "sum", "(", "np", ".", "dot", "(", "grid", ",", "inverse_sigma", ")", "*", "grid", ",", "2", ")", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.cdf2": [[67, 83], ["scipy.stats.multivariate_normal", "numpy.dot", "scipy.stats.multivariate_normal.cdf"], "function", ["None"], ["", "def", "cdf2", "(", "D", ",", "grid", ")", ":", "\n", "    ", "\"\"\"Calculate the CDF of the standard bivariate Gaussian distribution.\n        Used in skewed Gaussian distribution.\n\n    Args:\n        D (ndarrasy): skew matrix.\n        grid (ndarray): generated by :func:`mesh_grid`,\n            with the shape (K, K, 2), K is the kernel size.\n\n    Returns:\n        cdf (ndarray): skewed cdf.\n    \"\"\"", "\n", "rv", "=", "multivariate_normal", "(", "[", "0", ",", "0", "]", ",", "[", "[", "1", ",", "0", "]", ",", "[", "0", ",", "1", "]", "]", ")", "\n", "grid", "=", "np", ".", "dot", "(", "grid", ",", "D", ")", "\n", "cdf", "=", "rv", ".", "cdf", "(", "grid", ")", "\n", "return", "cdf", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_Gaussian": [[85, 111], ["degradations.pdf2", "degradations.mesh_grid", "numpy.array", "degradations.sigma_matrix2", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.pdf2", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.mesh_grid", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.sigma_matrix2"], ["", "def", "bivariate_Gaussian", "(", "kernel_size", ",", "sig_x", ",", "sig_y", ",", "theta", ",", "grid", "=", "None", ",", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Generate a bivariate isotropic or anisotropic Gaussian kernel.\n\n    In the isotropic mode, only `sig_x` is used. `sig_y` and `theta` is ignored.\n\n    Args:\n        kernel_size (int):\n        sig_x (float):\n        sig_y (float):\n        theta (float): Radian measurement.\n        grid (ndarray, optional): generated by :func:`mesh_grid`,\n            with the shape (K, K, 2), K is the kernel size. Default: None\n        isotropic (bool):\n\n    Returns:\n        kernel (ndarray): normalized kernel.\n    \"\"\"", "\n", "if", "grid", "is", "None", ":", "\n", "        ", "grid", ",", "_", ",", "_", "=", "mesh_grid", "(", "kernel_size", ")", "\n", "", "if", "isotropic", ":", "\n", "        ", "sigma_matrix", "=", "np", ".", "array", "(", "[", "[", "sig_x", "**", "2", ",", "0", "]", ",", "[", "0", ",", "sig_x", "**", "2", "]", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_matrix", "=", "sigma_matrix2", "(", "sig_x", ",", "sig_y", ",", "theta", ")", "\n", "", "kernel", "=", "pdf2", "(", "sigma_matrix", ",", "grid", ")", "\n", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_generalized_Gaussian": [[113, 146], ["numpy.linalg.inv", "numpy.exp", "degradations.mesh_grid", "numpy.array", "degradations.sigma_matrix2", "numpy.sum", "numpy.power", "numpy.sum", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.mesh_grid", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.sigma_matrix2"], ["", "def", "bivariate_generalized_Gaussian", "(", "kernel_size", ",", "sig_x", ",", "sig_y", ",", "theta", ",", "beta", ",", "grid", "=", "None", ",", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Generate a bivariate generalized Gaussian kernel.\n        Described in `Parameter Estimation For Multivariate Generalized\n        Gaussian Distributions`_\n        by Pascal et. al (2013).\n\n    In the isotropic mode, only `sig_x` is used. `sig_y` and `theta` is ignored.\n\n    Args:\n        kernel_size (int):\n        sig_x (float):\n        sig_y (float):\n        theta (float): Radian measurement.\n        beta (float): shape parameter, beta = 1 is the normal distribution.\n        grid (ndarray, optional): generated by :func:`mesh_grid`,\n            with the shape (K, K, 2), K is the kernel size. Default: None\n\n    Returns:\n        kernel (ndarray): normalized kernel.\n\n    .. _Parameter Estimation For Multivariate Generalized Gaussian\n    Distributions: https://arxiv.org/abs/1302.6498\n    \"\"\"", "\n", "if", "grid", "is", "None", ":", "\n", "        ", "grid", ",", "_", ",", "_", "=", "mesh_grid", "(", "kernel_size", ")", "\n", "", "if", "isotropic", ":", "\n", "        ", "sigma_matrix", "=", "np", ".", "array", "(", "[", "[", "sig_x", "**", "2", ",", "0", "]", ",", "[", "0", ",", "sig_x", "**", "2", "]", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_matrix", "=", "sigma_matrix2", "(", "sig_x", ",", "sig_y", ",", "theta", ")", "\n", "", "inverse_sigma", "=", "np", ".", "linalg", ".", "inv", "(", "sigma_matrix", ")", "\n", "kernel", "=", "np", ".", "exp", "(", "-", "0.5", "*", "np", ".", "power", "(", "np", ".", "sum", "(", "np", ".", "dot", "(", "grid", ",", "inverse_sigma", ")", "*", "grid", ",", "2", ")", ",", "beta", ")", ")", "\n", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_plateau": [[148, 178], ["numpy.linalg.inv", "numpy.reciprocal", "degradations.mesh_grid", "numpy.array", "degradations.sigma_matrix2", "numpy.sum", "numpy.power", "numpy.sum", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.mesh_grid", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.sigma_matrix2"], ["", "def", "bivariate_plateau", "(", "kernel_size", ",", "sig_x", ",", "sig_y", ",", "theta", ",", "beta", ",", "grid", "=", "None", ",", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Generate a plateau-like anisotropic kernel.\n    1 / (1+x^(beta))\n\n    Ref: https://stats.stackexchange.com/questions/203629/is-there-a-plateau-shaped-distribution\n\n    In the isotropic mode, only `sig_x` is used. `sig_y` and `theta` is ignored.\n\n    Args:\n        kernel_size (int):\n        sig_x (float):\n        sig_y (float):\n        theta (float): Radian measurement.\n        beta (float): shape parameter, beta = 1 is the normal distribution.\n        grid (ndarray, optional): generated by :func:`mesh_grid`,\n            with the shape (K, K, 2), K is the kernel size. Default: None\n\n    Returns:\n        kernel (ndarray): normalized kernel.\n    \"\"\"", "\n", "if", "grid", "is", "None", ":", "\n", "        ", "grid", ",", "_", ",", "_", "=", "mesh_grid", "(", "kernel_size", ")", "\n", "", "if", "isotropic", ":", "\n", "        ", "sigma_matrix", "=", "np", ".", "array", "(", "[", "[", "sig_x", "**", "2", ",", "0", "]", ",", "[", "0", ",", "sig_x", "**", "2", "]", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_matrix", "=", "sigma_matrix2", "(", "sig_x", ",", "sig_y", ",", "theta", ")", "\n", "", "inverse_sigma", "=", "np", ".", "linalg", ".", "inv", "(", "sigma_matrix", ")", "\n", "kernel", "=", "np", ".", "reciprocal", "(", "np", ".", "power", "(", "np", ".", "sum", "(", "np", ".", "dot", "(", "grid", ",", "inverse_sigma", ")", "*", "grid", ",", "2", ")", ",", "beta", ")", "+", "1", ")", "\n", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_Gaussian": [[180, 222], ["numpy.random.uniform", "degradations.bivariate_Gaussian", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_Gaussian"], ["", "def", "random_bivariate_Gaussian", "(", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "noise_range", "=", "None", ",", "\n", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Randomly generate bivariate isotropic or anisotropic Gaussian kernels.\n\n    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and `rotation_range` is ignored.\n\n    Args:\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi, math.pi]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "assert", "sigma_x_range", "[", "0", "]", "<", "sigma_x_range", "[", "1", "]", ",", "'Wrong sigma_x_range.'", "\n", "sigma_x", "=", "np", ".", "random", ".", "uniform", "(", "sigma_x_range", "[", "0", "]", ",", "sigma_x_range", "[", "1", "]", ")", "\n", "if", "isotropic", "is", "False", ":", "\n", "        ", "assert", "sigma_y_range", "[", "0", "]", "<", "sigma_y_range", "[", "1", "]", ",", "'Wrong sigma_y_range.'", "\n", "assert", "rotation_range", "[", "0", "]", "<", "rotation_range", "[", "1", "]", ",", "'Wrong rotation_range.'", "\n", "sigma_y", "=", "np", ".", "random", ".", "uniform", "(", "sigma_y_range", "[", "0", "]", ",", "sigma_y_range", "[", "1", "]", ")", "\n", "rotation", "=", "np", ".", "random", ".", "uniform", "(", "rotation_range", "[", "0", "]", ",", "rotation_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_y", "=", "sigma_x", "\n", "rotation", "=", "0", "\n", "\n", "", "kernel", "=", "bivariate_Gaussian", "(", "kernel_size", ",", "sigma_x", ",", "sigma_y", ",", "rotation", ",", "isotropic", "=", "isotropic", ")", "\n", "\n", "# add multiplicative noise", "\n", "if", "noise_range", "is", "not", "None", ":", "\n", "        ", "assert", "noise_range", "[", "0", "]", "<", "noise_range", "[", "1", "]", ",", "'Wrong noise range.'", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "noise_range", "[", "0", "]", ",", "noise_range", "[", "1", "]", ",", "size", "=", "kernel", ".", "shape", ")", "\n", "kernel", "=", "kernel", "*", "noise", "\n", "", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_Gaussian_Info": [[223, 265], ["numpy.random.uniform", "degradations.bivariate_Gaussian", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_Gaussian"], ["", "def", "random_bivariate_Gaussian_Info", "(", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "noise_range", "=", "None", ",", "\n", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Randomly generate bivariate isotropic or anisotropic Gaussian kernels.\n\n    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and `rotation_range` is ignored.\n\n    Args:\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi, math.pi]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "assert", "sigma_x_range", "[", "0", "]", "<", "sigma_x_range", "[", "1", "]", ",", "'Wrong sigma_x_range.'", "\n", "sigma_x", "=", "np", ".", "random", ".", "uniform", "(", "sigma_x_range", "[", "0", "]", ",", "sigma_x_range", "[", "1", "]", ")", "\n", "if", "isotropic", "is", "False", ":", "\n", "        ", "assert", "sigma_y_range", "[", "0", "]", "<", "sigma_y_range", "[", "1", "]", ",", "'Wrong sigma_y_range.'", "\n", "assert", "rotation_range", "[", "0", "]", "<", "rotation_range", "[", "1", "]", ",", "'Wrong rotation_range.'", "\n", "sigma_y", "=", "np", ".", "random", ".", "uniform", "(", "sigma_y_range", "[", "0", "]", ",", "sigma_y_range", "[", "1", "]", ")", "\n", "rotation", "=", "np", ".", "random", ".", "uniform", "(", "rotation_range", "[", "0", "]", ",", "rotation_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_y", "=", "sigma_x", "\n", "rotation", "=", "0", "\n", "\n", "", "kernel", "=", "bivariate_Gaussian", "(", "kernel_size", ",", "sigma_x", ",", "sigma_y", ",", "rotation", ",", "isotropic", "=", "isotropic", ")", "\n", "\n", "# add multiplicative noise", "\n", "if", "noise_range", "is", "not", "None", ":", "\n", "        ", "assert", "noise_range", "[", "0", "]", "<", "noise_range", "[", "1", "]", ",", "'Wrong noise range.'", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "noise_range", "[", "0", "]", ",", "noise_range", "[", "1", "]", ",", "size", "=", "kernel", ".", "shape", ")", "\n", "kernel", "=", "kernel", "*", "noise", "\n", "", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "{", "'kernel'", ":", "kernel", ",", "'kernel_size'", ":", "kernel_size", ",", "'sigma_x'", ":", "sigma_x", ",", "'sigma_y'", ":", "sigma_y", ",", "'rotation'", ":", "rotation", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_generalized_Gaussian": [[266, 316], ["numpy.random.uniform", "degradations.bivariate_generalized_Gaussian", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_generalized_Gaussian"], ["", "def", "random_bivariate_generalized_Gaussian", "(", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "beta_range", ",", "\n", "noise_range", "=", "None", ",", "\n", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Randomly generate bivariate generalized Gaussian kernels.\n\n    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and `rotation_range` is ignored.\n\n    Args:\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi, math.pi]\n        beta_range (tuple): [0.5, 8]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "assert", "sigma_x_range", "[", "0", "]", "<", "sigma_x_range", "[", "1", "]", ",", "'Wrong sigma_x_range.'", "\n", "sigma_x", "=", "np", ".", "random", ".", "uniform", "(", "sigma_x_range", "[", "0", "]", ",", "sigma_x_range", "[", "1", "]", ")", "\n", "if", "isotropic", "is", "False", ":", "\n", "        ", "assert", "sigma_y_range", "[", "0", "]", "<", "sigma_y_range", "[", "1", "]", ",", "'Wrong sigma_y_range.'", "\n", "assert", "rotation_range", "[", "0", "]", "<", "rotation_range", "[", "1", "]", ",", "'Wrong rotation_range.'", "\n", "sigma_y", "=", "np", ".", "random", ".", "uniform", "(", "sigma_y_range", "[", "0", "]", ",", "sigma_y_range", "[", "1", "]", ")", "\n", "rotation", "=", "np", ".", "random", ".", "uniform", "(", "rotation_range", "[", "0", "]", ",", "rotation_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_y", "=", "sigma_x", "\n", "rotation", "=", "0", "\n", "\n", "# assume beta_range[0] < 1 < beta_range[1]", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "beta_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "beta_range", "[", "1", "]", ")", "\n", "\n", "", "kernel", "=", "bivariate_generalized_Gaussian", "(", "kernel_size", ",", "sigma_x", ",", "sigma_y", ",", "rotation", ",", "beta", ",", "isotropic", "=", "isotropic", ")", "\n", "\n", "# add multiplicative noise", "\n", "if", "noise_range", "is", "not", "None", ":", "\n", "        ", "assert", "noise_range", "[", "0", "]", "<", "noise_range", "[", "1", "]", ",", "'Wrong noise range.'", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "noise_range", "[", "0", "]", ",", "noise_range", "[", "1", "]", ",", "size", "=", "kernel", ".", "shape", ")", "\n", "kernel", "=", "kernel", "*", "noise", "\n", "", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_generalized_Gaussian_Info": [[317, 367], ["numpy.random.uniform", "degradations.bivariate_generalized_Gaussian", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_generalized_Gaussian"], ["", "def", "random_bivariate_generalized_Gaussian_Info", "(", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "beta_range", ",", "\n", "noise_range", "=", "None", ",", "\n", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Randomly generate bivariate generalized Gaussian kernels.\n\n    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and `rotation_range` is ignored.\n\n    Args:\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi, math.pi]\n        beta_range (tuple): [0.5, 8]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "assert", "sigma_x_range", "[", "0", "]", "<", "sigma_x_range", "[", "1", "]", ",", "'Wrong sigma_x_range.'", "\n", "sigma_x", "=", "np", ".", "random", ".", "uniform", "(", "sigma_x_range", "[", "0", "]", ",", "sigma_x_range", "[", "1", "]", ")", "\n", "if", "isotropic", "is", "False", ":", "\n", "        ", "assert", "sigma_y_range", "[", "0", "]", "<", "sigma_y_range", "[", "1", "]", ",", "'Wrong sigma_y_range.'", "\n", "assert", "rotation_range", "[", "0", "]", "<", "rotation_range", "[", "1", "]", ",", "'Wrong rotation_range.'", "\n", "sigma_y", "=", "np", ".", "random", ".", "uniform", "(", "sigma_y_range", "[", "0", "]", ",", "sigma_y_range", "[", "1", "]", ")", "\n", "rotation", "=", "np", ".", "random", ".", "uniform", "(", "rotation_range", "[", "0", "]", ",", "rotation_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_y", "=", "sigma_x", "\n", "rotation", "=", "0", "\n", "\n", "# assume beta_range[0] < 1 < beta_range[1]", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "beta_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "beta_range", "[", "1", "]", ")", "\n", "\n", "", "kernel", "=", "bivariate_generalized_Gaussian", "(", "kernel_size", ",", "sigma_x", ",", "sigma_y", ",", "rotation", ",", "beta", ",", "isotropic", "=", "isotropic", ")", "\n", "\n", "# add multiplicative noise", "\n", "if", "noise_range", "is", "not", "None", ":", "\n", "        ", "assert", "noise_range", "[", "0", "]", "<", "noise_range", "[", "1", "]", ",", "'Wrong noise range.'", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "noise_range", "[", "0", "]", ",", "noise_range", "[", "1", "]", ",", "size", "=", "kernel", ".", "shape", ")", "\n", "kernel", "=", "kernel", "*", "noise", "\n", "", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "return", "{", "'kernel'", ":", "kernel", ",", "'kernel_size'", ":", "kernel_size", ",", "'sigma_x'", ":", "sigma_x", ",", "'sigma_y'", ":", "sigma_y", ",", "'rotation'", ":", "rotation", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_plateau": [[368, 418], ["numpy.random.uniform", "degradations.bivariate_plateau", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_plateau"], ["", "def", "random_bivariate_plateau", "(", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "beta_range", ",", "\n", "noise_range", "=", "None", ",", "\n", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Randomly generate bivariate plateau kernels.\n\n    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and `rotation_range` is ignored.\n\n    Args:\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi/2, math.pi/2]\n        beta_range (tuple): [1, 4]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "assert", "sigma_x_range", "[", "0", "]", "<", "sigma_x_range", "[", "1", "]", ",", "'Wrong sigma_x_range.'", "\n", "sigma_x", "=", "np", ".", "random", ".", "uniform", "(", "sigma_x_range", "[", "0", "]", ",", "sigma_x_range", "[", "1", "]", ")", "\n", "if", "isotropic", "is", "False", ":", "\n", "        ", "assert", "sigma_y_range", "[", "0", "]", "<", "sigma_y_range", "[", "1", "]", ",", "'Wrong sigma_y_range.'", "\n", "assert", "rotation_range", "[", "0", "]", "<", "rotation_range", "[", "1", "]", ",", "'Wrong rotation_range.'", "\n", "sigma_y", "=", "np", ".", "random", ".", "uniform", "(", "sigma_y_range", "[", "0", "]", ",", "sigma_y_range", "[", "1", "]", ")", "\n", "rotation", "=", "np", ".", "random", ".", "uniform", "(", "rotation_range", "[", "0", "]", ",", "rotation_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_y", "=", "sigma_x", "\n", "rotation", "=", "0", "\n", "\n", "# TODO: this may be not proper", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "beta_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "beta_range", "[", "1", "]", ")", "\n", "\n", "", "kernel", "=", "bivariate_plateau", "(", "kernel_size", ",", "sigma_x", ",", "sigma_y", ",", "rotation", ",", "beta", ",", "isotropic", "=", "isotropic", ")", "\n", "# add multiplicative noise", "\n", "if", "noise_range", "is", "not", "None", ":", "\n", "        ", "assert", "noise_range", "[", "0", "]", "<", "noise_range", "[", "1", "]", ",", "'Wrong noise range.'", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "noise_range", "[", "0", "]", ",", "noise_range", "[", "1", "]", ",", "size", "=", "kernel", ".", "shape", ")", "\n", "kernel", "=", "kernel", "*", "noise", "\n", "", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "\n", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_plateau_Info": [[419, 469], ["numpy.random.uniform", "degradations.bivariate_plateau", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.bivariate_plateau"], ["", "def", "random_bivariate_plateau_Info", "(", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "beta_range", ",", "\n", "noise_range", "=", "None", ",", "\n", "isotropic", "=", "True", ")", ":", "\n", "    ", "\"\"\"Randomly generate bivariate plateau kernels.\n\n    In the isotropic mode, only `sigma_x_range` is used. `sigma_y_range` and `rotation_range` is ignored.\n\n    Args:\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi/2, math.pi/2]\n        beta_range (tuple): [1, 4]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "assert", "sigma_x_range", "[", "0", "]", "<", "sigma_x_range", "[", "1", "]", ",", "'Wrong sigma_x_range.'", "\n", "sigma_x", "=", "np", ".", "random", ".", "uniform", "(", "sigma_x_range", "[", "0", "]", ",", "sigma_x_range", "[", "1", "]", ")", "\n", "if", "isotropic", "is", "False", ":", "\n", "        ", "assert", "sigma_y_range", "[", "0", "]", "<", "sigma_y_range", "[", "1", "]", ",", "'Wrong sigma_y_range.'", "\n", "assert", "rotation_range", "[", "0", "]", "<", "rotation_range", "[", "1", "]", ",", "'Wrong rotation_range.'", "\n", "sigma_y", "=", "np", ".", "random", ".", "uniform", "(", "sigma_y_range", "[", "0", "]", ",", "sigma_y_range", "[", "1", "]", ")", "\n", "rotation", "=", "np", ".", "random", ".", "uniform", "(", "rotation_range", "[", "0", "]", ",", "rotation_range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "sigma_y", "=", "sigma_x", "\n", "rotation", "=", "0", "\n", "\n", "# TODO: this may be not proper", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "beta_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "beta_range", "[", "1", "]", ")", "\n", "\n", "", "kernel", "=", "bivariate_plateau", "(", "kernel_size", ",", "sigma_x", ",", "sigma_y", ",", "rotation", ",", "beta", ",", "isotropic", "=", "isotropic", ")", "\n", "# add multiplicative noise", "\n", "if", "noise_range", "is", "not", "None", ":", "\n", "        ", "assert", "noise_range", "[", "0", "]", "<", "noise_range", "[", "1", "]", ",", "'Wrong noise range.'", "\n", "noise", "=", "np", ".", "random", ".", "uniform", "(", "noise_range", "[", "0", "]", ",", "noise_range", "[", "1", "]", ",", "size", "=", "kernel", ".", "shape", ")", "\n", "kernel", "=", "kernel", "*", "noise", "\n", "", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "\n", "return", "{", "'kernel'", ":", "kernel", ",", "'kernel_size'", ":", "kernel_size", ",", "'sigma_x'", ":", "sigma_x", ",", "'sigma_y'", ":", "sigma_y", ",", "'rotation'", ":", "rotation", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels": [[470, 523], ["random.choices", "degradations.random_bivariate_Gaussian", "degradations.random_bivariate_Gaussian", "degradations.random_bivariate_generalized_Gaussian", "degradations.random_bivariate_generalized_Gaussian", "degradations.random_bivariate_plateau", "degradations.random_bivariate_plateau"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_Gaussian", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_Gaussian", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_generalized_Gaussian", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_generalized_Gaussian", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_plateau", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_plateau"], ["", "def", "random_mixed_kernels", "(", "kernel_list", ",", "\n", "kernel_prob", ",", "\n", "kernel_size", "=", "21", ",", "\n", "sigma_x_range", "=", "[", "0.6", ",", "5", "]", ",", "\n", "sigma_y_range", "=", "[", "0.6", ",", "5", "]", ",", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "betag_range", "=", "[", "0.5", ",", "8", "]", ",", "\n", "betap_range", "=", "[", "0.5", ",", "8", "]", ",", "\n", "noise_range", "=", "None", ")", ":", "\n", "    ", "\"\"\"Randomly generate mixed kernels.\n\n    Args:\n        kernel_list (tuple): a list name of kenrel types,\n            support ['iso', 'aniso', 'skew', 'generalized', 'plateau_iso',\n            'plateau_aniso']\n        kernel_prob (tuple): corresponding kernel probability for each\n            kernel type\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi, math.pi]\n        beta_range (tuple): [0.5, 8]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "kernel_type", "=", "random", ".", "choices", "(", "kernel_list", ",", "kernel_prob", ")", "[", "0", "]", "\n", "if", "kernel_type", "==", "'iso'", ":", "\n", "        ", "kernel", "=", "random_bivariate_Gaussian", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "noise_range", "=", "noise_range", ",", "isotropic", "=", "True", ")", "\n", "", "elif", "kernel_type", "==", "'aniso'", ":", "\n", "        ", "kernel", "=", "random_bivariate_Gaussian", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "noise_range", "=", "noise_range", ",", "isotropic", "=", "False", ")", "\n", "", "elif", "kernel_type", "==", "'generalized_iso'", ":", "\n", "        ", "kernel", "=", "random_bivariate_generalized_Gaussian", "(", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "betag_range", ",", "noise_range", "=", "noise_range", ",", "isotropic", "=", "True", ")", "\n", "", "elif", "kernel_type", "==", "'generalized_aniso'", ":", "\n", "        ", "kernel", "=", "random_bivariate_generalized_Gaussian", "(", "\n", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "betag_range", ",", "\n", "noise_range", "=", "noise_range", ",", "\n", "isotropic", "=", "False", ")", "\n", "", "elif", "kernel_type", "==", "'plateau_iso'", ":", "\n", "        ", "kernel", "=", "random_bivariate_plateau", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "betap_range", ",", "noise_range", "=", "None", ",", "isotropic", "=", "True", ")", "\n", "", "elif", "kernel_type", "==", "'plateau_aniso'", ":", "\n", "        ", "kernel", "=", "random_bivariate_plateau", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "betap_range", ",", "noise_range", "=", "None", ",", "isotropic", "=", "False", ")", "\n", "", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info": [[524, 578], ["random.choices", "degradations.random_bivariate_Gaussian_Info", "degradations.random_bivariate_Gaussian_Info", "degradations.random_bivariate_generalized_Gaussian_Info", "degradations.random_bivariate_generalized_Gaussian_Info", "degradations.random_bivariate_plateau_Info", "degradations.random_bivariate_plateau_Info"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_Gaussian_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_Gaussian_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_generalized_Gaussian_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_generalized_Gaussian_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_plateau_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_bivariate_plateau_Info"], ["", "def", "random_mixed_kernels_Info", "(", "kernel_list", ",", "\n", "kernel_prob", ",", "\n", "kernel_size", "=", "21", ",", "\n", "sigma_x_range", "=", "[", "0.6", ",", "5", "]", ",", "\n", "sigma_y_range", "=", "[", "0.6", ",", "5", "]", ",", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "betag_range", "=", "[", "0.5", ",", "8", "]", ",", "\n", "betap_range", "=", "[", "0.5", ",", "8", "]", ",", "\n", "noise_range", "=", "None", ")", ":", "\n", "    ", "\"\"\"Randomly generate mixed kernels.\n\n    Args:\n        kernel_list (tuple): a list name of kenrel types,\n            support ['iso', 'aniso', 'skew', 'generalized', 'plateau_iso',\n            'plateau_aniso']\n        kernel_prob (tuple): corresponding kernel probability for each\n            kernel type\n        kernel_size (int):\n        sigma_x_range (tuple): [0.6, 5]\n        sigma_y_range (tuple): [0.6, 5]\n        rotation range (tuple): [-math.pi, math.pi]\n        beta_range (tuple): [0.5, 8]\n        noise_range(tuple, optional): multiplicative kernel noise,\n            [0.75, 1.25]. Default: None\n\n    Returns:\n        kernel (ndarray):\n    \"\"\"", "\n", "kernel_type", "=", "random", ".", "choices", "(", "kernel_list", ",", "kernel_prob", ")", "[", "0", "]", "\n", "if", "kernel_type", "==", "'iso'", ":", "\n", "        ", "kernel_info", "=", "random_bivariate_Gaussian_Info", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "noise_range", "=", "noise_range", ",", "isotropic", "=", "True", ")", "\n", "", "elif", "kernel_type", "==", "'aniso'", ":", "\n", "        ", "kernel_info", "=", "random_bivariate_Gaussian_Info", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "noise_range", "=", "noise_range", ",", "isotropic", "=", "False", ")", "\n", "", "elif", "kernel_type", "==", "'generalized_iso'", ":", "\n", "        ", "kernel_info", "=", "random_bivariate_generalized_Gaussian_Info", "(", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "betag_range", ",", "noise_range", "=", "noise_range", ",", "isotropic", "=", "True", ")", "\n", "", "elif", "kernel_type", "==", "'generalized_aniso'", ":", "\n", "        ", "kernel_info", "=", "random_bivariate_generalized_Gaussian_Info", "(", "\n", "kernel_size", ",", "\n", "sigma_x_range", ",", "\n", "sigma_y_range", ",", "\n", "rotation_range", ",", "\n", "betag_range", ",", "\n", "noise_range", "=", "noise_range", ",", "\n", "isotropic", "=", "False", ")", "\n", "", "elif", "kernel_type", "==", "'plateau_iso'", ":", "\n", "        ", "kernel_info", "=", "random_bivariate_plateau_Info", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "betap_range", ",", "noise_range", "=", "None", ",", "isotropic", "=", "True", ")", "\n", "", "elif", "kernel_type", "==", "'plateau_aniso'", ":", "\n", "        ", "kernel_info", "=", "random_bivariate_plateau_Info", "(", "\n", "kernel_size", ",", "sigma_x_range", ",", "sigma_y_range", ",", "rotation_range", ",", "betap_range", ",", "noise_range", "=", "None", ",", "isotropic", "=", "False", ")", "\n", "# {'kernel': kernel, 'kernel_size': kernel_size, 'sigma_x': sigma_x, 'sigma_y': sigma_y, 'rotation': rotation}", "\n", "", "return", "kernel_info", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel": [[582, 601], ["numpy.fromfunction", "numpy.sum", "numpy.pad", "scipy.special.j1", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["def", "circular_lowpass_kernel", "(", "cutoff", ",", "kernel_size", ",", "pad_to", "=", "0", ")", ":", "\n", "    ", "\"\"\"2D sinc filter, ref: https://dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter\n\n    Args:\n        cutoff (float): cutoff frequency in radians (pi is max)\n        kernel_size (int): horizontal and vertical size, must be odd.\n        pad_to (int): pad kernel size to desired size, must be odd or zero.\n    \"\"\"", "\n", "assert", "kernel_size", "%", "2", "==", "1", ",", "'Kernel size must be an odd number.'", "\n", "kernel", "=", "np", ".", "fromfunction", "(", "\n", "lambda", "x", ",", "y", ":", "cutoff", "*", "special", ".", "j1", "(", "cutoff", "*", "np", ".", "sqrt", "(", "\n", "(", "x", "-", "(", "kernel_size", "-", "1", ")", "/", "2", ")", "**", "2", "+", "(", "y", "-", "(", "kernel_size", "-", "1", ")", "/", "2", ")", "**", "2", ")", ")", "/", "(", "2", "*", "np", ".", "pi", "*", "np", ".", "sqrt", "(", "\n", "(", "x", "-", "(", "kernel_size", "-", "1", ")", "/", "2", ")", "**", "2", "+", "(", "y", "-", "(", "kernel_size", "-", "1", ")", "/", "2", ")", "**", "2", ")", ")", ",", "[", "kernel_size", ",", "kernel_size", "]", ")", "\n", "kernel", "[", "(", "kernel_size", "-", "1", ")", "//", "2", ",", "(", "kernel_size", "-", "1", ")", "//", "2", "]", "=", "cutoff", "**", "2", "/", "(", "4", "*", "np", ".", "pi", ")", "\n", "kernel", "=", "kernel", "/", "np", ".", "sum", "(", "kernel", ")", "\n", "if", "pad_to", ">", "kernel_size", ":", "\n", "        ", "pad_size", "=", "(", "pad_to", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_gaussian_noise": [[610, 627], ["numpy.expand_dims().repeat", "numpy.float32", "numpy.expand_dims", "numpy.float32", "numpy.random.randn", "numpy.random.randn"], "function", ["None"], ["", "def", "generate_gaussian_noise", "(", "img", ",", "sigma", "=", "10", ",", "gray_noise", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate Gaussian noise.\n\n    Args:\n        img (Numpy array): Input image, shape (h, w, c), range [0, 1], float32.\n        sigma (float): Noise scale (measured in range 255). Default: 10.\n\n    Returns:\n        (Numpy array): Returned noisy image, shape (h, w, c), range[0, 1],\n            float32.\n    \"\"\"", "\n", "if", "gray_noise", ":", "\n", "        ", "noise", "=", "np", ".", "float32", "(", "np", ".", "random", ".", "randn", "(", "*", "(", "img", ".", "shape", "[", "0", ":", "2", "]", ")", ")", ")", "*", "sigma", "/", "255.", "\n", "noise", "=", "np", ".", "expand_dims", "(", "noise", ",", "axis", "=", "2", ")", ".", "repeat", "(", "3", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "        ", "noise", "=", "np", ".", "float32", "(", "np", ".", "random", ".", "randn", "(", "*", "(", "img", ".", "shape", ")", ")", ")", "*", "sigma", "/", "255.", "\n", "", "return", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_gaussian_noise": [[629, 649], ["degradations.generate_gaussian_noise", "numpy.clip", "numpy.clip"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_gaussian_noise"], ["", "def", "add_gaussian_noise", "(", "img", ",", "sigma", "=", "10", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_noise", "=", "False", ")", ":", "\n", "    ", "\"\"\"Add Gaussian noise.\n\n    Args:\n        img (Numpy array): Input image, shape (h, w, c), range [0, 1], float32.\n        sigma (float): Noise scale (measured in range 255). Default: 10.\n\n    Returns:\n        (Numpy array): Returned noisy image, shape (h, w, c), range[0, 1],\n            float32.\n    \"\"\"", "\n", "noise", "=", "generate_gaussian_noise", "(", "img", ",", "sigma", ",", "gray_noise", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_gaussian_noise_pt": [[651, 684], ["img.size", "isinstance", "isinstance", "sigma.view.view", "gray_noise.view.view", "noise_gray.view.view", "img.size", "torch.sum", "torch.sum", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "img.size", "img.size"], "function", ["None"], ["", "def", "generate_gaussian_noise_pt", "(", "img", ",", "sigma", "=", "10", ",", "gray_noise", "=", "0", ")", ":", "\n", "    ", "\"\"\"Add Gaussian noise (PyTorch version).\n\n    Args:\n        img (Tensor): Shape (b, c, h, w), range[0, 1], float32.\n        scale (float | Tensor): Noise scale. Default: 1.0.\n\n    Returns:\n        (Tensor): Returned noisy image, shape (b, c, h, w), range[0, 1],\n            float32.\n    \"\"\"", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "img", ".", "size", "(", ")", "\n", "if", "not", "isinstance", "(", "sigma", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "        ", "sigma", "=", "sigma", ".", "view", "(", "img", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", "\n", "", "if", "isinstance", "(", "gray_noise", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "        ", "cal_gray_noise", "=", "gray_noise", ">", "0", "\n", "", "else", ":", "\n", "        ", "gray_noise", "=", "gray_noise", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "cal_gray_noise", "=", "torch", ".", "sum", "(", "gray_noise", ")", ">", "0", "\n", "\n", "", "if", "cal_gray_noise", ":", "\n", "        ", "noise_gray", "=", "torch", ".", "randn", "(", "*", "img", ".", "size", "(", ")", "[", "2", ":", "4", "]", ",", "dtype", "=", "img", ".", "dtype", ",", "device", "=", "img", ".", "device", ")", "*", "sigma", "/", "255.", "\n", "noise_gray", "=", "noise_gray", ".", "view", "(", "b", ",", "1", ",", "h", ",", "w", ")", "\n", "\n", "# alway calculate color noise", "\n", "", "noise", "=", "torch", ".", "randn", "(", "*", "img", ".", "size", "(", ")", ",", "dtype", "=", "img", ".", "dtype", ",", "device", "=", "img", ".", "device", ")", "*", "sigma", "/", "255.", "\n", "\n", "# print(gray_noise, noise.shape, noise_gray.shape)", "\n", "# tensor([[[[0.]]], [[[0.]]], [[[1.]]], [[[0.]]]], device='cuda:0') torch.Size([4, 3, 97, 97]) torch.Size([4, 1, 97, 97])", "\n", "if", "cal_gray_noise", ":", "# \u4ea4\u66ff", "\n", "        ", "noise", "=", "noise", "*", "(", "1", "-", "gray_noise", ")", "+", "noise_gray", "*", "gray_noise", "\n", "# torch.Size([4, 3, 237, 237]) torch.Size([4, 3, 115, 115]) ...", "\n", "", "return", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_gaussian_noise_pt": [[686, 706], ["degradations.generate_gaussian_noise_pt", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_gaussian_noise_pt"], ["", "def", "add_gaussian_noise_pt", "(", "img", ",", "sigma", "=", "10", ",", "gray_noise", "=", "0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "\"\"\"Add Gaussian noise (PyTorch version).\n\n    Args:\n        img (Tensor): Shape (b, c, h, w), range[0, 1], float32.\n        scale (float | Tensor): Noise scale. Default: 1.0.\n\n    Returns:\n        (Tensor): Returned noisy image, shape (b, c, h, w), range[0, 1],\n            float32.\n    \"\"\"", "\n", "noise", "=", "generate_gaussian_noise_pt", "(", "img", ",", "sigma", ",", "gray_noise", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_gaussian_noise": [[709, 716], ["numpy.random.uniform", "degradations.generate_gaussian_noise", "numpy.random.uniform"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_gaussian_noise"], ["", "def", "random_generate_gaussian_noise", "(", "img", ",", "sigma_range", "=", "(", "0", ",", "10", ")", ",", "gray_prob", "=", "0", ")", ":", "\n", "    ", "sigma", "=", "np", ".", "random", ".", "uniform", "(", "sigma_range", "[", "0", "]", ",", "sigma_range", "[", "1", "]", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "gray_prob", ":", "\n", "        ", "gray_noise", "=", "True", "\n", "", "else", ":", "\n", "        ", "gray_noise", "=", "False", "\n", "", "return", "generate_gaussian_noise", "(", "img", ",", "sigma", ",", "gray_noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise": [[718, 728], ["degradations.random_generate_gaussian_noise", "numpy.clip", "numpy.clip"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_gaussian_noise"], ["", "def", "random_add_gaussian_noise", "(", "img", ",", "sigma_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "noise", "=", "random_generate_gaussian_noise", "(", "img", ",", "sigma_range", ",", "gray_prob", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_gaussian_noise_pt": [[730, 735], ["torch.rand", "torch.rand", "img.size", "degradations.generate_gaussian_noise_pt", "torch.rand", "torch.rand", "img.size"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_gaussian_noise_pt"], ["", "def", "random_generate_gaussian_noise_pt", "(", "img", ",", "sigma_range", "=", "(", "0", ",", "10", ")", ",", "gray_prob", "=", "0", ")", ":", "\n", "    ", "sigma", "=", "torch", ".", "rand", "(", "img", ".", "size", "(", "0", ")", ",", "dtype", "=", "img", ".", "dtype", ",", "device", "=", "img", ".", "device", ")", "*", "(", "sigma_range", "[", "1", "]", "-", "sigma_range", "[", "0", "]", ")", "+", "sigma_range", "[", "0", "]", "# tensor([11.1178, 14.7019, 22.1756,  3.8562], device='cuda:0')", "\n", "gray_noise", "=", "torch", ".", "rand", "(", "img", ".", "size", "(", "0", ")", ",", "dtype", "=", "img", ".", "dtype", ",", "device", "=", "img", ".", "device", ")", "\n", "gray_noise", "=", "(", "gray_noise", "<", "gray_prob", ")", ".", "float", "(", ")", "# tensor([1., 0., 0., 0.], device='cuda:0') torch.Size([4]) tensor([0., 1., 1., 0.], device='cuda:0') torch.Size([4])", "\n", "return", "sigma", ",", "gray_noise", ",", "generate_gaussian_noise_pt", "(", "img", ",", "sigma", ",", "gray_noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt": [[737, 747], ["degradations.random_generate_gaussian_noise_pt", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_gaussian_noise_pt"], ["", "def", "random_add_gaussian_noise_pt", "(", "img", ",", "sigma_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "sigma", ",", "gray_noise", ",", "noise", "=", "random_generate_gaussian_noise_pt", "(", "img", ",", "sigma_range", ",", "gray_prob", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "sigma", ",", "gray_noise", ",", "out", ",", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt": [[748, 751], ["degradations.random_generate_gaussian_noise_pt"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_gaussian_noise_pt"], ["", "def", "only_generate_gaussian_noise_pt", "(", "img", ",", "sigma_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ")", ":", "\n", "    ", "_", ",", "_", ",", "noise", "=", "random_generate_gaussian_noise_pt", "(", "img", ",", "sigma_range", ",", "gray_prob", ")", "\n", "return", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_given_gaussian_noise_pt": [[752, 763], ["torch.functional.interpolate", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["None"], ["", "def", "add_given_gaussian_noise_pt", "(", "img", ",", "noise", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "if", "noise", ".", "size", "!=", "img", ".", "size", ":", "\n", "        ", "noise", "=", "nn", ".", "functional", ".", "interpolate", "(", "noise", ",", "size", "=", "(", "img", ".", "shape", "[", "2", "]", ",", "img", ".", "shape", "[", "3", "]", ")", ")", "\n", "", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_poisson_noise": [[767, 792], ["len", "numpy.float32", "cv2.cvtColor", "numpy.clip", "numpy.unique", "numpy.ceil", "numpy.repeat", "numpy.log2", "numpy.random.poisson", "float"], "function", ["None"], ["", "def", "generate_poisson_noise", "(", "img", ",", "scale", "=", "1.0", ",", "gray_noise", "=", "False", ")", ":", "\n", "    ", "\"\"\"Generate poisson noise.\n\n    Ref: https://github.com/scikit-image/scikit-image/blob/main/skimage/util/noise.py#L37-L219\n\n    Args:\n        img (Numpy array): Input image, shape (h, w, c), range [0, 1], float32.\n        scale (float): Noise scale. Default: 1.0.\n        gray_noise (bool): Whether generate gray noise. Default: False.\n\n    Returns:\n        (Numpy array): Returned noisy image, shape (h, w, c), range[0, 1],\n            float32.\n    \"\"\"", "\n", "if", "gray_noise", ":", "\n", "        ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "# round and clip image for counting vals correctly", "\n", "", "img", "=", "np", ".", "clip", "(", "(", "img", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "vals", "=", "len", "(", "np", ".", "unique", "(", "img", ")", ")", "\n", "vals", "=", "2", "**", "np", ".", "ceil", "(", "np", ".", "log2", "(", "vals", ")", ")", "\n", "out", "=", "np", ".", "float32", "(", "np", ".", "random", ".", "poisson", "(", "img", "*", "vals", ")", "/", "float", "(", "vals", ")", ")", "\n", "noise", "=", "out", "-", "img", "\n", "if", "gray_noise", ":", "\n", "        ", "noise", "=", "np", ".", "repeat", "(", "noise", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "3", ",", "axis", "=", "2", ")", "\n", "", "return", "noise", "*", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_poisson_noise": [[794, 815], ["degradations.generate_poisson_noise", "numpy.clip", "numpy.clip"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_poisson_noise"], ["", "def", "add_poisson_noise", "(", "img", ",", "scale", "=", "1.0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_noise", "=", "False", ")", ":", "\n", "    ", "\"\"\"Add poisson noise.\n\n    Args:\n        img (Numpy array): Input image, shape (h, w, c), range [0, 1], float32.\n        scale (float): Noise scale. Default: 1.0.\n        gray_noise (bool): Whether generate gray noise. Default: False.\n\n    Returns:\n        (Numpy array): Returned noisy image, shape (h, w, c), range[0, 1],\n            float32.\n    \"\"\"", "\n", "noise", "=", "generate_poisson_noise", "(", "img", ",", "scale", ",", "gray_noise", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_poisson_noise_pt": [[817, 863], ["img.size", "isinstance", "img.new_tensor().view", "gray_noise.view.view", "torchvision.transforms.functional_tensor.rgb_to_grayscale", "torchvision.transforms.functional_tensor.rgb_to_grayscale.new_tensor().view", "noise_gray.expand.expand", "torch.clamp", "torch.clamp", "len", "torch.poisson", "torch.poisson", "isinstance", "scale.view.view", "torch.sum", "torch.sum", "torch.clamp", "torch.clamp", "len", "torch.poisson", "torch.poisson", "torch.unique", "torch.unique", "range", "numpy.ceil", "img.new_tensor", "torch.unique", "torch.unique", "range", "numpy.ceil", "torchvision.transforms.functional_tensor.rgb_to_grayscale.new_tensor", "numpy.log2", "numpy.log2"], "function", ["None"], ["", "def", "generate_poisson_noise_pt", "(", "img", ",", "scale", "=", "1.0", ",", "gray_noise", "=", "0", ")", ":", "\n", "    ", "\"\"\"Generate a batch of poisson noise (PyTorch version)\n\n    Args:\n        img (Tensor): Input image, shape (b, c, h, w), range [0, 1], float32.\n        scale (float | Tensor): Noise scale. Number or Tensor with shape (b).\n            Default: 1.0.\n        gray_noise (float | Tensor): 0-1 number or Tensor with shape (b).\n            0 for False, 1 for True. Default: 0.\n\n    Returns:\n        (Tensor): Returned noisy image, shape (b, c, h, w), range[0, 1],\n            float32.\n    \"\"\"", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "img", ".", "size", "(", ")", "\n", "if", "isinstance", "(", "gray_noise", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "        ", "cal_gray_noise", "=", "gray_noise", ">", "0", "\n", "", "else", ":", "\n", "        ", "gray_noise", "=", "gray_noise", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "cal_gray_noise", "=", "torch", ".", "sum", "(", "gray_noise", ")", ">", "0", "\n", "", "if", "cal_gray_noise", ":", "\n", "        ", "img_gray", "=", "rgb_to_grayscale", "(", "img", ",", "num_output_channels", "=", "1", ")", "\n", "# round and clip image for counting vals correctly", "\n", "img_gray", "=", "torch", ".", "clamp", "(", "(", "img_gray", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "# use for-loop to get the unique values for each sample", "\n", "vals_list", "=", "[", "len", "(", "torch", ".", "unique", "(", "img_gray", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", ")", "for", "i", "in", "range", "(", "b", ")", "]", "\n", "vals_list", "=", "[", "2", "**", "np", ".", "ceil", "(", "np", ".", "log2", "(", "vals", ")", ")", "for", "vals", "in", "vals_list", "]", "\n", "vals", "=", "img_gray", ".", "new_tensor", "(", "vals_list", ")", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "out", "=", "torch", ".", "poisson", "(", "img_gray", "*", "vals", ")", "/", "vals", "\n", "noise_gray", "=", "out", "-", "img_gray", "\n", "noise_gray", "=", "noise_gray", ".", "expand", "(", "b", ",", "3", ",", "h", ",", "w", ")", "\n", "\n", "# alway calculate color noise", "\n", "# round and clip image for counting vals correctly", "\n", "", "img", "=", "torch", ".", "clamp", "(", "(", "img", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "# use for-loop to get the unique values for each sample", "\n", "vals_list", "=", "[", "len", "(", "torch", ".", "unique", "(", "img", "[", "i", ",", ":", ",", ":", ",", ":", "]", ")", ")", "for", "i", "in", "range", "(", "b", ")", "]", "\n", "vals_list", "=", "[", "2", "**", "np", ".", "ceil", "(", "np", ".", "log2", "(", "vals", ")", ")", "for", "vals", "in", "vals_list", "]", "\n", "vals", "=", "img", ".", "new_tensor", "(", "vals_list", ")", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "out", "=", "torch", ".", "poisson", "(", "img", "*", "vals", ")", "/", "vals", "\n", "noise", "=", "out", "-", "img", "\n", "if", "cal_gray_noise", ":", "\n", "        ", "noise", "=", "noise", "*", "(", "1", "-", "gray_noise", ")", "+", "noise_gray", "*", "gray_noise", "\n", "", "if", "not", "isinstance", "(", "scale", ",", "(", "float", ",", "int", ")", ")", ":", "\n", "        ", "scale", "=", "scale", ".", "view", "(", "b", ",", "1", ",", "1", ",", "1", ")", "\n", "", "return", "noise", "*", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_poisson_noise_pt": [[865, 888], ["degradations.generate_poisson_noise_pt", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_poisson_noise_pt"], ["", "def", "add_poisson_noise_pt", "(", "img", ",", "scale", "=", "1.0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_noise", "=", "0", ")", ":", "\n", "    ", "\"\"\"Add poisson noise to a batch of images (PyTorch version).\n\n    Args:\n        img (Tensor): Input image, shape (b, c, h, w), range [0, 1], float32.\n        scale (float | Tensor): Noise scale. Number or Tensor with shape (b).\n            Default: 1.0.\n        gray_noise (float | Tensor): 0-1 number or Tensor with shape (b).\n            0 for False, 1 for True. Default: 0.\n\n    Returns:\n        (Tensor): Returned noisy image, shape (b, c, h, w), range[0, 1],\n            float32.\n    \"\"\"", "\n", "noise", "=", "generate_poisson_noise_pt", "(", "img", ",", "scale", ",", "gray_noise", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_poisson_noise": [[893, 900], ["numpy.random.uniform", "degradations.generate_poisson_noise", "numpy.random.uniform"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_poisson_noise"], ["", "def", "random_generate_poisson_noise", "(", "img", ",", "scale_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ")", ":", "\n", "    ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "scale_range", "[", "0", "]", ",", "scale_range", "[", "1", "]", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "gray_prob", ":", "\n", "        ", "gray_noise", "=", "True", "\n", "", "else", ":", "\n", "        ", "gray_noise", "=", "False", "\n", "", "return", "generate_poisson_noise", "(", "img", ",", "scale", ",", "gray_noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise": [[902, 912], ["degradations.random_generate_poisson_noise", "numpy.clip", "numpy.clip"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_poisson_noise"], ["", "def", "random_add_poisson_noise", "(", "img", ",", "scale_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "noise", "=", "random_generate_poisson_noise", "(", "img", ",", "scale_range", ",", "gray_prob", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "np", ".", "clip", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_poisson_noise_pt": [[914, 919], ["torch.rand", "torch.rand", "img.size", "degradations.generate_poisson_noise_pt", "torch.rand", "torch.rand", "img.size"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.generate_poisson_noise_pt"], ["", "def", "random_generate_poisson_noise_pt", "(", "img", ",", "scale_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ")", ":", "\n", "    ", "scale", "=", "torch", ".", "rand", "(", "img", ".", "size", "(", "0", ")", ",", "dtype", "=", "img", ".", "dtype", ",", "device", "=", "img", ".", "device", ")", "*", "(", "scale_range", "[", "1", "]", "-", "scale_range", "[", "0", "]", ")", "+", "scale_range", "[", "0", "]", "# tensor([1.4829, 2.0538, 2.4698, 0.6297], device='cuda:0') torch.Size([4])", "\n", "gray_noise", "=", "torch", ".", "rand", "(", "img", ".", "size", "(", "0", ")", ",", "dtype", "=", "img", ".", "dtype", ",", "device", "=", "img", ".", "device", ")", "\n", "gray_noise", "=", "(", "gray_noise", "<", "gray_prob", ")", ".", "float", "(", ")", "# B * 1", "\n", "return", "scale", ",", "gray_noise", ",", "generate_poisson_noise_pt", "(", "img", ",", "scale", ",", "gray_noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt": [[921, 931], ["degradations.random_generate_poisson_noise_pt", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_poisson_noise_pt"], ["", "def", "random_add_poisson_noise_pt", "(", "img", ",", "scale_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "scale", ",", "gray_noise", ",", "noise", "=", "random_generate_poisson_noise_pt", "(", "img", ",", "scale_range", ",", "gray_prob", ")", "\n", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "scale", ",", "gray_noise", ",", "out", ",", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt": [[932, 935], ["degradations.random_generate_poisson_noise_pt"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_generate_poisson_noise_pt"], ["", "def", "only_generate_poisson_noise_pt", "(", "img", ",", "scale_range", "=", "(", "0", ",", "1.0", ")", ",", "gray_prob", "=", "0", ")", ":", "\n", "    ", "_", ",", "_", ",", "noise", "=", "random_generate_poisson_noise_pt", "(", "img", ",", "scale_range", ",", "gray_prob", ")", "\n", "return", "noise", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_given_poisson_noise_pt": [[936, 947], ["torch.functional.interpolate", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "function", ["None"], ["", "def", "add_given_poisson_noise_pt", "(", "img", ",", "noise", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", ":", "\n", "    ", "if", "noise", ".", "size", "!=", "img", ".", "size", ":", "\n", "        ", "noise", "=", "nn", ".", "functional", ".", "interpolate", "(", "noise", ",", "size", "=", "(", "img", ".", "shape", "[", "2", "]", ",", "img", ".", "shape", "[", "3", "]", ")", ")", "\n", "", "out", "=", "img", "+", "noise", "\n", "if", "clip", "and", "rounds", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "", "elif", "clip", ":", "\n", "        ", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "", "elif", "rounds", ":", "\n", "        ", "out", "=", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", "/", "255.", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_jpg_compression": [[953, 970], ["numpy.clip", "cv2.imencode", "int", "numpy.float32", "cv2.imdecode"], "function", ["None"], ["", "def", "add_jpg_compression", "(", "img", ",", "quality", "=", "90", ")", ":", "\n", "    ", "\"\"\"Add JPG compression artifacts.\n\n    Args:\n        img (Numpy array): Input image, shape (h, w, c), range [0, 1], float32.\n        quality (float): JPG compression quality. 0 for lowest quality, 100 for\n            best quality. Default: 90.\n\n    Returns:\n        (Numpy array): Returned image after JPG, shape (h, w, c), range[0, 1],\n            float32.\n    \"\"\"", "\n", "img", "=", "np", ".", "clip", "(", "img", ",", "0", ",", "1", ")", "\n", "encode_param", "=", "[", "int", "(", "cv2", ".", "IMWRITE_JPEG_QUALITY", ")", ",", "quality", "]", "\n", "_", ",", "encimg", "=", "cv2", ".", "imencode", "(", "'.jpg'", ",", "img", "*", "255.", ",", "encode_param", ")", "\n", "img", "=", "np", ".", "float32", "(", "cv2", ".", "imdecode", "(", "encimg", ",", "1", ")", ")", "/", "255.", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_jpg_compression": [[972, 987], ["numpy.random.uniform", "degradations.add_jpg_compression"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.add_jpg_compression"], ["", "def", "random_add_jpg_compression", "(", "img", ",", "quality_range", "=", "(", "90", ",", "100", ")", ")", ":", "\n", "    ", "\"\"\"Randomly add JPG compression artifacts.\n\n    Args:\n        img (Numpy array): Input image, shape (h, w, c), range [0, 1], float32.\n        quality_range (tuple[float] | list[float]): JPG compression quality\n            range. 0 for lowest quality, 100 for best quality.\n            Default: (90, 100).\n\n    Returns:\n        (Numpy array): Returned image after JPG, shape (h, w, c), range[0, 1],\n            float32.\n    \"\"\"", "\n", "quality", "=", "np", ".", "random", ".", "uniform", "(", "quality_range", "[", "0", "]", ",", "quality_range", "[", "1", "]", ")", "\n", "return", "add_jpg_compression", "(", "img", ",", "quality", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.DASR_dataset.DASRDataset.__init__": [[18, 88], ["torch.utils.data.Dataset.__init__", "torch.zeros().float", "torch.zeros().float", "DASR_dataset.DASRDataset.gt_folder.endswith", "ValueError", "open", "open", "range", "torch.zeros", "range", "torch.zeros", "os.join", "os.join", "line.strip", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "math.ceil", "math.ceil", "math.ceil", "math.ceil", "line.split"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "DASRDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "# file client (io backend)", "\n", "self", ".", "file_client", "=", "None", "\n", "self", ".", "io_backend_opt", "=", "opt", "[", "'io_backend'", "]", "\n", "self", ".", "gt_folder", "=", "opt", "[", "'dataroot_gt'", "]", "\n", "\n", "if", "self", ".", "io_backend_opt", "[", "'type'", "]", "==", "'lmdb'", ":", "\n", "            ", "self", ".", "io_backend_opt", "[", "'db_paths'", "]", "=", "[", "self", ".", "gt_folder", "]", "\n", "self", ".", "io_backend_opt", "[", "'client_keys'", "]", "=", "[", "'gt'", "]", "\n", "if", "not", "self", ".", "gt_folder", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "                ", "raise", "ValueError", "(", "f\"'dataroot_gt' should end with '.lmdb', but received {self.gt_folder}\"", ")", "\n", "", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "gt_folder", ",", "'meta_info.txt'", ")", ")", "as", "fin", ":", "\n", "                ", "self", ".", "paths", "=", "[", "line", ".", "split", "(", "'.'", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "", "", "else", ":", "\n", "            ", "with", "open", "(", "self", ".", "opt", "[", "'meta_info'", "]", ")", "as", "fin", ":", "\n", "                ", "paths", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "fin", "]", "\n", "self", ".", "paths", "=", "[", "os", ".", "path", ".", "join", "(", "self", ".", "gt_folder", ",", "v", ")", "for", "v", "in", "paths", "]", "\n", "\n", "# blur settings for the first degradation", "\n", "", "", "self", ".", "blur_kernel_size", "=", "opt", "[", "'blur_kernel_size'", "]", "\n", "self", ".", "blur_kernel_size_minimum", "=", "opt", "[", "'blur_kernel_size_minimum'", "]", "\n", "self", ".", "kernel_list", "=", "opt", "[", "'kernel_list'", "]", "\n", "self", ".", "kernel_prob", "=", "opt", "[", "'kernel_prob'", "]", "\n", "self", ".", "blur_sigma", "=", "opt", "[", "'blur_sigma'", "]", "\n", "self", ".", "betag_range", "=", "opt", "[", "'betag_range'", "]", "\n", "self", ".", "betap_range", "=", "opt", "[", "'betap_range'", "]", "\n", "self", ".", "sinc_prob", "=", "opt", "[", "'sinc_prob'", "]", "\n", "\n", "# blur settings for the second degradation", "\n", "self", ".", "blur_kernel_size2", "=", "opt", "[", "'blur_kernel_size2'", "]", "\n", "self", ".", "blur_kernel_size2_minimum", "=", "opt", "[", "'blur_kernel_size2_minimum'", "]", "\n", "self", ".", "kernel_list2", "=", "opt", "[", "'kernel_list2'", "]", "\n", "self", ".", "kernel_prob2", "=", "opt", "[", "'kernel_prob2'", "]", "\n", "self", ".", "blur_sigma2", "=", "opt", "[", "'blur_sigma2'", "]", "\n", "self", ".", "betag_range2", "=", "opt", "[", "'betag_range2'", "]", "\n", "self", ".", "betap_range2", "=", "opt", "[", "'betap_range2'", "]", "\n", "self", ".", "sinc_prob2", "=", "opt", "[", "'sinc_prob2'", "]", "\n", "\n", "# a final sinc filter", "\n", "self", ".", "final_sinc_prob", "=", "opt", "[", "'final_sinc_prob'", "]", "\n", "\n", "self", ".", "kernel_range", "=", "[", "2", "*", "v", "+", "1", "for", "v", "in", "range", "(", "math", ".", "ceil", "(", "self", ".", "blur_kernel_size_minimum", "/", "2", ")", ",", "math", ".", "ceil", "(", "self", ".", "blur_kernel_size", "/", "2", ")", ")", "]", "\n", "self", ".", "pulse_tensor", "=", "torch", ".", "zeros", "(", "21", ",", "21", ")", ".", "float", "(", ")", "# convolving with pulse tensor brings no blurry effect", "\n", "self", ".", "pulse_tensor", "[", "10", ",", "10", "]", "=", "1", "\n", "\n", "self", ".", "kernel_range2", "=", "[", "2", "*", "v", "+", "1", "for", "v", "in", "range", "(", "math", ".", "ceil", "(", "self", ".", "blur_kernel_size2_minimum", "/", "2", ")", ",", "math", ".", "ceil", "(", "self", ".", "blur_kernel_size2", "/", "2", ")", ")", "]", "\n", "self", ".", "pulse_tensor2", "=", "torch", ".", "zeros", "(", "21", ",", "21", ")", ".", "float", "(", ")", "# convolving with pulse tensor brings no blurry effect", "\n", "self", ".", "pulse_tensor2", "[", "10", ",", "10", "]", "=", "1", "\n", "\n", "# standard_degrade_one_stage", "\n", "self", ".", "blur_kernel_size_standard1", "=", "opt", "[", "'blur_kernel_size_standard1'", "]", "\n", "self", ".", "blur_kernel_size_minimum_standard1", "=", "opt", "[", "'blur_kernel_size_minimum_standard1'", "]", "\n", "self", ".", "kernel_list_standard1", "=", "opt", "[", "'kernel_list_standard1'", "]", "\n", "self", ".", "kernel_prob_standard1", "=", "opt", "[", "'kernel_prob_standard1'", "]", "\n", "self", ".", "blur_sigma_standard1", "=", "opt", "[", "'blur_sigma_standard1'", "]", "\n", "self", ".", "betag_range_standard1", "=", "opt", "[", "'betag_range_standard1'", "]", "\n", "self", ".", "betap_range_standard1", "=", "opt", "[", "'betap_range_standard1'", "]", "\n", "self", ".", "sinc_prob_standard1", "=", "opt", "[", "'sinc_prob_standard1'", "]", "\n", "\n", "# weak_degrade_one_stage", "\n", "self", ".", "blur_kernel_size_weak1", "=", "opt", "[", "'blur_kernel_size_weak1'", "]", "\n", "self", ".", "blur_kernel_size_minimum_weak1", "=", "opt", "[", "'blur_kernel_size_minimum_weak1'", "]", "\n", "self", ".", "kernel_list_weak1", "=", "opt", "[", "'kernel_list_weak1'", "]", "\n", "self", ".", "kernel_prob_weak1", "=", "opt", "[", "'kernel_prob_weak1'", "]", "\n", "self", ".", "blur_sigma_weak1", "=", "opt", "[", "'blur_sigma_weak1'", "]", "\n", "self", ".", "betag_range_weak1", "=", "opt", "[", "'betag_range_weak1'", "]", "\n", "self", ".", "betap_range_weak1", "=", "opt", "[", "'betap_range_weak1'", "]", "\n", "self", ".", "sinc_prob_weak1", "=", "opt", "[", "'sinc_prob_weak1'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.DASR_dataset.DASRDataset.__getitem__": [[89, 274], ["basicsr.utils.imfrombytes", "basicsr.data.transforms.augment", "random.choice", "numpy.pad", "random.choice", "numpy.pad", "torch.FloatTensor", "torch.FloatTensor", "random.choice", "numpy.pad", "torch.FloatTensor", "random.choice", "numpy.pad", "torch.FloatTensor", "basicsr.utils.FileClient", "max", "max", "cv2.copyMakeBorder", "random.randint", "random.randint", "basicsr.utils.img2tensor", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "numpy.random.uniform", "random.choice", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "torch.FloatTensor", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "DASR_dataset.DASRDataset.io_backend_opt.pop", "DASR_dataset.DASRDataset.file_client.get", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warn", "random.randint", "time.sleep", "DASR_dataset.DASRDataset.__len__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.augment", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.data.realesrgan_dataset.RealESRGANDataset.__len__"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "\n", "        ", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "FileClient", "(", "self", ".", "io_backend_opt", ".", "pop", "(", "'type'", ")", ",", "**", "self", ".", "io_backend_opt", ")", "\n", "\n", "# -------------------------------- Load gt images -------------------------------- #", "\n", "# Shape: (h, w, c); channel order: BGR; image range: [0, 1], float32.", "\n", "", "gt_path", "=", "self", ".", "paths", "[", "index", "]", "\n", "# avoid errors caused by high latency in reading files", "\n", "retry", "=", "3", "\n", "while", "retry", ">", "0", ":", "\n", "            ", "try", ":", "\n", "                ", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "gt_path", ",", "'gt'", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "                ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warn", "(", "f'File client error: {e}, remaining retry times: {retry - 1}'", ")", "\n", "# change another file to read", "\n", "index", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "__len__", "(", ")", ")", "\n", "gt_path", "=", "self", ".", "paths", "[", "index", "]", "\n", "time", ".", "sleep", "(", "1", ")", "# sleep 1s for occasional server congestion", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "finally", ":", "\n", "                ", "retry", "-=", "1", "\n", "", "", "img_gt", "=", "imfrombytes", "(", "img_bytes", ",", "float32", "=", "True", ")", "\n", "\n", "# -------------------- augmentation for training: flip, rotation -------------------- #", "\n", "img_gt", "=", "augment", "(", "img_gt", ",", "self", ".", "opt", "[", "'use_hflip'", "]", ",", "self", ".", "opt", "[", "'use_rot'", "]", ")", "\n", "\n", "# crop or pad to 400: 400 is hard-coded. You may change it accordingly", "\n", "h", ",", "w", "=", "img_gt", ".", "shape", "[", "0", ":", "2", "]", "\n", "crop_pad_size", "=", "400", "\n", "# pad", "\n", "if", "h", "<", "crop_pad_size", "or", "w", "<", "crop_pad_size", ":", "\n", "            ", "pad_h", "=", "max", "(", "0", ",", "crop_pad_size", "-", "h", ")", "\n", "pad_w", "=", "max", "(", "0", ",", "crop_pad_size", "-", "w", ")", "\n", "img_gt", "=", "cv2", ".", "copyMakeBorder", "(", "img_gt", ",", "0", ",", "pad_h", ",", "0", ",", "pad_w", ",", "cv2", ".", "BORDER_REFLECT_101", ")", "\n", "# crop", "\n", "", "if", "img_gt", ".", "shape", "[", "0", "]", ">", "crop_pad_size", "or", "img_gt", ".", "shape", "[", "1", "]", ">", "crop_pad_size", ":", "\n", "            ", "h", ",", "w", "=", "img_gt", ".", "shape", "[", "0", ":", "2", "]", "\n", "# randomly choose top and left coordinates", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h", "-", "crop_pad_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w", "-", "crop_pad_size", ")", "\n", "img_gt", "=", "img_gt", "[", "top", ":", "top", "+", "crop_pad_size", ",", "left", ":", "left", "+", "crop_pad_size", ",", "...", "]", "\n", "\n", "", "img_gt", "=", "img2tensor", "(", "[", "img_gt", "]", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "[", "0", "]", "\n", "\n", "return_d", "=", "{", "}", "\n", "\n", "# severe_degrade_two_stage", "\n", "# ------------------------ Generate kernels (used in the first degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'sinc_prob'", "]", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel_info", "=", "random_mixed_kernels_Info", "(", "\n", "self", ".", "kernel_list", ",", "\n", "self", ".", "kernel_prob", ",", "\n", "kernel_size", ",", "\n", "self", ".", "blur_sigma", ",", "\n", "self", ".", "blur_sigma", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "self", ".", "betag_range", ",", "\n", "self", ".", "betap_range", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel", "=", "kernel_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# ------------------------ Generate kernels (used in the second degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range2", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'sinc_prob2'", "]", ":", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel2", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel2_info", "=", "random_mixed_kernels_Info", "(", "\n", "self", ".", "kernel_list2", ",", "\n", "self", ".", "kernel_prob2", ",", "\n", "kernel_size", ",", "\n", "self", ".", "blur_sigma2", ",", "\n", "self", ".", "blur_sigma2", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "self", ".", "betag_range2", ",", "\n", "self", ".", "betap_range2", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel2", "=", "kernel2_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel2", "=", "np", ".", "pad", "(", "kernel2", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# ------------------------------------- sinc kernel ------------------------------------- #", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'final_sinc_prob'", "]", ":", "\n", "            ", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range2", ")", "\n", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "sinc_kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "21", ")", "\n", "sinc_kernel", "=", "torch", ".", "FloatTensor", "(", "sinc_kernel", ")", "\n", "kernel_sinc_info", "=", "{", "'kernel'", ":", "sinc_kernel", ",", "'kernel_size'", ":", "kernel_size", ",", "'omega_c'", ":", "omega_c", "}", "\n", "", "else", ":", "\n", "            ", "sinc_kernel", "=", "self", ".", "pulse_tensor2", "\n", "kernel_sinc_info", "=", "{", "'kernel'", ":", "sinc_kernel", ",", "'kernel_size'", ":", "0", ",", "'omega_c'", ":", "0", "}", "\n", "\n", "", "kernel", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", "\n", "kernel2", "=", "torch", ".", "FloatTensor", "(", "kernel2", ")", "\n", "kernel_info", "[", "'kernel'", "]", "=", "kernel", "\n", "kernel2_info", "[", "'kernel'", "]", "=", "kernel2", "\n", "\n", "return_d", "[", "'severe_degrade_two_stage'", "]", "=", "{", "'gt'", ":", "img_gt", ",", "'kernel1'", ":", "kernel_info", ",", "'kernel2'", ":", "kernel2_info", ",", "'sinc_kernel'", ":", "kernel_sinc_info", ",", "'gt_path'", ":", "gt_path", "}", "\n", "# return_d = {'gt': img_gt, 'kernel1': kernel_info, 'kernel2': kernel2_info, 'sinc_kernel': kernel_sinc_info, 'gt_path': gt_path}", "\n", "\n", "kernel_info", "=", "{", "}", "\n", "\n", "# standard_degrade_one_stage", "\n", "\n", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'sinc_prob_standard1'", "]", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel_info", "=", "random_mixed_kernels_Info", "(", "\n", "self", ".", "kernel_list_standard1", ",", "\n", "self", ".", "kernel_prob_standard1", ",", "\n", "kernel_size", ",", "\n", "self", ".", "blur_sigma_standard1", ",", "\n", "self", ".", "blur_sigma_standard1", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "self", ".", "betag_range_standard1", ",", "\n", "self", ".", "betap_range_standard1", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel", "=", "kernel_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "kernel", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", "\n", "kernel_info", "[", "'kernel'", "]", "=", "kernel", "\n", "\n", "return_d", "[", "'standard_degrade_one_stage'", "]", "=", "{", "'gt'", ":", "img_gt", ",", "'kernel1'", ":", "kernel_info", ",", "'gt_path'", ":", "gt_path", "}", "\n", "\n", "kernel_info", "=", "{", "}", "\n", "\n", "# weak_degrade_one_stage", "\n", "\n", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'sinc_prob_weak1'", "]", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel_info", "=", "random_mixed_kernels_Info", "(", "\n", "self", ".", "kernel_list_weak1", ",", "\n", "self", ".", "kernel_prob_weak1", ",", "\n", "kernel_size", ",", "\n", "self", ".", "blur_sigma_weak1", ",", "\n", "self", ".", "blur_sigma_weak1", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "self", ".", "betag_range_weak1", ",", "\n", "self", ".", "betap_range_weak1", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel", "=", "kernel_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "kernel", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", "\n", "kernel_info", "[", "'kernel'", "]", "=", "kernel", "\n", "\n", "return_d", "[", "'weak_degrade_one_stage'", "]", "=", "{", "'gt'", ":", "img_gt", ",", "'kernel1'", ":", "kernel_info", ",", "'gt_path'", ":", "gt_path", "}", "\n", "\n", "return", "return_d", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.DASR_dataset.DASRDataset.__len__": [[275, 277], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "paths", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data.realesrgan_dataset.RealESRGANDataset.__init__": [[32, 79], ["torch.utils.data.Dataset.__init__", "torch.zeros().float", "realesrgan_dataset.RealESRGANDataset.gt_folder.endswith", "ValueError", "open", "open", "range", "torch.zeros", "os.join", "os.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "line.split", "line.strip().split", "line.strip"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "opt", ")", ":", "\n", "        ", "super", "(", "RealESRGANDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "opt", "=", "opt", "\n", "self", ".", "file_client", "=", "None", "\n", "self", ".", "io_backend_opt", "=", "opt", "[", "'io_backend'", "]", "\n", "self", ".", "gt_folder", "=", "opt", "[", "'dataroot_gt'", "]", "\n", "\n", "# file client (lmdb io backend)", "\n", "if", "self", ".", "io_backend_opt", "[", "'type'", "]", "==", "'lmdb'", ":", "\n", "            ", "self", ".", "io_backend_opt", "[", "'db_paths'", "]", "=", "[", "self", ".", "gt_folder", "]", "\n", "self", ".", "io_backend_opt", "[", "'client_keys'", "]", "=", "[", "'gt'", "]", "\n", "if", "not", "self", ".", "gt_folder", ".", "endswith", "(", "'.lmdb'", ")", ":", "\n", "                ", "raise", "ValueError", "(", "f\"'dataroot_gt' should end with '.lmdb', but received {self.gt_folder}\"", ")", "\n", "", "with", "open", "(", "osp", ".", "join", "(", "self", ".", "gt_folder", ",", "'meta_info.txt'", ")", ")", "as", "fin", ":", "\n", "                ", "self", ".", "paths", "=", "[", "line", ".", "split", "(", "'.'", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "", "", "else", ":", "\n", "# disk backend with meta_info", "\n", "# Each line in the meta_info describes the relative path to an image", "\n", "            ", "with", "open", "(", "self", ".", "opt", "[", "'meta_info'", "]", ")", "as", "fin", ":", "\n", "                ", "paths", "=", "[", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "[", "0", "]", "for", "line", "in", "fin", "]", "\n", "self", ".", "paths", "=", "[", "os", ".", "path", ".", "join", "(", "self", ".", "gt_folder", ",", "v", ")", "for", "v", "in", "paths", "]", "\n", "\n", "# blur settings for the first degradation", "\n", "", "", "self", ".", "blur_kernel_size", "=", "opt", "[", "'blur_kernel_size'", "]", "\n", "self", ".", "kernel_list", "=", "opt", "[", "'kernel_list'", "]", "\n", "self", ".", "kernel_prob", "=", "opt", "[", "'kernel_prob'", "]", "# a list for each kernel probability", "\n", "self", ".", "blur_sigma", "=", "opt", "[", "'blur_sigma'", "]", "\n", "self", ".", "betag_range", "=", "opt", "[", "'betag_range'", "]", "# betag used in generalized Gaussian blur kernels", "\n", "self", ".", "betap_range", "=", "opt", "[", "'betap_range'", "]", "# betap used in plateau blur kernels", "\n", "self", ".", "sinc_prob", "=", "opt", "[", "'sinc_prob'", "]", "# the probability for sinc filters", "\n", "\n", "# blur settings for the second degradation", "\n", "self", ".", "blur_kernel_size2", "=", "opt", "[", "'blur_kernel_size2'", "]", "\n", "self", ".", "kernel_list2", "=", "opt", "[", "'kernel_list2'", "]", "\n", "self", ".", "kernel_prob2", "=", "opt", "[", "'kernel_prob2'", "]", "\n", "self", ".", "blur_sigma2", "=", "opt", "[", "'blur_sigma2'", "]", "\n", "self", ".", "betag_range2", "=", "opt", "[", "'betag_range2'", "]", "\n", "self", ".", "betap_range2", "=", "opt", "[", "'betap_range2'", "]", "\n", "self", ".", "sinc_prob2", "=", "opt", "[", "'sinc_prob2'", "]", "\n", "\n", "# a final sinc filter", "\n", "self", ".", "final_sinc_prob", "=", "opt", "[", "'final_sinc_prob'", "]", "\n", "\n", "self", ".", "kernel_range", "=", "[", "2", "*", "v", "+", "1", "for", "v", "in", "range", "(", "3", ",", "11", ")", "]", "# kernel size ranges from 7 to 21", "\n", "# TODO: kernel range is now hard-coded, should be in the configure file", "\n", "self", ".", "pulse_tensor", "=", "torch", ".", "zeros", "(", "21", ",", "21", ")", ".", "float", "(", ")", "# convolving with pulse tensor brings no blurry effect", "\n", "self", ".", "pulse_tensor", "[", "10", ",", "10", "]", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.realesrgan_dataset.RealESRGANDataset.__getitem__": [[80, 187], ["basicsr.utils.imfrombytes", "basicsr.data.transforms.augment", "random.choice", "numpy.pad", "random.choice", "numpy.pad", "torch.FloatTensor", "torch.FloatTensor", "basicsr.utils.FileClient", "max", "max", "cv2.copyMakeBorder", "random.randint", "random.randint", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels", "numpy.random.uniform", "random.choice", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "torch.FloatTensor", "basicsr.utils.img2tensor", "realesrgan_dataset.RealESRGANDataset.io_backend_opt.pop", "realesrgan_dataset.RealESRGANDataset.file_client.get", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.warn", "random.randint", "time.sleep", "realesrgan_dataset.RealESRGANDataset.__len__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imfrombytes", "home.repos.pwc.inspect_result.csjliang_dasr.data.transforms.augment", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.data.realesrgan_dataset.RealESRGANDataset.__len__"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "self", ".", "file_client", "is", "None", ":", "\n", "            ", "self", ".", "file_client", "=", "FileClient", "(", "self", ".", "io_backend_opt", ".", "pop", "(", "'type'", ")", ",", "**", "self", ".", "io_backend_opt", ")", "\n", "\n", "# -------------------------------- Load gt images -------------------------------- #", "\n", "# Shape: (h, w, c); channel order: BGR; image range: [0, 1], float32.", "\n", "", "gt_path", "=", "self", ".", "paths", "[", "index", "]", "\n", "# avoid errors caused by high latency in reading files", "\n", "retry", "=", "3", "\n", "while", "retry", ">", "0", ":", "\n", "            ", "try", ":", "\n", "                ", "img_bytes", "=", "self", ".", "file_client", ".", "get", "(", "gt_path", ",", "'gt'", ")", "\n", "", "except", "(", "IOError", ",", "OSError", ")", "as", "e", ":", "\n", "                ", "logger", "=", "get_root_logger", "(", ")", "\n", "logger", ".", "warn", "(", "f'File client error: {e}, remaining retry times: {retry - 1}'", ")", "\n", "# change another file to read", "\n", "index", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "__len__", "(", ")", ")", "\n", "gt_path", "=", "self", ".", "paths", "[", "index", "]", "\n", "time", ".", "sleep", "(", "1", ")", "# sleep 1s for occasional server congestion", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "finally", ":", "\n", "                ", "retry", "-=", "1", "\n", "", "", "img_gt", "=", "imfrombytes", "(", "img_bytes", ",", "float32", "=", "True", ")", "\n", "\n", "# -------------------- Do augmentation for training: flip, rotation -------------------- #", "\n", "img_gt", "=", "augment", "(", "img_gt", ",", "self", ".", "opt", "[", "'use_hflip'", "]", ",", "self", ".", "opt", "[", "'use_rot'", "]", ")", "\n", "\n", "# crop or pad to 400", "\n", "# TODO: 400 is hard-coded. You may change it accordingly", "\n", "h", ",", "w", "=", "img_gt", ".", "shape", "[", "0", ":", "2", "]", "\n", "crop_pad_size", "=", "400", "\n", "# pad", "\n", "if", "h", "<", "crop_pad_size", "or", "w", "<", "crop_pad_size", ":", "\n", "            ", "pad_h", "=", "max", "(", "0", ",", "crop_pad_size", "-", "h", ")", "\n", "pad_w", "=", "max", "(", "0", ",", "crop_pad_size", "-", "w", ")", "\n", "img_gt", "=", "cv2", ".", "copyMakeBorder", "(", "img_gt", ",", "0", ",", "pad_h", ",", "0", ",", "pad_w", ",", "cv2", ".", "BORDER_REFLECT_101", ")", "\n", "# crop", "\n", "", "if", "img_gt", ".", "shape", "[", "0", "]", ">", "crop_pad_size", "or", "img_gt", ".", "shape", "[", "1", "]", ">", "crop_pad_size", ":", "\n", "            ", "h", ",", "w", "=", "img_gt", ".", "shape", "[", "0", ":", "2", "]", "\n", "# randomly choose top and left coordinates", "\n", "top", "=", "random", ".", "randint", "(", "0", ",", "h", "-", "crop_pad_size", ")", "\n", "left", "=", "random", ".", "randint", "(", "0", ",", "w", "-", "crop_pad_size", ")", "\n", "img_gt", "=", "img_gt", "[", "top", ":", "top", "+", "crop_pad_size", ",", "left", ":", "left", "+", "crop_pad_size", ",", "...", "]", "\n", "\n", "# ------------------------ Generate kernels (used in the first degradation) ------------------------ #", "\n", "", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'sinc_prob'", "]", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel", "=", "random_mixed_kernels", "(", "\n", "self", ".", "kernel_list", ",", "\n", "self", ".", "kernel_prob", ",", "\n", "kernel_size", ",", "\n", "self", ".", "blur_sigma", ",", "\n", "self", ".", "blur_sigma", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "self", ".", "betag_range", ",", "\n", "self", ".", "betap_range", ",", "\n", "noise_range", "=", "None", ")", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# ------------------------ Generate kernels (used in the second degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'sinc_prob2'", "]", ":", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel2", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel2", "=", "random_mixed_kernels", "(", "\n", "self", ".", "kernel_list2", ",", "\n", "self", ".", "kernel_prob2", ",", "\n", "kernel_size", ",", "\n", "self", ".", "blur_sigma2", ",", "\n", "self", ".", "blur_sigma2", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "self", ".", "betag_range2", ",", "\n", "self", ".", "betap_range2", ",", "\n", "noise_range", "=", "None", ")", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel2", "=", "np", ".", "pad", "(", "kernel2", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# ------------------------------------- the final sinc kernel ------------------------------------- #", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "self", ".", "opt", "[", "'final_sinc_prob'", "]", ":", "\n", "            ", "kernel_size", "=", "random", ".", "choice", "(", "self", ".", "kernel_range", ")", "\n", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "sinc_kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "21", ")", "\n", "sinc_kernel", "=", "torch", ".", "FloatTensor", "(", "sinc_kernel", ")", "\n", "", "else", ":", "\n", "            ", "sinc_kernel", "=", "self", ".", "pulse_tensor", "\n", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "", "img_gt", "=", "img2tensor", "(", "[", "img_gt", "]", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", "[", "0", "]", "\n", "kernel", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", "\n", "kernel2", "=", "torch", ".", "FloatTensor", "(", "kernel2", ")", "\n", "\n", "return_d", "=", "{", "'gt'", ":", "img_gt", ",", "'kernel1'", ":", "kernel", ",", "'kernel2'", ":", "kernel2", ",", "'sinc_kernel'", ":", "sinc_kernel", ",", "'gt_path'", ":", "gt_path", "}", "\n", "return", "return_d", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data.realesrgan_dataset.RealESRGANDataset.__len__": [[188, 190], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "paths", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.__init__.build_loss": [[14, 27], ["copy.deepcopy", "copy.deepcopy.pop", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.registry.LOSS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.get"], []], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.L1Loss.__init__": [[41, 48], ["torch.nn.Module.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "loss_weight", "=", "1.0", ",", "reduction", "=", "'mean'", ")", ":", "\n", "        ", "super", "(", "L1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "reduction", "not", "in", "[", "'none'", ",", "'mean'", ",", "'sum'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unsupported reduction mode: {reduction}. '", "f'Supported ones are: {_reduction_modes}'", ")", "\n", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "reduction", "=", "reduction", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.L1Loss.forward": [[49, 58], ["losses.l1_loss"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.l1_loss"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            pred (Tensor): of shape (N, C, H, W). Predicted tensor.\n            target (Tensor): of shape (N, C, H, W). Ground truth tensor.\n            weight (Tensor, optional): of shape (N, C, H, W). Element-wise\n                weights. Default: None.\n        \"\"\"", "\n", "return", "self", ".", "loss_weight", "*", "l1_loss", "(", "pred", ",", "target", ",", "weight", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.MSELoss.__init__": [[70, 77], ["torch.nn.Module.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "loss_weight", "=", "1.0", ",", "reduction", "=", "'mean'", ")", ":", "\n", "        ", "super", "(", "MSELoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "reduction", "not", "in", "[", "'none'", ",", "'mean'", ",", "'sum'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unsupported reduction mode: {reduction}. '", "f'Supported ones are: {_reduction_modes}'", ")", "\n", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "reduction", "=", "reduction", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.MSELoss.forward": [[78, 87], ["losses.mse_loss"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.mse_loss"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            pred (Tensor): of shape (N, C, H, W). Predicted tensor.\n            target (Tensor): of shape (N, C, H, W). Ground truth tensor.\n            weight (Tensor, optional): of shape (N, C, H, W). Element-wise\n                weights. Default: None.\n        \"\"\"", "\n", "return", "self", ".", "loss_weight", "*", "mse_loss", "(", "pred", ",", "target", ",", "weight", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.CharbonnierLoss.__init__": [[105, 113], ["torch.nn.Module.__init__", "ValueError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "loss_weight", "=", "1.0", ",", "reduction", "=", "'mean'", ",", "eps", "=", "1e-12", ")", ":", "\n", "        ", "super", "(", "CharbonnierLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "reduction", "not", "in", "[", "'none'", ",", "'mean'", ",", "'sum'", "]", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unsupported reduction mode: {reduction}. '", "f'Supported ones are: {_reduction_modes}'", ")", "\n", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "reduction", "=", "reduction", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.CharbonnierLoss.forward": [[114, 123], ["losses.charbonnier_loss"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.charbonnier_loss"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            pred (Tensor): of shape (N, C, H, W). Predicted tensor.\n            target (Tensor): of shape (N, C, H, W). Ground truth tensor.\n            weight (Tensor, optional): of shape (N, C, H, W). Element-wise\n                weights. Default: None.\n        \"\"\"", "\n", "return", "self", ".", "loss_weight", "*", "charbonnier_loss", "(", "pred", ",", "target", ",", "weight", ",", "eps", "=", "self", ".", "eps", ",", "reduction", "=", "self", ".", "reduction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.WeightedTVLoss.__init__": [[133, 135], ["losses.L1Loss.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "WeightedTVLoss", ",", "self", ")", ".", "__init__", "(", "loss_weight", "=", "loss_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.WeightedTVLoss.forward": [[136, 143], ["losses.L1Loss.forward", "losses.L1Loss.forward"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANFeatLoss.forward", "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANFeatLoss.forward"], ["", "def", "forward", "(", "self", ",", "pred", ",", "weight", "=", "None", ")", ":", "\n", "        ", "y_diff", "=", "super", "(", "WeightedTVLoss", ",", "self", ")", ".", "forward", "(", "pred", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", ",", "pred", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", ",", "weight", "=", "weight", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", ")", "\n", "x_diff", "=", "super", "(", "WeightedTVLoss", ",", "self", ")", ".", "forward", "(", "pred", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", "]", ",", "pred", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", ",", "weight", "=", "weight", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", "]", ")", "\n", "\n", "loss", "=", "x_diff", "+", "y_diff", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss.__init__": [[169, 196], ["torch.nn.Module.__init__", "basicsr.archs.vgg_arch.VGGFeatureExtractor", "torch.nn.L1Loss", "list", "torch.nn.L2loss", "layer_weights.keys", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys"], ["def", "__init__", "(", "self", ",", "\n", "layer_weights", ",", "\n", "vgg_type", "=", "'vgg19'", ",", "\n", "use_input_norm", "=", "True", ",", "\n", "range_norm", "=", "False", ",", "\n", "perceptual_weight", "=", "1.0", ",", "\n", "style_weight", "=", "0.", ",", "\n", "criterion", "=", "'l1'", ")", ":", "\n", "        ", "super", "(", "PerceptualLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "perceptual_weight", "=", "perceptual_weight", "\n", "self", ".", "style_weight", "=", "style_weight", "\n", "self", ".", "layer_weights", "=", "layer_weights", "\n", "self", ".", "vgg", "=", "VGGFeatureExtractor", "(", "\n", "layer_name_list", "=", "list", "(", "layer_weights", ".", "keys", "(", ")", ")", ",", "\n", "vgg_type", "=", "vgg_type", ",", "\n", "use_input_norm", "=", "use_input_norm", ",", "\n", "range_norm", "=", "range_norm", ")", "\n", "\n", "self", ".", "criterion_type", "=", "criterion", "\n", "if", "self", ".", "criterion_type", "==", "'l1'", ":", "\n", "            ", "self", ".", "criterion", "=", "torch", ".", "nn", ".", "L1Loss", "(", ")", "\n", "", "elif", "self", ".", "criterion_type", "==", "'l2'", ":", "\n", "            ", "self", ".", "criterion", "=", "torch", ".", "nn", ".", "L2loss", "(", ")", "\n", "", "elif", "self", ".", "criterion_type", "==", "'fro'", ":", "\n", "            ", "self", ".", "criterion", "=", "None", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'{criterion} criterion has not been supported.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss.forward": [[197, 237], ["losses.PerceptualLoss.vgg", "losses.PerceptualLoss.vgg", "gt.detach", "losses.PerceptualLoss.keys", "losses.PerceptualLoss.keys", "torch.norm", "losses.PerceptualLoss.criterion", "torch.norm", "losses.PerceptualLoss.criterion", "losses.PerceptualLoss._gram_mat", "losses.PerceptualLoss._gram_mat", "losses.PerceptualLoss._gram_mat", "losses.PerceptualLoss._gram_mat"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.utils.registry.Registry.keys", "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss._gram_mat", "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss._gram_mat", "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss._gram_mat", "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss._gram_mat"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "gt", ")", ":", "\n", "        ", "\"\"\"Forward function.\n\n        Args:\n            x (Tensor): Input tensor with shape (n, c, h, w).\n            gt (Tensor): Ground-truth tensor with shape (n, c, h, w).\n\n        Returns:\n            Tensor: Forward results.\n        \"\"\"", "\n", "# extract vgg features", "\n", "x_features", "=", "self", ".", "vgg", "(", "x", ")", "\n", "gt_features", "=", "self", ".", "vgg", "(", "gt", ".", "detach", "(", ")", ")", "\n", "\n", "# calculate perceptual loss", "\n", "if", "self", ".", "perceptual_weight", ">", "0", ":", "\n", "            ", "percep_loss", "=", "0", "\n", "for", "k", "in", "x_features", ".", "keys", "(", ")", ":", "\n", "                ", "if", "self", ".", "criterion_type", "==", "'fro'", ":", "\n", "                    ", "percep_loss", "+=", "torch", ".", "norm", "(", "x_features", "[", "k", "]", "-", "gt_features", "[", "k", "]", ",", "p", "=", "'fro'", ")", "*", "self", ".", "layer_weights", "[", "k", "]", "\n", "", "else", ":", "\n", "                    ", "percep_loss", "+=", "self", ".", "criterion", "(", "x_features", "[", "k", "]", ",", "gt_features", "[", "k", "]", ")", "*", "self", ".", "layer_weights", "[", "k", "]", "\n", "", "", "percep_loss", "*=", "self", ".", "perceptual_weight", "\n", "", "else", ":", "\n", "            ", "percep_loss", "=", "None", "\n", "\n", "# calculate style loss", "\n", "", "if", "self", ".", "style_weight", ">", "0", ":", "\n", "            ", "style_loss", "=", "0", "\n", "for", "k", "in", "x_features", ".", "keys", "(", ")", ":", "\n", "                ", "if", "self", ".", "criterion_type", "==", "'fro'", ":", "\n", "                    ", "style_loss", "+=", "torch", ".", "norm", "(", "\n", "self", ".", "_gram_mat", "(", "x_features", "[", "k", "]", ")", "-", "self", ".", "_gram_mat", "(", "gt_features", "[", "k", "]", ")", ",", "p", "=", "'fro'", ")", "*", "self", ".", "layer_weights", "[", "k", "]", "\n", "", "else", ":", "\n", "                    ", "style_loss", "+=", "self", ".", "criterion", "(", "self", ".", "_gram_mat", "(", "x_features", "[", "k", "]", ")", ",", "self", ".", "_gram_mat", "(", "gt_features", "[", "k", "]", ")", ")", "*", "self", ".", "layer_weights", "[", "k", "]", "\n", "", "", "style_loss", "*=", "self", ".", "style_weight", "\n", "", "else", ":", "\n", "            ", "style_loss", "=", "None", "\n", "\n", "", "return", "percep_loss", ",", "style_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.PerceptualLoss._gram_mat": [[238, 252], ["x.size", "x.view", "x.view.transpose", "x.view.bmm"], "methods", ["None"], ["", "def", "_gram_mat", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Calculate Gram matrix.\n\n        Args:\n            x (torch.Tensor): Tensor with shape of (n, c, h, w).\n\n        Returns:\n            torch.Tensor: Gram matrix.\n        \"\"\"", "\n", "n", ",", "c", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "features", "=", "x", ".", "view", "(", "n", ",", "c", ",", "w", "*", "h", ")", "\n", "features_t", "=", "features", ".", "transpose", "(", "1", ",", "2", ")", "\n", "gram", "=", "features", ".", "bmm", "(", "features_t", ")", "/", "(", "c", "*", "h", "*", "w", ")", "\n", "return", "gram", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANLoss.__init__": [[267, 286], ["torch.nn.Module.__init__", "torch.nn.BCEWithLogitsLoss", "torch.nn.MSELoss", "torch.nn.ReLU", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "gan_type", ",", "real_label_val", "=", "1.0", ",", "fake_label_val", "=", "0.0", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "GANLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gan_type", "=", "gan_type", "\n", "self", ".", "loss_weight", "=", "loss_weight", "\n", "self", ".", "real_label_val", "=", "real_label_val", "\n", "self", ".", "fake_label_val", "=", "fake_label_val", "\n", "\n", "if", "self", ".", "gan_type", "==", "'vanilla'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "", "elif", "self", ".", "gan_type", "==", "'lsgan'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "MSELoss", "(", ")", "\n", "", "elif", "self", ".", "gan_type", "==", "'wgan'", ":", "\n", "            ", "self", ".", "loss", "=", "self", ".", "_wgan_loss", "\n", "", "elif", "self", ".", "gan_type", "==", "'wgan_softplus'", ":", "\n", "            ", "self", ".", "loss", "=", "self", ".", "_wgan_softplus_loss", "\n", "", "elif", "self", ".", "gan_type", "==", "'hinge'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "ReLU", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "f'GAN type {self.gan_type} is not implemented.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANLoss._wgan_loss": [[287, 298], ["input.mean", "input.mean"], "methods", ["None"], ["", "", "def", "_wgan_loss", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\"wgan loss.\n\n        Args:\n            input (Tensor): Input tensor.\n            target (bool): Target label.\n\n        Returns:\n            Tensor: wgan loss.\n        \"\"\"", "\n", "return", "-", "input", ".", "mean", "(", ")", "if", "target", "else", "input", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANLoss._wgan_softplus_loss": [[299, 315], ["torch.nn.functional.softplus().mean", "torch.nn.functional.softplus().mean", "torch.nn.functional.softplus", "torch.nn.functional.softplus"], "methods", ["None"], ["", "def", "_wgan_softplus_loss", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\"wgan loss with soft plus. softplus is a smooth approximation to the\n        ReLU function.\n\n        In StyleGAN2, it is called:\n            Logistic loss for discriminator;\n            Non-saturating loss for generator.\n\n        Args:\n            input (Tensor): Input tensor.\n            target (bool): Target label.\n\n        Returns:\n            Tensor: wgan loss.\n        \"\"\"", "\n", "return", "F", ".", "softplus", "(", "-", "input", ")", ".", "mean", "(", ")", "if", "target", "else", "F", ".", "softplus", "(", "input", ")", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANLoss.get_target_label": [[316, 332], ["input.new_ones", "input.size"], "methods", ["None"], ["", "def", "get_target_label", "(", "self", ",", "input", ",", "target_is_real", ")", ":", "\n", "        ", "\"\"\"Get target label.\n\n        Args:\n            input (Tensor): Input tensor.\n            target_is_real (bool): Whether the target is real or fake.\n\n        Returns:\n            (bool | Tensor): Target tensor. Return bool for wgan, otherwise,\n                return Tensor.\n        \"\"\"", "\n", "\n", "if", "self", ".", "gan_type", "in", "[", "'wgan'", ",", "'wgan_softplus'", "]", ":", "\n", "            ", "return", "target_is_real", "\n", "", "target_val", "=", "(", "self", ".", "real_label_val", "if", "target_is_real", "else", "self", ".", "fake_label_val", ")", "\n", "return", "input", ".", "new_ones", "(", "input", ".", "size", "(", ")", ")", "*", "target_val", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANLoss.forward": [[333, 357], ["losses.GANLoss.get_target_label", "losses.GANLoss.loss", "losses.GANLoss.loss().mean", "input.mean", "losses.GANLoss.loss"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANLoss.get_target_label"], ["", "def", "forward", "(", "self", ",", "input", ",", "target_is_real", ",", "is_disc", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input (Tensor): The input for the loss module, i.e., the network\n                prediction.\n            target_is_real (bool): Whether the targe is real or fake.\n            is_disc (bool): Whether the loss for discriminators or not.\n                Default: False.\n\n        Returns:\n            Tensor: GAN loss value.\n        \"\"\"", "\n", "target_label", "=", "self", ".", "get_target_label", "(", "input", ",", "target_is_real", ")", "\n", "if", "self", ".", "gan_type", "==", "'hinge'", ":", "\n", "            ", "if", "is_disc", ":", "# for discriminators in hinge-gan", "\n", "                ", "input", "=", "-", "input", "if", "target_is_real", "else", "input", "\n", "loss", "=", "self", ".", "loss", "(", "1", "+", "input", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "# for generators in hinge-gan", "\n", "                ", "loss", "=", "-", "input", ".", "mean", "(", ")", "\n", "", "", "else", ":", "# other gan types", "\n", "            ", "loss", "=", "self", ".", "loss", "(", "input", ",", "target_label", ")", "\n", "\n", "# loss_weight is always 1.0 for discriminators", "\n", "", "return", "loss", "if", "is_disc", "else", "loss", "*", "self", ".", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.MultiScaleGANLoss.__init__": [[365, 367], ["losses.GANLoss.__init__"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "gan_type", ",", "real_label_val", "=", "1.0", ",", "fake_label_val", "=", "0.0", ",", "loss_weight", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "MultiScaleGANLoss", ",", "self", ")", ".", "__init__", "(", "gan_type", ",", "real_label_val", ",", "fake_label_val", ",", "loss_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.MultiScaleGANLoss.forward": [[368, 385], ["isinstance", "losses.GANLoss.forward", "isinstance", "super().forward().mean", "len", "losses.GANLoss.forward"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANFeatLoss.forward", "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANFeatLoss.forward"], ["", "def", "forward", "(", "self", ",", "input", ",", "target_is_real", ",", "is_disc", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        The input is a list of tensors, or a list of (a list of tensors)\n        \"\"\"", "\n", "if", "isinstance", "(", "input", ",", "list", ")", ":", "\n", "            ", "loss", "=", "0", "\n", "for", "pred_i", "in", "input", ":", "\n", "                ", "if", "isinstance", "(", "pred_i", ",", "list", ")", ":", "\n", "# Only compute GAN loss for the last layer", "\n", "# in case of multiscale feature matching", "\n", "                    ", "pred_i", "=", "pred_i", "[", "-", "1", "]", "\n", "# Safe operaton: 0-dim tensor calling self.mean() does nothing", "\n", "", "loss_tensor", "=", "super", "(", ")", ".", "forward", "(", "pred_i", ",", "target_is_real", ",", "is_disc", ")", ".", "mean", "(", ")", "\n", "loss", "+=", "loss_tensor", "\n", "", "return", "loss", "/", "len", "(", "input", ")", "\n", "", "else", ":", "\n", "            ", "return", "super", "(", ")", ".", "forward", "(", "input", ",", "target_is_real", ",", "is_disc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANFeatLoss.__init__": [[466, 478], ["torch.nn.Module.__init__", "losses.L1Loss", "losses.MSELoss", "losses.CharbonnierLoss", "ValueError"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__"], ["def", "__init__", "(", "self", ",", "criterion", "=", "'l1'", ",", "loss_weight", "=", "1.0", ",", "reduction", "=", "'mean'", ")", ":", "\n", "        ", "super", "(", "GANFeatLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "criterion", "==", "'l1'", ":", "\n", "            ", "self", ".", "loss_op", "=", "L1Loss", "(", "loss_weight", ",", "reduction", ")", "\n", "", "elif", "criterion", "==", "'l2'", ":", "\n", "            ", "self", ".", "loss_op", "=", "MSELoss", "(", "loss_weight", ",", "reduction", ")", "\n", "", "elif", "criterion", "==", "'charbonnier'", ":", "\n", "            ", "self", ".", "loss_op", "=", "CharbonnierLoss", "(", "loss_weight", ",", "reduction", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "f'Unsupported loss mode: {criterion}. '", "f'Supported ones are: l1|l2|charbonnier'", ")", "\n", "\n", "", "self", ".", "loss_weight", "=", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.GANFeatLoss.forward": [[479, 489], ["len", "range", "range", "len", "losses.GANFeatLoss.loss_op", "[].detach"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred_fake", ",", "pred_real", ")", ":", "\n", "        ", "num_D", "=", "len", "(", "pred_fake", ")", "\n", "loss", "=", "0", "\n", "for", "i", "in", "range", "(", "num_D", ")", ":", "# for each discriminator", "\n", "# last output is the final prediction, exclude it", "\n", "            ", "num_intermediate_outputs", "=", "len", "(", "pred_fake", "[", "i", "]", ")", "-", "1", "\n", "for", "j", "in", "range", "(", "num_intermediate_outputs", ")", ":", "# for each layer output", "\n", "                ", "unweighted_loss", "=", "self", ".", "loss_op", "(", "pred_fake", "[", "i", "]", "[", "j", "]", ",", "pred_real", "[", "i", "]", "[", "j", "]", ".", "detach", "(", ")", ")", "\n", "loss", "+=", "unweighted_loss", "/", "num_D", "\n", "", "", "return", "loss", "*", "self", ".", "loss_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.l1_loss": [[16, 19], ["torch.nn.functional.l1_loss"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.l1_loss"], ["@", "weighted_loss", "\n", "def", "l1_loss", "(", "pred", ",", "target", ")", ":", "\n", "    ", "return", "F", ".", "l1_loss", "(", "pred", ",", "target", ",", "reduction", "=", "'none'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.mse_loss": [[21, 24], ["torch.nn.functional.mse_loss"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.mse_loss"], ["", "@", "weighted_loss", "\n", "def", "mse_loss", "(", "pred", ",", "target", ")", ":", "\n", "    ", "return", "F", ".", "mse_loss", "(", "pred", ",", "target", ",", "reduction", "=", "'none'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.charbonnier_loss": [[26, 29], ["torch.sqrt"], "function", ["None"], ["", "@", "weighted_loss", "\n", "def", "charbonnier_loss", "(", "pred", ",", "target", ",", "eps", "=", "1e-12", ")", ":", "\n", "    ", "return", "torch", ".", "sqrt", "(", "(", "pred", "-", "target", ")", "**", "2", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.r1_penalty": [[387, 402], ["grad_real.pow().view().sum().mean", "torch.autograd.grad", "grad_real.pow().view().sum", "real_pred.sum", "grad_real.pow().view", "grad_real.pow"], "function", ["None"], ["", "", "", "def", "r1_penalty", "(", "real_pred", ",", "real_img", ")", ":", "\n", "    ", "\"\"\"R1 regularization for discriminator. The core idea is to\n        penalize the gradient on real data alone: when the\n        generator distribution produces the true data distribution\n        and the discriminator is equal to 0 on the data manifold, the\n        gradient penalty ensures that the discriminator cannot create\n        a non-zero gradient orthogonal to the data manifold without\n        suffering a loss in the GAN game.\n\n        Ref:\n        Eq. 9 in Which training methods for GANs do actually converge.\n        \"\"\"", "\n", "grad_real", "=", "autograd", ".", "grad", "(", "outputs", "=", "real_pred", ".", "sum", "(", ")", ",", "inputs", "=", "real_img", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "grad_penalty", "=", "grad_real", ".", "pow", "(", "2", ")", ".", "view", "(", "grad_real", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", ")", "\n", "return", "grad_penalty", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.g_path_regularize": [[404, 414], ["torch.sqrt", "torch.randn_like", "math.sqrt", "torch.autograd.grad", "grad.pow().sum().mean", "torch.sqrt.detach().mean", "path_mean.detach", "grad.pow().sum", "torch.sqrt.mean", "torch.sqrt.detach", "grad.pow"], "function", ["None"], ["", "def", "g_path_regularize", "(", "fake_img", ",", "latents", ",", "mean_path_length", ",", "decay", "=", "0.01", ")", ":", "\n", "    ", "noise", "=", "torch", ".", "randn_like", "(", "fake_img", ")", "/", "math", ".", "sqrt", "(", "fake_img", ".", "shape", "[", "2", "]", "*", "fake_img", ".", "shape", "[", "3", "]", ")", "\n", "grad", "=", "autograd", ".", "grad", "(", "outputs", "=", "(", "fake_img", "*", "noise", ")", ".", "sum", "(", ")", ",", "inputs", "=", "latents", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "path_lengths", "=", "torch", ".", "sqrt", "(", "grad", ".", "pow", "(", "2", ")", ".", "sum", "(", "2", ")", ".", "mean", "(", "1", ")", ")", "\n", "\n", "path_mean", "=", "mean_path_length", "+", "decay", "*", "(", "path_lengths", ".", "mean", "(", ")", "-", "mean_path_length", ")", "\n", "\n", "path_penalty", "=", "(", "path_lengths", "-", "path_mean", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "return", "path_penalty", ",", "path_lengths", ".", "detach", "(", ")", ".", "mean", "(", ")", ",", "path_mean", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.gradient_penalty_loss": [[416, 453], ["real_data.size", "real_data.new_tensor", "torch.autograd.Variable", "discriminator", "torch.rand", "torch.autograd.grad", "torch.mean", "torch.ones_like", "gradients.norm"], "function", ["None"], ["", "def", "gradient_penalty_loss", "(", "discriminator", ",", "real_data", ",", "fake_data", ",", "weight", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate gradient penalty for wgan-gp.\n\n    Args:\n        discriminator (nn.Module): Network for the discriminator.\n        real_data (Tensor): Real input data.\n        fake_data (Tensor): Fake input data.\n        weight (Tensor): Weight tensor. Default: None.\n\n    Returns:\n        Tensor: A tensor for gradient penalty.\n    \"\"\"", "\n", "\n", "batch_size", "=", "real_data", ".", "size", "(", "0", ")", "\n", "alpha", "=", "real_data", ".", "new_tensor", "(", "torch", ".", "rand", "(", "batch_size", ",", "1", ",", "1", ",", "1", ")", ")", "\n", "\n", "# interpolate between real_data and fake_data", "\n", "interpolates", "=", "alpha", "*", "real_data", "+", "(", "1.", "-", "alpha", ")", "*", "fake_data", "\n", "interpolates", "=", "autograd", ".", "Variable", "(", "interpolates", ",", "requires_grad", "=", "True", ")", "\n", "\n", "disc_interpolates", "=", "discriminator", "(", "interpolates", ")", "\n", "gradients", "=", "autograd", ".", "grad", "(", "\n", "outputs", "=", "disc_interpolates", ",", "\n", "inputs", "=", "interpolates", ",", "\n", "grad_outputs", "=", "torch", ".", "ones_like", "(", "disc_interpolates", ")", ",", "\n", "create_graph", "=", "True", ",", "\n", "retain_graph", "=", "True", ",", "\n", "only_inputs", "=", "True", ")", "[", "0", "]", "\n", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "gradients", "=", "gradients", "*", "weight", "\n", "\n", "", "gradients_penalty", "=", "(", "(", "gradients", ".", "norm", "(", "2", ",", "dim", "=", "1", ")", "-", "1", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "gradients_penalty", "/=", "torch", ".", "mean", "(", "weight", ")", "\n", "\n", "", "return", "gradients_penalty", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.losses.compute_gradient_penalty": [[491, 511], ["torch.cuda.FloatTensor", "D", "torch.autograd.Variable", "gradients.view.view", "numpy.random.random", "torch.cuda.FloatTensor().fill_", "torch.autograd.grad", "gradients.view.size", "real_samples.size", "torch.cuda.FloatTensor", "gradients.view.norm"], "function", ["None"], ["", "", "def", "compute_gradient_penalty", "(", "D", ",", "real_samples", ",", "fake_samples", ")", ":", "\n", "\n", "# Random weight term for interpolation between real and fake samples", "\n", "    ", "alpha", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "np", ".", "random", ".", "random", "(", "(", "real_samples", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", ")", ")", "\n", "# Get random interpolation between real and fake samples", "\n", "interpolates", "=", "(", "alpha", "*", "real_samples", "+", "(", "(", "1", "-", "alpha", ")", "*", "fake_samples", ")", ")", ".", "requires_grad_", "(", "True", ")", "\n", "d_interpolates", "=", "D", "(", "interpolates", ")", "\n", "fake", "=", "Variable", "(", "torch", ".", "cuda", ".", "FloatTensor", "(", "real_samples", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "1", ")", ".", "fill_", "(", "1.0", ")", ",", "requires_grad", "=", "False", ")", "\n", "# Get gradient w.r.t. interpolates", "\n", "gradients", "=", "autograd", ".", "grad", "(", "\n", "outputs", "=", "d_interpolates", ",", "\n", "inputs", "=", "interpolates", ",", "\n", "grad_outputs", "=", "fake", ",", "\n", "create_graph", "=", "True", ",", "\n", "retain_graph", "=", "True", ",", "\n", "only_inputs", "=", "True", ",", "\n", ")", "[", "0", "]", "\n", "gradients", "=", "gradients", ".", "view", "(", "gradients", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "gradient_penalty", "=", "(", "(", "gradients", ".", "norm", "(", "2", ",", "dim", "=", "1", ")", "-", "1", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "return", "gradient_penalty", "", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.loss_util.reduce_loss": [[5, 23], ["torch.nn.functional._Reduction.get_enum", "loss.mean", "loss.sum"], "function", ["None"], ["def", "reduce_loss", "(", "loss", ",", "reduction", ")", ":", "\n", "    ", "\"\"\"Reduce loss as specified.\n\n    Args:\n        loss (Tensor): Elementwise loss tensor.\n        reduction (str): Options are 'none', 'mean' and 'sum'.\n\n    Returns:\n        Tensor: Reduced loss tensor.\n    \"\"\"", "\n", "reduction_enum", "=", "F", ".", "_Reduction", ".", "get_enum", "(", "reduction", ")", "\n", "# none: 0, elementwise_mean:1, sum: 2", "\n", "if", "reduction_enum", "==", "0", ":", "\n", "        ", "return", "loss", "\n", "", "elif", "reduction_enum", "==", "1", ":", "\n", "        ", "return", "loss", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "loss", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.loss_util.weight_reduce_loss": [[25, 55], ["loss_util.reduce_loss", "weight.sum.dim", "reduce_loss.dim", "weight.sum.size", "weight.sum.size", "reduce_loss.size", "weight.sum.size", "weight.sum.sum", "reduce_loss.sum", "weight.sum.sum", "reduce_loss.size"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.loss_util.reduce_loss"], ["", "", "def", "weight_reduce_loss", "(", "loss", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ")", ":", "\n", "    ", "\"\"\"Apply element-wise weight and reduce loss.\n\n    Args:\n        loss (Tensor): Element-wise loss.\n        weight (Tensor): Element-wise weights. Default: None.\n        reduction (str): Same as built-in losses of PyTorch. Options are\n            'none', 'mean' and 'sum'. Default: 'mean'.\n\n    Returns:\n        Tensor: Loss values.\n    \"\"\"", "\n", "# if weight is specified, apply element-wise weight", "\n", "if", "weight", "is", "not", "None", ":", "\n", "        ", "assert", "weight", ".", "dim", "(", ")", "==", "loss", ".", "dim", "(", ")", "\n", "assert", "weight", ".", "size", "(", "1", ")", "==", "1", "or", "weight", ".", "size", "(", "1", ")", "==", "loss", ".", "size", "(", "1", ")", "\n", "loss", "=", "loss", "*", "weight", "\n", "\n", "# if weight is not specified or reduction is sum, just reduce the loss", "\n", "", "if", "weight", "is", "None", "or", "reduction", "==", "'sum'", ":", "\n", "        ", "loss", "=", "reduce_loss", "(", "loss", ",", "reduction", ")", "\n", "# if reduction is mean, then compute mean over weight region", "\n", "", "elif", "reduction", "==", "'mean'", ":", "\n", "        ", "if", "weight", ".", "size", "(", "1", ")", ">", "1", ":", "\n", "            ", "weight", "=", "weight", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "weight", "=", "weight", ".", "sum", "(", ")", "*", "loss", ".", "size", "(", "1", ")", "\n", "", "loss", "=", "loss", ".", "sum", "(", ")", "/", "weight", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.losses.loss_util.weighted_loss": [[57, 96], ["functools.wraps", "loss_func", "loss_util.weight_reduce_loss"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.losses.loss_util.weight_reduce_loss"], ["", "def", "weighted_loss", "(", "loss_func", ")", ":", "\n", "    ", "\"\"\"Create a weighted version of a given loss function.\n\n    To use this decorator, the loss function must have the signature like\n    `loss_func(pred, target, **kwargs)`. The function only needs to compute\n    element-wise loss without any reduction. This decorator will add weight\n    and reduction arguments to the function. The decorated function will have\n    the signature like `loss_func(pred, target, weight=None, reduction='mean',\n    **kwargs)`.\n\n    :Example:\n\n    >>> import torch\n    >>> @weighted_loss\n    >>> def l1_loss(pred, target):\n    >>>     return (pred - target).abs()\n\n    >>> pred = torch.Tensor([0, 2, 3])\n    >>> target = torch.Tensor([1, 1, 1])\n    >>> weight = torch.Tensor([1, 0, 1])\n\n    >>> l1_loss(pred, target)\n    tensor(1.3333)\n    >>> l1_loss(pred, target, weight)\n    tensor(1.5000)\n    >>> l1_loss(pred, target, reduction='none')\n    tensor([1., 1., 2.])\n    >>> l1_loss(pred, target, weight, reduction='sum')\n    tensor(3.)\n    \"\"\"", "\n", "\n", "@", "functools", ".", "wraps", "(", "loss_func", ")", "\n", "def", "wrapper", "(", "pred", ",", "target", ",", "weight", "=", "None", ",", "reduction", "=", "'mean'", ",", "**", "kwargs", ")", ":", "\n", "# get element-wise loss", "\n", "        ", "loss", "=", "loss_func", "(", "pred", ",", "target", ",", "**", "kwargs", ")", "\n", "loss", "=", "weight_reduce_loss", "(", "loss", ",", "weight", ",", "reduction", ")", "\n", "return", "loss", "\n", "\n", "", "return", "wrapper", "\n", "", ""]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_realsr_validation_set_type3.degrade_func": [[30, 333], ["torch.no_grad", "torch.no_grad", "sorted", "glob.glob", "os.path.basename", "os.path.basename", "print", "print", "cv2.imread", "basicsr.utils.img2tensor().unsqueeze().cuda().contiguous", "basicsr.utils.DiffJPEG().cuda", "torch.zeros().float", "torch.zeros().float", "random.choice", "random.choice", "numpy.pad", "random.choice", "random.choice", "numpy.pad", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.zeros", "torch.zeros", "basicsr.utils.img_process_util.filter2D", "random.choice", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.tensor().expand", "torch.zeros.expand", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "torch.clamp", "DiffJPEG().cuda.", "normalized_jpeg_p.unsqueeze", "random.choice", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.tensor().expand", "torch.zeros.expand", "print", "print", "basicsr.utils.tensor2img", "print", "cv2.imwrite", "cv2.imwrite", "os.path.join", "os.path.join", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "numpy.random.uniform", "random.choice", "random.choice", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.zeros().float.cuda", "img2tensor().unsqueeze().cuda().contiguous.size", "random.choices", "random.choices", "numpy.random.uniform", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "basicsr.data.degradations.only_generate_poisson_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "basicsr.data.degradations.only_generate_gaussian_noise_pt", "numpy.random.uniform", "basicsr.utils.img_process_util.filter2D", "torch.tensor().expand", "torch.tensor().expand", "random.choices", "random.choices", "numpy.random.uniform", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "basicsr.data.degradations.only_generate_poisson_noise_pt", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "basicsr.data.degradations.only_generate_gaussian_noise_pt", "numpy.random.uniform", "random.choice", "random.choice", "torch.zeros", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "torch.clamp", "DiffJPEG().cuda.", "normalized_jpeg_p.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "torch.zeros.expand", "basicsr.utils.img_process_util.filter2D.new_zeros().uniform_", "torch.clamp", "torch.clamp", "DiffJPEG().cuda.", "random.choice", "random.choice", "torch.zeros", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "basicsr.utils.img_process_util.filter2D", "normalized_jpeg_p.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "torch.zeros.expand", "torch.clamp", "torch.clamp", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "basicsr.utils.img2tensor().unsqueeze().cuda", "basicsr.utils.DiffJPEG", "range", "torch.zeros", "torch.zeros", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.random.uniform", "torch.tensor", "torch.tensor", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "basicsr.utils.img_process_util.filter2D.new_zeros", "img2tensor().unsqueeze().cuda().contiguous.size", "numpy.random.uniform", "torch.tensor", "torch.tensor", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "os.path.basename.split", "str", "math.ceil", "math.ceil", "math.ceil", "math.ceil", "int", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "basicsr.utils.img_process_util.filter2D.size", "torch.tensor", "torch.tensor", "int", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "basicsr.utils.img_process_util.filter2D.new_zeros", "torch.tensor", "torch.tensor", "basicsr.utils.img_process_util.filter2D.new_zeros", "torch.tensor", "torch.tensor", "value.numpy", "basicsr.utils.img2tensor().unsqueeze", "basicsr.utils.img_process_util.filter2D.size", "basicsr.utils.img_process_util.filter2D.size", "basicsr.utils.img2tensor"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.only_generate_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "degrade_func", "(", "img_dir", ",", "output_dir", ")", ":", "\n", "\n", "    ", "img_list", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "img_dir", ",", "'*'", ")", ")", ")", "\n", "for", "img_path", "in", "img_list", ":", "\n", "        ", "img_name", "=", "os", ".", "path", ".", "basename", "(", "img_path", ")", "\n", "print", "(", "f'Processing {img_name} ...'", ")", "\n", "print", "(", "img_path", ")", "\n", "input_img", "=", "cv2", ".", "imread", "(", "img_path", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "gt", "=", "img2tensor", "(", "input_img", "/", "255.", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ".", "contiguous", "(", ")", "\n", "\n", "resize_mode_list", "=", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", "\n", "jpeger", "=", "DiffJPEG", "(", "differentiable", "=", "False", ")", ".", "cuda", "(", ")", "\n", "\n", "scale_overall", "=", "4", "\n", "\n", "# the first degradation process", "\n", "resize_prob", "=", "[", "0.2", ",", "0.7", ",", "0.1", "]", "# up, down, keep", "\n", "resize_range", "=", "[", "0.15", ",", "1.5", "]", "\n", "gaussian_noise_prob", "=", "0.5", "\n", "noise_range", "=", "[", "1", ",", "30", "]", "\n", "poisson_scale_range", "=", "[", "0.05", ",", "3", "]", "\n", "gray_noise_prob", "=", "0.4", "\n", "jpeg_range", "=", "[", "30", ",", "95", "]", "\n", "\n", "# the second degradation process", "\n", "second_blur_prob", "=", "0.8", "\n", "resize_prob2", "=", "[", "0.3", ",", "0.4", ",", "0.3", "]", "# up, down, keep", "\n", "resize_range2", "=", "[", "0.3", ",", "1.2", "]", "\n", "gaussian_noise_prob2", "=", "0.5", "\n", "noise_range2", "=", "[", "1", ",", "25", "]", "\n", "poisson_scale_range2", "=", "[", "0.05", ",", "2.5", "]", "\n", "gray_noise_prob2", "=", "0.4", "\n", "jpeg_range2", "=", "[", "30", ",", "95", "]", "\n", "\n", "# blur settings for the first degradation", "\n", "blur_kernel_size_minimum", "=", "7", "\n", "blur_kernel_size", "=", "21", "\n", "kernel_list", "=", "[", "'iso'", ",", "'aniso'", "]", "\n", "kernel_prob", "=", "[", "0.65", ",", "0.35", "]", "\n", "blur_sigma", "=", "[", "0.2", ",", "3", "]", "\n", "betag_range", "=", "[", "0.5", ",", "4", "]", "\n", "betap_range", "=", "[", "1", ",", "2", "]", "\n", "sinc_prob", "=", "0", "\n", "\n", "# blur settings for the second degradation", "\n", "kernel_list2", "=", "[", "'iso'", ",", "'aniso'", "]", "\n", "kernel_prob2", "=", "[", "0.65", ",", "0.35", "]", "\n", "blur_sigma2", "=", "[", "0.2", ",", "1.5", "]", "\n", "betag_range2", "=", "[", "0.5", ",", "4", "]", "\n", "betap_range2", "=", "[", "1", ",", "2", "]", "\n", "sinc_prob2", "=", "0", "\n", "\n", "# a final sinc filter", "\n", "final_sinc_prob", "=", "0.8", "\n", "\n", "kernel_range", "=", "[", "2", "*", "v", "+", "1", "for", "v", "in", "range", "(", "math", ".", "ceil", "(", "blur_kernel_size_minimum", "/", "2", ")", ",", "math", ".", "ceil", "(", "blur_kernel_size", "/", "2", ")", ")", "]", "# kernel size ranges from 7 to 21", "\n", "pulse_tensor", "=", "torch", ".", "zeros", "(", "blur_kernel_size", ",", "blur_kernel_size", ")", ".", "float", "(", ")", "# convolving with pulse tensor brings no blurry effect", "\n", "pulse_tensor", "[", "int", "(", "blur_kernel_size", "/", "2", ")", ",", "int", "(", "blur_kernel_size", "/", "2", ")", "]", "=", "1", "\n", "\n", "# ------------------------ Generate kernels (used in the first degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "sinc_prob", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel_info", "=", "random_mixed_kernels_Info", "(", "\n", "kernel_list", ",", "\n", "kernel_prob", ",", "\n", "kernel_size", ",", "\n", "blur_sigma", ",", "\n", "blur_sigma", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "betag_range", ",", "\n", "betap_range", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel", "=", "kernel_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# ------------------------ Generate kernels (used in the second degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "sinc_prob2", ":", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel2", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel2_info", "=", "random_mixed_kernels_Info", "(", "\n", "kernel_list2", ",", "\n", "kernel_prob2", ",", "\n", "kernel_size", ",", "\n", "blur_sigma2", ",", "\n", "blur_sigma2", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "betag_range2", ",", "\n", "betap_range2", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel2", "=", "kernel2_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel2", "=", "np", ".", "pad", "(", "kernel2", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# ------------------------------------- sinc kernel ------------------------------------- #", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "final_sinc_prob", ":", "\n", "            ", "kernel_size", "=", "random", ".", "choice", "(", "kernel_range", ")", "\n", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "sinc_kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "21", ")", "\n", "sinc_kernel", "=", "torch", ".", "FloatTensor", "(", "sinc_kernel", ")", ".", "cuda", "(", ")", "\n", "kernel_sinc_info", "=", "{", "'kernel'", ":", "sinc_kernel", ",", "'kernel_size'", ":", "kernel_size", ",", "'omega_c'", ":", "omega_c", "}", "\n", "", "else", ":", "\n", "            ", "sinc_kernel", "=", "pulse_tensor", ".", "cuda", "(", ")", "\n", "kernel_sinc_info", "=", "{", "'kernel'", ":", "sinc_kernel", ",", "'kernel_size'", ":", "0", ",", "'omega_c'", ":", "0", "}", "\n", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "# img_gt = img2tensor([img_gt], bgr2rgb=True, float32=True)[0]", "\n", "", "kernel1", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", ".", "cuda", "(", ")", "\n", "kernel2", "=", "torch", ".", "FloatTensor", "(", "kernel2", ")", ".", "cuda", "(", ")", "\n", "kernel_info", "[", "'kernel'", "]", "=", "kernel1", "\n", "kernel2_info", "[", "'kernel'", "]", "=", "kernel2", "\n", "\n", "# self.kernel1 = data['kernel1'].to(self.device)", "\n", "# self.kernel2 = data['kernel2'].to(self.device)", "\n", "# self.sinc_kernel = data['sinc_kernel'].to(self.device)", "\n", "\n", "# ori_h, ori_w = self.gt.size()[2:4]", "\n", "\n", "num_degradation_params", "=", "4", "*", "2", "+", "2", "# kernel", "\n", "num_degradation_params", "+=", "4", "*", "2", "# resize", "\n", "num_degradation_params", "+=", "4", "*", "2", "# noise", "\n", "num_degradation_params", "+=", "3", "+", "2", "+", "2", "# jpeg", "\n", "degradation_params", "=", "torch", ".", "zeros", "(", "num_degradation_params", ")", "\n", "road_map", "=", "[", "0", ",", "10", ",", "10", "+", "8", ",", "10", "+", "8", "+", "8", ",", "10", "+", "8", "+", "8", "+", "7", "]", "\n", "\n", "# {'kernel': kernel, 'kernel_size': kernel_size, 'sigma_x': sigma_x, 'sigma_y': sigma_y, 'rotation': rotation}", "\n", "kernel_size_range1", "=", "[", "blur_kernel_size_minimum", ",", "blur_kernel_size", "]", "\n", "kernel_size_range2", "=", "[", "blur_kernel_size_minimum", ",", "blur_kernel_size", "]", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", "\n", "omega_c_range", "=", "[", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", "]", "\n", "degradation_params", "[", "road_map", "[", "0", "]", ":", "road_map", "[", "0", "]", "+", "1", "]", "=", "(", "kernel_info", "[", "'kernel_size'", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "4", ":", "road_map", "[", "0", "]", "+", "5", "]", "=", "(", "kernel2_info", "[", "'kernel_size'", "]", "-", "kernel_size_range2", "[", "0", "]", ")", "/", "(", "kernel_size_range2", "[", "1", "]", "-", "kernel_size_range2", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "1", ":", "road_map", "[", "0", "]", "+", "2", "]", "=", "(", "kernel_info", "[", "'sigma_x'", "]", "-", "blur_sigma", "[", "0", "]", ")", "/", "(", "blur_sigma", "[", "1", "]", "-", "blur_sigma", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "5", ":", "road_map", "[", "0", "]", "+", "6", "]", "=", "(", "kernel2_info", "[", "'sigma_x'", "]", "-", "blur_sigma2", "[", "0", "]", ")", "/", "(", "blur_sigma2", "[", "1", "]", "-", "blur_sigma2", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "2", ":", "road_map", "[", "0", "]", "+", "3", "]", "=", "(", "kernel_info", "[", "'sigma_y'", "]", "-", "blur_sigma", "[", "0", "]", ")", "/", "(", "blur_sigma", "[", "1", "]", "-", "blur_sigma", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "6", ":", "road_map", "[", "0", "]", "+", "7", "]", "=", "(", "kernel2_info", "[", "'sigma_y'", "]", "-", "blur_sigma2", "[", "0", "]", ")", "/", "(", "blur_sigma2", "[", "1", "]", "-", "blur_sigma2", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "3", ":", "road_map", "[", "0", "]", "+", "4", "]", "=", "(", "kernel_info", "[", "'rotation'", "]", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "7", ":", "road_map", "[", "0", "]", "+", "8", "]", "=", "(", "kernel2_info", "[", "'rotation'", "]", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "8", ":", "road_map", "[", "0", "]", "+", "9", "]", "=", "(", "kernel_sinc_info", "[", "'kernel_size'", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "9", ":", "road_map", "[", "1", "]", "]", "=", "(", "kernel_sinc_info", "[", "'omega_c'", "]", "-", "omega_c_range", "[", "0", "]", ")", "/", "(", "omega_c_range", "[", "1", "]", "-", "omega_c_range", "[", "0", "]", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# ----------------------- The first degradation process ----------------------- #", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "gt", ",", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "resize_prob", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "resize_range", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "resize_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "resize_range", "[", "0", "]", ")", "/", "(", "resize_range", "[", "1", "]", "-", "resize_range", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "            ", "if", "mode_current", "==", "mode", ":", "\n", "                ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "degradation_params", "[", "road_map", "[", "1", "]", ":", "road_map", "[", "1", "]", "+", "1", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "1", "]", "+", "1", ":", "road_map", "[", "1", "]", "+", "4", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "gaussian_noise_prob", ":", "\n", "            ", "sigma", ",", "gray_noise", ",", "out", ",", "noise_g_first", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "noise_range", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "normalized_sigma", "=", "(", "sigma", "-", "noise_range", "[", "0", "]", ")", "/", "(", "noise_range", "[", "1", "]", "-", "noise_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", ":", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "1", ":", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "2", ":", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "noise_p_first", "=", "only_generate_poisson_noise_pt", "(", "out", ",", "scale_range", "=", "poisson_scale_range", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "", "else", ":", "\n", "            ", "scale", ",", "gray_noise", ",", "out", ",", "noise_p_first", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "scale_range", "=", "poisson_scale_range", ",", "gray_prob", "=", "gray_noise_prob", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "poisson_scale_range", "[", "0", "]", ")", "/", "(", "poisson_scale_range", "[", "1", "]", "-", "poisson_scale_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", ":", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "1", ":", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "2", ":", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "noise_g_first", "=", "only_generate_gaussian_noise_pt", "(", "out", ",", "sigma_range", "=", "noise_range", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "jpeg_range", ")", "# tensor([61.6463, 94.2723, 37.1205, 34.9564], device='cuda:0')]", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "jpeg_range", "[", "0", "]", ")", "/", "(", "jpeg_range", "[", "1", "]", "-", "jpeg_range", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", ":", "road_map", "[", "3", "]", "+", "1", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# ----------------------- The second degradation process ----------------------- #", "\n", "# blur", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "second_blur_prob", ":", "\n", "            ", "out", "=", "filter2D", "(", "out", ",", "kernel2", ")", "\n", "degradation_params", "[", "road_map", "[", "1", "]", "-", "1", ":", "road_map", "[", "1", "]", "]", "=", "torch", ".", "tensor", "(", "[", "1", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "# random resize", "\n", "", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "resize_prob2", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "resize_range2", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "resize_range2", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "int", "(", "ori_h", "/", "scale_overall", "*", "scale", ")", ",", "int", "(", "ori_w", "/", "scale_overall", "*", "scale", ")", ")", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "resize_range2", "[", "0", "]", ")", "/", "(", "resize_range2", "[", "1", "]", "-", "resize_range2", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "            ", "if", "mode_current", "==", "mode", ":", "\n", "                ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "degradation_params", "[", "road_map", "[", "1", "]", "+", "4", ":", "road_map", "[", "1", "]", "+", "5", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "1", "]", "+", "5", ":", "road_map", "[", "2", "]", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "# noise", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "gaussian_noise_prob2", ":", "\n", "            ", "sigma", ",", "gray_noise", ",", "out", ",", "noise_g_second", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "noise_range2", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob2", ")", "\n", "normalized_sigma", "=", "(", "sigma", "-", "noise_range2", "[", "0", "]", ")", "/", "(", "noise_range2", "[", "1", "]", "-", "noise_range2", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "4", ":", "road_map", "[", "2", "]", "+", "5", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "5", ":", "road_map", "[", "2", "]", "+", "6", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "6", ":", "road_map", "[", "3", "]", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "noise_p_second", "=", "only_generate_poisson_noise_pt", "(", "out", ",", "scale_range", "=", "poisson_scale_range2", ",", "gray_prob", "=", "gray_noise_prob2", ")", "\n", "", "else", ":", "\n", "            ", "scale", ",", "gray_noise", ",", "out", ",", "noise_p_second", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "\n", "scale_range", "=", "poisson_scale_range2", ",", "\n", "gray_prob", "=", "gray_noise_prob", ",", "\n", "clip", "=", "True", ",", "\n", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "poisson_scale_range2", "[", "0", "]", ")", "/", "(", "poisson_scale_range2", "[", "1", "]", "-", "poisson_scale_range2", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "4", ":", "road_map", "[", "2", "]", "+", "5", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "5", ":", "road_map", "[", "2", "]", "+", "6", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "6", ":", "road_map", "[", "3", "]", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "noise_g_second", "=", "only_generate_gaussian_noise_pt", "(", "out", ",", "sigma_range", "=", "noise_range2", ",", "gray_prob", "=", "gray_noise_prob2", ")", "\n", "\n", "# JPEG compression + the final sinc filter", "\n", "# We also need to resize images to desired sizes. We group [resize back + sinc filter] together", "\n", "# as one operation.", "\n", "# We consider two orders:", "\n", "#   1. [resize back + sinc filter] + JPEG compression", "\n", "#   2. JPEG compression + [resize back + sinc filter]", "\n", "# Empirically, we find other combinations (sinc + JPEG + Resize) will introduce twisted lines.", "\n", "", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "0.5", ":", "\n", "# resize back + the final sinc filter", "\n", "            ", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "                ", "if", "mode_current", "==", "mode", ":", "\n", "                    ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "scale_overall", ",", "ori_w", "//", "scale_overall", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "sinc_kernel", ")", "\n", "# JPEG compression", "\n", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "jpeg_range2", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "jpeg_range2", "[", "0", "]", ")", "/", "(", "jpeg_range2", "[", "1", "]", "-", "jpeg_range2", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "1", ":", "road_map", "[", "3", "]", "+", "2", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "2", ":", "road_map", "[", "3", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "", "else", ":", "\n", "# JPEG compression", "\n", "            ", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "jpeg_range2", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "jpeg_range2", "[", "0", "]", ")", "/", "(", "jpeg_range2", "[", "1", "]", "-", "jpeg_range2", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "# resize back + the final sinc filter", "\n", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "                ", "if", "mode_current", "==", "mode", ":", "\n", "                    ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "scale_overall", ",", "ori_w", "//", "scale_overall", ")", ",", "mode", "=", "mode", ")", "\n", "out", "=", "filter2D", "(", "out", ",", "sinc_kernel", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "1", ":", "road_map", "[", "3", "]", "+", "2", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "2", ":", "road_map", "[", "3", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "\n", "", "print", "(", "degradation_params", ")", "\n", "\n", "# clamp and round", "\n", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "print", "(", "out", ".", "shape", ")", "\n", "out", "=", "tensor2img", "(", "out", ")", "\n", "target_name", "=", "img_name", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'__'", "\n", "for", "value", "in", "degradation_params", ":", "\n", "            ", "target_name", "+=", "str", "(", "value", ".", "numpy", "(", ")", ")", "+", "'_'", "\n", "", "target_name", "+=", "'_.png'", "\n", "print", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "target_name", ")", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", "+", "'_withparams'", ",", "target_name", ")", ",", "out", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "img_name", ")", ",", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_realsr_validation_set_type1.degrade_func": [[38, 191], ["torch.no_grad", "torch.no_grad", "sorted", "glob.glob", "os.path.basename", "os.path.basename", "print", "print", "cv2.imread", "basicsr.utils.img2tensor().unsqueeze().cuda().contiguous", "basicsr.utils.DiffJPEG().cuda", "torch.zeros().float", "torch.zeros().float", "random.choice", "random.choice", "numpy.pad", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.zeros", "torch.zeros", "basicsr.utils.img_process_util.filter2D", "random.choice", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.tensor().expand", "torch.zeros.expand", "basicsr.utils.tensor2img.new_zeros().uniform_", "torch.clamp", "torch.clamp", "DiffJPEG().cuda.", "normalized_jpeg_p.unsqueeze", "random.choice", "random.choice", "torch.zeros", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "torch.zeros.expand", "print", "print", "basicsr.utils.tensor2img", "print", "cv2.imwrite", "cv2.imwrite", "os.path.join", "os.path.join", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "img2tensor().unsqueeze().cuda().contiguous.size", "random.choices", "random.choices", "numpy.random.uniform", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "torch.clamp", "torch.clamp", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "basicsr.utils.img2tensor().unsqueeze().cuda", "basicsr.utils.DiffJPEG", "range", "torch.zeros", "torch.zeros", "numpy.random.uniform", "numpy.random.uniform", "torch.FloatTensor", "torch.FloatTensor", "numpy.random.uniform", "torch.tensor", "torch.tensor", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "basicsr.utils.tensor2img.new_zeros", "os.path.basename.split", "str", "math.ceil", "math.ceil", "math.ceil", "math.ceil", "int", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "basicsr.utils.tensor2img.size", "value.numpy", "basicsr.utils.img2tensor().unsqueeze", "basicsr.utils.img2tensor"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "degrade_func", "(", "img_dir", ",", "output_dir", ")", ":", "\n", "\n", "    ", "img_list", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "img_dir", ",", "'*'", ")", ")", ")", "\n", "for", "img_path", "in", "img_list", ":", "\n", "        ", "img_name", "=", "os", ".", "path", ".", "basename", "(", "img_path", ")", "\n", "print", "(", "f'Processing {img_name} ...'", ")", "\n", "# img_path = os.path.join(img_path, img_name)", "\n", "print", "(", "img_path", ")", "\n", "input_img", "=", "cv2", ".", "imread", "(", "img_path", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "gt", "=", "img2tensor", "(", "input_img", "/", "255.", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ".", "contiguous", "(", ")", "\n", "\n", "resize_mode_list", "=", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", "\n", "jpeger", "=", "DiffJPEG", "(", "differentiable", "=", "False", ")", ".", "cuda", "(", ")", "\n", "\n", "scale_overall", "=", "4", "\n", "\n", "# the first degradation process", "\n", "resize_prob", "=", "[", "0.1", ",", "0.2", ",", "0.7", "]", "# up, down, keep", "\n", "resize_range", "=", "[", "0.85", ",", "1.2", "]", "\n", "gaussian_noise_prob", "=", "0.5", "\n", "noise_range", "=", "[", "1", ",", "10", "]", "\n", "poisson_scale_range", "=", "[", "0.05", ",", "0.5", "]", "\n", "gray_noise_prob", "=", "0.4", "\n", "jpeg_range", "=", "[", "90", ",", "95", "]", "\n", "\n", "# blur settings for the first degradation", "\n", "blur_kernel_size_minimum", "=", "7", "\n", "blur_kernel_size", "=", "21", "\n", "kernel_list", "=", "[", "'iso'", ",", "'aniso'", "]", "\n", "kernel_prob", "=", "[", "0.65", ",", "0.35", "]", "\n", "blur_sigma", "=", "[", "0.2", ",", "0.8", "]", "\n", "betag_range", "=", "[", "0.5", ",", "4", "]", "\n", "betap_range", "=", "[", "1", ",", "2", "]", "\n", "sinc_prob", "=", "0", "\n", "\n", "\n", "kernel_range", "=", "[", "2", "*", "v", "+", "1", "for", "v", "in", "range", "(", "math", ".", "ceil", "(", "blur_kernel_size_minimum", "/", "2", ")", ",", "math", ".", "ceil", "(", "blur_kernel_size", "/", "2", ")", ")", "]", "# kernel size ranges from 7 to 21", "\n", "pulse_tensor", "=", "torch", ".", "zeros", "(", "blur_kernel_size", ",", "blur_kernel_size", ")", ".", "float", "(", ")", "# convolving with pulse tensor brings no blurry effect", "\n", "pulse_tensor", "[", "int", "(", "blur_kernel_size", "/", "2", ")", ",", "int", "(", "blur_kernel_size", "/", "2", ")", "]", "=", "1", "\n", "\n", "# ------------------------ Generate kernels (used in the first degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "sinc_prob", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel_info", "=", "random_mixed_kernels_Info", "(", "\n", "kernel_list", ",", "\n", "kernel_prob", ",", "\n", "kernel_size", ",", "\n", "blur_sigma", ",", "\n", "blur_sigma", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "betag_range", ",", "\n", "betap_range", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel", "=", "kernel_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "# img_gt = img2tensor([img_gt], bgr2rgb=True, float32=True)[0]", "\n", "kernel1", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", ".", "cuda", "(", ")", "\n", "kernel_info", "[", "'kernel'", "]", "=", "kernel1", "\n", "\n", "num_degradation_params", "=", "4", "*", "2", "+", "2", "# kernel", "\n", "num_degradation_params", "+=", "4", "*", "2", "# resize", "\n", "num_degradation_params", "+=", "4", "*", "2", "# noise", "\n", "num_degradation_params", "+=", "3", "+", "2", "+", "2", "# jpeg", "\n", "degradation_params", "=", "torch", ".", "zeros", "(", "num_degradation_params", ")", "\n", "road_map", "=", "[", "0", ",", "10", ",", "10", "+", "8", ",", "10", "+", "8", "+", "8", ",", "10", "+", "8", "+", "8", "+", "7", "]", "\n", "\n", "kernel_size_range1", "=", "[", "blur_kernel_size_minimum", ",", "blur_kernel_size", "]", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", "\n", "degradation_params", "[", "road_map", "[", "0", "]", ":", "road_map", "[", "0", "]", "+", "1", "]", "=", "(", "kernel_info", "[", "'kernel_size'", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "1", ":", "road_map", "[", "0", "]", "+", "2", "]", "=", "(", "kernel_info", "[", "'sigma_x'", "]", "-", "blur_sigma", "[", "0", "]", ")", "/", "(", "blur_sigma", "[", "1", "]", "-", "blur_sigma", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "2", ":", "road_map", "[", "0", "]", "+", "3", "]", "=", "(", "kernel_info", "[", "'sigma_y'", "]", "-", "blur_sigma", "[", "0", "]", ")", "/", "(", "blur_sigma", "[", "1", "]", "-", "blur_sigma", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "3", ":", "road_map", "[", "0", "]", "+", "4", "]", "=", "(", "kernel_info", "[", "'rotation'", "]", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# ----------------------- The first degradation process ----------------------- #", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "gt", ",", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "resize_prob", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "resize_range", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "resize_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "resize_range", "[", "0", "]", ")", "/", "(", "resize_range", "[", "1", "]", "-", "resize_range", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "            ", "if", "mode_current", "==", "mode", ":", "\n", "                ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "degradation_params", "[", "road_map", "[", "1", "]", ":", "road_map", "[", "1", "]", "+", "1", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "1", "]", "+", "1", ":", "road_map", "[", "1", "]", "+", "4", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "gaussian_noise_prob", ":", "\n", "            ", "sigma", ",", "gray_noise", ",", "out", ",", "noise_g_first", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "noise_range", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "normalized_sigma", "=", "(", "sigma", "-", "noise_range", "[", "0", "]", ")", "/", "(", "noise_range", "[", "1", "]", "-", "noise_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", ":", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "1", ":", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "2", ":", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "", "else", ":", "\n", "            ", "scale", ",", "gray_noise", ",", "out", ",", "noise_p_first", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "scale_range", "=", "poisson_scale_range", ",", "gray_prob", "=", "gray_noise_prob", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "poisson_scale_range", "[", "0", "]", ")", "/", "(", "poisson_scale_range", "[", "1", "]", "-", "poisson_scale_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", ":", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "1", ":", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "2", ":", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "jpeg_range", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "jpeg_range", "[", "0", "]", ")", "/", "(", "jpeg_range", "[", "1", "]", "-", "jpeg_range", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", ":", "road_map", "[", "3", "]", "+", "1", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# resize back", "\n", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "            ", "if", "mode_current", "==", "mode", ":", "\n", "                ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "scale_overall", ",", "ori_w", "//", "scale_overall", ")", ",", "mode", "=", "mode", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "\n", "print", "(", "degradation_params", ")", "\n", "\n", "# clamp and round", "\n", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "print", "(", "out", ".", "shape", ")", "\n", "out", "=", "tensor2img", "(", "out", ")", "\n", "target_name", "=", "img_name", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'__'", "\n", "for", "value", "in", "degradation_params", ":", "\n", "            ", "target_name", "+=", "str", "(", "value", ".", "numpy", "(", ")", ")", "+", "'_'", "\n", "", "target_name", "+=", "'_.png'", "\n", "print", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "target_name", ")", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", "+", "'_withparams'", ",", "target_name", ")", ",", "out", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "img_name", ")", ",", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.generate_meta_info_RealESRGAN.generate_meta_info_div2k": [[7, 22], ["sorted", "list", "open", "enumerate", "basicsr.utils.scandir", "print", "f.write"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["def", "generate_meta_info_div2k", "(", ")", ":", "\n", "    ", "\"\"\"Generate meta info for DIV2K dataset.\n    \"\"\"", "\n", "\n", "gt_folder", "=", "'datasets/DF2K/DF2K_multiscaleHR_sub'", "\n", "meta_info_txt", "=", "'datasets/DF2K/DF2K_multiscaleHR_OST_sub.txt'", "\n", "\n", "img_list", "=", "sorted", "(", "list", "(", "scandir", "(", "gt_folder", ")", ")", ")", "\n", "\n", "with", "open", "(", "meta_info_txt", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "idx", ",", "img_path", "in", "enumerate", "(", "img_list", ")", ":", "\n", "\n", "            ", "info", "=", "f'{img_path}'", "\n", "print", "(", "idx", "+", "1", ",", "info", ")", "\n", "f", ".", "write", "(", "f'{info}\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.generate_meta_info.generate_meta_info_div2k": [[7, 31], ["sorted", "list", "open", "enumerate", "basicsr.utils.scandir", "PIL.Image.open", "print", "f.write", "os.path.join", "ValueError"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["def", "generate_meta_info_div2k", "(", ")", ":", "\n", "    ", "\"\"\"Generate meta info for DIV2K dataset.\n    \"\"\"", "\n", "\n", "gt_folder", "=", "'datasets/DIV2K/DIV2K_train_HR_sub/'", "\n", "meta_info_txt", "=", "'basicsr/data/meta_info/meta_info_DIV2K800sub_GT.txt'", "\n", "\n", "img_list", "=", "sorted", "(", "list", "(", "scandir", "(", "gt_folder", ")", ")", ")", "\n", "\n", "with", "open", "(", "meta_info_txt", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "for", "idx", ",", "img_path", "in", "enumerate", "(", "img_list", ")", ":", "\n", "            ", "img", "=", "Image", ".", "open", "(", "osp", ".", "join", "(", "gt_folder", ",", "img_path", ")", ")", "# lazy load", "\n", "width", ",", "height", "=", "img", ".", "size", "\n", "mode", "=", "img", ".", "mode", "\n", "if", "mode", "==", "'RGB'", ":", "\n", "                ", "n_channel", "=", "3", "\n", "", "elif", "mode", "==", "'L'", ":", "\n", "                ", "n_channel", "=", "1", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "f'Unsupported mode {mode}.'", ")", "\n", "\n", "", "info", "=", "f'{img_path} ({height},{width},{n_channel})'", "\n", "print", "(", "idx", "+", "1", ",", "info", ")", "\n", "f", ".", "write", "(", "f'{info}\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.extract_subimages.main": [[12, 45], ["None"], "function", ["None"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\"A multi-thread tool to crop large images to sub-images for faster IO.\n\n    It is used for DIV2K dataset.\n\n    opt (dict): Configuration dict. It contains:\n        n_thread (int): Thread number.\n        compression_level (int):  CV_IMWRITE_PNG_COMPRESSION from 0 to 9.\n            A higher value means a smaller size and longer compression time.\n            Use 0 for faster CPU decompression. Default: 3, same in cv2.\n\n        input_folder (str): Path to the input folder.\n        save_folder (str): Path to save folder.\n        crop_size (int): Crop size.\n        step (int): Step for overlapped sliding window.\n        thresh_size (int): Threshold size. Patches whose size is lower\n            than thresh_size will be dropped.\n\n    Usage:\n        For each folder, run this script.\n        Typically, there are four folders to be processed for DIV2K dataset.\n            DIV2K_train_HR\n            DIV2K_train_LR_bicubic/X2\n            DIV2K_train_LR_bicubic/X3\n            DIV2K_train_LR_bicubic/X4\n        After process, each sub_folder should have the same number of\n        subimages.\n        Remember to modify opt configurations according to your settings.\n    \"\"\"", "\n", "\n", "opt", "=", "{", "}", "\n", "opt", "[", "'n_thread'", "]", "=", "20", "\n", "opt", "[", "'compression_level'", "]", "=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.extract_subimages.extract_subimages": [[63, 91], ["list", "tqdm.tqdm", "multiprocessing.Pool", "multiprocessing.Pool.close", "multiprocessing.Pool.join", "tqdm.tqdm.close", "print", "os.path.exists", "os.makedirs", "print", "print", "sys.exit", "basicsr.utils.scandir", "multiprocessing.Pool.apply_async", "len", "tqdm.tqdm.update"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.LmdbMaker.close", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "extract_subimages", "(", "opt", ")", ":", "\n", "    ", "\"\"\"Crop images to subimages.\n\n    Args:\n        opt (dict): Configuration dict. It contains:\n            input_folder (str): Path to the input folder.\n            save_folder (str): Path to save folder.\n            n_thread (int): Thread number.\n    \"\"\"", "\n", "input_folder", "=", "opt", "[", "'input_folder'", "]", "\n", "save_folder", "=", "opt", "[", "'save_folder'", "]", "\n", "if", "not", "osp", ".", "exists", "(", "save_folder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_folder", ")", "\n", "print", "(", "f'mkdir {save_folder} ...'", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "f'Folder {save_folder} already exists. Exit.'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "", "img_list", "=", "list", "(", "scandir", "(", "input_folder", ",", "full_path", "=", "True", ")", ")", "\n", "\n", "pbar", "=", "tqdm", "(", "total", "=", "len", "(", "img_list", ")", ",", "unit", "=", "'image'", ",", "desc", "=", "'Extract'", ")", "\n", "pool", "=", "Pool", "(", "opt", "[", "'n_thread'", "]", ")", "\n", "for", "path", "in", "img_list", ":", "\n", "        ", "pool", ".", "apply_async", "(", "worker", ",", "args", "=", "(", "path", ",", "opt", ")", ",", "callback", "=", "lambda", "arg", ":", "pbar", ".", "update", "(", "1", ")", ")", "\n", "", "pool", ".", "close", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "pbar", ".", "close", "(", ")", "\n", "print", "(", "'All processes done.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.extract_subimages.worker": [[93, 148], ["os.path.splitext", "cv2.imread", "numpy.arange", "numpy.arange", "os.path.basename", "numpy.append", "numpy.append", "ValueError", "numpy.ascontiguousarray", "cv2.imwrite", "os.path.join"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite"], ["", "def", "worker", "(", "path", ",", "opt", ")", ":", "\n", "    ", "\"\"\"Worker for each process.\n\n    Args:\n        path (str): Image path.\n        opt (dict): Configuration dict. It contains:\n            crop_size (int): Crop size.\n            step (int): Step for overlapped sliding window.\n            thresh_size (int): Threshold size. Patches whose size is lower\n                than thresh_size will be dropped.\n            save_folder (str): Path to save folder.\n            compression_level (int): for cv2.IMWRITE_PNG_COMPRESSION.\n\n    Returns:\n        process_info (str): Process information displayed in progress bar.\n    \"\"\"", "\n", "crop_size", "=", "opt", "[", "'crop_size'", "]", "\n", "step", "=", "opt", "[", "'step'", "]", "\n", "thresh_size", "=", "opt", "[", "'thresh_size'", "]", "\n", "img_name", ",", "extension", "=", "osp", ".", "splitext", "(", "osp", ".", "basename", "(", "path", ")", ")", "\n", "\n", "# remove the x2, x3, x4 and x8 in the filename for DIV2K", "\n", "# img_name = img_name.replace('x2', '').replace('x3', '').replace('x4', '').replace('x8', '')", "\n", "\n", "img", "=", "cv2", ".", "imread", "(", "path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", "\n", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "\n", "", "elif", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "h", ",", "w", ",", "c", "=", "img", ".", "shape", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "f'Image ndim should be 2 or 3, but got {img.ndim}'", ")", "\n", "\n", "# if h < 480 or w < 480:", "\n", "#     crop_size = 300", "\n", "#     step = 150", "\n", "\n", "", "h_space", "=", "np", ".", "arange", "(", "0", ",", "h", "-", "crop_size", "+", "1", ",", "step", ")", "\n", "if", "h", "-", "(", "h_space", "[", "-", "1", "]", "+", "crop_size", ")", ">", "thresh_size", ":", "\n", "        ", "h_space", "=", "np", ".", "append", "(", "h_space", ",", "h", "-", "crop_size", ")", "\n", "", "w_space", "=", "np", ".", "arange", "(", "0", ",", "w", "-", "crop_size", "+", "1", ",", "step", ")", "\n", "if", "w", "-", "(", "w_space", "[", "-", "1", "]", "+", "crop_size", ")", ">", "thresh_size", ":", "\n", "        ", "w_space", "=", "np", ".", "append", "(", "w_space", ",", "w", "-", "crop_size", ")", "\n", "\n", "", "index", "=", "0", "\n", "for", "x", "in", "h_space", ":", "\n", "        ", "for", "y", "in", "w_space", ":", "\n", "            ", "index", "+=", "1", "\n", "cropped_img", "=", "img", "[", "x", ":", "x", "+", "crop_size", ",", "y", ":", "y", "+", "crop_size", ",", "...", "]", "\n", "cropped_img", "=", "np", ".", "ascontiguousarray", "(", "cropped_img", ")", "\n", "cv2", ".", "imwrite", "(", "\n", "osp", ".", "join", "(", "opt", "[", "'save_folder'", "]", ",", "f'{img_name}_s{index:03d}{extension}'", ")", ",", "cropped_img", ",", "\n", "[", "cv2", ".", "IMWRITE_PNG_COMPRESSION", ",", "opt", "[", "'compression_level'", "]", "]", ")", "\n", "", "", "process_info", "=", "f'Processing {img_name} ...'", "\n", "return", "process_info", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_realsr_validation_set_type2.degrade_func": [[38, 194], ["torch.no_grad", "torch.no_grad", "sorted", "glob.glob", "os.path.basename", "os.path.basename", "print", "print", "cv2.imread", "basicsr.utils.img2tensor().unsqueeze().cuda().contiguous", "basicsr.utils.DiffJPEG().cuda", "torch.zeros().float", "torch.zeros().float", "random.choice", "random.choice", "numpy.pad", "torch.FloatTensor().cuda", "torch.FloatTensor().cuda", "torch.zeros", "torch.zeros", "basicsr.utils.img_process_util.filter2D", "random.choice", "random.choice", "torch.nn.functional.interpolate", "torch.zeros", "torch.zeros", "enumerate", "torch.tensor().expand", "torch.tensor().expand", "torch.zeros.expand", "basicsr.utils.tensor2img.new_zeros().uniform_", "torch.clamp", "torch.clamp", "DiffJPEG().cuda.", "normalized_jpeg_p.unsqueeze", "random.choice", "random.choice", "torch.zeros", "torch.zeros", "enumerate", "torch.nn.functional.interpolate", "torch.zeros.expand", "print", "print", "basicsr.utils.tensor2img", "print", "cv2.imwrite", "cv2.imwrite", "os.path.join", "os.path.join", "numpy.random.uniform", "basicsr.data.degradations.circular_lowpass_kernel", "basicsr.data.degradations.random_mixed_kernels_Info", "img2tensor().unsqueeze().cuda().contiguous.size", "random.choices", "random.choices", "numpy.random.uniform", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "numpy.random.uniform", "basicsr.data.degradations.random_add_gaussian_noise_pt", "normalized_sigma.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "basicsr.data.degradations.random_add_poisson_noise_pt", "normalized_scale.unsqueeze", "gray_noise.unsqueeze", "torch.tensor().expand", "torch.tensor().expand", "len", "img2tensor().unsqueeze().cuda().contiguous.size", "len", "torch.clamp", "torch.clamp", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "basicsr.utils.img2tensor().unsqueeze().cuda", "basicsr.utils.DiffJPEG", "range", "torch.zeros", "torch.zeros", "numpy.random.uniform", "numpy.random.uniform", "torch.FloatTensor", "torch.FloatTensor", "numpy.random.uniform", "torch.tensor", "torch.tensor", "img2tensor().unsqueeze().cuda().contiguous.size", "img2tensor().unsqueeze().cuda().contiguous.size", "basicsr.utils.tensor2img.new_zeros", "os.path.basename.split", "str", "math.ceil", "math.ceil", "math.ceil", "math.ceil", "int", "int", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "basicsr.utils.tensor2img.size", "value.numpy", "basicsr.utils.img2tensor().unsqueeze", "basicsr.utils.img2tensor"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.img_process_util.filter2D", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.tensor2img", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.imwrite", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.circular_lowpass_kernel", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_mixed_kernels_Info", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_gaussian_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.data.degradations.random_add_poisson_noise_pt", "home.repos.pwc.inspect_result.csjliang_dasr.utils.img_util.img2tensor"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "degrade_func", "(", "img_dir", ",", "output_dir", ")", ":", "\n", "\n", "    ", "img_list", "=", "sorted", "(", "glob", ".", "glob", "(", "os", ".", "path", ".", "join", "(", "img_dir", ",", "'*'", ")", ")", ")", "\n", "for", "img_path", "in", "img_list", ":", "\n", "        ", "img_name", "=", "os", ".", "path", ".", "basename", "(", "img_path", ")", "\n", "print", "(", "f'Processing {img_name} ...'", ")", "\n", "# img_path = os.path.join(img_path, img_name)", "\n", "print", "(", "img_path", ")", "\n", "input_img", "=", "cv2", ".", "imread", "(", "img_path", ",", "cv2", ".", "IMREAD_COLOR", ")", "\n", "gt", "=", "img2tensor", "(", "input_img", "/", "255.", ",", "bgr2rgb", "=", "True", ",", "float32", "=", "True", ")", ".", "unsqueeze", "(", "0", ")", ".", "cuda", "(", ")", ".", "contiguous", "(", ")", "\n", "\n", "resize_mode_list", "=", "[", "'area'", ",", "'bilinear'", ",", "'bicubic'", "]", "\n", "jpeger", "=", "DiffJPEG", "(", "differentiable", "=", "False", ")", ".", "cuda", "(", ")", "\n", "\n", "scale_overall", "=", "4", "\n", "\n", "# the first degradation process", "\n", "resize_prob", "=", "[", "0.3", ",", "0.4", ",", "0.3", "]", "# up, down, keep", "\n", "resize_range", "=", "[", "0.5", ",", "1.2", "]", "\n", "gaussian_noise_prob", "=", "0.5", "\n", "noise_range", "=", "[", "1", ",", "20", "]", "\n", "poisson_scale_range", "=", "[", "0.05", ",", "1.5", "]", "\n", "gray_noise_prob", "=", "0.4", "\n", "jpeg_range", "=", "[", "50", ",", "95", "]", "\n", "\n", "# blur settings for the first degradation", "\n", "blur_kernel_size_minimum", "=", "7", "\n", "blur_kernel_size", "=", "21", "\n", "kernel_list", "=", "[", "'iso'", ",", "'aniso'", "]", "\n", "kernel_prob", "=", "[", "0.65", ",", "0.35", "]", "\n", "blur_sigma", "=", "[", "0.2", ",", "1.5", "]", "\n", "betag_range", "=", "[", "0.5", ",", "4", "]", "\n", "betap_range", "=", "[", "1", ",", "2", "]", "\n", "sinc_prob", "=", "0", "\n", "\n", "\n", "kernel_range", "=", "[", "2", "*", "v", "+", "1", "for", "v", "in", "range", "(", "math", ".", "ceil", "(", "blur_kernel_size_minimum", "/", "2", ")", ",", "math", ".", "ceil", "(", "blur_kernel_size", "/", "2", ")", ")", "]", "# kernel size ranges from 7 to 21", "\n", "pulse_tensor", "=", "torch", ".", "zeros", "(", "blur_kernel_size", ",", "blur_kernel_size", ")", ".", "float", "(", ")", "# convolving with pulse tensor brings no blurry effect", "\n", "pulse_tensor", "[", "int", "(", "blur_kernel_size", "/", "2", ")", ",", "int", "(", "blur_kernel_size", "/", "2", ")", "]", "=", "1", "\n", "\n", "# ------------------------ Generate kernels (used in the first degradation) ------------------------ #", "\n", "kernel_size", "=", "random", ".", "choice", "(", "kernel_range", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "sinc_prob", ":", "\n", "# this sinc filter setting is for kernels ranging from [7, 21]", "\n", "            ", "if", "kernel_size", "<", "13", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "3", ",", "np", ".", "pi", ")", "\n", "", "else", ":", "\n", "                ", "omega_c", "=", "np", ".", "random", ".", "uniform", "(", "np", ".", "pi", "/", "5", ",", "np", ".", "pi", ")", "\n", "", "kernel", "=", "circular_lowpass_kernel", "(", "omega_c", ",", "kernel_size", ",", "pad_to", "=", "False", ")", "\n", "", "else", ":", "\n", "            ", "kernel_info", "=", "random_mixed_kernels_Info", "(", "\n", "kernel_list", ",", "\n", "kernel_prob", ",", "\n", "kernel_size", ",", "\n", "blur_sigma", ",", "\n", "blur_sigma", ",", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", ",", "\n", "betag_range", ",", "\n", "betap_range", ",", "\n", "noise_range", "=", "None", ")", "\n", "kernel", "=", "kernel_info", "[", "'kernel'", "]", "\n", "\n", "# pad kernel", "\n", "", "pad_size", "=", "(", "21", "-", "kernel_size", ")", "//", "2", "\n", "kernel", "=", "np", ".", "pad", "(", "kernel", ",", "(", "(", "pad_size", ",", "pad_size", ")", ",", "(", "pad_size", ",", "pad_size", ")", ")", ")", "\n", "\n", "# BGR to RGB, HWC to CHW, numpy to tensor", "\n", "# img_gt = img2tensor([img_gt], bgr2rgb=True, float32=True)[0]", "\n", "kernel1", "=", "torch", ".", "FloatTensor", "(", "kernel", ")", ".", "cuda", "(", ")", "\n", "kernel_info", "[", "'kernel'", "]", "=", "kernel1", "\n", "\n", "num_degradation_params", "=", "4", "*", "2", "+", "2", "# kernel", "\n", "num_degradation_params", "+=", "4", "*", "2", "# resize", "\n", "num_degradation_params", "+=", "4", "*", "2", "# noise", "\n", "num_degradation_params", "+=", "3", "+", "2", "+", "2", "# jpeg", "\n", "degradation_params", "=", "torch", ".", "zeros", "(", "num_degradation_params", ")", "\n", "road_map", "=", "[", "0", ",", "10", ",", "10", "+", "8", ",", "10", "+", "8", "+", "8", ",", "10", "+", "8", "+", "8", "+", "7", "]", "\n", "\n", "# {'kernel': kernel, 'kernel_size': kernel_size, 'sigma_x': sigma_x, 'sigma_y': sigma_y, 'rotation': rotation}", "\n", "kernel_size_range1", "=", "[", "blur_kernel_size_minimum", ",", "blur_kernel_size", "]", "\n", "rotation_range", "=", "[", "-", "math", ".", "pi", ",", "math", ".", "pi", "]", "\n", "degradation_params", "[", "road_map", "[", "0", "]", ":", "road_map", "[", "0", "]", "+", "1", "]", "=", "(", "kernel_info", "[", "'kernel_size'", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "/", "(", "kernel_size_range1", "[", "1", "]", "-", "kernel_size_range1", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "1", ":", "road_map", "[", "0", "]", "+", "2", "]", "=", "(", "kernel_info", "[", "'sigma_x'", "]", "-", "blur_sigma", "[", "0", "]", ")", "/", "(", "blur_sigma", "[", "1", "]", "-", "blur_sigma", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "2", ":", "road_map", "[", "0", "]", "+", "3", "]", "=", "(", "kernel_info", "[", "'sigma_y'", "]", "-", "blur_sigma", "[", "0", "]", ")", "/", "(", "blur_sigma", "[", "1", "]", "-", "blur_sigma", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "0", "]", "+", "3", ":", "road_map", "[", "0", "]", "+", "4", "]", "=", "(", "kernel_info", "[", "'rotation'", "]", "-", "rotation_range", "[", "0", "]", ")", "/", "(", "rotation_range", "[", "1", "]", "-", "rotation_range", "[", "0", "]", ")", "\n", "\n", "ori_h", ",", "ori_w", "=", "gt", ".", "size", "(", ")", "[", "2", ":", "4", "]", "\n", "\n", "# ----------------------- The first degradation process ----------------------- #", "\n", "# blur", "\n", "out", "=", "filter2D", "(", "gt", ",", "kernel1", ")", "\n", "# random resize", "\n", "updown_type", "=", "random", ".", "choices", "(", "[", "'up'", ",", "'down'", ",", "'keep'", "]", ",", "resize_prob", ")", "[", "0", "]", "\n", "if", "updown_type", "==", "'up'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "1", ",", "resize_range", "[", "1", "]", ")", "\n", "", "elif", "updown_type", "==", "'down'", ":", "\n", "            ", "scale", "=", "np", ".", "random", ".", "uniform", "(", "resize_range", "[", "0", "]", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "scale", "=", "1", "\n", "", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "out", "=", "F", ".", "interpolate", "(", "out", ",", "scale_factor", "=", "scale", ",", "mode", "=", "mode", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "resize_range", "[", "0", "]", ")", "/", "(", "resize_range", "[", "1", "]", "-", "resize_range", "[", "0", "]", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "            ", "if", "mode_current", "==", "mode", ":", "\n", "                ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "degradation_params", "[", "road_map", "[", "1", "]", ":", "road_map", "[", "1", "]", "+", "1", "]", "=", "torch", ".", "tensor", "(", "normalized_scale", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "1", "]", "+", "1", ":", "road_map", "[", "1", "]", "+", "4", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "if", "np", ".", "random", ".", "uniform", "(", ")", "<", "gaussian_noise_prob", ":", "\n", "            ", "sigma", ",", "gray_noise", ",", "out", ",", "noise_g_first", "=", "random_add_gaussian_noise_pt", "(", "\n", "out", ",", "sigma_range", "=", "noise_range", ",", "clip", "=", "True", ",", "rounds", "=", "False", ",", "gray_prob", "=", "gray_noise_prob", ")", "\n", "\n", "normalized_sigma", "=", "(", "sigma", "-", "noise_range", "[", "0", "]", ")", "/", "(", "noise_range", "[", "1", "]", "-", "noise_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", ":", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_sigma", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "1", ":", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "2", ":", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "1", ",", "0", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "# noise_p_first = only_generate_poisson_noise_pt(out, scale_range=poisson_scale_range, gray_prob=gray_noise_prob)", "\n", "", "else", ":", "\n", "            ", "scale", ",", "gray_noise", ",", "out", ",", "noise_p_first", "=", "random_add_poisson_noise_pt", "(", "\n", "out", ",", "scale_range", "=", "poisson_scale_range", ",", "gray_prob", "=", "gray_noise_prob", ",", "clip", "=", "True", ",", "rounds", "=", "False", ")", "\n", "normalized_scale", "=", "(", "scale", "-", "poisson_scale_range", "[", "0", "]", ")", "/", "(", "poisson_scale_range", "[", "1", "]", "-", "poisson_scale_range", "[", "0", "]", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", ":", "road_map", "[", "2", "]", "+", "1", "]", "=", "normalized_scale", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "1", ":", "road_map", "[", "2", "]", "+", "2", "]", "=", "gray_noise", ".", "unsqueeze", "(", "1", ")", "\n", "degradation_params", "[", "road_map", "[", "2", "]", "+", "2", ":", "road_map", "[", "2", "]", "+", "4", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "1", "]", ")", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "2", ")", "\n", "# noise_g_first = only_generate_gaussian_noise_pt(out, sigma_range=noise_range, gray_prob=gray_noise_prob)", "\n", "\n", "# JPEG compression", "\n", "", "jpeg_p", "=", "out", ".", "new_zeros", "(", "out", ".", "size", "(", "0", ")", ")", ".", "uniform_", "(", "*", "jpeg_range", ")", "\n", "normalized_jpeg_p", "=", "(", "jpeg_p", "-", "jpeg_range", "[", "0", "]", ")", "/", "(", "jpeg_range", "[", "1", "]", "-", "jpeg_range", "[", "0", "]", ")", "\n", "out", "=", "torch", ".", "clamp", "(", "out", ",", "0", ",", "1", ")", "\n", "out", "=", "jpeger", "(", "out", ",", "quality", "=", "jpeg_p", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", ":", "road_map", "[", "3", "]", "+", "1", "]", "=", "normalized_jpeg_p", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# resize back", "\n", "mode", "=", "random", ".", "choice", "(", "resize_mode_list", ")", "\n", "onehot_mode", "=", "torch", ".", "zeros", "(", "len", "(", "resize_mode_list", ")", ")", "\n", "for", "index", ",", "mode_current", "in", "enumerate", "(", "resize_mode_list", ")", ":", "\n", "            ", "if", "mode_current", "==", "mode", ":", "\n", "                ", "onehot_mode", "[", "index", "]", "=", "1", "\n", "", "", "out", "=", "F", ".", "interpolate", "(", "out", ",", "size", "=", "(", "ori_h", "//", "scale_overall", ",", "ori_w", "//", "scale_overall", ")", ",", "mode", "=", "mode", ")", "\n", "degradation_params", "[", "road_map", "[", "3", "]", "+", "4", ":", "]", "=", "onehot_mode", ".", "expand", "(", "gt", ".", "size", "(", "0", ")", ",", "len", "(", "resize_mode_list", ")", ")", "\n", "\n", "print", "(", "degradation_params", ")", "\n", "\n", "# clamp and round", "\n", "out", "=", "torch", ".", "clamp", "(", "(", "out", "*", "255.0", ")", ".", "round", "(", ")", ",", "0", ",", "255", ")", "/", "255.", "\n", "\n", "print", "(", "out", ".", "shape", ")", "\n", "out", "=", "tensor2img", "(", "out", ")", "\n", "target_name", "=", "img_name", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'__'", "\n", "for", "value", "in", "degradation_params", ":", "\n", "            ", "target_name", "+=", "str", "(", "value", ".", "numpy", "(", ")", ")", "+", "'_'", "\n", "", "target_name", "+=", "'_.png'", "\n", "print", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "target_name", ")", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", "+", "'_withparams'", ",", "target_name", ")", ",", "out", ")", "\n", "cv2", ".", "imwrite", "(", "os", ".", "path", ".", "join", "(", "output_dir", ",", "img_name", ")", ",", "out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.create_lmdb_for_div2k": [[8, 42], ["create_lmdb.prepare_keys_div2k", "basicsr.utils.lmdb_util.make_lmdb_from_imgs"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_div2k", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.make_lmdb_from_imgs"], ["def", "create_lmdb_for_div2k", "(", ")", ":", "\n", "    ", "\"\"\"Create lmdb files for DIV2K dataset.\n\n    Usage:\n        Before run this script, please run `extract_subimages.py`.\n        Typically, there are four folders to be processed for DIV2K dataset.\n            DIV2K_train_HR_sub\n            DIV2K_train_LR_bicubic/X2_sub\n            DIV2K_train_LR_bicubic/X3_sub\n            DIV2K_train_LR_bicubic/X4_sub\n        Remember to modify opt configurations according to your settings.\n    \"\"\"", "\n", "# # FiveK images", "\n", "# folder_path = 'datasets/FiveK/FiveK_480p/train_4500/B'", "\n", "# lmdb_path = 'datasets/FiveK/FiveK_train_4500_target.lmdb'", "\n", "# img_path_list, keys = prepare_keys_fivek(folder_path)", "\n", "# make_lmdb_from_imgs(folder_path, lmdb_path, img_path_list, keys)", "\n", "#", "\n", "# folder_path = 'datasets/FiveK/FiveK_480p/train_4500/A'", "\n", "# lmdb_path = 'datasets/FiveK/FiveK_train_4500_source.lmdb'", "\n", "# img_path_list, keys = prepare_keys_fivek(folder_path)", "\n", "# make_lmdb_from_imgs(folder_path, lmdb_path, img_path_list, keys)", "\n", "\n", "# # HR images", "\n", "# folder_path = 'datasets/DIV2K/DIV2K_train_HR_sub'", "\n", "# lmdb_path = 'datasets/DIV2K/DIV2K_train_HR_sub.lmdb'", "\n", "# img_path_list, keys = prepare_keys_div2k(folder_path)", "\n", "# make_lmdb_from_imgs(folder_path, lmdb_path, img_path_list, keys)", "\n", "#", "\n", "# # LRx2 images", "\n", "folder_path", "=", "'datasets/DF2K/LRbicx2_sub'", "\n", "lmdb_path", "=", "'datasets/DF2K/LRbicx2_sub.lmdb'", "\n", "img_path_list", ",", "keys", "=", "prepare_keys_div2k", "(", "folder_path", ")", "\n", "make_lmdb_from_imgs", "(", "folder_path", ",", "lmdb_path", ",", "img_path_list", ",", "keys", ")", "\n", "#", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_fivek": [[55, 70], ["print", "sorted", "list", "basicsr.utils.scandir", "img_path.split", "sorted"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "prepare_keys_fivek", "(", "folder_path", ")", ":", "\n", "    ", "\"\"\"Prepare image path list and keys for DIV2K dataset.\n\n    Args:\n        folder_path (str): Folder path.\n\n    Returns:\n        list[str]: Image path list.\n        list[str]: Key list.\n    \"\"\"", "\n", "print", "(", "'Reading image path list ...'", ")", "\n", "img_path_list", "=", "sorted", "(", "list", "(", "scandir", "(", "folder_path", ",", "suffix", "=", "'jpg'", ",", "recursive", "=", "False", ")", ")", ")", "\n", "keys", "=", "[", "img_path", ".", "split", "(", "'.jpg'", ")", "[", "0", "]", "for", "img_path", "in", "sorted", "(", "img_path_list", ")", "]", "\n", "\n", "return", "img_path_list", ",", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_div2k": [[71, 86], ["print", "sorted", "list", "basicsr.utils.scandir", "img_path.split", "sorted"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "prepare_keys_div2k", "(", "folder_path", ")", ":", "\n", "    ", "\"\"\"Prepare image path list and keys for DIV2K dataset.\n\n    Args:\n        folder_path (str): Folder path.\n\n    Returns:\n        list[str]: Image path list.\n        list[str]: Key list.\n    \"\"\"", "\n", "print", "(", "'Reading image path list ...'", ")", "\n", "img_path_list", "=", "sorted", "(", "list", "(", "scandir", "(", "folder_path", ",", "suffix", "=", "'png'", ",", "recursive", "=", "False", ")", ")", ")", "\n", "keys", "=", "[", "img_path", ".", "split", "(", "'.png'", ")", "[", "0", "]", "for", "img_path", "in", "sorted", "(", "img_path_list", ")", "]", "\n", "\n", "return", "img_path_list", ",", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.create_lmdb_for_reds": [[88, 109], ["create_lmdb.prepare_keys_reds", "basicsr.utils.lmdb_util.make_lmdb_from_imgs", "create_lmdb.prepare_keys_reds", "basicsr.utils.lmdb_util.make_lmdb_from_imgs"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_reds", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.make_lmdb_from_imgs", "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_reds", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.make_lmdb_from_imgs"], ["", "def", "create_lmdb_for_reds", "(", ")", ":", "\n", "    ", "\"\"\"Create lmdb files for REDS dataset.\n\n    Usage:\n        Before run this script, please run `merge_reds_train_val.py`.\n        We take two folders for example:\n            train_sharp\n            train_sharp_bicubic\n        Remember to modify opt configurations according to your settings.\n    \"\"\"", "\n", "# train_sharp", "\n", "folder_path", "=", "'datasets/REDS/train_sharp'", "\n", "lmdb_path", "=", "'datasets/REDS/train_sharp_with_val.lmdb'", "\n", "img_path_list", ",", "keys", "=", "prepare_keys_reds", "(", "folder_path", ")", "\n", "make_lmdb_from_imgs", "(", "folder_path", ",", "lmdb_path", ",", "img_path_list", ",", "keys", ",", "multiprocessing_read", "=", "True", ")", "\n", "\n", "# train_sharp_bicubic", "\n", "folder_path", "=", "'datasets/REDS/train_sharp_bicubic'", "\n", "lmdb_path", "=", "'datasets/REDS/train_sharp_bicubic_with_val.lmdb'", "\n", "img_path_list", ",", "keys", "=", "prepare_keys_reds", "(", "folder_path", ")", "\n", "make_lmdb_from_imgs", "(", "folder_path", ",", "lmdb_path", ",", "img_path_list", ",", "keys", ",", "multiprocessing_read", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_reds": [[111, 126], ["print", "sorted", "list", "basicsr.utils.scandir", "v.split"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.scandir"], ["", "def", "prepare_keys_reds", "(", "folder_path", ")", ":", "\n", "    ", "\"\"\"Prepare image path list and keys for REDS dataset.\n\n    Args:\n        folder_path (str): Folder path.\n\n    Returns:\n        list[str]: Image path list.\n        list[str]: Key list.\n    \"\"\"", "\n", "print", "(", "'Reading image path list ...'", ")", "\n", "img_path_list", "=", "sorted", "(", "list", "(", "scandir", "(", "folder_path", ",", "suffix", "=", "'png'", ",", "recursive", "=", "True", ")", ")", ")", "\n", "keys", "=", "[", "v", ".", "split", "(", "'.png'", ")", "[", "0", "]", "for", "v", "in", "img_path_list", "]", "# example: 000/00000000", "\n", "\n", "return", "img_path_list", ",", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.create_lmdb_for_vimeo90k": [[128, 147], ["create_lmdb.prepare_keys_vimeo90k", "basicsr.utils.lmdb_util.make_lmdb_from_imgs", "create_lmdb.prepare_keys_vimeo90k", "basicsr.utils.lmdb_util.make_lmdb_from_imgs"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_vimeo90k", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.make_lmdb_from_imgs", "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_vimeo90k", "home.repos.pwc.inspect_result.csjliang_dasr.utils.lmdb_util.make_lmdb_from_imgs"], ["", "def", "create_lmdb_for_vimeo90k", "(", ")", ":", "\n", "    ", "\"\"\"Create lmdb files for Vimeo90K dataset.\n\n    Usage:\n        Remember to modify opt configurations according to your settings.\n    \"\"\"", "\n", "# GT", "\n", "folder_path", "=", "'datasets/vimeo90k/vimeo_septuplet/sequences'", "\n", "lmdb_path", "=", "'datasets/vimeo90k/vimeo90k_train_GT_only4th.lmdb'", "\n", "train_list_path", "=", "'datasets/vimeo90k/vimeo_septuplet/sep_trainlist.txt'", "\n", "img_path_list", ",", "keys", "=", "prepare_keys_vimeo90k", "(", "folder_path", ",", "train_list_path", ",", "'gt'", ")", "\n", "make_lmdb_from_imgs", "(", "folder_path", ",", "lmdb_path", ",", "img_path_list", ",", "keys", ",", "multiprocessing_read", "=", "True", ")", "\n", "\n", "# LQ", "\n", "folder_path", "=", "'datasets/vimeo90k/vimeo_septuplet_matlabLRx4/sequences'", "\n", "lmdb_path", "=", "'datasets/vimeo90k/vimeo90k_train_LR7frames.lmdb'", "\n", "train_list_path", "=", "'datasets/vimeo90k/vimeo_septuplet/sep_trainlist.txt'", "\n", "img_path_list", ",", "keys", "=", "prepare_keys_vimeo90k", "(", "folder_path", ",", "train_list_path", ",", "'lq'", ")", "\n", "make_lmdb_from_imgs", "(", "folder_path", ",", "lmdb_path", ",", "img_path_list", ",", "keys", ",", "multiprocessing_read", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.data_preparation.create_lmdb.prepare_keys_vimeo90k": [[149, 178], ["print", "open", "line.split", "img_path_list.extend", "keys.extend", "print", "line.strip", "os.path.join", "v.endswith", "v.endswith", "range", "range"], "function", ["None"], ["", "def", "prepare_keys_vimeo90k", "(", "folder_path", ",", "train_list_path", ",", "mode", ")", ":", "\n", "    ", "\"\"\"Prepare image path list and keys for Vimeo90K dataset.\n\n    Args:\n        folder_path (str): Folder path.\n        train_list_path (str): Path to the official train list.\n        mode (str): One of 'gt' or 'lq'.\n\n    Returns:\n        list[str]: Image path list.\n        list[str]: Key list.\n    \"\"\"", "\n", "print", "(", "'Reading image path list ...'", ")", "\n", "with", "open", "(", "train_list_path", ",", "'r'", ")", "as", "fin", ":", "\n", "        ", "train_list", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "fin", "]", "\n", "\n", "", "img_path_list", "=", "[", "]", "\n", "keys", "=", "[", "]", "\n", "for", "line", "in", "train_list", ":", "\n", "        ", "folder", ",", "sub_folder", "=", "line", ".", "split", "(", "'/'", ")", "\n", "img_path_list", ".", "extend", "(", "[", "osp", ".", "join", "(", "folder", ",", "sub_folder", ",", "f'im{j + 1}.png'", ")", "for", "j", "in", "range", "(", "7", ")", "]", ")", "\n", "keys", ".", "extend", "(", "[", "f'{folder}/{sub_folder}/im{j + 1}'", "for", "j", "in", "range", "(", "7", ")", "]", ")", "\n", "\n", "", "if", "mode", "==", "'gt'", ":", "\n", "        ", "print", "(", "'Only keep the 4th frame for the gt mode.'", ")", "\n", "img_path_list", "=", "[", "v", "for", "v", "in", "img_path_list", "if", "v", ".", "endswith", "(", "'im4.png'", ")", "]", "\n", "keys", "=", "[", "v", "for", "v", "in", "keys", "if", "v", ".", "endswith", "(", "'/im4'", ")", "]", "\n", "\n", "", "return", "img_path_list", ",", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.test.test_pipeline": [[11, 41], ["basicsr.utils.options.parse_options", "basicsr.utils.make_exp_dirs", "os.path.join", "basicsr.utils.get_root_logger", "basicsr.utils.get_root_logger.info", "basicsr.utils.get_root_logger.info", "sorted", "basicsr.models.build_model", "basicsr.utils.get_env_info", "basicsr.utils.options.dict2str", "opt[].items", "basicsr.data.build_dataset", "basicsr.data.build_dataloader", "basicsr.utils.get_root_logger.info", "test_loaders.append", "basicsr.utils.get_root_logger.info", "basicsr.models.build_model.validation", "basicsr.utils.get_time_str", "len"], "function", ["home.repos.pwc.inspect_result.csjliang_dasr.utils.options.parse_options", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.make_exp_dirs", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_root_logger", "home.repos.pwc.inspect_result.csjliang_dasr.models.__init__.build_model", "home.repos.pwc.inspect_result.csjliang_dasr.utils.logger.get_env_info", "home.repos.pwc.inspect_result.csjliang_dasr.utils.options.dict2str", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataset", "home.repos.pwc.inspect_result.csjliang_dasr.data.__init__.build_dataloader", "home.repos.pwc.inspect_result.csjliang_dasr.models.base_model.BaseModel.validation", "home.repos.pwc.inspect_result.csjliang_dasr.utils.misc.get_time_str"], ["def", "test_pipeline", "(", "root_path", ")", ":", "\n", "# parse options, set distributed setting, set ramdom seed", "\n", "    ", "opt", "=", "parse_options", "(", "root_path", ",", "is_train", "=", "False", ")", "\n", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "True", "\n", "# torch.backends.cudnn.deterministic = True", "\n", "\n", "# mkdir and initialize loggers", "\n", "make_exp_dirs", "(", "opt", ")", "\n", "log_file", "=", "osp", ".", "join", "(", "opt", "[", "'path'", "]", "[", "'log'", "]", ",", "f\"test_{opt['name']}_{get_time_str()}.log\"", ")", "\n", "logger", "=", "get_root_logger", "(", "logger_name", "=", "'basicsr'", ",", "log_level", "=", "logging", ".", "INFO", ",", "log_file", "=", "log_file", ")", "\n", "logger", ".", "info", "(", "get_env_info", "(", ")", ")", "\n", "logger", ".", "info", "(", "dict2str", "(", "opt", ")", ")", "\n", "\n", "# create test dataset and dataloader", "\n", "test_loaders", "=", "[", "]", "\n", "for", "phase", ",", "dataset_opt", "in", "sorted", "(", "opt", "[", "'datasets'", "]", ".", "items", "(", ")", ")", ":", "\n", "        ", "test_set", "=", "build_dataset", "(", "dataset_opt", ")", "\n", "test_loader", "=", "build_dataloader", "(", "\n", "test_set", ",", "dataset_opt", ",", "num_gpu", "=", "opt", "[", "'num_gpu'", "]", ",", "dist", "=", "opt", "[", "'dist'", "]", ",", "sampler", "=", "None", ",", "seed", "=", "opt", "[", "'manual_seed'", "]", ")", "\n", "logger", ".", "info", "(", "f\"Number of test images in {dataset_opt['name']}: {len(test_set)}\"", ")", "\n", "test_loaders", ".", "append", "(", "test_loader", ")", "\n", "\n", "# create model", "\n", "", "model", "=", "build_model", "(", "opt", ")", "\n", "\n", "for", "test_loader", "in", "test_loaders", ":", "\n", "        ", "test_set_name", "=", "test_loader", ".", "dataset", ".", "opt", "[", "'name'", "]", "\n", "logger", ".", "info", "(", "f'Testing {test_set_name}...'", ")", "\n", "model", ".", "validation", "(", "test_loader", ",", "current_iter", "=", "opt", "[", "'name'", "]", ",", "tb_logger", "=", "None", ",", "save_img", "=", "opt", "[", "'val'", "]", "[", "'save_img'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.__init__": [[16, 41], ["torch.device", "basicsr.archs.rrdbnet_arch.RRDBNet", "load_file_from_url.startswith", "torch.load", "basicsr.archs.rrdbnet_arch.RRDBNet.load_state_dict", "basicsr.archs.rrdbnet_arch.RRDBNet.eval", "basicsr.archs.rrdbnet_arch.RRDBNet.to", "utils.load_file_from_url", "utils.RealESRGANer.model.half", "torch.cuda.is_available"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.load_file_from_url"], ["    ", "def", "__init__", "(", "self", ",", "scale", ",", "model_path", ",", "tile", "=", "0", ",", "tile_pad", "=", "10", ",", "pre_pad", "=", "10", ",", "half", "=", "False", ")", ":", "\n", "        ", "self", ".", "scale", "=", "scale", "\n", "self", ".", "tile_size", "=", "tile", "\n", "self", ".", "tile_pad", "=", "tile_pad", "\n", "self", ".", "pre_pad", "=", "pre_pad", "\n", "self", ".", "mod_scale", "=", "None", "\n", "self", ".", "half", "=", "half", "\n", "\n", "# initialize model", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "model", "=", "RRDBNet", "(", "num_in_ch", "=", "3", ",", "num_out_ch", "=", "3", ",", "num_feat", "=", "64", ",", "num_block", "=", "23", ",", "num_grow_ch", "=", "32", ",", "scale", "=", "scale", ")", "\n", "\n", "if", "model_path", ".", "startswith", "(", "'https://'", ")", ":", "\n", "            ", "model_path", "=", "load_file_from_url", "(", "\n", "url", "=", "model_path", ",", "model_dir", "=", "'realesrgan/weights'", ",", "progress", "=", "True", ",", "file_name", "=", "None", ")", "\n", "", "loadnet", "=", "torch", ".", "load", "(", "model_path", ")", "\n", "if", "'params_ema'", "in", "loadnet", ":", "\n", "            ", "keyname", "=", "'params_ema'", "\n", "", "else", ":", "\n", "            ", "keyname", "=", "'params'", "\n", "", "model", ".", "load_state_dict", "(", "loadnet", "[", "keyname", "]", ",", "strict", "=", "True", ")", "\n", "model", ".", "eval", "(", ")", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "self", ".", "half", ":", "\n", "            ", "self", ".", "model", "=", "self", ".", "model", ".", "half", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.pre_process": [[42, 64], ["torch.from_numpy().float", "torch.from_numpy().float.unsqueeze().to", "utils.RealESRGANer.img.half", "torch.nn.functional.pad", "utils.RealESRGANer.img.size", "torch.nn.functional.pad", "torch.from_numpy", "torch.from_numpy().float.unsqueeze", "numpy.transpose"], "methods", ["None"], ["", "", "def", "pre_process", "(", "self", ",", "img", ")", ":", "\n", "        ", "img", "=", "torch", ".", "from_numpy", "(", "np", ".", "transpose", "(", "img", ",", "(", "2", ",", "0", ",", "1", ")", ")", ")", ".", "float", "(", ")", "\n", "self", ".", "img", "=", "img", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "self", ".", "half", ":", "\n", "            ", "self", ".", "img", "=", "self", ".", "img", ".", "half", "(", ")", "\n", "\n", "# pre_pad", "\n", "", "if", "self", ".", "pre_pad", "!=", "0", ":", "\n", "            ", "self", ".", "img", "=", "F", ".", "pad", "(", "self", ".", "img", ",", "(", "0", ",", "self", ".", "pre_pad", ",", "0", ",", "self", ".", "pre_pad", ")", ",", "'reflect'", ")", "\n", "# mod pad", "\n", "", "if", "self", ".", "scale", "==", "2", ":", "\n", "            ", "self", ".", "mod_scale", "=", "2", "\n", "", "elif", "self", ".", "scale", "==", "1", ":", "\n", "            ", "self", ".", "mod_scale", "=", "4", "\n", "", "if", "self", ".", "mod_scale", "is", "not", "None", ":", "\n", "            ", "self", ".", "mod_pad_h", ",", "self", ".", "mod_pad_w", "=", "0", ",", "0", "\n", "_", ",", "_", ",", "h", ",", "w", "=", "self", ".", "img", ".", "size", "(", ")", "\n", "if", "(", "h", "%", "self", ".", "mod_scale", "!=", "0", ")", ":", "\n", "                ", "self", ".", "mod_pad_h", "=", "(", "self", ".", "mod_scale", "-", "h", "%", "self", ".", "mod_scale", ")", "\n", "", "if", "(", "w", "%", "self", ".", "mod_scale", "!=", "0", ")", ":", "\n", "                ", "self", ".", "mod_pad_w", "=", "(", "self", ".", "mod_scale", "-", "w", "%", "self", ".", "mod_scale", ")", "\n", "", "self", ".", "img", "=", "F", ".", "pad", "(", "self", ".", "img", ",", "(", "0", ",", "self", ".", "mod_pad_w", ",", "0", ",", "self", ".", "mod_pad_h", ")", ",", "'reflect'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.process": [[65, 67], ["utils.RealESRGANer.model"], "methods", ["None"], ["", "", "def", "process", "(", "self", ")", ":", "\n", "        ", "self", ".", "output", "=", "self", ".", "model", "(", "self", ".", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.tile_process": [[68, 129], ["utils.RealESRGANer.img.new_zeros", "math.ceil", "math.ceil", "range", "range", "min", "min", "max", "min", "max", "min", "print", "torch.no_grad", "utils.RealESRGANer.model", "print"], "methods", ["None"], ["", "def", "tile_process", "(", "self", ")", ":", "\n", "        ", "\"\"\"Modified from: https://github.com/ata4/esrgan-launcher\n        \"\"\"", "\n", "batch", ",", "channel", ",", "height", ",", "width", "=", "self", ".", "img", ".", "shape", "\n", "output_height", "=", "height", "*", "self", ".", "scale", "\n", "output_width", "=", "width", "*", "self", ".", "scale", "\n", "output_shape", "=", "(", "batch", ",", "channel", ",", "output_height", ",", "output_width", ")", "\n", "\n", "# start with black image", "\n", "self", ".", "output", "=", "self", ".", "img", ".", "new_zeros", "(", "output_shape", ")", "\n", "tiles_x", "=", "math", ".", "ceil", "(", "width", "/", "self", ".", "tile_size", ")", "\n", "tiles_y", "=", "math", ".", "ceil", "(", "height", "/", "self", ".", "tile_size", ")", "\n", "\n", "# loop over all tiles", "\n", "for", "y", "in", "range", "(", "tiles_y", ")", ":", "\n", "            ", "for", "x", "in", "range", "(", "tiles_x", ")", ":", "\n", "# extract tile from input image", "\n", "                ", "ofs_x", "=", "x", "*", "self", ".", "tile_size", "\n", "ofs_y", "=", "y", "*", "self", ".", "tile_size", "\n", "# input tile area on total image", "\n", "input_start_x", "=", "ofs_x", "\n", "input_end_x", "=", "min", "(", "ofs_x", "+", "self", ".", "tile_size", ",", "width", ")", "\n", "input_start_y", "=", "ofs_y", "\n", "input_end_y", "=", "min", "(", "ofs_y", "+", "self", ".", "tile_size", ",", "height", ")", "\n", "\n", "# input tile area on total image with padding", "\n", "input_start_x_pad", "=", "max", "(", "input_start_x", "-", "self", ".", "tile_pad", ",", "0", ")", "\n", "input_end_x_pad", "=", "min", "(", "input_end_x", "+", "self", ".", "tile_pad", ",", "width", ")", "\n", "input_start_y_pad", "=", "max", "(", "input_start_y", "-", "self", ".", "tile_pad", ",", "0", ")", "\n", "input_end_y_pad", "=", "min", "(", "input_end_y", "+", "self", ".", "tile_pad", ",", "height", ")", "\n", "\n", "# input tile dimensions", "\n", "input_tile_width", "=", "input_end_x", "-", "input_start_x", "\n", "input_tile_height", "=", "input_end_y", "-", "input_start_y", "\n", "tile_idx", "=", "y", "*", "tiles_x", "+", "x", "+", "1", "\n", "input_tile", "=", "self", ".", "img", "[", ":", ",", ":", ",", "input_start_y_pad", ":", "input_end_y_pad", ",", "input_start_x_pad", ":", "input_end_x_pad", "]", "\n", "\n", "# upscale tile", "\n", "try", ":", "\n", "                    ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                        ", "output_tile", "=", "self", ".", "model", "(", "input_tile", ")", "\n", "", "", "except", "Exception", "as", "error", ":", "\n", "                    ", "print", "(", "'Error'", ",", "error", ")", "\n", "", "print", "(", "f'\\tTile {tile_idx}/{tiles_x * tiles_y}'", ")", "\n", "\n", "# output tile area on total image", "\n", "output_start_x", "=", "input_start_x", "*", "self", ".", "scale", "\n", "output_end_x", "=", "input_end_x", "*", "self", ".", "scale", "\n", "output_start_y", "=", "input_start_y", "*", "self", ".", "scale", "\n", "output_end_y", "=", "input_end_y", "*", "self", ".", "scale", "\n", "\n", "# output tile area without padding", "\n", "output_start_x_tile", "=", "(", "input_start_x", "-", "input_start_x_pad", ")", "*", "self", ".", "scale", "\n", "output_end_x_tile", "=", "output_start_x_tile", "+", "input_tile_width", "*", "self", ".", "scale", "\n", "output_start_y_tile", "=", "(", "input_start_y", "-", "input_start_y_pad", ")", "*", "self", ".", "scale", "\n", "output_end_y_tile", "=", "output_start_y_tile", "+", "input_tile_height", "*", "self", ".", "scale", "\n", "\n", "# put tile into output image", "\n", "self", ".", "output", "[", ":", ",", ":", ",", "output_start_y", ":", "output_end_y", ",", "\n", "output_start_x", ":", "output_end_x", "]", "=", "output_tile", "[", ":", ",", ":", ",", "output_start_y_tile", ":", "output_end_y_tile", ",", "\n", "output_start_x_tile", ":", "output_end_x_tile", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.post_process": [[130, 140], ["utils.RealESRGANer.output.size", "utils.RealESRGANer.output.size"], "methods", ["None"], ["", "", "", "def", "post_process", "(", "self", ")", ":", "\n", "# remove extra pad", "\n", "        ", "if", "self", ".", "mod_scale", "is", "not", "None", ":", "\n", "            ", "_", ",", "_", ",", "h", ",", "w", "=", "self", ".", "output", ".", "size", "(", ")", "\n", "self", ".", "output", "=", "self", ".", "output", "[", ":", ",", ":", ",", "0", ":", "h", "-", "self", ".", "mod_pad_h", "*", "self", ".", "scale", ",", "0", ":", "w", "-", "self", ".", "mod_pad_w", "*", "self", ".", "scale", "]", "\n", "# remove prepad", "\n", "", "if", "self", ".", "pre_pad", "!=", "0", ":", "\n", "            ", "_", ",", "_", ",", "h", ",", "w", "=", "self", ".", "output", ".", "size", "(", ")", "\n", "self", ".", "output", "=", "self", ".", "output", "[", ":", ",", ":", ",", "0", ":", "h", "-", "self", ".", "pre_pad", "*", "self", ".", "scale", ",", "0", ":", "w", "-", "self", ".", "pre_pad", "*", "self", ".", "scale", "]", "\n", "", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.enhance": [[141, 212], ["torch.no_grad", "cv2.cvtColor.astype", "utils.RealESRGANer.pre_process", "utils.RealESRGANer.post_process", "cv2.cvtColor.data.squeeze().float().cpu().clamp_().numpy", "numpy.transpose", "numpy.max", "print", "len", "cv2.cvtColor", "utils.RealESRGANer.tile_process", "utils.RealESRGANer.process", "cv2.cvtColor", "cv2.cvtColor", "cv2.resize", "cv2.cvtColor", "cv2.cvtColor", "cv2.cvtColor.data.squeeze().float().cpu().clamp_", "utils.RealESRGANer.pre_process", "utils.RealESRGANer.post_process", "cv2.resize.data.squeeze().float().cpu().clamp_().numpy", "numpy.transpose", "cv2.cvtColor", "cv2.resize", "float", "cv2.cvtColor", "utils.RealESRGANer.tile_process", "utils.RealESRGANer.process", "int", "int", "cv2.cvtColor.data.squeeze().float().cpu", "cv2.resize.data.squeeze().float().cpu().clamp_", "cv2.cvtColor.data.squeeze().float", "cv2.resize.data.squeeze().float().cpu", "cv2.cvtColor.data.squeeze", "cv2.resize.data.squeeze().float", "cv2.resize.data.squeeze"], "methods", ["home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.pre_process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.post_process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.tile_process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.pre_process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.post_process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.tile_process", "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.RealESRGANer.process"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "enhance", "(", "self", ",", "img", ",", "outscale", "=", "None", ",", "alpha_upsampler", "=", "'realesrgan'", ")", ":", "\n", "        ", "h_input", ",", "w_input", "=", "img", ".", "shape", "[", "0", ":", "2", "]", "\n", "# img: numpy", "\n", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "np", ".", "max", "(", "img", ")", ">", "255", ":", "# 16-bit image", "\n", "            ", "max_range", "=", "65535", "\n", "print", "(", "'\\tInput is a 16-bit image'", ")", "\n", "", "else", ":", "\n", "            ", "max_range", "=", "255", "\n", "", "img", "=", "img", "/", "max_range", "\n", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "# gray image", "\n", "            ", "img_mode", "=", "'L'", "\n", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "\n", "", "elif", "img", ".", "shape", "[", "2", "]", "==", "4", ":", "# RGBA image with alpha channel", "\n", "            ", "img_mode", "=", "'RGBA'", "\n", "alpha", "=", "img", "[", ":", ",", ":", ",", "3", "]", "\n", "img", "=", "img", "[", ":", ",", ":", ",", "0", ":", "3", "]", "\n", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2RGB", ")", "\n", "if", "alpha_upsampler", "==", "'realesrgan'", ":", "\n", "                ", "alpha", "=", "cv2", ".", "cvtColor", "(", "alpha", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "\n", "", "", "else", ":", "\n", "            ", "img_mode", "=", "'RGB'", "\n", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2RGB", ")", "\n", "\n", "# ------------------- process image (without the alpha channel) ------------------- #", "\n", "", "self", ".", "pre_process", "(", "img", ")", "\n", "if", "self", ".", "tile_size", ">", "0", ":", "\n", "            ", "self", ".", "tile_process", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "process", "(", ")", "\n", "", "output_img", "=", "self", ".", "post_process", "(", ")", "\n", "output_img", "=", "output_img", ".", "data", ".", "squeeze", "(", ")", ".", "float", "(", ")", ".", "cpu", "(", ")", ".", "clamp_", "(", "0", ",", "1", ")", ".", "numpy", "(", ")", "\n", "output_img", "=", "np", ".", "transpose", "(", "output_img", "[", "[", "2", ",", "1", ",", "0", "]", ",", ":", ",", ":", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "if", "img_mode", "==", "'L'", ":", "\n", "            ", "output_img", "=", "cv2", ".", "cvtColor", "(", "output_img", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "\n", "# ------------------- process the alpha channel if necessary ------------------- #", "\n", "", "if", "img_mode", "==", "'RGBA'", ":", "\n", "            ", "if", "alpha_upsampler", "==", "'realesrgan'", ":", "\n", "                ", "self", ".", "pre_process", "(", "alpha", ")", "\n", "if", "self", ".", "tile_size", ">", "0", ":", "\n", "                    ", "self", ".", "tile_process", "(", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "process", "(", ")", "\n", "", "output_alpha", "=", "self", ".", "post_process", "(", ")", "\n", "output_alpha", "=", "output_alpha", ".", "data", ".", "squeeze", "(", ")", ".", "float", "(", ")", ".", "cpu", "(", ")", ".", "clamp_", "(", "0", ",", "1", ")", ".", "numpy", "(", ")", "\n", "output_alpha", "=", "np", ".", "transpose", "(", "output_alpha", "[", "[", "2", ",", "1", ",", "0", "]", ",", ":", ",", ":", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "output_alpha", "=", "cv2", ".", "cvtColor", "(", "output_alpha", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "\n", "", "else", ":", "\n", "                ", "h", ",", "w", "=", "alpha", ".", "shape", "[", "0", ":", "2", "]", "\n", "output_alpha", "=", "cv2", ".", "resize", "(", "alpha", ",", "(", "w", "*", "self", ".", "scale", ",", "h", "*", "self", ".", "scale", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "\n", "# merge the alpha channel", "\n", "", "output_img", "=", "cv2", ".", "cvtColor", "(", "output_img", ",", "cv2", ".", "COLOR_BGR2BGRA", ")", "\n", "output_img", "[", ":", ",", ":", ",", "3", "]", "=", "output_alpha", "\n", "\n", "# ------------------------------ return ------------------------------ #", "\n", "", "if", "max_range", "==", "65535", ":", "# 16-bit image", "\n", "            ", "output", "=", "(", "output_img", "*", "65535.0", ")", ".", "round", "(", ")", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "(", "output_img", "*", "255.0", ")", ".", "round", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "", "if", "outscale", "is", "not", "None", "and", "outscale", "!=", "float", "(", "self", ".", "scale", ")", ":", "\n", "            ", "output", "=", "cv2", ".", "resize", "(", "\n", "output", ",", "(", "\n", "int", "(", "w_input", "*", "outscale", ")", ",", "\n", "int", "(", "h_input", "*", "outscale", ")", ",", "\n", ")", ",", "interpolation", "=", "cv2", ".", "INTER_LANCZOS4", ")", "\n", "\n", "", "return", "output", ",", "img_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.csjliang_dasr.dasr.utils.load_file_from_url": [[214, 232], ["os.makedirs", "urllib.parse.urlparse", "os.path.basename", "os.path.abspath", "torch.hub.get_dir", "os.path.join", "os.path.join", "os.path.join", "os.path.exists", "print", "torch.hub.download_url_to_file"], "function", ["None"], ["", "", "def", "load_file_from_url", "(", "url", ",", "model_dir", "=", "None", ",", "progress", "=", "True", ",", "file_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"Ref:https://github.com/1adrianb/face-alignment/blob/master/face_alignment/utils.py\n    \"\"\"", "\n", "if", "model_dir", "is", "None", ":", "\n", "        ", "hub_dir", "=", "get_dir", "(", ")", "\n", "model_dir", "=", "os", ".", "path", ".", "join", "(", "hub_dir", ",", "'checkpoints'", ")", "\n", "\n", "", "os", ".", "makedirs", "(", "os", ".", "path", ".", "join", "(", "ROOT_DIR", ",", "model_dir", ")", ",", "exist_ok", "=", "True", ")", "\n", "\n", "parts", "=", "urlparse", "(", "url", ")", "\n", "filename", "=", "os", ".", "path", ".", "basename", "(", "parts", ".", "path", ")", "\n", "if", "file_name", "is", "not", "None", ":", "\n", "        ", "filename", "=", "file_name", "\n", "", "cached_file", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "ROOT_DIR", ",", "model_dir", ",", "filename", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cached_file", ")", ":", "\n", "        ", "print", "(", "f'Downloading: \"{url}\" to {cached_file}\\n'", ")", "\n", "download_url_to_file", "(", "url", ",", "cached_file", ",", "hash_prefix", "=", "None", ",", "progress", "=", "progress", ")", "\n", "", "return", "cached_file", "\n", "", ""]]}