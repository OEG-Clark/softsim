{"home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.CCCLoss.__init__": [[20, 22], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.CCCLoss.forward": [[23, 38], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "gold", ",", "pred", ",", "weights", "=", "None", ")", ":", "\n", "# pred = torch.tanh(pred)", "\n", "        ", "gold_mean", "=", "torch", ".", "mean", "(", "gold", ",", "1", ",", "keepdim", "=", "True", ",", "out", "=", "None", ")", "\n", "pred_mean", "=", "torch", ".", "mean", "(", "pred", ",", "1", ",", "keepdim", "=", "True", ",", "out", "=", "None", ")", "\n", "covariance", "=", "(", "gold", "-", "gold_mean", ")", "*", "(", "pred", "-", "pred_mean", ")", "\n", "gold_var", "=", "torch", ".", "var", "(", "gold", ",", "1", ",", "keepdim", "=", "True", ",", "unbiased", "=", "True", ",", "out", "=", "None", ")", "\n", "pred_var", "=", "torch", ".", "var", "(", "pred", ",", "1", ",", "keepdim", "=", "True", ",", "unbiased", "=", "True", ",", "out", "=", "None", ")", "\n", "ccc", "=", "2.", "*", "covariance", "/", "(", "\n", "(", "gold_var", "+", "pred_var", "+", "torch", ".", "mul", "(", "gold_mean", "-", "pred_mean", ",", "gold_mean", "-", "pred_mean", ")", ")", "+", "1e-08", ")", "\n", "ccc_loss", "=", "1.", "-", "ccc", "\n", "\n", "if", "weights", "is", "not", "None", ":", "\n", "            ", "ccc_loss", "*=", "weights", "\n", "\n", "", "return", "torch", ".", "mean", "(", "ccc_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.__init__": [[41, 112], ["experiment_regular.Experiment.get_train_emotion", "experiment_regular.Experiment.init_device", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.get_train_emotion", "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_device"], ["    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "self", ".", "args", "=", "args", "\n", "self", ".", "experiment_name", "=", "args", ".", "experiment_name", "\n", "self", ".", "dataset_path", "=", "args", ".", "dataset_path", "\n", "self", ".", "model_load_path", "=", "args", ".", "model_load_path", "\n", "self", ".", "model_save_path", "=", "args", ".", "model_save_path", "\n", "self", ".", "resume", "=", "args", ".", "resume", "\n", "self", ".", "debug", "=", "args", ".", "debug", "\n", "self", ".", "config", "=", "config", "\n", "\n", "self", ".", "gpu", "=", "args", ".", "gpu", "\n", "self", ".", "cpu", "=", "args", ".", "cpu", "\n", "# If the code is to run on high-performance computer, which is usually not", "\n", "# available to specify gpu index and cpu threads, then set them to none.", "\n", "if", "self", ".", "args", ".", "high_performance_cluster", ":", "\n", "            ", "self", ".", "gpu", "=", "None", "\n", "self", ".", "cpu", "=", "None", "\n", "\n", "", "self", ".", "stamp", "=", "args", ".", "stamp", "\n", "\n", "self", ".", "head", "=", "\"single-headed\"", "\n", "if", "args", ".", "head", "==", "\"mh\"", ":", "\n", "            ", "self", ".", "head", "=", "\"multi-headed\"", "\n", "\n", "", "self", ".", "train_emotion", "=", "args", ".", "train_emotion", "\n", "\n", "self", ".", "emotion_dimension", "=", "self", ".", "get_train_emotion", "(", "args", ".", "train_emotion", ",", "args", ".", "head", ")", "\n", "self", ".", "modality", "=", "args", ".", "modality", "\n", "\n", "self", ".", "backbone_state_dict", "=", "args", ".", "backbone_state_dict", "\n", "self", ".", "backbone_mode", "=", "args", ".", "backbone_mode", "\n", "\n", "self", ".", "cnn1d_embedding_dim", "=", "args", ".", "cnn1d_embedding_dim", "\n", "self", ".", "cnn1d_channels", "=", "args", ".", "cnn1d_channels", "\n", "self", ".", "cnn1d_kernel_size", "=", "args", ".", "cnn1d_kernel_size", "\n", "self", ".", "cnn1d_dropout", "=", "args", ".", "cnn1d_dropout", "\n", "self", ".", "cnn1d_attention", "=", "args", ".", "cnn1d_attention", "\n", "self", ".", "lstm_embedding_dim", "=", "args", ".", "lstm_embedding_dim", "\n", "self", ".", "lstm_hidden_dim", "=", "args", ".", "lstm_hidden_dim", "\n", "self", ".", "lstm_dropout", "=", "args", ".", "lstm_dropout", "\n", "\n", "self", ".", "cross_validation", "=", "args", ".", "cross_validation", "\n", "self", ".", "folds_to_run", "=", "args", ".", "folds_to_run", "\n", "if", "not", "self", ".", "cross_validation", ":", "\n", "            ", "self", ".", "folds_to_run", "=", "[", "0", "]", "\n", "\n", "", "self", ".", "milestone", "=", "args", ".", "milestone", "\n", "self", ".", "learning_rate", "=", "args", ".", "learning_rate", "\n", "self", ".", "min_learning_rate", "=", "args", ".", "min_learning_rate", "\n", "self", ".", "early_stopping", "=", "args", ".", "early_stopping", "\n", "self", ".", "patience", "=", "args", ".", "patience", "\n", "self", ".", "time_delay", "=", "args", ".", "time_delay", "\n", "self", ".", "num_epochs", "=", "args", ".", "num_epochs", "\n", "self", ".", "min_num_epochs", "=", "args", ".", "min_num_epochs", "\n", "self", ".", "factor", "=", "args", ".", "factor", "\n", "\n", "self", ".", "window_length", "=", "args", ".", "window_length", "\n", "self", ".", "hop_length", "=", "args", ".", "hop_length", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "\n", "self", ".", "metrics", "=", "args", ".", "metrics", "\n", "self", ".", "release_count", "=", "args", ".", "release_count", "\n", "self", ".", "gradual_release", "=", "args", ".", "gradual_release", "\n", "self", ".", "load_best_at_each_epoch", "=", "args", ".", "load_best_at_each_epoch", "\n", "\n", "self", ".", "save_plot", "=", "args", ".", "save_plot", "\n", "self", ".", "device", "=", "self", ".", "init_device", "(", ")", "\n", "\n", "self", ".", "model_name", "=", "self", ".", "experiment_name", "+", "\"_\"", "+", "args", ".", "model_name", "+", "\"_\"", "+", "self", ".", "modality", "[", "\n", "0", "]", "+", "\"_\"", "+", "self", ".", "train_emotion", "+", "\"_\"", "+", "args", ".", "head", "+", "\"_bs_\"", "+", "str", "(", "self", ".", "batch_size", ")", "+", "\"_lr_\"", "+", "str", "(", "\n", "self", ".", "learning_rate", ")", "+", "\"_mlr_\"", "+", "str", "(", "self", ".", "min_learning_rate", ")", "+", "\"_\"", "+", "self", ".", "stamp", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.init_dataloader": [[113, 136], ["experiment_regular.Experiment.init_random_seed", "base.dataset.ABAW2_VA_Arranger", "base.dataset.ABAW2_VA_Arranger.resample_according_to_window_and_hop_length", "random.shuffle", "base.dataset.ABAW2_VA_Dataset", "experiment_regular.Experiment.init_random_seed", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "base.dataset.ABAW2_VA_Dataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_random_seed", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Arranger.resample_according_to_window_and_hop_length", "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_random_seed"], ["", "def", "init_dataloader", "(", "self", ",", "fold", ")", ":", "\n", "        ", "self", ".", "init_random_seed", "(", ")", "\n", "arranger", "=", "ABAW2_VA_Arranger", "(", "self", ".", "dataset_path", ",", "window_length", "=", "self", ".", "window_length", ",", "hop_length", "=", "self", ".", "hop_length", ",", "\n", "debug", "=", "self", ".", "debug", ")", "\n", "\n", "# For fold = 0, it is the original partition.", "\n", "data_dict", "=", "arranger", ".", "resample_according_to_window_and_hop_length", "(", "fold", ")", "\n", "random", ".", "shuffle", "(", "data_dict", "[", "'Train_Set'", "]", ")", "\n", "train_dataset", "=", "ABAW2_VA_Dataset", "(", "data_dict", "[", "'Train_Set'", "]", ",", "time_delay", "=", "self", ".", "time_delay", ",", "emotion", "=", "self", ".", "train_emotion", ",", "\n", "head", "=", "self", ".", "head", ",", "modality", "=", "self", ".", "modality", ",", "\n", "mode", "=", "'train'", ",", "fold", "=", "fold", ",", "mean_std_info", "=", "arranger", ".", "mean_std_info", ")", "\n", "self", ".", "init_random_seed", "(", ")", "\n", "train_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "train_dataset", ",", "batch_size", "=", "self", ".", "batch_size", ",", "shuffle", "=", "False", ")", "\n", "\n", "validate_dataset", "=", "ABAW2_VA_Dataset", "(", "data_dict", "[", "'Validation_Set'", "]", ",", "time_delay", "=", "self", ".", "time_delay", ",", "\n", "emotion", "=", "self", ".", "train_emotion", ",", "modality", "=", "self", ".", "modality", ",", "\n", "head", "=", "self", ".", "head", ",", "mode", "=", "'validate'", ",", "fold", "=", "fold", ",", "mean_std_info", "=", "arranger", ".", "mean_std_info", ")", "\n", "validate_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "validate_dataset", ",", "batch_size", "=", "self", ".", "batch_size", ",", "shuffle", "=", "False", ")", "\n", "\n", "dataloader_dict", "=", "{", "'train'", ":", "train_loader", ",", "'validate'", ":", "validate_loader", "}", "\n", "return", "dataloader_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.experiment": [[137, 176], ["experiment_regular.CCCLoss", "iter", "os.path.join", "os.makedirs", "os.path.join", "experiment_regular.Experiment.init_model", "experiment_regular.Experiment.init_dataloader", "base.trainer.ABAW2Trainer", "base.parameter_control.ParamControl", "base.checkpointer.Checkpointer", "str", "base.checkpointer.Checkpointer.load_checkpoint", "base.checkpointer.Checkpointer.init_csv_logger", "base.trainer.ABAW2Trainer.fit"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_model", "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_dataloader", "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.load_checkpoint", "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.init_csv_logger", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.fit"], ["", "def", "experiment", "(", "self", ")", ":", "\n", "\n", "        ", "criterion", "=", "CCCLoss", "(", ")", "\n", "\n", "for", "fold", "in", "iter", "(", "self", ".", "folds_to_run", ")", ":", "\n", "\n", "            ", "save_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "model_save_path", ",", "self", ".", "model_name", ",", "str", "(", "fold", ")", ")", "\n", "os", ".", "makedirs", "(", "save_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "checkpoint_filename", "=", "os", ".", "path", ".", "join", "(", "save_path", ",", "\"checkpoint.pkl\"", ")", "\n", "\n", "model", "=", "self", ".", "init_model", "(", ")", "\n", "\n", "dataloader_dict", "=", "self", ".", "init_dataloader", "(", "fold", ")", "\n", "\n", "\n", "trainer", "=", "ABAW2Trainer", "(", "model", ",", "model_name", "=", "self", ".", "model_name", ",", "learning_rate", "=", "self", ".", "learning_rate", ",", "\n", "min_learning_rate", "=", "self", ".", "min_learning_rate", ",", "\n", "metrics", "=", "self", ".", "metrics", ",", "save_path", "=", "save_path", ",", "early_stopping", "=", "self", ".", "early_stopping", ",", "\n", "train_emotion", "=", "self", ".", "train_emotion", ",", "patience", "=", "self", ".", "patience", ",", "factor", "=", "self", ".", "factor", ",", "\n", "emotional_dimension", "=", "self", ".", "emotion_dimension", ",", "head", "=", "self", ".", "head", ",", "max_epoch", "=", "self", ".", "num_epochs", ",", "\n", "load_best_at_each_epoch", "=", "self", ".", "load_best_at_each_epoch", ",", "window_length", "=", "self", ".", "window_length", ",", "\n", "milestone", "=", "self", ".", "milestone", ",", "criterion", "=", "criterion", ",", "verbose", "=", "True", ",", "save_plot", "=", "self", ".", "save_plot", ",", "\n", "fold", "=", "fold", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "parameter_controller", "=", "ParamControl", "(", "trainer", ",", "gradual_release", "=", "self", ".", "gradual_release", ",", "\n", "release_count", "=", "self", ".", "release_count", ",", "backbone_mode", "=", "self", ".", "backbone_mode", ")", "\n", "\n", "checkpoint_controller", "=", "Checkpointer", "(", "checkpoint_filename", ",", "trainer", ",", "parameter_controller", ",", "resume", "=", "self", ".", "resume", ")", "\n", "\n", "if", "self", ".", "resume", ":", "\n", "                ", "trainer", ",", "parameter_controller", "=", "checkpoint_controller", ".", "load_checkpoint", "(", ")", "\n", "", "else", ":", "\n", "                ", "checkpoint_controller", ".", "init_csv_logger", "(", "self", ".", "args", ",", "self", ".", "config", ")", "\n", "\n", "", "if", "not", "trainer", ".", "fit_finished", ":", "\n", "                ", "trainer", ".", "fit", "(", "dataloader_dict", ",", "num_epochs", "=", "self", ".", "num_epochs", ",", "min_num_epochs", "=", "self", ".", "min_num_epochs", ",", "\n", "save_model", "=", "True", ",", "parameter_controller", "=", "parameter_controller", ",", "\n", "checkpoint_controller", "=", "checkpoint_controller", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.init_model": [[177, 201], ["experiment_regular.Experiment.init_random_seed", "model.model.my_2d1d.model.my_2d1d.init", "ValueError", "len", "model.model.my_2d1d.model.my_2d1ddy", "model.model.my_2d1d.model.my_2d1d"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_random_seed", "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2dlstm.init"], ["", "", "", "def", "init_model", "(", "self", ")", ":", "\n", "        ", "self", ".", "init_random_seed", "(", ")", "\n", "\n", "if", "self", ".", "head", "==", "\"multi-headed\"", ":", "\n", "            ", "output_dim", "=", "2", "\n", "", "else", ":", "\n", "            ", "output_dim", "=", "1", "\n", "\n", "", "if", "\"2d1d\"", "in", "self", ".", "model_name", ":", "\n", "            ", "if", "len", "(", "self", ".", "modality", ")", ">", "1", ":", "\n", "                ", "model", "=", "my_2d1ddy", "(", "backbone_state_dict", "=", "self", ".", "backbone_state_dict", ",", "backbone_mode", "=", "self", ".", "backbone_mode", ",", "\n", "embedding_dim", "=", "self", ".", "cnn1d_embedding_dim", ",", "channels", "=", "self", ".", "cnn1d_channels", ",", "modality", "=", "self", ".", "modality", ",", "\n", "output_dim", "=", "output_dim", ",", "kernel_size", "=", "self", ".", "cnn1d_kernel_size", ",", "attention", "=", "self", ".", "cnn1d_attention", ",", "\n", "dropout", "=", "self", ".", "cnn1d_dropout", ",", "root_dir", "=", "self", ".", "model_load_path", ")", "\n", "", "else", ":", "\n", "                ", "model", "=", "my_2d1d", "(", "backbone_state_dict", "=", "self", ".", "backbone_state_dict", ",", "backbone_mode", "=", "self", ".", "backbone_mode", ",", "\n", "embedding_dim", "=", "self", ".", "cnn1d_embedding_dim", ",", "channels", "=", "self", ".", "cnn1d_channels", ",", "modality", "=", "self", ".", "modality", ",", "\n", "output_dim", "=", "output_dim", ",", "kernel_size", "=", "self", ".", "cnn1d_kernel_size", ",", "attention", "=", "self", ".", "cnn1d_attention", ",", "\n", "dropout", "=", "self", ".", "cnn1d_dropout", ",", "root_dir", "=", "self", ".", "model_load_path", ")", "\n", "", "model", ".", "init", "(", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown base_model!\"", ")", "\n", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.get_train_emotion": [[202, 215], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_train_emotion", "(", "emotion_tag", ",", "head", ")", ":", "\n", "\n", "        ", "emotion", "=", "[", "\"Valence\"", ",", "\"Arousal\"", "]", "\n", "\n", "if", "emotion_tag", "==", "\"arousal\"", ":", "\n", "            ", "if", "head", "==", "\"sh\"", ":", "\n", "                ", "emotion", "=", "[", "\"Arousal\"", "]", "\n", "", "", "elif", "emotion_tag", "==", "\"valence\"", ":", "\n", "            ", "if", "head", "==", "\"sh\"", ":", "\n", "                ", "emotion", "=", "[", "\"Valence\"", "]", "\n", "\n", "", "", "return", "emotion", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.init_random_seed": [[216, 224], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "init_random_seed", "(", ")", ":", "\n", "        ", "random", ".", "seed", "(", "0", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "0", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.experiment_regular.Experiment.init_device": [[225, 233], ["base.utils.detect_device", "base.utils.select_gpu", "base.utils.set_cpu_thread"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.detect_device", "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.select_gpu", "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.set_cpu_thread"], ["", "def", "init_device", "(", "self", ")", ":", "\n", "        ", "device", "=", "detect_device", "(", ")", "\n", "\n", "if", "not", "self", ".", "args", ".", "high_performance_cluster", ":", "\n", "            ", "select_gpu", "(", "self", ".", "gpu", ")", "\n", "set_cpu_thread", "(", "self", ".", "cpu", ")", "\n", "\n", "", "return", "device", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.confirm_length.get_video_path": [[9, 30], ["video_filename_without_extension.endswith", "os.path.join", "label.split", "video_filename_without_extension.endswith", "video_filename_without_extension.split", "print", "ValueError", "video_filename_without_extension.split"], "function", ["None"], ["def", "get_video_path", "(", "label", ",", "partition", ")", ":", "\n", "    ", "label", "=", "label", ".", "split", "(", "\".txt\"", ")", "[", "0", "]", "\n", "video_filename_without_extension", "=", "label", "\n", "\n", "# Find the corresonding video filename.", "\n", "if", "video_filename_without_extension", ".", "endswith", "(", "\"_right\"", ")", ":", "\n", "        ", "video_filename_without_extension", "=", "video_filename_without_extension", ".", "split", "(", "\"_right\"", ")", "[", "0", "]", "\n", "", "elif", "video_filename_without_extension", ".", "endswith", "(", "\"_left\"", ")", ":", "\n", "        ", "video_filename_without_extension", "=", "video_filename_without_extension", ".", "split", "(", "\"_left\"", ")", "[", "0", "]", "\n", "\n", "", "if", "(", "video_filename_without_extension", "+", "\".avi\"", ")", "in", "video_to_partition_dict", "[", "partition", "]", ":", "\n", "        ", "corresponding_video_filename", "=", "video_filename_without_extension", "+", "\".avi\"", "\n", "", "elif", "(", "video_filename_without_extension", "+", "\".mp4\"", ")", "in", "video_to_partition_dict", "[", "partition", "]", ":", "\n", "        ", "corresponding_video_filename", "=", "video_filename_without_extension", "+", "\".mp4\"", "\n", "", "else", ":", "\n", "        ", "print", "(", "video_filename_without_extension", ")", "\n", "raise", "ValueError", "(", "\"Cannot find the corresponding video\"", ")", "\n", "\n", "", "corresponding_video", "=", "os", ".", "path", ".", "join", "(", "raw_video_path", ",", "corresponding_video_filename", ")", "\n", "\n", "return", "corresponding_video", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.__init__": [[16, 76], ["preprocessing.ABAW2_Preprocessing.generate_video_to_partition_dict", "preprocessing.ABAW2_Preprocessing.generate_annotation_to_partition_dict", "preprocessing.ABAW2_Preprocessing.convert_video_to_wav", "preprocessing.ABAW2_Preprocessing.extract_aural_features", "preprocessing.ABAW2_Preprocessing.get_labeled_frame_indices", "preprocessing.ABAW2_Preprocessing.get_available_frame_indices", "preprocessing.ABAW2_Preprocessing.compact_visual_features", "preprocessing.ABAW2_Preprocessing.compact_aural_features", "preprocessing.ABAW2_Preprocessing.compact_labels", "preprocessing.ABAW2_Preprocessing.generate_dataset_info"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.generate_video_to_partition_dict", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.generate_annotation_to_partition_dict", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.convert_video_to_wav", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.extract_aural_features", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.get_labeled_frame_indices", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.get_available_frame_indices", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.compact_visual_features", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.compact_aural_features", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.compact_labels", "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.generate_dataset_info"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "raw_video_path", "=", "config", "[", "'raw_video_path'", "]", "\n", "self", ".", "test_video_path", "=", "config", "[", "'test_video_path'", "]", "\n", "self", ".", "image_path", "=", "config", "[", "'image_path'", "]", "\n", "self", ".", "annotation_path", "=", "config", "[", "'annotation_path'", "]", "\n", "self", ".", "output_path", "=", "config", "[", "'output_path'", "]", "\n", "\n", "self", ".", "aural_feature_list", "=", "config", "[", "'aural_feature_list'", "]", "\n", "self", ".", "opensmile_exe_path", "=", "config", "[", "'opensmile_exe_path'", "]", "\n", "self", ".", "opensmile_config_path", "=", "config", "[", "'opensmile_config_path'", "]", "\n", "\n", "self", ".", "openface_config", "=", "config", "[", "'openface_config'", "]", "\n", "\n", "self", ".", "dataset_info", "=", "{", "}", "\n", "\n", "# Step 1: obtain the data list for training, validation set, and test sets.", "\n", "# Step 1.1: obtain the video list.", "\n", "self", ".", "video_to_partition_dict", "=", "self", ".", "generate_video_to_partition_dict", "(", ")", "\n", "self", ".", "dataset_info", "[", "'video_to_partition_dict'", "]", "=", "self", ".", "video_to_partition_dict", "\n", "\n", "# Step 1.2: obtain the annotation list.", "\n", "self", ".", "annotation_to_partition_dict", "=", "self", ".", "generate_annotation_to_partition_dict", "(", ")", "\n", "self", ".", "dataset_info", "[", "'annotation_to_partition_dict'", "]", "=", "self", ".", "annotation_to_partition_dict", "\n", "\n", "# Step 2: preprocess the aural modality.", "\n", "# Step 2.1: convert all mp4 or avi to uncompressed wav format, since the OpenSmile is not compiled", "\n", "#   with ffmpeg support. The wav files are to be stored in another folder with the same filename.", "\n", "self", ".", "convert_video_to_wav", "(", ")", "\n", "\n", "# # Step 2.2: extract aural features, including mfcc, egemaps, and vggish.", "\n", "self", ".", "extract_aural_features", "(", ")", "\n", "\n", "# Step 3: preprocess the visual modality.", "\n", "# Step 3.1: obtain the labeled frame index for each video.", "\n", "# 1 for labeled, 0 for non-labeled.", "\n", "self", ".", "labeled_frame_indices_of_each_video", "=", "self", ".", "get_labeled_frame_indices", "(", ")", "\n", "\n", "# Step 3.2: obtained the available frame images from \"cropped_aligned\" folder.", "\n", "# 1 for available, 0 for unavailable, -1 for non-labeled.", "\n", "self", ".", "available_frame_indices_of_each_video", "=", "self", ".", "get_available_frame_indices", "(", ")", "\n", "\n", "# Step 3.3: extract visual features including facial landmarks and action units.", "\n", "#   (Extract cropped facial images using Openface. It is not used eventually.", "\n", "#   The cropped-aligned images from the database are used.", "\n", "#    The images are better (in terms of per-frame success rate) than those extracted by OpenFace.)", "\n", "# self.extract_visual_features()", "\n", "\n", "# Step 4: prepare the extracted features into npy format.", "\n", "# Step 4.1: compact the downloaded cropped_aligned jpgs to npy format.", "\n", "#       And filled the missing jpg as black images.", "\n", "self", ".", "compact_visual_features", "(", ")", "\n", "#", "\n", "# Step 4.2: compact the extracted aural features, including mfcc, egemaps, and vggish.", "\n", "self", ".", "compact_aural_features", "(", ")", "\n", "\n", "# Step 4.3: compact the txt labels into npy format.", "\n", "self", ".", "compact_labels", "(", ")", "\n", "#", "\n", "# Step 5: generate the dataset info.", "\n", "self", ".", "generate_dataset_info", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.generate_dataset_info": [[77, 92], ["preprocessing.ABAW2_Preprocessing.annotation_to_partition_dict.items", "base.utils.save_pkl_file", "tqdm.tqdm.tqdm", "numpy.sum", "len"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.save_pkl_file"], ["", "def", "generate_dataset_info", "(", "self", ")", ":", "\n", "        ", "dataset_info", "=", "{", "}", "\n", "\n", "partition_dict", "=", "{", "'Train_Set'", ":", "{", "}", ",", "'Validation_Set'", ":", "{", "}", ",", "'Test_Set'", ":", "{", "}", "}", "\n", "for", "partition", ",", "labels", "in", "self", ".", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "label", "in", "tqdm", "(", "labels", ",", "total", "=", "len", "(", "labels", ")", ",", "desc", "=", "partition", ")", ":", "\n", "                ", "trial_name", "=", "label", "[", ":", "-", "4", "]", "\n", "if", "partition", "==", "\"Test_Set\"", ":", "\n", "                    ", "trial_name", "=", "label", "\n", "", "trial_length", "=", "np", ".", "sum", "(", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", ")", "\n", "partition_dict", "[", "partition", "]", "[", "trial_name", "]", "=", "trial_length", "\n", "\n", "", "", "dataset_info", "[", "'partition'", "]", "=", "partition_dict", "\n", "\n", "save_pkl_file", "(", "self", ".", "output_path", ",", "\"dataset_info.pkl\"", ",", "dataset_info", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.compact_labels": [[93, 114], ["preprocessing.ABAW2_Preprocessing.annotation_to_partition_dict.items", "tqdm.tqdm.tqdm", "os.path.join", "base.utils.txt_row_count", "os.path.join", "os.makedirs", "os.path.join", "len", "os.path.isfile", "range", "numpy.stack", "numpy.save", "pandas.read_csv", "numpy.stack.append"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.txt_row_count"], ["", "def", "compact_labels", "(", "self", ")", ":", "\n", "        ", "for", "partition", ",", "labels", "in", "self", ".", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "partition", "!=", "\"Test_Set\"", ":", "\n", "                ", "for", "label", "in", "tqdm", "(", "labels", ",", "total", "=", "len", "(", "labels", ")", ")", ":", "\n", "                    ", "trial_name", "=", "label", "[", ":", "-", "4", "]", "\n", "label_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "annotation_path", ",", "partition", ",", "label", ")", "\n", "trial_length", "=", "txt_row_count", "(", "label_path", ")", "\n", "\n", "npy_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"npy_data\"", ",", "trial_name", ")", "\n", "os", ".", "makedirs", "(", "npy_folder", ",", "exist_ok", "=", "True", ")", "\n", "\n", "npy_label_path", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"label.npy\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_label_path", ")", ":", "\n", "                        ", "label_data", "=", "pd", ".", "read_csv", "(", "label_path", ",", "sep", "=", "\",\"", ")", ".", "values", "\n", "label_sampled", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                            ", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                                ", "label_sampled", ".", "append", "(", "label_data", "[", "i", ",", ":", "]", ")", "\n", "\n", "", "", "label_sampled", "=", "np", ".", "stack", "(", "label_sampled", ")", "\n", "np", ".", "save", "(", "npy_label_path", ",", "label_sampled", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.compact_aural_features": [[115, 190], ["preprocessing.ABAW2_Preprocessing.annotation_to_partition_dict.items", "tqdm.tqdm.tqdm", "trial_name.endswith", "os.path.join", "base.utils.txt_row_count", "os.path.join", "os.makedirs", "preprocessing.ABAW2_Preprocessing.get_video_path", "cv2.VideoCapture", "cv2.VideoCapture.get", "os.path.join", "os.path.join", "os.path.join", "len", "trial_name.endswith", "os.path.isfile", "os.path.join", "range", "numpy.stack", "numpy.save", "os.path.isfile", "os.path.join", "range", "numpy.stack", "numpy.save", "os.path.isfile", "os.path.join", "numpy.load", "range", "numpy.stack", "numpy.save", "pandas.read_csv", "pandas.read_csv", "int", "numpy.stack.append", "int", "numpy.stack.append", "numpy.stack.append", "range", "round", "len", "range", "round", "len", "len"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.txt_row_count", "home.repos.pwc.inspect_result.sucv_ABAW2.script.confirm_length.get_video_path"], ["", "", "", "", "", "def", "compact_aural_features", "(", "self", ")", ":", "\n", "        ", "for", "partition", ",", "labels", "in", "self", ".", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "label", "in", "tqdm", "(", "labels", ",", "total", "=", "len", "(", "labels", ")", ",", "desc", "=", "partition", ")", ":", "\n", "                ", "trial_name", "=", "label", "[", ":", "-", "4", "]", "\n", "if", "trial_name", ".", "endswith", "(", "\"_left\"", ")", ":", "\n", "                    ", "trial_name_without_left_right", "=", "trial_name", "[", ":", "-", "5", "]", "\n", "", "elif", "trial_name", ".", "endswith", "(", "\"_right\"", ")", ":", "\n", "                    ", "trial_name_without_left_right", "=", "trial_name", "[", ":", "-", "6", "]", "\n", "", "else", ":", "\n", "                    ", "trial_name_without_left_right", "=", "trial_name", "\n", "\n", "", "label_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "annotation_path", ",", "partition", ",", "label", ")", "\n", "trial_length", "=", "txt_row_count", "(", "label_path", ")", "\n", "\n", "npy_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"npy_data\"", ",", "trial_name", ")", "\n", "os", ".", "makedirs", "(", "npy_folder", ",", "exist_ok", "=", "True", ")", "\n", "\n", "current_video_path", "=", "self", ".", "get_video_path", "(", "label", ",", "partition", ")", "\n", "video", "=", "cv2", ".", "VideoCapture", "(", "current_video_path", ")", "\n", "video_fps", "=", "video", ".", "get", "(", "cv2", ".", "CAP_PROP_FPS", ")", "\n", "\n", "# For mfcc feature", "\n", "npy_path_mfcc", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"mfcc.npy\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_path_mfcc", ")", ":", "\n", "                    ", "mfcc_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"audio_features_mfcc\"", ",", "partition", ",", "\n", "trial_name_without_left_right", "+", "\".csv\"", ")", "\n", "mfcc_feature_matrix", "=", "pd", ".", "read_csv", "(", "mfcc_path", ",", "sep", "=", "\";\"", ",", "usecols", "=", "range", "(", "2", ",", "41", ")", ")", ".", "values", "\n", "mfcc_feature_sampled", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                        ", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                            ", "index_to_sample", "=", "int", "(", "round", "(", "i", "*", "1", "/", "video_fps", "/", "0.01", ")", ")", "\n", "if", "index_to_sample", ">=", "len", "(", "mfcc_feature_matrix", ")", ":", "\n", "                                ", "index_to_sample", "=", "-", "1", "\n", "", "mfcc_feature_sampled", ".", "append", "(", "mfcc_feature_matrix", "[", "index_to_sample", "]", ")", "\n", "\n", "", "", "mfcc_feature_sampled", "=", "np", ".", "stack", "(", "mfcc_feature_sampled", ")", "\n", "\n", "np", ".", "save", "(", "npy_path_mfcc", ",", "mfcc_feature_sampled", ")", "\n", "\n", "# For vggish feature", "\n", "", "npy_path_egemaps", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"egemaps.npy\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_path_egemaps", ")", ":", "\n", "                    ", "egemaps_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"audio_features_egemaps\"", ",", "partition", ",", "\n", "trial_name_without_left_right", "+", "\".csv\"", ")", "\n", "egemaps_feature_matrix", "=", "pd", ".", "read_csv", "(", "egemaps_path", ",", "sep", "=", "\";\"", ",", "usecols", "=", "range", "(", "2", ",", "25", ")", ")", ".", "values", "\n", "egemaps_feature_sampled", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                        ", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                            ", "index_to_sample", "=", "int", "(", "round", "(", "i", "*", "1", "/", "video_fps", "/", "0.01", ")", ")", "\n", "if", "index_to_sample", ">=", "len", "(", "egemaps_feature_matrix", ")", ":", "\n", "                                ", "index_to_sample", "=", "-", "1", "\n", "\n", "", "egemaps_feature_sampled", ".", "append", "(", "egemaps_feature_matrix", "[", "index_to_sample", "]", ")", "\n", "\n", "", "", "egemaps_feature_sampled", "=", "np", ".", "stack", "(", "egemaps_feature_sampled", ")", "\n", "\n", "np", ".", "save", "(", "npy_path_egemaps", ",", "egemaps_feature_sampled", ")", "\n", "\n", "# For vggish feature", "\n", "", "npy_path_vggish", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"vggish.npy\"", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_path_vggish", ")", ":", "\n", "                    ", "vggish_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"audio_features_vggish\"", ",", "partition", ",", "\n", "trial_name_without_left_right", "+", "\".npy\"", ")", "\n", "vggish_feature_matrix", "=", "np", ".", "load", "(", "vggish_path", ",", "mmap_mode", "=", "\"c\"", ")", "\n", "\n", "vggish_feature_sampled", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                        ", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                            ", "index_to_sample", "=", "i", "\n", "if", "index_to_sample", ">=", "len", "(", "vggish_feature_matrix", ")", ":", "\n", "                                ", "index_to_sample", "=", "-", "1", "\n", "", "vggish_feature_sampled", ".", "append", "(", "vggish_feature_matrix", "[", "index_to_sample", ",", ":", "]", ")", "\n", "\n", "", "", "vggish_feature_sampled", "=", "np", ".", "stack", "(", "vggish_feature_sampled", ")", "\n", "np", ".", "save", "(", "npy_path_vggish", ",", "vggish_feature_sampled", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.compact_visual_features": [[191, 266], ["preprocessing.ABAW2_Preprocessing.annotation_to_partition_dict.items", "tqdm.tqdm.tqdm", "os.path.join", "os.path.join", "os.makedirs", "os.path.join", "numpy.zeros", "os.path.join", "os.path.join", "len", "os.path.join", "base.utils.txt_row_count", "preprocessing.ABAW2_Preprocessing.get_video_path", "cv2.VideoCapture", "int", "os.path.isfile", "range", "numpy.stack", "numpy.save", "os.path.isfile", "os.path.join", "numpy.concatenate", "numpy.where", "base.utils.standardize_facial_landmarks", "range", "numpy.stack", "numpy.save", "os.path.isfile", "os.path.join", "range", "numpy.stack", "numpy.save", "cv2.VideoCapture.get", "os.path.join", "pandas.read_csv", "pandas.read_csv", "pandas.read_csv", "os.path.isfile", "numpy.stack.append", "numpy.stack.append", "str().zfill", "PIL.Image.open", "current_frame.resize.resize.resize", "numpy.stack.append", "numpy.stack.append", "range", "range", "pandas.read_csv", "len", "range", "len", "numpy.array", "str", "range"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.txt_row_count", "home.repos.pwc.inspect_result.sucv_ABAW2.script.confirm_length.get_video_path", "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.standardize_facial_landmarks"], ["", "", "", "", "def", "compact_visual_features", "(", "self", ")", ":", "\n", "        ", "for", "partition", ",", "labels", "in", "self", ".", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "label", "in", "tqdm", "(", "labels", ",", "total", "=", "len", "(", "labels", ")", ",", "desc", "=", "partition", ")", ":", "\n", "                ", "if", "partition", "!=", "\"Test_Set\"", ":", "\n", "                    ", "trial_name", "=", "label", "[", ":", "-", "4", "]", "\n", "label_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "annotation_path", ",", "partition", ",", "label", ")", "\n", "trial_length", "=", "txt_row_count", "(", "label_path", ")", "\n", "", "else", ":", "\n", "                    ", "trial_name", "=", "label", "\n", "corresponding_video", "=", "self", ".", "get_video_path", "(", "trial_name", "+", "\".txt\"", ",", "partition", ")", "\n", "video", "=", "cv2", ".", "VideoCapture", "(", "corresponding_video", ")", "\n", "trial_length", "=", "int", "(", "video", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_COUNT", ")", ")", "\n", "\n", "", "input_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "image_path", ",", "trial_name", ")", "\n", "npy_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"npy_data\"", ",", "trial_name", ")", "\n", "os", ".", "makedirs", "(", "npy_folder", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# For frame", "\n", "npy_frame_path", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"frame.npy\"", ")", "\n", "frame_matrix", "=", "[", "]", "\n", "black", "=", "np", ".", "zeros", "(", "(", "48", ",", "48", ",", "3", ")", ",", "dtype", "=", "np", ".", "int8", ")", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_frame_path", ")", ":", "\n", "\n", "                    ", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                        ", "current_frame_path", "=", "os", ".", "path", ".", "join", "(", "input_path", ",", "str", "(", "i", "+", "1", ")", ".", "zfill", "(", "5", ")", "+", "\".jpg\"", ")", "\n", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                            ", "if", "os", ".", "path", ".", "isfile", "(", "current_frame_path", ")", ":", "\n", "                                ", "current_frame", "=", "Image", ".", "open", "(", "current_frame_path", ")", "\n", "current_frame", "=", "current_frame", ".", "resize", "(", "(", "48", ",", "48", ")", ")", "\n", "frame_matrix", ".", "append", "(", "np", ".", "array", "(", "current_frame", ")", ")", "\n", "", "else", ":", "\n", "                                ", "frame_matrix", ".", "append", "(", "black", ")", "\n", "\n", "", "", "", "frame_matrix", "=", "np", ".", "stack", "(", "frame_matrix", ")", "\n", "np", ".", "save", "(", "npy_frame_path", ",", "frame_matrix", ")", "\n", "\n", "# For facial landmark", "\n", "", "npy_flm_path", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"landmark.npy\"", ")", "\n", "landmark_matrix", "=", "[", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_flm_path", ")", ":", "\n", "                    ", "flm_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"visual_features_openface_48\"", ",", "trial_name", "+", "\".csv\"", ")", "\n", "flm_data_x", "=", "pd", ".", "read_csv", "(", "flm_path", ",", "usecols", "=", "range", "(", "5", ",", "73", ")", ")", ".", "values", "\n", "flm_data_y", "=", "pd", ".", "read_csv", "(", "flm_path", ",", "usecols", "=", "range", "(", "73", ",", "141", ")", ")", ".", "values", "\n", "flm_data", "=", "np", ".", "concatenate", "(", "(", "flm_data_x", "[", "...", ",", "None", "]", ",", "flm_data_y", "[", "...", ",", "None", "]", ")", ",", "axis", "=", "2", ")", "\n", "success_flm_indices", "=", "np", ".", "where", "(", "pd", ".", "read_csv", "(", "flm_path", ",", "usecols", "=", "range", "(", "4", ",", "5", ")", ")", ".", "values", "==", "1", ")", "\n", "success_flm_data", "=", "flm_data", "[", "success_flm_indices", "[", "0", "]", "]", "\n", "success_flm_data", "=", "standardize_facial_landmarks", "(", "success_flm_data", ")", "\n", "flm_data", "[", "success_flm_indices", "[", "0", "]", "]", "=", "success_flm_data", "\n", "\n", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                        ", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                            ", "if", "i", ">=", "len", "(", "flm_data", ")", ":", "\n", "                                ", "i", "=", "-", "1", "\n", "", "landmark_matrix", ".", "append", "(", "flm_data", "[", "i", "]", ")", "\n", "\n", "", "", "landmark_matrix", "=", "np", ".", "stack", "(", "landmark_matrix", ")", "\n", "np", ".", "save", "(", "npy_flm_path", ",", "landmark_matrix", ")", "\n", "\n", "# For facial action unit", "\n", "", "npy_au_path", "=", "os", ".", "path", ".", "join", "(", "npy_folder", ",", "\"au.npy\"", ")", "\n", "au_matrix", "=", "[", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "npy_au_path", ")", ":", "\n", "                    ", "au_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"visual_features_openface_48\"", ",", "trial_name", "+", "\".csv\"", ")", "\n", "au_data", "=", "pd", ".", "read_csv", "(", "au_path", ",", "usecols", "=", "range", "(", "141", ",", "158", ")", ")", ".", "values", "\n", "\n", "for", "i", "in", "range", "(", "trial_length", ")", ":", "\n", "                        ", "if", "self", ".", "labeled_frame_indices_of_each_video", "[", "partition", "]", "[", "trial_name", "]", "[", "i", "]", "==", "1", ":", "\n", "                            ", "if", "i", ">=", "len", "(", "au_data", ")", ":", "\n", "                                ", "i", "=", "-", "1", "\n", "", "au_matrix", ".", "append", "(", "au_data", "[", "i", "]", ")", "\n", "\n", "", "", "au_matrix", "=", "np", ".", "stack", "(", "au_matrix", ")", "\n", "np", ".", "save", "(", "npy_au_path", ",", "au_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.extract_visual_features": [[267, 279], ["preprocessing.ABAW2_Preprocessing.annotation_to_partition_dict.items", "tqdm.tqdm.tqdm", "os.path.join", "os.path.join", "os.makedirs", "base.utils.OpenFaceController", "base.utils.OpenFaceController.process_video", "len"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.OpenFaceController.process_video"], ["", "", "", "", "def", "extract_visual_features", "(", "self", ")", ":", "\n", "\n", "        ", "for", "partition", ",", "labels", "in", "self", ".", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "label", "in", "tqdm", "(", "labels", ",", "total", "=", "len", "(", "labels", ")", ")", ":", "\n", "                ", "input_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "image_path", ",", "label", "[", ":", "-", "4", "]", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"visual_features_openface_48\"", ")", "\n", "os", ".", "makedirs", "(", "output_path", ",", "exist_ok", "=", "True", ")", "\n", "\n", "openface", "=", "OpenFaceController", "(", "openface_path", "=", "self", ".", "openface_config", "[", "'openface_directory'", "]", ",", "\n", "output_directory", "=", "output_path", ")", "\n", "_", "=", "openface", ".", "process_video", "(", "\n", "input_filename", "=", "input_path", ",", "output_filename", "=", "label", "[", ":", "-", "4", "]", ",", "**", "self", ".", "openface_config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.get_available_frame_indices": [[280, 310], ["os.path.join", "os.path.isfile", "preprocessing.ABAW2_Preprocessing.labeled_frame_indices_of_each_video.items", "open", "pickle.load", "tqdm.tqdm.tqdm", "open", "pickle.dump", "index_dict.items", "enumerate", "available_frame_indices[].update", "len", "str().zfill", "os.path.join", "os.path.isfile", "available_indices.append", "available_indices.append", "available_indices.append", "str"], "methods", ["None"], ["", "", "", "def", "get_available_frame_indices", "(", "self", ")", ":", "\n", "        ", "available_frame_indices", "=", "{", "'Train_Set'", ":", "{", "}", ",", "'Validation_Set'", ":", "{", "}", ",", "'Test_Set'", ":", "{", "}", "}", "\n", "intermediate_pkl_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"available_frame_indices.pkl\"", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "intermediate_pkl_path", ")", ":", "\n", "            ", "with", "open", "(", "intermediate_pkl_path", ",", "'rb'", ")", "as", "handle", ":", "\n", "                ", "available_frame_indices", "=", "pickle", ".", "load", "(", "handle", ")", "\n", "", "", "else", ":", "\n", "# If this is not done before, then do it now.", "\n", "            ", "for", "partition", ",", "index_dict", "in", "self", ".", "labeled_frame_indices_of_each_video", ".", "items", "(", ")", ":", "\n", "\n", "                ", "for", "trial", ",", "index", "in", "tqdm", "(", "index_dict", ".", "items", "(", ")", ",", "total", "=", "len", "(", "index_dict", ")", ")", ":", "\n", "\n", "                    ", "available_indices", "=", "[", "]", "\n", "for", "i", ",", "flag", "in", "enumerate", "(", "index", ")", ":", "\n", "                        ", "if", "flag", "==", "1", ":", "\n", "                            ", "frame_id", "=", "str", "(", "i", "+", "1", ")", ".", "zfill", "(", "5", ")", "\n", "frame_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "image_path", ",", "trial", ",", "frame_id", "+", "\".jpg\"", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "frame_path", ")", ":", "\n", "                                ", "available_indices", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "                                ", "available_indices", ".", "append", "(", "0", ")", "\n", "", "", "else", ":", "\n", "                            ", "available_indices", ".", "append", "(", "-", "1", ")", "\n", "", "", "available_frame_indices", "[", "partition", "]", ".", "update", "(", "{", "trial", ":", "available_indices", "}", ")", "\n", "\n", "", "", "with", "open", "(", "intermediate_pkl_path", ",", "'wb'", ")", "as", "handle", ":", "\n", "                ", "pickle", ".", "dump", "(", "available_frame_indices", ",", "handle", ")", "\n", "\n", "", "", "return", "available_frame_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.get_labeled_frame_indices": [[311, 351], ["os.path.join", "os.path.isfile", "preprocessing.ABAW2_Preprocessing.annotation_to_partition_dict.items", "open", "pickle.load", "tqdm.tqdm.tqdm", "open", "pickle.dump", "len", "os.path.join", "pandas.read_csv", "pandas.read_csv.iterrows", "labeled_frame_indices[].update", "preprocessing.ABAW2_Preprocessing.get_video_path", "cv2.VideoCapture", "int", "numpy.ones().tolist", "labeled_frame_indices[].update", "cv2.VideoCapture.get", "numpy.ones().tolist.append", "numpy.ones().tolist.append", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.script.confirm_length.get_video_path"], ["", "def", "get_labeled_frame_indices", "(", "self", ")", ":", "\n", "\n", "        ", "labeled_frame_indices", "=", "{", "'Train_Set'", ":", "{", "}", ",", "'Validation_Set'", ":", "{", "}", ",", "'Test_Set'", ":", "{", "}", "}", "\n", "intermediate_pkl_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"labeled_frame_indices.pkl\"", ")", "\n", "if", "os", ".", "path", ".", "isfile", "(", "intermediate_pkl_path", ")", ":", "\n", "            ", "with", "open", "(", "intermediate_pkl_path", ",", "'rb'", ")", "as", "handle", ":", "\n", "                ", "labeled_frame_indices", "=", "pickle", ".", "load", "(", "handle", ")", "\n", "", "", "else", ":", "\n", "# If this is not done before, then do it now.", "\n", "            ", "for", "partition", ",", "labels", "in", "self", ".", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "\n", "                ", "for", "label", "in", "tqdm", "(", "labels", ",", "total", "=", "len", "(", "labels", ")", ")", ":", "\n", "\n", "                    ", "if", "partition", "!=", "\"Test_Set\"", ":", "\n", "                        ", "label_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "annotation_path", ",", "partition", ",", "label", ")", "\n", "\n", "df", "=", "pd", ".", "read_csv", "(", "label_path", ",", "delimiter", "=", "\",\"", ")", "\n", "num_label_points", ",", "_", "=", "df", ".", "shape", "\n", "\n", "labeled_indices", "=", "[", "]", "\n", "\n", "for", "index", ",", "row", "in", "df", ".", "iterrows", "(", ")", ":", "\n", "                            ", "if", "row", "[", "'valence'", "]", "!=", "-", "5", "and", "row", "[", "'arousal'", "]", "!=", "-", "5", ":", "\n", "                                ", "labeled_indices", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "                                ", "labeled_indices", ".", "append", "(", "0", ")", "\n", "\n", "", "", "labeled_frame_indices", "[", "partition", "]", ".", "update", "(", "{", "label", "[", ":", "-", "4", "]", ":", "labeled_indices", "}", ")", "\n", "\n", "", "else", ":", "\n", "                        ", "corresponding_video", "=", "self", ".", "get_video_path", "(", "label", "+", "\".txt\"", ",", "partition", ")", "\n", "video", "=", "cv2", ".", "VideoCapture", "(", "corresponding_video", ")", "\n", "video_frame_count", "=", "int", "(", "video", ".", "get", "(", "cv2", ".", "CAP_PROP_FRAME_COUNT", ")", ")", "\n", "labeled_indices", "=", "np", ".", "ones", "(", "video_frame_count", ",", "dtype", "=", "np", ".", "int64", ")", ".", "tolist", "(", ")", "\n", "labeled_frame_indices", "[", "partition", "]", ".", "update", "(", "{", "label", ":", "labeled_indices", "}", ")", "\n", "\n", "", "", "", "with", "open", "(", "intermediate_pkl_path", ",", "'wb'", ")", "as", "handle", ":", "\n", "                ", "pickle", ".", "dump", "(", "labeled_frame_indices", ",", "handle", ")", "\n", "\n", "", "", "return", "labeled_frame_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.get_video_path": [[352, 373], ["video_filename_without_extension.endswith", "os.path.join", "video_filename_without_extension.endswith", "video_filename_without_extension.split", "print", "ValueError", "video_filename_without_extension.split"], "methods", ["None"], ["", "def", "get_video_path", "(", "self", ",", "label", ",", "partition", ")", ":", "\n", "\n", "        ", "video_filename_without_extension", "=", "label", "[", ":", "-", "4", "]", "\n", "\n", "# Find the corresonding video filename.", "\n", "if", "video_filename_without_extension", ".", "endswith", "(", "\"_right\"", ")", ":", "\n", "            ", "video_filename_without_extension", "=", "video_filename_without_extension", ".", "split", "(", "\"_right\"", ")", "[", "0", "]", "\n", "", "elif", "video_filename_without_extension", ".", "endswith", "(", "\"_left\"", ")", ":", "\n", "            ", "video_filename_without_extension", "=", "video_filename_without_extension", ".", "split", "(", "\"_left\"", ")", "[", "0", "]", "\n", "\n", "", "if", "(", "video_filename_without_extension", "+", "\".avi\"", ")", "in", "self", ".", "video_to_partition_dict", "[", "partition", "]", ":", "\n", "            ", "corresponding_video_filename", "=", "video_filename_without_extension", "+", "\".avi\"", "\n", "", "elif", "(", "video_filename_without_extension", "+", "\".mp4\"", ")", "in", "self", ".", "video_to_partition_dict", "[", "partition", "]", ":", "\n", "            ", "corresponding_video_filename", "=", "video_filename_without_extension", "+", "\".mp4\"", "\n", "", "else", ":", "\n", "            ", "print", "(", "video_filename_without_extension", ")", "\n", "raise", "ValueError", "(", "\"Cannot find the corresponding video\"", ")", "\n", "\n", "", "corresponding_video", "=", "os", ".", "path", ".", "join", "(", "self", ".", "raw_video_path", ",", "corresponding_video_filename", ")", "\n", "\n", "return", "corresponding_video", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.extract_aural_features": [[374, 436], ["preprocessing.ABAW2_Preprocessing.video_to_partition_dict.items", "tqdm.tqdm.tqdm", "os.path.join", "os.path.join", "len", "os.path.join", "os.path.join", "os.makedirs", "os.path.join", "os.path.join", "os.path.join", "os.makedirs", "os.path.join", "os.path.join", "os.makedirs", "os.path.join", "os.path.isfile", "subprocess.call", "os.path.isfile", "subprocess.call", "os.path.isfile", "cv2.VideoCapture", "cv2.VideoCapture.get", "extract_vggish", "numpy.save"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.inference.extract_vggish"], ["", "def", "extract_aural_features", "(", "self", ")", ":", "\n", "\n", "        ", "for", "partition", ",", "wavs", "in", "self", ".", "video_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "wav", "in", "tqdm", "(", "wavs", ",", "total", "=", "len", "(", "wavs", ")", ")", ":", "\n", "\n", "                ", "input_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"wav\"", ",", "partition", ",", "wav", "[", ":", "-", "4", "]", "+", "\".wav\"", ")", "\n", "corresponding_video", "=", "os", ".", "path", ".", "join", "(", "self", ".", "raw_video_path", ",", "wav", ")", "\n", "\n", "if", "\"mfcc\"", "in", "self", ".", "aural_feature_list", ":", "\n", "                    ", "feature", "=", "\"mfcc\"", "\n", "opensmile_config_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opensmile_config_path", ",", "feature", ",", "\"MFCC12_0_D_A.conf\"", ")", "\n", "opensmile_options", "=", "\"-configfile \"", "+", "opensmile_config_path", "+", "\" -appendcsv 0 -timestampcsv 1 -headercsv 1 \"", "\n", "output_option", "=", "\"-csvoutput\"", "\n", "\n", "output_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"audio_features_\"", "+", "feature", ",", "partition", ")", "\n", "os", ".", "makedirs", "(", "output_folder", ",", "exist_ok", "=", "True", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "wav", "[", ":", "-", "4", "]", "+", "\".csv\"", ")", "\n", "\n", "command", "=", "\"{opensmile_exe_path} {opensmile_options} -inputfile {input_path} {output_option} {output_path} -instname {filename} -output ?\"", ".", "format", "(", "\n", "opensmile_exe_path", "=", "self", ".", "opensmile_exe_path", ",", "opensmile_options", "=", "opensmile_options", ",", "\n", "input_path", "=", "input_path", ",", "output_option", "=", "output_option", ",", "output_path", "=", "output_path", ",", "filename", "=", "wav", "[", ":", "-", "4", "]", "\n", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_path", ")", ":", "\n", "                        ", "subprocess", ".", "call", "(", "command", ")", "\n", "\n", "", "", "if", "\"egemaps\"", "in", "self", ".", "aural_feature_list", ":", "\n", "                    ", "feature", "=", "\"egemaps\"", "\n", "opensmile_config_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "opensmile_config_path", ",", "feature", ",", "\"v01a\"", ",", "\n", "\"eGeMAPSv01a.conf\"", ")", "\n", "opensmile_options", "=", "\"-configfile \"", "+", "opensmile_config_path", "+", "\" -appendcsvlld 0 -timestampcsvlld 1 -headercsvlld 1 \"", "\n", "output_option", "=", "\"-lldcsvoutput\"", "\n", "\n", "output_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"audio_features_\"", "+", "feature", ",", "partition", ")", "\n", "os", ".", "makedirs", "(", "output_folder", ",", "exist_ok", "=", "True", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "wav", "[", ":", "-", "4", "]", "+", "\".csv\"", ")", "\n", "\n", "command", "=", "\"{opensmile_exe_path} {opensmile_options} -inputfile {input_path} {output_option} {output_path} -instname {filename} -output ?\"", ".", "format", "(", "\n", "opensmile_exe_path", "=", "self", ".", "opensmile_exe_path", ",", "opensmile_options", "=", "opensmile_options", ",", "\n", "input_path", "=", "input_path", ",", "output_option", "=", "output_option", ",", "output_path", "=", "output_path", ",", "filename", "=", "wav", "[", ":", "-", "4", "]", "\n", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_path", ")", ":", "\n", "                        ", "subprocess", ".", "call", "(", "command", ")", "\n", "\n", "", "", "if", "\"vggish\"", "in", "self", ".", "aural_feature_list", ":", "\n", "# Requires tensorflow and GPU to run. One wav file at a time.", "\n", "                    ", "from", "vggish", ".", "inference", "import", "extract_vggish", "\n", "feature", "=", "\"vggish\"", "\n", "\n", "output_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"audio_features_\"", "+", "feature", ",", "partition", ")", "\n", "os", ".", "makedirs", "(", "output_folder", ",", "exist_ok", "=", "True", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "wav", "[", ":", "-", "4", "]", "+", "\".npy\"", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_path", ")", ":", "\n", "                        ", "video", "=", "cv2", ".", "VideoCapture", "(", "corresponding_video", ")", "\n", "video_fps", "=", "video", ".", "get", "(", "cv2", ".", "CAP_PROP_FPS", ")", "\n", "hop_sec", "=", "1", "/", "video_fps", "\n", "\n", "vggish_feature", "=", "extract_vggish", "(", "wav_file", "=", "input_path", ",", "window_sec", "=", "0.96", ",", "hop_sec", "=", "hop_sec", ")", "\n", "\n", "np", ".", "save", "(", "output_path", ",", "vggish_feature", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.convert_video_to_wav": [[437, 456], ["preprocessing.ABAW2_Preprocessing.video_to_partition_dict.items", "tqdm.tqdm.tqdm", "os.path.join", "os.path.join", "os.makedirs", "os.path.join", "len", "os.path.isfile", "subprocess.call"], "methods", ["None"], ["", "", "", "", "", "def", "convert_video_to_wav", "(", "self", ")", ":", "\n", "        ", "for", "partition", ",", "files", "in", "self", ".", "video_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "file", "in", "tqdm", "(", "files", ",", "total", "=", "len", "(", "files", ")", ")", ":", "\n", "# Input mp4 or avi", "\n", "                ", "input_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "raw_video_path", ",", "file", ")", "\n", "\n", "# Output wav", "\n", "output_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "output_path", ",", "\"wav\"", ",", "partition", ")", "\n", "os", ".", "makedirs", "(", "output_folder", ",", "exist_ok", "=", "True", ")", "\n", "output_path", "=", "os", ".", "path", ".", "join", "(", "output_folder", ",", "file", "[", ":", "-", "4", "]", "+", "\".wav\"", ")", "\n", "\n", "# ffmpeg command to execute", "\n", "# -ac 1 for mono, -ar 16000 for sample rate 16k, -q:v 0 for unchanging the quality.", "\n", "command", "=", "\"ffmpeg -i {input_path} -ac 1 -ar 16000  -q:v 0 -f wav {output_path}\"", ".", "format", "(", "\n", "input_path", "=", "input_path", ",", "output_path", "=", "output_path", ")", "\n", "\n", "# execute if the output does not exist", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "output_path", ")", ":", "\n", "                    ", "subprocess", ".", "call", "(", "command", ",", "shell", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.generate_video_to_partition_dict": [[457, 488], ["os.walk", "os.listdir", "os.listdir", "root.split", "file.endswith", "len", "processed.append", "video_to_partition_dict[].append", "file.split", "file.split"], "methods", ["None"], ["", "", "", "", "def", "generate_video_to_partition_dict", "(", "self", ")", ":", "\n", "        ", "video_to_partition_dict", "=", "{", "'Train_Set'", ":", "[", "]", ",", "'Validation_Set'", ":", "[", "]", ",", "'Test_Set'", ":", "[", "]", "}", "\n", "\n", "# Training set and validation set.", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "self", ".", "annotation_path", ")", ":", "\n", "\n", "            ", "video_pool", "=", "os", ".", "listdir", "(", "self", ".", "raw_video_path", ")", "\n", "processed", "=", "[", "]", "\n", "partition", "=", "root", ".", "split", "(", "sep", "=", "os", ".", "sep", ")", "[", "-", "1", "]", "\n", "for", "file", "in", "files", ":", "\n", "\n", "                ", "if", "file", ".", "endswith", "(", "\".txt\"", ")", ":", "\n", "                    ", "if", "\"right\"", "in", "file", ":", "\n", "                        ", "file", "=", "file", ".", "split", "(", "\"_right\"", ")", "[", "0", "]", "\n", "", "elif", "\"left\"", "in", "file", ":", "\n", "                        ", "file", "=", "file", ".", "split", "(", "\"_left\"", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "                        ", "file", "=", "file", "[", ":", "-", "4", "]", "\n", "\n", "", "found_video", "=", "[", "video", "for", "video", "in", "video_pool", "if", "(", "file", "+", "\".mp4\"", "==", "video", "or", "file", "+", "\".avi\"", "==", "video", ")", "]", "\n", "\n", "assert", "len", "(", "found_video", ")", "==", "1", "\n", "\n", "if", "found_video", "[", "0", "]", "not", "in", "processed", ":", "\n", "                        ", "processed", ".", "append", "(", "found_video", "[", "0", "]", ")", "\n", "video_to_partition_dict", "[", "partition", "]", ".", "append", "(", "found_video", "[", "0", "]", ")", "\n", "\n", "# Testing set", "\n", "", "", "", "", "video_pool", "=", "os", ".", "listdir", "(", "self", ".", "test_video_path", ")", "\n", "video_to_partition_dict", "[", "'Test_Set'", "]", "=", "video_pool", "\n", "return", "video_to_partition_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.preprocessing.ABAW2_Preprocessing.generate_annotation_to_partition_dict": [[489, 513], ["os.walk", "os.listdir", "annotation_to_partition_dict.items", "root.split", "file.endswith", "annotation_to_partition_dict[].append", "os.listdir.remove", "ValueError"], "methods", ["None"], ["", "def", "generate_annotation_to_partition_dict", "(", "self", ")", ":", "\n", "        ", "annotation_to_partition_dict", "=", "{", "'Train_Set'", ":", "[", "]", ",", "'Validation_Set'", ":", "[", "]", ",", "'Test_Set'", ":", "[", "]", "}", "\n", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "self", ".", "annotation_path", ")", ":", "\n", "\n", "# exclude the hidden file .DS_Store", "\n", "\n", "            ", "partition", "=", "root", ".", "split", "(", "sep", "=", "os", ".", "sep", ")", "[", "-", "1", "]", "\n", "for", "file", "in", "files", ":", "\n", "                ", "if", "file", ".", "endswith", "(", "\".txt\"", ")", ":", "\n", "# exclude the extension", "\n", "                    ", "annotation_to_partition_dict", "[", "partition", "]", ".", "append", "(", "file", ")", "\n", "\n", "# For Test_Set:", "\n", "", "", "", "cropped_aligned_image_folder_pool", "=", "os", ".", "listdir", "(", "self", ".", "image_path", ")", "\n", "\n", "for", "partition", ",", "files", "in", "annotation_to_partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "file", "in", "files", ":", "\n", "                ", "if", "file", "[", ":", "-", "4", "]", "in", "cropped_aligned_image_folder_pool", ":", "\n", "                    ", "cropped_aligned_image_folder_pool", ".", "remove", "(", "file", "[", ":", "-", "4", "]", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Duplication found!\"", ")", "\n", "", "", "", "annotation_to_partition_dict", "[", "'Test_Set'", "]", "=", "cropped_aligned_image_folder_pool", "\n", "return", "annotation_to_partition_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.CCCLoss.__init__": [[20, 22], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.CCCLoss.forward": [[23, 38], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.var", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "gold", ",", "pred", ",", "weights", "=", "None", ")", ":", "\n", "# pred = torch.tanh(pred)", "\n", "        ", "gold_mean", "=", "torch", ".", "mean", "(", "gold", ",", "1", ",", "keepdim", "=", "True", ",", "out", "=", "None", ")", "\n", "pred_mean", "=", "torch", ".", "mean", "(", "pred", ",", "1", ",", "keepdim", "=", "True", ",", "out", "=", "None", ")", "\n", "covariance", "=", "(", "gold", "-", "gold_mean", ")", "*", "(", "pred", "-", "pred_mean", ")", "\n", "gold_var", "=", "torch", ".", "var", "(", "gold", ",", "1", ",", "keepdim", "=", "True", ",", "unbiased", "=", "True", ",", "out", "=", "None", ")", "\n", "pred_var", "=", "torch", ".", "var", "(", "pred", ",", "1", ",", "keepdim", "=", "True", ",", "unbiased", "=", "True", ",", "out", "=", "None", ")", "\n", "ccc", "=", "2.", "*", "covariance", "/", "(", "\n", "(", "gold_var", "+", "pred_var", "+", "torch", ".", "mul", "(", "gold_mean", "-", "pred_mean", ",", "gold_mean", "-", "pred_mean", ")", ")", "+", "1e-08", ")", "\n", "ccc_loss", "=", "1.", "-", "ccc", "\n", "\n", "if", "weights", "is", "not", "None", ":", "\n", "            ", "ccc_loss", "*=", "weights", "\n", "\n", "", "return", "torch", ".", "mean", "(", "ccc_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.__init__": [[41, 113], ["test.Experiment.get_train_emotion", "test.Experiment.init_device", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.get_train_emotion", "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_device"], ["    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "self", ".", "args", "=", "args", "\n", "self", ".", "experiment_name", "=", "args", ".", "experiment_name", "\n", "self", ".", "dataset_path", "=", "args", ".", "dataset_path", "\n", "self", ".", "model_load_path", "=", "args", ".", "model_load_path", "\n", "self", ".", "model_save_path", "=", "args", ".", "model_save_path", "\n", "self", ".", "resume", "=", "args", ".", "resume", "\n", "self", ".", "debug", "=", "args", ".", "debug", "\n", "self", ".", "config", "=", "config", "\n", "\n", "self", ".", "gpu", "=", "args", ".", "gpu", "\n", "self", ".", "cpu", "=", "args", ".", "cpu", "\n", "# If the code is to run on high-performance computer, which is usually not", "\n", "# available to specify gpu index and cpu threads, then set them to none.", "\n", "if", "self", ".", "args", ".", "high_performance_cluster", ":", "\n", "            ", "self", ".", "gpu", "=", "None", "\n", "self", ".", "cpu", "=", "None", "\n", "\n", "", "self", ".", "stamp", "=", "args", ".", "stamp", "\n", "\n", "self", ".", "head", "=", "\"single-headed\"", "\n", "if", "args", ".", "head", "==", "\"mh\"", ":", "\n", "            ", "self", ".", "head", "=", "\"multi-headed\"", "\n", "\n", "", "self", ".", "train_emotion", "=", "args", ".", "train_emotion", "\n", "\n", "self", ".", "emotion_dimension", "=", "self", ".", "get_train_emotion", "(", "args", ".", "train_emotion", ",", "args", ".", "head", ")", "\n", "self", ".", "modality", "=", "args", ".", "modality", "\n", "\n", "self", ".", "backbone_state_dict", "=", "args", ".", "backbone_state_dict", "\n", "self", ".", "backbone_mode", "=", "args", ".", "backbone_mode", "\n", "\n", "self", ".", "input_dim", "=", "args", ".", "input_dim", "\n", "self", ".", "cnn1d_embedding_dim", "=", "args", ".", "cnn1d_embedding_dim", "\n", "self", ".", "cnn1d_channels", "=", "args", ".", "cnn1d_channels", "\n", "self", ".", "cnn1d_kernel_size", "=", "args", ".", "cnn1d_kernel_size", "\n", "self", ".", "cnn1d_dropout", "=", "args", ".", "cnn1d_dropout", "\n", "self", ".", "cnn1d_attention", "=", "args", ".", "cnn1d_attention", "\n", "self", ".", "lstm_embedding_dim", "=", "args", ".", "lstm_embedding_dim", "\n", "self", ".", "lstm_hidden_dim", "=", "args", ".", "lstm_hidden_dim", "\n", "self", ".", "lstm_dropout", "=", "args", ".", "lstm_dropout", "\n", "\n", "self", ".", "cross_validation", "=", "args", ".", "cross_validation", "\n", "self", ".", "folds_to_run", "=", "args", ".", "folds_to_run", "\n", "if", "not", "self", ".", "cross_validation", ":", "\n", "            ", "self", ".", "folds_to_run", "=", "[", "0", "]", "\n", "\n", "", "self", ".", "milestone", "=", "args", ".", "milestone", "\n", "self", ".", "learning_rate", "=", "args", ".", "learning_rate", "\n", "self", ".", "min_learning_rate", "=", "args", ".", "min_learning_rate", "\n", "self", ".", "early_stopping", "=", "args", ".", "early_stopping", "\n", "self", ".", "patience", "=", "args", ".", "patience", "\n", "self", ".", "time_delay", "=", "args", ".", "time_delay", "\n", "self", ".", "num_epochs", "=", "args", ".", "num_epochs", "\n", "self", ".", "min_num_epochs", "=", "args", ".", "min_num_epochs", "\n", "self", ".", "factor", "=", "args", ".", "factor", "\n", "\n", "self", ".", "window_length", "=", "args", ".", "window_length", "\n", "self", ".", "hop_length", "=", "args", ".", "hop_length", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "\n", "self", ".", "metrics", "=", "args", ".", "metrics", "\n", "self", ".", "release_count", "=", "args", ".", "release_count", "\n", "self", ".", "gradual_release", "=", "args", ".", "gradual_release", "\n", "self", ".", "load_best_at_each_epoch", "=", "args", ".", "load_best_at_each_epoch", "\n", "\n", "self", ".", "save_plot", "=", "args", ".", "save_plot", "\n", "self", ".", "device", "=", "self", ".", "init_device", "(", ")", "\n", "\n", "self", ".", "model_name", "=", "self", ".", "experiment_name", "+", "\"_\"", "+", "args", ".", "model_name", "+", "\"_\"", "+", "self", ".", "modality", "[", "\n", "0", "]", "+", "\"_\"", "+", "self", ".", "train_emotion", "+", "\"_\"", "+", "args", ".", "head", "+", "\"_bs_\"", "+", "str", "(", "self", ".", "batch_size", ")", "+", "\"_lr_\"", "+", "str", "(", "\n", "self", ".", "learning_rate", ")", "+", "\"_mlr_\"", "+", "str", "(", "self", ".", "min_learning_rate", ")", "+", "\"_\"", "+", "self", ".", "stamp", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_dataloader": [[114, 129], ["base.dataset.ABAW2_VA_Arranger", "base.dataset.ABAW2_VA_Arranger.resample_according_to_window_and_hop_length", "base.dataset.ABAW2_VA_Dataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Arranger.resample_according_to_window_and_hop_length"], ["", "def", "init_dataloader", "(", "self", ",", "fold", ")", ":", "\n", "        ", "arranger", "=", "ABAW2_VA_Arranger", "(", "self", ".", "dataset_path", ",", "window_length", "=", "self", ".", "window_length", ",", "hop_length", "=", "self", ".", "hop_length", ",", "\n", "debug", "=", "self", ".", "debug", ")", "\n", "\n", "# For fold = 0, it is the original partition.", "\n", "data_dict", "=", "arranger", ".", "resample_according_to_window_and_hop_length", "(", "fold", ")", "\n", "\n", "test_dataset", "=", "ABAW2_VA_Dataset", "(", "data_dict", "[", "'Target_Set'", "]", ",", "time_delay", "=", "self", ".", "time_delay", ",", "\n", "emotion", "=", "self", ".", "train_emotion", ",", "modality", "=", "self", ".", "modality", ",", "\n", "head", "=", "self", ".", "head", ",", "mode", "=", "'test'", ",", "fold", "=", "fold", ",", "mean_std_info", "=", "arranger", ".", "mean_std_info", ")", "\n", "test_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", "=", "test_dataset", ",", "batch_size", "=", "self", ".", "batch_size", ",", "shuffle", "=", "False", ")", "\n", "\n", "dataloader_dict", "=", "{", "'test'", ":", "test_loader", "}", "\n", "return", "dataloader_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.experiment": [[130, 168], ["test.CCCLoss", "iter", "len", "os.path.join", "os.path.join", "os.path.join", "test.Experiment.init_model", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "test.Experiment.load_state_dict", "test.Experiment.parameters", "test.Experiment.init_dataloader", "base.trainer.ABAW2Trainer", "base.trainer.ABAW2Trainer.test", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_model", "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_dataloader", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.test"], ["", "def", "experiment", "(", "self", ")", ":", "\n", "\n", "        ", "criterion", "=", "CCCLoss", "(", ")", "\n", "version", "=", "\"_v3\"", "\n", "if", "len", "(", "self", ".", "modality", ")", "==", "1", ":", "\n", "            ", "model_folder", "=", "\"cv_\"", "+", "self", ".", "train_emotion", "+", "version", "\n", "output_folder", "=", "\"cv\"", "+", "version", "\n", "", "else", ":", "\n", "            ", "model_folder", "=", "\"fusion_\"", "+", "self", ".", "train_emotion", "+", "version", "\n", "output_folder", "=", "\"fusion\"", "+", "version", "\n", "\n", "", "for", "fold", "in", "iter", "(", "self", ".", "folds_to_run", ")", ":", "\n", "\n", "            ", "save_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "model_save_path", ",", "self", ".", "model_name", ",", "str", "(", "fold", ")", ")", "\n", "\n", "\n", "model_state_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "model_load_path", ",", "model_folder", ",", "str", "(", "fold", ")", ",", "\"model_state_dict.pth\"", ")", "\n", "output_save_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "model_save_path", ",", "output_folder", ",", "str", "(", "fold", ")", ")", "\n", "\n", "model", "=", "self", ".", "init_model", "(", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "model_state_path", ",", "map_location", "=", "'cpu'", ")", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "for", "parameter", "in", "model", ".", "parameters", "(", ")", ":", "\n", "                ", "parameter", ".", "requires_grad", "=", "False", "\n", "\n", "", "dataloader_dict", "=", "self", ".", "init_dataloader", "(", "fold", ")", "\n", "\n", "\n", "trainer", "=", "ABAW2Trainer", "(", "model", ",", "model_name", "=", "self", ".", "model_name", ",", "learning_rate", "=", "self", ".", "learning_rate", ",", "\n", "min_learning_rate", "=", "self", ".", "min_learning_rate", ",", "\n", "metrics", "=", "self", ".", "metrics", ",", "save_path", "=", "save_path", ",", "early_stopping", "=", "self", ".", "early_stopping", ",", "\n", "train_emotion", "=", "self", ".", "train_emotion", ",", "patience", "=", "self", ".", "patience", ",", "factor", "=", "self", ".", "factor", ",", "\n", "emotional_dimension", "=", "self", ".", "emotion_dimension", ",", "head", "=", "self", ".", "head", ",", "max_epoch", "=", "self", ".", "num_epochs", ",", "\n", "load_best_at_each_epoch", "=", "self", ".", "load_best_at_each_epoch", ",", "window_length", "=", "self", ".", "window_length", ",", "\n", "milestone", "=", "self", ".", "milestone", ",", "criterion", "=", "criterion", ",", "verbose", "=", "True", ",", "save_plot", "=", "self", ".", "save_plot", ",", "\n", "fold", "=", "fold", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "trainer", ".", "test", "(", "dataloader_dict", "[", "'test'", "]", ",", "output_save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_model": [[169, 190], ["model.model.my_2d1d.model.my_2d1d.init", "len", "model.model.my_2d1d.model.my_2d1ddy", "model.model.my_2d1d.model.my_2d1d"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2dlstm.init"], ["", "", "def", "init_model", "(", "self", ")", ":", "\n", "\n", "\n", "        ", "if", "self", ".", "head", "==", "\"multi-headed\"", ":", "\n", "            ", "output_dim", "=", "2", "\n", "", "else", ":", "\n", "            ", "output_dim", "=", "1", "\n", "\n", "", "if", "len", "(", "self", ".", "modality", ")", ">", "1", ":", "\n", "            ", "model", "=", "my_2d1ddy", "(", "backbone_state_dict", "=", "self", ".", "backbone_state_dict", ",", "backbone_mode", "=", "self", ".", "backbone_mode", ",", "\n", "embedding_dim", "=", "self", ".", "cnn1d_embedding_dim", ",", "channels", "=", "self", ".", "cnn1d_channels", ",", "modality", "=", "self", ".", "modality", ",", "\n", "output_dim", "=", "output_dim", ",", "kernel_size", "=", "self", ".", "cnn1d_kernel_size", ",", "attention", "=", "self", ".", "cnn1d_attention", ",", "\n", "dropout", "=", "self", ".", "cnn1d_dropout", ",", "root_dir", "=", "self", ".", "model_load_path", ")", "\n", "", "else", ":", "\n", "            ", "model", "=", "my_2d1d", "(", "backbone_state_dict", "=", "self", ".", "backbone_state_dict", ",", "backbone_mode", "=", "self", ".", "backbone_mode", ",", "\n", "embedding_dim", "=", "self", ".", "cnn1d_embedding_dim", ",", "channels", "=", "self", ".", "cnn1d_channels", ",", "modality", "=", "self", ".", "modality", ",", "\n", "output_dim", "=", "output_dim", ",", "kernel_size", "=", "self", ".", "cnn1d_kernel_size", ",", "attention", "=", "self", ".", "cnn1d_attention", ",", "\n", "dropout", "=", "self", ".", "cnn1d_dropout", ",", "root_dir", "=", "self", ".", "model_load_path", ")", "\n", "", "model", ".", "init", "(", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.get_train_emotion": [[191, 204], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_train_emotion", "(", "emotion_tag", ",", "head", ")", ":", "\n", "\n", "        ", "emotion", "=", "[", "\"Valence\"", ",", "\"Arousal\"", "]", "\n", "\n", "if", "emotion_tag", "==", "\"arousal\"", ":", "\n", "            ", "if", "head", "==", "\"sh\"", ":", "\n", "                ", "emotion", "=", "[", "\"Arousal\"", "]", "\n", "", "", "elif", "emotion_tag", "==", "\"valence\"", ":", "\n", "            ", "if", "head", "==", "\"sh\"", ":", "\n", "                ", "emotion", "=", "[", "\"Valence\"", "]", "\n", "\n", "", "", "return", "emotion", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_random_seed": [[205, 212], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "init_random_seed", "(", ")", ":", "\n", "        ", "random", ".", "seed", "(", "0", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "0", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.None.test.Experiment.init_device": [[213, 221], ["base.utils.detect_device", "base.utils.select_gpu", "base.utils.set_cpu_thread"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.detect_device", "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.select_gpu", "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.set_cpu_thread"], ["", "def", "init_device", "(", "self", ")", ":", "\n", "        ", "device", "=", "detect_device", "(", ")", "\n", "\n", "if", "not", "self", ".", "args", ".", "high_performance_cluster", ":", "\n", "            ", "select_gpu", "(", "self", ".", "gpu", ")", "\n", "set_cpu_thread", "(", "self", ".", "cpu", ")", "\n", "\n", "", "return", "device", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.Chomp1d.__init__": [[13, 16], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "chomp_size", ")", ":", "\n", "        ", "super", "(", "Chomp1d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "chomp_size", "=", "chomp_size", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.Chomp1d.forward": [[17, 19], ["x[].contiguous"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "[", ":", ",", ":", ",", ":", "-", "self", ".", "chomp_size", "]", ".", "contiguous", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.TemporalBlock.__init__": [[22, 41], ["torch.Module.__init__", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "temporal_convolutional_model.Chomp1d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Dropout2d", "torch.Dropout2d", "torch.Dropout2d", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "temporal_convolutional_model.Chomp1d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Dropout2d", "torch.Dropout2d", "torch.Dropout2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "temporal_convolutional_model.TemporalBlock.init_weights", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__", "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.TemporalBlock.init_weights"], ["    ", "def", "__init__", "(", "self", ",", "n_inputs", ",", "n_outputs", ",", "kernel_size", ",", "stride", ",", "dilation", ",", "padding", ",", "dropout", "=", "0.2", ")", ":", "\n", "        ", "super", "(", "TemporalBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "weight_norm", "(", "nn", ".", "Conv1d", "(", "n_inputs", ",", "n_outputs", ",", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "dilation", "=", "dilation", ")", ")", "\n", "self", ".", "chomp1", "=", "Chomp1d", "(", "padding", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "LeakyReLU", "(", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout2d", "(", "dropout", ")", "\n", "\n", "self", ".", "conv2", "=", "weight_norm", "(", "nn", ".", "Conv1d", "(", "n_outputs", ",", "n_outputs", ",", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "dilation", "=", "dilation", ")", ")", "\n", "self", ".", "chomp2", "=", "Chomp1d", "(", "padding", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "LeakyReLU", "(", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout2d", "(", "dropout", ")", "\n", "\n", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "self", ".", "conv1", ",", "self", ".", "chomp1", ",", "self", ".", "relu1", ",", "self", ".", "dropout1", ",", "\n", "self", ".", "conv2", ",", "self", ".", "chomp2", ",", "self", ".", "relu2", ",", "self", ".", "dropout2", ")", "\n", "self", ".", "downsample", "=", "nn", ".", "Conv1d", "(", "n_inputs", ",", "n_outputs", ",", "1", ")", "if", "n_inputs", "!=", "n_outputs", "else", "None", "\n", "self", ".", "relu", "=", "nn", ".", "LeakyReLU", "(", ")", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.TemporalBlock.init_weights": [[42, 50], ["torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "torch.init.xavier_uniform", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["None"], ["", "def", "init_weights", "(", "self", ")", ":", "\n", "# self.conv1.weight.data.normal_(0, 0.01)", "\n", "        ", "nn", ".", "init", ".", "xavier_uniform", "(", "self", ".", "conv1", ".", "weight", ",", "gain", "=", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "# self.conv2.weight.data.normal_(0, 0.01)", "\n", "nn", ".", "init", ".", "xavier_uniform", "(", "self", ".", "conv2", ".", "weight", ",", "gain", "=", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "# self.downsample.weight.data.normal_(0, 0.01)", "\n", "            ", "nn", ".", "init", ".", "xavier_uniform", "(", "self", ".", "downsample", ".", "weight", ",", "gain", "=", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.TemporalBlock.forward": [[51, 55], ["temporal_convolutional_model.TemporalBlock.net", "temporal_convolutional_model.TemporalBlock.relu", "temporal_convolutional_model.TemporalBlock.downsample"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "net", "=", "self", ".", "net", "(", "x", ")", "\n", "res", "=", "x", "if", "self", ".", "downsample", "is", "None", "else", "self", ".", "downsample", "(", "x", ")", "\n", "return", "self", ".", "relu", "(", "net", "+", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.TemporalConvNet.__init__": [[58, 72], ["torch.Module.__init__", "len", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "temporal_convolutional_model.TemporalBlock", "temporal_convolutional_model.AttentionBlock"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_inputs", ",", "num_channels", ",", "kernel_size", "=", "2", ",", "dropout", "=", "0.2", ",", "max_length", "=", "200", ",", "attention", "=", "0", ")", ":", "\n", "        ", "super", "(", "TemporalConvNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "layers", "=", "[", "]", "\n", "num_levels", "=", "len", "(", "num_channels", ")", "\n", "for", "i", "in", "range", "(", "num_levels", ")", ":", "\n", "            ", "dilation_size", "=", "2", "**", "i", "\n", "in_channels", "=", "num_inputs", "if", "i", "==", "0", "else", "num_channels", "[", "i", "-", "1", "]", "\n", "out_channels", "=", "num_channels", "[", "i", "]", "\n", "layers", "+=", "[", "TemporalBlock", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", "=", "1", ",", "dilation", "=", "dilation_size", ",", "\n", "padding", "=", "(", "kernel_size", "-", "1", ")", "*", "dilation_size", ",", "dropout", "=", "dropout", ")", "]", "\n", "if", "attention", "==", "1", ":", "\n", "                ", "layers", "+=", "[", "AttentionBlock", "(", "max_length", ",", "max_length", ",", "max_length", ")", "]", "\n", "\n", "", "", "self", ".", "network", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.TemporalConvNet.forward": [[73, 75], ["temporal_convolutional_model.TemporalConvNet.network"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "network", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.AttentionBlock.__init__": [[92, 98], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "math.sqrt"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["def", "__init__", "(", "self", ",", "dims", ",", "k_size", ",", "v_size", ",", "seq_len", "=", "None", ")", ":", "\n", "        ", "super", "(", "AttentionBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "key_layer", "=", "nn", ".", "Linear", "(", "dims", ",", "k_size", ")", "\n", "self", ".", "query_layer", "=", "nn", ".", "Linear", "(", "dims", ",", "k_size", ")", "\n", "self", ".", "value_layer", "=", "nn", ".", "Linear", "(", "dims", ",", "v_size", ")", "\n", "self", ".", "sqrt_k", "=", "math", ".", "sqrt", "(", "k_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.temporal_convolutional_model.AttentionBlock.forward": [[99, 115], ["temporal_convolutional_model.AttentionBlock.key_layer", "temporal_convolutional_model.AttentionBlock.query_layer", "temporal_convolutional_model.AttentionBlock.value_layer", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "numpy.triu().astype", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.bmm.data.masked_fill_", "torch.bmm.data.masked_fill_", "torch.bmm.data.masked_fill_", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "temporal_convolutional_model.AttentionBlock.transpose", "float", "torch.softmax", "torch.softmax", "torch.softmax", "numpy.triu", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.ones", "torch.bmm.size", "torch.bmm.size", "torch.bmm.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "minibatch", ")", ":", "\n", "        ", "keys", "=", "self", ".", "key_layer", "(", "minibatch", ")", "\n", "queries", "=", "self", ".", "query_layer", "(", "minibatch", ")", "\n", "values", "=", "self", ".", "value_layer", "(", "minibatch", ")", "\n", "logits", "=", "torch", ".", "bmm", "(", "queries", ",", "keys", ".", "transpose", "(", "2", ",", "1", ")", ")", "\n", "# Use numpy triu because you can't do 3D triu with PyTorch", "\n", "# TODO: using float32 here might break for non FloatTensor inputs.", "\n", "# Should update this later to use numpy/PyTorch types of the input.", "\n", "mask", "=", "np", ".", "triu", "(", "np", ".", "ones", "(", "logits", ".", "size", "(", ")", ")", ",", "k", "=", "1", ")", ".", "astype", "(", "'uint8'", ")", "\n", "mask", "=", "torch", ".", "from_numpy", "(", "mask", ")", ".", "cuda", "(", ")", "\n", "# do masked_fill_ on data rather than Variable because PyTorch doesn't", "\n", "# support masked_fill_ w/-inf directly on Variables for some reason.", "\n", "logits", ".", "data", ".", "masked_fill_", "(", "mask", ",", "float", "(", "'-inf'", ")", ")", "\n", "probs", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "1", ")", "/", "self", ".", "sqrt_k", "\n", "read", "=", "torch", ".", "bmm", "(", "probs", ",", "values", ")", "\n", "return", "minibatch", "+", "read", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.Flatten.forward": [[12, 14], ["input.view", "input.size"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", ".", "view", "(", "input", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_res50.__init__": [[17, 54], ["torch.nn.Module.__init__", "model.arcface_model.Backbone", "torch.nn.Sequential", "torch.nn.Linear", "os.path.join", "torch.load", "model.my_res50.backbone.parameters", "torch.nn.BatchNorm2d", "torch.nn.Dropout", "model.Flatten", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.Sequential", "torch.load.items", "model.my_res50.backbone.load_state_dict", "model.my_res50.backbone.load_state_dict", "list", "torch.nn.BatchNorm2d", "torch.nn.Dropout", "model.Flatten", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.load.keys"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_channels", "=", "3", ",", "num_classes", "=", "8", ",", "use_pretrained", "=", "True", ",", "state_dict_name", "=", "''", ",", "root_dir", "=", "''", ",", "mode", "=", "\"ir\"", ",", "\n", "embedding_dim", "=", "512", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "backbone", "=", "Backbone", "(", "input_channels", "=", "input_channels", ",", "num_layers", "=", "50", ",", "drop_ratio", "=", "0.4", ",", "mode", "=", "mode", ")", "\n", "if", "use_pretrained", ":", "\n", "            ", "path", "=", "os", ".", "path", ".", "join", "(", "root_dir", ",", "state_dict_name", "+", "\".pth\"", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "if", "\"backbone\"", "in", "list", "(", "state_dict", ".", "keys", "(", ")", ")", "[", "0", "]", ":", "\n", "\n", "                ", "self", ".", "backbone", ".", "output_layer", "=", "Sequential", "(", "BatchNorm2d", "(", "embedding_dim", ")", ",", "\n", "Dropout", "(", "0.4", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Linear", "(", "embedding_dim", "*", "5", "*", "5", ",", "embedding_dim", ")", ",", "\n", "BatchNorm1d", "(", "embedding_dim", ")", ")", "\n", "\n", "new_state_dict", "=", "{", "}", "\n", "for", "key", ",", "value", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "\n", "                    ", "if", "\"logits\"", "not", "in", "key", ":", "\n", "                        ", "new_key", "=", "key", "[", "9", ":", "]", "\n", "new_state_dict", "[", "new_key", "]", "=", "value", "\n", "\n", "", "", "self", ".", "backbone", ".", "load_state_dict", "(", "new_state_dict", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "backbone", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n", "", "for", "param", "in", "self", ".", "backbone", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "", "self", ".", "backbone", ".", "output_layer", "=", "Sequential", "(", "BatchNorm2d", "(", "embedding_dim", ")", ",", "\n", "Dropout", "(", "0.4", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Linear", "(", "embedding_dim", "*", "5", "*", "5", ",", "embedding_dim", ")", ",", "\n", "BatchNorm1d", "(", "embedding_dim", ")", ")", "\n", "\n", "self", ".", "logits", "=", "nn", ".", "Linear", "(", "in_features", "=", "embedding_dim", ",", "out_features", "=", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_res50.forward": [[55, 59], ["model.my_res50.backbone", "model.my_res50.logits"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "backbone", "(", "x", ")", "\n", "x", "=", "self", ".", "logits", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2d1d.__init__": [[62, 77], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "backbone_state_dict", ",", "backbone_mode", "=", "\"ir\"", ",", "modality", "=", "[", "'frame'", "]", ",", "embedding_dim", "=", "512", ",", "channels", "=", "None", ",", "attention", "=", "0", ",", "\n", "output_dim", "=", "1", ",", "kernel_size", "=", "5", ",", "dropout", "=", "0.1", ",", "root_dir", "=", "''", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "modality", "=", "modality", "\n", "self", ".", "backbone_state_dict", "=", "backbone_state_dict", "\n", "self", ".", "backbone_mode", "=", "backbone_mode", "\n", "self", ".", "root_dir", "=", "root_dir", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "attention", "=", "attention", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2d1d.init": [[78, 106], ["os.path.join", "my_res50.parameters", "model.temporal_convolutional_model.TemporalConvNet", "torch.nn.Linear", "model.my_res50", "torch.load", "my_res50.load_state_dict", "model.my_res50", "torch.load", "my_res50.load_state_dict", "ValueError", "os.path.join", "str"], "methods", ["None"], ["", "def", "init", "(", "self", ",", "fold", "=", "None", ")", ":", "\n", "        ", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root_dir", ",", "self", ".", "backbone_state_dict", "+", "\".pth\"", ")", "\n", "\n", "if", "'frame'", "in", "self", ".", "modality", ":", "\n", "            ", "spatial", "=", "my_res50", "(", "mode", "=", "self", ".", "backbone_mode", ",", "root_dir", "=", "self", ".", "root_dir", ",", "use_pretrained", "=", "False", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "'cpu'", ")", "\n", "spatial", ".", "load_state_dict", "(", "state_dict", ")", "\n", "", "elif", "'eeg_image'", "in", "self", ".", "modality", ":", "\n", "            ", "spatial", "=", "my_res50", "(", "mode", "=", "self", ".", "backbone_mode", ",", "root_dir", "=", "self", ".", "root_dir", ",", "use_pretrained", "=", "False", ",", "num_classes", "=", "3", ",", "\n", "input_channels", "=", "6", ")", "\n", "\n", "if", "fold", "is", "not", "None", ":", "\n", "                ", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root_dir", ",", "self", ".", "backbone_state_dict", "+", "\"_\"", "+", "str", "(", "fold", ")", "+", "\".pth\"", ")", "\n", "\n", "", "state_dict", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "spatial", ".", "load_state_dict", "(", "state_dict", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unsupported modality!\"", ")", "\n", "\n", "", "for", "param", "in", "spatial", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "spatial", "=", "spatial", ".", "backbone", "\n", "self", ".", "temporal", "=", "TemporalConvNet", "(", "\n", "num_inputs", "=", "self", ".", "embedding_dim", ",", "num_channels", "=", "self", ".", "channels", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "attention", "=", "self", ".", "attention", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "self", ".", "regressor", "=", "nn", ".", "Linear", "(", "self", ".", "embedding_dim", "//", "4", ",", "self", ".", "output_dim", ")", "\n", "# self.regressor = Sequential(", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2d1d.forward": [[111, 122], ["x.view.view.view", "model.my_2d1d.spatial", "x.view.view.view().transpose().contiguous", "model.my_2d1d.temporal().transpose().contiguous", "x.view.view.contiguous().view", "model.my_2d1d.regressor", "x.view.view.view", "x.view.view.view().transpose", "model.my_2d1d.temporal().transpose", "x.view.view.contiguous", "x.view.view.view", "model.my_2d1d.temporal"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "num_batches", ",", "length", ",", "channel", ",", "width", ",", "height", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "channel", ",", "width", ",", "height", ")", "\n", "x", "=", "self", ".", "spatial", "(", "x", ")", "\n", "_", ",", "feature_dim", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "num_batches", ",", "length", ",", "feature_dim", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "self", ".", "temporal", "(", "x", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "regressor", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "num_batches", ",", "length", ",", "-", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2d1ddy.__init__": [[125, 141], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "backbone_state_dict", ",", "backbone_mode", "=", "\"ir\"", ",", "modality", "=", "[", "'frame'", "]", ",", "embedding_dim", "=", "512", ",", "channels", "=", "None", ",", "attention", "=", "0", ",", "\n", "output_dim", "=", "1", ",", "kernel_size", "=", "5", ",", "dropout", "=", "0.1", ",", "root_dir", "=", "''", ",", "input_dim_other", "=", "[", "128", ",", "39", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "modality", "=", "modality", "\n", "self", ".", "backbone_state_dict", "=", "backbone_state_dict", "\n", "self", ".", "backbone_mode", "=", "backbone_mode", "\n", "self", ".", "root_dir", "=", "root_dir", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "channels", "=", "channels", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "attention", "=", "attention", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "other_feature_dim", "=", "input_dim_other", "# input dimension of other modalities", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2d1ddy.init": [[142, 194], ["os.path.join", "model.my_res50", "torch.load", "my_res50.load_state_dict", "my_res50.parameters", "model.temporal_convolutional_model.TemporalConvNet", "model.temporal_convolutional_model.TemporalConvNet", "model.temporal_convolutional_model.TemporalConvNet", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.GroupNorm", "torch.nn.GroupNorm", "torch.nn.LayerNorm", "torch.nn.Linear"], "methods", ["None"], ["", "def", "init", "(", "self", ",", "fold", "=", "None", ")", ":", "\n", "        ", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root_dir", ",", "self", ".", "backbone_state_dict", "+", "\".pth\"", ")", "\n", "\n", "spatial", "=", "my_res50", "(", "mode", "=", "self", ".", "backbone_mode", ",", "root_dir", "=", "self", ".", "root_dir", ",", "use_pretrained", "=", "False", ")", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "'cpu'", ")", "\n", "spatial", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n", "for", "param", "in", "spatial", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "spatial", "=", "spatial", ".", "backbone", "\n", "self", ".", "temporal", "=", "TemporalConvNet", "(", "\n", "num_inputs", "=", "self", ".", "embedding_dim", ",", "num_channels", "=", "self", ".", "channels", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "attention", "=", "self", ".", "attention", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "\n", "self", ".", "temporal1", "=", "TemporalConvNet", "(", "\n", "num_inputs", "=", "self", ".", "other_feature_dim", "[", "0", "]", ",", "num_channels", "=", "[", "32", ",", "32", ",", "32", ",", "32", "]", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "attention", "=", "self", ".", "attention", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "self", ".", "temporal2", "=", "TemporalConvNet", "(", "\n", "num_inputs", "=", "self", ".", "other_feature_dim", "[", "1", "]", ",", "num_channels", "=", "[", "32", ",", "32", ",", "32", ",", "32", "]", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "attention", "=", "self", ".", "attention", ",", "\n", "dropout", "=", "self", ".", "dropout", ")", "\n", "'''\n        self.temporal3 = TemporalConvNet(\n            num_inputs=self.other_feature_dim[2], num_channels=[32, 32, 32, 32], kernel_size=self.kernel_size,\n            attention=self.attention,\n            dropout=self.dropout)\n        self.temporal4 = TemporalConvNet(\n            num_inputs=self.other_feature_dim[3], num_channels=[32, 32, 32, 32], kernel_size=self.kernel_size,\n            attention=self.attention,\n            dropout=self.dropout)\n        '''", "\n", "\n", "self", ".", "encoder1", "=", "nn", ".", "Linear", "(", "self", ".", "embedding_dim", "//", "4", ",", "32", ")", "\n", "self", ".", "encoder2", "=", "nn", ".", "Linear", "(", "self", ".", "other_feature_dim", "[", "0", "]", "//", "4", ",", "32", ")", "\n", "self", ".", "encoder3", "=", "nn", ".", "Linear", "(", "32", ",", "32", ")", "\n", "\n", "self", ".", "encoderQ1", "=", "nn", ".", "Linear", "(", "self", ".", "embedding_dim", "//", "4", ",", "32", ")", "\n", "self", ".", "encoderQ2", "=", "nn", ".", "Linear", "(", "self", ".", "other_feature_dim", "[", "0", "]", "//", "4", ",", "32", ")", "\n", "self", ".", "encoderQ3", "=", "nn", ".", "Linear", "(", "32", ",", "32", ")", "\n", "\n", "self", ".", "encoderV1", "=", "nn", ".", "Linear", "(", "self", ".", "embedding_dim", "//", "4", ",", "32", ")", "\n", "self", ".", "encoderV2", "=", "nn", ".", "Linear", "(", "self", ".", "other_feature_dim", "[", "0", "]", "//", "4", ",", "32", ")", "\n", "self", ".", "encoderV3", "=", "nn", ".", "Linear", "(", "32", ",", "32", ")", "\n", "#self.encoder4 = nn.Linear(self.other_feature_dim[3] // 4, 32)", "\n", "self", ".", "gn1", "=", "nn", ".", "GroupNorm", "(", "8", ",", "32", ")", "\n", "self", ".", "gn2", "=", "nn", ".", "GroupNorm", "(", "8", ",", "32", ")", "\n", "\n", "self", ".", "ln", "=", "nn", ".", "LayerNorm", "(", "[", "3", ",", "32", "]", ")", "\n", "\n", "self", ".", "regressor", "=", "nn", ".", "Linear", "(", "224", ",", "self", ".", "output_dim", ")", "\n", "# self.regressor = Sequential(", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2d1ddy.forward": [[199, 256], ["x.view.view.view", "model.my_2d1ddy.spatial", "x.view.view.view().transpose().contiguous", "model.my_2d1ddy.temporal().transpose().contiguous", "x.view.view.contiguous().view", "model.my_2d1ddy.temporal1().transpose().contiguous", "model.my_2d1ddy.temporal2().transpose().contiguous", "model.my_2d1ddy.encoder1", "model.my_2d1ddy.encoder2", "model.my_2d1ddy.encoder3", "model.my_2d1ddy.encoderQ1", "model.my_2d1ddy.encoderQ2", "model.my_2d1ddy.encoderQ3", "model.my_2d1ddy.encoderV1", "model.my_2d1ddy.encoderV2", "model.my_2d1ddy.encoderV3", "torch.stack", "torch.stack", "torch.stack", "torch.stack.permute", "torch.nn.functional.softmax", "torch.matmul", "model.my_2d1ddy.ln", "out.view.view.view", "torch.cat", "model.my_2d1ddy.regressor", "x.view.view.view", "[].transpose().contiguous().float.squeeze().transpose().contiguous().float", "[].transpose().contiguous().float.squeeze().transpose().contiguous().float", "[].transpose().contiguous().float", "[].transpose().contiguous().float", "[].transpose().contiguous().float.contiguous().view", "[].transpose().contiguous().float.contiguous().view", "[].transpose().contiguous().float.contiguous().view", "[].transpose().contiguous().float.contiguous().view", "[].transpose().contiguous().float.contiguous().view", "[].transpose().contiguous().float.contiguous().view", "torch.matmul", "math.sqrt", "x.view.view.view().transpose", "model.my_2d1ddy.temporal().transpose", "x.view.view.contiguous", "len", "len", "model.my_2d1ddy.temporal1().transpose", "model.my_2d1ddy.temporal2().transpose", "out.view.view.size", "[].transpose().contiguous().float.squeeze().transpose().contiguous", "[].transpose().contiguous().float.squeeze().transpose().contiguous", "[].transpose().contiguous", "[].transpose().contiguous", "[].transpose().contiguous().float.contiguous", "[].transpose().contiguous().float.contiguous", "[].transpose().contiguous().float.contiguous", "[].transpose().contiguous().float.contiguous", "[].transpose().contiguous().float.contiguous", "[].transpose().contiguous().float.contiguous", "x.view.view.view", "model.my_2d1ddy.temporal", "model.my_2d1ddy.temporal1", "model.my_2d1ddy.temporal2", "[].transpose().contiguous().float.squeeze().transpose", "[].transpose().contiguous().float.squeeze().transpose", "[].transpose", "[].transpose", "[].transpose().contiguous().float.squeeze", "[].transpose().contiguous().float.squeeze", "[].transpose().contiguous().float.squeeze", "[].transpose().contiguous().float.squeeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "num_batches", ",", "length", ",", "channel", ",", "width", ",", "height", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "channel", ",", "width", ",", "height", ")", "\n", "x", "=", "self", ".", "spatial", "(", "x", ")", "\n", "_", ",", "feature_dim", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "num_batches", ",", "length", ",", "feature_dim", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "self", ".", "temporal", "(", "x", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", "\n", "\n", "if", "len", "(", "x1", ")", ">", "1", "and", "len", "(", "x2", ")", ">", "1", ":", "\n", "            ", "x1", "=", "x1", ".", "squeeze", "(", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "float", "(", ")", "\n", "x2", "=", "x2", ".", "squeeze", "(", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "            ", "x1", "=", "x1", ".", "squeeze", "(", ")", "[", "None", ",", ":", ",", ":", "]", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "float", "(", ")", "\n", "x2", "=", "x2", ".", "squeeze", "(", ")", "[", "None", ",", ":", ",", ":", "]", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "float", "(", ")", "\n", "#x3 = x3.transpose(1, 2).contiguous().float()", "\n", "#x4 = x4.transpose(1, 2).contiguous().float()", "\n", "\n", "", "x1", "=", "self", ".", "temporal1", "(", "x1", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x2", "=", "self", ".", "temporal2", "(", "x2", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "#x3 = self.temporal3(x3).transpose(1, 2).contiguous()", "\n", "#x4 = self.temporal4(x4).transpose(1, 2).contiguous()", "\n", "\n", "x0", "=", "self", ".", "encoder1", "(", "x", ")", "\n", "x1", "=", "self", ".", "encoder2", "(", "x1", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", ")", "\n", "x2", "=", "self", ".", "encoder3", "(", "x2", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", ")", "\n", "\n", "xq0", "=", "self", ".", "encoderQ1", "(", "x", ")", "\n", "xq1", "=", "self", ".", "encoderQ2", "(", "x1", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", ")", "\n", "xq2", "=", "self", ".", "encoderQ3", "(", "x2", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", ")", "\n", "\n", "xv0", "=", "self", ".", "encoderV1", "(", "x", ")", "\n", "xv1", "=", "self", ".", "encoderV2", "(", "x1", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", ")", "\n", "xv2", "=", "self", ".", "encoderV3", "(", "x2", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", ")", "\n", "#x3 = x3.contiguous().view(num_batches * length, -1)", "\n", "#x4 = x4.contiguous().view(num_batches * length, -1)", "\n", "\n", "x_K", "=", "torch", ".", "stack", "(", "(", "x0", ",", "x1", ",", "x2", ")", ",", "dim", "=", "-", "2", ")", "\n", "x_Q", "=", "torch", ".", "stack", "(", "(", "xq0", ",", "xq1", ",", "xq2", ")", ",", "dim", "=", "-", "2", ")", "\n", "x_V", "=", "torch", ".", "stack", "(", "(", "xv0", ",", "xv1", ",", "xv2", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "x_QT", "=", "x_Q", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "\n", "scores", "=", "torch", ".", "matmul", "(", "x_K", ",", "x_QT", ")", "/", "math", ".", "sqrt", "(", "32", ")", "\n", "\n", "scores", "=", "nn", ".", "functional", ".", "softmax", "(", "scores", ",", "dim", "=", "-", "1", ")", "\n", "\n", "out", "=", "torch", ".", "matmul", "(", "scores", ",", "x_V", ")", "\n", "\n", "out", "=", "self", ".", "ln", "(", "out", "+", "x_V", ")", "\n", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", ")", "[", "0", "]", ",", "-", "1", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "out", ")", ",", "dim", "=", "-", "1", ")", "\n", "x", "=", "self", ".", "regressor", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "num_batches", ",", "length", ",", "-", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2dlstm.__init__": [[259, 272], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "backbone_state_dict", ",", "backbone_mode", "=", "\"ir\"", ",", "modality", "=", "'frame'", ",", "embedding_dim", "=", "512", ",", "hidden_dim", "=", "256", ",", "\n", "output_dim", "=", "1", ",", "dropout", "=", "0.5", ",", "root_dir", "=", "''", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "modality", "=", "modality", "\n", "self", ".", "backbone_state_dict", "=", "backbone_state_dict", "\n", "self", ".", "backbone_mode", "=", "backbone_mode", "\n", "self", ".", "root_dir", "=", "root_dir", "\n", "\n", "self", ".", "embedding_dim", "=", "embedding_dim", "\n", "self", ".", "hidden_dim", "=", "hidden_dim", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2dlstm.init": [[273, 302], ["os.path.join", "my_res50.parameters", "torch.nn.LSTM", "torch.nn.Linear", "model.my_res50", "torch.load", "my_res50.load_state_dict", "model.my_res50", "torch.load", "my_res50.load_state_dict", "ValueError", "os.path.join", "str"], "methods", ["None"], ["", "def", "init", "(", "self", ",", "fold", "=", "None", ")", ":", "\n", "        ", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root_dir", ",", "self", ".", "backbone_state_dict", "+", "\".pth\"", ")", "\n", "\n", "if", "'frame'", "in", "self", ".", "modality", ":", "\n", "            ", "spatial", "=", "my_res50", "(", "mode", "=", "self", ".", "backbone_mode", ",", "root_dir", "=", "self", ".", "root_dir", ",", "use_pretrained", "=", "False", ")", "\n", "\n", "state_dict", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "spatial", ".", "load_state_dict", "(", "state_dict", ")", "\n", "", "elif", "'eeg_image'", "in", "self", ".", "modality", ":", "\n", "            ", "spatial", "=", "my_res50", "(", "mode", "=", "self", ".", "backbone_mode", ",", "root_dir", "=", "self", ".", "root_dir", ",", "use_pretrained", "=", "False", ",", "num_classes", "=", "3", ",", "\n", "input_channels", "=", "6", ")", "\n", "\n", "if", "fold", "is", "not", "None", ":", "\n", "                ", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root_dir", ",", "self", ".", "backbone_state_dict", "+", "\"_\"", "+", "str", "(", "fold", ")", "+", "\".pth\"", ")", "\n", "\n", "", "state_dict", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "'cpu'", ")", "\n", "\n", "spatial", ".", "load_state_dict", "(", "state_dict", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unsupported modality!\"", ")", "\n", "\n", "", "for", "param", "in", "spatial", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n", "", "self", ".", "spatial", "=", "spatial", ".", "backbone", "\n", "self", ".", "temporal", "=", "nn", ".", "LSTM", "(", "input_size", "=", "self", ".", "embedding_dim", ",", "hidden_size", "=", "self", ".", "hidden_dim", ",", "num_layers", "=", "2", ",", "\n", "batch_first", "=", "True", ",", "bidirectional", "=", "True", ",", "dropout", "=", "self", ".", "dropout", ")", "\n", "self", ".", "regressor", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_dim", "*", "2", ",", "self", ".", "output_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_2dlstm.forward": [[303, 314], ["x.view.view.view", "model.my_2dlstm.spatial", "x.view.view.view().contiguous", "model.my_2dlstm.temporal", "x.view.view.contiguous().view", "model.my_2dlstm.regressor", "x.view.view.view", "x.view.view.view", "x.view.view.contiguous"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "num_batches", ",", "length", ",", "channel", ",", "width", ",", "height", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "channel", ",", "width", ",", "height", ")", "\n", "x", "=", "self", ".", "spatial", "(", "x", ")", "\n", "_", ",", "feature_dim", "=", "x", ".", "shape", "\n", "x", "=", "x", ".", "view", "(", "num_batches", ",", "length", ",", "feature_dim", ")", ".", "contiguous", "(", ")", "\n", "x", ",", "_", "=", "self", ".", "temporal", "(", "x", ")", "\n", "x", "=", "x", ".", "contiguous", "(", ")", ".", "view", "(", "num_batches", "*", "length", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "regressor", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "num_batches", ",", "length", ",", "-", "1", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_temporal.__init__": [[317, 335], ["torch.nn.Module.__init__", "model.temporal_convolutional_model.TemporalConvNet", "torch.nn.Linear", "torch.nn.LSTM", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "model_name", ",", "num_inputs", "=", "192", ",", "cnn1d_channels", "=", "[", "128", ",", "128", ",", "128", "]", ",", "cnn1d_kernel_size", "=", "5", ",", "cnn1d_dropout_rate", "=", "0.1", ",", "\n", "embedding_dim", "=", "256", ",", "hidden_dim", "=", "128", ",", "lstm_dropout_rate", "=", "0.5", ",", "bidirectional", "=", "True", ",", "output_dim", "=", "1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "model_name", "=", "model_name", "\n", "if", "\"1d\"", "in", "model_name", ":", "\n", "            ", "self", ".", "temporal", "=", "TemporalConvNet", "(", "num_inputs", "=", "num_inputs", ",", "num_channels", "=", "cnn1d_channels", ",", "\n", "kernel_size", "=", "cnn1d_kernel_size", ",", "dropout", "=", "cnn1d_dropout_rate", ")", "\n", "self", ".", "regressor", "=", "nn", ".", "Linear", "(", "cnn1d_channels", "[", "-", "1", "]", ",", "output_dim", ")", "\n", "\n", "", "elif", "\"lstm\"", "in", "model_name", ":", "\n", "            ", "self", ".", "temporal", "=", "nn", ".", "LSTM", "(", "input_size", "=", "num_inputs", ",", "hidden_size", "=", "hidden_dim", ",", "num_layers", "=", "2", ",", "\n", "batch_first", "=", "True", ",", "bidirectional", "=", "bidirectional", ",", "dropout", "=", "lstm_dropout_rate", ")", "\n", "input_dim", "=", "hidden_dim", "\n", "if", "bidirectional", ":", "\n", "                ", "input_dim", "=", "hidden_dim", "*", "2", "\n", "\n", "", "self", ".", "regressor", "=", "nn", ".", "Linear", "(", "input_dim", ",", "output_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.model.my_temporal.forward": [[337, 351], ["model.my_temporal.view", "model.my_temporal.regressor().contiguous", "model.my_temporal.view", "model.my_temporal.temporal", "model.my_temporal.contiguous", "model.my_temporal.transpose().contiguous", "model.my_temporal.temporal().transpose().contiguous", "model.my_temporal.regressor", "model.my_temporal.transpose", "model.my_temporal.temporal().transpose", "model.my_temporal.temporal"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "features", "=", "{", "}", "\n", "if", "\"lstm_only\"", "in", "self", ".", "model_name", ":", "\n", "            ", "x", ",", "_", "=", "self", ".", "temporal", "(", "x", ")", "\n", "x", "=", "x", ".", "contiguous", "(", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "self", ".", "temporal", "(", "x", ")", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "", "batch", ",", "time_step", ",", "temporal_feature_dim", "=", "x", ".", "shape", "\n", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "temporal_feature_dim", ")", "\n", "x", "=", "self", ".", "regressor", "(", "x", ")", ".", "contiguous", "(", ")", "\n", "x", "=", "x", ".", "view", "(", "batch", ",", "time_step", ",", "self", ".", "output_dim", ")", "\n", "return", "x", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.Flatten.forward": [[13, 15], ["input.view", "input.size"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", ".", "view", "(", "input", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.SEModule.__init__": [[24, 33], ["torch.nn.Module.__init__", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Sigmoid", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channels", ",", "reduction", ")", ":", "\n", "        ", "super", "(", "SEModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "avg_pool", "=", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "fc1", "=", "Conv2d", "(", "\n", "channels", ",", "channels", "//", "reduction", ",", "kernel_size", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "self", ".", "relu", "=", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "fc2", "=", "Conv2d", "(", "\n", "channels", "//", "reduction", ",", "channels", ",", "kernel_size", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "self", ".", "sigmoid", "=", "Sigmoid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.SEModule.forward": [[34, 42], ["arcface_model.SEModule.avg_pool", "arcface_model.SEModule.fc1", "arcface_model.SEModule.relu", "arcface_model.SEModule.fc2", "arcface_model.SEModule.sigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "module_input", "=", "x", "\n", "x", "=", "self", ".", "avg_pool", "(", "x", ")", "\n", "x", "=", "self", ".", "fc1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "x", "=", "self", ".", "sigmoid", "(", "x", ")", "\n", "return", "module_input", "*", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.bottleneck_IR.__init__": [[45, 56], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel", ",", "depth", ",", "stride", ")", ":", "\n", "        ", "super", "(", "bottleneck_IR", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "in_channel", "==", "depth", ":", "\n", "            ", "self", ".", "shortcut_layer", "=", "MaxPool2d", "(", "1", ",", "stride", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut_layer", "=", "Sequential", "(", "\n", "Conv2d", "(", "in_channel", ",", "depth", ",", "(", "1", ",", "1", ")", ",", "stride", ",", "bias", "=", "False", ")", ",", "BatchNorm2d", "(", "depth", ")", ")", "\n", "", "self", ".", "res_layer", "=", "Sequential", "(", "\n", "BatchNorm2d", "(", "in_channel", ")", ",", "\n", "Conv2d", "(", "in_channel", ",", "depth", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "1", ",", "bias", "=", "False", ")", ",", "PReLU", "(", "depth", ")", ",", "\n", "Conv2d", "(", "depth", ",", "depth", ",", "(", "3", ",", "3", ")", ",", "stride", ",", "1", ",", "bias", "=", "False", ")", ",", "BatchNorm2d", "(", "depth", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.bottleneck_IR.forward": [[57, 61], ["arcface_model.bottleneck_IR.shortcut_layer", "arcface_model.bottleneck_IR.res_layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "shortcut", "=", "self", ".", "shortcut_layer", "(", "x", ")", "\n", "res", "=", "self", ".", "res_layer", "(", "x", ")", "\n", "return", "res", "+", "shortcut", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.bottleneck_IR_SE.__init__": [[64, 79], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "arcface_model.SEModule", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channel", ",", "depth", ",", "stride", ")", ":", "\n", "        ", "super", "(", "bottleneck_IR_SE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "in_channel", "==", "depth", ":", "\n", "            ", "self", ".", "shortcut_layer", "=", "MaxPool2d", "(", "1", ",", "stride", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "shortcut_layer", "=", "Sequential", "(", "\n", "Conv2d", "(", "in_channel", ",", "depth", ",", "(", "1", ",", "1", ")", ",", "stride", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "depth", ")", ")", "\n", "", "self", ".", "res_layer", "=", "Sequential", "(", "\n", "BatchNorm2d", "(", "in_channel", ")", ",", "\n", "Conv2d", "(", "in_channel", ",", "depth", ",", "(", "3", ",", "3", ")", ",", "(", "1", ",", "1", ")", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "PReLU", "(", "depth", ")", ",", "\n", "Conv2d", "(", "depth", ",", "depth", ",", "(", "3", ",", "3", ")", ",", "stride", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "depth", ")", ",", "\n", "SEModule", "(", "depth", ",", "16", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.bottleneck_IR_SE.forward": [[81, 85], ["arcface_model.bottleneck_IR_SE.shortcut_layer", "arcface_model.bottleneck_IR_SE.res_layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "shortcut", "=", "self", ".", "shortcut_layer", "(", "x", ")", "\n", "res", "=", "self", ".", "res_layer", "(", "x", ")", "\n", "return", "res", "+", "shortcut", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.Backbone.__init__": [[121, 146], ["torch.nn.Module.__init__", "arcface_model.get_blocks", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Dropout", "torch.nn.Dropout", "arcface_model.Flatten", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "modules.append", "unit_module"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_blocks"], ["    ", "def", "__init__", "(", "self", ",", "num_layers", ",", "drop_ratio", ",", "input_channels", "=", "3", ",", "mode", "=", "'ir'", ")", ":", "\n", "        ", "super", "(", "Backbone", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "num_layers", "in", "[", "50", ",", "100", ",", "152", "]", ",", "'num_layers should be 50,100, or 152'", "\n", "assert", "mode", "in", "[", "'ir'", ",", "'ir_se'", "]", ",", "'mode should be ir or ir_se'", "\n", "blocks", "=", "get_blocks", "(", "num_layers", ")", "\n", "if", "mode", "==", "'ir'", ":", "\n", "            ", "unit_module", "=", "bottleneck_IR", "\n", "", "elif", "mode", "==", "'ir_se'", ":", "\n", "            ", "unit_module", "=", "bottleneck_IR_SE", "\n", "", "self", ".", "input_layer", "=", "Sequential", "(", "Conv2d", "(", "input_channels", ",", "64", ",", "(", "3", ",", "3", ")", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "64", ")", ",", "\n", "PReLU", "(", "64", ")", ")", "\n", "self", ".", "output_layer", "=", "Sequential", "(", "BatchNorm2d", "(", "512", ")", ",", "\n", "Dropout", "(", "drop_ratio", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Linear", "(", "512", "*", "7", "*", "7", ",", "512", ")", ",", "\n", "BatchNorm1d", "(", "512", ")", ")", "\n", "modules", "=", "[", "]", "\n", "for", "block", "in", "blocks", ":", "\n", "            ", "for", "bottleneck", "in", "block", ":", "\n", "                ", "modules", ".", "append", "(", "\n", "unit_module", "(", "bottleneck", ".", "in_channel", ",", "\n", "bottleneck", ".", "depth", ",", "\n", "bottleneck", ".", "stride", ")", ")", "\n", "", "", "self", ".", "body", "=", "Sequential", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.Backbone.forward": [[147, 152], ["arcface_model.Backbone.input_layer", "arcface_model.Backbone.body", "arcface_model.Backbone.output_layer", "arcface_model.l2_norm"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.l2_norm"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "input_layer", "(", "x", ")", "\n", "x", "=", "self", ".", "body", "(", "x", ")", "\n", "x", "=", "self", ".", "output_layer", "(", "x", ")", "\n", "return", "l2_norm", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.Backbone_Eeg.__init__": [[155, 180], ["torch.nn.Module.__init__", "arcface_model.get_blocks", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Dropout", "torch.nn.Dropout", "arcface_model.Flatten", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "modules.append", "unit_module"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_blocks"], ["    ", "def", "__init__", "(", "self", ",", "num_layers", ",", "drop_ratio", ",", "input_channels", "=", "5", ",", "mode", "=", "'ir'", ")", ":", "\n", "        ", "super", "(", "Backbone_Eeg", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "num_layers", "in", "[", "50", ",", "100", ",", "152", "]", ",", "'num_layers should be 50,100, or 152'", "\n", "assert", "mode", "in", "[", "'ir'", ",", "'ir_se'", "]", ",", "'mode should be ir or ir_se'", "\n", "blocks", "=", "get_blocks", "(", "num_layers", ")", "\n", "if", "mode", "==", "'ir'", ":", "\n", "            ", "unit_module", "=", "bottleneck_IR", "\n", "", "elif", "mode", "==", "'ir_se'", ":", "\n", "            ", "unit_module", "=", "bottleneck_IR_SE", "\n", "", "self", ".", "input_layer", "=", "Sequential", "(", "Conv2d", "(", "input_channels", ",", "64", ",", "(", "3", ",", "3", ")", ",", "1", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "BatchNorm2d", "(", "64", ")", ",", "\n", "PReLU", "(", "64", ")", ")", "\n", "self", ".", "output_layer", "=", "Sequential", "(", "BatchNorm2d", "(", "512", ")", ",", "\n", "Dropout", "(", "drop_ratio", ")", ",", "\n", "Flatten", "(", ")", ",", "\n", "Linear", "(", "512", "*", "7", "*", "7", ",", "512", ")", ",", "\n", "BatchNorm1d", "(", "512", ")", ")", "\n", "modules", "=", "[", "]", "\n", "for", "block", "in", "blocks", ":", "\n", "            ", "for", "bottleneck", "in", "block", ":", "\n", "                ", "modules", ".", "append", "(", "\n", "unit_module", "(", "bottleneck", ".", "in_channel", ",", "\n", "bottleneck", ".", "depth", ",", "\n", "bottleneck", ".", "stride", ")", ")", "\n", "", "", "self", ".", "body", "=", "Sequential", "(", "*", "modules", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.Backbone_Eeg.forward": [[181, 186], ["arcface_model.Backbone_Eeg.input_layer", "arcface_model.Backbone_Eeg.body", "arcface_model.Backbone_Eeg.output_layer", "arcface_model.l2_norm"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.l2_norm"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "input_layer", "(", "x", ")", "\n", "x", "=", "self", ".", "body", "(", "x", ")", "\n", "x", "=", "self", ".", "output_layer", "(", "x", ")", "\n", "return", "l2_norm", "(", "x", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.l2_norm": [[17, 21], ["torch.norm", "torch.norm", "torch.div", "torch.div"], "function", ["None"], ["", "", "def", "l2_norm", "(", "input", ",", "axis", "=", "1", ")", ":", "\n", "    ", "norm", "=", "torch", ".", "norm", "(", "input", ",", "2", ",", "axis", ",", "True", ")", "\n", "output", "=", "torch", ".", "div", "(", "input", ",", "norm", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block": [[91, 93], ["arcface_model.Bottleneck", "arcface_model.Bottleneck", "range"], "function", ["None"], ["", "def", "get_block", "(", "in_channel", ",", "depth", ",", "num_units", ",", "stride", "=", "2", ")", ":", "\n", "    ", "return", "[", "Bottleneck", "(", "in_channel", ",", "depth", ",", "stride", ")", "]", "+", "[", "Bottleneck", "(", "depth", ",", "depth", ",", "1", ")", "for", "i", "in", "range", "(", "num_units", "-", "1", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_blocks": [[95, 118], ["arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block", "arcface_model.get_block"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block", "home.repos.pwc.inspect_result.sucv_ABAW2.model.arcface_model.get_block"], ["", "def", "get_blocks", "(", "num_layers", ")", ":", "\n", "    ", "if", "num_layers", "==", "50", ":", "\n", "        ", "blocks", "=", "[", "\n", "get_block", "(", "in_channel", "=", "64", ",", "depth", "=", "64", ",", "num_units", "=", "3", ",", "stride", "=", "1", ")", ",", "\n", "get_block", "(", "in_channel", "=", "64", ",", "depth", "=", "128", ",", "num_units", "=", "4", ")", ",", "\n", "get_block", "(", "in_channel", "=", "128", ",", "depth", "=", "256", ",", "num_units", "=", "14", ")", ",", "\n", "get_block", "(", "in_channel", "=", "256", ",", "depth", "=", "512", ",", "num_units", "=", "3", ")", "\n", "]", "\n", "", "elif", "num_layers", "==", "100", ":", "\n", "        ", "blocks", "=", "[", "\n", "get_block", "(", "in_channel", "=", "64", ",", "depth", "=", "64", ",", "num_units", "=", "3", ")", ",", "\n", "get_block", "(", "in_channel", "=", "64", ",", "depth", "=", "128", ",", "num_units", "=", "13", ")", ",", "\n", "get_block", "(", "in_channel", "=", "128", ",", "depth", "=", "256", ",", "num_units", "=", "30", ")", ",", "\n", "get_block", "(", "in_channel", "=", "256", ",", "depth", "=", "512", ",", "num_units", "=", "3", ")", "\n", "]", "\n", "", "elif", "num_layers", "==", "152", ":", "\n", "        ", "blocks", "=", "[", "\n", "get_block", "(", "in_channel", "=", "64", ",", "depth", "=", "64", ",", "num_units", "=", "3", ")", ",", "\n", "get_block", "(", "in_channel", "=", "64", ",", "depth", "=", "128", ",", "num_units", "=", "8", ")", ",", "\n", "get_block", "(", "in_channel", "=", "128", ",", "depth", "=", "256", ",", "num_units", "=", "36", ")", ",", "\n", "get_block", "(", "in_channel", "=", "256", ",", "depth", "=", "512", ",", "num_units", "=", "3", ")", "\n", "]", "\n", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.script.confirm_length.get_video_path": [[9, 30], ["video_filename_without_extension.endswith", "os.path.join", "label.split", "video_filename_without_extension.endswith", "video_filename_without_extension.split", "print", "ValueError", "video_filename_without_extension.split"], "function", ["None"], ["def", "get_video_path", "(", "label", ",", "partition", ")", ":", "\n", "    ", "label", "=", "label", ".", "split", "(", "\".txt\"", ")", "[", "0", "]", "\n", "video_filename_without_extension", "=", "label", "\n", "\n", "# Find the corresonding video filename.", "\n", "if", "video_filename_without_extension", ".", "endswith", "(", "\"_right\"", ")", ":", "\n", "        ", "video_filename_without_extension", "=", "video_filename_without_extension", ".", "split", "(", "\"_right\"", ")", "[", "0", "]", "\n", "", "elif", "video_filename_without_extension", ".", "endswith", "(", "\"_left\"", ")", ":", "\n", "        ", "video_filename_without_extension", "=", "video_filename_without_extension", ".", "split", "(", "\"_left\"", ")", "[", "0", "]", "\n", "\n", "", "if", "(", "video_filename_without_extension", "+", "\".avi\"", ")", "in", "video_to_partition_dict", "[", "partition", "]", ":", "\n", "        ", "corresponding_video_filename", "=", "video_filename_without_extension", "+", "\".avi\"", "\n", "", "elif", "(", "video_filename_without_extension", "+", "\".mp4\"", ")", "in", "video_to_partition_dict", "[", "partition", "]", ":", "\n", "        ", "corresponding_video_filename", "=", "video_filename_without_extension", "+", "\".mp4\"", "\n", "", "else", ":", "\n", "        ", "print", "(", "video_filename_without_extension", ")", "\n", "raise", "ValueError", "(", "\"Cannot find the corresponding video\"", ")", "\n", "\n", "", "corresponding_video", "=", "os", ".", "path", ".", "join", "(", "raw_video_path", ",", "corresponding_video_filename", ")", "\n", "\n", "return", "corresponding_video", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_postprocess.Postprocessor.__init__": [[34, 49], ["numpy.load", "params[].reshape"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pca_params_npz_path", ")", ":", "\n", "    ", "\"\"\"Constructs a postprocessor.\n    Args:\n      pca_params_npz_path: Path to a NumPy-format .npz file that\n        contains the PCA parameters used in postprocessing.\n    \"\"\"", "\n", "params", "=", "np", ".", "load", "(", "pca_params_npz_path", ")", "\n", "self", ".", "_pca_matrix", "=", "params", "[", "vggish_params", ".", "PCA_EIGEN_VECTORS_NAME", "]", "\n", "# Load means into a column vector for easier broadcasting later.", "\n", "self", ".", "_pca_means", "=", "params", "[", "vggish_params", ".", "PCA_MEANS_NAME", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "assert", "self", ".", "_pca_matrix", ".", "shape", "==", "(", "\n", "vggish_params", ".", "EMBEDDING_SIZE", ",", "vggish_params", ".", "EMBEDDING_SIZE", ")", ",", "(", "\n", "'Bad PCA matrix shape: %r'", "%", "(", "self", ".", "_pca_matrix", ".", "shape", ",", ")", ")", "\n", "assert", "self", ".", "_pca_means", ".", "shape", "==", "(", "vggish_params", ".", "EMBEDDING_SIZE", ",", "1", ")", ",", "(", "\n", "'Bad PCA means shape: %r'", "%", "(", "self", ".", "_pca_means", ".", "shape", ",", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_postprocess.Postprocessor.postprocess": [[50, 88], ["numpy.clip", "len", "numpy.dot"], "methods", ["None"], ["", "def", "postprocess", "(", "self", ",", "embeddings_batch", ")", ":", "\n", "    ", "\"\"\"Applies postprocessing to a batch of embeddings.\n    Args:\n      embeddings_batch: An nparray of shape [batch_size, embedding_size]\n        containing output from the embedding layer of VGGish.\n    Returns:\n      An nparray of the same shape as the input but of type uint8,\n      containing the PCA-transformed and quantized version of the input.\n    \"\"\"", "\n", "assert", "len", "(", "embeddings_batch", ".", "shape", ")", "==", "2", ",", "(", "\n", "'Expected 2-d batch, got %r'", "%", "(", "embeddings_batch", ".", "shape", ",", ")", ")", "\n", "assert", "embeddings_batch", ".", "shape", "[", "1", "]", "==", "vggish_params", ".", "EMBEDDING_SIZE", ",", "(", "\n", "'Bad batch shape: %r'", "%", "(", "embeddings_batch", ".", "shape", ",", ")", ")", "\n", "\n", "# Apply PCA.", "\n", "# - Embeddings come in as [batch_size, embedding_size].", "\n", "# - Transpose to [embedding_size, batch_size].", "\n", "# - Subtract pca_means column vector from each column.", "\n", "# - Premultiply by PCA matrix of shape [output_dims, input_dims]", "\n", "#   where both are are equal to embedding_size in our case.", "\n", "# - Transpose result back to [batch_size, embedding_size].", "\n", "pca_applied", "=", "np", ".", "dot", "(", "self", ".", "_pca_matrix", ",", "\n", "(", "embeddings_batch", ".", "T", "-", "self", ".", "_pca_means", ")", ")", ".", "T", "\n", "\n", "# Quantize by:", "\n", "# - clipping to [min, max] range", "\n", "clipped_embeddings", "=", "np", ".", "clip", "(", "\n", "pca_applied", ",", "vggish_params", ".", "QUANTIZE_MIN_VAL", ",", "\n", "vggish_params", ".", "QUANTIZE_MAX_VAL", ")", "\n", "# # - convert to 8-bit in range [0.0, 255.0]", "\n", "# quantized_embeddings = (", "\n", "#     (clipped_embeddings - vggish_params.QUANTIZE_MIN_VAL) *", "\n", "#     (255.0 /", "\n", "#      (vggish_params.QUANTIZE_MAX_VAL - vggish_params.QUANTIZE_MIN_VAL)))", "\n", "# # - cast 8-bit float to uint8", "\n", "# quantized_embeddings = quantized_embeddings.astype(np.uint8)", "\n", "\n", "return", "quantized_embeddings", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_input.waveform_to_examples": [[37, 83], ["vggish.mel_features.log_mel_spectrogram", "int", "vggish.mel_features.my_frame", "len", "numpy.mean", "resampy.resample", "round"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.log_mel_spectrogram", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.my_frame"], ["", "", "def", "waveform_to_examples", "(", "data", ",", "sample_rate", ",", "window_sec", ",", "hop_sec", ")", ":", "\n", "  ", "\"\"\"Converts audio waveform into an array of examples for VGGish.\n  Args:\n    data: np.array of either one dimension (mono) or two dimensions\n      (multi-channel, with the outer dimension representing channels).\n      Each sample is generally expected to lie in the range [-1.0, +1.0],\n      although this is not required.\n    sample_rate: Sample rate of data.\n  Returns:\n    3-D np.array of shape [num_examples, num_frames, num_bands] which represents\n    a sequence of examples, each of which contains a patch of log mel\n    spectrogram, covering num_frames frames of audio and num_bands mel frequency\n    bands, where the frame length is vggish_params.STFT_HOP_LENGTH_SECONDS.\n  \"\"\"", "\n", "# Convert to mono.", "\n", "if", "len", "(", "data", ".", "shape", ")", ">", "1", ":", "\n", "    ", "data", "=", "np", ".", "mean", "(", "data", ",", "axis", "=", "1", ")", "\n", "# Resample to the rate assumed by VGGish.", "\n", "", "if", "sample_rate", "!=", "vggish_params", ".", "SAMPLE_RATE", ":", "\n", "    ", "data", "=", "resampy", ".", "resample", "(", "data", ",", "sample_rate", ",", "vggish_params", ".", "SAMPLE_RATE", ")", "\n", "\n", "# Compute log mel spectrogram features.", "\n", "", "log_mel", "=", "mel_features", ".", "log_mel_spectrogram", "(", "\n", "data", ",", "\n", "audio_sample_rate", "=", "vggish_params", ".", "SAMPLE_RATE", ",", "\n", "log_offset", "=", "vggish_params", ".", "LOG_OFFSET", ",", "\n", "window_length_secs", "=", "vggish_params", ".", "STFT_WINDOW_LENGTH_SECONDS", ",", "\n", "hop_length_secs", "=", "vggish_params", ".", "STFT_HOP_LENGTH_SECONDS", ",", "\n", "num_mel_bins", "=", "vggish_params", ".", "NUM_MEL_BINS", ",", "\n", "lower_edge_hertz", "=", "vggish_params", ".", "MEL_MIN_HZ", ",", "\n", "upper_edge_hertz", "=", "vggish_params", ".", "MEL_MAX_HZ", ")", "\n", "\n", "# Frame features into examples.", "\n", "features_sample_rate", "=", "1.0", "/", "vggish_params", ".", "STFT_HOP_LENGTH_SECONDS", "\n", "example_window_length", "=", "int", "(", "round", "(", "\n", "window_sec", "*", "features_sample_rate", ")", ")", "\n", "\n", "# example_hop_length = int(round(", "\n", "#     hop_sec * features_sample_rate))", "\n", "\n", "example_hop_length", "=", "hop_sec", "*", "features_sample_rate", "\n", "log_mel_examples", "=", "mel_features", ".", "my_frame", "(", "\n", "log_mel", ",", "\n", "window_length", "=", "example_window_length", ",", "\n", "hop_length", "=", "example_hop_length", ")", "\n", "return", "log_mel_examples", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_input.wavfile_to_examples": [[85, 99], ["wav_read", "numpy.pad", "vggish_input.waveform_to_examples"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_input.waveform_to_examples"], ["", "def", "wavfile_to_examples", "(", "wav_file", ",", "window_sec", ",", "hop_sec", ")", ":", "\n", "  ", "\"\"\"Convenience wrapper around waveform_to_examples() for a common WAV format.\n  Args:\n    wav_file: String path to a file, or a file-like object. The file\n    is assumed to contain WAV audio data with signed 16-bit PCM samples.\n  Returns:\n    See waveform_to_examples.\n  \"\"\"", "\n", "wav_data", ",", "sr", "=", "wav_read", "(", "wav_file", ")", "\n", "assert", "wav_data", ".", "dtype", "==", "np", ".", "int16", ",", "'Bad sample type: %r'", "%", "wav_data", ".", "dtype", "\n", "samples", "=", "wav_data", "/", "32768.0", "# Convert to [-1.0, +1.0]", "\n", "\n", "samples", "=", "np", ".", "pad", "(", "samples", ",", "(", "0", ",", "sr", ")", ",", "'edge'", ")", "\n", "return", "waveform_to_examples", "(", "samples", ",", "sr", ",", "window_sec", ",", "hop_sec", ")", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.inference.extract_vggish": [[37, 83], ["vggish.vggish_input.wavfile_to_examples", "tensorflow.Graph().as_default", "tensorflow.Session", "vggish.vggish_slim.define_vggish_slim", "vggish.vggish_slim.load_vggish_slim_checkpoint", "sess.graph.get_tensor_by_name", "sess.graph.get_tensor_by_name", "sess.run", "tensorflow.Graph"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_input.wavfile_to_examples", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_slim.define_vggish_slim", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_slim.load_vggish_slim_checkpoint"], ["def", "extract_vggish", "(", "\n", "wav_file", ",", "\n", "window_sec", "=", "0.025", ",", "\n", "hop_sec", "=", "0.01", ",", "\n", ")", ":", "\n", "    ", "examples_batch", "=", "vggish_input", ".", "wavfile_to_examples", "(", "wav_file", ",", "window_sec", "=", "window_sec", ",", "hop_sec", "=", "hop_sec", ")", "\n", "\n", "with", "tf", ".", "Graph", "(", ")", ".", "as_default", "(", ")", ",", "tf", ".", "Session", "(", ")", "as", "sess", ":", "\n", "# Define the model in inference mode, load the checkpoint, and", "\n", "# locate input and output tensors.", "\n", "        ", "vggish_slim", ".", "define_vggish_slim", "(", "training", "=", "False", ")", "\n", "vggish_slim", ".", "load_vggish_slim_checkpoint", "(", "sess", ",", "FLAGS", ".", "checkpoint", ")", "\n", "features_tensor", "=", "sess", ".", "graph", ".", "get_tensor_by_name", "(", "\n", "vggish_params", ".", "INPUT_TENSOR_NAME", ")", "\n", "embedding_tensor", "=", "sess", ".", "graph", ".", "get_tensor_by_name", "(", "\n", "vggish_params", ".", "OUTPUT_TENSOR_NAME", ")", "\n", "\n", "# Run inference and postprocessing.", "\n", "[", "embedding_batch", "]", "=", "sess", ".", "run", "(", "[", "embedding_tensor", "]", ",", "\n", "feed_dict", "=", "{", "features_tensor", ":", "examples_batch", "}", ")", "\n", "# print(embedding_batch)", "\n", "# postprocessed_batch = pproc.postprocess(embedding_batch)", "\n", "# print(postprocessed_batch)", "\n", "\n", "# # Write the postprocessed embeddings as a SequenceExample, in a similar", "\n", "# # format as the features released in AudioSet. Each row of the batch of", "\n", "# # embeddings corresponds to roughly a second of audio (96 10ms frames), and", "\n", "# # the rows are written as a sequence of bytes-valued features, where each", "\n", "# # feature value contains the 128 bytes of the whitened quantized embedding.", "\n", "# seq_example = tf.train.SequenceExample(", "\n", "#     feature_lists=tf.train.FeatureLists(", "\n", "#         feature_list={", "\n", "#             vggish_params.AUDIO_EMBEDDING_FEATURE_NAME:", "\n", "#                 tf.train.FeatureList(", "\n", "#                     feature=[", "\n", "#                         tf.train.Feature(", "\n", "#                             bytes_list=tf.train.BytesList(", "\n", "#                                 value=[embedding.tobytes()]))", "\n", "#                         for embedding in embedding_batch", "\n", "#                     ]", "\n", "#                 )", "\n", "#         }", "\n", "#     )", "\n", "# )", "\n", "\n", "return", "embedding_batch", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.my_frame": [[21, 50], ["range", "numpy.stack", "int", "round", "np.stack.append", "numpy.floor"], "function", ["None"], ["def", "my_frame", "(", "data", ",", "window_length", ",", "hop_length", ")", ":", "\n", "    ", "\"\"\"Convert array into a sequence of successive possibly overlapping frames.\n  An n-dimensional array of shape (num_samples, ...) is converted into an\n  (n+1)-D array of shape (num_frames, window_length, ...), where each frame\n  starts hop_length points after the preceding one.\n  This is accomplished using stride_tricks, so the original data is not\n  copied.  However, there is no zero-padding, so any incomplete frames at the\n  end are not included.\n  Args:\n    data: np.array of dimension N >= 1.\n    window_length: Number of samples in each frame.\n    hop_length: Advance (in samples) between each window.\n  Returns:\n    (N+1)-D np.array with as many rows as there are complete frames that can be\n    extracted.\n  \"\"\"", "\n", "num_samples", "=", "data", ".", "shape", "[", "0", "]", "\n", "num_frames", "=", "1", "+", "int", "(", "np", ".", "floor", "(", "(", "num_samples", "-", "window_length", ")", "/", "hop_length", ")", ")", "\n", "shape", "=", "(", "num_frames", ",", "window_length", ")", "+", "data", ".", "shape", "[", "1", ":", "]", "\n", "\n", "frame", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_frames", ")", ":", "\n", "        ", "current_frame_start", "=", "round", "(", "hop_length", "*", "i", ")", "\n", "current_frame_end", "=", "current_frame_start", "+", "window_length", "\n", "current_frame", "=", "data", "[", "current_frame_start", ":", "current_frame_end", ",", ":", "]", "\n", "frame", ".", "append", "(", "current_frame", ")", "\n", "\n", "", "frame", "=", "np", ".", "stack", "(", "frame", ")", "\n", "return", "frame", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.frame": [[52, 73], ["numpy.lib.stride_tricks.as_strided", "int", "numpy.floor"], "function", ["None"], ["", "def", "frame", "(", "data", ",", "window_length", ",", "hop_length", ")", ":", "\n", "    ", "\"\"\"Convert array into a sequence of successive possibly overlapping frames.\n  An n-dimensional array of shape (num_samples, ...) is converted into an\n  (n+1)-D array of shape (num_frames, window_length, ...), where each frame\n  starts hop_length points after the preceding one.\n  This is accomplished using stride_tricks, so the original data is not\n  copied.  However, there is no zero-padding, so any incomplete frames at the\n  end are not included.\n  Args:\n    data: np.array of dimension N >= 1.\n    window_length: Number of samples in each frame.\n    hop_length: Advance (in samples) between each window.\n  Returns:\n    (N+1)-D np.array with as many rows as there are complete frames that can be\n    extracted.\n  \"\"\"", "\n", "num_samples", "=", "data", ".", "shape", "[", "0", "]", "\n", "num_frames", "=", "1", "+", "int", "(", "np", ".", "floor", "(", "(", "num_samples", "-", "window_length", ")", "/", "hop_length", ")", ")", "\n", "shape", "=", "(", "num_frames", ",", "window_length", ")", "+", "data", ".", "shape", "[", "1", ":", "]", "\n", "strides", "=", "(", "data", ".", "strides", "[", "0", "]", "*", "hop_length", ",", ")", "+", "data", ".", "strides", "\n", "return", "np", ".", "lib", ".", "stride_tricks", ".", "as_strided", "(", "data", ",", "shape", "=", "shape", ",", "strides", "=", "strides", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.periodic_hann": [[75, 93], ["numpy.cos", "numpy.arange"], "function", ["None"], ["", "def", "periodic_hann", "(", "window_length", ")", ":", "\n", "    ", "\"\"\"Calculate a \"periodic\" Hann window.\n  The classic Hann window is defined as a raised cosine that starts and\n  ends on zero, and where every value appears twice, except the middle\n  point for an odd-length window.  Matlab calls this a \"symmetric\" window\n  and np.hanning() returns it.  However, for Fourier analysis, this\n  actually represents just over one cycle of a period N-1 cosine, and\n  thus is not compactly expressed on a length-N Fourier basis.  Instead,\n  it's better to use a raised cosine that ends just before the final\n  zero value - i.e. a complete cycle of a period-N cosine.  Matlab\n  calls this a \"periodic\" window. This routine calculates it.\n  Args:\n    window_length: The number of points in the returned window.\n  Returns:\n    A 1D np.array containing the periodic hann window.\n  \"\"\"", "\n", "return", "0.5", "-", "(", "0.5", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "/", "window_length", "*", "\n", "np", ".", "arange", "(", "window_length", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.stft_magnitude": [[95, 115], ["mel_features.frame", "mel_features.periodic_hann", "numpy.abs", "numpy.fft.rfft", "int"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.frame", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.periodic_hann"], ["", "def", "stft_magnitude", "(", "signal", ",", "fft_length", ",", "\n", "hop_length", "=", "None", ",", "\n", "window_length", "=", "None", ")", ":", "\n", "    ", "\"\"\"Calculate the short-time Fourier transform magnitude.\n  Args:\n    signal: 1D np.array of the input time-domain signal.\n    fft_length: Size of the FFT to apply.\n    hop_length: Advance (in samples) between each frame passed to FFT.\n    window_length: Length of each block of samples to pass to FFT.\n  Returns:\n    2D np.array where each row contains the magnitudes of the fft_length/2+1\n    unique values of the FFT for the corresponding frame of input samples.\n  \"\"\"", "\n", "frames", "=", "frame", "(", "signal", ",", "window_length", ",", "hop_length", ")", "\n", "# Apply frame window to each frame. We use a periodic Hann (cosine of period", "\n", "# window_length) instead of the symmetric Hann of np.hanning (period", "\n", "# window_length-1).", "\n", "window", "=", "periodic_hann", "(", "window_length", ")", "\n", "windowed_frames", "=", "frames", "*", "window", "\n", "return", "np", ".", "abs", "(", "np", ".", "fft", ".", "rfft", "(", "windowed_frames", ",", "int", "(", "fft_length", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.hertz_to_mel": [[122, 132], ["numpy.log"], "function", ["None"], ["def", "hertz_to_mel", "(", "frequencies_hertz", ")", ":", "\n", "    ", "\"\"\"Convert frequencies to mel scale using HTK formula.\n  Args:\n    frequencies_hertz: Scalar or np.array of frequencies in hertz.\n  Returns:\n    Object of same size as frequencies_hertz containing corresponding values\n    on the mel scale.\n  \"\"\"", "\n", "return", "_MEL_HIGH_FREQUENCY_Q", "*", "np", ".", "log", "(", "\n", "1.0", "+", "(", "frequencies_hertz", "/", "_MEL_BREAK_FREQUENCY_HERTZ", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.spectrogram_to_mel_matrix": [[134, 205], ["numpy.linspace", "mel_features.hertz_to_mel", "numpy.linspace", "numpy.empty", "range", "ValueError", "ValueError", "ValueError", "mel_features.hertz_to_mel", "mel_features.hertz_to_mel", "numpy.maximum", "numpy.minimum"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.hertz_to_mel", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.hertz_to_mel", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.hertz_to_mel"], ["", "def", "spectrogram_to_mel_matrix", "(", "num_mel_bins", "=", "20", ",", "\n", "num_spectrogram_bins", "=", "129", ",", "\n", "audio_sample_rate", "=", "8000", ",", "\n", "lower_edge_hertz", "=", "125.0", ",", "\n", "upper_edge_hertz", "=", "3800.0", ")", ":", "\n", "    ", "\"\"\"Return a matrix that can post-multiply spectrogram rows to make mel.\n  Returns a np.array matrix A that can be used to post-multiply a matrix S of\n  spectrogram values (STFT magnitudes) arranged as frames x bins to generate a\n  \"mel spectrogram\" M of frames x num_mel_bins.  M = S A.\n  The classic HTK algorithm exploits the complementarity of adjacent mel bands\n  to multiply each FFT bin by only one mel weight, then add it, with positive\n  and negative signs, to the two adjacent mel bands to which that bin\n  contributes.  Here, by expressing this operation as a matrix multiply, we go\n  from num_fft multiplies per frame (plus around 2*num_fft adds) to around\n  num_fft^2 multiplies and adds.  However, because these are all presumably\n  accomplished in a single call to np.dot(), it's not clear which approach is\n  faster in Python.  The matrix multiplication has the attraction of being more\n  general and flexible, and much easier to read.\n  Args:\n    num_mel_bins: How many bands in the resulting mel spectrum.  This is\n      the number of columns in the output matrix.\n    num_spectrogram_bins: How many bins there are in the source spectrogram\n      data, which is understood to be fft_size/2 + 1, i.e. the spectrogram\n      only contains the nonredundant FFT bins.\n    audio_sample_rate: Samples per second of the audio at the input to the\n      spectrogram. We need this to figure out the actual frequencies for\n      each spectrogram bin, which dictates how they are mapped into mel.\n    lower_edge_hertz: Lower bound on the frequencies to be included in the mel\n      spectrum.  This corresponds to the lower edge of the lowest triangular\n      band.\n    upper_edge_hertz: The desired top edge of the highest frequency band.\n  Returns:\n    An np.array with shape (num_spectrogram_bins, num_mel_bins).\n  Raises:\n    ValueError: if frequency edges are incorrectly ordered or out of range.\n  \"\"\"", "\n", "nyquist_hertz", "=", "audio_sample_rate", "/", "2.", "\n", "if", "lower_edge_hertz", "<", "0.0", ":", "\n", "        ", "raise", "ValueError", "(", "\"lower_edge_hertz %.1f must be >= 0\"", "%", "lower_edge_hertz", ")", "\n", "", "if", "lower_edge_hertz", ">=", "upper_edge_hertz", ":", "\n", "        ", "raise", "ValueError", "(", "\"lower_edge_hertz %.1f >= upper_edge_hertz %.1f\"", "%", "\n", "(", "lower_edge_hertz", ",", "upper_edge_hertz", ")", ")", "\n", "", "if", "upper_edge_hertz", ">", "nyquist_hertz", ":", "\n", "        ", "raise", "ValueError", "(", "\"upper_edge_hertz %.1f is greater than Nyquist %.1f\"", "%", "\n", "(", "upper_edge_hertz", ",", "nyquist_hertz", ")", ")", "\n", "", "spectrogram_bins_hertz", "=", "np", ".", "linspace", "(", "0.0", ",", "nyquist_hertz", ",", "num_spectrogram_bins", ")", "\n", "spectrogram_bins_mel", "=", "hertz_to_mel", "(", "spectrogram_bins_hertz", ")", "\n", "# The i'th mel band (starting from i=1) has center frequency", "\n", "# band_edges_mel[i], lower edge band_edges_mel[i-1], and higher edge", "\n", "# band_edges_mel[i+1].  Thus, we need num_mel_bins + 2 values in", "\n", "# the band_edges_mel arrays.", "\n", "band_edges_mel", "=", "np", ".", "linspace", "(", "hertz_to_mel", "(", "lower_edge_hertz", ")", ",", "\n", "hertz_to_mel", "(", "upper_edge_hertz", ")", ",", "num_mel_bins", "+", "2", ")", "\n", "# Matrix to post-multiply feature arrays whose rows are num_spectrogram_bins", "\n", "# of spectrogram values.", "\n", "mel_weights_matrix", "=", "np", ".", "empty", "(", "(", "num_spectrogram_bins", ",", "num_mel_bins", ")", ")", "\n", "for", "i", "in", "range", "(", "num_mel_bins", ")", ":", "\n", "        ", "lower_edge_mel", ",", "center_mel", ",", "upper_edge_mel", "=", "band_edges_mel", "[", "i", ":", "i", "+", "3", "]", "\n", "# Calculate lower and upper slopes for every spectrogram bin.", "\n", "# Line segments are linear in the *mel* domain, not hertz.", "\n", "lower_slope", "=", "(", "(", "spectrogram_bins_mel", "-", "lower_edge_mel", ")", "/", "\n", "(", "center_mel", "-", "lower_edge_mel", ")", ")", "\n", "upper_slope", "=", "(", "(", "upper_edge_mel", "-", "spectrogram_bins_mel", ")", "/", "\n", "(", "upper_edge_mel", "-", "center_mel", ")", ")", "\n", "# .. then intersect them with each other and zero.", "\n", "mel_weights_matrix", "[", ":", ",", "i", "]", "=", "np", ".", "maximum", "(", "0.0", ",", "np", ".", "minimum", "(", "lower_slope", ",", "\n", "upper_slope", ")", ")", "\n", "# HTK excludes the spectrogram DC bin; make sure it always gets a zero", "\n", "# coefficient.", "\n", "", "mel_weights_matrix", "[", "0", ",", ":", "]", "=", "0.0", "\n", "return", "mel_weights_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.log_mel_spectrogram": [[207, 237], ["int", "int", "mel_features.stft_magnitude", "numpy.dot", "numpy.log", "round", "round", "int", "mel_features.spectrogram_to_mel_matrix", "numpy.ceil", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.stft_magnitude", "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.mel_features.spectrogram_to_mel_matrix"], ["", "def", "log_mel_spectrogram", "(", "data", ",", "\n", "audio_sample_rate", "=", "8000", ",", "\n", "log_offset", "=", "0.0", ",", "\n", "window_length_secs", "=", "0.025", ",", "\n", "hop_length_secs", "=", "0.010", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Convert waveform to a log magnitude mel-frequency spectrogram.\n  Args:\n    data: 1D np.array of waveform data.\n    audio_sample_rate: The sampling rate of data.\n    log_offset: Add this to values when taking log to avoid -Infs.\n    window_length_secs: Duration of each window to analyze.\n    hop_length_secs: Advance between successive analysis windows.\n    **kwargs: Additional arguments to pass to spectrogram_to_mel_matrix.\n  Returns:\n    2D np.array of (num_frames, num_mel_bins) consisting of log mel filterbank\n    magnitudes for successive frames.\n  \"\"\"", "\n", "window_length_samples", "=", "int", "(", "round", "(", "audio_sample_rate", "*", "window_length_secs", ")", ")", "\n", "hop_length_samples", "=", "int", "(", "round", "(", "audio_sample_rate", "*", "hop_length_secs", ")", ")", "\n", "fft_length", "=", "2", "**", "int", "(", "np", ".", "ceil", "(", "np", ".", "log", "(", "window_length_samples", ")", "/", "np", ".", "log", "(", "2.0", ")", ")", ")", "\n", "spectrogram", "=", "stft_magnitude", "(", "\n", "data", ",", "\n", "fft_length", "=", "fft_length", ",", "\n", "hop_length", "=", "hop_length_samples", ",", "\n", "window_length", "=", "window_length_samples", ")", "\n", "mel_spectrogram", "=", "np", ".", "dot", "(", "spectrogram", ",", "spectrogram_to_mel_matrix", "(", "\n", "num_spectrogram_bins", "=", "spectrogram", ".", "shape", "[", "1", "]", ",", "\n", "audio_sample_rate", "=", "audio_sample_rate", ",", "**", "kwargs", ")", ")", "\n", "return", "np", ".", "log", "(", "mel_spectrogram", "+", "log_offset", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_slim.define_vggish_slim": [[36, 100], ["tf_slim.arg_scope", "tf_slim.arg_scope", "tf_slim.arg_scope", "tensorflow.variable_scope", "tensorflow.reshape", "tf_slim.conv2d", "tf_slim.max_pool2d", "tf_slim.conv2d", "tf_slim.max_pool2d", "tf_slim.repeat", "tf_slim.max_pool2d", "tf_slim.repeat", "tf_slim.max_pool2d", "tf_slim.flatten", "tf_slim.repeat", "tf_slim.fully_connected", "tensorflow.identity", "tensorflow.placeholder", "tensorflow.truncated_normal_initializer", "tensorflow.zeros_initializer"], "function", ["None"], ["def", "define_vggish_slim", "(", "features_tensor", "=", "None", ",", "training", "=", "False", ")", ":", "\n", "  ", "\"\"\"Defines the VGGish TensorFlow model.\n  All ops are created in the current default graph, under the scope 'vggish/'.\n  The input is either a tensor passed in via the optional 'features_tensor'\n  argument or a placeholder created below named 'vggish/input_features'. The\n  input is expected to have dtype float32 and shape [batch_size, num_frames,\n  num_bands] where batch_size is variable and num_frames and num_bands are\n  constants, and [num_frames, num_bands] represents a log-mel-scale spectrogram\n  patch covering num_bands frequency bands and num_frames time frames (where\n  each frame step is usually 10ms). This is produced by computing the stabilized\n  log(mel-spectrogram + params.LOG_OFFSET).  The output is a tensor named\n  'vggish/embedding' which produces the pre-activation values of a 128-D\n  embedding layer, which is usually the penultimate layer when used as part of a\n  full model with a final classifier layer.\n  Args:\n    features_tensor: If not None, the tensor containing the input features.\n      If None, a placeholder input is created.\n    training: If true, all parameters are marked trainable.\n  Returns:\n    The op 'vggish/embeddings'.\n  \"\"\"", "\n", "# Defaults:", "\n", "# - All weights are initialized to N(0, INIT_STDDEV).", "\n", "# - All biases are initialized to 0.", "\n", "# - All activations are ReLU.", "\n", "# - All convolutions are 3x3 with stride 1 and SAME padding.", "\n", "# - All max-pools are 2x2 with stride 2 and SAME padding.", "\n", "with", "slim", ".", "arg_scope", "(", "[", "slim", ".", "conv2d", ",", "slim", ".", "fully_connected", "]", ",", "\n", "weights_initializer", "=", "tf", ".", "truncated_normal_initializer", "(", "\n", "stddev", "=", "params", ".", "INIT_STDDEV", ")", ",", "\n", "biases_initializer", "=", "tf", ".", "zeros_initializer", "(", ")", ",", "\n", "activation_fn", "=", "tf", ".", "nn", ".", "relu", ",", "\n", "trainable", "=", "training", ")", ",", "slim", ".", "arg_scope", "(", "[", "slim", ".", "conv2d", "]", ",", "\n", "kernel_size", "=", "[", "3", ",", "3", "]", ",", "stride", "=", "1", ",", "padding", "=", "'SAME'", ")", ",", "slim", ".", "arg_scope", "(", "[", "slim", ".", "max_pool2d", "]", ",", "\n", "kernel_size", "=", "[", "2", ",", "2", "]", ",", "stride", "=", "2", ",", "padding", "=", "'SAME'", ")", ",", "tf", ".", "variable_scope", "(", "'vggish'", ")", ":", "\n", "# Input: a batch of 2-D log-mel-spectrogram patches.", "\n", "    ", "if", "features_tensor", "is", "None", ":", "\n", "      ", "features_tensor", "=", "tf", ".", "placeholder", "(", "\n", "tf", ".", "float32", ",", "shape", "=", "(", "None", ",", "params", ".", "NUM_FRAMES", ",", "params", ".", "NUM_BANDS", ")", ",", "\n", "name", "=", "'input_features'", ")", "\n", "# Reshape to 4-D so that we can convolve a batch with conv2d().", "\n", "", "net", "=", "tf", ".", "reshape", "(", "features_tensor", ",", "\n", "[", "-", "1", ",", "params", ".", "NUM_FRAMES", ",", "params", ".", "NUM_BANDS", ",", "1", "]", ")", "\n", "\n", "# The VGG stack of alternating convolutions and max-pools.", "\n", "net", "=", "slim", ".", "conv2d", "(", "net", ",", "64", ",", "scope", "=", "'conv1'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "scope", "=", "'pool1'", ")", "\n", "net", "=", "slim", ".", "conv2d", "(", "net", ",", "128", ",", "scope", "=", "'conv2'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "scope", "=", "'pool2'", ")", "\n", "net", "=", "slim", ".", "repeat", "(", "net", ",", "2", ",", "slim", ".", "conv2d", ",", "256", ",", "scope", "=", "'conv3'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "scope", "=", "'pool3'", ")", "\n", "net", "=", "slim", ".", "repeat", "(", "net", ",", "2", ",", "slim", ".", "conv2d", ",", "512", ",", "scope", "=", "'conv4'", ")", "\n", "net", "=", "slim", ".", "max_pool2d", "(", "net", ",", "scope", "=", "'pool4'", ")", "\n", "\n", "# Flatten before entering fully-connected layers", "\n", "net", "=", "slim", ".", "flatten", "(", "net", ")", "\n", "net", "=", "slim", ".", "repeat", "(", "net", ",", "2", ",", "slim", ".", "fully_connected", ",", "4096", ",", "scope", "=", "'fc1'", ")", "\n", "# The embedding layer.", "\n", "net", "=", "slim", ".", "fully_connected", "(", "net", ",", "params", ".", "EMBEDDING_SIZE", ",", "scope", "=", "'fc2'", ",", "\n", "activation_fn", "=", "None", ")", "\n", "return", "tf", ".", "identity", "(", "net", ",", "name", "=", "'embedding'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_slim.load_vggish_slim_checkpoint": [[102, 128], ["tensorflow.train.Saver", "tf.train.Saver.restore", "tensorflow.Graph().as_default", "vggish_slim.define_vggish_slim", "tensorflow.global_variables", "tensorflow.Graph", "tensorflow.global_variables"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.vggish.vggish_slim.define_vggish_slim"], ["", "", "def", "load_vggish_slim_checkpoint", "(", "session", ",", "checkpoint_path", ")", ":", "\n", "  ", "\"\"\"Loads a pre-trained VGGish-compatible checkpoint.\n  This function can be used as an initialization function (referred to as\n  init_fn in TensorFlow documentation) which is called in a Session after\n  initializating all variables. When used as an init_fn, this will load\n  a pre-trained checkpoint that is compatible with the VGGish model\n  definition. Only variables defined by VGGish will be loaded.\n  Args:\n    session: an active TensorFlow session.\n    checkpoint_path: path to a file containing a checkpoint that is\n      compatible with the VGGish model definition.\n  \"\"\"", "\n", "# Get the list of names of all VGGish variables that exist in", "\n", "# the checkpoint (i.e., all inference-mode VGGish variables).", "\n", "with", "tf", ".", "Graph", "(", ")", ".", "as_default", "(", ")", ":", "\n", "    ", "define_vggish_slim", "(", "training", "=", "False", ")", "\n", "vggish_var_names", "=", "[", "v", ".", "name", "for", "v", "in", "tf", ".", "global_variables", "(", ")", "]", "\n", "\n", "# Get the list of all currently existing variables that match", "\n", "# the list of variable names we just computed.", "\n", "", "vggish_vars", "=", "[", "v", "for", "v", "in", "tf", ".", "global_variables", "(", ")", "if", "v", ".", "name", "in", "vggish_var_names", "]", "\n", "\n", "# Use a Saver to restore just the variables selected above.", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", "vggish_vars", ",", "name", "=", "'vggish_load_pretrained'", ",", "\n", "write_version", "=", "1", ")", "\n", "saver", ".", "restore", "(", "session", ",", "checkpoint_path", ")", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.__init__": [[7, 15], ["parameter_control.ParamControl.init_module_list", "parameter_control.ParamControl.init_param_group"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.init_module_list", "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.init_param_group"], ["    ", "def", "__init__", "(", "self", ",", "trainer", ",", "gradual_release", "=", "1", ",", "release_count", "=", "8", ",", "backbone_mode", "=", "\"ir\"", ")", ":", "\n", "        ", "self", ".", "trainer", "=", "trainer", "\n", "self", ".", "gradual_release", "=", "gradual_release", "\n", "self", ".", "release_count", "=", "release_count", "\n", "self", ".", "backbone_mode", "=", "backbone_mode", "\n", "self", ".", "module_list", "=", "self", ".", "init_module_list", "(", ")", "\n", "self", ".", "module_stack", "=", "self", ".", "init_param_group", "(", ")", "\n", "self", ".", "early_stop", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.init_module_list": [[16, 23], ["None"], "methods", ["None"], ["", "def", "init_module_list", "(", "self", ")", ":", "\n", "\n", "        ", "module_list", "=", "[", "[", "(", "4", ",", "10", ")", "]", ",", "[", "(", "163", ",", "187", ")", "]", ",", "[", "(", "142", ",", "163", ")", "]", "]", "\n", "if", "self", ".", "backbone_mode", "==", "\"ir_se\"", ":", "\n", "            ", "module_list", "=", "[", "[", "(", "4", ",", "10", ")", "]", ",", "[", "(", "205", ",", "235", ")", "]", ",", "[", "(", "187", ",", "205", ")", "]", "]", "\n", "\n", "", "return", "module_list", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.init_param_group": [[24, 39], ["module_stack.append", "len", "list", "list", "numpy.arange", "numpy.arange"], "methods", ["None"], ["", "def", "init_param_group", "(", "self", ")", ":", "\n", "# return {'0': slice(151, 160), '1': slice(160, 169), '2': slice(169, 178),", "\n", "#         '3': slice(178, 187), '4': slice(187, 196), '5': slice(196, 205),", "\n", "#         '6': slice(205, 235), '7': slice(4, 10)}", "\n", "        ", "module_stack", "=", "[", "]", "\n", "for", "groups", "in", "self", ".", "module_list", ":", "\n", "            ", "slice_range", "=", "[", "]", "\n", "if", "len", "(", "groups", ")", ">", "1", ":", "\n", "                ", "for", "group", "in", "groups", ":", "\n", "                    ", "slice_range", "+=", "list", "(", "np", ".", "arange", "(", "*", "group", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "slice_range", "=", "list", "(", "np", ".", "arange", "(", "*", "groups", "[", "0", "]", ")", ")", "\n", "\n", "", "module_stack", ".", "append", "(", "slice_range", ")", "\n", "", "return", "module_stack", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.get_param_group": [[40, 43], ["parameter_control.ParamControl.module_stack.pop"], "methods", ["None"], ["", "def", "get_param_group", "(", "self", ")", ":", "\n", "        ", "modules_to_release", "=", "self", ".", "module_stack", ".", "pop", "(", "0", ")", "\n", "return", "modules_to_release", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.get_current_lr": [[44, 47], ["None"], "methods", ["None"], ["", "def", "get_current_lr", "(", "self", ")", ":", "\n", "        ", "current_lr", "=", "self", ".", "trainer", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "\n", "return", "current_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.release_param": [[48, 61], ["parameter_control.ParamControl.get_param_group", "list", "parameter_control.ParamControl.trainer.init_optimizer_and_scheduler", "print", "operator.itemgetter", "list", "parameter_control.ParamControl.trainer.model.parameters"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.get_param_group", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.init_optimizer_and_scheduler"], ["", "def", "release_param", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "gradual_release", ":", "\n", "            ", "if", "self", ".", "release_count", ">", "0", ":", "\n", "                ", "indices", "=", "self", ".", "get_param_group", "(", ")", "\n", "\n", "for", "param", "in", "list", "(", "itemgetter", "(", "*", "indices", ")", "(", "list", "(", "self", ".", "trainer", ".", "model", ".", "parameters", "(", ")", ")", ")", ")", ":", "\n", "                    ", "param", ".", "requires_grad", "=", "True", "\n", "\n", "", "self", ".", "trainer", ".", "init_optimizer_and_scheduler", "(", ")", "\n", "self", ".", "release_count", "-=", "1", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"Early stopped since no further parameters to release!\"", ")", "\n", "self", ".", "early_stop", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.load_trainer": [[62, 64], ["None"], "methods", ["None"], ["", "", "", "def", "load_trainer", "(", "self", ",", "trainer", ")", ":", "\n", "        ", "self", ".", "trainer", "=", "trainer", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.__init__": [[18, 85], ["model.to", "trainer.ABAW2Trainer.init_optimizer_and_scheduler", "os.makedirs", "model.to", "trainer.ABAW2Trainer.init_optimizer_and_scheduler"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.init_optimizer_and_scheduler", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.init_optimizer_and_scheduler"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "model_name", "=", "'2d1d'", ",", "save_path", "=", "None", ",", "train_emotion", "=", "'both'", ",", "head", "=", "'multi-headed'", ",", "factor", "=", "0.1", ",", "\n", "early_stopping", "=", "100", ",", "criterion", "=", "None", ",", "milestone", "=", "[", "0", "]", ",", "patience", "=", "10", ",", "learning_rate", "=", "0.00001", ",", "device", "=", "'cpu'", ",", "num_classes", "=", "2", ",", "max_epoch", "=", "50", ",", "min_learning_rate", "=", "1e-7", ",", "\n", "emotional_dimension", "=", "None", ",", "metrics", "=", "None", ",", "verbose", "=", "False", ",", "print_training_metric", "=", "False", ",", "save_plot", "=", "False", ",", "window_length", "=", "300", ",", "\n", "load_best_at_each_epoch", "=", "False", ",", "fold", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "self", ".", "model_name", "=", "model_name", "\n", "self", ".", "save_path", "=", "save_path", "\n", "self", ".", "fold", "=", "fold", "\n", "\n", "self", ".", "window_length", "=", "window_length", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "max_epoch", "=", "max_epoch", "\n", "self", ".", "start_epoch", "=", "0", "\n", "self", ".", "early_stopping", "=", "early_stopping", "\n", "self", ".", "early_stopping_counter", "=", "self", ".", "early_stopping", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "min_learning_rate", "=", "min_learning_rate", "\n", "self", ".", "patience", "=", "patience", "\n", "self", ".", "criterion", "=", "criterion", "\n", "self", ".", "factor", "=", "factor", "\n", "self", ".", "init_optimizer_and_scheduler", "(", ")", "\n", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n", "self", ".", "device", "=", "device", "\n", "\n", "# Whether to show the information strings.", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "save_plot", "=", "save_plot", "\n", "\n", "# Whether print the metrics for training.", "\n", "self", ".", "print_training_metric", "=", "print_training_metric", "\n", "\n", "# What emotional dimensions to consider.", "\n", "self", ".", "emotional_dimension", "=", "emotional_dimension", "\n", "self", ".", "train_emotion", "=", "train_emotion", "\n", "self", ".", "head", "=", "head", "\n", "\n", "self", ".", "metrics", "=", "metrics", "\n", "\n", "# The learning rate, and the patience of schedule.", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "patience", "=", "patience", "\n", "\n", "# The networks.", "\n", "self", ".", "save_path", "=", "save_path", "\n", "os", ".", "makedirs", "(", "self", ".", "save_path", ",", "exist_ok", "=", "True", ")", "\n", "self", ".", "model", "=", "model", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "init_optimizer_and_scheduler", "(", ")", "\n", "\n", "# parameter_control", "\n", "self", ".", "milestone", "=", "milestone", "\n", "\n", "# For checkpoint", "\n", "self", ".", "fit_finished", "=", "False", "\n", "self", ".", "fold_finished", "=", "False", "\n", "self", ".", "resume", "=", "False", "\n", "self", ".", "time_fit_start", "=", "None", "\n", "self", ".", "combined_record_dict", "=", "{", "'train'", ":", "{", "}", ",", "'validate'", ":", "{", "}", "}", "\n", "self", ".", "train_losses", "=", "[", "]", "\n", "self", ".", "validate_losses", "=", "[", "]", "\n", "self", ".", "csv_filename", "=", "None", "\n", "self", ".", "best_epoch_info", "=", "None", "\n", "self", ".", "load_best_at_each_epoch", "=", "load_best_at_each_epoch", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.init_optimizer_and_scheduler": [[86, 91], ["len", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "trainer.ABAW2Trainer.get_parameters", "trainer.ABAW2Trainer.get_parameters"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.get_parameters", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.get_parameters"], ["", "def", "init_optimizer_and_scheduler", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "get_parameters", "(", ")", ")", "!=", "0", ":", "\n", "            ", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "self", ".", "get_parameters", "(", ")", ",", "lr", "=", "self", ".", "learning_rate", ",", "weight_decay", "=", "0.001", ")", "\n", "self", ".", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "ReduceLROnPlateau", "(", "self", ".", "optimizer", ",", "mode", "=", "'max'", ",", "patience", "=", "self", ".", "patience", ",", "\n", "factor", "=", "self", ".", "factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.get_parameters": [[92, 102], ["trainer.ABAW2Trainer.model.named_parameters", "params_to_update.append"], "methods", ["None"], ["", "", "def", "get_parameters", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        Get the parameters to update.\n        :return:\n        \"\"\"", "\n", "params_to_update", "=", "[", "]", "\n", "for", "name", ",", "param", "in", "self", ".", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "param", ".", "requires_grad", ":", "\n", "                ", "params_to_update", ".", "append", "(", "param", ")", "\n", "", "", "return", "params_to_update", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.train": [[103, 108], ["trainer.ABAW2Trainer.model.train", "trainer.ABAW2Trainer.loop"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.train", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.loop"], ["", "def", "train", "(", "self", ",", "data_loader", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "loss", ",", "result_dict", "=", "self", ".", "loop", "(", "data_loader", ",", "epoch", ",", "\n", "train_mode", "=", "True", ")", "\n", "return", "loss", ",", "result_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.validate": [[109, 114], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.ABAW2Trainer.model.eval", "trainer.ABAW2Trainer.loop"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.loop"], ["", "def", "validate", "(", "self", ",", "data_loader", ",", "epoch", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "self", ".", "model", ".", "eval", "(", ")", "\n", "loss", ",", "result_dict", "=", "self", ".", "loop", "(", "data_loader", ",", "epoch", ",", "train_mode", "=", "False", ")", "\n", "", "return", "loss", ",", "result_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.test": [[115, 127], ["print", "print", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.ABAW2Trainer.model.eval", "trainer.ABAW2Trainer.loop_test"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.loop_test"], ["", "def", "test", "(", "\n", "self", ",", "\n", "data_to_load", ",", "\n", "output_save_path", "\n", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"------\"", ")", "\n", "print", "(", "\"Starting testing, on device:\"", ",", "self", ".", "device", ")", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "loop_test", "(", "data_to_load", ",", "output_save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.fit": [[129, 267], ["time.time", "numpy.arange", "checkpoint_controller.save_checkpoint", "trainer.ABAW2Trainer.model.load_state_dict", "print", "print", "time.time", "print", "trainer.ABAW2Trainer.train", "trainer.ABAW2Trainer.combine_record_dict", "trainer.ABAW2Trainer.validate", "trainer.ABAW2Trainer.combine_record_dict", "trainer.ABAW2Trainer.train_losses.append", "trainer.ABAW2Trainer.validate_losses.append", "checkpoint_controller.save_log_to_csv", "trainer.ABAW2Trainer.scheduler.step", "checkpoint_controller.save_checkpoint", "copy.deepcopy", "parameter_controller.release_param", "trainer.ABAW2Trainer.model.load_state_dict", "numpy.mean", "print", "print", "print", "print", "print", "trainer.ABAW2Trainer.model.load_state_dict", "trainer.ABAW2Trainer.model.state_dict", "print", "parameter_controller.get_current_lr", "len", "numpy.mean", "torch.save", "torch.save", "torch.save", "torch.save", "copy.deepcopy", "numpy.mean", "ValueError", "trainer.ABAW2Trainer.model.state_dict", "os.path.join", "trainer.ABAW2Trainer.model.state_dict", "time.time", "int"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.save_checkpoint", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.train", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.combine_record_dict", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.validate", "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.combine_record_dict", "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.save_log_to_csv", "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.save_checkpoint", "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.release_param", "home.repos.pwc.inspect_result.sucv_ABAW2.base.parameter_control.ParamControl.get_current_lr"], ["", "", "def", "fit", "(", "\n", "self", ",", "\n", "data_to_load", ",", "\n", "num_epochs", "=", "100", ",", "\n", "min_num_epochs", "=", "10", ",", "\n", "checkpoint_controller", "=", "None", ",", "\n", "parameter_controller", "=", "None", ",", "\n", "save_model", "=", "False", "\n", ")", ":", "\n", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"------\"", ")", "\n", "print", "(", "\"Starting training, on device:\"", ",", "self", ".", "device", ")", "\n", "\n", "", "self", ".", "time_fit_start", "=", "time", ".", "time", "(", ")", "\n", "start_epoch", "=", "self", ".", "start_epoch", "\n", "\n", "if", "self", ".", "best_epoch_info", "is", "None", ":", "\n", "            ", "self", ".", "best_epoch_info", "=", "{", "\n", "'model_weights'", ":", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", ",", "\n", "'loss'", ":", "1e10", ",", "\n", "'ccc'", ":", "-", "1e10", "\n", "}", "\n", "\n", "# Loop the epochs", "\n", "", "for", "epoch", "in", "np", ".", "arange", "(", "start_epoch", ",", "num_epochs", ")", ":", "\n", "\n", "            ", "if", "self", ".", "fit_finished", ":", "\n", "                ", "if", "self", ".", "verbose", ":", "\n", "                    ", "print", "(", "\"\\nEarly Stop!\\n\"", ")", "\n", "", "break", "\n", "\n", "", "if", "epoch", "in", "self", ".", "milestone", "or", "parameter_controller", ".", "get_current_lr", "(", ")", "<", "self", ".", "min_learning_rate", ":", "\n", "                ", "parameter_controller", ".", "release_param", "(", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "self", ".", "best_epoch_info", "[", "'model_weights'", "]", ")", "\n", "\n", "if", "parameter_controller", ".", "early_stop", ":", "\n", "                    ", "break", "\n", "\n", "", "", "time_epoch_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "print", "(", "\"There are {} layers to update.\"", ".", "format", "(", "len", "(", "self", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'params'", "]", ")", ")", ")", "\n", "\n", "# Get the losses and the record dictionaries for training and validation.", "\n", "train_loss", ",", "train_record_dict", "=", "self", ".", "train", "(", "data_to_load", "[", "'train'", "]", ",", "epoch", ")", "\n", "\n", "# Combine the record to a long array for each subject.", "\n", "self", ".", "combined_record_dict", "[", "'train'", "]", "=", "self", ".", "combine_record_dict", "(", "\n", "self", ".", "combined_record_dict", "[", "'train'", "]", ",", "train_record_dict", ")", "\n", "\n", "validate_loss", ",", "validate_record_dict", "=", "self", ".", "validate", "(", "data_to_load", "[", "'validate'", "]", ",", "epoch", ")", "\n", "\n", "self", ".", "combined_record_dict", "[", "'validate'", "]", "=", "self", ".", "combine_record_dict", "(", "\n", "self", ".", "combined_record_dict", "[", "'validate'", "]", ",", "validate_record_dict", ")", "\n", "\n", "self", ".", "train_losses", ".", "append", "(", "train_loss", ")", "\n", "self", ".", "validate_losses", ".", "append", "(", "validate_loss", ")", "\n", "\n", "improvement", "=", "False", "\n", "\n", "if", "self", ".", "train_emotion", "==", "\"both\"", ":", "\n", "                ", "validate_ccc", "=", "np", ".", "mean", "(", "\n", "[", "validate_record_dict", "[", "'overall'", "]", "[", "emotion", "]", "[", "'ccc'", "]", "for", "emotion", "in", "self", ".", "emotional_dimension", "]", ")", "\n", "", "elif", "self", ".", "train_emotion", "==", "\"arousal\"", ":", "\n", "                ", "validate_ccc", "=", "np", ".", "mean", "(", "validate_record_dict", "[", "'overall'", "]", "[", "'Arousal'", "]", "[", "'ccc'", "]", ")", "\n", "", "elif", "self", ".", "train_emotion", "==", "\"valence\"", ":", "\n", "                ", "validate_ccc", "=", "np", ".", "mean", "(", "validate_record_dict", "[", "'overall'", "]", "[", "'Valence'", "]", "[", "'ccc'", "]", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "\"Unknown emotion dimension!\"", ")", "\n", "\n", "# If a lower validate loss appears.", "\n", "", "if", "validate_ccc", ">", "self", ".", "best_epoch_info", "[", "'ccc'", "]", ":", "\n", "                ", "if", "save_model", ":", "\n", "                    ", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "os", ".", "path", ".", "join", "(", "self", ".", "save_path", ",", "\"model_state_dict.pth\"", ")", ")", "\n", "\n", "", "improvement", "=", "True", "\n", "self", ".", "best_epoch_info", "=", "{", "\n", "'model_weights'", ":", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", ",", "\n", "'loss'", ":", "validate_loss", ",", "\n", "'ccc'", ":", "validate_ccc", ",", "\n", "'epoch'", ":", "epoch", ",", "\n", "'scalar_metrics'", ":", "{", "\n", "'train_loss'", ":", "train_loss", ",", "\n", "'validate_loss'", ":", "validate_loss", ",", "\n", "}", ",", "\n", "'array_metrics'", ":", "{", "\n", "'train_metric_record'", ":", "train_record_dict", "[", "'overall'", "]", ",", "\n", "'validate_metric_record'", ":", "validate_record_dict", "[", "'overall'", "]", "\n", "}", "\n", "}", "\n", "\n", "", "if", "validate_loss", "<", "0", ":", "\n", "                ", "print", "(", "'validate loss negative'", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\n", "\"\\n Fold {:2} Epoch {:2} in {:.0f}s || Train loss={:.3f} | Val loss={:.3f} | LR={:.1e} | Release_count={} | best={} | \"", "\n", "\"improvement={}-{}\"", ".", "format", "(", "\n", "self", ".", "fold", ",", "\n", "epoch", "+", "1", ",", "\n", "time", ".", "time", "(", ")", "-", "time_epoch_start", ",", "\n", "train_loss", ",", "\n", "validate_loss", ",", "\n", "self", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", ",", "\n", "parameter_controller", ".", "release_count", ",", "\n", "int", "(", "self", ".", "best_epoch_info", "[", "'epoch'", "]", ")", "+", "1", ",", "\n", "improvement", ",", "\n", "self", ".", "early_stopping_counter", ")", ")", "\n", "\n", "print", "(", "train_record_dict", "[", "'overall'", "]", ")", "\n", "print", "(", "validate_record_dict", "[", "'overall'", "]", ")", "\n", "print", "(", "\"------\"", ")", "\n", "\n", "", "checkpoint_controller", ".", "save_log_to_csv", "(", "\n", "epoch", ",", "train_record_dict", "[", "'overall'", "]", ",", "validate_record_dict", "[", "'overall'", "]", ")", "\n", "\n", "# Early stopping controller.", "\n", "if", "self", ".", "early_stopping", "and", "epoch", ">", "min_num_epochs", ":", "\n", "                ", "if", "improvement", ":", "\n", "                    ", "self", ".", "early_stopping_counter", "=", "self", ".", "early_stopping", "\n", "", "else", ":", "\n", "                    ", "self", ".", "early_stopping_counter", "-=", "1", "\n", "\n", "", "if", "self", ".", "early_stopping_counter", "<=", "0", ":", "\n", "                    ", "self", ".", "fit_finished", "=", "True", "\n", "\n", "", "", "self", ".", "scheduler", ".", "step", "(", "validate_ccc", ")", "\n", "self", ".", "start_epoch", "=", "epoch", "+", "1", "\n", "\n", "if", "self", ".", "load_best_at_each_epoch", ":", "\n", "                ", "self", ".", "model", ".", "load_state_dict", "(", "self", ".", "best_epoch_info", "[", "'model_weights'", "]", ")", "\n", "\n", "", "checkpoint_controller", ".", "save_checkpoint", "(", "self", ",", "parameter_controller", ",", "self", ".", "save_path", ")", "\n", "\n", "", "self", ".", "fit_finished", "=", "True", "\n", "checkpoint_controller", ".", "save_checkpoint", "(", "self", ",", "parameter_controller", ",", "self", ".", "save_path", ")", "\n", "\n", "self", ".", "model", ".", "load_state_dict", "(", "self", ".", "best_epoch_info", "[", "'model_weights'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.loop": [[268, 363], ["base.logger.ContinuousOutputHandlerNPYTrial", "base.logger.ContinuousOutputHandlerNPYTrial", "base.logger.ContinuousMetricsCalculatorTrial", "tqdm.tqdm.tqdm", "base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "base.logger.ContinuousMetricsCalculatorTrial.calculate_metrics", "enumerate", "len", "Y.float().to", "torch.ones_like().to", "torch.ones_like().to", "torch.ones_like().to", "torch.ones_like().to", "base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "trainer.ABAW2Trainer.criterion", "trainer.ABAW2Trainer.mean().item", "base.logger.PlotHandlerTrial", "base.logger.PlotHandlerTrial.save_output_vs_continuous_label_plot", "len", "X[].to", "X[].to", "X[].to", "X[].to", "X[].to", "X[].to", "trainer.ABAW2Trainer.optimizer.zero_grad", "len", "trainer.ABAW2Trainer.model", "trainer.ABAW2Trainer.model", "trainer.ABAW2Trainer.detach().cpu().numpy", "Y.float().to.detach().cpu().numpy", "trainer.ABAW2Trainer.backward", "trainer.ABAW2Trainer.optimizer.step", "Y.float", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "X.keys", "trainer.ABAW2Trainer.mean", "trainer.ABAW2Trainer.detach().cpu", "Y.float().to.detach().cpu", "ValueError", "trainer.ABAW2Trainer.detach", "Y.float().to.detach"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.calculate_metrics", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.save_output_vs_continuous_label_plot"], ["", "def", "loop", "(", "self", ",", "data_loader", ",", "epoch", ",", "train_mode", "=", "True", ")", ":", "\n", "        ", "running_loss", "=", "0.0", "\n", "\n", "output_handler", "=", "ContinuousOutputHandlerNPYTrial", "(", "self", ".", "emotional_dimension", ")", "\n", "continuous_label_handler", "=", "ContinuousOutputHandlerNPYTrial", "(", "self", ".", "emotional_dimension", ")", "\n", "\n", "# This object calculate the metrics, usually by root mean square error, pearson correlation", "\n", "# coefficient, and concordance correlation coefficient.", "\n", "metric_handler", "=", "ContinuousMetricsCalculatorTrial", "(", "self", ".", "metrics", ",", "self", ".", "emotional_dimension", ",", "\n", "output_handler", ",", "continuous_label_handler", ")", "\n", "total_batch_counter", "=", "0", "\n", "for", "batch_index", ",", "(", "X", ",", "Y", ",", "trials", ",", "lengths", ",", "indices", ")", "in", "tqdm", "(", "enumerate", "(", "data_loader", ")", ",", "total", "=", "len", "(", "data_loader", ")", ")", ":", "\n", "            ", "total_batch_counter", "+=", "len", "(", "trials", ")", "\n", "\n", "if", "'frame'", "in", "X", ":", "\n", "                ", "inputs", "=", "X", "[", "'frame'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'landmark'", "in", "X", ":", "\n", "                ", "inputs1", "=", "X", "[", "'landmark'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'au'", "in", "X", ":", "\n", "                ", "inputs2", "=", "X", "[", "'au'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'mfcc'", "in", "X", ":", "\n", "                ", "inputs3", "=", "X", "[", "'mfcc'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'egemaps'", "in", "X", ":", "\n", "                ", "inputs", "=", "X", "[", "'egemaps'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'vggish'", "in", "X", ":", "\n", "                ", "inputs4", "=", "X", "[", "'vggish'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "labels", "=", "Y", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "# Determine the weight for loss function", "\n", "loss_weights", "=", "torch", ".", "ones_like", "(", "labels", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "if", "train_mode", ":", "\n", "                ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "if", "self", ".", "head", "==", "\"multi-headed\"", ":", "\n", "                    ", "if", "self", ".", "train_emotion", "==", "\"both\"", ":", "\n", "                        ", "loss_weights", "[", ":", ",", ":", ",", "0", "]", "*=", "1", "\n", "loss_weights", "[", ":", ",", ":", ",", "1", "]", "*=", "1", "\n", "", "elif", "self", ".", "train_emotion", "==", "\"arousal\"", ":", "\n", "                        ", "loss_weights", "[", ":", ",", ":", ",", "0", "]", "*=", "1", "\n", "loss_weights", "[", ":", ",", ":", ",", "1", "]", "*=", "10", "\n", "", "elif", "self", ".", "train_emotion", "==", "\"valence\"", ":", "\n", "                        ", "loss_weights", "[", ":", ",", ":", ",", "0", "]", "*=", "10", "\n", "loss_weights", "[", ":", ",", ":", ",", "1", "]", "*=", "1", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "\"Unknown emotion dimention to train!\"", ")", "\n", "\n", "", "", "", "if", "len", "(", "X", ".", "keys", "(", ")", ")", ">", "1", ":", "\n", "                ", "outputs", "=", "self", ".", "model", "(", "inputs", ",", "inputs4", ",", "inputs3", ")", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "", "output_handler", ".", "update_output_for_seen_trials", "(", "outputs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "trials", ",", "indices", ",", "lengths", ")", "\n", "continuous_label_handler", ".", "update_output_for_seen_trials", "(", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "trials", ",", "indices", ",", "lengths", ")", "\n", "\n", "loss", "=", "self", ".", "criterion", "(", "outputs", ",", "labels", ",", "loss_weights", ")", "\n", "\n", "running_loss", "+=", "loss", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n", "if", "train_mode", ":", "\n", "                ", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "#  print_progress(batch_index, len(data_loader))", "\n", "\n", "", "", "epoch_loss", "=", "running_loss", "/", "total_batch_counter", "\n", "\n", "output_handler", ".", "average_trial_wise_records", "(", ")", "\n", "continuous_label_handler", ".", "average_trial_wise_records", "(", ")", "\n", "\n", "output_handler", ".", "concat_records", "(", ")", "\n", "continuous_label_handler", ".", "concat_records", "(", ")", "\n", "\n", "# Compute the root mean square error, pearson correlation coefficient and significance, and the", "\n", "# concordance correlation coefficient.", "\n", "# They are calculated by  first concatenating all the output", "\n", "# and continuous labels to two long arrays, and then calculate the metrics.", "\n", "metric_handler", ".", "calculate_metrics", "(", ")", "\n", "epoch_result_dict", "=", "metric_handler", ".", "metric_record_dict", "\n", "\n", "if", "self", ".", "save_plot", ":", "\n", "# This object plot the figures and save them.", "\n", "            ", "plot_handler", "=", "PlotHandlerTrial", "(", "self", ".", "metrics", ",", "self", ".", "emotional_dimension", ",", "epoch_result_dict", ",", "\n", "output_handler", ".", "trialwise_records", ",", "\n", "continuous_label_handler", ".", "trialwise_records", ",", "\n", "epoch", "=", "epoch", ",", "train_mode", "=", "train_mode", ",", "\n", "directory_to_save_plot", "=", "self", ".", "save_path", ")", "\n", "plot_handler", ".", "save_output_vs_continuous_label_plot", "(", ")", "\n", "\n", "", "return", "epoch_loss", ",", "epoch_result_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.loop_test": [[364, 436], ["base.logger.ContinuousOutputHandlerNPYTrial", "base.logger.ContinuousOutputHandlerNPYTrial", "base.logger.ContinuousMetricsCalculatorTrial", "tqdm.tqdm.tqdm", "base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "base.logger.ContinuousMetricsCalculatorTrial.calculate_metrics", "base.logger.PlotHandlerTrial", "base.logger.PlotHandlerTrial.save_output_vs_continuous_label_plot", "base.logger.ContinuousOutputHandlerNPYTrial.trialwise_records.items", "print", "enumerate", "len", "Y.float().to", "base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "record.items", "len", "X[].to", "X[].to", "X[].to", "X[].to", "X[].to", "X[].to", "len", "trainer.ABAW2Trainer.model", "trainer.ABAW2Trainer.model", "trainer.ABAW2Trainer.detach().cpu().numpy", "Y.float().to.detach().cpu().numpy", "pandas.DataFrame", "os.path.join", "os.makedirs", "os.path.join", "pandas.DataFrame.to_csv", "Y.float", "X.keys", "trainer.ABAW2Trainer.detach().cpu", "Y.float().to.detach().cpu", "trainer.ABAW2Trainer.detach", "Y.float().to.detach"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.concat_records", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.calculate_metrics", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.save_output_vs_continuous_label_plot", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials"], ["", "def", "loop_test", "(", "self", ",", "data_loader", ",", "output_save_path", ")", ":", "\n", "\n", "        ", "output_handler", "=", "ContinuousOutputHandlerNPYTrial", "(", "self", ".", "emotional_dimension", ")", "\n", "continuous_label_handler", "=", "ContinuousOutputHandlerNPYTrial", "(", "self", ".", "emotional_dimension", ")", "\n", "\n", "# This object calculate the metrics, usually by root mean square error, pearson correlation", "\n", "# coefficient, and concordance correlation coefficient.", "\n", "metric_handler", "=", "ContinuousMetricsCalculatorTrial", "(", "self", ".", "metrics", ",", "self", ".", "emotional_dimension", ",", "\n", "output_handler", ",", "continuous_label_handler", ")", "\n", "\n", "total_batch_counter", "=", "0", "\n", "for", "batch_index", ",", "(", "X", ",", "Y", ",", "trials", ",", "lengths", ",", "indices", ")", "in", "tqdm", "(", "enumerate", "(", "data_loader", ")", ",", "total", "=", "len", "(", "data_loader", ")", ")", ":", "\n", "            ", "total_batch_counter", "+=", "len", "(", "trials", ")", "\n", "\n", "if", "'frame'", "in", "X", ":", "\n", "                ", "inputs", "=", "X", "[", "'frame'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'landmark'", "in", "X", ":", "\n", "                ", "inputs1", "=", "X", "[", "'landmark'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'au'", "in", "X", ":", "\n", "                ", "inputs2", "=", "X", "[", "'au'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'mfcc'", "in", "X", ":", "\n", "                ", "inputs3", "=", "X", "[", "'mfcc'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'egemaps'", "in", "X", ":", "\n", "                ", "inputs", "=", "X", "[", "'egemaps'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "if", "'vggish'", "in", "X", ":", "\n", "                ", "inputs4", "=", "X", "[", "'vggish'", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "labels", "=", "Y", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "if", "len", "(", "X", ".", "keys", "(", ")", ")", ">", "1", ":", "\n", "                ", "outputs", "=", "self", ".", "model", "(", "inputs", ",", "inputs4", ",", "inputs3", ")", "\n", "", "else", ":", "\n", "                ", "outputs", "=", "self", ".", "model", "(", "inputs", ")", "\n", "\n", "", "output_handler", ".", "update_output_for_seen_trials", "(", "outputs", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "trials", ",", "indices", ",", "lengths", ")", "\n", "continuous_label_handler", ".", "update_output_for_seen_trials", "(", "labels", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "trials", ",", "indices", ",", "\n", "lengths", ")", "\n", "\n", "", "output_handler", ".", "average_trial_wise_records", "(", ")", "\n", "continuous_label_handler", ".", "average_trial_wise_records", "(", ")", "\n", "\n", "output_handler", ".", "concat_records", "(", ")", "\n", "continuous_label_handler", ".", "concat_records", "(", ")", "\n", "\n", "# Compute the root mean square error, pearson correlation coefficient and significance, and the", "\n", "# concordance correlation coefficient.", "\n", "# They are calculated by  first concatenating all the output", "\n", "# and continuous labels to two long arrays, and then calculate the metrics.", "\n", "metric_handler", ".", "calculate_metrics", "(", ")", "\n", "epoch_result_dict", "=", "metric_handler", ".", "metric_record_dict", "\n", "\n", "plot_handler", "=", "PlotHandlerTrial", "(", "self", ".", "metrics", ",", "self", ".", "emotional_dimension", ",", "epoch_result_dict", ",", "\n", "output_handler", ".", "trialwise_records", ",", "\n", "continuous_label_handler", ".", "trialwise_records", ",", "\n", "epoch", "=", "'final'", ",", "train_mode", "=", "False", ",", "\n", "directory_to_save_plot", "=", "self", ".", "save_path", ")", "\n", "plot_handler", ".", "save_output_vs_continuous_label_plot", "(", ")", "\n", "\n", "for", "trial", ",", "record", "in", "output_handler", ".", "trialwise_records", ".", "items", "(", ")", ":", "\n", "            ", "for", "emotion", ",", "pred", "in", "record", ".", "items", "(", ")", ":", "\n", "                ", "result", "=", "pd", ".", "DataFrame", "(", "{", "emotion", ":", "pred", "}", ")", "\n", "result_path", "=", "os", ".", "path", ".", "join", "(", "output_save_path", ",", "emotion", ")", "\n", "os", ".", "makedirs", "(", "result_path", ",", "exist_ok", "=", "True", ")", "\n", "result_path", "=", "os", ".", "path", ".", "join", "(", "result_path", ",", "trial", "+", "\".txt\"", ")", "\n", "result", ".", "to_csv", "(", "result_path", ",", "sep", "=", "','", ",", "index", "=", "None", ")", "\n", "\n", "", "", "print", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.combine_record_dict": [[438, 468], ["zip", "bool", "main_record_dict.items", "epoch_record_dict.items", "[].append"], "methods", ["None"], ["", "def", "combine_record_dict", "(", "self", ",", "main_record_dict", ",", "epoch_record_dict", ")", ":", "\n", "        ", "r\"\"\"\n        Append the metric recording dictionary of an epoch to a main record dictionary.\n            Each single term from epoch_record_dict will be appended to the corresponding\n            list in min_record_dict.\n        Therefore, the minimum terms in main_record_dict are lists, whose element number\n            are the epoch number.\n        \"\"\"", "\n", "\n", "# If the main record dictionary is blank, then initialize it by directly copying from epoch_record_dict.", "\n", "# Since the minimum term in epoch_record_dict is list, it is available to append further.", "\n", "if", "not", "bool", "(", "main_record_dict", ")", ":", "\n", "            ", "main_record_dict", "=", "epoch_record_dict", "\n", "return", "main_record_dict", "\n", "\n", "# Iterate the dict and append each terms from epoch_record_dict to", "\n", "# main_record_dict.", "\n", "", "for", "(", "trial", ",", "main_subject_record", ")", ",", "(", "_", ",", "epoch_subject_record", ")", "in", "zip", "(", "main_record_dict", ".", "items", "(", ")", ",", "epoch_record_dict", ".", "items", "(", ")", ")", ":", "\n", "\n", "# Go through emotions, e.g., Arousal and Valence.", "\n", "            ", "for", "emotion", "in", "self", ".", "emotional_dimension", ":", "\n", "# Go through metrics, e.g., rmse, pcc, and ccc.", "\n", "                ", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "# Go through the sub-dictionary belonging to each subject.", "\n", "                    ", "main_record_dict", "[", "trial", "]", "[", "emotion", "]", "[", "metric", "]", ".", "append", "(", "\n", "epoch_record_dict", "[", "trial", "]", "[", "emotion", "]", "[", "metric", "]", "\n", ")", "\n", "\n", "", "", "", "return", "main_record_dict", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.__init__": [[14, 27], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "metrics", ",", "emotional_dimension", ",", "epoch_result_dict", ",", "\n", "trialwise_output_dict", ",", "trialwise_continuous_label_dict", ",", "\n", "epoch", "=", "None", ",", "train_mode", "=", "None", ",", "directory_to_save_plot", "=", "None", ")", ":", "\n", "        ", "self", ".", "metrics", "=", "metrics", "\n", "self", ".", "emotional_dimension", "=", "emotional_dimension", "\n", "self", ".", "epoch_result_dict", "=", "epoch_result_dict", "\n", "\n", "self", ".", "epoch", "=", "epoch", "\n", "self", ".", "train_mode", "=", "train_mode", "\n", "self", ".", "directory_to_save_plot", "=", "directory_to_save_plot", "\n", "\n", "self", ".", "trialwise_output_dict", "=", "trialwise_output_dict", "\n", "self", ".", "trialwise_continuous_label_dict", "=", "trialwise_continuous_label_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.complete_directory_to_save_plot": [[28, 46], ["os.path.join", "os.makedirs", "os.path.join", "str"], "methods", ["None"], ["", "def", "complete_directory_to_save_plot", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        Determine the full path to save the plot.\n        \"\"\"", "\n", "if", "self", ".", "train_mode", ":", "\n", "            ", "exp_folder", "=", "\"train\"", "\n", "", "else", ":", "\n", "            ", "exp_folder", "=", "\"validate\"", "\n", "\n", "", "if", "self", ".", "epoch", "is", "None", ":", "\n", "            ", "exp_folder", "=", "\"test\"", "\n", "\n", "", "directory", "=", "os", ".", "path", ".", "join", "(", "self", ".", "directory_to_save_plot", ",", "\"plot\"", ",", "exp_folder", ",", "\"epoch_\"", "+", "str", "(", "self", ".", "epoch", ")", ")", "\n", "if", "self", ".", "epoch", "==", "\"test\"", ":", "\n", "            ", "directory", "=", "os", ".", "path", ".", "join", "(", "self", ".", "directory_to_save_plot", ",", "\"plot\"", ",", "exp_folder", ")", "\n", "\n", "", "os", ".", "makedirs", "(", "directory", ",", "exist_ok", "=", "True", ")", "\n", "return", "directory", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.save_output_vs_continuous_label_plot": [[47, 70], ["zip", "logger.PlotHandlerTrial.trialwise_output_dict.items", "logger.PlotHandlerTrial.trialwise_continuous_label_dict.items", "logger.PlotHandlerTrial.complete_directory_to_save_plot", "os.path.join", "logger.PlotHandlerTrial.plot_and_save", "len", "ylim_low.append", "ylim_high.append", "min", "max", "min", "max", "min", "min", "max", "max"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.complete_directory_to_save_plot", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.plot_and_save"], ["", "def", "save_output_vs_continuous_label_plot", "(", "self", ")", ":", "\n", "        ", "r\"\"\"\n        Plot the output versus continuous label figures for each session.\n        \"\"\"", "\n", "\n", "for", "(", "trial", ",", "output_record", ")", ",", "(", "_", ",", "label_record", ")", "in", "zip", "(", "self", ".", "trialwise_output_dict", ".", "items", "(", ")", ",", "self", ".", "trialwise_continuous_label_dict", ".", "items", "(", ")", ")", ":", "\n", "\n", "            ", "complete_directory", "=", "self", ".", "complete_directory_to_save_plot", "(", ")", "\n", "\n", "plot_filename", "=", "trial", "\n", "full_plot_filename", "=", "os", ".", "path", ".", "join", "(", "complete_directory", ",", "plot_filename", "+", "\".jpg\"", ")", "\n", "\n", "# Find the y ranges for subplot with better clarity.", "\n", "if", "len", "(", "self", ".", "emotional_dimension", ")", ">", "1", ":", "\n", "                ", "ylim_low", ",", "ylim_high", "=", "[", "]", ",", "[", "]", "\n", "for", "emotion", "in", "self", ".", "emotional_dimension", ":", "\n", "                    ", "ylim_low", ".", "append", "(", "min", "(", "min", "(", "output_record", "[", "emotion", "]", ")", ",", "min", "(", "label_record", "[", "emotion", "]", ")", ")", ")", "\n", "ylim_high", ".", "append", "(", "max", "(", "max", "(", "output_record", "[", "emotion", "]", ")", ",", "max", "(", "label_record", "[", "emotion", "]", ")", ")", ")", "\n", "", "ylim_low", ",", "ylim_high", "=", "min", "(", "ylim_low", ")", "*", "1.15", ",", "max", "(", "ylim_high", ")", "*", "1.15", "\n", "", "else", ":", "\n", "                ", "ylim_low", ",", "ylim_high", "=", "None", ",", "None", "\n", "\n", "", "self", ".", "plot_and_save", "(", "full_plot_filename", ",", "trial", ",", "output_record", ",", "label_record", ",", "ylim_low", ",", "ylim_high", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.PlotHandlerTrial.plot_and_save": [[71, 107], ["plt.subplots", "enumerate", "fig.tight_layout", "plt.savefig", "plt.close", "len", "result_list.append", "len", "ax[].plot", "ax[].plot", "ax[].set_ylim", "ax[].set_xlabel", "ax[].set_ylabel", "ax[].legend", "ax[].title.set_text", "ax.plot", "ax.plot", "ax.set_xlabel", "ax.set_ylabel", "ax.legend", "ax.title.set_text"], "methods", ["None"], ["", "", "def", "plot_and_save", "(", "self", ",", "full_plot_filename", ",", "trial", ",", "output", ",", "continuous_label", ",", "ylim_low", "=", "None", ",", "ylim_high", "=", "None", ")", ":", "\n", "        ", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "len", "(", "self", ".", "emotional_dimension", ")", ",", "1", ")", "\n", "\n", "for", "index", ",", "emotion", "in", "enumerate", "(", "self", ".", "emotional_dimension", ")", ":", "\n", "            ", "result_list", "=", "[", "]", "\n", "\n", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "                ", "result", "=", "self", ".", "epoch_result_dict", "[", "trial", "]", "[", "emotion", "]", "[", "metric", "]", "[", "0", "]", "\n", "# The pcc usually have two output, one for value and one for confidence. So", "\n", "# here we only read and the value and discard the confidence.", "\n", "if", "metric", "==", "\"pcc\"", ":", "\n", "                    ", "result", "=", "self", ".", "epoch_result_dict", "[", "trial", "]", "[", "emotion", "]", "[", "metric", "]", "[", "0", "]", "[", "0", "]", "\n", "", "result_list", ".", "append", "(", "result", ")", "\n", "\n", "", "if", "len", "(", "self", ".", "emotional_dimension", ")", ">", "1", ":", "\n", "# Plot the sub-figures, each for one emotional dimension.", "\n", "                ", "ax", "[", "index", "]", ".", "plot", "(", "output", "[", "emotion", "]", ",", "\"r-\"", ",", "label", "=", "\"Output\"", ")", "\n", "ax", "[", "index", "]", ".", "plot", "(", "continuous_label", "[", "emotion", "]", ",", "\"g-\"", ",", "label", "=", "\"Label\"", ")", "\n", "ax", "[", "index", "]", ".", "set_ylim", "(", "[", "ylim_low", ",", "ylim_high", "]", ")", "\n", "ax", "[", "index", "]", ".", "set_xlabel", "(", "\"Sample\"", ")", "\n", "ax", "[", "index", "]", ".", "set_ylabel", "(", "\"Value\"", ")", "\n", "ax", "[", "index", "]", ".", "legend", "(", "loc", "=", "\"upper right\"", ",", "framealpha", "=", "0.2", ")", "\n", "ax", "[", "index", "]", ".", "title", ".", "set_text", "(", "\n", "\"{}: rmse={:.3f}, pcc={:.3f}, ccc={:.3f}\"", ".", "format", "(", "emotion", ",", "*", "result_list", ")", ")", "\n", "", "else", ":", "\n", "                ", "ax", ".", "plot", "(", "output", "[", "emotion", "]", ",", "\"r-\"", ",", "label", "=", "\"Output\"", ")", "\n", "ax", ".", "plot", "(", "continuous_label", "[", "emotion", "]", ",", "\"g-\"", ",", "label", "=", "\"Label\"", ")", "\n", "ax", ".", "set_xlabel", "(", "\"Sample\"", ")", "\n", "ax", ".", "set_ylabel", "(", "\"Value\"", ")", "\n", "ax", ".", "legend", "(", "loc", "=", "\"upper right\"", ",", "framealpha", "=", "0.2", ")", "\n", "ax", ".", "title", ".", "set_text", "(", "\n", "\"{}: rmse={:.3f}, pcc={:.3f}, ccc={:.3f}\"", ".", "format", "(", "emotion", ",", "*", "result_list", ")", ")", "\n", "", "", "fig", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "full_plot_filename", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.__init__": [[122, 134], ["logger.ConcordanceCorrelationCoefficient.generate_combination_pair", "logger.ConcordanceCorrelationCoefficient.generate_cnk_matrix", "logger.ConcordanceCorrelationCoefficient.calculate_paired_ccc", "logger.ConcordanceCorrelationCoefficient.calculate_rator_wise_agreement", "logger.ConcordanceCorrelationCoefficient.calculate_mean_data", "logger.ConcordanceCorrelationCoefficient.calculate_weight", "logger.ConcordanceCorrelationCoefficient.perform_centering"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.generate_combination_pair", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.generate_cnk_matrix", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_paired_ccc", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_rator_wise_agreement", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_mean_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_weight", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.perform_centering"], ["def", "__init__", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "data", "=", "data", "\n", "if", "data", ".", "shape", "[", "0", "]", ">", "data", ".", "shape", "[", "1", "]", ":", "\n", "            ", "self", ".", "data", "=", "data", ".", "T", "\n", "", "self", ".", "rator_number", "=", "self", ".", "data", ".", "shape", "[", "0", "]", "\n", "self", ".", "combination_list", "=", "self", ".", "generate_combination_pair", "(", ")", "\n", "self", ".", "cnk_matrix", "=", "self", ".", "generate_cnk_matrix", "(", ")", "\n", "self", ".", "ccc", "=", "self", ".", "calculate_paired_ccc", "(", ")", "\n", "self", ".", "agreement", "=", "self", ".", "calculate_rator_wise_agreement", "(", ")", "\n", "self", ".", "mean_data", "=", "self", ".", "calculate_mean_data", "(", ")", "\n", "self", ".", "weight", "=", "self", ".", "calculate_weight", "(", ")", "\n", "self", ".", "centered_data", "=", "self", ".", "perform_centering", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.perform_centering": [[135, 142], ["numpy.repeat"], "methods", ["None"], ["", "def", "perform_centering", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The centering is done by directly average the shifted and weighted data.\n        :return: (ndarray), the centered  data.\n        \"\"\"", "\n", "centered_data", "=", "self", ".", "data", "-", "np", ".", "repeat", "(", "self", ".", "mean_data", "[", ":", ",", "np", ".", "newaxis", "]", ",", "self", ".", "data", ".", "shape", "[", "1", "]", ",", "axis", "=", "1", ")", "+", "self", ".", "weight", "\n", "return", "centered_data", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_weight": [[143, 151], ["numpy.sum", "numpy.sum"], "methods", ["None"], ["", "def", "calculate_weight", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        The weight of the m continuous labels. It will be used to weight (actually translate) the data when\n            performing the final step.\n        :return: (float), the weight of the given m continuous labels.\n        \"\"\"", "\n", "weight", "=", "np", ".", "sum", "(", "(", "self", ".", "mean_data", "*", "self", ".", "agreement", ")", "/", "np", ".", "sum", "(", "self", ".", "agreement", ")", ")", "\n", "return", "weight", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_mean_data": [[152, 159], ["numpy.mean"], "methods", ["None"], ["", "def", "calculate_mean_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        A directly average of data.\n        :return: (ndarray), the averaged data.\n        \"\"\"", "\n", "mean_data", "=", "np", ".", "mean", "(", "self", ".", "data", ",", "axis", "=", "1", ")", "\n", "return", "mean_data", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.generate_combination_pair": [[160, 173], ["range", "numpy.asarray", "numpy.arange", "combination_list.append"], "methods", ["None"], ["", "def", "generate_combination_pair", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generate all possible combinations of Cn2.\n        :return: (ndarray), the combination list of Cn2.\n        \"\"\"", "\n", "n", "=", "self", ".", "rator_number", "\n", "combination_list", "=", "[", "]", "\n", "\n", "for", "boy", "in", "range", "(", "n", "-", "1", ")", ":", "\n", "            ", "for", "girl", "in", "np", ".", "arange", "(", "boy", "+", "1", ",", "n", ",", "1", ")", ":", "\n", "                ", "combination_list", ".", "append", "(", "[", "boy", ",", "girl", "]", ")", "\n", "\n", "", "", "return", "np", ".", "asarray", "(", "combination_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.generate_cnk_matrix": [[174, 189], ["numpy.zeros", "range", "numpy.zeros.astype", "numpy.concatenate", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "generate_cnk_matrix", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Generate the Cn2 matrix. The j-th column of the matrix records all the possible candidate\n            to the j-th rater. So that for the j-th column, we can acquire all the possible unrepeated\n            combination for the j-th rater.\n        :return:\n        \"\"\"", "\n", "total", "=", "self", ".", "rator_number", "\n", "cnk_matrix", "=", "np", ".", "zeros", "(", "(", "total", "-", "1", ",", "total", ")", ")", "\n", "\n", "for", "column", "in", "range", "(", "total", ")", ":", "\n", "            ", "cnk_matrix", "[", ":", ",", "column", "]", "=", "np", ".", "concatenate", "(", "(", "np", ".", "where", "(", "self", ".", "combination_list", "[", ":", ",", "0", "]", "==", "column", ")", "[", "0", "]", ",", "\n", "np", ".", "where", "(", "self", ".", "combination_list", "[", ":", ",", "1", "]", "==", "column", ")", "[", "0", "]", ")", ")", "\n", "\n", "", "return", "cnk_matrix", ".", "astype", "(", "int", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_ccc": [[190, 210], ["numpy.nanmean", "numpy.nanmean", "numpy.nanmean", "numpy.nansum", "numpy.nansum", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "calculate_ccc", "(", "x", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Calculate the CCC.\n        :param x: (ndarray), an 1xn array.\n        :param y: (ndarray), another 1xn array.\n        :return: the CCC.\n        \"\"\"", "\n", "\n", "x_mean", "=", "np", ".", "nanmean", "(", "x", ")", "\n", "y_mean", "=", "np", ".", "nanmean", "(", "y", ")", "\n", "covariance", "=", "np", ".", "nanmean", "(", "(", "x", "-", "x_mean", ")", "*", "(", "y", "-", "y_mean", ")", ")", "\n", "# Make it consistent with Matlab's nanvar (division by len(x)-1, not len(x)))", "\n", "x_var", "=", "1.0", "/", "(", "len", "(", "x", ")", "-", "1", ")", "*", "np", ".", "nansum", "(", "(", "x", "-", "x_mean", ")", "**", "2", ")", "\n", "y_var", "=", "1.0", "/", "(", "len", "(", "y", ")", "-", "1", ")", "*", "np", ".", "nansum", "(", "(", "y", "-", "y_mean", ")", "**", "2", ")", "\n", "\n", "concordance_correlation_coefficient", "=", "(", "2", "*", "covariance", ")", "/", "(", "x_var", "+", "y_var", "+", "(", "x_mean", "-", "y_mean", ")", "**", "2", "+", "1e-100", ")", "\n", "\n", "return", "concordance_correlation_coefficient", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_paired_ccc": [[211, 222], ["numpy.zeros", "range", "len", "logger.ConcordanceCorrelationCoefficient.calculate_ccc"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_ccc"], ["", "def", "calculate_paired_ccc", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Calculate the CCC for all the pairs from the combination list.\n        :return: (ndarray), the CCC for each combinations.\n        \"\"\"", "\n", "ccc", "=", "np", ".", "zeros", "(", "(", "self", ".", "combination_list", ".", "shape", "[", "0", "]", ")", ")", "\n", "for", "index", "in", "range", "(", "len", "(", "self", ".", "combination_list", ")", ")", ":", "\n", "            ", "ccc", "[", "index", "]", "=", "self", ".", "calculate_ccc", "(", "self", ".", "data", "[", "self", ".", "combination_list", "[", "index", ",", "0", "]", ",", ":", "]", ",", "\n", "self", ".", "data", "[", "self", ".", "combination_list", "[", "index", ",", "1", "]", ",", ":", "]", ")", "\n", "\n", "", "return", "ccc", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_rator_wise_agreement": [[223, 235], ["numpy.zeros", "range", "numpy.mean"], "methods", ["None"], ["", "def", "calculate_rator_wise_agreement", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Calculate the inter-rater CCC agreement.\n        :return: (ndarray), a array recording the CCC agreement of each single rater to all the rest raters.\n        \"\"\"", "\n", "\n", "ccc_agreement", "=", "np", ".", "zeros", "(", "self", ".", "rator_number", ")", "\n", "\n", "for", "index", "in", "range", "(", "self", ".", "rator_number", ")", ":", "\n", "            ", "ccc_agreement", "[", "index", "]", "=", "np", ".", "mean", "(", "self", ".", "ccc", "[", "self", ".", "cnk_matrix", "[", ":", ",", "index", "]", "]", ")", "\n", "\n", "", "return", "ccc_agreement", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.__init__": [[238, 243], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "emotion_dimension", ")", ":", "\n", "        ", "self", ".", "emotion_dimension", "=", "emotion_dimension", "\n", "self", ".", "seen_trials", "=", "[", "]", "\n", "self", ".", "trialwise_records", "=", "{", "}", "\n", "self", ".", "partition_records", "=", "{", "emotion", ":", "[", "]", "for", "emotion", "in", "self", ".", "emotion_dimension", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.update_output_for_seen_trials": [[244, 259], ["enumerate", "enumerate", "logger.ContinuousOutputHandlerNPYTrial.seen_trials.append", "logger.ContinuousOutputHandlerNPYTrial.create_list_for_a_trial", "enumerate", "[].append"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.create_list_for_a_trial"], ["", "def", "update_output_for_seen_trials", "(", "self", ",", "output", ",", "trials", ",", "indices", ",", "lengths", ")", ":", "\n", "\n", "        ", "for", "i", ",", "trial", "in", "enumerate", "(", "trials", ")", ":", "\n", "\n", "# If this is the first time to record the output for trial", "\n", "            ", "if", "trial", "not", "in", "self", ".", "seen_trials", ":", "\n", "                ", "self", ".", "seen_trials", ".", "append", "(", "trial", ")", "\n", "self", ".", "trialwise_records", "[", "trial", "]", "=", "self", ".", "create_list_for_a_trial", "(", "lengths", "[", "i", "]", ")", "\n", "\n", "", "index", "=", "indices", "[", "i", "]", "\n", "for", "j", ",", "emotion", "in", "enumerate", "(", "self", ".", "emotion_dimension", ")", ":", "\n", "                ", "for", "k", ",", "data", "in", "enumerate", "(", "output", "[", "i", ",", ":", ",", "j", "]", ")", ":", "\n", "                    ", "if", "k", "==", "lengths", "[", "i", "]", ":", "\n", "                        ", "break", "\n", "", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", "[", "index", "[", "k", "]", "]", ".", "append", "(", "output", "[", "i", ",", "k", ",", "j", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.average_trial_wise_records": [[260, 271], ["len", "range", "numpy.asarray", "statistics.mean"], "methods", ["None"], ["", "", "", "", "def", "average_trial_wise_records", "(", "self", ")", ":", "\n", "\n", "        ", "for", "trial", "in", "self", ".", "seen_trials", ":", "\n", "            ", "for", "emotion", "in", "self", ".", "emotion_dimension", ":", "\n", "                ", "length", "=", "len", "(", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "length", ")", ":", "\n", "                    ", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", "[", "i", "]", "=", "statistics", ".", "mean", "(", "\n", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", "[", "i", "]", ")", "\n", "\n", "", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", "=", "np", ".", "asarray", "(", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.concat_records": [[272, 279], ["numpy.asarray", "logger.ContinuousOutputHandlerNPYTrial.partition_records[].extend"], "methods", ["None"], ["", "", "", "def", "concat_records", "(", "self", ")", ":", "\n", "        ", "for", "trial", "in", "self", ".", "seen_trials", ":", "\n", "            ", "for", "emotion", "in", "self", ".", "emotion_dimension", ":", "\n", "                ", "self", ".", "partition_records", "[", "emotion", "]", ".", "extend", "(", "self", ".", "trialwise_records", "[", "trial", "]", "[", "emotion", "]", ")", "\n", "\n", "", "", "for", "emotion", "in", "self", ".", "emotion_dimension", ":", "\n", "            ", "self", ".", "partition_records", "[", "emotion", "]", "=", "np", ".", "asarray", "(", "self", ".", "partition_records", "[", "emotion", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousOutputHandlerNPYTrial.create_list_for_a_trial": [[280, 283], ["range"], "methods", ["None"], ["", "", "def", "create_list_for_a_trial", "(", "self", ",", "length", ")", ":", "\n", "        ", "trial_record", "=", "{", "emotion", ":", "[", "[", "]", "for", "i", "in", "range", "(", "length", ")", "]", "for", "emotion", "in", "self", ".", "emotion_dimension", "}", "\n", "return", "trial_record", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.__init__": [[290, 310], ["logger.ContinuousMetricsCalculatorTrial.init_metric_record_dict"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.init_metric_record_dict"], ["def", "__init__", "(", "\n", "self", ",", "\n", "metrics", ",", "\n", "emotional_dimension", ",", "\n", "output_handler", ",", "\n", "continuous_label_handler", ",", "\n", ")", ":", "\n", "\n", "# What metrics to calculate.", "\n", "        ", "self", ".", "metrics", "=", "metrics", "\n", "\n", "# What emotional dimensions to consider.", "\n", "self", ".", "emotional_dimension", "=", "emotional_dimension", "\n", "\n", "# The instances saving the data for evaluation.", "\n", "self", ".", "output_handler", "=", "output_handler", "\n", "self", ".", "continuous_label_handler", "=", "continuous_label_handler", "\n", "\n", "# Initialize the dictionary for saving the metric results.", "\n", "self", ".", "metric_record_dict", "=", "self", ".", "init_metric_record_dict", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.get_partitionwise_output_and_continuous_label": [[311, 314], ["None"], "methods", ["None"], ["", "def", "get_partitionwise_output_and_continuous_label", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output_handler", ".", "partition_records", ",", "self", ".", "continuous_label_handler", ".", "partition_records", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.get_trialwise_output_and_continuous_label": [[315, 318], ["None"], "methods", ["None"], ["", "def", "get_trialwise_output_and_continuous_label", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "output_handler", ".", "trialwise_records", ",", "self", ".", "continuous_label_handler", ".", "trialwise_records", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.init_metric_record_dict": [[319, 323], ["logger.ContinuousMetricsCalculatorTrial.get_trialwise_output_and_continuous_label"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.get_trialwise_output_and_continuous_label"], ["", "def", "init_metric_record_dict", "(", "self", ")", ":", "\n", "        ", "trialwise_dict", ",", "_", "=", "self", ".", "get_trialwise_output_and_continuous_label", "(", ")", "\n", "metric_record_dict", "=", "{", "key", ":", "[", "]", "for", "key", "in", "trialwise_dict", "}", "\n", "return", "metric_record_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.calculator": [[324, 335], ["numpy.sqrt", "scipy.stats.pearsonr", "logger.ConcordanceCorrelationCoefficient.calculate_ccc", "ValueError"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ConcordanceCorrelationCoefficient.calculate_ccc"], ["", "@", "staticmethod", "\n", "def", "calculator", "(", "output", ",", "label", ",", "metric", ")", ":", "\n", "        ", "if", "metric", "==", "\"rmse\"", ":", "\n", "            ", "result", "=", "np", ".", "sqrt", "(", "(", "(", "output", "-", "label", ")", "**", "2", ")", ".", "mean", "(", ")", ")", "\n", "", "elif", "metric", "==", "\"pcc\"", ":", "\n", "            ", "result", "=", "pearsonr", "(", "output", ",", "label", ")", "\n", "", "elif", "metric", "==", "\"ccc\"", ":", "\n", "            ", "result", "=", "ConcordanceCorrelationCoefficient", ".", "calculate_ccc", "(", "output", ",", "label", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Metric {} is not defined.\"", ".", "format", "(", "metric", ")", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.calculate_metrics": [[336, 375], ["logger.ContinuousMetricsCalculatorTrial.get_trialwise_output_and_continuous_label", "logger.ContinuousMetricsCalculatorTrial.get_partitionwise_output_and_continuous_label", "zip", "trialwise_output.items", "trialwise_continuous_label.items", "enumerate", "logger.ContinuousMetricsCalculatorTrial.calculator", "logger.ContinuousMetricsCalculatorTrial.calculator", "partitionwise_dict[].append", "partitionwise_dict[].append"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.get_trialwise_output_and_continuous_label", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.get_partitionwise_output_and_continuous_label", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.calculator", "home.repos.pwc.inspect_result.sucv_ABAW2.base.logger.ContinuousMetricsCalculatorTrial.calculator"], ["", "def", "calculate_metrics", "(", "self", ")", ":", "\n", "\n", "# Load the data for three scenarios.", "\n", "# They will all be evaluated.", "\n", "        ", "trialwise_output", ",", "trialwise_continuous_label", "=", "self", ".", "get_trialwise_output_and_continuous_label", "(", ")", "\n", "partitionwise_output", ",", "partitionwise_continuous_label", "=", "self", ".", "get_partitionwise_output_and_continuous_label", "(", ")", "\n", "\n", "for", "(", "trial_id", ",", "output", ")", ",", "(", "_", ",", "label", ")", "in", "zip", "(", "\n", "trialwise_output", ".", "items", "(", ")", ",", "trialwise_continuous_label", ".", "items", "(", ")", ")", ":", "\n", "\n", "            ", "trial_record_dict", "=", "{", "key", ":", "{", "}", "for", "key", "in", "self", ".", "emotional_dimension", "}", "\n", "\n", "for", "column", ",", "emotion", "in", "enumerate", "(", "self", ".", "emotional_dimension", ")", ":", "\n", "                ", "result_dict", "=", "{", "metric", ":", "[", "]", "for", "metric", "in", "self", ".", "metrics", "}", "\n", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "                    ", "result", "=", "self", ".", "calculator", "(", "output", "[", "emotion", "]", ",", "label", "[", "emotion", "]", ",", "metric", ")", "\n", "result_dict", "[", "metric", "]", "=", "[", "result", "]", "\n", "# if metric == \"pcc\":", "\n", "#     result_dict[metric] = [result]", "\n", "", "trial_record_dict", "[", "emotion", "]", "=", "result_dict", "\n", "", "self", ".", "metric_record_dict", "[", "trial_id", "]", "=", "trial_record_dict", "\n", "\n", "# Partition-wise evaluation", "\n", "", "overall_records", "=", "{", "emotion", ":", "[", "]", "for", "emotion", "in", "self", ".", "emotional_dimension", "}", "\n", "for", "emotion", "in", "self", ".", "emotional_dimension", ":", "\n", "            ", "partitionwise_dict", "=", "{", "metric", ":", "[", "]", "for", "metric", "in", "self", ".", "metrics", "}", "\n", "\n", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "                ", "result", "=", "self", ".", "calculator", "(", "partitionwise_output", "[", "emotion", "]", ",", "partitionwise_continuous_label", "[", "emotion", "]", ",", "\n", "metric", ")", "\n", "\n", "if", "metric", "==", "\"pcc\"", ":", "\n", "                    ", "partitionwise_dict", "[", "metric", "]", ".", "append", "(", "result", ")", "\n", "", "else", ":", "\n", "                    ", "partitionwise_dict", "[", "metric", "]", ".", "append", "(", "[", "result", "]", ")", "\n", "\n", "", "", "overall_records", "[", "emotion", "]", "=", "partitionwise_dict", "\n", "\n", "", "self", ".", "metric_record_dict", "[", "'overall'", "]", "=", "overall_records", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Arranger.__init__": [[14, 21], ["os.path.join", "base.utils.load_single_pkl", "base.utils.load_single_pkl"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.load_single_pkl", "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.load_single_pkl"], ["    ", "def", "__init__", "(", "self", ",", "dataset_path", ",", "window_length", "=", "300", ",", "hop_length", "=", "300", ",", "debug", "=", "0", ")", ":", "\n", "        ", "self", ".", "dataset_path", "=", "os", ".", "path", ".", "join", "(", "dataset_path", ",", "\"npy_data\"", ")", "\n", "self", ".", "dataset_info", "=", "load_single_pkl", "(", "directory", "=", "dataset_path", ",", "filename", "=", "\"dataset_info\"", ")", "\n", "self", ".", "mean_std_info", "=", "load_single_pkl", "(", "directory", "=", "dataset_path", ",", "filename", "=", "\"mean_std_dict\"", ")", "\n", "self", ".", "window_length", "=", "window_length", "\n", "self", ".", "hop_length", "=", "hop_length", "\n", "self", ".", "debug", "=", "debug", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Arranger.generate_partition_dict_for_cross_validation": [[22, 59], ["list", "list", "list", "numpy.roll", "list", "enumerate", "partition_dict[].keys", "partition_dict[].keys", "partition_dict[].keys", "numpy.arange", "slice", "slice", "slice", "slice", "slice", "len", "operator.itemgetter", "new_partition_dict[].update", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "generate_partition_dict_for_cross_validation", "(", "partition_dict", ",", "fold", ")", ":", "\n", "        ", "new_partition_dict", "=", "{", "'Train_Set'", ":", "{", "}", ",", "'Validation_Set'", ":", "{", "}", ",", "'Target_Set'", ":", "{", "}", "}", "\n", "partition_pool", "=", "{", "**", "partition_dict", "[", "'Train_Set'", "]", ",", "**", "partition_dict", "[", "'Validation_Set'", "]", "}", "\n", "\n", "trials_of_train_set", "=", "list", "(", "partition_dict", "[", "'Train_Set'", "]", ".", "keys", "(", ")", ")", "\n", "trials_of_original_validate_set", "=", "list", "(", "partition_dict", "[", "'Validation_Set'", "]", ".", "keys", "(", ")", ")", "\n", "trials_of_putative_test_set", "=", "list", "(", "partition_dict", "[", "'Target_Set'", "]", ".", "keys", "(", ")", ")", "\n", "\n", "fold_0_trials", "=", "trials_of_train_set", "[", "slice", "(", "0", ",", "70", ")", "]", "\n", "fold_1_trials", "=", "trials_of_train_set", "[", "slice", "(", "70", ",", "140", ")", "]", "\n", "fold_2_trials", "=", "trials_of_train_set", "[", "slice", "(", "140", ",", "210", ")", "]", "\n", "fold_3_trials", "=", "trials_of_train_set", "[", "slice", "(", "210", ",", "280", ")", "]", "\n", "fold_4_trials", "=", "trials_of_train_set", "[", "slice", "(", "280", ",", "351", ")", "]", "\n", "fold_5_trials", "=", "trials_of_original_validate_set", "\n", "\n", "fold_n_trials", "=", "[", "\n", "fold_0_trials", ",", "\n", "fold_1_trials", ",", "\n", "fold_2_trials", ",", "\n", "fold_3_trials", ",", "\n", "fold_4_trials", ",", "\n", "fold_5_trials", "\n", "]", "\n", "\n", "fold_index", "=", "np", ".", "roll", "(", "np", ".", "arange", "(", "len", "(", "fold_n_trials", ")", ")", ",", "fold", ")", "\n", "ordered_trials", "=", "list", "(", "itemgetter", "(", "*", "fold_index", ")", "(", "fold_n_trials", ")", ")", "\n", "\n", "for", "nth_fold", ",", "trials_of_a_fold", "in", "enumerate", "(", "ordered_trials", ")", ":", "\n", "            ", "for", "trial", "in", "trials_of_a_fold", ":", "\n", "                ", "partition", "=", "\"Train_Set\"", "\n", "if", "nth_fold", "==", "len", "(", "fold_n_trials", ")", "-", "1", ":", "\n", "                    ", "partition", "=", "\"Validation_Set\"", "\n", "", "new_partition_dict", "[", "partition", "]", ".", "update", "(", "{", "trial", ":", "partition_pool", "[", "trial", "]", "}", ")", "\n", "\n", "", "", "new_partition_dict", "[", "'Target_Set'", "]", "=", "partition_dict", "[", "'Target_Set'", "]", "\n", "return", "new_partition_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Arranger.resample_according_to_window_and_hop_length": [[60, 100], ["dataset.ABAW2_VA_Arranger.generate_partition_dict_for_cross_validation", "dataset.ABAW2_VA_Arranger.items", "trials.items", "numpy.arange", "os.path.join", "sampled_list[].append", "numpy.arange", "os.path.join", "sampled_list[].append", "numpy.arange", "os.path.join", "sampled_list[].append"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Arranger.generate_partition_dict_for_cross_validation"], ["", "def", "resample_according_to_window_and_hop_length", "(", "self", ",", "fold", ")", ":", "\n", "        ", "partition_dict", "=", "self", ".", "dataset_info", "[", "'partition'", "]", "\n", "\n", "partition_dict", "=", "self", ".", "generate_partition_dict_for_cross_validation", "(", "partition_dict", ",", "fold", ")", "\n", "sampled_list", "=", "{", "'Train_Set'", ":", "[", "]", ",", "'Validation_Set'", ":", "[", "]", ",", "'Target_Set'", ":", "[", "]", "}", "\n", "\n", "for", "partition", ",", "trials", "in", "partition_dict", ".", "items", "(", ")", ":", "\n", "            ", "trial_count", "=", "0", "\n", "for", "trial", ",", "length", "in", "trials", ".", "items", "(", ")", ":", "\n", "\n", "                ", "start", "=", "0", "\n", "end", "=", "start", "+", "self", ".", "window_length", "\n", "\n", "if", "end", "<", "length", ":", "\n", "# Windows before the last one", "\n", "                    ", "while", "end", "<", "length", ":", "\n", "                        ", "indices", "=", "np", ".", "arange", "(", "start", ",", "end", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "trial", ")", "\n", "sampled_list", "[", "partition", "]", ".", "append", "(", "[", "path", ",", "trial", ",", "indices", ",", "length", "]", ")", "\n", "start", "=", "start", "+", "self", ".", "hop_length", "\n", "end", "=", "start", "+", "self", ".", "window_length", "\n", "\n", "# The last window ends with the trial length, which ensures that no data are wasted.", "\n", "", "start", "=", "length", "-", "self", ".", "window_length", "\n", "end", "=", "length", "\n", "indices", "=", "np", ".", "arange", "(", "start", ",", "end", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "trial", ")", "\n", "sampled_list", "[", "partition", "]", ".", "append", "(", "[", "path", ",", "trial", ",", "indices", ",", "length", "]", ")", "\n", "", "else", ":", "\n", "                    ", "end", "=", "length", "\n", "indices", "=", "np", ".", "arange", "(", "start", ",", "end", ")", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "trial", ")", "\n", "sampled_list", "[", "partition", "]", ".", "append", "(", "[", "path", ",", "trial", ",", "indices", ",", "length", "]", ")", "\n", "\n", "", "trial_count", "+=", "1", "\n", "\n", "if", "self", ".", "debug", "and", "trial_count", ">=", "self", ".", "debug", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "return", "sampled_list", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.__init__": [[103, 115], ["dataset.ABAW2_VA_Dataset.get_partition_name_from_mode", "dataset.ABAW2_VA_Dataset.get_3D_transforms"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.get_partition_name_from_mode", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.get_3D_transforms"], ["    ", "def", "__init__", "(", "self", ",", "data_list", ",", "time_delay", "=", "0", ",", "emotion", "=", "\"both\"", ",", "head", "=", "\"multi_head\"", ",", "modality", "=", "[", "'frame'", "]", ",", "window_length", "=", "300", ",", "mode", "=", "'train'", ",", "fold", "=", "0", ",", "mean_std_info", "=", "None", ")", ":", "\n", "        ", "self", ".", "data_list", "=", "data_list", "\n", "self", ".", "time_delay", "=", "time_delay", "\n", "self", ".", "emotion", "=", "emotion", "\n", "self", ".", "head", "=", "head", "\n", "self", ".", "modality", "=", "modality", "\n", "self", ".", "window_length", "=", "window_length", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "partition", "=", "self", ".", "get_partition_name_from_mode", "(", ")", "\n", "self", ".", "fold", "=", "fold", "\n", "self", ".", "mean_std_info", "=", "mean_std_info", "\n", "self", ".", "get_3D_transforms", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.get_partition_name_from_mode": [[116, 127], ["ValueError"], "methods", ["None"], ["", "def", "get_partition_name_from_mode", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "mode", "==", "\"train\"", ":", "\n", "            ", "partition", "=", "\"Train_Set\"", "\n", "", "elif", "self", ".", "mode", "==", "\"validate\"", ":", "\n", "            ", "partition", "=", "\"Validation_Set\"", "\n", "", "elif", "self", ".", "mode", "==", "\"test\"", ":", "\n", "            ", "partition", "=", "\"Target_Set\"", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown partition!\"", ")", "\n", "\n", "", "return", "partition", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.get_3D_transforms": [[128, 164], ["GroupNormalize", "torchvision.transforms.transforms.Compose", "torchvision.transforms.transforms.Compose", "torchvision.transforms.transforms.Compose", "torchvision.transforms.transforms.Compose", "torchvision.transforms.transforms.ToTensor", "torchvision.transforms.transforms.Normalize", "torchvision.transforms.transforms.ToTensor", "torchvision.transforms.transforms.Normalize", "GroupNumpyToPILImage", "GroupRandomCrop", "GroupRandomHorizontalFlip", "Stack", "ToTorchFormatTensor", "GroupNumpyToPILImage", "GroupCenterCrop", "Stack", "ToTorchFormatTensor"], "methods", ["None"], ["", "def", "get_3D_transforms", "(", "self", ")", ":", "\n", "        ", "normalize", "=", "GroupNormalize", "(", "[", "0.5", ",", "0.5", ",", "0.5", "]", ",", "[", "0.5", ",", "0.5", ",", "0.5", "]", ")", "\n", "\n", "if", "self", ".", "mode", "==", "'train'", ":", "\n", "            ", "if", "\"frame\"", "in", "self", ".", "modality", ":", "\n", "                ", "self", ".", "image_transforms", "=", "transforms", ".", "Compose", "(", "[", "\n", "GroupNumpyToPILImage", "(", "0", ")", ",", "\n", "GroupRandomCrop", "(", "48", ",", "40", ")", ",", "\n", "GroupRandomHorizontalFlip", "(", ")", ",", "\n", "Stack", "(", ")", ",", "\n", "ToTorchFormatTensor", "(", ")", ",", "\n", "normalize", "\n", "]", ")", "\n", "\n", "", "", "if", "self", ".", "mode", "!=", "'train'", ":", "\n", "            ", "if", "\"frame\"", "in", "self", ".", "modality", ":", "\n", "                ", "self", ".", "image_transforms", "=", "transforms", ".", "Compose", "(", "[", "\n", "GroupNumpyToPILImage", "(", "0", ")", ",", "\n", "GroupCenterCrop", "(", "40", ")", ",", "\n", "Stack", "(", ")", ",", "\n", "ToTorchFormatTensor", "(", ")", ",", "\n", "normalize", "\n", "]", ")", "\n", "\n", "", "", "if", "\"mfcc\"", "in", "self", ".", "modality", ":", "\n", "            ", "self", ".", "mfcc_transforms", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "mean", "=", "self", ".", "mean_std_info", "[", "\"mfcc\"", "]", "[", "self", ".", "fold", "]", "[", "self", ".", "partition", "]", "[", "'mean'", "]", ",", "\n", "std", "=", "self", ".", "mean_std_info", "[", "\"mfcc\"", "]", "[", "self", ".", "fold", "]", "[", "self", ".", "partition", "]", "[", "'std'", "]", ")", ",", "\n", "]", ")", "\n", "\n", "", "if", "\"vggish\"", "in", "self", ".", "modality", ":", "\n", "            ", "self", ".", "vggish_transforms", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "mean", "=", "self", ".", "mean_std_info", "[", "\"vggish\"", "]", "[", "self", ".", "fold", "]", "[", "self", ".", "partition", "]", "[", "'mean'", "]", ",", "\n", "std", "=", "self", ".", "mean_std_info", "[", "\"vggish\"", "]", "[", "self", ".", "fold", "]", "[", "self", ".", "partition", "]", "[", "'std'", "]", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data": [[168, 173], ["os.path.join", "numpy.load"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "load_data", "(", "directory", ",", "indices", ",", "filename", ")", ":", "\n", "        ", "filename", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "filename", ")", "\n", "frames", "=", "np", ".", "load", "(", "filename", ",", "mmap_mode", "=", "'c'", ")", "[", "indices", "]", "\n", "return", "frames", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.__getitem__": [[174, 263], ["dataset.ABAW2_VA_Dataset.image_transforms", "features.update", "features.update", "numpy.array", "features.update", "dataset.ABAW2_VA_Dataset.mfcc_transforms", "features.update", "features.update", "dataset.ABAW2_VA_Dataset.vggish_transforms", "features.update", "numpy.concatenate", "len", "numpy.arange", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.reshape", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data().astype", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data().astype", "numpy.zeros", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data", "len", "numpy.repeat", "dataset.ABAW2_VA_Dataset.load_data", "dataset.ABAW2_VA_Dataset.load_data", "ValueError"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data", "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.load_data"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "path", "=", "self", ".", "data_list", "[", "index", "]", "[", "0", "]", "\n", "trial", "=", "self", ".", "data_list", "[", "index", "]", "[", "1", "]", "\n", "indices", "=", "self", ".", "data_list", "[", "index", "]", "[", "2", "]", "\n", "length", "=", "self", ".", "data_list", "[", "index", "]", "[", "3", "]", "\n", "labels", "=", "0", "\n", "features", "=", "{", "}", "\n", "\n", "if", "\"frame\"", "in", "self", ".", "modality", ":", "\n", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "frames", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "48", ",", "48", ",", "3", ")", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "frames", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"frame.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "frames", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"frame.npy\"", ")", "\n", "\n", "", "frames", "=", "self", ".", "image_transforms", "(", "frames", ")", "\n", "features", ".", "update", "(", "{", "'frame'", ":", "frames", "}", ")", "\n", "\n", "", "if", "\"fau\"", "in", "self", ".", "modality", ":", "\n", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "au", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "17", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "au", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"au.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "au", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"au.npy\"", ")", "\n", "", "features", ".", "update", "(", "{", "'au'", ":", "au", "}", ")", "\n", "\n", "", "if", "\"flm\"", "in", "self", ".", "modality", ":", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "landmark", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "68", ",", "2", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "landmark", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"landmark.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "landmark", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"landmark.npy\"", ")", "\n", "", "landmark", "=", "np", ".", "array", "(", "landmark", ".", "reshape", "(", "len", "(", "landmark", ")", ",", "-", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "features", ".", "update", "(", "{", "'landmark'", ":", "landmark", "}", ")", "\n", "\n", "", "if", "\"mfcc\"", "in", "self", ".", "modality", ":", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "mfcc", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "39", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "mfcc", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"mfcc.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "mfcc", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"mfcc.npy\"", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "", "mfcc", "=", "self", ".", "mfcc_transforms", "(", "mfcc", ")", "\n", "features", ".", "update", "(", "{", "'mfcc'", ":", "mfcc", "}", ")", "\n", "\n", "", "if", "\"egemaps\"", "in", "self", ".", "modality", ":", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "egemaps", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "23", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "egemaps", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"egemaps.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "egemaps", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"egemaps.npy\"", ")", "\n", "", "features", ".", "update", "(", "{", "'egemaps'", ":", "egemaps", "}", ")", "\n", "\n", "", "if", "\"vggish\"", "in", "self", ".", "modality", ":", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "vggish", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "128", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "vggish", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"vggish.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "vggish", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"vggish.npy\"", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "# vggish = (vggish - (-0.105)) / 0.4476", "\n", "", "vggish", "=", "self", ".", "vggish_transforms", "(", "vggish", ")", "\n", "features", ".", "update", "(", "{", "'vggish'", ":", "vggish", "}", ")", "\n", "\n", "", "if", "self", ".", "mode", "!=", "\"test\"", ":", "\n", "            ", "if", "length", "<", "self", ".", "window_length", ":", "\n", "                ", "labels", "=", "np", ".", "zeros", "(", "(", "self", ".", "window_length", ",", "2", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "labels", "[", "indices", "]", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"label.npy\"", ")", "\n", "", "else", ":", "\n", "                ", "labels", "=", "self", ".", "load_data", "(", "path", ",", "indices", ",", "\"label.npy\"", ")", "\n", "\n", "", "if", "self", ".", "head", "==", "\"single-headed\"", ":", "\n", "                ", "if", "self", ".", "emotion", "==", "\"arousal\"", ":", "#Arousal", "\n", "                    ", "labels", "=", "labels", "[", ":", ",", "1", "]", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "elif", "self", ".", "emotion", "==", "\"valence\"", ":", "# Valence", "\n", "                    ", "labels", "=", "labels", "[", ":", ",", "0", "]", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "\"Unsupported emotional dimension for continuous labels!\"", ")", "\n", "\n", "# Deal with the label delay by making the time_delay-th label point as the 1st point and shift other points accordingly.", "\n", "# The previous last point is copied for time_delay times.", "\n", "", "", "labels", "=", "np", ".", "concatenate", "(", "\n", "(", "labels", "[", "self", ".", "time_delay", ":", ",", ":", "]", ",", "\n", "np", ".", "repeat", "(", "labels", "[", "-", "1", ",", ":", "]", "[", "np", ".", "newaxis", "]", ",", "repeats", "=", "self", ".", "time_delay", ",", "axis", "=", "0", ")", ")", ",", "axis", "=", "0", ")", "\n", "\n", "", "if", "len", "(", "indices", ")", "<", "self", ".", "window_length", ":", "\n", "            ", "indices", "=", "np", ".", "arange", "(", "self", ".", "window_length", ")", "\n", "\n", "", "return", "features", ",", "labels", ",", "trial", ",", "length", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.dataset.ABAW2_VA_Dataset.__len__": [[264, 266], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "data_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.loss_function.CCCLoss.__init__": [[6, 8], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.loss_function.CCCLoss.forward": [[9, 24], ["torch.mean", "torch.mean", "torch.var", "torch.var", "torch.mean", "torch.mul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "gold", ",", "pred", ",", "weights", "=", "None", ")", ":", "\n", "# pred = torch.tanh(pred)", "\n", "        ", "gold_mean", "=", "torch", ".", "mean", "(", "gold", ",", "1", ",", "keepdim", "=", "True", ",", "out", "=", "None", ")", "\n", "pred_mean", "=", "torch", ".", "mean", "(", "pred", ",", "1", ",", "keepdim", "=", "True", ",", "out", "=", "None", ")", "\n", "covariance", "=", "(", "gold", "-", "gold_mean", ")", "*", "(", "pred", "-", "pred_mean", ")", "\n", "gold_var", "=", "torch", ".", "var", "(", "gold", ",", "1", ",", "keepdim", "=", "True", ",", "unbiased", "=", "True", ",", "out", "=", "None", ")", "\n", "pred_var", "=", "torch", ".", "var", "(", "pred", ",", "1", ",", "keepdim", "=", "True", ",", "unbiased", "=", "True", ",", "out", "=", "None", ")", "\n", "ccc", "=", "2.", "*", "covariance", "/", "(", "\n", "(", "gold_var", "+", "pred_var", "+", "torch", ".", "mul", "(", "gold_mean", "-", "pred_mean", ",", "gold_mean", "-", "pred_mean", ")", ")", "+", "1e-08", ")", "\n", "ccc_loss", "=", "1.", "-", "ccc", "\n", "\n", "if", "weights", "is", "not", "None", ":", "\n", "            ", "ccc_loss", "*=", "weights", "\n", "\n", "", "return", "torch", ".", "mean", "(", "ccc_loss", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.__init__": [[15, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "path", ",", "trainer", ",", "parameter_controller", ",", "resume", ")", ":", "\n", "        ", "self", ".", "checkpoint", "=", "{", "}", "\n", "self", ".", "path", "=", "path", "\n", "self", ".", "trainer", "=", "trainer", "\n", "self", ".", "parameter_controller", "=", "parameter_controller", "\n", "self", ".", "resume", "=", "resume", "\n", "\n", "self", ".", "columns", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.save_log_to_csv": [[24, 58], ["len", "pandas.DataFrame", "pandas.DataFrame.T.to_csv", "time.time", "int", "csv_records.extend", "csv_records.extend", "csv_records.extend"], "methods", ["None"], ["", "def", "save_log_to_csv", "(", "self", ",", "epoch", ",", "mean_train_record", ",", "mean_validate_record", ")", ":", "\n", "        ", "num_layers_to_update", "=", "len", "(", "self", ".", "trainer", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'params'", "]", ")", "\n", "\n", "csv_records", "=", "[", "time", ".", "time", "(", ")", ",", "epoch", ",", "int", "(", "self", ".", "trainer", ".", "best_epoch_info", "[", "'epoch'", "]", ")", ",", "num_layers_to_update", ",", "\n", "self", ".", "trainer", ".", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", ",", "self", ".", "trainer", ".", "train_losses", "[", "-", "1", "]", ",", "\n", "self", ".", "trainer", ".", "validate_losses", "[", "-", "1", "]", "]", "\n", "\n", "if", "self", ".", "trainer", ".", "head", "==", "\"single-headed\"", ":", "\n", "            ", "if", "self", ".", "trainer", ".", "train_emotion", "==", "\"arousal\"", ":", "\n", "                ", "csv_records", ".", "extend", "(", "[", "\n", "mean_train_record", "[", "'Arousal'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_train_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_train_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_train_record", "[", "'Arousal'", "]", "[", "'ccc'", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Arousal'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_validate_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_validate_record", "[", "'Arousal'", "]", "[", "'ccc'", "]", "[", "0", "]", "]", ")", "\n", "", "else", ":", "\n", "                ", "csv_records", ".", "extend", "(", "[", "\n", "mean_train_record", "[", "'Valence'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_train_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_train_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_train_record", "[", "'Valence'", "]", "[", "'ccc'", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Valence'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_validate_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_validate_record", "[", "'Valence'", "]", "[", "'ccc'", "]", "[", "0", "]", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "csv_records", ".", "extend", "(", "[", "\n", "mean_train_record", "[", "'Arousal'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_train_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_train_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_train_record", "[", "'Arousal'", "]", "[", "'ccc'", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Arousal'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_validate_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Arousal'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_validate_record", "[", "'Arousal'", "]", "[", "'ccc'", "]", "[", "0", "]", "]", "+", "\n", "[", "\n", "mean_train_record", "[", "'Valence'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_train_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_train_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_train_record", "[", "'Valence'", "]", "[", "'ccc'", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Valence'", "]", "[", "'rmse'", "]", "[", "0", "]", ",", "mean_validate_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "0", "]", ",", "\n", "mean_validate_record", "[", "'Valence'", "]", "[", "'pcc'", "]", "[", "0", "]", "[", "1", "]", ",", "mean_validate_record", "[", "'Valence'", "]", "[", "'ccc'", "]", "[", "0", "]", "]", ")", "\n", "\n", "", "row_df", "=", "pd", ".", "DataFrame", "(", "data", "=", "csv_records", ")", "\n", "row_df", ".", "T", ".", "to_csv", "(", "self", ".", "trainer", ".", "csv_filename", ",", "mode", "=", "'a'", ",", "index", "=", "False", ",", "header", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.init_csv_logger": [[59, 92], ["os.path.join", "vars", "pandas.json_normalize", "pandas.DataFrame", "pandas.DataFrame.to_csv", "pandas.json_normalize", "pandas.DataFrame", "pandas.DataFrame.to_csv", "pandas.DataFrame", "pandas.DataFrame.to_csv", "checkpointer.Checkpointer.columns.extend", "checkpointer.Checkpointer.columns.extend", "checkpointer.Checkpointer.columns.extend"], "methods", ["None"], ["", "def", "init_csv_logger", "(", "self", ",", "args", ",", "config", ")", ":", "\n", "\n", "        ", "self", ".", "trainer", ".", "csv_filename", "=", "os", ".", "path", ".", "join", "(", "self", ".", "trainer", ".", "save_path", ",", "\"training_logs.csv\"", ")", "\n", "\n", "# Record the arguments.", "\n", "arguments_dict", "=", "vars", "(", "args", ")", "\n", "arguments_dict", "=", "pd", ".", "json_normalize", "(", "arguments_dict", ",", "sep", "=", "'_'", ")", "\n", "\n", "df_args", "=", "pd", ".", "DataFrame", "(", "data", "=", "arguments_dict", ")", "\n", "df_args", ".", "to_csv", "(", "self", ".", "trainer", ".", "csv_filename", ",", "index", "=", "False", ")", "\n", "\n", "config", "=", "pd", ".", "json_normalize", "(", "config", ",", "sep", "=", "'_'", ")", "\n", "df_config", "=", "pd", ".", "DataFrame", "(", "data", "=", "config", ")", "\n", "df_config", ".", "to_csv", "(", "self", ".", "trainer", ".", "csv_filename", ",", "mode", "=", "'a'", ",", "index", "=", "False", ")", "\n", "\n", "self", ".", "columns", "=", "[", "'time'", ",", "'epoch'", ",", "'best_epoch'", ",", "'layer_to_update'", ",", "'lr'", ",", "\n", "'tr_loss'", ",", "'val_loss'", "]", "\n", "\n", "if", "self", ".", "trainer", ".", "head", "==", "\"single-headed\"", ":", "\n", "            ", "if", "self", ".", "trainer", ".", "train_emotion", "==", "\"arousal\"", ":", "\n", "                ", "self", ".", "columns", ".", "extend", "(", "[", "'tr_rmse_a'", ",", "'tr_pcc_a_v'", ",", "'tr_pcc_a_conf'", ",", "'tr_ccc_a'", ",", "\n", "'val_rmse_a'", ",", "'val_pcc_a_v'", ",", "'val_pcc_a_conf'", ",", "'val_ccc_a'", "]", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "columns", ".", "extend", "(", "[", "'tr_rmse_v'", ",", "'tr_pcc_v_v'", ",", "'tr_pcc_v_conf'", ",", "'tr_ccc_v'", ",", "\n", "'val_rmse_v'", ",", "'val_pcc_v_v'", ",", "'val_pcc_v_conf'", ",", "'val_ccc_v'", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "columns", ".", "extend", "(", "[", "'tr_rmse_a'", ",", "'tr_pcc_a_v'", ",", "'tr_pcc_a_conf'", ",", "'tr_ccc_a'", ",", "\n", "'val_rmse_a'", ",", "'val_pcc_a_v'", ",", "'val_pcc_a_conf'", ",", "'val_ccc_a'", "]", "\n", "+", "[", "'tr_rmse_v'", ",", "'tr_pcc_v_v'", ",", "'tr_pcc_v_conf'", ",", "'tr_ccc_v'", ",", "\n", "'val_rmse_v'", ",", "'val_pcc_v_v'", ",", "'val_pcc_v_conf'", ",", "'val_ccc_v'", "]", ")", "\n", "\n", "", "df", "=", "pd", ".", "DataFrame", "(", "columns", "=", "self", ".", "columns", ")", "\n", "df", ".", "to_csv", "(", "self", ".", "trainer", ".", "csv_filename", ",", "mode", "=", "'a'", ",", "index", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.load_checkpoint": [[93, 107], ["os.path.isfile", "print", "print", "ValueError", "base.utils.load_single_pkl"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.load_single_pkl"], ["", "def", "load_checkpoint", "(", "self", ")", ":", "\n", "# If checkpoint file exists, then read it.", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "self", ".", "path", ")", ":", "\n", "            ", "print", "(", "\"Loading checkpoint. Are you sure it is intended?\"", ")", "\n", "self", ".", "checkpoint", "=", "{", "**", "self", ".", "checkpoint", ",", "**", "load_single_pkl", "(", "self", ".", "path", ")", "}", "\n", "print", "(", "\"Checkpoint loaded!\"", ")", "\n", "\n", "self", ".", "trainer", "=", "self", ".", "checkpoint", "[", "'trainer'", "]", "\n", "self", ".", "trainer", ".", "resume", "=", "True", "\n", "self", ".", "parameter_controller", "=", "self", ".", "checkpoint", "[", "'param_control'", "]", "\n", "self", ".", "parameter_controller", ".", "trainer", "=", "self", ".", "trainer", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Checkpoint not exists!!\"", ")", "\n", "", "return", "self", ".", "trainer", ",", "self", ".", "parameter_controller", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.checkpointer.Checkpointer.save_checkpoint": [[108, 116], ["print", "base.utils.save_pkl_file", "print"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.save_pkl_file"], ["", "def", "save_checkpoint", "(", "self", ",", "trainer", ",", "parameter_controller", ",", "path", ")", ":", "\n", "        ", "self", ".", "checkpoint", "[", "'trainer'", "]", "=", "trainer", "\n", "self", ".", "checkpoint", "[", "'param_control'", "]", "=", "parameter_controller", "\n", "\n", "if", "path", ":", "\n", "            ", "print", "(", "\"Saving checkpoint.\"", ")", "\n", "save_pkl_file", "(", "path", ",", "\"checkpoint.pkl\"", ",", "self", ".", "checkpoint", ")", "\n", "print", "(", "\"Checkpoint saved.\"", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.OpenFaceController.__init__": [[10, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "openface_path", ",", "output_directory", ")", ":", "\n", "        ", "self", ".", "openface_path", "=", "openface_path", "\n", "self", ".", "output_directory", "=", "output_directory", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.OpenFaceController.get_openface_command": [[14, 32], ["None"], "methods", ["None"], ["", "def", "get_openface_command", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "openface_path", "=", "self", ".", "openface_path", "\n", "input_flag", "=", "kwargs", "[", "'input_flag'", "]", "\n", "output_features", "=", "kwargs", "[", "'output_features'", "]", "\n", "output_action_unit", "=", "kwargs", "[", "'output_action_unit'", "]", "\n", "output_image_flag", "=", "kwargs", "[", "'output_image_flag'", "]", "\n", "output_image_size", "=", "kwargs", "[", "'output_image_size'", "]", "\n", "output_image_format", "=", "kwargs", "[", "'output_image_format'", "]", "\n", "output_filename_flag", "=", "kwargs", "[", "'output_filename_flag'", "]", "\n", "output_directory_flag", "=", "kwargs", "[", "'output_directory_flag'", "]", "\n", "output_directory", "=", "self", ".", "output_directory", "\n", "output_image_mask_flag", "=", "kwargs", "[", "'output_image_mask_flag'", "]", "\n", "\n", "command", "=", "openface_path", "+", "input_flag", "+", "\" {input_filename} \"", "+", "output_features", "+", "output_action_unit", "+", "output_image_flag", "+", "output_image_size", "+", "output_image_format", "+", "output_filename_flag", "+", "\" {output_filename} \"", "+", "output_directory_flag", "+", "output_directory", "+", "output_image_mask_flag", "\n", "return", "command", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.OpenFaceController.process_video": [[33, 47], ["utils.OpenFaceController.get_openface_command", "command.format.format.format", "os.path.join", "os.path.isfile", "subprocess.call", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.OpenFaceController.get_openface_command"], ["", "def", "process_video", "(", "self", ",", "input_filename", ",", "output_filename", ",", "**", "kwargs", ")", ":", "\n", "\n", "# Quote the file name if spaces occurred.", "\n", "        ", "if", "\" \"", "in", "input_filename", ":", "\n", "            ", "input_filename", "=", "'\"'", "+", "input_filename", "+", "'\"'", "\n", "\n", "", "command", "=", "self", ".", "get_openface_command", "(", "**", "kwargs", ")", "\n", "command", "=", "command", ".", "format", "(", "\n", "input_filename", "=", "input_filename", ",", "output_filename", "=", "output_filename", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "os", ".", "path", ".", "join", "(", "self", ".", "output_directory", ",", "output_filename", "+", "\".csv\"", ")", ")", ":", "\n", "            ", "subprocess", ".", "call", "(", "command", ",", "shell", "=", "True", ")", "\n", "\n", "", "return", "os", ".", "path", ".", "join", "(", "self", ".", "output_directory", ",", "output_filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.get_filename_from_a_folder_given_extension": [[49, 58], ["os.walk", "root.startswith", "root.split", "file.endswith", "print", "os.path.join"], "function", ["None"], ["", "", "def", "get_filename_from_a_folder_given_extension", "(", "folder", ",", "extension", ")", ":", "\n", "    ", "file_list", "=", "[", "]", "\n", "import", "os", "\n", "for", "root", ",", "dirs", ",", "files", "in", "os", ".", "walk", "(", "folder", ")", ":", "\n", "        ", "if", "not", "root", ".", "startswith", "(", "\".\"", ")", ":", "\n", "            ", "partition", "=", "root", ".", "split", "(", "sep", "=", "os", ".", "sep", ")", "[", "-", "1", "]", "\n", "for", "file", "in", "files", ":", "\n", "                ", "if", "file", ".", "endswith", "(", "extension", ")", ":", "\n", "                    ", "print", "(", "os", ".", "path", ".", "join", "(", "root", ",", "file", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.txt_row_count": [[60, 65], ["open", "enumerate"], "function", ["None"], ["", "", "", "", "", "def", "txt_row_count", "(", "fname", ")", ":", "\n", "    ", "with", "open", "(", "fname", ")", "as", "f", ":", "\n", "        ", "for", "i", ",", "l", "in", "enumerate", "(", "f", ")", ":", "\n", "            ", "pass", "\n", "", "", "return", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.standardize_facial_landmarks": [[67, 77], ["range", "numpy.transpose", "preprocessing.StandardScaler().fit", "np.transpose.append", "numpy.stack", "preprocessing.StandardScaler().fit.transform", "preprocessing.StandardScaler"], "function", ["home.repos.pwc.inspect_result.sucv_ABAW2.base.trainer.ABAW2Trainer.fit"], ["", "def", "standardize_facial_landmarks", "(", "landmark_sequence", ")", ":", "\n", "    ", "from", "sklearn", "import", "preprocessing", "\n", "\n", "landmark_sequence_scaled", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "landmark_sequence", ".", "shape", "[", "2", "]", ")", ":", "\n", "        ", "current_dim", "=", "landmark_sequence", "[", ":", ",", ":", ",", "i", "]", "\n", "scaler", "=", "preprocessing", ".", "StandardScaler", "(", ")", ".", "fit", "(", "current_dim", ")", "\n", "landmark_sequence_scaled", ".", "append", "(", "scaler", ".", "transform", "(", "current_dim", ")", ")", "\n", "", "landmark_sequence_scaled", "=", "np", ".", "transpose", "(", "np", ".", "stack", "(", "landmark_sequence_scaled", ")", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "return", "landmark_sequence_scaled", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.load_single_pkl": [[79, 94], ["os.path.join", "glob.glob", "open", "pickle.load", "directory.endswith"], "function", ["None"], ["", "def", "load_single_pkl", "(", "directory", ",", "filename", "=", "None", ",", "extension", "=", "'.pkl'", ")", ":", "\n", "    ", "r\"\"\"\n    Load one pkl file according to the filename.\n    \"\"\"", "\n", "if", "filename", "is", "not", "None", ":", "\n", "        ", "fullname", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "filename", "+", "extension", ")", "\n", "", "else", ":", "\n", "        ", "fullname", "=", "directory", "if", "directory", ".", "endswith", "(", "\".pkl\"", ")", "else", "directory", "+", "\".pkl\"", "\n", "\n", "", "fullname", "=", "glob", ".", "glob", "(", "fullname", ")", "[", "0", "]", "\n", "\n", "with", "open", "(", "fullname", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "pkl_file", "=", "pickle", ".", "load", "(", "f", ")", "\n", "\n", "", "return", "pkl_file", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.save_pkl_file": [[96, 102], ["os.makedirs", "os.path.join", "open", "pickle.dump"], "function", ["None"], ["", "def", "save_pkl_file", "(", "directory", ",", "filename", ",", "data", ")", ":", "\n", "    ", "os", ".", "makedirs", "(", "directory", ",", "exist_ok", "=", "True", ")", "\n", "fullname", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "filename", ")", "\n", "\n", "with", "open", "(", "fullname", ",", "'wb'", ")", "as", "pkl_file", ":", "\n", "        ", "pickle", ".", "dump", "(", "data", ",", "pkl_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.detect_device": [[103, 108], ["torch.device", "torch.cuda.is_available"], "function", ["None"], ["", "", "def", "detect_device", "(", ")", ":", "\n", "    ", "import", "torch", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "# device = torch.device('cuda:1')", "\n", "return", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.select_gpu": [[110, 118], ["torch.cuda.set_device"], "function", ["None"], ["", "def", "select_gpu", "(", "index", ")", ":", "\n", "    ", "import", "torch", "\n", "r\"\"\"\n    Choose which gpu to use.\n    :param index: (int), the index corresponding to the desired gpu. For example,\n        0 means the 1st gpu.\n    \"\"\"", "\n", "torch", ".", "cuda", ".", "set_device", "(", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.utils.set_cpu_thread": [[120, 127], ["torch.set_num_threads"], "function", ["None"], ["", "def", "set_cpu_thread", "(", "number", ")", ":", "\n", "    ", "import", "torch", "\n", "r\"\"\"\n    Set the maximum thread of cpu for torch module.\n    :param number: (int), the number of thread allowed, usually 1 is enough.\n    \"\"\"", "\n", "torch", ".", "set_num_threads", "(", "number", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupNumpyToPILImage.__init__": [[11, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "use_inverse", ")", ":", "\n", "        ", "self", ".", "use_inverse", "=", "use_inverse", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupNumpyToPILImage.__call__": [[14, 26], ["range", "PIL.Image.fromarray().convert", "ImgGroup.append", "PIL.Image.fromarray", "Img[].astype"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "Img", ")", ":", "\n", "        ", "ImgGroup", "=", "[", "]", "\n", "\n", "for", "k", "in", "range", "(", "Img", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "self", ".", "use_inverse", ":", "\n", "                ", "kk", "=", "Img", ".", "shape", "[", "0", "]", "-", "k", "-", "1", "\n", "", "else", ":", "\n", "                ", "kk", "=", "k", "\n", "", "img", "=", "Image", ".", "fromarray", "(", "Img", "[", "kk", ",", ":", ",", ":", ",", ":", "]", ".", "astype", "(", "'uint8'", ")", ")", ".", "convert", "(", "'RGB'", ")", "\n", "ImgGroup", ".", "append", "(", "img", ")", "\n", "\n", "", "return", "ImgGroup", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupRandomCrop.__init__": [[29, 39], ["isinstance", "isinstance", "int", "int", "int", "int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "img_size", ",", "crop_size", ")", ":", "\n", "        ", "if", "isinstance", "(", "img_size", ",", "numbers", ".", "Number", ")", ":", "\n", "            ", "self", ".", "img_size", "=", "(", "int", "(", "img_size", ")", ",", "int", "(", "img_size", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "img_size", "=", "img_size", "\n", "\n", "", "if", "isinstance", "(", "crop_size", ",", "numbers", ".", "Number", ")", ":", "\n", "            ", "self", ".", "crop_size", "=", "(", "int", "(", "crop_size", ")", ",", "int", "(", "crop_size", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "crop_size", "=", "crop_size", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupRandomCrop.__call__": [[40, 58], ["list", "random.randint", "random.randint", "list.append", "list.append", "img.crop"], "methods", ["None"], ["", "", "def", "__call__", "(", "self", ",", "img_group", ")", ":", "\n", "\n", "        ", "w", ",", "h", "=", "self", ".", "img_size", "\n", "th", ",", "tw", "=", "self", ".", "crop_size", "\n", "\n", "out_images", "=", "list", "(", ")", "\n", "\n", "x1", "=", "random", ".", "randint", "(", "0", ",", "w", "-", "tw", ")", "\n", "y1", "=", "random", ".", "randint", "(", "0", ",", "h", "-", "th", ")", "\n", "\n", "for", "img", "in", "img_group", ":", "\n", "            ", "assert", "(", "img", ".", "size", "[", "0", "]", "==", "w", "and", "img", ".", "size", "[", "1", "]", "==", "h", ")", "\n", "if", "w", "==", "tw", "and", "h", "==", "th", ":", "\n", "                ", "out_images", ".", "append", "(", "img", ")", "\n", "", "else", ":", "\n", "                ", "out_images", ".", "append", "(", "img", ".", "crop", "(", "(", "x1", ",", "y1", ",", "x1", "+", "tw", ",", "y1", "+", "th", ")", ")", ")", "\n", "\n", "", "", "return", "out_images", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupCenterCrop.__init__": [[61, 63], ["torchvision.transforms.CenterCrop"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "size", ")", ":", "\n", "        ", "self", ".", "worker", "=", "torchvision", ".", "transforms", ".", "CenterCrop", "(", "size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupCenterCrop.__call__": [[64, 66], ["transforms3D.GroupCenterCrop.worker"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img_group", ")", ":", "\n", "        ", "return", "[", "self", ".", "worker", "(", "img", ")", "for", "img", "in", "img_group", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupRandomHorizontalFlip.__init__": [[71, 73], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupRandomHorizontalFlip.__call__": [[74, 81], ["random.random", "img.transpose"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img_group", ",", "is_flow", "=", "False", ")", ":", "\n", "        ", "v", "=", "random", ".", "random", "(", ")", "\n", "if", "v", "<", "0.5", ":", "\n", "            ", "ret", "=", "[", "img", ".", "transpose", "(", "Image", ".", "FLIP_LEFT_RIGHT", ")", "for", "img", "in", "img_group", "]", "\n", "return", "ret", "\n", "", "else", ":", "\n", "            ", "return", "img_group", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupNormalize.__init__": [[84, 86], ["torchvision.transforms.Normalize"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "normalize", "=", "torchvision", ".", "transforms", ".", "Normalize", "(", "mean", "=", "mean", ",", "std", "=", "std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupNormalize.__call__": [[87, 96], ["range", "torch.stack", "transforms3D.GroupNormalize.normalize", "tensor.append"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "Imgs", ")", ":", "\n", "        ", "L", ",", "C", ",", "H", ",", "W", "=", "Imgs", ".", "shape", "\n", "\n", "tensor", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "L", ")", ":", "\n", "            ", "img", "=", "self", ".", "normalize", "(", "Imgs", "[", "k", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "tensor", ".", "append", "(", "img", ")", "\n", "\n", "", "return", "torch", ".", "stack", "(", "tensor", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupScale.__init__": [[107, 109], ["torchvision.transforms.Resize"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "size", ",", "interpolation", "=", "Image", ".", "BILINEAR", ")", ":", "\n", "        ", "self", ".", "worker", "=", "torchvision", ".", "transforms", ".", "Resize", "(", "size", ",", "interpolation", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.GroupScale.__call__": [[110, 112], ["transforms3D.GroupScale.worker"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img_group", ")", ":", "\n", "        ", "return", "[", "self", ".", "worker", "(", "img", ")", "for", "img", "in", "img_group", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.Stack.__init__": [[116, 118], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "roll", "=", "False", ")", ":", "\n", "        ", "self", ".", "roll", "=", "roll", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.Stack.__call__": [[119, 125], ["numpy.concatenate", "numpy.stack", "numpy.expand_dims"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "img_group", ")", ":", "\n", "        ", "if", "img_group", "[", "0", "]", ".", "mode", "==", "'L'", ":", "\n", "            ", "return", "np", ".", "concatenate", "(", "[", "np", ".", "expand_dims", "(", "x", ",", "2", ")", "for", "x", "in", "img_group", "]", ",", "axis", "=", "2", ")", "\n", "", "elif", "img_group", "[", "0", "]", ".", "mode", "==", "'RGB'", ":", "\n", "# return np.concatenate(img_group, axis=2)", "\n", "            ", "return", "np", ".", "stack", "(", "img_group", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__init__": [[130, 132], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "div", "=", "True", ")", ":", "\n", "        ", "self", ".", "div", "=", "div", "\n", "\n"]], "home.repos.pwc.inspect_result.sucv_ABAW2.base.transforms3D.ToTorchFormatTensor.__call__": [[133, 139], ["isinstance", "torch.from_numpy().permute().contiguous", "torch.from_numpy().permute().contiguous.float().div", "torch.from_numpy().permute().contiguous.float", "torch.from_numpy().permute", "torch.from_numpy().permute().contiguous.float", "torch.from_numpy"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "pic", ")", ":", "\n", "        ", "if", "isinstance", "(", "pic", ",", "np", ".", "ndarray", ")", ":", "\n", "# handle numpy array", "\n", "            ", "img", "=", "torch", ".", "from_numpy", "(", "pic", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ".", "contiguous", "(", ")", "\n", "\n", "", "return", "img", ".", "float", "(", ")", ".", "div", "(", "255", ")", "if", "self", ".", "div", "else", "img", ".", "float", "(", ")", "\n", "\n"]]}