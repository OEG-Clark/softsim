{"home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.evaluate.getSingleMAP": [[3, 18], ["enumerate", "set", "re.sub", "len", "len", "already_output.add", "float", "float", "ranks.append"], "function", ["None"], ["def", "getSingleMAP", "(", "gold", ",", "pred", ")", ":", "\n", "    ", "ranks", ",", "rank", ",", "already_output", "=", "[", "]", ",", "0", ",", "set", "(", ")", "\n", "for", "ex_uid_long", "in", "pred", ":", "\n", "        ", "ex_uid", "=", "re", ".", "sub", "(", "r'_\\d+$'", ",", "''", ",", "ex_uid_long", ")", "# Clear of trailing _dd (if any)", "\n", "if", "not", "ex_uid", "in", "already_output", ":", "\n", "            ", "rank", "+=", "1", "# This is adjusted automatically to dedupe the ggg_x combos", "\n", "already_output", ".", "add", "(", "ex_uid", ")", "\n", "if", "ex_uid", "in", "gold", ":", "\n", "                ", "ranks", ".", "append", "(", "rank", ")", "\n", "", "", "", "total", "=", "0.", "\n", "for", "i", ",", "rank", "in", "enumerate", "(", "ranks", ")", ":", "\n", "        ", "total", "+=", "float", "(", "i", "+", "1", ")", "/", "float", "(", "rank", ")", "\n", "\n", "", "if", "len", "(", "gold", ")", "==", "0", ":", "return", "0.", "\n", "return", "total", "/", "len", "(", "gold", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.convert_texts": [[50, 79], ["set", "nlp.pipe", "nltk.corpus.stopwords.words", "preprocess.convert_texts.prepreprocess"], "function", ["None"], ["def", "convert_texts", "(", "texts", ",", "remove_stop", "=", "True", ",", "remove_punct", "=", "True", ")", ":", "\n", "    ", "def", "prepreprocess", "(", "arr", ")", ":", "\n", "# Sometimes spacy doesn't handle punctuation well eg \"work;life\"", "\n", "# But completely removing all punctuation worsens score", "\n", "        ", "return", "[", "txt", ".", "replace", "(", "\";\"", ",", "\"; \"", ")", "for", "txt", "in", "arr", "]", "\n", "\n", "", "stops", "=", "set", "(", "nltk", ".", "corpus", ".", "stopwords", ".", "words", "(", "\"english\"", ")", ")", "\n", "\n", "tokens", ",", "lemmas", "=", "[", "]", ",", "[", "]", "\n", "for", "doc", "in", "nlp", ".", "pipe", "(", "prepreprocess", "(", "texts", ")", ",", "disable", "=", "[", "\"ner\"", ",", "\"tagger\"", ",", "\"parser\"", "]", ")", ":", "\n", "        ", "_tokens", ",", "_lemmas", "=", "[", "]", ",", "[", "]", "\n", "for", "token", "in", "doc", ":", "\n", "#print(token.text.lower())", "\n", "            ", "if", "not", "token", ".", "text", ".", "lower", "(", ")", "in", "whitelist_words", ":", "# These get waved through", "\n", "# if token.is_stop and remove_stop:", "\n", "#     continue", "\n", "                ", "if", "token", ".", "text", "in", "stops", "and", "remove_stop", ":", "\n", "                    ", "continue", "\n", "", "if", "token", ".", "is_punct", "and", "remove_punct", ":", "\n", "                    ", "continue", "\n", "", "if", "len", "(", "token", ".", "lemma_", ".", "strip", "(", ")", ")", "==", "0", ":", "\n", "                    ", "continue", "# Kill spaces", "\n", "", "", "_tokens", ".", "append", "(", "token", ".", "text", ")", "\n", "#_lemmas.append(token.lemma_)  ", "\n", "_lemmas", ".", "append", "(", "token", ".", "lemma_", ".", "strip", "(", ")", ".", "lower", "(", ")", ")", "\n", "", "tokens", ".", "append", "(", "_tokens", ")", "\n", "lemmas", ".", "append", "(", "_lemmas", ")", "\n", "\n", "", "return", "tokens", ",", "lemmas", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.get_questions": [[80, 87], ["pandas.read_csv", "preprocess.convert_texts", "print", "pathlib.Path().joinpath", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.convert_texts"], ["", "def", "get_questions", "(", "path_questions", ",", "fname", ")", ":", "\n", "    ", "df", "=", "pd", ".", "read_csv", "(", "Path", "(", "path_questions", ")", ".", "joinpath", "(", "fname", ")", ",", "sep", "=", "\"\\t\"", ")", "\n", "tokens", ",", "lemmas", "=", "convert_texts", "(", "df", ".", "Question", ")", "\n", "df", "[", "\"tokens\"", "]", "=", "tokens", "\n", "df", "[", "\"lemmas\"", "]", "=", "lemmas", "\n", "print", "(", "df", ".", "shape", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.read_explanations_with_permutations": [[89, 156], ["pandas.read_csv", "name.startswith", "print", "uids_existing.add", "zip", "range", "header.append", "len", "print", "dict", "len", "enumerate", "arr.append", "pandas.isna", "o.strip", "len", "len", "combo.append", "pandas.isna", "len", "str().split", "len", "lemmas.append", "os.path.basename().replace", "str().strip", "len", "str", "os.path.basename", "str", "len", "len", "len"], "function", ["None"], ["", "def", "read_explanations_with_permutations", "(", "path", ",", "uids_existing", ")", ":", "# uids_existing is modified-in-place", "\n", "    ", "df", "=", "pd", ".", "read_csv", "(", "path", ",", "sep", "=", "'\\t'", ")", "\n", "\n", "header", ",", "uid_column", ",", "dep_column", "=", "[", "]", ",", "None", ",", "None", "\n", "for", "name", "in", "df", ".", "columns", ":", "\n", "        ", "if", "name", ".", "startswith", "(", "'[SKIP]'", ")", ":", "\n", "            ", "if", "'UID'", "in", "name", "and", "not", "uid_column", ":", "\n", "                ", "uid_column", "=", "name", "# This is the column header", "\n", "", "if", "'DEP'", "in", "name", "and", "not", "dep_column", ":", "\n", "                ", "dep_column", "=", "name", "# This is the column header", "\n", "", "", "else", ":", "\n", "            ", "header", ".", "append", "(", "name", ")", "# These are all those not market '[SKIP]'", "\n", "\n", "", "", "if", "not", "uid_column", "or", "len", "(", "df", ")", "==", "0", ":", "\n", "        ", "print", "(", "'Possibly misformatted file: '", "+", "path", ")", "\n", "return", "[", "]", "\n", "\n", "", "arr", "=", "[", "]", "\n", "for", "idx", "in", "df", ".", "index", ":", "\n", "        ", "if", "dep_column", "is", "not", "None", ":", "\n", "            ", "dep", "=", "df", ".", "loc", "[", "idx", "]", "[", "dep_column", "]", "\n", "if", "not", "pd", ".", "isna", "(", "dep", ")", "and", "len", "(", "str", "(", "dep", ")", ".", "strip", "(", ")", ")", ">", "0", ":", "\n", "#print(f\"Skipping : '{df.loc[idx][dep_column]}' for\")", "\n", "#print(f\"  {df.loc[idx]}\")", "\n", "                ", "if", "False", ":", "# Actually this hasn't been done properly in the dataset", "\n", "                    ", "continue", "\n", "\n", "", "", "", "uid_raw", "=", "df", ".", "at", "[", "idx", ",", "uid_column", "]", "\n", "if", "uid_raw", "in", "uids_existing", ":", "\n", "            ", "print", "(", "f\"Skipping duplicate uid : '{uid_raw}'\"", ")", "\n", "continue", "\n", "", "uids_existing", ".", "add", "(", "uid_raw", ")", "\n", "\n", "cells", ",", "combos", ",", "combo_tot", "=", "dict", "(", ")", ",", "[", "]", ",", "1", "\n", "for", "h", ",", "v", "in", "zip", "(", "header", ",", "df", ".", "loc", "[", "idx", "]", "[", "header", "]", ")", ":", "\n", "            ", "s", "=", "''", "if", "pd", ".", "isna", "(", "v", ")", "else", "v", "\n", "options", "=", "[", "o", ".", "strip", "(", ")", "for", "o", "in", "str", "(", "s", ")", ".", "split", "(", "';'", ")", "]", "\n", "options", "=", "[", "o", "for", "o", "in", "options", "if", "len", "(", "o", ")", ">", "0", "]", "\n", "if", "len", "(", "options", ")", "==", "0", ":", "options", "=", "[", "''", "]", "\n", "#print(options)", "\n", "cells", "[", "h", "]", "=", "options", "\n", "combos", "+=", "[", "len", "(", "options", ")", "]", "\n", "combo_tot", "*=", "len", "(", "options", ")", "# Count up the number of combos this contributes", "\n", "\n", "", "for", "i", "in", "range", "(", "combo_tot", ")", ":", "\n", "# Go through all the columns, figuring out which combo we're on", "\n", "            ", "combo", ",", "lemmas", ",", "residual", "=", "[", "]", ",", "[", "]", ",", "i", "\n", "for", "j", ",", "h", "in", "enumerate", "(", "header", ")", ":", "\n", "# Find the relevant part for this specific combo", "\n", "                ", "c", "=", "cells", "[", "h", "]", "[", "residual", "%", "combos", "[", "j", "]", "]", "# Works even if only 1 combo", "\n", "if", "len", "(", "cells", "[", "h", "]", ")", ">", "1", ":", "lemmas", ".", "append", "(", "c", ")", "# This is when there are choices", "\n", "combo", ".", "append", "(", "c", ")", "\n", "residual", "=", "residual", "//", "combos", "[", "j", "]", "# TeeHee", "\n", "\n", "# Order : uid, text, musthave, orig", "\n", "", "arr", ".", "append", "(", "[", "\n", "f\"{uid_raw}_{i}\"", ",", "# uid_i", "\n", "' '", ".", "join", "(", "[", "c", "for", "c", "in", "combo", "if", "len", "(", "c", ")", ">", "0", "]", ")", ",", "# text for this combo", "\n", "lemmas", ",", "\n", "' '", ".", "join", "(", "[", "(", "f\"{{{'; '.join(cells[h])}}}\"", "if", "len", "(", "cells", "[", "h", "]", ")", ">", "1", "else", "cells", "[", "h", "]", "[", "0", "]", ")", "\n", "for", "h", "in", "header", "\n", "if", "len", "(", "cells", "[", "h", "]", "[", "0", "]", ")", ">", "0", "]", ")", ".", "strip", "(", ")", ",", "# 'orig' for debug", "\n", "os", ".", "path", ".", "basename", "(", "path", ")", ".", "replace", "(", "'.tsv'", ",", "''", ")", ",", "# 'table'", "\n", "uid_raw", ",", "# 'uid_raw'", "\n", "]", ")", "\n", "\n", "", "", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.get_df_explanations": [[158, 184], ["path_tables.iterdir", "pandas.DataFrame", "preprocess.convert_texts", "print", "set", "preprocess.read_explanations_with_permutations", "enumerate", "str", "preprocess.convert_texts", "len", "print"], "function", ["home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.convert_texts", "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.read_explanations_with_permutations", "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.convert_texts"], ["", "def", "get_df_explanations", "(", "path_tables", ")", ":", "\n", "    ", "explanations", ",", "uids_existing", "=", "[", "]", ",", "set", "(", ")", "\n", "for", "p", "in", "path_tables", ".", "iterdir", "(", ")", ":", "\n", "#if 'USEDFOR.tsv' not in str(p): continue", "\n", "        ", "explanations", "+=", "read_explanations_with_permutations", "(", "str", "(", "p", ")", ",", "uids_existing", ")", "\n", "#print(len(uids_existing))  # Check that uids_existing is being modified-in-place", "\n", "\n", "", "df", "=", "pd", ".", "DataFrame", "(", "explanations", ",", "columns", "=", "(", "\"uid\"", ",", "\"text\"", ",", "\"musthave\"", ",", "\"orig\"", ",", "\"table\"", ",", "\"uid_raw\"", ",", ")", ")", "\n", "\n", "#print( df[ df.duplicated(\"uid\") ]['uid'] )  # have a look at the problem rows", "\n", "#    this problem eliminate in parse above using '[SKIP] DEP' column", "\n", "#df = df.drop_duplicates(\"uid\")  # NOO!", "\n", "#return df", "\n", "\n", "tokens", ",", "lemmas", "=", "convert_texts", "(", "df", ".", "text", ")", "\n", "#df[\"tokens\"] = tokens", "\n", "df", "[", "\"lemmas\"", "]", "=", "lemmas", "\n", "\n", "for", "idx", "in", "df", ".", "index", ":", "\n", "        ", "musthave", "=", "df", ".", "at", "[", "idx", ",", "'musthave'", "]", "\n", "for", "i", ",", "musthave_lemma", "in", "enumerate", "(", "convert_texts", "(", "musthave", ")", "[", "1", "]", ")", ":", "\n", "            ", "if", "len", "(", "musthave_lemma", ")", "==", "0", ":", "\n", "                ", "print", "(", "f\"Need to have lemma of '{musthave[i]}' in :\\n  '{df.at[idx, 'orig']}'\"", ")", "\n", "\n", "", "", "", "print", "(", "df", ".", "shape", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.flatten": [[187, 189], ["None"], "function", ["None"], ["", "def", "flatten", "(", "nested_list", ")", ":", "\n", "    ", "return", "[", "item", "for", "lst", "in", "nested_list", "for", "item", "in", "lst", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.get_flattened_items": [[190, 195], ["all_items.extend", "preprocess.flatten"], "function", ["home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.flatten"], ["", "def", "get_flattened_items", "(", "dfs", ",", "field", ")", ":", "\n", "    ", "all_items", "=", "[", "]", "\n", "for", "df", "in", "dfs", ":", "\n", "        ", "all_items", ".", "extend", "(", "flatten", "(", "df", "[", "field", "]", ")", ")", "\n", "", "return", "all_items", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.get_node_fns": [[224, 237], ["preprocess.get_flattened_items", "sorted", "print", "list", "set", "enumerate", "len", "len"], "function", ["home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.get_flattened_items"], ["", "def", "get_node_fns", "(", "dfs", ")", ":", "\n", "    ", "all_lemmas", "=", "get_flattened_items", "(", "dfs", ",", "\"lemmas\"", ")", "\n", "unique_lemmas", "=", "sorted", "(", "list", "(", "set", "(", "all_lemmas", ")", ")", ")", "\n", "print", "(", "f\"Total number of lemmas found : {len(all_lemmas):d}, unique : {len(unique_lemmas)}\"", ")", "\n", "\n", "node_lemma", "=", "unique_lemmas", "\n", "#n_nodes=len(node_lemma)", "\n", "\n", "lemma2node", "=", "{", "lemma", ":", "idx", "for", "idx", ",", "lemma", "in", "enumerate", "(", "node_lemma", ")", "}", "\n", "def", "nodes_to_sentence", "(", "nodes", ")", ":", "\n", "        ", "return", "' '", ".", "join", "(", "[", "node_lemma", "[", "n", "]", "for", "n", "in", "nodes", "]", ")", "\n", "\n", "", "return", "node_lemma", ",", "lemma2node", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.decompose_questions": [[238, 271], ["re.split", "preprocess.convert_texts", "enumerate", "preprocess.decompose_questions.get_nodes"], "function", ["home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.convert_texts"], ["", "def", "decompose_questions", "(", "df", ",", "lemma2node", ")", ":", "\n", "    ", "def", "get_nodes", "(", "lemmas", ")", ":", "\n", "        ", "return", "[", "lemma2node", "[", "lemma", "]", "for", "lemma", "in", "lemmas", "]", "\n", "\n", "", "df", "[", "'q_lem'", "]", ",", "df", "[", "'a_lem'", "]", "=", "None", ",", "None", "\n", "for", "prob", "in", "df", ".", "index", ":", "\n", "        ", "multi", "=", "re", ".", "split", "(", "r'\\([ABCDEF]\\)\\s*'", ",", "df", ".", "at", "[", "prob", ",", "'Question'", "]", ")", "\n", "j_ans", "=", "'ABCDEF'", ".", "find", "(", "df", ".", "at", "[", "prob", ",", "'AnswerKey'", "]", ")", "+", "1", "\n", "\n", "q_lem", ",", "a_lem", "=", "None", ",", "[", "]", "\n", "_", ",", "lemmas", "=", "convert_texts", "(", "multi", ")", "\n", "for", "j", ",", "ls", "in", "enumerate", "(", "lemmas", ")", ":", "\n", "#print(ls)", "\n", "            ", "ids", "=", "get_nodes", "(", "ls", ")", "\n", "#print(ls, ids, j_ans)", "\n", "if", "0", "==", "len", "(", "ids", ")", ":", "\n", "# Just show that there's a problem (fortunately, no correct answer has 0 lemma terms)", "\n", "                ", "print", "(", "prob", ",", "multi", ",", "lemmas", ",", "j", ",", "j_ans", ",", "ids", ")", "\n", "", "if", "0", "==", "j", ":", "\n", "                ", "q_lem", "=", "ids", "# This is the question", "\n", "", "else", ":", "\n", "                ", "if", "j", "==", "j_ans", ":", "# This is the correct answer (reorder to first in list)", "\n", "                    ", "a_lem", ".", "insert", "(", "0", ",", "ids", ")", "\n", "", "else", ":", "# Wrong answers come after correct one", "\n", "                    ", "a_lem", ".", "append", "(", "ids", ")", "\n", "\n", "", "", "", "if", "False", ":", "\n", "            ", "print", "(", "q_lem", ")", "\n", "for", "a", "in", "a_lem", ":", "\n", "                ", "print", "(", "\"   \"", ",", "a", ")", "\n", "\n", "", "", "df", ".", "at", "[", "prob", ",", "'q_lem'", "]", "=", "q_lem", "\n", "df", ".", "at", "[", "prob", ",", "'a_lem'", "]", "=", "a_lem", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.add_tfidf_questions": [[273, 278], ["None"], "function", ["None"], ["", "", "def", "add_tfidf_questions", "(", "df", ",", "node_lemma", ")", ":", "\n", "    ", "for", "prob", "in", "df", ".", "index", ":", "\n", "        ", "question_with_ans", "=", "df", ".", "at", "[", "prob", ",", "'q_lem'", "]", "+", "df", ".", "at", "[", "prob", ",", "'a_lem'", "]", "[", "0", "]", "\n", "df", ".", "at", "[", "prob", ",", "'q_tfidf'", "]", "=", "' '", ".", "join", "(", "\n", "[", "node_lemma", "[", "n", "]", "for", "n", "in", "question_with_ans", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.add_tfidf_explanation": [[280, 284], ["None"], "function", ["None"], ["", "", "def", "add_tfidf_explanation", "(", "dfe", ",", "node_lemma", ")", ":", "\n", "    ", "for", "e", "in", "dfe", ".", "index", ":", "\n", "        ", "ex_nodes", "=", "dfe", ".", "at", "[", "e", ",", "'nodes'", "]", "\n", "dfe", ".", "at", "[", "e", ",", "'e_tfidf'", "]", "=", "' '", ".", "join", "(", "[", "node_lemma", "[", "n", "]", "for", "n", "in", "ex_nodes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mdda_worldtree_corpus.None.preprocess.add_gold_explanation_idx": [[286, 307], ["type", "exs_str.split", "ex_str.split", "range", "ex_arr.append", "reason_arr.append", "len", "exs_arr.append", "len", "print", "df_exp.index.get_loc"], "function", ["None"], ["", "", "def", "add_gold_explanation_idx", "(", "df", ",", "df_exp", ")", ":", "\n", "    ", "df", "[", "'ex_gold'", "]", "=", "None", "\n", "df", "[", "'ex_reason'", "]", "=", "None", "\n", "for", "prob", "in", "df", ".", "index", ":", "\n", "        ", "exs_str", "=", "df", ".", "at", "[", "prob", ",", "'explanation'", "]", "\n", "ex_arr", ",", "reason_arr", "=", "[", "]", ",", "[", "]", "\n", "if", "type", "(", "exs_str", ")", "is", "str", ":", "\n", "            ", "for", "ex_str", "in", "exs_str", ".", "split", "(", "' '", ")", ":", "\n", "                ", "uid", ",", "reason", "=", "ex_str", ".", "split", "(", "'|'", ")", "\n", "ex_uid_rows", "=", "df_exp", "[", "df_exp", "[", "'uid_raw'", "]", "==", "uid", "]", "\n", "exs_arr", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "ex_uid_rows", ")", ")", ":", "\n", "                    ", "exs_arr", ".", "append", "(", "df_exp", ".", "index", ".", "get_loc", "(", "ex_uid_rows", ".", "iloc", "[", "i", "]", ".", "name", ")", ")", "\n", "", "if", "0", "==", "len", "(", "exs_arr", ")", ":", "\n", "                    ", "print", "(", "\"Missing ID '%s' in '%s'\"", "%", "(", "uid", ",", "exs_str", ",", ")", ")", "\n", "continue", "# missing uid, somehow", "\n", "#print(exs_arr)", "\n", "", "ex_arr", ".", "append", "(", "exs_arr", ")", "\n", "reason_arr", ".", "append", "(", "reason", ")", "\n", "", "", "df", ".", "at", "[", "prob", ",", "'ex_gold'", "]", "=", "ex_arr", "# Each explanation is an array of uid_raw aliases", "\n", "df", ".", "at", "[", "prob", ",", "'ex_reason'", "]", "=", "reason_arr", "# Only for those found", "\n", "\n"]]}