{"home.repos.pwc.inspect_result.RixonC_DINGO.None.DiSCO.DiSCO": [[8, 190], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "DiSCO.distributed_PCG_algorithm", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "DiSCO.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.broadcast", "torch.norm", "torch.norm", "torch.zeros", "torch.zeros", "torch.broadcast", "gradient.to.to", "torch.norm", "torch.norm", "DiSCO.get_updated_model", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "DiSCO.print_row", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "direction.to.to", "DiSCO.get_updated_model", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.norm", "torch.norm", "get_updated_model.parameters", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "direction.to.to", "DiSCO.get_updated_model", "gradient.to.cpu", "time.time", "torch.norm", "torch.norm", "direction.to.cpu", "direction.to.cpu", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DiSCO.distributed_PCG_algorithm", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient"], ["def", "DiSCO", "(", "model", ",", "worker", ",", "device", ",", "max_iterations", "=", "100", ",", "\n", "max_communication_rounds", "=", "200", ",", "gradient_norm_tolerance", "=", "1e-8", ",", "\n", "subproblem_tolerance", "=", "1e-4", ",", "subproblem_maximum_iterations", "=", "50", ")", ":", "\n", "    ", "\"\"\"Run the DiSCO algorithm.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance. The worker on the driver is\n            used to record test accuracy.\n        device (torch.device): The device tensors will be allocated to.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of\n            communication rounds.\n        gradient_norm_tolerance (float, optional): The smallest the norm of the\n            full gradient can be before the algorithm stops.\n        subproblem_tolerance (float, optional): The tolerance used by the\n            subproblem solvers.\n        subproblem_maximum_iterations (int, optional): The maximum number of\n            iterations used by the subproblem solver.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^86s}\\n\"", ".", "format", "(", "\" DiSCO \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "subproblem_failed", "=", "False", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#-------------------------- DiSCO iteration ---------------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", ">", "0", ":", "\n", "# This iteration requires an initial update to workers' model.", "\n", "            ", "if", "rank", "==", "0", ":", "\n", "# direction is from previous iteration.", "\n", "                ", "dist", ".", "broadcast", "(", "direction", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "                ", "direction", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "direction", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "direction", "=", "direction", ".", "to", "(", "device", ")", "\n", "model", "=", "get_updated_model", "(", "model", ",", "direction", ")", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "# All workers send local objective value and gradient to driver.", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "dist", ".", "broadcast", "(", "gradient", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "end_message", "=", "'gradient_norm_tolerance reached'", "\n", "break", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "gradient", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient", "=", "gradient", ".", "to", "(", "device", ")", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "break", "\n", "\n", "", "", "PCG_result", "=", "distributed_PCG_algorithm", "(", "model", ",", "worker", ",", "device", ",", "gradient", ",", "\n", "subproblem_tolerance", ",", "subproblem_maximum_iterations", ")", "\n", "\n", "if", "rank", ">", "0", ":", "\n", "            ", "if", "PCG_result", "is", "None", ":", "# PCG failed", "\n", "                ", "break", "\n", "", "total_communication_rounds", "+=", "PCG_result", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "if", "PCG_result", "is", "None", ":", "# PCG failed", "\n", "                ", "end_message", "=", "'PCG failed'", "\n", "subproblem_failed", "=", "True", "\n", "break", "\n", "", "v", ",", "delta", ",", "PCG_communication_rounds", "=", "PCG_result", "\n", "total_communication_rounds", "+=", "PCG_communication_rounds", "\n", "direction", "=", "(", "-", "1.0", "/", "(", "1", "+", "delta", ")", ")", "*", "v", "\n", "new_model", "=", "get_updated_model", "(", "model", ",", "direction", ")", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ Printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "torch", ".", "norm", "(", "direction", ")", ",", "loss", ",", "gradient_norm", ",", "\n", "test_accuracy", ")", "\n", "\n", "model", "=", "new_model", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "", "if", "(", "iteration", "==", "max_iterations", "\n", "or", "total_communication_rounds", ">=", "max_communication_rounds", ")", ":", "\n", "# Need to first get objective value and gradient norm on final model.", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "            ", "dist", ".", "broadcast", "(", "direction", ".", "cpu", "(", ")", ",", "0", ")", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "direction", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "direction", ",", "0", ")", "\n", "direction", "=", "direction", ".", "to", "(", "device", ")", "\n", "model", "=", "get_updated_model", "(", "model", ",", "direction", ")", "\n", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "test_accuracy", "=", "test_accuracy", ",", "\n", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "label", "=", "\"DiSCO\"", ",", "\n", "max_x", "=", "max_communication_rounds", ",", "failed", "=", "subproblem_failed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DiSCO.print_row": [[192, 227], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "update_direction_norm", "=", "0", ",", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "\n", "test_accuracy", "=", "0", ",", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for DiSCO.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of\n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the\n            iteration.\n        update_direction_norm (float, optional): The norm of the update\n            direction.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the\n            results table.\n    \"\"\"", "\n", "header", "=", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^10s}{:^14s}{:^20s}\"", ".", "format", "(", "\n", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\"||p_t||\"", ",", "\"f(w_t)\"", ",", "\"||\u2207f(w_t)||\"", ",", "\n", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:32s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10.2e}{:^10.2e}{:^14.2e}\"", "\n", "\"{:^20.2f}\"", ")", ".", "format", "(", "iteration", ",", "cumulative_communication_rounds", ",", "\n", "iteration_time", ",", "update_direction_norm", ",", "objective_value", ",", "\n", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DiSCO.get_updated_model": [[229, 245], ["copy.deepcopy", "torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "copy.deepcopy.parameters", "direction_split[].reshape", "copy.deepcopy.parameters"], "function", ["None"], ["", "", "def", "get_updated_model", "(", "model", ",", "update_direction", ")", ":", "\n", "    ", "\"\"\"Returns a new model with parameters equal to the addition of\n    update_direction and the input model parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n        update_direction (torch.Tensor): The update direction.\n    \"\"\"", "\n", "new_model", "=", "deepcopy", "(", "model", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "new_model", ".", "parameters", "(", ")", "]", "\n", "direction_split", "=", "torch", ".", "split", "(", "update_direction", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "new_model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", "+=", "direction_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "new_model", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DiSCO.distributed_PCG_algorithm": [[247, 346], ["torch.get_rank", "sum", "torch.device", "torch.device", "range", "torch.norm", "torch.norm", "torch.zeros", "torch.zeros", "gradient.clone", "r_t_plus_1.clone.clone", "s_t_plus_1.clone.clone", "torch.zeros", "torch.zeros", "p.numel", "torch.get_world_size", "torch.cat", "torch.cat", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "temp[].to", "worker.get_local_hessian_times_vector().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "hessian_times_u_t.to.to", "torch.mm", "torch.mm", "r_t_plus_1.clone", "torch.sqrt", "torch.sqrt", "v_t_plus_1.clone", "r_t_plus_1.clone", "r_t_plus_1.clone.clone", "u_t_plus_1.clone", "hessian_times_v_t_plus_1.clone", "model.parameters", "int", "int", "u_t_plus_1.clone.transpose", "torch.cat", "torch.cat", "torch.broadcast", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.cat", "torch.cat", "torch.broadcast", "torch.zeros", "torch.zeros", "u_t_plus_1.clone.cpu", "worker.get_local_hessian_times_vector", "r_t_plus_1.clone.transpose", "r_t_plus_1.transpose", "r_t_plus_1.clone.transpose", "torch.mm", "torch.mm", "torch.norm", "torch.norm", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "v_t_plus_1.transpose", "torch.mm", "torch.mm", "torch.zeros", "torch.zeros", "v_t_plus_1.transpose", "torch.ones", "torch.ones"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector"], ["", "def", "distributed_PCG_algorithm", "(", "model", ",", "worker", ",", "device", ",", "gradient", ",", "\n", "relative_residual_tolerance", ",", "max_iterations", ")", ":", "\n", "    ", "\"\"\"Run the distributed PCG algorithm. This implimentation does not use\n    preconditioning.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        gradient (torch.Tensor): The current full gradient.\n        relative_residual_tolerance (float): The relative residual\n            tolerance.\n        max_iterations (int): The maximum number of iterations.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "# Initialization.", "\n", "v_t", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "device", ")", "\n", "r_t", "=", "gradient", ".", "clone", "(", ")", "\n", "s_t", "=", "r_t", ".", "clone", "(", ")", "\n", "u_t", "=", "s_t", ".", "clone", "(", ")", "\n", "hessian_times_v_t", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "device", ")", "\n", "\n", "# Repeat.", "\n", "", "communication_rounds", "=", "0", "\n", "for", "iteration", "in", "range", "(", "max_iterations", ")", ":", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "# The 0 in temp indicates that PCG has not yet failed.", "\n", "            ", "temp", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "u_t", ".", "cpu", "(", ")", "]", ",", "\n", "dim", "=", "0", ")", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "temp", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "if", "int", "(", "temp", "[", "0", ",", "0", "]", ")", "==", "1", ":", "# PCG failed in previous iteration", "\n", "                ", "return", "None", "\n", "", "if", "int", "(", "temp", "[", "0", ",", "0", "]", ")", "==", "-", "1", ":", "# Relative residual tolerance reached", "\n", "                ", "break", "\n", "", "u_t", "=", "temp", "[", "1", ":", "]", ".", "to", "(", "device", ")", "\n", "local_hessian_times_u_t", "=", "worker", ".", "get_local_hessian_times_vector", "(", "\n", "model", ",", "u_t", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_hessian_times_u_t", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "hessian_times_u_t", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "hessian_times_u_t", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "hessian_times_u_t", "=", "hessian_times_u_t", ".", "to", "(", "device", ")", "\n", "hessian_times_u_t", "*=", "1.0", "/", "num_workers", "\n", "uHu", "=", "torch", ".", "mm", "(", "u_t", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_u_t", ")", "\n", "if", "uHu", "<=", "0", ":", "# PCG has failed", "\n", "                ", "temp", "=", "torch", ".", "cat", "(", "[", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "torch", ".", "zeros", "(", "(", "dimension", ",", "1", ")", ",", "device", "=", "cpu", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The 1 indicates that PCG failed.", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "return", "None", "\n", "", "alpha_t", "=", "torch", ".", "mm", "(", "r_t", ".", "transpose", "(", "0", ",", "1", ")", ",", "s_t", ")", "/", "uHu", "\n", "v_t_plus_1", "=", "v_t", "+", "alpha_t", "*", "u_t", "\n", "hessian_times_v_t_plus_1", "=", "hessian_times_v_t", "+", "alpha_t", "*", "hessian_times_u_t", "\n", "r_t_plus_1", "=", "r_t", "-", "alpha_t", "*", "hessian_times_u_t", "\n", "s_t_plus_1", "=", "r_t_plus_1", ".", "clone", "(", ")", "\n", "beta_t", "=", "torch", ".", "mm", "(", "r_t_plus_1", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "s_t_plus_1", ")", "/", "torch", ".", "mm", "(", "r_t", ".", "transpose", "(", "0", ",", "1", ")", ",", "s_t", ")", "\n", "u_t_plus_1", "=", "s_t_plus_1", "+", "beta_t", "*", "u_t", "\n", "\n", "delta", "=", "torch", ".", "sqrt", "(", "torch", ".", "mm", "(", "v_t_plus_1", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "hessian_times_v_t", ")", "\n", "+", "alpha_t", "*", "torch", ".", "mm", "(", "v_t_plus_1", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "hessian_times_u_t", ")", ")", "\n", "\n", "v_t", "=", "v_t_plus_1", ".", "clone", "(", ")", "\n", "r_t", "=", "r_t_plus_1", ".", "clone", "(", ")", "\n", "s_t", "=", "s_t_plus_1", ".", "clone", "(", ")", "\n", "u_t", "=", "u_t_plus_1", ".", "clone", "(", ")", "\n", "hessian_times_v_t", "=", "hessian_times_v_t_plus_1", ".", "clone", "(", ")", "\n", "\n", "if", "(", "torch", ".", "norm", "(", "hessian_times_v_t", "-", "gradient", ")", "/", "gradient_norm", "\n", "<=", "relative_residual_tolerance", ")", ":", "\n", "                ", "temp", "=", "torch", ".", "cat", "(", "[", "-", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "torch", ".", "zeros", "(", "(", "dimension", ",", "1", ")", ",", "device", "=", "cpu", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The -1 indicates to break.", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "break", "\n", "\n", "", "", "", "if", "rank", "==", "0", ":", "\n", "        ", "return", "v_t", ",", "delta", ",", "communication_rounds", "\n", "", "else", ":", "\n", "        ", "return", "communication_rounds", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO_with_only_case_1.DINGO_with_only_case_1": [[8, 193], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "loss_list.append", "torch.norm", "torch.norm", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "DINGO_with_only_case_1.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "torch.cat", "torch.cat", "torch.broadcast", "torch.norm", "torch.norm", "torch.norm.pow", "torch.zeros", "torch.zeros", "torch.broadcast", "alpha_and_gradient.to.to", "torch.norm", "torch.norm", "DINGO_with_only_case_1.get_update_direction", "DINGO_with_only_case_1.get_update_direction", "DINGO_with_only_case_1.get_local_line_search_matrix", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "line_search_matrix.to.to", "DINGO_with_only_case_1.line_search", "loss_list.append", "gradient_norm_list.append", "step_size_list.append", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "DINGO_with_only_case_1.print_row", "get_updated_model.parameters", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "DINGO_with_only_case_1.get_updated_model", "torch.mm", "torch.mm", "print", "time.time", "torch.norm", "torch.norm", "torch.tensor().reshape", "torch.tensor().reshape", "gradient.cpu", "get_update_direction.transpose", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "torch.tensor", "torch.tensor", "float"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_update_direction", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_update_direction", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_local_line_search_matrix", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.line_search", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient"], ["def", "DINGO_with_only_case_1", "(", "model", ",", "worker", ",", "device", ",", "theta", "=", "1e-4", ",", "\n", "max_iterations", "=", "100", ",", "max_communication_rounds", "=", "200", ",", "\n", "gradient_norm_tolerance", "=", "1e-8", ",", "line_search_rho", "=", "1e-4", ",", "\n", "line_search_max_iterations", "=", "50", ")", ":", "\n", "    ", "\"\"\"Run the DINGO algorithm with only Case 1.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        theta (float, optional): The hyperparameter theta in the DINGO\n            algorithm.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of\n            communication rounds.\n        gradient_norm_tolerance (float, optional): The smallest the norm of the\n            full gradient can be before the algorithm stops.\n        line_search_rho (float, optional): Armijo line search parameter.\n        line_search_max_iterations (int, optional): The maximum number of line\n            search iterations.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^116s}\\n\"", ".", "format", "(", "\" DINGO With Only Case 1 \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "step_size_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#----------------------- DINGO Case 1 iteration -----------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", "==", "0", ":", "\n", "# This iteration requires an additional communication round.", "\n", "            ", "'''\n            In subsequent iterations, the driver will broadcast the step-size\n            to update workers' model.\n            '''", "\n", "if", "rank", ">", "0", ":", "\n", "                ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "# Workers send local objective value and gradient to driver.", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "                ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "step_size", "=", "0.0", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "# The driver broadcasts the step-size and gradient to all workers.", "\n", "# step_size is from previous line search.", "\n", "            ", "alpha_and_gradient", "=", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "tensor", "(", "float", "(", "step_size", ")", ",", "device", "=", "cpu", ")", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "gradient", ".", "cpu", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "broadcast", "(", "alpha_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "end_message", "=", "'gradient_norm_tolerance reached'", "\n", "break", "\n", "", "gradient_norm_squared", "=", "gradient_norm", ".", "pow", "(", "2", ")", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "alpha_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "alpha_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "alpha_and_gradient", "=", "alpha_and_gradient", ".", "to", "(", "device", ")", "\n", "step_size", "=", "alpha_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "alpha_and_gradient", "[", "1", ":", "]", "\n", "if", "iteration", ">", "0", ":", "\n", "# All workers update to current model.", "\n", "# This worker node has direction from previous line search.", "\n", "                ", "model", "=", "get_updated_model", "(", "model", ",", "direction", ",", "step_size", ")", "\n", "", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "break", "\n", "\n", "# Update Direction.", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "            ", "direction", ",", "hessian_times_gradient", "=", "get_update_direction", "(", "model", ",", "\n", "worker", ",", "device", ",", "gradient", ")", "\n", "total_communication_rounds", "+=", "2", "\n", "# The Case 1 direction might not be a suitable descent direction.", "\n", "if", "(", "torch", ".", "mm", "(", "direction", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_gradient", ")", "\n", ">", "-", "theta", "*", "gradient_norm_squared", ")", ":", "\n", "                ", "print", "(", "\"Warning: At iteration t={}, Case 1 direction does not\"", "\n", "\"satisfy <p,Hg> <= -\u03b8||g||\"", ".", "format", "(", "iteration", ")", ")", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "direction", "=", "get_update_direction", "(", "model", ",", "worker", ",", "device", ",", "gradient", ")", "\n", "total_communication_rounds", "+=", "2", "\n", "\n", "# Line Search.", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_line_search_matrix", "=", "get_local_line_search_matrix", "(", "model", ",", "\n", "worker", ",", "direction", ",", "line_search_max_iterations", ")", "\n", "dist", ".", "reduce", "(", "local_line_search_matrix", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver averages all workers' local line-search matrix.", "\n", "            ", "line_search_matrix", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "\n", "line_search_max_iterations", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "line_search_matrix", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "line_search_matrix", "=", "line_search_matrix", ".", "to", "(", "device", ")", "\n", "line_search_matrix", "*=", "1.0", "/", "num_workers", "\n", "new_model", ",", "new_loss", ",", "new_gradient", ",", "line_search_exp", ",", "step_size", "=", "line_search", "(", "model", ",", "line_search_matrix", ",", "gradient_norm_squared", ",", "\n", "direction", ",", "hessian_times_gradient", ",", "\n", "line_search_rho", ")", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ Printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "step_size_list", ".", "append", "(", "step_size", ")", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "1", ",", "line_search_exp", ",", "step_size", ",", "torch", ".", "norm", "(", "direction", ")", ",", "\n", "loss", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "\n", "loss", "=", "new_loss", "\n", "gradient", "=", "new_gradient", "\n", "model", "=", "new_model", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "\n", "test_accuracy", "=", "test_accuracy", ",", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "step_size_list", ",", "\n", "label", "=", "\"DINGO\"", ",", "max_x", "=", "max_communication_rounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO_with_only_case_1.print_row": [[195, 236], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "case", "=", "1", ",", "line_search_exp", "=", "0", ",", "step_size", "=", "1", ",", "update_direction_norm", "=", "0", ",", "\n", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "test_accuracy", "=", "0", ",", "\n", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for DINGO.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of\n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the\n            iteration.\n        case (int, optional): The case the iteration belongs to.\n        line_search_exp (int, optional): The line search exponent found.\n        step_size (float, optional): The step size found.\n        update_direction_norm (float, optional): The norm of the update\n            direction.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the\n            results table.\n    \"\"\"", "\n", "header", "=", "(", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^10s}{:^10s}{:^10s}\"", "\n", "\"{:^10s}{:^14s}{:^20s}\"", ")", ".", "format", "(", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\n", "\"Case\"", ",", "\"LS Exp\"", ",", "\"Step Size\"", ",", "\"||p_t||\"", ",", "\"f(w_t)\"", ",", "\n", "\"||\u2207f(w_t)||\"", ",", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:62s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10d}{:^10d}{:^10.2e}\"", "\n", "\"{:^10.2e}{:^10.2e}{:^14.2e}{:^20.2f}\"", ")", ".", "format", "(", "\n", "iteration", ",", "cumulative_communication_rounds", ",", "iteration_time", ",", "\n", "case", ",", "line_search_exp", ",", "step_size", ",", "update_direction_norm", ",", "\n", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO_with_only_case_1.get_update_direction": [[238, 277], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "worker.get_local_hessian_times_vector().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "Hg_and_direction.to.to", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "direction.to.to", "p.numel", "worker.get_local_hessian_inverse_times_vector().cpu", "direction.to.cpu", "model.parameters", "worker.get_local_hessian_times_vector", "worker.get_local_hessian_inverse_times_vector"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_inverse_times_vector"], ["", "", "def", "get_update_direction", "(", "model", ",", "worker", ",", "device", ",", "gradient", ")", ":", "\n", "    ", "\"\"\"Returns the Case 1 update direction of DINGO. Also returns the\n    Hessian-gradient product to the driver node.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        gradient (torch.Tensor): The current full gradient.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", ">", "0", ":", "\n", "        ", "local_hessian_times_gradient", "=", "worker", ".", "get_local_hessian_times_vector", "(", "model", ",", "gradient", ")", ".", "cpu", "(", ")", "\n", "local_direction", "=", "-", "1.0", "*", "worker", ".", "get_local_hessian_inverse_times_vector", "(", "\n", "model", ",", "gradient", ",", "\"minresQLP\"", ")", ".", "cpu", "(", ")", "\n", "local_Hg_and_direction", "=", "torch", ".", "cat", "(", "[", "local_hessian_times_gradient", ",", "\n", "local_direction", "]", ",", "dim", "=", "1", ")", "\n", "dist", ".", "reduce", "(", "local_Hg_and_direction", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "Hg_and_direction", "=", "torch", ".", "zeros", "(", "dimension", ",", "2", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "Hg_and_direction", ",", "0", ")", "\n", "Hg_and_direction", "=", "Hg_and_direction", ".", "to", "(", "device", ")", "\n", "Hg_and_direction", "*=", "1.0", "/", "num_workers", "\n", "hessian_times_gradient", "=", "Hg_and_direction", "[", ":", ",", "0", ":", "1", "]", "\n", "direction", "=", "Hg_and_direction", "[", ":", ",", "1", ":", "2", "]", "\n", "dist", ".", "broadcast", "(", "direction", ".", "cpu", "(", ")", ",", "0", ")", "\n", "return", "direction", ",", "hessian_times_gradient", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "        ", "direction", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "direction", ",", "0", ")", "\n", "direction", "=", "direction", ".", "to", "(", "device", ")", "\n", "return", "direction", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO_with_only_case_1.get_updated_model": [[283, 300], ["copy.deepcopy", "torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "copy.deepcopy.parameters", "copy.deepcopy.parameters", "direction_split[].reshape"], "function", ["None"], ["", "", "def", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", ":", "\n", "    ", "\"\"\"Returns a new model with parameters equal to the addition of\n    step_size*update_direction and the input model parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n        update_direction (torch.Tensor): The update direction.\n        step_size (float): The step size.\n    \"\"\"", "\n", "new_model", "=", "deepcopy", "(", "model", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "new_model", ".", "parameters", "(", ")", "]", "\n", "direction_split", "=", "torch", ".", "split", "(", "update_direction", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "new_model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", "+=", "step_size", "*", "direction_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "new_model", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO_with_only_case_1.get_local_line_search_matrix": [[302, 326], ["torch.cat", "torch.cat", "DINGO_with_only_case_1.get_updated_model", "worker.get_local_loss().reshape().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "local_vector_list.append", "worker.get_local_loss().reshape", "worker.get_local_gradient", "worker.get_local_loss"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss"], ["", "def", "get_local_line_search_matrix", "(", "model", ",", "worker", ",", "update_direction", ",", "\n", "line_search_max_iterations", ")", ":", "\n", "    ", "\"\"\"Return a tensor where column k is the local objective value and local\n    gradient at the point: weights + 0.5**k * update_direction.\n\n    Args:\n        model (torch.nn.Module): A model.\n        worker (Worker): A Worker class instance.\n        update_direction (torch.Tensor): The update direction.\n        line_search_max_iterations (int): The maximum number of line search\n            iterations.\n    \"\"\"", "\n", "local_vector_list", "=", "[", "]", "\n", "line_search_exp", "=", "0", "\n", "step_size", "=", "1.0", "\n", "while", "line_search_exp", "<", "line_search_max_iterations", ":", "\n", "        ", "temp_model", "=", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", "\n", "temp_loss", "=", "worker", ".", "get_local_loss", "(", "temp_model", ")", ".", "reshape", "(", "1", ",", "1", ")", ".", "cpu", "(", ")", "\n", "temp_gradient", "=", "worker", ".", "get_local_gradient", "(", "temp_model", ")", ".", "cpu", "(", ")", "\n", "temp_vector", "=", "torch", ".", "cat", "(", "[", "temp_loss", ",", "temp_gradient", "]", ",", "dim", "=", "0", ")", "\n", "local_vector_list", ".", "append", "(", "temp_vector", ")", "\n", "line_search_exp", "+=", "1", "\n", "step_size", "=", "step_size", "/", "2", "\n", "", "return", "torch", ".", "cat", "(", "local_vector_list", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO_with_only_case_1.line_search": [[328, 363], ["torch.mm", "torch.mm", "DINGO_with_only_case_1.get_updated_model", "update_direction.transpose", "torch.mm", "torch.mm", "new_gradient.transpose"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model"], ["", "def", "line_search", "(", "model", ",", "line_search_matrix", ",", "gradient_norm_squared", ",", "\n", "update_direction", ",", "hessian_times_gradient", ",", "line_search_rho", ")", ":", "\n", "    ", "\"\"\"Compute the largest step-size that passes backtracking line search on\n    the square of the norm of the gradient. Otherwise, return the smallest\n    step-size.\n\n    Args:\n        model (torch.nn.Module): The current model.\n        line_search_matrix (torch.Tensor): A matrix where column k is the\n            objective value and gradient at the point:\n            weights + 0.5**k * update_direction.\n        gradient_norm_squared (float): The square of the norm of the full\n            gradient.\n        update_direction (torch.Tensor): The update direction.\n        hessian_times_gradient (torch.Tensor): The current Hessian-gradient\n            product.\n        line_search_rho (float): Armijo line search parameter.\n    \"\"\"", "\n", "line_search_exp", "=", "0", "\n", "step_size", "=", "1.0", "\n", "line_search_max_iterations", "=", "line_search_matrix", ".", "shape", "[", "1", "]", "\n", "direction_dot_hessian_times_gradient", "=", "torch", ".", "mm", "(", "\n", "update_direction", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_gradient", ")", "\n", "new_loss", "=", "line_search_matrix", "[", "0", ",", "0", "]", "\n", "new_gradient", "=", "line_search_matrix", "[", "1", ":", ",", "0", ":", "1", "]", "\n", "while", "(", "torch", ".", "mm", "(", "new_gradient", ".", "transpose", "(", "0", ",", "1", ")", ",", "new_gradient", ")", "\n", ">", "gradient_norm_squared", "\n", "+", "2", "*", "step_size", "*", "line_search_rho", "*", "direction_dot_hessian_times_gradient", "\n", "and", "line_search_exp", "<", "line_search_max_iterations", ")", ":", "\n", "        ", "line_search_exp", "+=", "1", "\n", "step_size", "=", "step_size", "/", "2", "\n", "new_loss", "=", "line_search_matrix", "[", "0", ",", "line_search_exp", "]", "\n", "new_gradient", "=", "line_search_matrix", "[", "1", ":", ",", "line_search_exp", ":", "line_search_exp", "+", "1", "]", "\n", "", "new_model", "=", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", "\n", "return", "new_model", ",", "new_loss", ",", "new_gradient", ",", "line_search_exp", ",", "step_size", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.GIANT": [[8, 242], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "GIANT.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "torch.broadcast", "torch.norm", "torch.norm", "torch.zeros", "torch.zeros", "torch.broadcast", "gradient.to.to", "torch.norm", "torch.norm", "worker.get_local_hessian_inverse_times_vector", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "torch.broadcast", "direction.to.to", "torch.zeros", "torch.zeros", "torch.broadcast", "direction.to.to", "get_local_line_search_values().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "line_search_values.to.to", "GIANT.line_search", "loss_list.append", "gradient_norm_list.append", "step_size_list.append", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "GIANT.print_row", "torch.tensor().reshape", "torch.tensor().reshape", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "step_size.item.item", "GIANT.get_updated_model", "worker.get_local_gradient().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "gradient.to.to", "torch.norm", "torch.norm", "get_updated_model.parameters", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.tensor().reshape", "torch.tensor().reshape", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "step_size.item.item", "GIANT.get_updated_model", "worker.get_local_gradient().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "gradient.to.to", "gradient.to.cpu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "int", "int", "time.time", "torch.norm", "torch.norm", "int", "GIANT.get_local_line_search_values", "torch.tensor", "torch.tensor", "worker.get_local_gradient", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "torch.tensor", "torch.tensor", "worker.get_local_gradient", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "worker.get_local_hessian_inverse_times_vector.cpu", "float", "float"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_inverse_times_vector", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.line_search", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.get_local_line_search_values", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient"], ["def", "GIANT", "(", "model", ",", "worker", ",", "device", ",", "max_iterations", "=", "100", ",", "\n", "max_communication_rounds", "=", "200", ",", "gradient_norm_tolerance", "=", "1e-8", ",", "\n", "line_search_rho", "=", "1e-4", ",", "line_search_max_iterations", "=", "50", ")", ":", "\n", "    ", "\"\"\"Run the GIANT algorithm.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance. The worker on the driver is\n            used to record test accuracy.\n        device (torch.device): The device tensors will be allocated to.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of \n            communication rounds.\n        gradient_norm_tolerance (float, optional): The smallest the norm of the\n            full gradient can be before the algorithm stops.\n        line_search_rho (float, optional): Armijo line search parameter.\n        line_search_max_iterations (int, optional): The maximum number of line \n            search iterations.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^106s}\\n\"", ".", "format", "(", "\" GIANT \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "step_size_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "subproblem_failed", "=", "False", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#-------------------------- GIANT iteration ---------------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", "==", "0", ":", "\n", "# This iteration doesn't require initial update to workers' model.", "\n", "            ", "if", "rank", ">", "0", ":", "\n", "                ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "# Workers send local objective value and gradient to driver.", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "                ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "\n", "", "", "else", ":", "\n", "# Broadcast step_size to update workers' model and compute gradient.", "\n", "            ", "if", "rank", "==", "0", ":", "\n", "# step_size is from previous line search.", "\n", "                ", "step_size", "=", "torch", ".", "tensor", "(", "float", "(", "step_size", ")", ",", "\n", "device", "=", "cpu", ")", ".", "reshape", "(", "1", ",", "1", ")", "\n", "dist", ".", "broadcast", "(", "step_size", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "                ", "step_size", "=", "torch", ".", "zeros", "(", "1", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "step_size", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "step_size", "=", "step_size", ".", "item", "(", ")", "\n", "# This worker node has direction from previous line search.", "\n", "model", "=", "get_updated_model", "(", "model", ",", "direction", ",", "step_size", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "                ", "gradient", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient", "=", "gradient", ".", "to", "(", "device", ")", "\n", "gradient", "*=", "1.0", "/", "num_workers", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "            ", "dist", ".", "broadcast", "(", "gradient", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "end_message", "=", "'gradient_norm_tolerance reached'", "\n", "break", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "gradient", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient", "=", "gradient", ".", "to", "(", "device", ")", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "break", "\n", "", "local_hessian_inverse_times_gradient", "=", "worker", ".", "get_local_hessian_inverse_times_vector", "(", "model", ",", "\n", "gradient", ",", "\"CG\"", ")", "\n", "# CG could have failed.", "\n", "if", "local_hessian_inverse_times_gradient", "is", "None", ":", "\n", "                ", "v", "=", "torch", ".", "cat", "(", "[", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "torch", ".", "zeros", "(", "(", "dimension", ",", "1", ")", ",", "device", "=", "cpu", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The 1 indicates that CG failed.", "\n", "", "else", ":", "\n", "                ", "v", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "local_hessian_inverse_times_gradient", ".", "cpu", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The 0 indicates that CG passed.", "\n", "", "dist", ".", "reduce", "(", "v", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "direction", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "direction", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "dist", ".", "broadcast", "(", "direction", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "if", "int", "(", "direction", "[", "0", ",", "0", "]", ")", ">", "0", ":", "# CG failed on at least 1 worker node", "\n", "                ", "end_message", "=", "'CG failed on {} worker nodes'", ".", "format", "(", "\n", "int", "(", "direction", "[", "0", ",", "0", "]", ")", ")", "\n", "subproblem_failed", "=", "True", "\n", "break", "\n", "", "direction", "=", "direction", ".", "to", "(", "device", ")", "\n", "direction", "=", "direction", "[", "1", ":", "]", "\n", "direction", "*=", "-", "1.0", "/", "num_workers", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "direction", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "direction", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "if", "int", "(", "direction", "[", "0", ",", "0", "]", ")", ">", "0", ":", "# CG failed on at least 1 worker node", "\n", "                ", "break", "\n", "", "direction", "=", "direction", ".", "to", "(", "device", ")", "\n", "direction", "=", "direction", "[", "1", ":", "]", "\n", "direction", "*=", "-", "1.0", "/", "num_workers", "\n", "local_line_search_values", "=", "get_local_line_search_values", "(", "\n", "model", ",", "worker", ",", "direction", ",", "line_search_max_iterations", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_line_search_values", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "line_search_values", "=", "torch", ".", "zeros", "(", "1", ",", "line_search_max_iterations", ",", "\n", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "line_search_values", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "line_search_values", "=", "line_search_values", ".", "to", "(", "device", ")", "\n", "line_search_values", "*=", "1.0", "/", "num_workers", "\n", "new_model", ",", "new_loss", ",", "line_search_exp", ",", "step_size", "=", "line_search", "(", "\n", "model", ",", "line_search_values", ",", "loss", ",", "gradient", ",", "direction", ",", "\n", "line_search_rho", ")", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ Printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "step_size_list", ".", "append", "(", "step_size", ")", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "line_search_exp", ",", "step_size", ",", "torch", ".", "norm", "(", "direction", ")", ",", "\n", "loss", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "\n", "loss", "=", "new_loss", "\n", "model", "=", "new_model", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "", "if", "(", "iteration", "==", "max_iterations", "\n", "or", "total_communication_rounds", ">=", "max_communication_rounds", ")", ":", "\n", "# Need to first get gradient norm on the final model.", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "            ", "step_size", "=", "torch", ".", "tensor", "(", "float", "(", "step_size", ")", ",", "device", "=", "cpu", ")", ".", "reshape", "(", "1", ",", "1", ")", "\n", "dist", ".", "broadcast", "(", "step_size", ",", "0", ")", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "step_size", "=", "torch", ".", "zeros", "(", "1", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "step_size", ",", "0", ")", "\n", "step_size", "=", "step_size", ".", "item", "(", ")", "\n", "model", "=", "get_updated_model", "(", "model", ",", "direction", ",", "step_size", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_gradient", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "gradient", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "gradient", ",", "0", ")", "\n", "gradient", "=", "gradient", ".", "to", "(", "device", ")", "\n", "gradient", "*=", "1.0", "/", "num_workers", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "\n", "test_accuracy", "=", "test_accuracy", ",", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "step_size_list", ",", "\n", "label", "=", "\"GIANT\"", ",", "max_x", "=", "max_communication_rounds", ",", "\n", "failed", "=", "subproblem_failed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.print_row": [[244, 284], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "line_search_exp", "=", "0", ",", "step_size", "=", "1", ",", "update_direction_norm", "=", "0", ",", "\n", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "test_accuracy", "=", "0", ",", "\n", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for GIANT.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of \n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the \n            iteration.\n        line_search_exp (int, optional): The line search exponent found.\n        step_size (float, optional): The step size found.\n        update_direction_norm (float, optional): The norm of the update \n            direction.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the \n            results table.\n    \"\"\"", "\n", "header", "=", "(", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^10s}{:^10s}{:^10s}{:^14s}\"", "\n", "\"{:^20s}\"", ")", ".", "format", "(", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\"LS Exp\"", ",", "\n", "\"Step Size\"", ",", "\"||p_t||\"", ",", "\"f(w_t)\"", ",", "\n", "\"||\u2207f(w_t)||\"", ",", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:52s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10d}{:^10.2e}{:^10.2e}{:^10.2e}\"", "\n", "\"{:^14.2e}{:^20.2f}\"", ")", ".", "format", "(", "iteration", ",", "\n", "cumulative_communication_rounds", ",", "iteration_time", ",", "\n", "line_search_exp", ",", "step_size", ",", "update_direction_norm", ",", "\n", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.get_updated_model": [[286, 303], ["copy.deepcopy", "torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "copy.deepcopy.parameters", "copy.deepcopy.parameters", "direction_split[].reshape"], "function", ["None"], ["", "", "def", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", ":", "\n", "    ", "\"\"\"Returns a new model with parameters equal to the addition of \n    step_size*update_direction and the input model parameters.\n    \n    Arguments:\n        model (torch.nn.Module): A model.\n        update_direction (torch.Tensor): The update direction.\n        step_size (float): The step size.\n    \"\"\"", "\n", "new_model", "=", "deepcopy", "(", "model", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "new_model", ".", "parameters", "(", ")", "]", "\n", "direction_split", "=", "torch", ".", "split", "(", "update_direction", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "new_model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", "+=", "step_size", "*", "direction_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "new_model", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.get_local_line_search_values": [[305, 327], ["torch.cat", "torch.cat", "GIANT.get_updated_model", "worker.get_local_loss", "local_loss_list.append", "worker.get_local_loss.reshape"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss"], ["", "def", "get_local_line_search_values", "(", "model", ",", "worker", ",", "update_direction", ",", "\n", "line_search_max_iterations", ")", ":", "\n", "    ", "\"\"\"Return a tensor where column k is the local objective value at the \n    point: weights + 0.5**k * update_direction.\n\n    Args:\n        model (torch.nn.Module): A model.\n        worker (Worker): A Worker class instance.\n        update_direction (torch.Tensor): The update direction.\n        line_search_max_iterations (int): The maximum number of line search \n            iterations.\n    \"\"\"", "\n", "local_loss_list", "=", "[", "]", "\n", "line_search_exp", "=", "0", "\n", "step_size", "=", "1.0", "\n", "while", "line_search_exp", "<", "line_search_max_iterations", ":", "\n", "        ", "temp_model", "=", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", "\n", "temp_loss", "=", "worker", ".", "get_local_loss", "(", "temp_model", ")", "\n", "local_loss_list", ".", "append", "(", "temp_loss", ".", "reshape", "(", "1", ",", "1", ")", ")", "\n", "line_search_exp", "+=", "1", "\n", "step_size", "=", "step_size", "/", "2", "\n", "", "return", "torch", ".", "cat", "(", "local_loss_list", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.line_search": [[329, 356], ["torch.mm", "torch.mm", "GIANT.get_updated_model", "update_direction.transpose"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model"], ["", "def", "line_search", "(", "model", ",", "line_search_values", ",", "loss", ",", "gradient", ",", "update_direction", ",", "\n", "line_search_rho", ")", ":", "\n", "    ", "\"\"\"Compute the largest step-size that passes backtracking line search on \n    the objective value. Otherwise, return the smallest step-size.\n\n    Args:\n        model (torch.nn.Module): The current model.\n        line_search_values (torch.Tensor): A tensor where column k is the  \n            objective value at the point: weights + 0.5**k * update_direction.\n        loss (float): The current objective value.\n        gradient (torch.Tensor): The current full gradient.\n        update_direction (torch.Tensor): The update direction.\n        line_search_rho (float): Armijo line search parameter.\n    \"\"\"", "\n", "line_search_exp", "=", "0", "\n", "step_size", "=", "1.0", "\n", "line_search_max_iterations", "=", "line_search_values", ".", "shape", "[", "1", "]", "\n", "direction_dot_gradient", "=", "torch", ".", "mm", "(", "update_direction", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "gradient", ")", "\n", "new_loss", "=", "line_search_values", "[", "0", ",", "0", "]", "\n", "while", "(", "new_loss", ">", "loss", "+", "step_size", "*", "line_search_rho", "*", "direction_dot_gradient", "\n", "and", "line_search_exp", "<", "line_search_max_iterations", ")", ":", "\n", "        ", "line_search_exp", "+=", "1", "\n", "step_size", "=", "step_size", "/", "2", "\n", "new_loss", "=", "line_search_values", "[", "0", ",", "line_search_exp", "]", "\n", "", "new_model", "=", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", "\n", "return", "new_model", ",", "new_loss", ",", "line_search_exp", ",", "step_size", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.minresQLP": [[4, 388], ["b.reshape.reshape", "torch.norm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.norm", "torch.norm", "torch.norm", "b.reshape.size", "minres_qlp.Precond", "torch.mm", "np.append", "print", "print", "print", "print", "print", "print", "minres_qlp.Ax", "torch.mm", "torch.sqrt", "minres_qlp.SymGivens", "torch.sqrt", "torch.is_tensor", "torch.is_tensor", "torch.sqrt", "minres_qlp.SymGivens", "torch.abs", "max", "torch.sqrt", "print", "print", "print", "print", "print", "print", "torch.stack", "Precond.transpose", "print", "torch.sqrt", "Precond.transpose", "torch.norm", "minres_qlp.Precond", "torch.mm", "minres_qlp.SymGivens", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "print", "print", "minres_qlp.Ax", "minres_qlp.Ax", "torch.finfo", "print", "print", "r2.transpose", "torch.sqrt", "print", "torch.tensor", "torch.abs", "torch.sqrt", "torch.tensor", "torch.zeros", "min", "torch.finfo", "torch.stack", "torch.stack", "print", "torch.finfo", "float", "torch.finfo", "float", "print", "print", "print", "print", "int"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Precond", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Ax", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.SymGivens", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.SymGivens", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Precond", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.SymGivens", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Ax", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Ax"], ["def", "minresQLP", "(", "A", ",", "b", ",", "device", ",", "rtol", "=", "1e-4", ",", "maxit", "=", "100", ",", "M", "=", "None", ",", "shift", "=", "0", ",", "\n", "maxxnorm", "=", "1e7", ",", "Acondlim", "=", "1e15", ",", "TranCond", "=", "1e7", ",", "show", "=", "False", ",", "\n", "rnormvec", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute an approximation of A_pseudoinverse*b using MinresQLP.\n    \n    Arguments:\n        A (function): Matrix-vector product function.\n        b (torch.Tensor): A vector.\n        device (torch.device): The device tensors will be allocated to.\n        rtol (float, optional): The relative residual tolerance.\n        maxit (int, optional): The maximum number of iterations.\n    \"\"\"", "\n", "if", "rnormvec", ":", "\n", "        ", "resvec", "=", "[", "]", "\n", "Aresvec", "=", "[", "]", "\n", "\n", "", "b", "=", "b", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "n", "=", "b", ".", "size", "(", ")", "[", "0", "]", "\n", "r2", "=", "b", "\n", "r3", "=", "r2", "\n", "beta1", "=", "torch", ".", "norm", "(", "r2", ")", "\n", "\n", "if", "M", "is", "None", ":", "\n", "        ", "noprecon", "=", "True", "\n", "pass", "\n", "", "else", ":", "\n", "        ", "noprecon", "=", "False", "\n", "r3", "=", "Precond", "(", "M", ",", "r2", ")", "\n", "beta1", "=", "torch", ".", "mm", "(", "r3", ".", "transpose", "(", "0", ",", "1", ")", ",", "r2", ")", "\n", "if", "beta1", "<", "0", ":", "\n", "            ", "print", "(", "'Error: \"M\" is indefinite!'", ")", "\n", "", "else", ":", "\n", "            ", "beta1", "=", "torch", ".", "sqrt", "(", "beta1", ")", "\n", "\n", "## Initialize", "\n", "", "", "flag0", "=", "-", "2", "\n", "flag", "=", "-", "2", "\n", "iters", "=", "0", "\n", "QLPiter", "=", "0", "\n", "beta", "=", "0", "\n", "tau", "=", "0", "\n", "taul", "=", "0", "\n", "phi", "=", "beta1", "\n", "betan", "=", "beta1", "\n", "gmin", "=", "0", "\n", "cs", "=", "-", "1", "\n", "sn", "=", "0", "\n", "cr1", "=", "-", "1", "\n", "sr1", "=", "0", "\n", "cr2", "=", "-", "1", "\n", "sr2", "=", "0", "\n", "dltan", "=", "0", "\n", "eplnn", "=", "0", "\n", "gama", "=", "0", "\n", "gamal", "=", "0", "\n", "gamal2", "=", "0", "\n", "eta", "=", "0", "\n", "etal", "=", "0", "\n", "etal2", "=", "0", "\n", "vepln", "=", "0", "\n", "veplnl", "=", "0", "\n", "veplnl2", "=", "0", "\n", "ul3", "=", "0", "\n", "ul2", "=", "0", "\n", "ul", "=", "0", "\n", "u", "=", "0", "\n", "rnorm", "=", "betan", "\n", "xnorm", "=", "0", "\n", "xl2norm", "=", "0", "\n", "Axnorm", "=", "0", "\n", "Anorm", "=", "0", "\n", "Acond", "=", "1", "\n", "relres", "=", "rnorm", "/", "(", "beta1", "+", "1e-50", ")", "\n", "x", "=", "torch", ".", "zeros", "(", "n", ",", "1", ",", "device", "=", "device", ")", "\n", "w", "=", "torch", ".", "zeros", "(", "n", ",", "1", ",", "device", "=", "device", ")", "\n", "wl", "=", "torch", ".", "zeros", "(", "n", ",", "1", ",", "device", "=", "device", ")", "\n", "if", "rnormvec", ":", "\n", "        ", "resvec", "=", "np", ".", "append", "(", "resvec", ",", "beta1", ")", "\n", "\n", "", "msg", "=", "[", "' beta2 = 0.  b and x are eigenvectors                   '", ",", "# -1", "\n", "' beta1 = 0.  The exact solution is  x = 0               '", ",", "# 0", "\n", "' A solution to Ax = b found, given rtol                 '", ",", "# 1", "\n", "' Min-length solution for singular LS problem, given rtol'", ",", "# 2", "\n", "' A solution to Ax = b found, given eps                  '", ",", "# 3", "\n", "' Min-length solution for singular LS problem, given eps '", ",", "# 4", "\n", "' x has converged to an eigenvector                      '", ",", "# 5", "\n", "' xnorm has exceeded maxxnorm                            '", ",", "# 6", "\n", "' Acond has exceeded Acondlim                            '", ",", "# 7", "\n", "' The iteration limit was reached                        '", ",", "# 8", "\n", "' Least-squares problem but no converged solution yet    '", "]", "# 9", "\n", "\n", "if", "show", ":", "\n", "        ", "print", "(", "' '", ")", "\n", "print", "(", "'Enter Minres-QLP: '", ")", "\n", "print", "(", "'Min-length solution of symmetric(singular)'", ",", "end", "=", "' '", ")", "\n", "print", "(", "'(A-sI)x = b or min ||(A-sI)x - b||'", ")", "\n", "#||Ax - b|| is ||(A-sI)x - b|| if shift != 0 here", "\n", "hstr1", "=", "'    n = %8g    ||Ax - b|| = %8.2e     '", "%", "(", "n", ",", "beta1", ")", "\n", "hstr2", "=", "'shift = %8.2e       rtol = %8g'", "%", "(", "shift", ",", "rtol", ")", "\n", "hstr3", "=", "'maxit = %8g      maxxnorm = %8.2e  '", "%", "(", "maxit", ",", "maxxnorm", ")", "\n", "hstr4", "=", "'Acondlim = %8.2e   TranCond = %8g'", "%", "(", "Acondlim", ",", "TranCond", ")", "\n", "print", "(", "hstr1", ",", "hstr2", ")", "\n", "print", "(", "hstr3", ",", "hstr4", ")", "\n", "\n", "#b = 0 --> x = 0 skip the main loop", "\n", "", "if", "beta1", "==", "0", ":", "\n", "        ", "flag", "=", "0", "\n", "\n", "", "while", "flag", "==", "flag0", "and", "iters", "<", "maxit", ":", "\n", "#lanczos", "\n", "        ", "iters", "+=", "1", "\n", "betal", "=", "beta", "\n", "beta", "=", "betan", "\n", "v", "=", "r3", "/", "beta", "\n", "r3", "=", "Ax", "(", "A", ",", "v", ")", "\n", "if", "shift", "==", "0", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "r3", "=", "r3", "-", "shift", "*", "v", "\n", "\n", "", "if", "iters", ">", "1", ":", "\n", "            ", "r3", "=", "r3", "-", "r1", "*", "beta", "/", "betal", "\n", "\n", "# alfa = torch.tensor(np.real(torch.mm(r3.transpose(0,1), v).numpy()))", "\n", "", "alfa", "=", "torch", ".", "mm", "(", "r3", ".", "transpose", "(", "0", ",", "1", ")", ",", "v", ")", "\n", "r3", "=", "r3", "-", "r2", "*", "alfa", "/", "beta", "\n", "r1", "=", "r2", "\n", "r2", "=", "r3", "\n", "\n", "if", "noprecon", ":", "\n", "            ", "betan", "=", "torch", ".", "norm", "(", "r3", ")", "\n", "if", "iters", "==", "1", ":", "\n", "                ", "if", "betan", "==", "0", ":", "\n", "                    ", "if", "alfa", "==", "0", ":", "\n", "                        ", "flag", "=", "0", "\n", "break", "\n", "", "else", ":", "\n", "                        ", "flag", "=", "-", "1", "\n", "x", "=", "b", "/", "alfa", "\n", "break", "\n", "", "", "", "", "else", ":", "\n", "            ", "r3", "=", "Precond", "(", "M", ",", "r2", ")", "\n", "betan", "=", "torch", ".", "mm", "(", "r2", ".", "transpose", "(", "0", ",", "1", ")", ",", "r3", ")", "\n", "if", "betan", ">", "0", ":", "\n", "                ", "betan", "=", "torch", ".", "sqrt", "(", "betan", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Error: \"M\" is indefinite or singular!'", ")", "\n", "", "", "pnorm", "=", "torch", ".", "sqrt", "(", "betal", "**", "2", "+", "alfa", "**", "2", "+", "betan", "**", "2", ")", "\n", "\n", "#previous left rotation Q_{k-1}", "\n", "dbar", "=", "dltan", "\n", "dlta", "=", "cs", "*", "dbar", "+", "sn", "*", "alfa", "\n", "epln", "=", "eplnn", "\n", "gbar", "=", "sn", "*", "dbar", "-", "cs", "*", "alfa", "\n", "eplnn", "=", "sn", "*", "betan", "\n", "dltan", "=", "-", "cs", "*", "betan", "\n", "dlta_QLP", "=", "dlta", "\n", "#current left plane rotation Q_k", "\n", "gamal3", "=", "gamal2", "\n", "gamal2", "=", "gamal", "\n", "gamal", "=", "gama", "\n", "cs", ",", "sn", ",", "gama", "=", "SymGivens", "(", "gbar", ",", "betan", ",", "device", ")", "\n", "gama_tmp", "=", "gama", "\n", "taul2", "=", "taul", "\n", "taul", "=", "tau", "\n", "tau", "=", "cs", "*", "phi", "\n", "Axnorm", "=", "torch", ".", "sqrt", "(", "Axnorm", "**", "2", "+", "tau", "**", "2", ")", "\n", "phi", "=", "sn", "*", "phi", "\n", "#previous right plane rotation P_{k-2,k}", "\n", "if", "iters", ">", "2", ":", "\n", "            ", "veplnl2", "=", "veplnl", "\n", "etal2", "=", "etal", "\n", "etal", "=", "eta", "\n", "dlta_tmp", "=", "sr2", "*", "vepln", "-", "cr2", "*", "dlta", "\n", "veplnl", "=", "cr2", "*", "vepln", "+", "sr2", "*", "dlta", "\n", "dlta", "=", "dlta_tmp", "\n", "eta", "=", "sr2", "*", "gama", "\n", "gama", "=", "-", "cr2", "*", "gama", "\n", "#current right plane rotation P{k-1,k}", "\n", "", "if", "iters", ">", "1", ":", "\n", "            ", "cr1", ",", "sr1", ",", "gamal", "=", "SymGivens", "(", "gamal", ",", "dlta", ",", "device", ")", "\n", "vepln", "=", "sr1", "*", "gama", "\n", "gama", "=", "-", "cr1", "*", "gama", "\n", "\n", "#update xnorm", "\n", "", "xnorml", "=", "xnorm", "\n", "ul4", "=", "ul3", "\n", "ul3", "=", "ul2", "\n", "if", "iters", ">", "2", ":", "\n", "            ", "ul2", "=", "(", "taul2", "-", "etal2", "*", "ul4", "-", "veplnl2", "*", "ul3", ")", "/", "gamal2", "\n", "", "if", "iters", ">", "1", ":", "\n", "            ", "ul", "=", "(", "taul", "-", "etal", "*", "ul3", "-", "veplnl", "*", "ul2", ")", "/", "gamal", "\n", "", "if", "torch", ".", "is_tensor", "(", "xl2norm", "**", "2", "+", "ul2", "**", "2", "+", "ul", "**", "2", ")", ":", "\n", "            ", "xnorm_tmp", "=", "torch", ".", "sqrt", "(", "xl2norm", "**", "2", "+", "ul2", "**", "2", "+", "ul", "**", "2", ")", "\n", "", "else", ":", "\n", "            ", "xnorm_tmp", "=", "torch", ".", "sqrt", "(", "torch", ".", "tensor", "(", "\n", "float", "(", "xl2norm", "**", "2", "+", "ul2", "**", "2", "+", "ul", "**", "2", ")", ",", "device", "=", "device", ")", ")", "\n", "", "if", "torch", ".", "abs", "(", "gama", ")", ">", "torch", ".", "finfo", "(", ")", ".", "tiny", "and", "xnorm_tmp", "<", "maxxnorm", ":", "\n", "            ", "u", "=", "(", "tau", "-", "eta", "*", "ul2", "-", "vepln", "*", "ul", ")", "/", "gama", "\n", "if", "torch", ".", "sqrt", "(", "xnorm_tmp", "**", "2", "+", "u", "**", "2", ")", ">", "maxxnorm", ":", "\n", "                ", "u", "=", "0", "\n", "flag", "=", "6", "\n", "", "", "else", ":", "\n", "            ", "u", "=", "0", "\n", "flag", "=", "9", "\n", "", "if", "torch", ".", "is_tensor", "(", "xl2norm", "**", "2", "+", "ul2", "**", "2", ")", ":", "\n", "            ", "xl2norm", "=", "torch", ".", "sqrt", "(", "xl2norm", "**", "2", "+", "ul2", "**", "2", ")", "\n", "", "else", ":", "\n", "            ", "xl2norm", "=", "torch", ".", "sqrt", "(", "\n", "torch", ".", "tensor", "(", "float", "(", "xl2norm", "**", "2", "+", "ul2", "**", "2", ")", ",", "device", "=", "device", ")", ")", "\n", "", "xnorm", "=", "torch", ".", "sqrt", "(", "xl2norm", "**", "2", "+", "ul", "**", "2", "+", "u", "**", "2", ")", "\n", "#update w&x", "\n", "#Minres", "\n", "if", "(", "Acond", "<", "TranCond", ")", "and", "flag", "!=", "flag0", "and", "QLPiter", "==", "0", ":", "\n", "            ", "wl2", "=", "wl", "\n", "wl", "=", "w", "\n", "w", "=", "(", "v", "-", "epln", "*", "wl2", "-", "dlta_QLP", "*", "wl", ")", "/", "gama_tmp", "\n", "if", "xnorm", "<", "maxxnorm", ":", "\n", "                ", "x", "+=", "tau", "*", "w", "\n", "", "else", ":", "\n", "                ", "flag", "=", "6", "\n", "#Minres-QLP", "\n", "", "", "else", ":", "\n", "            ", "QLPiter", "+=", "1", "\n", "if", "QLPiter", "==", "1", ":", "\n", "                ", "xl2", "=", "torch", ".", "zeros", "(", "n", ",", "1", ",", "device", "=", "device", ")", "\n", "if", "(", "iters", ">", "1", ")", ":", "# construct w_{k-3}, w_{k-2}, w_{k-1}", "\n", "                    ", "if", "iters", ">", "3", ":", "\n", "                        ", "wl2", "=", "gamal3", "*", "wl2", "+", "veplnl2", "*", "wl", "+", "etal", "*", "w", "\n", "", "if", "iters", ">", "2", ":", "\n", "                        ", "wl", "=", "gamal_QLP", "*", "wl", "+", "vepln_QLP", "*", "w", "\n", "", "w", "=", "gama_QLP", "*", "w", "\n", "xl2", "=", "x", "-", "wl", "*", "ul_QLP", "-", "w", "*", "u_QLP", "\n", "\n", "", "", "if", "iters", "==", "1", ":", "\n", "                ", "wl2", "=", "wl", "\n", "wl", "=", "v", "*", "sr1", "\n", "w", "=", "-", "v", "*", "cr1", "\n", "", "elif", "iters", "==", "2", ":", "\n", "                ", "wl2", "=", "wl", "\n", "wl", "=", "w", "*", "cr1", "+", "v", "*", "sr1", "\n", "w", "=", "w", "*", "sr1", "-", "v", "*", "cr1", "\n", "", "else", ":", "\n", "                ", "wl2", "=", "wl", "\n", "wl", "=", "w", "\n", "w", "=", "wl2", "*", "sr2", "-", "v", "*", "cr2", "\n", "wl2", "=", "wl2", "*", "cr2", "+", "v", "*", "sr2", "\n", "v", "=", "wl", "*", "cr1", "+", "w", "*", "sr1", "\n", "w", "=", "wl", "*", "sr1", "-", "w", "*", "cr1", "\n", "wl", "=", "v", "\n", "", "xl2", "=", "xl2", "+", "wl2", "*", "ul2", "\n", "x", "=", "xl2", "+", "wl", "*", "ul", "+", "w", "*", "u", "\n", "\n", "#next right plane rotation P{k-1,k+1}", "\n", "", "gamal_tmp", "=", "gamal", "\n", "cr2", ",", "sr2", ",", "gamal", "=", "SymGivens", "(", "gamal", ",", "eplnn", ",", "device", ")", "\n", "#transfering from Minres to Minres-QLP", "\n", "gamal_QLP", "=", "gamal_tmp", "\n", "#print('gamal_QLP=', gamal_QLP)", "\n", "vepln_QLP", "=", "vepln", "\n", "gama_QLP", "=", "gama", "\n", "ul_QLP", "=", "ul", "\n", "u_QLP", "=", "u", "\n", "## Estimate various norms", "\n", "abs_gama", "=", "torch", ".", "abs", "(", "gama", ")", "\n", "Anorml", "=", "Anorm", "\n", "Anorm", "=", "max", "(", "[", "Anorm", ",", "pnorm", ",", "gamal", ",", "abs_gama", "]", ")", "\n", "if", "iters", "==", "1", ":", "\n", "            ", "gmin", "=", "gama", "\n", "gminl", "=", "gmin", "\n", "", "elif", "iters", ">", "1", ":", "\n", "            ", "gminl2", "=", "gminl", "\n", "gminl", "=", "gmin", "\n", "gmin", "=", "min", "(", "[", "gminl2", ",", "gamal", ",", "abs_gama", "]", ")", "\n", "", "Acondl", "=", "Acond", "\n", "Acond", "=", "Anorm", "/", "gmin", "\n", "rnorml", "=", "rnorm", "\n", "relresl", "=", "relres", "\n", "if", "flag", "!=", "9", ":", "\n", "            ", "rnorm", "=", "phi", "\n", "", "relres", "=", "rnorm", "/", "(", "Anorm", "*", "xnorm", "+", "beta1", ")", "\n", "rootl", "=", "torch", ".", "sqrt", "(", "gbar", "**", "2", "+", "dltan", "**", "2", ")", "\n", "Arnorml", "=", "rnorml", "*", "rootl", "\n", "relAresl", "=", "rootl", "/", "Anorm", "\n", "## See if any of the stopping criteria are satisfied.", "\n", "epsx", "=", "Anorm", "*", "xnorm", "*", "torch", ".", "finfo", "(", ")", ".", "eps", "\n", "if", "(", "flag", "==", "flag0", ")", "or", "(", "flag", "==", "9", ")", ":", "\n", "            ", "t1", "=", "1", "+", "relres", "\n", "t2", "=", "1", "+", "relAresl", "\n", "if", "iters", ">=", "maxit", ":", "\n", "                ", "flag", "=", "8", "#exit before maxit", "\n", "", "if", "Acond", ">=", "Acondlim", ":", "\n", "                ", "flag", "=", "7", "#Huge Acond", "\n", "", "if", "xnorm", ">=", "maxxnorm", ":", "\n", "                ", "flag", "=", "6", "#xnorm exceeded", "\n", "", "if", "epsx", ">=", "beta1", ":", "\n", "                ", "flag", "=", "5", "#x = eigenvector", "\n", "", "if", "t2", "<=", "1", ":", "\n", "                ", "flag", "=", "4", "#Accurate Least Square Solution", "\n", "", "if", "t1", "<=", "1", ":", "\n", "                ", "flag", "=", "3", "#Accurate Ax = b Solution", "\n", "", "if", "relAresl", "<=", "rtol", ":", "\n", "                ", "flag", "=", "2", "#Trustful Least Square Solution", "\n", "", "if", "relres", "<=", "rtol", ":", "\n", "                ", "flag", "=", "1", "#Trustful Ax = b Solution", "\n", "", "", "if", "flag", "==", "2", "or", "flag", "==", "4", "or", "flag", "==", "6", "or", "flag", "==", "7", ":", "\n", "#possibly singular", "\n", "            ", "iters", "=", "iters", "-", "1", "\n", "Acond", "=", "Acondl", "\n", "rnorm", "=", "rnorml", "\n", "relres", "=", "relresl", "\n", "", "else", ":", "\n", "            ", "if", "rnormvec", ":", "\n", "                ", "resvec", "=", "torch", ".", "stack", "(", "resvec", ",", "rnorm", ")", "\n", "Aresvec", "=", "torch", ".", "stack", "(", "Aresvec", ",", "Arnorml", ")", "\n", "\n", "", "if", "show", ":", "\n", "                ", "if", "iters", "%", "10", "-", "1", "==", "0", ":", "\n", "                    ", "lstr", "=", "(", "'        iter     rnorm    Arnorm    relres   '", "+", "\n", "'relAres    Anorm     Acond     xnorm'", ")", "\n", "print", "(", "' '", ")", "\n", "print", "(", "lstr", ")", "\n", "", "if", "QLPiter", "==", "1", ":", "\n", "                    ", "print", "(", "'QLP'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "                    ", "print", "(", "'   '", ",", "end", "=", "''", ")", "\n", "", "lstr1", "=", "'%8g    %8.2e '", "%", "(", "iters", "-", "1", ",", "rnorml", ")", "\n", "lstr2", "=", "'%8.2e  %8.2e '", "%", "(", "Arnorml", ",", "relresl", ")", "\n", "lstr3", "=", "'%8.2e  %8.2e '", "%", "(", "relAresl", ",", "Anorml", ")", "\n", "lstr4", "=", "'%8.2e  %8.2e '", "%", "(", "Acondl", ",", "xnorml", ")", "\n", "print", "(", "lstr1", ",", "lstr2", ",", "lstr3", ",", "lstr4", ")", "\n", "\n", "#exited the main loop", "\n", "", "", "", "if", "show", ":", "\n", "        ", "if", "QLPiter", "==", "1", ":", "\n", "            ", "print", "(", "'QLP'", ",", "end", "=", "''", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'   '", ",", "end", "=", "''", ")", "\n", "", "", "Miter", "=", "iters", "-", "QLPiter", "\n", "\n", "#final quantities", "\n", "r1", "=", "b", "-", "Ax", "(", "A", ",", "x", ")", "+", "shift", "*", "x", "\n", "rnorm", "=", "torch", ".", "norm", "(", "r1", ")", "\n", "Arnorm", "=", "torch", ".", "norm", "(", "Ax", "(", "A", ",", "r1", ")", "-", "shift", "*", "r1", ")", "\n", "xnorm", "=", "torch", ".", "norm", "(", "x", ")", "\n", "relres", "=", "rnorm", "/", "(", "Anorm", "*", "xnorm", "+", "beta1", ")", "\n", "relAres", "=", "0", "\n", "if", "rnorm", ">", "torch", ".", "finfo", "(", ")", ".", "tiny", ":", "\n", "        ", "relAres", "=", "Arnorm", "/", "(", "Anorm", "*", "rnorm", ")", "\n", "\n", "", "if", "show", ":", "\n", "        ", "if", "rnorm", ">", "torch", ".", "finfo", "(", ")", ".", "tiny", ":", "\n", "            ", "lstr1", "=", "'%8g    %8.2e '", "%", "(", "iters", ",", "rnorm", ")", "\n", "lstr2", "=", "'%8.2eD %8.2e '", "%", "(", "Arnorm", ",", "relres", ")", "\n", "lstr3", "=", "'%8.2eD %8.2e '", "%", "(", "relAres", ",", "Anorm", ")", "\n", "lstr4", "=", "'%8.2e  %8.2e '", "%", "(", "Acond", ",", "xnorm", ")", "\n", "print", "(", "lstr1", ",", "lstr2", ",", "lstr3", ",", "lstr4", ")", "\n", "", "else", ":", "\n", "            ", "lstr1", "=", "'%8g    %8.2e '", "%", "(", "iters", ",", "rnorm", ")", "\n", "lstr2", "=", "'%8.2eD %8.2e '", "%", "(", "Arnorm", ",", "relres", ")", "\n", "lstr3", "=", "'          %8.2e '", "%", "(", "Anorm", ")", "\n", "lstr4", "=", "'%8.2e  %8.2e '", "%", "(", "Acond", ",", "xnorm", ")", "\n", "print", "(", "lstr1", ",", "lstr2", ",", "lstr3", ",", "lstr4", ")", "\n", "\n", "", "print", "(", "' '", ")", "\n", "print", "(", "'Exit Minres-QLP: '", ")", "\n", "str1", "=", "'Flag = %8g    %8s'", "%", "(", "flag", ",", "msg", "[", "int", "(", "flag", "+", "1", ")", "]", ")", "\n", "str2", "=", "'Iter = %8g      '", "%", "(", "iters", ")", "\n", "str3", "=", "'Minres = %8g       Minres-QLP = %8g'", "%", "(", "Miter", ",", "QLPiter", ")", "\n", "str4", "=", "'relres = %8.2e    relAres = %8.2e    '", "%", "(", "relres", ",", "relAres", ")", "\n", "str5", "=", "'rnorm = %8.2e      Arnorm = %8.2e'", "%", "(", "rnorm", ",", "Arnorm", ")", "\n", "str6", "=", "'Anorm = %8.2e       Acond = %8.2e    '", "%", "(", "Anorm", ",", "Acond", ")", "\n", "str7", "=", "'xnorm = %8.2e      Axnorm = %8.2e'", "%", "(", "xnorm", ",", "Axnorm", ")", "\n", "print", "(", "str1", ")", "\n", "print", "(", "str2", ",", "str3", ")", "\n", "print", "(", "str4", ",", "str5", ")", "\n", "print", "(", "str6", ",", "str7", ")", "\n", "\n", "", "if", "rnormvec", ":", "\n", "        ", "Aresvec", "=", "torch", ".", "stack", "(", "Aresvec", ",", "Arnorm", ")", "\n", "return", "(", "x", ",", "flag", ",", "iters", ",", "Miter", ",", "QLPiter", ",", "relres", ",", "relAres", ",", "Anorm", ",", "Acond", ",", "\n", "xnorm", ",", "Axnorm", ",", "resvec", ",", "Aresvec", ")", "\n", "\n", "", "return", "(", "x", ",", "flag", ",", "iters", ",", "Miter", ",", "QLPiter", ",", "relres", ",", "relAres", ",", "Anorm", ",", "Acond", ",", "xnorm", ",", "Axnorm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Ax": [[390, 403], ["callable", "A", "torch.mm"], "function", ["None"], ["", "def", "Ax", "(", "A", ",", "x", ")", ":", "\n", "    ", "\"\"\"Returns the Matrix-vector product Ax.\n    \n    Arguments:\n        A (function or torch.Tensor): Matrix-vector product function or \n            explicit matrix.\n        x (torch.Tensor): A vector.\n    \"\"\"", "\n", "if", "callable", "(", "A", ")", ":", "\n", "        ", "Ax", "=", "A", "(", "x", ")", "\n", "", "else", ":", "\n", "        ", "Ax", "=", "torch", ".", "mm", "(", "A", ",", "x", ")", "\n", "", "return", "Ax", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.Precond": [[405, 413], ["None"], "function", ["None"], ["", "def", "Precond", "(", "M", ",", "r", ")", ":", "\n", "    ", "\"\"\"This can implement preconditioning into minresQLP.\"\"\"", "\n", "# if callable(M):", "\n", "#     h = cg(M, r)", "\n", "# else:", "\n", "#     h = inv(M).dot(r)", "\n", "# return h", "\n", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.SymGivens": [[415, 449], ["torch.is_tensor", "torch.tensor", "torch.is_tensor", "torch.tensor", "torch.abs", "float", "float", "torch.sign", "torch.sign", "torch.abs", "torch.abs", "torch.abs", "torch.sign", "torch.sqrt", "torch.sign", "torch.sqrt"], "function", ["None"], ["", "def", "SymGivens", "(", "a", ",", "b", ",", "device", ")", ":", "\n", "    ", "\"\"\"This is used by the function minresQLP.\n    \n    Arguments:\n        a (float): A number.\n        b (float): A number.\n        device (torch.device): The device tensors will be allocated to.\n    \"\"\"", "\n", "if", "not", "torch", ".", "is_tensor", "(", "a", ")", ":", "\n", "        ", "a", "=", "torch", ".", "tensor", "(", "float", "(", "a", ")", ",", "device", "=", "device", ")", "\n", "", "if", "not", "torch", ".", "is_tensor", "(", "b", ")", ":", "\n", "        ", "b", "=", "torch", ".", "tensor", "(", "float", "(", "b", ")", ",", "device", "=", "device", ")", "\n", "", "if", "b", "==", "0", ":", "\n", "        ", "if", "a", "==", "0", ":", "\n", "            ", "c", "=", "1", "\n", "", "else", ":", "\n", "            ", "c", "=", "torch", ".", "sign", "(", "a", ")", "\n", "", "s", "=", "0", "\n", "r", "=", "torch", ".", "abs", "(", "a", ")", "\n", "", "elif", "a", "==", "0", ":", "\n", "        ", "c", "=", "0", "\n", "s", "=", "torch", ".", "sign", "(", "b", ")", "\n", "r", "=", "torch", ".", "abs", "(", "b", ")", "\n", "", "elif", "torch", ".", "abs", "(", "b", ")", ">", "torch", ".", "abs", "(", "a", ")", ":", "\n", "        ", "t", "=", "a", "/", "b", "\n", "s", "=", "torch", ".", "sign", "(", "b", ")", "/", "torch", ".", "sqrt", "(", "1", "+", "t", "**", "2", ")", "\n", "c", "=", "s", "*", "t", "\n", "r", "=", "b", "/", "s", "\n", "", "else", ":", "\n", "        ", "t", "=", "b", "/", "a", "\n", "c", "=", "torch", ".", "sign", "(", "a", ")", "/", "torch", ".", "sqrt", "(", "1", "+", "t", "**", "2", ")", "\n", "s", "=", "c", "*", "t", "\n", "r", "=", "a", "/", "c", "\n", "", "return", "c", ",", "s", ",", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.main": [[451, 460], ["torch.manual_seed", "torch.device", "torch.randn", "torch.randn", "minres_qlp.minresQLP", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.minresQLP"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Run an example of minresQLP.\"\"\"", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "n", "=", "1000", "\n", "A", "=", "torch", ".", "randn", "(", "n", ",", "n", ",", "device", "=", "device", ")", "\n", "b", "=", "torch", ".", "randn", "(", "n", ",", "device", "=", "device", ")", "\n", "x", ",", "flag", ",", "iters", ",", "Miter", ",", "QLPiter", ",", "relres", ",", "relAres", ",", "Anorm", ",", "Acond", ",", "xnorm", ",", "Axnorm", "=", "minresQLP", "(", "A", ",", "b", ",", "device", ",", "maxit", "=", "100", ",", "show", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.main.main": [[18, 120], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "torch.device", "torch.device", "torch.device", "torch.get_rank", "torchvision.CIFAR10", "softmaxModel.softmaxModel().to", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "DINGO.DINGO", "GIANT.GIANT", "DiSCO.DiSCO", "InexactDANE.InexactDANE", "AIDE.AIDE", "SGD.Synchronous_SGD", "torch.get_world_size", "int", "torch.Subset", "torchvision.CIFAR10", "print", "print", "print", "print", "print", "len", "worker.Worker", "worker.Worker", "print", "print", "print", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torchvision.ToTensor", "range", "softmaxModel.softmaxModel", "len", "torchvision.ToTensor", "len", "len", "sum", "p.numel", "softmaxModel().to.parameters"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.DINGO", "home.repos.pwc.inspect_result.RixonC_DINGO.None.GIANT.GIANT", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DiSCO.DiSCO", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.InexactDANE", "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.AIDE", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.Synchronous_SGD"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Compare the distributed optimization algorithms.\"\"\"", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "number_of_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "\n", "#-------- Worker nodes load local trainset and driver loads testset -------", "\n", "\n", "data_dir", "=", "\"./data/CIFAR10\"", "\n", "trainset", "=", "datasets", ".", "CIFAR10", "(", "data_dir", ",", "train", "=", "True", ",", "\n", "transform", "=", "transforms", ".", "ToTensor", "(", ")", ")", "\n", "if", "rank", ">", "0", ":", "\n", "        ", "local_trainset_size", "=", "int", "(", "len", "(", "trainset", ")", "/", "number_of_workers", ")", "\n", "local_trainset", "=", "data", ".", "Subset", "(", "trainset", ",", "\n", "range", "(", "local_trainset_size", "*", "(", "rank", "-", "1", ")", ",", "\n", "local_trainset_size", "*", "(", "rank", ")", ")", ")", "\n", "", "else", ":", "\n", "# The driver node will record test accuracy.", "\n", "        ", "testset", "=", "datasets", ".", "CIFAR10", "(", "data_dir", ",", "train", "=", "False", ",", "\n", "transform", "=", "transforms", ".", "ToTensor", "(", ")", ")", "\n", "print", "(", "\"\\nCIFAR10\"", ")", "\n", "print", "(", "\"trainset size = {:,}\"", ".", "format", "(", "len", "(", "trainset", ")", ")", ")", "\n", "print", "(", "\"testset size = {:,}\"", ".", "format", "(", "len", "(", "testset", ")", ")", ")", "\n", "\n", "#-------------------------- Load model to train ---------------------------", "\n", "\n", "", "model", "=", "softmaxModel", "(", "32", "*", "32", "*", "3", ",", "10", ")", ".", "to", "(", "device", ")", "# softmax model for CIFAR10", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"Softmax\"", ")", "\n", "print", "(", "\"dimension = {:,}\"", ".", "format", "(", "\n", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", ")", ")", "\n", "\n", "#------------------ Choose criterion and regularization -------------------", "\n", "\n", "", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", "reduction", "=", "'sum'", ")", "\n", "regularization_parameter", "=", "1.0", "/", "len", "(", "trainset", ")", "\n", "\n", "#------------------------ Initialize worker class -------------------------", "\n", "\n", "'''\n    A Worker class instance is held on each worker node. It contains the local\n    trainset and local computation instructions, e.g., functions to compute the\n    gradient on local data.\n\n    A Worker class instance, containing the test dataset, is held on the driver\n    node. This is used to compute the test accuracy.\n    '''", "\n", "subproblem_maximum_iterations", "=", "50", "\n", "subproblem_tolerance", "=", "1e-4", "\n", "dataloader_processes", "=", "0", "\n", "batch_size", "=", "1000", "# batch_size is the number of samples loaded at a time", "\n", "# when computing objective value, gradient, Hessian-vector products and", "\n", "# test accuracy.", "\n", "\n", "if", "rank", ">", "0", ":", "\n", "        ", "worker", "=", "Worker", "(", "local_trainset", ",", "batch_size", ",", "dataloader_processes", ",", "\n", "criterion", ",", "device", ",", "subproblem_tolerance", ",", "\n", "subproblem_maximum_iterations", ",", "\n", "regularization_parameter", ")", "\n", "", "else", ":", "\n", "        ", "worker", "=", "Worker", "(", "testset", ",", "batch_size", ",", "dataloader_processes", ",", "\n", "criterion", ",", "device", ",", "subproblem_tolerance", ",", "\n", "subproblem_maximum_iterations", ",", "\n", "regularization_parameter", ")", "\n", "print", "(", "\"number of worker nodes = {:,}\"", ".", "format", "(", "number_of_workers", ")", ")", "\n", "print", "(", "\"subproblem_tolerance = {:.2e}\"", ".", "format", "(", "subproblem_tolerance", ")", ")", "\n", "print", "(", "\"subproblem_maximum_iterations = \"", "+", "\n", "\"{:,}\"", ".", "format", "(", "subproblem_maximum_iterations", ")", ")", "\n", "\n", "#------------------------------ Train model -------------------------------", "\n", "\n", "", "max_communication_rounds", "=", "500", "\n", "max_iterations", "=", "2000", "\n", "\n", "DINGO", "(", "deepcopy", "(", "model", ")", ",", "worker", ",", "device", ",", "theta", "=", "1e-4", ",", "phi", "=", "1e-6", ",", "\n", "max_iterations", "=", "max_iterations", ",", "\n", "max_communication_rounds", "=", "max_communication_rounds", ")", "\n", "\n", "#    DINGO_with_only_case_1(deepcopy(model), worker, device, theta=1e-4,", "\n", "#                          max_iterations = max_iterations,", "\n", "#                          max_communication_rounds = max_communication_rounds)", "\n", "\n", "GIANT", "(", "deepcopy", "(", "model", ")", ",", "worker", ",", "device", ",", "max_iterations", "=", "max_iterations", ",", "\n", "max_communication_rounds", "=", "max_communication_rounds", ")", "\n", "\n", "DiSCO", "(", "deepcopy", "(", "model", ")", ",", "worker", ",", "device", ",", "max_iterations", "=", "max_iterations", ",", "\n", "max_communication_rounds", "=", "max_communication_rounds", ",", "\n", "subproblem_tolerance", "=", "subproblem_tolerance", ",", "\n", "subproblem_maximum_iterations", "=", "subproblem_maximum_iterations", ")", "\n", "\n", "InexactDANE", "(", "deepcopy", "(", "model", ")", ",", "worker", ",", "device", ",", "eta", "=", "1.0", ",", "mu", "=", "0.0", ",", "\n", "subproblem_step_size", "=", "1e-3", ",", "max_iterations", "=", "max_iterations", ",", "\n", "max_communication_rounds", "=", "max_communication_rounds", ")", "\n", "\n", "AIDE", "(", "deepcopy", "(", "model", ")", ",", "worker", ",", "device", ",", "eta", "=", "1.0", ",", "mu", "=", "0.0", ",", "tau", "=", "100", ",", "\n", "subproblem_step_size", "=", "1e-3", ",", "max_iterations", "=", "max_iterations", ",", "\n", "max_communication_rounds", "=", "max_communication_rounds", ")", "\n", "\n", "Synchronous_SGD", "(", "deepcopy", "(", "model", ")", ",", "worker", ",", "device", ",", "learning_rate", "=", "1e-2", ",", "\n", "max_iterations", "=", "max_iterations", ",", "\n", "max_communication_rounds", "=", "max_communication_rounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.__init__": [[30, 43], ["torch.data.DataLoader", "torch.data.DataLoader", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "dataset", ",", "batch_size", ",", "dataloader_processes", ",", "criterion", ",", "\n", "device", ",", "subproblem_tolerance", ",", "subproblem_maximum_iterations", ",", "\n", "regularization_parameter", "=", "0.0", ")", ":", "\n", "        ", "self", ".", "criterion", "=", "criterion", "\n", "self", ".", "device", "=", "device", "\n", "self", ".", "dataset", "=", "dataset", "\n", "self", ".", "dataloader", "=", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "num_workers", "=", "dataloader_processes", ")", "\n", "self", ".", "dataloader_processes", "=", "dataloader_processes", "\n", "self", ".", "regularization_parameter", "=", "regularization_parameter", "\n", "self", ".", "s", "=", "len", "(", "dataset", ")", "\n", "self", ".", "subproblem_maximum_iterations", "=", "subproblem_maximum_iterations", "\n", "self", ".", "subproblem_tolerance", "=", "subproblem_tolerance", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss": [[45, 66], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "iter", "worker.Worker.get_model_weights", "inputs.to.to.to", "labels.to.to.to", "model", "worker.Worker.criterion().item", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "torch.norm().pow", "worker.Worker.criterion", "torch.norm", "torch.norm", "torch.norm", "torch.norm"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights"], ["", "def", "get_local_loss", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Returns the local loss (objective value).\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n        \"\"\"", "\n", "loss", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "data", "in", "iter", "(", "self", ".", "dataloader", ")", ":", "\n", "                ", "inputs", ",", "labels", "=", "data", "\n", "inputs", "=", "inputs", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "loss", "+=", "self", ".", "criterion", "(", "outputs", ",", "labels", ")", ".", "item", "(", ")", "\n", "\n", "", "", "if", "self", ".", "regularization_parameter", "!=", "0", ":", "\n", "            ", "weights", "=", "self", ".", "get_model_weights", "(", "model", ")", "\n", "loss", "+=", "(", "(", "self", ".", "regularization_parameter", "/", "2.0", ")", "\n", "*", "torch", ".", "norm", "(", "weights", ")", ".", "pow", "(", "2", ")", ")", "\n", "\n", "", "return", "loss", "*", "(", "1.0", "/", "self", ".", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient": [[68, 91], ["iter", "inputs.to.to.to", "labels.to.to.to", "model", "worker.Worker.criterion", "model.zero_grad", "worker.Worker.backward", "worker.Worker.get_model_weights", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "T.grad.reshape", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights"], ["", "def", "get_local_gradient", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Returns the local gradient.\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n        \"\"\"", "\n", "local_gradient", "=", "0", "\n", "for", "data", "in", "iter", "(", "self", ".", "dataloader", ")", ":", "\n", "            ", "inputs", ",", "labels", "=", "data", "\n", "inputs", "=", "inputs", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "local_loss", "=", "self", ".", "criterion", "(", "outputs", ",", "labels", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "local_loss", ".", "backward", "(", ")", "\n", "local_gradient", "+=", "torch", ".", "cat", "(", "\n", "[", "T", ".", "grad", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "T", "in", "model", ".", "parameters", "(", ")", "]", ",", "dim", "=", "0", ")", ".", "data", "\n", "\n", "", "if", "self", ".", "regularization_parameter", "!=", "0", ":", "\n", "            ", "weights", "=", "self", ".", "get_model_weights", "(", "model", ")", "\n", "local_gradient", "+=", "self", ".", "regularization_parameter", "*", "weights", "\n", "\n", "", "return", "local_gradient", "*", "(", "1.0", "/", "self", ".", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector": [[93, 123], ["iter", "inputs.to.to.to", "labels.to.to.to", "model", "worker.Worker.criterion", "model.zero_grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "model.zero_grad", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "model.parameters", "torch.cat.transpose", "torch.cat.transpose", "model.parameters", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "g.reshape", "v.reshape"], "methods", ["None"], ["", "def", "get_local_hessian_times_vector", "(", "self", ",", "model", ",", "vector", ")", ":", "\n", "        ", "\"\"\"Returns the local Hessian-vector product.\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n            vector (torch.Tensor): A column vector.\n        \"\"\"", "\n", "hessian_times_vector", "=", "0", "\n", "for", "data", "in", "iter", "(", "self", ".", "dataloader", ")", ":", "\n", "            ", "inputs", ",", "labels", "=", "data", "\n", "inputs", "=", "inputs", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "local_loss", "=", "self", ".", "criterion", "(", "outputs", ",", "labels", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "local_gradients", "=", "torch", ".", "autograd", ".", "grad", "(", "local_loss", ",", "\n", "model", ".", "parameters", "(", ")", ",", "\n", "create_graph", "=", "True", ")", "\n", "local_gradient", "=", "torch", ".", "cat", "(", "\n", "[", "g", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "g", "in", "local_gradients", "]", ",", "dim", "=", "0", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "z", "=", "torch", ".", "mm", "(", "local_gradient", ".", "transpose", "(", "0", ",", "1", ")", ",", "vector", ")", "\n", "local_hess_vects", "=", "torch", ".", "autograd", ".", "grad", "(", "z", ",", "model", ".", "parameters", "(", ")", ")", "\n", "hessian_times_vector", "+=", "torch", ".", "cat", "(", "\n", "[", "v", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "v", "in", "local_hess_vects", "]", ",", "dim", "=", "0", ")", ".", "data", "\n", "\n", "", "if", "self", ".", "regularization_parameter", "!=", "0", ":", "\n", "            ", "hessian_times_vector", "+=", "self", ".", "regularization_parameter", "*", "vector", "\n", "\n", "", "return", "hessian_times_vector", "*", "(", "1.0", "/", "self", ".", "s", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_model_weights": [[125, 135], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "w.reshape", "model.parameters"], "methods", ["None"], ["", "def", "get_model_weights", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Returns a column tensor of the model parameters.\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "weights", "=", "torch", ".", "cat", "(", "[", "w", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "w", "in", "model", ".", "parameters", "(", ")", "]", ",", "\n", "dim", "=", "0", ")", ".", "data", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy": [[137, 157], ["model.eval", "model.train", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "inputs.to.to.to", "labels.to.to.to", "model", "torch.max", "torch.max", "torch.max", "torch.max", "labels.to.to.size"], "methods", ["None"], ["", "def", "get_accuracy", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Compute the accuracy of the model on the locally stored dataset.\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n        \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "correct", "=", "0", "\n", "total", "=", "0", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "data", "in", "self", ".", "dataloader", ":", "\n", "                ", "inputs", ",", "labels", "=", "data", "\n", "inputs", "=", "inputs", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "_", ",", "predicted", "=", "torch", ".", "max", "(", "outputs", ".", "data", ",", "1", ")", "\n", "total", "+=", "labels", ".", "size", "(", "0", ")", "\n", "correct", "+=", "(", "predicted", "==", "labels", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", "model", ".", "train", "(", ")", "\n", "return", "100", "*", "correct", "/", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_inverse_times_vector": [[163, 185], ["worker.Worker.get_local_hessian_times_vector", "cg.CG", "minres_qlp.minresQLP"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector", "home.repos.pwc.inspect_result.RixonC_DINGO.None.cg.CG", "home.repos.pwc.inspect_result.RixonC_DINGO.None.minres_qlp.minresQLP"], ["", "def", "get_local_hessian_inverse_times_vector", "(", "self", ",", "model", ",", "vector", ",", "\n", "method", "=", "\"CG\"", ")", ":", "\n", "        ", "\"\"\"Returns an approximation of the local Hessian inverse (or \n        pseudoinverse) times the vector, using either CG or minresQLP method.\n        \n        Arguments:\n            model (torch.nn.Module): A model.\n            vector (torch.Tensor): A column vector.\n            method (str, optional): Use 'CG' or 'minresQLP' method.\n        \"\"\"", "\n", "H", "=", "lambda", "v", ":", "self", ".", "get_local_hessian_times_vector", "(", "model", ",", "v", ")", "\n", "if", "method", "==", "\"CG\"", ":", "\n", "            ", "result", "=", "CG", "(", "H", ",", "vector", ",", "self", ".", "device", ",", "rtol", "=", "self", ".", "subproblem_tolerance", ",", "\n", "maxit", "=", "self", ".", "subproblem_maximum_iterations", ")", "\n", "if", "result", "is", "None", ":", "# CG failed", "\n", "                ", "return", "None", "\n", "", "else", ":", "\n", "                ", "return", "result", "[", "0", "]", "\n", "", "", "else", ":", "\n", "            ", "return", "minresQLP", "(", "H", ",", "vector", ",", "self", ".", "device", ",", "\n", "rtol", "=", "self", ".", "subproblem_tolerance", ",", "\n", "maxit", "=", "self", ".", "subproblem_maximum_iterations", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_tilde_pseudoinverse_times_vector_tilde": [[191, 212], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "worker.Worker.get_local_hessian_times_vector", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "lsmr.LSMR", "H", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "H", "int", "int", "len", "len"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector", "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.LSMR"], ["", "", "def", "get_local_hessian_tilde_pseudoinverse_times_vector_tilde", "(", "self", ",", "\n", "model", ",", "vector", ",", "phi", ")", ":", "\n", "        ", "\"\"\"Returns an approximation of the local Hessian_tilde pseudoinverse \n        times the vector, using LSMR method.\n        \n        Arguments:\n            model (torch.nn.Module): A model.\n            vector (torch.Tensor): A column vector.\n            phi (float): The hyperparameter phi in the DINGO algorithm.\n        \"\"\"", "\n", "dimension", "=", "vector", ".", "shape", "[", "0", "]", "\n", "H", "=", "lambda", "v", ":", "self", ".", "get_local_hessian_times_vector", "(", "model", ",", "v", ")", "\n", "H_tilde", "=", "lambda", "v", ":", "torch", ".", "cat", "(", "[", "H", "(", "v", ")", ",", "phi", "*", "v", "]", ",", "dim", "=", "0", ")", "\n", "H_tilde_transpose", "=", "lambda", "v", ":", "H", "(", "v", "[", "0", ":", "int", "(", "len", "(", "v", ")", "/", "2.0", ")", "]", ")", "+", "phi", "*", "v", "[", "int", "(", "len", "(", "v", ")", "/", "2.0", ")", ":", "]", "\n", "vector_tilde", "=", "torch", ".", "cat", "(", "\n", "[", "vector", ",", "torch", ".", "zeros", "(", "vector", ".", "shape", ",", "device", "=", "self", ".", "device", ")", "]", ",", "dim", "=", "0", ")", "\n", "v", "=", "LSMR", "(", "H_tilde", ",", "H_tilde_transpose", ",", "vector_tilde", ",", "\n", "dimension", ",", "self", ".", "device", ",", "myRtol", "=", "self", ".", "subproblem_tolerance", ",", "\n", "maxit", "=", "self", ".", "subproblem_maximum_iterations", ")", "[", "0", "]", "\n", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_tilde_pseudoinverse_times_gradient_tilde": [[214, 228], ["worker.Worker.get_local_hessian_tilde_pseudoinverse_times_vector_tilde"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_tilde_pseudoinverse_times_vector_tilde"], ["", "def", "get_local_hessian_tilde_pseudoinverse_times_gradient_tilde", "(", "self", ",", "\n", "model", ",", "gradient", ",", "phi", ")", ":", "\n", "        ", "\"\"\"Returns an approximation of the local Hessian_tilde pseudoinverse \n        times the gradient, using LSMR method.\n        \n        Arguments:\n            model (torch.nn.Module): A model.\n            gradient (torch.Tensor): The current full gradient.\n            phi (float): The hyperparameter phi in the DINGO algorithm.\n        \"\"\"", "\n", "v", "=", "self", ".", "get_local_hessian_tilde_pseudoinverse_times_vector_tilde", "(", "\n", "model", ",", "gradient", ",", "phi", ")", "\n", "self", ".", "local_hessian_tilde_pseudoinverse_times_gradient_tilde", "=", "v", "\n", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_case_3_update_direction": [[230, 266], ["torch.mm", "torch.mm", "torch.mm", "torch.mm", "cg.CG", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "z.transpose", "worker.Worker.get_local_hessian_times_vector", "hessian_times_gradient.transpose", "H", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "H", "z.transpose"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.cg.CG", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector"], ["", "def", "get_local_case_3_update_direction", "(", "self", ",", "model", ",", "hessian_times_gradient", ",", "\n", "gradient_norm_squared", ",", "theta", ",", "phi", ")", ":", "\n", "        ", "\"\"\"Returns the local update direction of DINGO under Case 3. Assumes \n        self.get_local_hessian_tilde_pseudoinverse_times_gradient_tilde has \n        been called prior.\n        \n        Arguments:\n            model (torch.nn.Module): A model.\n            hessian_times_gradient (torch.Tensor): The current Hessian-gradient \n                product.\n            gradient_norm_squared (float): The square of the norm of the full \n                gradient.\n            theta (float): The hyperparameter theta in the DINGO algorithm.\n            phi (float): The hyperparameter phi in the DINGO algorithm.\n        \"\"\"", "\n", "z", "=", "self", ".", "local_hessian_tilde_pseudoinverse_times_gradient_tilde", "\n", "if", "(", "torch", ".", "mm", "(", "z", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_gradient", ")", "\n", "<", "theta", "*", "gradient_norm_squared", ")", ":", "\n", "            ", "H", "=", "lambda", "v", ":", "self", ".", "get_local_hessian_times_vector", "(", "model", ",", "v", ")", "\n", "A", "=", "lambda", "v", ":", "H", "(", "H", "(", "v", ")", ")", "+", "phi", "*", "phi", "*", "v", "\n", "temp", "=", "CG", "(", "A", ",", "hessian_times_gradient", ",", "self", ".", "device", ",", "\n", "rtol", "=", "self", ".", "subproblem_tolerance", ",", "\n", "maxit", "=", "self", ".", "subproblem_maximum_iterations", ")", "\n", "if", "temp", "is", "None", ":", "# CG failed", "\n", "                ", "return", "None", "\n", "", "inverse_times_hessian_times_gradient", "=", "temp", "[", "0", "]", "\n", "lagrangian_numerator", "=", "-", "torch", ".", "mm", "(", "z", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "hessian_times_gradient", ")", "+", "theta", "*", "gradient_norm_squared", "\n", "lagrangian_denominator", "=", "torch", ".", "mm", "(", "\n", "hessian_times_gradient", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "inverse_times_hessian_times_gradient", ")", "\n", "lagrangian", "=", "lagrangian_numerator", "/", "lagrangian_denominator", "\n", "direction", "=", "-", "z", "-", "lagrangian", "*", "inverse_times_hessian_times_gradient", "\n", "", "else", ":", "\n", "            ", "direction", "=", "-", "z", "\n", "", "return", "direction", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_gradient_on_sample": [[272, 295], ["inputs.to.to.to", "labels.to.to.to", "model", "worker.Worker.criterion", "model.zero_grad", "worker.Worker.backward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "worker.Worker.get_model_weights", "len", "T.grad.reshape", "model.parameters"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights"], ["", "def", "get_gradient_on_sample", "(", "self", ",", "model", ",", "sample", ")", ":", "\n", "        ", "\"\"\"Returns the gradient over the sample.\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n            sample (tuple(torch.Tensor, torch.Tensor)): A tuple of inputs and \n                labels.\n        \"\"\"", "\n", "inputs", ",", "labels", "=", "sample", "\n", "inputs", "=", "inputs", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "labels", ".", "to", "(", "self", ".", "device", ")", "\n", "outputs", "=", "model", "(", "inputs", ")", "\n", "loss", "=", "self", ".", "criterion", "(", "outputs", ",", "labels", ")", "\n", "model", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "gradient", "=", "torch", ".", "cat", "(", "\n", "[", "T", ".", "grad", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "T", "in", "model", ".", "parameters", "(", ")", "]", ",", "dim", "=", "0", ")", ".", "data", "\n", "\n", "if", "self", ".", "regularization_parameter", "!=", "0", ":", "\n", "            ", "weights", "=", "self", ".", "get_model_weights", "(", "model", ")", "\n", "gradient", "+=", "self", ".", "regularization_parameter", "*", "weights", "\n", "\n", "", "return", "gradient", "*", "(", "1.0", "/", "len", "(", "labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.update_model": [[301, 314], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "torch.split", "torch.split", "enumerate", "parameter.numel", "model.parameters", "direction_split[].reshape", "model.parameters"], "methods", ["None"], ["", "def", "update_model", "(", "self", ",", "model", ",", "update_direction", ")", ":", "\n", "        ", "\"\"\"Add the update_direction to the model parameters.\n        \n        Arguments:\n            model (torch.nn.Module): A model.\n            update_direction (torch.Tensor): The update direction.\n        \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "model", ".", "parameters", "(", ")", "]", "\n", "direction_split", "=", "torch", ".", "split", "(", "update_direction", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "                ", "parameter", "+=", "direction_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_InexactDANE_subproblem_solution": [[316, 368], ["worker.Worker.get_model_weights", "copy.deepcopy", "worker.Worker.get_model_weights", "numpy.random.choice", "torch.data.Subset", "torch.data.Subset", "torch.data.DataLoader", "torch.data.DataLoader", "iter", "worker.Worker.update_model", "worker.Worker.get_model_weights", "worker.Worker.get_gradient_on_sample", "worker.Worker.get_gradient_on_sample", "worker.Worker.get_gradient_on_sample", "worker.Worker.get_gradient_on_sample"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.update_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_gradient_on_sample", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_gradient_on_sample", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_gradient_on_sample", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_gradient_on_sample"], ["", "", "", "def", "get_InexactDANE_subproblem_solution", "(", "self", ",", "model", ",", "gradient", ",", "\n", "step_size", "=", "1.0", ",", "eta", "=", "1.0", ",", "mu", "=", "0.0", ",", "\n", "AIDE_tau", "=", "0.0", ",", "AIDE_y", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"Returns a solution to the local InexactDANE subproblem using SVRG.\n        \n        Arguments:\n            model (torch.nn.Module): A model.\n            gradient (torch.Tensor): The current full gradient.\n            step_size (float, optional): The step size for SVRG solver.\n            eta (float, optional): The hyperparameter eta in the InexactDANE \n                algorithm.\n            mu (float, optional): The hyperparameter mu in the InexactDANE \n                algorithm.\n            AIDE_tau (float, optional): The hyperparameter tau in the AIDE \n                algorithm.\n            AIDE_y (torch.Tensor, optional): The tensor y in the AIDE \n                algorithm.\n        \"\"\"", "\n", "model_weights", "=", "self", ".", "get_model_weights", "(", "model", ")", "\n", "new_model", "=", "deepcopy", "(", "model", ")", "\n", "new_model_weights", "=", "self", ".", "get_model_weights", "(", "new_model", ")", "\n", "\n", "if", "AIDE_tau", "!=", "0", ":", "\n", "            ", "gradient", "=", "gradient", "+", "AIDE_tau", "*", "(", "model_weights", "-", "AIDE_y", ")", "\n", "\n", "", "sample_indices", "=", "np", ".", "random", ".", "choice", "(", "self", ".", "s", ",", "\n", "self", ".", "subproblem_maximum_iterations", ")", "\n", "sample_set", "=", "utils", ".", "data", ".", "Subset", "(", "self", ".", "dataset", ",", "sample_indices", ")", "\n", "sample_loader", "=", "utils", ".", "data", ".", "DataLoader", "(", "sample_set", ",", "batch_size", "=", "1", ",", "\n", "num_workers", "=", "self", ".", "dataloader_processes", ")", "\n", "\n", "for", "sample", "in", "iter", "(", "sample_loader", ")", ":", "\n", "            ", "if", "AIDE_tau", "==", "0", ":", "\n", "                ", "sample_gradient_model", "=", "self", ".", "get_gradient_on_sample", "(", "model", ",", "\n", "sample", ")", "\n", "sample_gradient_new_model", "=", "self", ".", "get_gradient_on_sample", "(", "\n", "new_model", ",", "sample", ")", "\n", "", "else", ":", "\n", "                ", "sample_gradient_model", "=", "self", ".", "get_gradient_on_sample", "(", "model", ",", "sample", ")", "+", "AIDE_tau", "*", "(", "model_weights", "-", "AIDE_y", ")", "\n", "sample_gradient_new_model", "=", "self", ".", "get_gradient_on_sample", "(", "new_model", ",", "sample", ")", "+", "AIDE_tau", "*", "(", "new_model_weights", "-", "AIDE_y", ")", "\n", "", "update_direction", "=", "sample_gradient_new_model", "-", "sample_gradient_model", "+", "eta", "*", "gradient", "+", "mu", "*", "(", "new_model_weights", "-", "model_weights", ")", "\n", "update_direction", "*=", "-", "step_size", "\n", "self", ".", "update_model", "(", "new_model", ",", "update_direction", ")", "\n", "new_model_weights", "=", "self", ".", "get_model_weights", "(", "new_model", ")", "\n", "\n", "", "return", "new_model_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_minibatch_grad": [[374, 388], ["int", "numpy.random.choice", "torch.data.Subset", "torch.data.Subset", "torch.data.DataLoader", "torch.data.DataLoader", "iter().next", "worker.Worker.get_gradient_on_sample", "len", "len", "iter"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_gradient_on_sample"], ["", "def", "get_minibatch_grad", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Returns the local gradient over a random mini-batch of size s/5.\n    \n        Arguments:\n            model (torch.nn.Module): A model.\n        \"\"\"", "\n", "minibatch_size", "=", "int", "(", "self", ".", "s", "/", "5.0", ")", "\n", "sample_indices", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "self", ".", "dataset", ")", ",", "minibatch_size", ")", "\n", "sample_set", "=", "utils", ".", "data", ".", "Subset", "(", "self", ".", "dataset", ",", "sample_indices", ")", "\n", "sample_loader", "=", "utils", ".", "data", ".", "DataLoader", "(", "sample_set", ",", "\n", "batch_size", "=", "len", "(", "sample_set", ")", ",", "num_workers", "=", "self", ".", "dataloader_processes", ")", "\n", "sample", "=", "iter", "(", "sample_loader", ")", ".", "next", "(", ")", "\n", "sample_gradient", "=", "self", ".", "get_gradient_on_sample", "(", "model", ",", "sample", ")", "\n", "return", "sample_gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.DINGO": [[8, 197], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "DINGO.get_update_direction", "loss_list.append", "torch.norm", "torch.norm", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "DINGO.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "torch.cat", "torch.cat", "torch.broadcast", "torch.norm", "torch.norm", "torch.norm.pow", "torch.zeros", "torch.zeros", "torch.broadcast", "alpha_and_gradient.to.to", "torch.norm", "torch.norm", "DINGO.get_local_line_search_matrix", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "line_search_matrix.to.to", "DINGO.line_search", "loss_list.append", "gradient_norm_list.append", "step_size_list.append", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "DINGO.print_row", "get_updated_model.parameters", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "DINGO.get_updated_model", "time.time", "torch.norm", "torch.norm", "torch.tensor().reshape", "torch.tensor().reshape", "gradient.cpu", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "torch.tensor", "torch.tensor", "float"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_update_direction", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_local_line_search_matrix", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.line_search", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient"], ["def", "DINGO", "(", "model", ",", "worker", ",", "device", ",", "theta", "=", "1e-4", ",", "phi", "=", "1e-6", ",", "max_iterations", "=", "100", ",", "\n", "max_communication_rounds", "=", "200", ",", "gradient_norm_tolerance", "=", "1e-8", ",", "\n", "line_search_rho", "=", "1e-4", ",", "line_search_max_iterations", "=", "50", ")", ":", "\n", "    ", "\"\"\"Run the DINGO algorithm.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        theta (float, optional): The hyperparameter theta in the DINGO \n            algorithm.\n        phi (float, optional): The hyperparameter phi in the DINGO algorithm.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of \n            communication rounds.\n        gradient_norm_tolerance (float, optional): The smallest the norm of the\n            full gradient can be before the algorithm stops.\n        line_search_rho (float, optional): Armijo line search parameter.\n        line_search_max_iterations (int, optional): The maximum number of line \n            search iterations.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^116s}\\n\"", ".", "format", "(", "\" DINGO \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "step_size_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "subproblem_failed", "=", "False", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#-------------------------- DINGO iteration ---------------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", "==", "0", ":", "\n", "# This iteration requires an additional communication round.", "\n", "            ", "'''\n            In subsequent iterations, the driver will broadcast the step-size \n            to update workers' model.\n            '''", "\n", "if", "rank", ">", "0", ":", "\n", "                ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "# Workers send local objective value and gradient to driver.", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "                ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "step_size", "=", "0.0", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "# The driver broadcasts the step-size and gradient to all workers.", "\n", "# step_size is from previous line search.", "\n", "            ", "alpha_and_gradient", "=", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "tensor", "(", "float", "(", "step_size", ")", ",", "device", "=", "cpu", ")", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "gradient", ".", "cpu", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "broadcast", "(", "alpha_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "end_message", "=", "'gradient_norm_tolerance reached'", "\n", "break", "\n", "", "gradient_norm_squared", "=", "gradient_norm", ".", "pow", "(", "2", ")", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "alpha_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "alpha_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "alpha_and_gradient", "=", "alpha_and_gradient", ".", "to", "(", "device", ")", "\n", "step_size", "=", "alpha_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "alpha_and_gradient", "[", "1", ":", "]", "\n", "if", "iteration", ">", "0", ":", "\n", "# All workers update to current model.", "\n", "# This worker node has direction from previous line search.", "\n", "                ", "model", "=", "get_updated_model", "(", "model", ",", "direction", ",", "step_size", ")", "\n", "", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "break", "\n", "\n", "# Update Direction.", "\n", "", "", "temp", "=", "get_update_direction", "(", "model", ",", "worker", ",", "device", ",", "gradient", ",", "theta", ",", "\n", "phi", ")", "\n", "if", "rank", "==", "0", ":", "\n", "            ", "if", "temp", "is", "None", ":", "\n", "                ", "end_message", "=", "'CG failed'", "\n", "subproblem_failed", "=", "True", "\n", "break", "\n", "", "direction", ",", "hessian_times_gradient", ",", "case", ",", "rounds", "=", "temp", "\n", "total_communication_rounds", "+=", "rounds", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "if", "temp", "is", "None", ":", "\n", "                ", "break", "\n", "", "direction", ",", "rounds", "=", "temp", "\n", "total_communication_rounds", "+=", "rounds", "\n", "\n", "# Line Search.", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_line_search_matrix", "=", "get_local_line_search_matrix", "(", "model", ",", "\n", "worker", ",", "direction", ",", "line_search_max_iterations", ")", "\n", "dist", ".", "reduce", "(", "local_line_search_matrix", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver averages all workers' local line-search matrix.", "\n", "            ", "line_search_matrix", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "\n", "line_search_max_iterations", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "line_search_matrix", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "line_search_matrix", "=", "line_search_matrix", ".", "to", "(", "device", ")", "\n", "line_search_matrix", "*=", "1.0", "/", "num_workers", "\n", "new_model", ",", "new_loss", ",", "new_gradient", ",", "line_search_exp", ",", "step_size", "=", "line_search", "(", "model", ",", "line_search_matrix", ",", "gradient_norm_squared", ",", "\n", "direction", ",", "hessian_times_gradient", ",", "\n", "line_search_rho", ")", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ Printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "step_size_list", ".", "append", "(", "step_size", ")", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "case", ",", "line_search_exp", ",", "step_size", ",", "torch", ".", "norm", "(", "direction", ")", ",", "\n", "loss", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "\n", "loss", "=", "new_loss", "\n", "gradient", "=", "new_gradient", "\n", "model", "=", "new_model", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "\n", "test_accuracy", "=", "test_accuracy", ",", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "step_size_list", ",", "\n", "label", "=", "\"DINGO\"", ",", "max_x", "=", "max_communication_rounds", ",", "\n", "failed", "=", "subproblem_failed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.print_row": [[199, 240], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "case", "=", "1", ",", "line_search_exp", "=", "0", ",", "step_size", "=", "1", ",", "update_direction_norm", "=", "0", ",", "\n", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "test_accuracy", "=", "0", ",", "\n", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for DINGO.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of \n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the \n            iteration.\n        case (int, optional): The case the iteration belongs to.\n        line_search_exp (int, optional): The line search exponent found.\n        step_size (float, optional): The step size found.\n        update_direction_norm (float, optional): The norm of the update \n            direction.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the \n            results table.\n    \"\"\"", "\n", "header", "=", "(", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^10s}{:^10s}{:^10s}\"", "\n", "\"{:^10s}{:^14s}{:^20s}\"", ")", ".", "format", "(", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\n", "\"Case\"", ",", "\"LS Exp\"", ",", "\"Step Size\"", ",", "\"||p_t||\"", ",", "\"f(w_t)\"", ",", "\n", "\"||\u2207f(w_t)||\"", ",", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:62s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10d}{:^10d}{:^10.2e}\"", "\n", "\"{:^10.2e}{:^10.2e}{:^14.2e}{:^20.2f}\"", ")", ".", "format", "(", "\n", "iteration", ",", "cumulative_communication_rounds", ",", "iteration_time", ",", "\n", "case", ",", "line_search_exp", ",", "step_size", ",", "update_direction_norm", ",", "\n", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_update_direction": [[242, 367], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.norm().pow", "torch.norm().pow", "torch.get_world_size", "worker.get_local_hessian_times_vector().cpu", "worker.get_local_hessian_inverse_times_vector().cpu", "worker.get_local_hessian_tilde_pseudoinverse_times_gradient_tilde().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "Hg_c1_and_c2.to.to", "torch.cat", "torch.cat", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "temp[].to", "p.numel", "torch.norm", "torch.norm", "torch.mm", "torch.mm", "temp[].to", "worker.get_local_case_3_update_direction", "torch.reduce", "torch.zeros", "torch.zeros", "torch.broadcast", "model.parameters", "worker.get_local_hessian_times_vector", "worker.get_local_hessian_inverse_times_vector", "worker.get_local_hessian_tilde_pseudoinverse_times_gradient_tilde", "case_1_direction.transpose", "torch.mm", "torch.mm", "torch.cat", "torch.cat", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.reduce", "case_3_direction[].to", "temp[].to.cpu", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "int", "case_2_direction.transpose", "int", "print", "torch.cat", "torch.cat", "torch.broadcast", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "temp[].to.cpu", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat.cpu", "int", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_case_3_update_direction", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_times_vector", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_inverse_times_vector", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_hessian_tilde_pseudoinverse_times_gradient_tilde"], ["", "", "def", "get_update_direction", "(", "model", ",", "worker", ",", "device", ",", "gradient", ",", "theta", ",", "phi", ")", ":", "\n", "    ", "\"\"\"Compute the update direction of DINGO.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        gradient (torch.Tensor): The current full gradient.\n        theta (float): The hyperparameter theta in the DINGO \n            algorithm.\n        phi (float): The hyperparameter phi in the DINGO algorithm.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "gradient_norm_squared", "=", "torch", ".", "norm", "(", "gradient", ")", ".", "pow", "(", "2", ")", "\n", "communication_rounds", "=", "0", "\n", "\n", "if", "rank", ">", "0", ":", "\n", "        ", "local_hessian_times_gradient", "=", "worker", ".", "get_local_hessian_times_vector", "(", "\n", "model", ",", "gradient", ")", ".", "cpu", "(", ")", "\n", "c1", "=", "worker", ".", "get_local_hessian_inverse_times_vector", "(", "model", ",", "gradient", ",", "\n", "\"minresQLP\"", ")", ".", "cpu", "(", ")", "\n", "c2", "=", "worker", ".", "get_local_hessian_tilde_pseudoinverse_times_gradient_tilde", "(", "\n", "model", ",", "gradient", ",", "phi", ")", ".", "cpu", "(", ")", "\n", "local_Hg_c1_and_c2", "=", "torch", ".", "cat", "(", "[", "local_hessian_times_gradient", ",", "c1", ",", "c2", "]", ",", "\n", "dim", "=", "1", ")", "\n", "dist", ".", "reduce", "(", "local_Hg_c1_and_c2", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "Hg_c1_and_c2", "=", "torch", ".", "zeros", "(", "dimension", ",", "3", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "Hg_c1_and_c2", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "Hg_c1_and_c2", "=", "Hg_c1_and_c2", ".", "to", "(", "device", ")", "\n", "Hg_c1_and_c2", "*=", "1.0", "/", "num_workers", "\n", "hessian_times_gradient", "=", "Hg_c1_and_c2", "[", ":", ",", "0", ":", "1", "]", "\n", "case_1_direction", "=", "-", "1.0", "*", "Hg_c1_and_c2", "[", ":", ",", "1", ":", "2", "]", "\n", "case_2_direction", "=", "-", "1.0", "*", "Hg_c1_and_c2", "[", ":", ",", "2", ":", "3", "]", "\n", "\n", "if", "(", "torch", ".", "mm", "(", "case_1_direction", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_gradient", ")", "\n", "<=", "-", "theta", "*", "gradient_norm_squared", ")", ":", "# Case 1.", "\n", "            ", "case", "=", "1", "\n", "direction", "=", "case_1_direction", "\n", "", "elif", "(", "torch", ".", "mm", "(", "case_2_direction", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_gradient", ")", "\n", "<=", "-", "theta", "*", "gradient_norm_squared", ")", ":", "# Case 2.", "\n", "            ", "case", "=", "2", "\n", "direction", "=", "case_2_direction", "\n", "", "else", ":", "# Case 1 and Case 2 failed, so now use Case 3.", "\n", "            ", "'''\n            For simplicity, the driver broadcasts the Hessian-gradient \n            product to all workers. In practice, the Hessian-gradient \n            product only needs to be sent to the workers that need to \n            compute the local Case 3 update direction.\n            '''", "\n", "cat_1_and_hessian_times_gradient", "=", "torch", ".", "cat", "(", "\n", "[", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "hessian_times_gradient", ".", "cpu", "(", ")", "]", ",", "\n", "dim", "=", "0", ")", "\n", "'''\n            The 1 indicates to the worker that we are computing the \n            Case 3 update direction.\n            '''", "\n", "dist", ".", "broadcast", "(", "cat_1_and_hessian_times_gradient", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "\n", "# The driver computes the Case 3 update direction.", "\n", "case_3_direction", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "case_3_direction", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "if", "int", "(", "case_3_direction", "[", "0", ",", "0", "]", ")", ">", "0", ":", "# CG failed on at least 1 worker", "\n", "                ", "print", "(", "\"CG in Case 3 failed on {} worker nodes\"", ".", "format", "(", "\n", "int", "(", "case_3_direction", "[", "0", ",", "0", "]", ")", ")", ")", "\n", "temp", "=", "torch", ".", "cat", "(", "[", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "torch", ".", "zeros", "(", "(", "dimension", ",", "1", ")", ",", "device", "=", "cpu", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The 1 indicates that CG failed.", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "return", "None", "\n", "", "case_3_direction", "=", "case_3_direction", "[", "1", ":", "]", ".", "to", "(", "device", ")", "\n", "case_3_direction", "*=", "1.0", "/", "num_workers", "\n", "\n", "case", "=", "3", "\n", "direction", "=", "case_3_direction", "\n", "\n", "", "cat_minus_1_and_direction", "=", "torch", ".", "cat", "(", "[", "-", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "direction", ".", "cpu", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "'''\n        The -1 indicates to the worker that we have computed the update \n        direction.\n        '''", "\n", "dist", ".", "broadcast", "(", "cat_minus_1_and_direction", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "return", "direction", ",", "hessian_times_gradient", ",", "case", ",", "communication_rounds", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "        ", "temp", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "\n", "if", "temp", "[", "0", ",", "0", "]", ">", "0", ":", "# Compute local Case 3 update direction.", "\n", "            ", "hessian_times_gradient", "=", "temp", "[", "1", ":", "]", ".", "to", "(", "device", ")", "\n", "temp", "=", "worker", ".", "get_local_case_3_update_direction", "(", "model", ",", "\n", "hessian_times_gradient", ",", "gradient_norm_squared", ",", "theta", ",", "phi", ")", "\n", "if", "temp", "is", "None", ":", "# CG failed.", "\n", "                ", "v", "=", "torch", ".", "cat", "(", "[", "torch", ".", "ones", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "torch", ".", "zeros", "(", "(", "dimension", ",", "1", ")", ",", "device", "=", "cpu", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The 1 indicates that CG failed.", "\n", "", "else", ":", "\n", "                ", "v", "=", "torch", ".", "cat", "(", "[", "torch", ".", "zeros", "(", "(", "1", ",", "1", ")", ",", "device", "=", "cpu", ")", ",", "\n", "temp", ".", "cpu", "(", ")", "]", ",", "dim", "=", "0", ")", "\n", "# The 0 indicates that CG passed.", "\n", "", "dist", ".", "reduce", "(", "v", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "\n", "# Line search.", "\n", "temp", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "temp", ",", "0", ")", "\n", "communication_rounds", "+=", "1", "\n", "if", "int", "(", "temp", "[", "0", ",", "0", "]", ")", ">", "0", ":", "# CG failed", "\n", "                ", "return", "None", "\n", "\n", "# Line search.", "\n", "", "", "assert", "(", "temp", "[", "0", ",", "0", "]", "<", "0", ")", "\n", "direction", "=", "temp", "[", "1", ":", "]", ".", "to", "(", "device", ")", "\n", "return", "direction", ",", "communication_rounds", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model": [[373, 390], ["copy.deepcopy", "torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "copy.deepcopy.parameters", "copy.deepcopy.parameters", "direction_split[].reshape"], "function", ["None"], ["", "", "def", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", ":", "\n", "    ", "\"\"\"Returns a new model with parameters equal to the addition of \n    step_size*update_direction and the input model parameters.\n    \n    Arguments:\n        model (torch.nn.Module): A model.\n        update_direction (torch.Tensor): The update direction.\n        step_size (float): The step size.\n    \"\"\"", "\n", "new_model", "=", "deepcopy", "(", "model", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "new_model", ".", "parameters", "(", ")", "]", "\n", "direction_split", "=", "torch", ".", "split", "(", "update_direction", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "new_model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", "+=", "step_size", "*", "direction_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "new_model", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_local_line_search_matrix": [[392, 416], ["torch.cat", "torch.cat", "DINGO.get_updated_model", "worker.get_local_loss().reshape().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "local_vector_list.append", "worker.get_local_loss().reshape", "worker.get_local_gradient", "worker.get_local_loss"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss"], ["", "def", "get_local_line_search_matrix", "(", "model", ",", "worker", ",", "update_direction", ",", "\n", "line_search_max_iterations", ")", ":", "\n", "    ", "\"\"\"Return a tensor where column k is the local objective value and local \n    gradient at the point: weights + 0.5**k * update_direction.\n\n    Args:\n        model (torch.nn.Module): A model.\n        worker (Worker): A Worker class instance.\n        update_direction (torch.Tensor): The update direction.\n        line_search_max_iterations (int): The maximum number of line search \n            iterations.\n    \"\"\"", "\n", "local_vector_list", "=", "[", "]", "\n", "line_search_exp", "=", "0", "\n", "step_size", "=", "1.0", "\n", "while", "line_search_exp", "<", "line_search_max_iterations", ":", "\n", "        ", "temp_model", "=", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", "\n", "temp_loss", "=", "worker", ".", "get_local_loss", "(", "temp_model", ")", ".", "reshape", "(", "1", ",", "1", ")", ".", "cpu", "(", ")", "\n", "temp_gradient", "=", "worker", ".", "get_local_gradient", "(", "temp_model", ")", ".", "cpu", "(", ")", "\n", "temp_vector", "=", "torch", ".", "cat", "(", "[", "temp_loss", ",", "temp_gradient", "]", ",", "dim", "=", "0", ")", "\n", "local_vector_list", ".", "append", "(", "temp_vector", ")", "\n", "line_search_exp", "+=", "1", "\n", "step_size", "=", "step_size", "/", "2", "\n", "", "return", "torch", ".", "cat", "(", "local_vector_list", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.line_search": [[418, 453], ["torch.mm", "torch.mm", "DINGO.get_updated_model", "update_direction.transpose", "torch.mm", "torch.mm", "new_gradient.transpose"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.DINGO.get_updated_model"], ["", "def", "line_search", "(", "model", ",", "line_search_matrix", ",", "gradient_norm_squared", ",", "\n", "update_direction", ",", "hessian_times_gradient", ",", "line_search_rho", ")", ":", "\n", "    ", "\"\"\"Compute the largest step-size that passes backtracking line search on \n    the square of the norm of the gradient. Otherwise, return the smallest \n    step-size.\n\n    Args:\n        model (torch.nn.Module): The current model.\n        line_search_matrix (torch.Tensor): A matrix where column k is the\n            objective value and gradient at the point:\n            weights + 0.5**k * update_direction.\n        gradient_norm_squared (float): The square of the norm of the full \n            gradient.\n        update_direction (torch.Tensor): The update direction.\n        hessian_times_gradient (torch.Tensor): The current Hessian-gradient \n            product.\n        line_search_rho (float): Armijo line search parameter.\n    \"\"\"", "\n", "line_search_exp", "=", "0", "\n", "step_size", "=", "1.0", "\n", "line_search_max_iterations", "=", "line_search_matrix", ".", "shape", "[", "1", "]", "\n", "direction_dot_hessian_times_gradient", "=", "torch", ".", "mm", "(", "\n", "update_direction", ".", "transpose", "(", "0", ",", "1", ")", ",", "hessian_times_gradient", ")", "\n", "new_loss", "=", "line_search_matrix", "[", "0", ",", "0", "]", "\n", "new_gradient", "=", "line_search_matrix", "[", "1", ":", ",", "0", ":", "1", "]", "\n", "while", "(", "torch", ".", "mm", "(", "new_gradient", ".", "transpose", "(", "0", ",", "1", ")", ",", "new_gradient", ")", "\n", ">", "gradient_norm_squared", "\n", "+", "2", "*", "step_size", "*", "line_search_rho", "*", "direction_dot_hessian_times_gradient", "\n", "and", "line_search_exp", "<", "line_search_max_iterations", ")", ":", "\n", "        ", "line_search_exp", "+=", "1", "\n", "step_size", "=", "step_size", "/", "2", "\n", "new_loss", "=", "line_search_matrix", "[", "0", ",", "line_search_exp", "]", "\n", "new_gradient", "=", "line_search_matrix", "[", "1", ":", ",", "line_search_exp", ":", "line_search_exp", "+", "1", "]", "\n", "", "new_model", "=", "get_updated_model", "(", "model", ",", "update_direction", ",", "step_size", ")", "\n", "return", "new_model", ",", "new_loss", ",", "new_gradient", ",", "line_search_exp", ",", "step_size", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results": [[4, 95], ["float", "matplotlib.figure", "matplotlib.subplots_adjust", "matplotlib.subplot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.subplot", "matplotlib.semilogy", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.subplot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.savefig", "matplotlib.plot", "matplotlib.xlim", "matplotlib.semilogy", "matplotlib.xlim", "matplotlib.plot", "matplotlib.xlim", "len", "matplotlib.subplot", "matplotlib.semilogy", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.semilogy", "len"], "function", ["None"], ["def", "plot_results", "(", "loss_list", ",", "grad_norm_list", ",", "test_accuracy_list", ",", "x_list", ",", "\n", "step_size_list", "=", "[", "]", ",", "label", "=", "\"DINGO\"", ",", "max_x", "=", "float", "(", "'inf'", ")", ",", "\n", "xlabel", "=", "\"Communication Rounds\"", ",", "failed", "=", "False", ")", ":", "\n", "    ", "\"\"\"Plot the results of an algorithm.\n\n    Arguments:\n        loss_list (list[float]): A list of the objective value at each \n            iteration.\n        grad_norm_list (list[float]): A list of the norm of the gradient at \n            each iteration.\n        test_accuracy_list (list[float]): A list of the accuracy on the test\n            dataset at each iteration.\n        x_list (list[int]): A list of horizontal axis values.\n        step_size_list (list[float], optional): A list of the step size used \n            at each iteration.\n        label (str, optional): The label in the plots.\n        max_x (float, optional): The maximum value on the horizontal axes.\n        xlabel (str, optional): The label on the horizontal axes.\n        failed (bool, optional): Whether the algorithm failed.\n    \"\"\"", "\n", "if", "label", "==", "'AIDE'", ":", "\n", "        ", "colour", "=", "'r'", "\n", "style", "=", "':'", "\n", "", "elif", "label", "==", "'Asynchronous SGD'", ":", "\n", "        ", "colour", "=", "'y'", "\n", "style", "=", "'--'", "\n", "", "elif", "label", "==", "'DINGO'", ":", "\n", "        ", "colour", "=", "'k'", "\n", "style", "=", "'-'", "\n", "", "elif", "label", "==", "'DiSCO'", ":", "\n", "        ", "colour", "=", "'c'", "\n", "style", "=", "'-.'", "\n", "", "elif", "label", "==", "\"GIANT\"", ":", "\n", "        ", "colour", "=", "'g'", "\n", "style", "=", "'-.'", "\n", "", "elif", "label", "==", "'InexactDANE'", ":", "\n", "        ", "colour", "=", "'m'", "\n", "style", "=", "':'", "\n", "", "else", ":", "\n", "        ", "colour", "=", "'b'", "\n", "style", "=", "'--'", "\n", "\n", "", "plt", ".", "figure", "(", "1", ",", "figsize", "=", "(", "20", ",", "4", ")", ")", "\n", "plt", ".", "subplots_adjust", "(", "wspace", "=", "0.3", ")", "\n", "\n", "plt", ".", "subplot", "(", "141", ")", "\n", "plt", ".", "plot", "(", "x_list", ",", "loss_list", ",", "color", "=", "colour", ",", "linestyle", "=", "style", ",", "label", "=", "label", ")", "\n", "if", "failed", ":", "\n", "        ", "plt", ".", "plot", "(", "x_list", "[", "-", "1", ":", "]", ",", "loss_list", "[", "-", "1", ":", "]", ",", "color", "=", "colour", ",", "linestyle", "=", "style", ",", "\n", "label", "=", "label", ",", "marker", "=", "'x'", ")", "\n", "", "plt", ".", "xlabel", "(", "xlabel", ")", "\n", "plt", ".", "ylabel", "(", "r'Objective Function: $f\\:(\\mathbf{w})$'", ")", "\n", "if", "x_list", "[", "-", "1", "]", ">", "max_x", ":", "\n", "        ", "plt", ".", "xlim", "(", "right", "=", "max_x", ")", "\n", "\n", "", "plt", ".", "subplot", "(", "142", ")", "\n", "plt", ".", "semilogy", "(", "x_list", ",", "grad_norm_list", ",", "color", "=", "colour", ",", "linestyle", "=", "style", ",", "\n", "label", "=", "label", ")", "\n", "if", "failed", ":", "\n", "        ", "plt", ".", "semilogy", "(", "x_list", "[", "-", "1", ":", "]", ",", "grad_norm_list", "[", "-", "1", ":", "]", ",", "color", "=", "colour", ",", "\n", "linestyle", "=", "style", ",", "label", "=", "label", ",", "marker", "=", "'x'", ")", "\n", "", "plt", ".", "xlabel", "(", "xlabel", ")", "\n", "plt", ".", "ylabel", "(", "r'Gradient Norm: $||\\nabla f(\\mathbf{w})||$'", ")", "\n", "if", "x_list", "[", "-", "1", "]", ">", "max_x", ":", "\n", "        ", "plt", ".", "xlim", "(", "right", "=", "max_x", ")", "\n", "\n", "", "plt", ".", "subplot", "(", "143", ")", "\n", "plt", ".", "plot", "(", "x_list", ",", "test_accuracy_list", ",", "color", "=", "colour", ",", "linestyle", "=", "style", ",", "\n", "label", "=", "label", ")", "\n", "if", "failed", ":", "\n", "        ", "plt", ".", "plot", "(", "x_list", "[", "-", "1", ":", "]", ",", "test_accuracy_list", "[", "-", "1", ":", "]", ",", "color", "=", "colour", ",", "\n", "linestyle", "=", "style", ",", "label", "=", "label", ",", "marker", "=", "'x'", ")", "\n", "", "plt", ".", "xlabel", "(", "xlabel", ")", "\n", "plt", ".", "ylabel", "(", "'Test Classification Accuracy (%)'", ")", "\n", "if", "x_list", "[", "-", "1", "]", ">", "max_x", ":", "\n", "        ", "plt", ".", "xlim", "(", "right", "=", "max_x", ")", "\n", "\n", "", "xlabel", "=", "'Iteration'", "\n", "\n", "if", "len", "(", "step_size_list", ")", ">", "0", ":", "\n", "        ", "plt", ".", "subplot", "(", "144", ")", "\n", "plt", ".", "semilogy", "(", "step_size_list", ",", "color", "=", "colour", ",", "linestyle", "=", "style", ",", "\n", "label", "=", "label", ")", "\n", "if", "failed", ":", "\n", "            ", "plt", ".", "semilogy", "(", "[", "len", "(", "step_size_list", ")", "-", "1", "]", ",", "step_size_list", "[", "-", "1", ":", "]", ",", "\n", "color", "=", "colour", ",", "linestyle", "=", "style", ",", "label", "=", "label", ",", "\n", "marker", "=", "'x'", ")", "\n", "", "plt", ".", "xlabel", "(", "xlabel", ")", "\n", "plt", ".", "ylabel", "(", "r'Line Search: $\\alpha$'", ")", "\n", "\n", "", "plt", ".", "savefig", "(", "\"./plots/plot.pdf\"", ",", "bbox_inches", "=", "'tight'", ")", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.AIDE": [[8, 190], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "AIDE.get_model_weights", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "AIDE.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.broadcast", "torch.norm", "torch.norm", "torch.zeros", "torch.zeros", "torch.broadcast", "gradient.to.to", "torch.norm", "torch.norm", "worker.get_InexactDANE_subproblem_solution().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "new_weights.to.to", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "AIDE.print_row", "AIDE.replace_model_weights", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "new_weights.to.to", "AIDE.replace_model_weights", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.norm", "torch.norm", "replace_model_weights.parameters", "AIDE.replace_model_weights", "torch.broadcast", "AIDE.get_model_weights", "torch.zeros", "torch.zeros", "torch.broadcast", "new_weights.to.to", "AIDE.replace_model_weights", "AIDE.get_new_y_and_new_zeta", "gradient.to.cpu", "time.time", "new_weights.to.cpu", "new_weights.to.cpu", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "worker.get_InexactDANE_subproblem_solution", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.get_new_y_and_new_zeta", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_InexactDANE_subproblem_solution", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient"], ["def", "AIDE", "(", "model", ",", "worker", ",", "device", ",", "eta", "=", "1.0", ",", "mu", "=", "0.0", ",", "tau", "=", "0.0", ",", "\n", "subproblem_step_size", "=", "1.0", ",", "max_iterations", "=", "100", ",", "\n", "max_communication_rounds", "=", "200", ",", "gradient_norm_tolerance", "=", "1e-8", ")", ":", "\n", "    ", "\"\"\"Run the AIDE algorithm.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        eta (float, optional): The hyperparameter eta in the InexactDANE \n            algorithm.\n        mu (float, optional): The hyperparameter mu in the InexactDANE \n            algorithm.\n        tau (float, optional): The hyperparameter tau in the AIDE algorithm.\n        subproblem_step_size (float, optional): The step size used by the \n            subproblem solver.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of \n            communication rounds.\n        gradient_norm_tolerance (float, optional): The smallest the norm of the\n            full gradient can be before the algorithm stops.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^76s}\\n\"", ".", "format", "(", "\" AIDE \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "", "else", ":", "\n", "        ", "AIDE_y", "=", "get_model_weights", "(", "model", ")", "\n", "zeta", "=", "0.5", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#-------------------------- AIDE iteration ----------------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", ">", "0", ":", "\n", "# This iteration requires an initial update to workers' model.", "\n", "            ", "if", "rank", "==", "0", ":", "\n", "# new_weights is from previous iteration.", "\n", "                ", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "                ", "old_weights", "=", "get_model_weights", "(", "model", ")", "\n", "new_weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "new_weights", "=", "new_weights", ".", "to", "(", "device", ")", "\n", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "AIDE_y", ",", "zeta", "=", "get_new_y_and_new_zeta", "(", "old_weights", ",", "new_weights", ",", "\n", "tau", ",", "zeta", ")", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "# All workers send local objective value and gradient to driver.", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "dist", ".", "broadcast", "(", "gradient", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "end_message", "=", "'gradient_norm_tolerance reached'", "\n", "break", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "gradient", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient", "=", "gradient", ".", "to", "(", "device", ")", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "break", "\n", "", "local_solution", "=", "worker", ".", "get_InexactDANE_subproblem_solution", "(", "\n", "model", ",", "gradient", ",", "subproblem_step_size", ",", "eta", ",", "mu", ",", "tau", ",", "\n", "AIDE_y", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_solution", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "new_weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "new_weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "new_weights", "=", "new_weights", ".", "to", "(", "device", ")", "\n", "new_weights", "*=", "1.0", "/", "num_workers", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ Printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "loss", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "", "if", "(", "iteration", "==", "max_iterations", "\n", "or", "total_communication_rounds", ">=", "max_communication_rounds", ")", ":", "\n", "# Need to first get objective value and gradient norm on final model.", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "            ", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ".", "cpu", "(", ")", ",", "0", ")", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "new_weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ",", "0", ")", "\n", "new_weights", "=", "new_weights", ".", "to", "(", "device", ")", "\n", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "test_accuracy", "=", "test_accuracy", ",", "\n", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "label", "=", "\"AIDE\"", ",", "\n", "max_x", "=", "max_communication_rounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.print_row": [[192, 225], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "test_accuracy", "=", "0", ",", "\n", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for AIDE.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of\n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the\n            iteration.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the\n            results table.\n    \"\"\"", "\n", "header", "=", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^14s}{:^20s}\"", ".", "format", "(", "\n", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\"f(w_t)\"", ",", "\"||\u2207f(w_t)||\"", ",", "\n", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:22s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10.2e}{:^14.2e}\"", "\n", "\"{:^20.2f}\"", ")", ".", "format", "(", "iteration", ",", "cumulative_communication_rounds", ",", "\n", "iteration_time", ",", "objective_value", ",", "\n", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.get_model_weights": [[227, 237], ["torch.no_grad", "torch.no_grad", "torch.cat", "torch.cat", "w.reshape", "model.parameters"], "function", ["None"], ["", "", "def", "get_model_weights", "(", "model", ")", ":", "\n", "    ", "\"\"\"Returns a column tensor of the model parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "weights", "=", "torch", ".", "cat", "(", "[", "w", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "w", "in", "model", ".", "parameters", "(", ")", "]", ",", "\n", "dim", "=", "0", ")", ".", "data", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.replace_model_weights": [[239, 254], ["torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "model.parameters", "parameter.zero_", "weights_split[].reshape", "model.parameters"], "function", ["None"], ["", "def", "replace_model_weights", "(", "model", ",", "new_weights", ")", ":", "\n", "    ", "\"\"\"Replace the model parameters with new parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n        new_weights (torch.Tensor): A column tensor of new parameters.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "model", ".", "parameters", "(", ")", "]", "\n", "weights_split", "=", "torch", ".", "split", "(", "new_weights", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", ".", "zero_", "(", ")", "\n", "parameter", "+=", "weights_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.AIDE.get_new_y_and_new_zeta": [[256, 277], ["numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "get_new_y_and_new_zeta", "(", "old_weights", ",", "new_weights", ",", "tau", ",", "old_zeta", ",", "lamda", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"Returns the new y and zeta in the AIDE algorithm.\n\n    Arguments:\n        old_weights (torch.Tensor): The column tensor of the old model \n            parameters.\n        new_weights (torch.Tensor): The column tensor of the new model \n            parameters.\n        tau (float): The hyperparameter tau in the AIDE algorithm.\n        old_zeta (float): The current float zeta in the AIDE algorithm.\n        lamda (float, optional): The parameter lambda in the AIDE algorithm.\n    \"\"\"", "\n", "q", "=", "lamda", "/", "(", "lamda", "+", "tau", ")", "\n", "b", "=", "old_zeta", "*", "old_zeta", "-", "q", "\n", "new_zeta", "=", "(", "-", "b", "+", "sqrt", "(", "b", "*", "b", "+", "4", "*", "old_zeta", "*", "old_zeta", ")", ")", "/", "2.0", "\n", "if", "new_zeta", "<", "0", "or", "new_zeta", ">", "1", ":", "\n", "        ", "new_zeta", "=", "(", "-", "b", "-", "sqrt", "(", "b", "*", "b", "+", "4", "*", "old_zeta", "*", "old_zeta", ")", ")", "/", "2.0", "\n", "", "assert", "new_zeta", ">", "0", "and", "new_zeta", "<", "1", "\n", "beta", "=", "old_zeta", "*", "(", "1", "-", "old_zeta", ")", "/", "(", "old_zeta", "*", "old_zeta", "+", "new_zeta", ")", "\n", "new_y", "=", "new_weights", "+", "beta", "*", "(", "new_weights", "-", "old_weights", ")", "\n", "return", "new_y", ",", "new_zeta", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.Synchronous_SGD": [[7, 156], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "get_model_weights().cpu", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "weights.to.to", "SGD.replace_model_weights", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.norm", "torch.norm", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "SGD.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "worker.get_minibatch_grad().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "direction.to.to", "SGD.update_model", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.norm", "torch.norm", "loss_list.append", "gradient_norm_list.append", "SGD.print_row", "replace_model_weights.parameters", "get_model_weights().cpu", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "weights.to.to", "SGD.replace_model_weights", "time.time", "torch.norm", "torch.norm", "SGD.get_model_weights", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "worker.get_minibatch_grad", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "SGD.get_model_weights"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.update_model", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_minibatch_grad", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights"], ["def", "Synchronous_SGD", "(", "model", ",", "worker", ",", "device", ",", "learning_rate", "=", "1", ",", "max_iterations", "=", "100", ",", "\n", "max_communication_rounds", "=", "200", ")", ":", "\n", "    ", "\"\"\"Run the Synchronous SGD algorithm.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance. The worker for the driver is\n            used to record test accuracy.\n        device (torch.device): The device tensors will be allocated to.\n        learning_rate (float, optional): The learning rate.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of \n            communication rounds.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^86s}\\n\"", ".", "format", "(", "\" Synchronous SGD \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#--------------------- Synchronous SGD iteration ----------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", ">", "0", ":", "\n", "# This iteration requires an initial update to workers' model.", "\n", "            ", "if", "rank", "==", "0", ":", "\n", "                ", "weights", "=", "get_model_weights", "(", "model", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "broadcast", "(", "weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "                ", "weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "weights", "=", "weights", ".", "to", "(", "device", ")", "\n", "model", "=", "replace_model_weights", "(", "model", ",", "weights", ")", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_minibatch_gradient", "=", "worker", ".", "get_minibatch_grad", "(", "model", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_minibatch_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "direction", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "direction", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "direction", "=", "direction", ".", "to", "(", "device", ")", "\n", "direction", "*=", "-", "1.0", "/", "num_workers", "\n", "update_model", "(", "model", ",", "direction", ",", "learning_rate", ")", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "            ", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "\n", "# Compute loss and gradient for printing.", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "torch", ".", "norm", "(", "learning_rate", "*", "direction", ")", ",", "loss", ",", "\n", "gradient_norm", ",", "test_accuracy", ")", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "# Need to first get loss and gradient norm of the final model.", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "weights", "=", "get_model_weights", "(", "model", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "broadcast", "(", "weights", ",", "0", ")", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "        ", "weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "weights", ",", "0", ")", "\n", "weights", "=", "weights", ".", "to", "(", "device", ")", "\n", "model", "=", "replace_model_weights", "(", "model", ",", "weights", ")", "\n", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "test_accuracy", "=", "test_accuracy", ",", "\n", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "\n", "label", "=", "\"Synchronous SGD\"", ",", "max_x", "=", "max_communication_rounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.print_row": [[158, 193], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "update_direction_norm", "=", "0", ",", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "\n", "test_accuracy", "=", "0", ",", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for Synchronous SGD.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of \n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the \n            iteration.\n        update_direction_norm (float, optional): The norm of the update \n            direction.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the \n            results table.\n    \"\"\"", "\n", "header", "=", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^10s}{:^14s}{:^20s}\"", ".", "format", "(", "\n", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\"||p_t||\"", ",", "\"f(w_t)\"", ",", "\"||\u2207f(w_t)||\"", ",", "\n", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:32s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10.2e}{:^10.2e}{:^14.2e}\"", "\n", "\"{:^20.2f}\"", ")", ".", "format", "(", "iteration", ",", "cumulative_communication_rounds", ",", "\n", "iteration_time", ",", "update_direction_norm", ",", "objective_value", ",", "\n", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.get_model_weights": [[195, 205], ["torch.no_grad", "torch.no_grad", "torch.cat", "torch.cat", "w.reshape", "model.parameters"], "function", ["None"], ["", "", "def", "get_model_weights", "(", "model", ")", ":", "\n", "    ", "\"\"\"Returns a column tensor of the model parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "weights", "=", "torch", ".", "cat", "(", "[", "w", ".", "reshape", "(", "-", "1", ",", "1", ")", "for", "w", "in", "model", ".", "parameters", "(", ")", "]", ",", "\n", "dim", "=", "0", ")", ".", "data", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.update_model": [[207, 222], ["torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "model.parameters", "model.parameters", "direction_split[].reshape"], "function", ["None"], ["", "def", "update_model", "(", "model", ",", "update_direction", ",", "learning_rate", ")", ":", "\n", "    ", "\"\"\"Adds learning_rate*update_direction to the model parameters.\n    \n    Arguments:\n        model (torch.nn.Module): A model.\n        update_direction (torch.Tensor): The update direction.\n        learning_rate (float): The learning rate.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "model", ".", "parameters", "(", ")", "]", "\n", "direction_split", "=", "torch", ".", "split", "(", "update_direction", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", "+=", "learning_rate", "*", "direction_split", "[", "i", "]", ".", "reshape", "(", "\n", "parameter", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.SGD.replace_model_weights": [[224, 239], ["torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "model.parameters", "parameter.zero_", "weights_split[].reshape", "model.parameters"], "function", ["None"], ["", "", "", "def", "replace_model_weights", "(", "model", ",", "new_weights", ")", ":", "\n", "    ", "\"\"\"Replace the model parameters with new parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n        new_weights (torch.Tensor): A column tensor of new parameters.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "model", ".", "parameters", "(", ")", "]", "\n", "weights_split", "=", "torch", ".", "split", "(", "new_weights", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", ".", "zero_", "(", ")", "\n", "parameter", "+=", "weights_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "model", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.InexactDANE": [[7, 183], ["torch.get_rank", "sum", "torch.device", "torch.device", "torch.get_world_size", "print", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "InexactDANE.print_row", "print", "plot_results.plot_results", "p.numel", "time.time", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.broadcast", "torch.norm", "torch.norm", "torch.zeros", "torch.zeros", "torch.broadcast", "gradient.to.to", "torch.norm", "torch.norm", "worker.get_InexactDANE_subproblem_solution().cpu", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "new_weights.to.to", "loss_list.append", "gradient_norm_list.append", "worker.get_accuracy", "test_accuracy_list.append", "cumulative_communication_rounds_list.append", "cumulative_time_list.append", "InexactDANE.print_row", "InexactDANE.replace_model_weights", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "new_weights.to.to", "InexactDANE.replace_model_weights", "worker.get_local_loss().cpu", "worker.get_local_gradient().cpu", "torch.cat", "torch.cat", "torch.reduce", "torch.zeros", "torch.zeros", "torch.reduce", "loss_and_gradient.to.to", "torch.norm", "torch.norm", "replace_model_weights.parameters", "InexactDANE.replace_model_weights", "torch.broadcast", "torch.zeros", "torch.zeros", "torch.broadcast", "new_weights.to.to", "InexactDANE.replace_model_weights", "gradient.to.cpu", "time.time", "new_weights.to.cpu", "new_weights.to.cpu", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape", "worker.get_InexactDANE_subproblem_solution", "worker.get_local_loss", "worker.get_local_gradient", "worker.get_local_loss().cpu.reshape"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.plot_results.plot_results", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_accuracy", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_InexactDANE_subproblem_solution", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_loss", "home.repos.pwc.inspect_result.RixonC_DINGO.None.worker.Worker.get_local_gradient"], ["def", "InexactDANE", "(", "model", ",", "worker", ",", "device", ",", "eta", "=", "1.0", ",", "mu", "=", "0.0", ",", "\n", "subproblem_step_size", "=", "1.0", ",", "max_iterations", "=", "100", ",", "\n", "max_communication_rounds", "=", "200", ",", "gradient_norm_tolerance", "=", "1e-8", ")", ":", "\n", "    ", "\"\"\"Run the InexactDANE algorithm.\n\n    Arguments:\n        model (torch.nn.Module): A model to optimize.\n        worker (Worker): A Worker class instance.\n        device (torch.device): The device tensors will be allocated to.\n        eta (float, optional): The hyperparameter eta in the InexactDANE \n            algorithm.\n        mu (float, optional): The hyperparameter mu in the InexactDANE \n            algorithm.\n        subproblem_step_size (float, optional): The step size used by the \n            subproblem solver.\n        max_iterations (int, optional): The maximum number of iterations.\n        max_communication_rounds (int, optional): The maximum number of \n            communication rounds.\n        gradient_norm_tolerance (float, optional): The smallest the norm of the\n            full gradient can be before the algorithm stops.\n    \"\"\"", "\n", "rank", "=", "dist", ".", "get_rank", "(", ")", "\n", "dimension", "=", "sum", "(", "[", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "num_workers", "=", "dist", ".", "get_world_size", "(", ")", "-", "1", "\n", "cpu", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n", "if", "rank", "==", "0", ":", "\n", "        ", "print", "(", "\"\\n{:-^76s}\\n\"", ".", "format", "(", "\" InexactDANE \"", ")", ")", "\n", "# Results are added to these lists and then plotted.", "\n", "cumulative_communication_rounds_list", "=", "[", "0", "]", "\n", "cumulative_time_list", "=", "[", "0", "]", "\n", "gradient_norm_list", "=", "[", "]", "\n", "loss_list", "=", "[", "]", "\n", "test_accuracy_list", "=", "[", "]", "\n", "# We will store a message about why the algorithm stopped.", "\n", "end_message", "=", "\"max_iterations reached\"", "\n", "\n", "", "iteration", "=", "0", "\n", "total_communication_rounds", "=", "0", "\n", "\n", "while", "iteration", "<", "max_iterations", ":", "\n", "        ", "if", "total_communication_rounds", ">=", "max_communication_rounds", ":", "\n", "            ", "end_message", "=", "'max_communication_rounds reached'", "\n", "break", "\n", "\n", "#----------------------- InexactDANE iteration ------------------------", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "# The driver will record how long each iteration takes.", "\n", "            ", "iteration_start_time", "=", "time", "(", ")", "\n", "\n", "", "if", "iteration", ">", "0", ":", "\n", "# This iteration requires an initial update to workers' model.", "\n", "            ", "if", "rank", "==", "0", ":", "\n", "# new_weights is from previous iteration.", "\n", "                ", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "                ", "new_weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "new_weights", "=", "new_weights", ".", "to", "(", "device", ")", "\n", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "# All workers send local objective value and gradient to driver.", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "dist", ".", "broadcast", "(", "gradient", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "end_message", "=", "'gradient_norm_tolerance reached'", "\n", "break", "\n", "\n", "", "", "if", "rank", ">", "0", ":", "\n", "            ", "gradient", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "gradient", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "gradient", "=", "gradient", ".", "to", "(", "device", ")", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "if", "gradient_norm", "<=", "gradient_norm_tolerance", ":", "\n", "                ", "break", "\n", "", "local_solution", "=", "worker", ".", "get_InexactDANE_subproblem_solution", "(", "\n", "model", ",", "gradient", ",", "subproblem_step_size", ",", "eta", ",", "mu", ")", ".", "cpu", "(", ")", "\n", "dist", ".", "reduce", "(", "local_solution", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "new_weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "new_weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "new_weights", "=", "new_weights", ".", "to", "(", "device", ")", "\n", "new_weights", "*=", "1.0", "/", "num_workers", "\n", "iteration_time", "=", "time", "(", ")", "-", "iteration_start_time", "\n", "\n", "#------------------------------ Printing ------------------------------", "\n", "# This time is not recorded.", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "# Recall that the driver stores the test dataset in its worker.", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "cumulative_communication_rounds_list", ".", "append", "(", "\n", "total_communication_rounds", ")", "\n", "cumulative_time_list", ".", "append", "(", "\n", "cumulative_time_list", "[", "-", "1", "]", "+", "iteration_time", ")", "\n", "print_row", "(", "iteration", ",", "total_communication_rounds", ",", "iteration_time", ",", "\n", "loss", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "\n", "", "iteration", "+=", "1", "\n", "\n", "\n", "# Print final row.", "\n", "", "if", "(", "iteration", "==", "max_iterations", "\n", "or", "total_communication_rounds", ">=", "max_communication_rounds", ")", ":", "\n", "# Need to first get objective value and gradient norm on final model.", "\n", "        ", "if", "rank", "==", "0", ":", "\n", "            ", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ".", "cpu", "(", ")", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "\n", "", "if", "rank", ">", "0", ":", "\n", "            ", "new_weights", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "broadcast", "(", "new_weights", ",", "0", ")", "\n", "total_communication_rounds", "+=", "1", "\n", "new_weights", "=", "new_weights", ".", "to", "(", "device", ")", "\n", "model", "=", "replace_model_weights", "(", "model", ",", "new_weights", ")", "\n", "local_loss", "=", "worker", ".", "get_local_loss", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_gradient", "=", "worker", ".", "get_local_gradient", "(", "model", ")", ".", "cpu", "(", ")", "\n", "local_loss_and_gradient", "=", "torch", ".", "cat", "(", "[", "local_loss", ".", "reshape", "(", "1", ",", "1", ")", ",", "\n", "local_gradient", "]", ",", "dim", "=", "0", ")", "\n", "dist", ".", "reduce", "(", "local_loss_and_gradient", ",", "0", ")", "\n", "\n", "", "if", "rank", "==", "0", ":", "\n", "            ", "loss_and_gradient", "=", "torch", ".", "zeros", "(", "1", "+", "dimension", ",", "1", ",", "device", "=", "cpu", ")", "\n", "dist", ".", "reduce", "(", "loss_and_gradient", ",", "0", ")", "\n", "loss_and_gradient", "=", "loss_and_gradient", ".", "to", "(", "device", ")", "\n", "loss_and_gradient", "*=", "1.0", "/", "num_workers", "\n", "loss", "=", "loss_and_gradient", "[", "0", ",", "0", "]", "\n", "gradient", "=", "loss_and_gradient", "[", "1", ":", "]", "\n", "gradient_norm", "=", "torch", ".", "norm", "(", "gradient", ")", "\n", "\n", "", "", "if", "rank", "==", "0", ":", "\n", "        ", "loss_list", ".", "append", "(", "loss", ")", "\n", "gradient_norm_list", ".", "append", "(", "gradient_norm", ")", "\n", "test_accuracy", "=", "worker", ".", "get_accuracy", "(", "model", ")", "\n", "test_accuracy_list", ".", "append", "(", "test_accuracy", ")", "\n", "\n", "print_row", "(", "iteration", "=", "iteration", ",", "objective_value", "=", "loss", ",", "\n", "gradient_norm", "=", "gradient_norm", ",", "test_accuracy", "=", "test_accuracy", ",", "\n", "is_final_row", "=", "True", ")", "\n", "\n", "print", "(", "\"\\n{} after {:.2f} seconds\\n\"", ".", "format", "(", "end_message", ",", "\n", "cumulative_time_list", "[", "-", "1", "]", ")", ")", "\n", "\n", "plot_results", "(", "loss_list", ",", "gradient_norm_list", ",", "test_accuracy_list", ",", "\n", "cumulative_communication_rounds_list", ",", "label", "=", "\"InexactDANE\"", ",", "\n", "max_x", "=", "max_communication_rounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.print_row": [[185, 218], ["print", "print", "print"], "function", ["None"], ["", "", "def", "print_row", "(", "iteration", "=", "0", ",", "cumulative_communication_rounds", "=", "0", ",", "iteration_time", "=", "0", ",", "\n", "objective_value", "=", "0", ",", "gradient_norm", "=", "0", ",", "test_accuracy", "=", "0", ",", "\n", "is_final_row", "=", "False", ")", ":", "\n", "    ", "\"\"\"Print a row of the results table for InexactDANE.\n\n    Arguments:\n        iteration (int, optional): The iteration number.\n        cumulative_communication_rounds (int, optional): The total number of\n            communication rounds so far.\n        iteration_time (float, optional): The runtime, in seconds, of the\n            iteration.\n        objective_value (float, optional): The objective value.\n        gradient_norm (float, optional): The norm of the full gradient.\n        test_accuracy (float, optional): The accuracy on the test dataset.\n        is_final_row (bool, optional): Whether this is the final row of the\n            results table.\n    \"\"\"", "\n", "header", "=", "\"{:^10s}{:^10s}{:^12s}{:^10s}{:^14s}{:^20s}\"", ".", "format", "(", "\n", "\"Iter (t)\"", ",", "\"CCR\"", ",", "\"Time (sec)\"", ",", "\"f(w_t)\"", ",", "\"||\u2207f(w_t)||\"", ",", "\n", "\"Test Accuracy (%)\"", ")", "\n", "if", "(", "iteration", ")", "%", "20", "==", "0", ":", "\n", "# Print the header every 20 iterations.", "\n", "        ", "print", "(", "header", ")", "\n", "", "if", "is_final_row", ":", "\n", "        ", "prt", "=", "\"{:^10d}{:22s}{:^10.2e}{:^14.2e}{:^20.2f}\"", ".", "format", "(", "\n", "iteration", ",", "''", ",", "objective_value", ",", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "", "else", ":", "\n", "        ", "prt", "=", "(", "\"{:^10d}{:^10d}{:^12.2e}{:^10.2e}{:^14.2e}\"", "\n", "\"{:^20.2f}\"", ")", ".", "format", "(", "iteration", ",", "cumulative_communication_rounds", ",", "\n", "iteration_time", ",", "objective_value", ",", "\n", "gradient_norm", ",", "test_accuracy", ")", "\n", "print", "(", "prt", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.InexactDANE.replace_model_weights": [[220, 235], ["torch.no_grad", "torch.no_grad", "torch.split", "torch.split", "enumerate", "parameter.numel", "model.parameters", "parameter.zero_", "weights_split[].reshape", "model.parameters"], "function", ["None"], ["", "", "def", "replace_model_weights", "(", "model", ",", "new_weights", ")", ":", "\n", "    ", "\"\"\"Replace the model parameters with new parameters.\n\n    Arguments:\n        model (torch.nn.Module): A model.\n        new_weights (torch.Tensor): A column tensor of new parameters.\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "parameter_numels", "=", "[", "parameter", ".", "numel", "(", ")", "for", "parameter", "in", "model", ".", "parameters", "(", ")", "]", "\n", "weights_split", "=", "torch", ".", "split", "(", "new_weights", ",", "parameter_numels", ")", "\n", "for", "i", ",", "parameter", "in", "enumerate", "(", "model", ".", "parameters", "(", ")", ",", "0", ")", ":", "\n", "            ", "parameter", ".", "zero_", "(", ")", "\n", "parameter", "+=", "weights_split", "[", "i", "]", ".", "reshape", "(", "parameter", ".", "shape", ")", "\n", "", "", "return", "model", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.softmaxModel.softmaxModel.__init__": [[13, 19], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.softmaxModel.softmaxModel.__init__"], ["def", "__init__", "(", "self", ",", "num_features", ",", "num_classes", ")", ":", "\n", "        ", "super", "(", "softmaxModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_features", "=", "num_features", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "W", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "num_features", ",", "num_classes", ",", "\n", "requires_grad", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.softmaxModel.softmaxModel.forward": [[21, 30], ["x.reshape", "torch.mm", "torch.mm", "torch.mm", "torch.mm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward pass.\n        \n        Arguments:\n            x (torch.Tensor): Input tensor.\n        \"\"\"", "\n", "X", "=", "x", ".", "reshape", "(", "-", "1", ",", "self", ".", "num_features", ")", "\n", "XW", "=", "torch", ".", "mm", "(", "X", ",", "self", ".", "W", ")", "\n", "return", "XW", "# use criterion: nn.CrossEntropyLoss()", "", "", "", ""]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.cg.CG": [[4, 51], ["b.reshape.reshape", "torch.zeros", "b.reshape.clone", "torch.mm", "torch.mm", "b.clone.clone", "torch.zeros", "b.clone.transpose", "b.reshape.transpose", "torch.finfo", "torch.norm", "A", "torch.mm", "torch.mm.clone", "torch.mm", "r.clone.transpose", "torch.norm", "torch.norm", "torch.zeros.clone", "rel_res_k.clone", "b.clone.transpose"], "function", ["None"], ["def", "CG", "(", "A", ",", "b", ",", "device", ",", "rtol", "=", "1e-4", ",", "maxit", "=", "100", ")", ":", "\n", "    ", "\"\"\"Compute an approximate solution to A*x=b using CG.\n    \n    Arguments:\n        A (function): Matrix-vector product function.\n        b (torch.Tensor): A vector.\n        device (torch.device): The device tensors will be allocated to.\n        rtol (float, optional): The relative residual tolerance.\n        maxit (int, optional): The maximum number of iterations.\n    \"\"\"", "\n", "b", "=", "b", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "rtol2", "=", "rtol", "**", "2", "\n", "x", "=", "torch", ".", "zeros", "(", "b", ".", "shape", ",", "device", "=", "device", ")", "\n", "r", "=", "b", ".", "clone", "(", ")", "\n", "delta", "=", "torch", ".", "mm", "(", "r", ".", "transpose", "(", "0", ",", "1", ")", ",", "r", ")", "\n", "bb", "=", "torch", ".", "mm", "(", "b", ".", "transpose", "(", "0", ",", "1", ")", ",", "b", ")", "\n", "p", "=", "r", ".", "clone", "(", ")", "\n", "iteration", "=", "0", "\n", "best_rel_residual", "=", "torch", ".", "finfo", "(", ")", ".", "max", "\n", "\n", "if", "torch", ".", "norm", "(", "r", ")", "==", "0", ":", "\n", "        ", "rel_res", "=", "0", "\n", "return", "x", ",", "rel_res", ",", "iteration", "\n", "\n", "", "x_best", "=", "torch", ".", "zeros", "(", "b", ".", "shape", "[", "0", "]", ",", "1", ",", "device", "=", "device", ")", "\n", "\n", "while", "delta", ">", "rtol2", "*", "bb", "and", "iteration", "<", "maxit", ":", "\n", "        ", "Ap", "=", "A", "(", "p", ")", "\n", "pAp", "=", "torch", ".", "mm", "(", "p", ".", "transpose", "(", "0", ",", "1", ")", ",", "Ap", ")", "\n", "if", "pAp", "<=", "0", ":", "\n", "            ", "return", "None", "\n", "", "alpha", "=", "delta", "/", "pAp", "\n", "x", "=", "x", "+", "alpha", "*", "p", "\n", "r", "=", "r", "-", "alpha", "*", "Ap", "\n", "rel_res_k", "=", "torch", ".", "norm", "(", "r", ")", "/", "torch", ".", "norm", "(", "b", ")", "\n", "if", "best_rel_residual", ">", "rel_res_k", ":", "\n", "            ", "x_best", "=", "x", ".", "clone", "(", ")", "\n", "best_rel_residual", "=", "rel_res_k", ".", "clone", "(", ")", "\n", "", "prev_delta", "=", "delta", ".", "clone", "(", ")", "\n", "delta", "=", "torch", ".", "mm", "(", "r", ".", "transpose", "(", "0", ",", "1", ")", ",", "r", ")", "\n", "p", "=", "r", "+", "(", "delta", "/", "prev_delta", ")", "*", "p", "\n", "iteration", "+=", "1", "\n", "\n", "", "x", "=", "x_best", "\n", "rel_res", "=", "best_rel_residual", "\n", "\n", "return", "x", ",", "rel_res", ",", "iteration", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.cg.main": [[53, 68], ["torch.manual_seed", "torch.device", "torch.randn", "torch.mm", "torch.randn", "cg.CG", "torch.mm.transpose", "torch.mm", "print", "print", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.cg.CG"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Run an example of CG.\"\"\"", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "n", "=", "1000", "\n", "A", "=", "torch", ".", "randn", "(", "n", ",", "n", ",", "device", "=", "device", ")", "\n", "A", "=", "torch", ".", "mm", "(", "A", ".", "transpose", "(", "0", ",", "1", ")", ",", "A", ")", "\n", "H", "=", "lambda", "x", ":", "torch", ".", "mm", "(", "A", ",", "x", ")", "\n", "b", "=", "torch", ".", "randn", "(", "n", ",", "device", "=", "device", ")", "\n", "result", "=", "CG", "(", "H", ",", "b", ",", "device", ",", "maxit", "=", "1000", ")", "\n", "if", "result", "is", "None", ":", "\n", "        ", "print", "(", "\"CG failed\"", ")", "\n", "", "else", ":", "\n", "        ", "x", ",", "rel_res", ",", "iteration", "=", "result", "\n", "print", "(", "rel_res", ",", "iteration", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.LSMR": [[5, 190], ["b.reshape.reshape", "copy.deepcopy", "torch.norm", "torch.zeros", "copy.deepcopy", "torch.zeros", "torch.zeros", "A_transpose", "torch.norm", "torch.is_tensor", "torch.sqrt", "torch.sqrt", "torch.norm", "lsmr.symOrtho", "lsmr.symOrtho", "lsmr.symOrtho", "lsmr.symOrtho", "torch.sqrt", "abs", "torch.norm", "torch.tensor", "A", "torch.norm", "torch.is_tensor", "torch.sqrt", "torch.sqrt", "float", "A_transpose", "torch.tensor", "float"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.symOrtho", "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.symOrtho", "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.symOrtho", "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.symOrtho"], ["def", "LSMR", "(", "A", ",", "A_transpose", ",", "b", ",", "dimension", ",", "device", ",", "myRtol", "=", "1e-4", ",", "maxit", "=", "100", ",", "\n", "damp", "=", "0.0", ",", "atol", "=", "0.0", ",", "btol", "=", "0.0", ",", "conlim", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"Compute an approximate least-squares solution to A*x=b using LSMR.\n    \n    Arguments:\n        A (function): Matrix-vector product function.\n        A_transpose (function): Matrix_transpose-vector product function.\n        b (torch.Tensor): A vector.\n        dimension (int): Dimension of solution vector.\n        device (torch.device): The device tensors will be allocated to.\n        myRtol (float, optional): The relative residual tolerance.\n        maxit (int, optional): The maximum number of iterations.\n    \"\"\"", "\n", "b", "=", "b", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "# Initialize the Golub-Kahan bidiagonalization process.", "\n", "\n", "Mu", "=", "deepcopy", "(", "b", ")", "\n", "u", "=", "Mu", "\n", "beta", "=", "torch", ".", "norm", "(", "u", ")", "\n", "\n", "v", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "device", ")", "\n", "alpha", "=", "0", "\n", "\n", "if", "beta", ">", "0", ":", "\n", "        ", "u", "/=", "beta", "\n", "Nv", "=", "A_transpose", "(", "u", ")", "\n", "v", "=", "Nv", "\n", "alpha", "=", "torch", ".", "norm", "(", "v", ")", "\n", "\n", "", "if", "alpha", ">", "0", ":", "\n", "        ", "v", "/=", "alpha", "\n", "\n", "# Initialize variables for 1st iteration.", "\n", "\n", "", "itn", "=", "0", "\n", "zetabar", "=", "alpha", "*", "beta", "\n", "alphabar", "=", "alpha", "\n", "rho", "=", "1", "\n", "rhobar", "=", "1", "\n", "cbar", "=", "1", "\n", "sbar", "=", "0", "\n", "\n", "h", "=", "deepcopy", "(", "v", ")", "\n", "hbar", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "device", ")", "\n", "x", "=", "torch", ".", "zeros", "(", "dimension", ",", "1", ",", "device", "=", "device", ")", "\n", "\n", "# Initialize variables for estimation of ||r||.", "\n", "\n", "betadd", "=", "beta", "\n", "betad", "=", "0", "\n", "rhodold", "=", "1", "\n", "tautildeold", "=", "0", "\n", "thetatilde", "=", "0", "\n", "zeta", "=", "0", "\n", "d", "=", "0", "\n", "\n", "# Initialize variables for estimation of ||A|| and cond(A)", "\n", "\n", "normA2", "=", "alpha", "*", "alpha", "\n", "if", "torch", ".", "is_tensor", "(", "normA2", ")", "==", "False", ":", "\n", "        ", "normA", "=", "torch", ".", "sqrt", "(", "torch", ".", "tensor", "(", "float", "(", "normA2", ")", ",", "device", "=", "device", ")", ")", "\n", "", "else", ":", "\n", "        ", "normA", "=", "torch", ".", "sqrt", "(", "normA2", ")", "\n", "", "condA", "=", "1", "\n", "normx", "=", "0", "\n", "\n", "# Items for use in stopping rules.", "\n", "normb", "=", "beta", "\n", "istop", "=", "0", "\n", "normr", "=", "beta", "\n", "\n", "# Reverse the order here from the original matlab code because", "\n", "# there was an error on return when arnorm==0", "\n", "normar", "=", "alpha", "*", "beta", "\n", "if", "normar", "==", "0", ":", "\n", "        ", "return", "x", ",", "istop", ",", "itn", ",", "normr", ",", "normar", ",", "normA", ",", "condA", ",", "normx", "\n", "\n", "# Main iteration loop.", "\n", "", "while", "itn", "<", "maxit", ":", "\n", "        ", "itn", "+=", "1", "\n", "Mu", "=", "A", "(", "v", ")", "-", "alpha", "*", "Mu", "\n", "u", "=", "Mu", "\n", "beta", "=", "torch", ".", "norm", "(", "u", ")", "# norm(u)", "\n", "\n", "if", "beta", ">", "0", ":", "\n", "            ", "u", "/=", "beta", "\n", "Nv", "=", "A_transpose", "(", "u", ")", "-", "beta", "*", "Nv", "\n", "v", "=", "Nv", "\n", "\n", "alpha", "=", "torch", ".", "norm", "(", "v", ")", "# norm(v)", "\n", "\n", "if", "alpha", ">", "0", ":", "\n", "                ", "v", "/=", "alpha", "\n", "\n", "# At this point, beta = beta_{k+1}, alpha = alpha_{k+1}.", "\n", "\n", "# Construct rotation Qhat_{k,2k+1}.", "\n", "\n", "", "", "chat", ",", "shat", ",", "alphahat", "=", "symOrtho", "(", "alphabar", ",", "damp", ",", "device", ")", "\n", "\n", "# Use a plane rotation (Q_i) to turn B_i to R_i", "\n", "\n", "rhoold", "=", "rho", "\n", "c", ",", "s", ",", "rho", "=", "symOrtho", "(", "alphahat", ",", "beta", ",", "device", ")", "\n", "thetanew", "=", "s", "*", "alpha", "\n", "alphabar", "=", "c", "*", "alpha", "\n", "\n", "# Use a plane rotation (Qbar_i) to turn R_i^T to R_i^bar", "\n", "\n", "rhobarold", "=", "rhobar", "\n", "zetaold", "=", "zeta", "\n", "thetabar", "=", "sbar", "*", "rho", "\n", "cbar", ",", "sbar", ",", "rhobar", "=", "symOrtho", "(", "cbar", "*", "rho", ",", "thetanew", ",", "device", ")", "\n", "zeta", "=", "cbar", "*", "zetabar", "\n", "zetabar", "=", "-", "sbar", "*", "zetabar", "\n", "\n", "# Update h, h_hat, x.", "\n", "\n", "hbar", "=", "h", "-", "(", "thetabar", "*", "rho", "/", "(", "rhoold", "*", "rhobarold", ")", ")", "*", "hbar", "\n", "x", "=", "x", "+", "(", "zeta", "/", "(", "rho", "*", "rhobar", ")", ")", "*", "hbar", "\n", "h", "=", "v", "-", "(", "thetanew", "/", "rho", ")", "*", "h", "\n", "\n", "# Estimate of ||r||.", "\n", "\n", "# Apply rotation Qhat_{k,2k+1}.", "\n", "betaacute", "=", "chat", "*", "betadd", "\n", "betacheck", "=", "-", "shat", "*", "betadd", "\n", "\n", "# Apply rotation Q_{k,k+1}.", "\n", "betahat", "=", "c", "*", "betaacute", "\n", "betadd", "=", "-", "s", "*", "betaacute", "\n", "\n", "# Apply rotation Qtilde_{k-1}.", "\n", "# betad = betad_{k-1} here.", "\n", "\n", "thetatildeold", "=", "thetatilde", "\n", "ctildeold", ",", "stildeold", ",", "rhotildeold", "=", "symOrtho", "(", "rhodold", ",", "thetabar", ",", "device", ")", "\n", "thetatilde", "=", "stildeold", "*", "rhobar", "\n", "rhodold", "=", "ctildeold", "*", "rhobar", "\n", "betad", "=", "-", "stildeold", "*", "betad", "+", "ctildeold", "*", "betahat", "\n", "\n", "# betad   = betad_k here.", "\n", "# rhodold = rhod_k  here.", "\n", "\n", "tautildeold", "=", "(", "zetaold", "-", "thetatildeold", "*", "tautildeold", ")", "/", "rhotildeold", "\n", "taud", "=", "(", "zeta", "-", "thetatilde", "*", "tautildeold", ")", "/", "rhodold", "\n", "d", "=", "d", "+", "betacheck", "*", "betacheck", "\n", "if", "torch", ".", "is_tensor", "(", "d", "+", "(", "betad", "-", "taud", ")", "**", "2", "+", "betadd", "*", "betadd", ")", "==", "False", ":", "\n", "            ", "normr", "=", "torch", ".", "sqrt", "(", "torch", ".", "tensor", "(", "\n", "float", "(", "d", "+", "(", "betad", "-", "taud", ")", "**", "2", "+", "betadd", "*", "betadd", ")", ",", "device", "=", "device", ")", ")", "\n", "", "else", ":", "\n", "            ", "normr", "=", "torch", ".", "sqrt", "(", "d", "+", "(", "betad", "-", "taud", ")", "**", "2", "+", "betadd", "*", "betadd", ")", "\n", "\n", "# Estimate ||A||.", "\n", "", "normA2", "=", "normA2", "+", "beta", "*", "beta", "\n", "normA", "=", "torch", ".", "sqrt", "(", "normA2", ")", "\n", "normA2", "=", "normA2", "+", "alpha", "*", "alpha", "\n", "\n", "# Test for convergence.", "\n", "\n", "# Compute norms for convergence testing.", "\n", "normar", "=", "abs", "(", "zetabar", ")", "\n", "normx", "=", "torch", ".", "norm", "(", "x", ")", "\n", "\n", "# Now use these norms to estimate certain other quantities,", "\n", "# some of which will be small near a solution.", "\n", "\n", "test1", "=", "normr", "/", "normb", "\n", "if", "test1", "<=", "myRtol", ":", "\n", "            ", "break", "\n", "", "test2", "=", "normar", "/", "(", "normA", "*", "normr", ")", "\n", "t1", "=", "test1", "/", "(", "1", "+", "normA", "*", "normx", "/", "normb", ")", "\n", "rtol", "=", "btol", "+", "atol", "*", "normA", "*", "normx", "/", "normb", "\n", "\n", "if", "itn", ">=", "maxit", ":", "istop", "=", "7", "\n", "if", "1", "+", "test2", "<=", "1", ":", "istop", "=", "5", "\n", "if", "1", "+", "t1", "<=", "1", ":", "istop", "=", "4", "\n", "if", "test2", "<=", "atol", ":", "istop", "=", "2", "\n", "if", "test1", "<=", "rtol", ":", "istop", "=", "1", "\n", "\n", "if", "istop", ">", "0", ":", "\n", "            ", "break", "\n", "\n", "", "", "return", "x", ",", "test1", ",", "itn", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.symOrtho": [[192, 219], ["torch.is_tensor", "torch.tensor", "torch.is_tensor", "torch.tensor", "float", "float", "torch.sign", "torch.abs", "torch.sign", "torch.abs", "torch.abs", "torch.abs", "torch.sign", "torch.sqrt", "torch.sign", "torch.sqrt"], "function", ["None"], ["", "def", "symOrtho", "(", "a", ",", "b", ",", "device", ")", ":", "\n", "    ", "\"\"\"This is used by the function LSMR.\n    \n    Arguments:\n        a (float): A number.\n        b (float): A number.\n        device (torch.device): The device tensors will be allocated to.\n    \"\"\"", "\n", "if", "torch", ".", "is_tensor", "(", "a", ")", "==", "False", ":", "\n", "        ", "a", "=", "torch", ".", "tensor", "(", "float", "(", "a", ")", ",", "device", "=", "device", ")", "\n", "", "if", "torch", ".", "is_tensor", "(", "b", ")", "==", "False", ":", "\n", "        ", "b", "=", "torch", ".", "tensor", "(", "float", "(", "b", ")", ",", "device", "=", "device", ")", "\n", "", "if", "b", "==", "0", ":", "\n", "        ", "return", "torch", ".", "sign", "(", "a", ")", ",", "0", ",", "torch", ".", "abs", "(", "a", ")", "\n", "", "elif", "a", "==", "0", ":", "\n", "        ", "return", "0", ",", "torch", ".", "sign", "(", "b", ")", ",", "torch", ".", "abs", "(", "b", ")", "\n", "", "elif", "torch", ".", "abs", "(", "b", ")", ">", "torch", ".", "abs", "(", "a", ")", ":", "\n", "        ", "tau", "=", "a", "/", "b", "\n", "s", "=", "torch", ".", "sign", "(", "b", ")", "/", "torch", ".", "sqrt", "(", "1", "+", "tau", "*", "tau", ")", "\n", "c", "=", "s", "*", "tau", "\n", "r", "=", "b", "/", "s", "\n", "", "else", ":", "\n", "        ", "tau", "=", "b", "/", "a", "\n", "c", "=", "torch", ".", "sign", "(", "a", ")", "/", "torch", ".", "sqrt", "(", "1", "+", "tau", "*", "tau", ")", "\n", "s", "=", "c", "*", "tau", "\n", "r", "=", "a", "/", "c", "\n", "", "return", "c", ",", "s", ",", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.main": [[221, 233], ["torch.manual_seed", "torch.device", "torch.randn", "torch.randn.transpose", "torch.randn", "lsmr.LSMR", "print", "torch.mm", "torch.mm", "torch.cuda.is_available"], "function", ["home.repos.pwc.inspect_result.RixonC_DINGO.None.lsmr.LSMR"], ["", "def", "main", "(", ")", ":", "\n", "    ", "\"\"\"Run an example of LSMR.\"\"\"", "\n", "torch", ".", "manual_seed", "(", "0", ")", "\n", "device", "=", "torch", ".", "device", "(", "\"cuda:0\"", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "\"cpu\"", ")", "\n", "n", "=", "1000", "\n", "A", "=", "torch", ".", "randn", "(", "2", "*", "n", ",", "n", ",", "device", "=", "device", ")", "\n", "A_T", "=", "A", ".", "transpose", "(", "0", ",", "1", ")", "\n", "H", "=", "lambda", "x", ":", "torch", ".", "mm", "(", "A", ",", "x", ")", "\n", "H_T", "=", "lambda", "x", ":", "torch", ".", "mm", "(", "A_T", ",", "x", ")", "\n", "b", "=", "torch", ".", "randn", "(", "2", "*", "n", ",", "device", "=", "device", ")", "\n", "x", ",", "test1", ",", "itn", "=", "LSMR", "(", "H", ",", "H_T", ",", "b", ",", "n", ",", "device", ",", "maxit", "=", "10", ")", "\n", "print", "(", "test1", ",", "itn", ")", "\n", "\n"]]}