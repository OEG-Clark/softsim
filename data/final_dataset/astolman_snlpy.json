{"home.repos.pwc.inspect_result.astolman_snlpy.scripts.structural-preprocess.ppr_prepocess": [[7, 11], ["scipy.sparse.vstack", "range", "snlpy.ppr.ppr"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.ppr.ppr"], ["def", "ppr_prepocess", "(", "adj", ",", "alpha", "=", "0.8", ",", "tol", "=", "0.00001", ",", "workers", "=", "20", ",", "seeds", "=", "None", ")", ":", "\n", "    ", "if", "seeds", "is", "None", ":", "\n", "        ", "seeds", "=", "range", "(", "adj", ".", "shape", "[", "0", "]", ")", "\n", "", "return", "sparse", ".", "vstack", "(", "[", "ppr", "(", "adj", ",", "[", "seed", "]", ",", "alpha", ",", "tol", ")", "for", "seed", "in", "seeds", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.scripts.link-prediction.sample_rows": [[28, 38], ["numpy.random.randint", "numpy.vstack", "graph.number_of_nodes", "numpy.array", "graph.nodes"], "function", ["None"], ["def", "sample_rows", "(", "graph", ",", "num_rows", ")", ":", "\n", "    ", "\"\"\"\n    Provide coordinates for all entries in num_rows number of random rows\n\n    :param graph: CsrGraph to choose rows from.\n    :param num_rows: Number of rows to sample.\n    \"\"\"", "\n", "rows", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "high", "=", "graph", ".", "number_of_nodes", "(", ")", ",", "size", "=", "num_rows", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "pairs", "=", "np", ".", "vstack", "(", "[", "np", ".", "array", "(", "[", "u", ",", "v", "]", ")", "for", "u", "in", "graph", ".", "nodes", "(", ")", "for", "v", "in", "rows", "]", ")", "\n", "return", "pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.scripts.link-prediction.histofy": [[39, 49], ["numpy.zeros", "range", "print", "len", "int", "numpy.floor"], "function", ["None"], ["", "def", "histofy", "(", "ps", ",", "num_bins", "=", "1000", ")", ":", "\n", "    ", "bins", "=", "np", ".", "zeros", "(", "num_bins", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "p", "in", "ps", ":", "\n", "        ", "bins", "[", "int", "(", "np", ".", "floor", "(", "p", "*", "(", "num_bins", "-", "1", ")", ")", ")", "]", "+=", "1", "\n", "", "accumulator", "=", "0", "\n", "for", "i", "in", "range", "(", "num_bins", ")", ":", "\n", "        ", "accumulator", "+=", "bins", "[", "-", "(", "i", "+", "1", ")", "]", "\n", "bins", "[", "-", "(", "i", "+", "1", ")", "]", "=", "accumulator", "/", "len", "(", "ps", ")", "\n", "", "print", "(", "bins", ")", "\n", "return", "bins", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.ppr.ppr": [[14, 48], ["numpy.zeros", "numpy.zeros", "collections.deque", "collections.deque.extend", "scipy.sparse.csr_matrix", "len", "len", "collections.deque.popleft", "ppr.push", "collections.deque.extend", "numpy.copy", "numpy.where", "numpy.sum", "adj[].todense"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.ppr.push"], ["def", "ppr", "(", "adj", ",", "seed", ",", "alpha", "=", "0.85", ",", "tol", "=", "0.0001", ")", ":", "\n", "    ", "\"\"\"\n    Compute approximate ppr vector for the given seed on the graph\n\n    note: this is stolen from dgleich's github page originally\n\n    PARAMETERS\n    ----------\n    G : CsrGraph\n        The graph on which to perform PPR\n    seed : Iterable of ints\n        node ids for seeds for PPR walk to teleport to\n    alpha : float\n        teleportation parameter for PPR\n    tol : float\n        resolution parameter for PPR, maximum nnz size of result is\n        1/tol\n\n    RETURNS\n    -------\n    scipy.sparse.csr_matrix representation of approximate PPR vector\n    \"\"\"", "\n", "p", "=", "np", ".", "zeros", "(", "adj", ".", "shape", "[", "0", "]", ")", "\n", "r", "=", "np", ".", "zeros", "(", "adj", ".", "shape", "[", "0", "]", ")", "\n", "Q", "=", "collections", ".", "deque", "(", ")", "# initialize queue", "\n", "r", "[", "seed", "]", "=", "1", "/", "len", "(", "seed", ")", "\n", "Q", ".", "extend", "(", "s", "for", "s", "in", "seed", ")", "\n", "while", "len", "(", "Q", ")", ">", "0", ":", "\n", "        ", "v", "=", "Q", ".", "popleft", "(", ")", "# v has r[v] > tol*deg(v)", "\n", "p", ",", "r_prime", "=", "push", "(", "v", ",", "np", ".", "copy", "(", "r", ")", ",", "p", ",", "adj", ".", "indptr", ",", "adj", ".", "indices", ",", "alpha", ")", "\n", "new_verts", "=", "np", ".", "where", "(", "r_prime", "-", "r", ">", "0", ")", "[", "0", "]", "\n", "r", "=", "r_prime", "\n", "Q", ".", "extend", "(", "u", "for", "u", "in", "new_verts", "if", "r", "[", "u", "]", "/", "np", ".", "sum", "(", "adj", "[", "u", "]", ".", "todense", "(", ")", ")", ">", "tol", ")", "\n", "", "return", "sparse", ".", "csr_matrix", "(", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.ppr.push": [[50, 58], ["numba.njit"], "function", ["None"], ["", "@", "njit", "(", ")", "\n", "def", "push", "(", "u", ",", "r", ",", "p", ",", "adj_ptrs", ",", "adj_cols", ",", "alpha", ")", ":", "\n", "    ", "r_u", "=", "r", "[", "u", "]", "\n", "p", "[", "u", "]", "+=", "alpha", "*", "r_u", "\n", "r", "[", "u", "]", "=", "(", "1", "-", "alpha", ")", "*", "r_u", "/", "2", "\n", "r", "[", "adj_cols", "[", "adj_ptrs", "[", "u", "]", ":", "adj_ptrs", "[", "u", "+", "1", "]", "]", "\n", "]", "+=", "(", "1", "-", "alpha", ")", "*", "r_u", "/", "(", "2", "*", "(", "adj_ptrs", "[", "u", "+", "1", "]", "-", "adj_ptrs", "[", "u", "]", ")", ")", "\n", "return", "p", ",", "r", "\n", "", ""]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural.structural_feats": [[7, 13], ["numpy.vstack", "len", "range", "int", "structural._batch_features", "int", "len", "len", "int", "len"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._batch_features"], ["def", "structural_feats", "(", "pairs", ",", "adj", ",", "ppr", ",", "chunksize", "=", "10000", ")", ":", "\n", "    ", "chunked_pairs", "=", "[", "pairs", "[", "i", "*", "chunksize", ":", "(", "i", "+", "1", ")", "*", "chunksize", "]", "\n", "for", "i", "in", "range", "(", "int", "(", "len", "(", "pairs", ")", "/", "chunksize", ")", ")", "]", "\n", "if", "int", "(", "len", "(", "pairs", ")", "/", "chunksize", ")", "*", "chunksize", "!=", "len", "(", "pairs", ")", ":", "\n", "        ", "chunked_pairs", "+=", "[", "pairs", "[", "int", "(", "len", "(", "pairs", ")", "/", "chunksize", ")", "*", "chunksize", ":", "]", "]", "\n", "", "return", "np", ".", "vstack", "(", "[", "_batch_features", "(", "batch", ",", "adj", ",", "ppr", ")", "for", "batch", "in", "chunked_pairs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._batch_features": [[14, 22], ["structural.cosine_sim", "structural.compute_three_paths", "numpy.array", "numpy.hstack", "len", "list", "map"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural.cosine_sim", "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural.compute_three_paths"], ["", "def", "_batch_features", "(", "batch", ",", "adj", ",", "ppr", ")", ":", "\n", "    ", "if", "len", "(", "batch", ")", "==", "0", ":", "\n", "        ", "return", "\n", "", "cosines", "=", "cosine_sim", "(", "batch", ",", "adj", ")", "\n", "connectivities", "=", "compute_three_paths", "(", "batch", ",", "adj", ")", "\n", "pprs", "=", "np", ".", "array", "(", "list", "(", "map", "(", "\n", "lambda", "x", ":", "[", "ppr", "[", "x", "[", "0", "]", ",", "x", "[", "1", "]", "]", ",", "ppr", "[", "x", "[", "1", "]", ",", "x", "[", "0", "]", "]", "]", ",", "batch", ")", ")", ")", "\n", "return", "np", ".", "hstack", "(", "(", "cosines", ",", "connectivities", ",", "pprs", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural.compute_three_paths": [[23, 46], ["numpy.zeros", "adj[].todense", "structural._compute_three_paths_aggregate", "len"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._compute_three_paths_aggregate"], ["", "def", "compute_three_paths", "(", "pairs", ",", "adj", ")", ":", "\n", "    ", "\"\"\"\n    Computes number of paths of legth 3 between vertices in pairs.\n\n    PARAMETERS\n    ----------\n    pairs : np.ndarray(dtype=np.int32, shape=(k, 2))\n        array of pairs\n    graph : CsrGraph\n        graph to use\n\n    RETURNS\n    -------\n    np.ndarray(dtype=np.int32, shape=(k,1))\n        array of number of paths of length 3\n    \"\"\"", "\n", "row_ptrs", "=", "adj", ".", "indptr", "\n", "col_indxs", "=", "adj", ".", "indices", "\n", "connectivities", "=", "np", ".", "zeros", "(", "(", "len", "(", "pairs", ")", ",", "1", ")", ")", "\n", "u_neighb", "=", "adj", "[", "pairs", "[", ":", ",", "1", "]", "]", ".", "todense", "(", ")", "\n", "return", "_compute_three_paths_aggregate", "(", "connectivities", ",", "pairs", "[", ":", ",", "0", "]", ",", "\n", "row_ptrs", ",", "col_indxs", ",", "\n", "u_neighb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._compute_three_paths_aggregate": [[47, 56], ["numba.njit", "numba.prange", "len"], "function", ["None"], ["", "@", "njit", "(", "parallel", "=", "True", ")", "\n", "def", "_compute_three_paths_aggregate", "(", "feature_vec", ",", "vs", ",", "row_ptrs", ",", "col_indxs", ",", "u_neighb", ")", ":", "\n", "    ", "for", "i", "in", "prange", "(", "len", "(", "vs", ")", ")", ":", "\n", "        ", "v", "=", "vs", "[", "i", "]", "\n", "for", "k", "in", "col_indxs", "[", "row_ptrs", "[", "v", "]", ":", "row_ptrs", "[", "v", "+", "1", "]", "]", ":", "\n", "            ", "for", "l", "in", "col_indxs", "[", "row_ptrs", "[", "k", "]", ":", "row_ptrs", "[", "k", "+", "1", "]", "]", ":", "\n", "                ", "if", "u_neighb", "[", "i", ",", "l", "]", ":", "\n", "                    ", "feature_vec", "[", "i", "]", "+=", "1", "\n", "", "", "", "", "return", "feature_vec", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural.cosine_sim": [[57, 83], ["numpy.zeros", "_cosines().reshape", "len", "structural._cosines"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._cosines"], ["", "def", "cosine_sim", "(", "pairs", ",", "m", ")", ":", "\n", "    ", "\"\"\"\n    Computes cosine similarities between all pairs of\n    vertices in pairs.\n\n    PARAMETERS\n    ----------\n    pairs : np.ndarray(dtype=np.int32, shape=(k, 2))\n        array of pairs to compute cosine similarities for\n    m : scipy.sparse.csr_matrix\n        csr_matrix representation of graph to use to\n        compute cosine similarities\n\n    RETURNS\n    -------\n    np.ndarray(dtype=np.float32, shape=(k,1))\n        array of cosine similarities\n    \"\"\"", "\n", "left_adj_vectors", "=", "m", "[", "pairs", "[", ":", ",", "0", "]", "]", "\n", "right_adj_vectors", "=", "m", "[", "pairs", "[", ":", ",", "1", "]", "]", "\n", "lav_ptr", "=", "left_adj_vectors", ".", "indptr", "\n", "lav_col", "=", "left_adj_vectors", ".", "indices", "\n", "rav_ptr", "=", "right_adj_vectors", ".", "indptr", "\n", "rav_col", "=", "right_adj_vectors", ".", "indices", "\n", "cosines", "=", "np", ".", "zeros", "(", "len", "(", "rav_ptr", ")", "-", "1", ")", "\n", "return", "_cosines", "(", "lav_ptr", ",", "lav_col", ",", "rav_ptr", ",", "rav_col", ",", "cosines", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._cosines": [[84, 90], ["numba.njit", "numba.prange", "len", "structural._cosine_sim_pair"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._cosine_sim_pair"], ["", "@", "njit", "(", "parallel", "=", "True", ")", "\n", "def", "_cosines", "(", "lav_ptr", ",", "lav_col", ",", "rav_ptr", ",", "rav_col", ",", "cosines", ")", ":", "\n", "    ", "for", "i", "in", "prange", "(", "len", "(", "cosines", ")", ")", ":", "\n", "        ", "cosines", "[", "i", "]", "=", "_cosine_sim_pair", "(", "lav_col", "[", "lav_ptr", "[", "i", "]", ":", "lav_ptr", "[", "i", "+", "1", "]", "]", ",", "\n", "rav_col", "[", "rav_ptr", "[", "i", "]", ":", "rav_ptr", "[", "i", "+", "1", "]", "]", ")", "\n", "", "return", "cosines", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.snlpy.structural._cosine_sim_pair": [[91, 109], ["numba.njit", "numpy.sqrt", "len", "len", "len", "len", "len", "len"], "function", ["None"], ["", "@", "njit", "(", ")", "\n", "def", "_cosine_sim_pair", "(", "left_ind", ",", "right_ind", ")", ":", "\n", "    ", "if", "len", "(", "left_ind", ")", "==", "0", "or", "len", "(", "right_ind", ")", "==", "0", ":", "\n", "        ", "return", "0.0", "\n", "", "factor", "=", "1", "/", "np", ".", "sqrt", "(", "len", "(", "left_ind", ")", "*", "len", "(", "right_ind", ")", ")", "\n", "cosine", "=", "0", "\n", "i", "=", "0", "\n", "j", "=", "0", "\n", "while", "i", "<", "len", "(", "left_ind", ")", "and", "j", "<", "len", "(", "right_ind", ")", ":", "\n", "        ", "if", "left_ind", "[", "i", "]", "==", "right_ind", "[", "j", "]", ":", "\n", "            ", "cosine", "+=", "1", "\n", "i", "+=", "1", "\n", "j", "+=", "1", "\n", "", "elif", "left_ind", "[", "i", "]", "<", "right_ind", "[", "j", "]", ":", "\n", "            ", "i", "+=", "1", "\n", "", "else", ":", "\n", "            ", "j", "+=", "1", "\n", "", "", "return", "factor", "*", "cosine", "\n", "", ""]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf.NetMF": [[10, 33], ["netmf._create_target_matrix", "netmf._create_embedding"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_target_matrix", "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_embedding"], ["def", "NetMF", "(", "graph", ",", "dimensions", "=", "128", ",", "iterations", "=", "10", ",", "order", "=", "2", ",", "negative_samples", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Fits a NetMF embedding to the given graph.\n\n    PARAMETERS\n    ----------\n    graph : CsrGraph\n        Graph to which to fit an embedding\n    dimensions : int, optional\n        Number of dimensions for embedding, default is 128\n    iterations : int, optional\n        Number of iterations to run NetMF\n    order : int, optional\n        Power of matrix to go up to for NetMF\n    negative_samples : int, optional\n        Parameter for NetMF\n\n    RETURNS\n    -------\n    np.ndarray(shape=(graph.shape[0], d), dtype=np.float32)\n    \"\"\"", "\n", "target_matrix", "=", "_create_target_matrix", "(", "graph", ",", "order", ",", "negative_samples", ")", "\n", "return", "_create_embedding", "(", "target_matrix", ",", "dimensions", ",", "iterations", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_D_inverse": [[34, 49], ["numpy.arange", "numpy.array", "scipy.sparse.csr_matrix", "numpy.sum", "range"], "function", ["None"], ["", "def", "_create_D_inverse", "(", "graph", ")", ":", "\n", "    ", "\"\"\"\n    Creating a sparse inverse degree matrix.\n\n    Arg types:\n        * **graph** *(NetworkX graph)* - The graph to be embedded.\n\n    Return types:\n        * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix.\n    \"\"\"", "\n", "index", "=", "np", ".", "arange", "(", "graph", ".", "shape", "[", "0", "]", ")", "\n", "values", "=", "np", ".", "array", "(", "[", "1.0", "/", "np", ".", "sum", "(", "graph", "[", "node", "]", ")", "for", "node", "in", "range", "(", "graph", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "shape", "=", "(", "graph", ".", "shape", "[", "0", "]", ",", "graph", ".", "shape", "[", "0", "]", ")", "\n", "D_inverse", "=", "sparse", ".", "csr_matrix", "(", "(", "values", ",", "(", "index", ",", "index", ")", ")", ",", "shape", "=", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "return", "D_inverse", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_base_matrix": [[50, 64], ["netmf._create_D_inverse", "_create_D_inverse.dot"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_D_inverse"], ["", "def", "_create_base_matrix", "(", "A", ")", ":", "\n", "    ", "\"\"\"\n    Creating the normalized adjacency matrix.\n\n    Arg types:\n        * **graph** *(NetworkX graph)* - The graph to be embedded.\n\n    Return types:\n        * **(A_hat, A_hat, A_hat, D_inverse)** *(SciPy arrays)* - Normalized adjacency matrices.\n    \"\"\"", "\n", "#A = graph.to_csr_matrix()", "\n", "D_inverse", "=", "_create_D_inverse", "(", "A", ")", "\n", "A_hat", "=", "D_inverse", ".", "dot", "(", "A", ")", "\n", "return", "(", "A_hat", ",", "A_hat", ",", "A_hat", ",", "D_inverse", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_target_matrix": [[65, 87], ["netmf._create_base_matrix", "range", "A_pool.dot.dot", "scipy.sparse.csr_matrix", "A_tilde.dot.dot", "numpy.log"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_base_matrix"], ["", "def", "_create_target_matrix", "(", "graph", ",", "order", ",", "negative_samples", ")", ":", "\n", "    ", "\"\"\"\n    Creating a log transformed target matrix.\n\n    Arg types:\n        * **graph** *(NetworkX graph)* - The graph to be embedded.\n\n    Return types:\n        * **target_matrix** *(SciPy array)* - The shifted PMI matrix.\n    \"\"\"", "\n", "A_pool", ",", "A_tilde", ",", "A_hat", ",", "D_inverse", "=", "_create_base_matrix", "(", "graph", ")", "\n", "for", "_", "in", "range", "(", "order", "-", "1", ")", ":", "\n", "        ", "A_tilde", "=", "A_tilde", ".", "dot", "(", "A_hat", ")", "\n", "A_pool", "=", "A_pool", "+", "A_tilde", "\n", "", "del", "A_hat", ",", "A_tilde", "\n", "A_pool", ".", "data", "=", "(", "graph", ".", "nnz", "/", "2", "*", "A_pool", ".", "data", ")", "/", "(", "order", "*", "negative_samples", ")", "\n", "A_pool", "=", "A_pool", ".", "dot", "(", "D_inverse", ")", "\n", "A_pool", ".", "data", "[", "A_pool", ".", "data", "<", "1.0", "]", "=", "1.0", "\n", "target_matrix", "=", "sparse", ".", "csr_matrix", "(", "(", "np", ".", "log", "(", "A_pool", ".", "data", ")", ",", "A_pool", ".", "indices", ",", "A_pool", ".", "indptr", ")", ",", "\n", "shape", "=", "A_pool", ".", "shape", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "return", "target_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.netmf._create_embedding": [[88, 97], ["sklearn.decomposition.TruncatedSVD", "sklearn.decomposition.TruncatedSVD.fit", "sklearn.decomposition.TruncatedSVD.transform"], "function", ["None"], ["", "def", "_create_embedding", "(", "target_matrix", ",", "dimensions", ",", "iterations", ")", ":", "\n", "    ", "\"\"\"\n    Fitting a truncated SVD embedding of a PMI matrix.\n    \"\"\"", "\n", "svd", "=", "TruncatedSVD", "(", "n_components", "=", "dimensions", ",", "\n", "n_iter", "=", "iterations", ")", "\n", "svd", ".", "fit", "(", "target_matrix", ")", "\n", "embedding", "=", "svd", ".", "transform", "(", "target_matrix", ")", "\n", "return", "embedding", "\n", "", ""]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk._WalkContainer.__init__": [[115, 118], ["numpy.zeros"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "height", ",", "width", ")", ":", "\n", "        ", "\"\"\"height, width: ints for size of walk container\"\"\"", "\n", "self", ".", "walks", "=", "np", ".", "zeros", "(", "(", "height", ",", "width", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk._WalkContainer.__iter__": [[119, 122], ["str"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "walk", "in", "self", ".", "walks", ":", "\n", "            ", "yield", "[", "str", "(", "x", ")", "for", "x", "in", "walk", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.DeepWalk": [[10, 53], ["deepwalk._do_walks", "gensim.models.word2vec.Word2Vec", "numpy.zeros", "range", "str"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_walks"], ["def", "DeepWalk", "(", "adj", ",", "walk_number", "=", "10", ",", "walk_length", "=", "80", ",", "dimensions", "=", "128", ",", "\n", "workers", "=", "4", ",", "window_size", "=", "5", ",", "epochs", "=", "1", ",", "learning_rate", "=", "0.05", ")", ":", "\n", "    ", "\"\"\"\n    Fit an embedding to graph according to DeepWalk method\n\n    PARAMETERS\n    ----------\n    graph : scipy.sparse.csr_matrix\n        adjacency matrix of graph to which to fit an embedding\n    walk_number : int, optionl\n        number of walks for DeepWalk\n    walk_length : int, optionl\n        length of walks for DeepWalk\n    dimensions : int, optionl\n        number of dimensions for the embedding\n    workers : int, optionl\n        number of workers for the Word2Vec step\n        (random walks use all available cores)\n    window_size : int, optionl\n        window size for Word2Vec\n    epochs : int, optionl\n        number of iterations for Word2Vec\n    learning_rate : float, optionl\n        parameter for Word2Vec\n\n    RETURNS\n    -------\n    np.ndarray(shape=(adj.shape[0], d), dtype=np.float32)\n    \"\"\"", "\n", "walk_container", "=", "_do_walks", "(", "adj", ",", "walk_length", ",", "walk_number", ")", "\n", "model", "=", "Word2Vec", "(", "walk_container", ",", "\n", "hs", "=", "1", ",", "\n", "alpha", "=", "learning_rate", ",", "\n", "iter", "=", "epochs", ",", "\n", "size", "=", "dimensions", ",", "\n", "window", "=", "window_size", ",", "\n", "min_count", "=", "1", ",", "\n", "workers", "=", "workers", ",", "\n", ")", "\n", "emb", "=", "np", ".", "zeros", "(", "(", "adj", ".", "shape", "[", "0", "]", ",", "dimensions", ")", ")", "\n", "for", "i", "in", "range", "(", "adj", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "emb", "[", "i", ",", ":", "]", "=", "model", "[", "str", "(", "i", ")", "]", "\n", "", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.do_step": [[55, 74], ["numba.njit", "numpy.random.choice"], "function", ["None"], ["", "@", "njit", "(", ")", "\n", "def", "do_step", "(", "v", ",", "rows", ",", "indxs", ")", ":", "\n", "    ", "\"\"\"does one step of a walk from v\n\n    PARAMETERS\n    ----------\n    v : int\n        vertex from which to step\n    rows : np.ndarray\n        array containing all rows of adjacency matrix concatenated\n    indxs : np.ndarray\n        array of pointers into rows\n\n    RETURNS\n    _______\n    int\n        next step in random walk\n    \"\"\"", "\n", "return", "random", ".", "choice", "(", "rows", "[", "indxs", "[", "v", "]", ":", "indxs", "[", "v", "+", "1", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.do_walk": [[76, 104], ["numba.njit", "numba.prange", "len", "range", "deepwalk.do_step"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.do_step"], ["", "@", "njit", "(", "parallel", "=", "True", ")", "\n", "def", "do_walk", "(", "rows", ",", "indxs", ",", "num_steps", ",", "endpoints", ",", "walks", ")", ":", "\n", "    ", "\"\"\"\n    does a walk from every vertex given in endpoints\n\n    PARAMETERS\n    ----------\n    rows : np.ndarray\n        array containing column indices of all nonzero coordinates\n        in the adjacency matrix\n    indxs : np.ndarray\n        array of pointers into rows indicating the start of each row\n    num_steps : int\n        length of walk to perform\n    endpoints : np.ndarray\n        array of endpoints from which to start walks\n    walks : np.ndarray\n        empty placeholder array which will be filled with walk transcripts\n\n    RETURNS\n    _______\n    np.ndarray containing walk transcripts\n    \"\"\"", "\n", "walks", "[", ":", ",", "0", "]", "=", "endpoints", "\n", "for", "v", "in", "prange", "(", "len", "(", "endpoints", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "1", ",", "num_steps", ")", ":", "\n", "            ", "walks", "[", "v", ",", "j", "]", "=", "do_step", "(", "walks", "[", "v", ",", "j", "-", "1", "]", ",", "rows", ",", "indxs", ")", "\n", "", "", "return", "walks", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.process_adj": [[106, 110], ["None"], "function", ["None"], ["", "def", "process_adj", "(", "g", ")", ":", "\n", "    ", "rows", "=", "g", ".", "indices", "\n", "indxs", "=", "g", ".", "indptr", "\n", "return", "rows", ",", "indxs", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk._do_walks": [[124, 150], ["deepwalk.process_adj", "deepwalk._WalkContainer", "range", "len", "numpy.arange", "deepwalk.do_walk"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.process_adj", "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.do_walk"], ["", "", "", "def", "_do_walks", "(", "adj", ",", "walk_length", ",", "walk_number", ")", ":", "\n", "    ", "\"\"\"\n    Perform random walks\n\n\n    PARAMETERS\n    ----------\n    adj : scipy.sparse.csr_matrix\n        adjacency matrix of graph to do walks on\n    walk_length : int\n        length of random walks\n    walk_number : int\n        number of random walks per vertex\n\n    RETURNS\n    -------\n    iterator containing walk as lists of strings\n    \"\"\"", "\n", "rows", ",", "indxs", "=", "process_adj", "(", "adj", ")", "\n", "n", "=", "len", "(", "indxs", ")", "-", "1", "\n", "walk_container", "=", "_WalkContainer", "(", "n", "*", "walk_number", ",", "walk_length", ")", "\n", "for", "i", "in", "range", "(", "walk_number", ")", ":", "\n", "        ", "endpoints", "=", "np", ".", "arange", "(", "n", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "do_walk", "(", "rows", ",", "indxs", ",", "walk_length", ",", "endpoints", ",", "\n", "walk_container", ".", "walks", "[", "i", "*", "n", ":", "(", "i", "+", "1", ")", "*", "n", "]", ")", "\n", "", "return", "walk_container", "\n", "", ""]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec.Node2Vec": [[10, 53], ["node2vec._do_walks", "gensim.models.word2vec.Word2Vec", "numpy.zeros", "range", "str"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_walks"], ["def", "Node2Vec", "(", "adj", ",", "walk_number", "=", "10", ",", "walk_length", "=", "80", ",", "dimensions", "=", "128", ",", "\n", "workers", "=", "4", ",", "window_size", "=", "5", ",", "epochs", "=", "1", ",", "learning_rate", "=", "0.05", ",", "p", "=", "0.5", ",", "q", "=", "0.5", ")", ":", "\n", "    ", "\"\"\"\n        PARAMETERS\n        ----------\n        adj : CsrGraph\n            adjacency matrix of graph to which to fit an embedding\n        walk_number : int, optional\n            number of walks for Node2Vec\n        walk_length : int, optional\n            length of walks for Node2Vec\n        dimensions : int, optional\n            number of dimensions for the embedding\n        workers : int, optional\n            number of workers for the Word2Vec step, default is 4.\n        window_size : int, optional\n            window size for Word2Vec, default is 5\n        epochs : int, optonal\n            number of iterations for Word2Vec, default is 1\n        learning_rate=0.05\n            parameter for Word2Vec\n        p : float, optional\n            parameter for Node2Vec walks\n        q : float, optional\n            parameter for Node2Vec walks\n\n        RETURNS\n        -------\n        np.ndarray(shape=(adj.shape[0], dtype=np.float32))\n    \"\"\"", "\n", "walk_container", "=", "_do_walks", "(", "adj", ",", "walk_length", ",", "walk_number", ",", "p", ",", "q", ")", "\n", "model", "=", "Word2Vec", "(", "walk_container", ",", "\n", "hs", "=", "1", ",", "\n", "alpha", "=", "learning_rate", ",", "\n", "iter", "=", "epochs", ",", "\n", "size", "=", "dimensions", ",", "\n", "window", "=", "window_size", ",", "\n", "min_count", "=", "1", ",", "\n", "workers", "=", "workers", ")", "\n", "emb", "=", "np", ".", "zeros", "(", "(", "adj", ".", "shape", "[", "0", "]", ",", "dimensions", ")", ")", "\n", "for", "i", "in", "range", "(", "adj", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "emb", "[", "i", ",", ":", "]", "=", "model", "[", "str", "(", "i", ")", "]", "\n", "", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_step": [[55, 94], ["numba.njit", "numpy.concatenate().astype", "numpy.concatenate().astype", "range", "numpy.sum", "numpy.concatenate", "numpy.concatenate", "node2vec._prob_map", "numpy.random.random_sample"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._prob_map"], ["", "@", "njit", "(", ")", "\n", "def", "_do_step", "(", "t", ",", "v", ",", "p", ",", "q", ",", "t_neighbs", ",", "v_neighbs", ")", ":", "\n", "    ", "\"\"\"\n    Returns next step of Node2Vec walk when t is the previous vertex\n    and v is the current one. Parameters are p and q and t_neighbs\n    and v_neighbs are arrays holding the neighbors of t and v\n    respectively.\n    \"\"\"", "\n", "# first we need to calculate the distribution over possible", "\n", "# next steps", "\n", "index", "=", "0", "\n", "domain", "=", "np", ".", "concatenate", "(", "(", "t_neighbs", ",", "v_neighbs", ")", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "ps", "=", "np", ".", "concatenate", "(", "(", "t_neighbs", ",", "v_neighbs", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "for", "u", "in", "v_neighbs", ":", "\n", "        ", "domain", "[", "index", "]", "=", "u", "\n", "# I would like to check if u in t_neighbs, but numba wont", "\n", "# let me use \"in\" here, have to write our own search", "\n", "# TODO: would binary search be worth implementing here?", "\n", "in_t_flag", "=", "False", "\n", "for", "w", "in", "t_neighbs", ":", "\n", "            ", "if", "u", "==", "w", ":", "\n", "                ", "in_t_flag", "=", "True", "\n", "break", "\n", "", "", "if", "in_t_flag", ":", "\n", "            ", "ps", "[", "index", "]", "=", "1.0", "\n", "", "elif", "u", "==", "t", ":", "\n", "            ", "ps", "[", "index", "]", "=", "1", "/", "p", "\n", "", "else", ":", "\n", "            ", "ps", "[", "index", "]", "=", "1", "/", "q", "\n", "", "index", "+=", "1", "\n", "", "ps", "[", "index", ":", "]", "=", "0", "\n", "# normalize and make ps contain the cdf", "\n", "mass", "=", "0", "\n", "ps", "=", "ps", "/", "np", ".", "sum", "(", "ps", ")", "\n", "for", "i", "in", "range", "(", "index", ")", ":", "\n", "        ", "mass", "+=", "ps", "[", "i", "]", "\n", "ps", "[", "i", "]", "=", "mass", "\n", "# now sample from distribution and return endpoint", "\n", "", "return", "domain", "[", "_prob_map", "(", "np", ".", "random", ".", "random_sample", "(", ")", ",", "ps", ",", "0", ",", "index", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_n2v_walks": [[96, 118], ["numpy.zeros", "range", "len", "min", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "range", "node2vec._batch_walks", "numpy.vstack"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._batch_walks"], ["", "def", "_do_n2v_walks", "(", "p", ",", "q", ",", "length", ",", "rows", ",", "indxs", ",", "chunksize", "=", "10000", ")", ":", "\n", "    ", "\"\"\"Breaks walks up into chunks for memory reasons and performs the walks on them\"\"\"", "\n", "n", "=", "len", "(", "indxs", ")", "-", "1", "\n", "transcripts", "=", "np", ".", "zeros", "(", "(", "0", ",", "length", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "for", "chunk_start", "in", "range", "(", "0", ",", "n", ",", "chunksize", ")", ":", "\n", "        ", "chunk_stop", "=", "min", "(", "chunk_start", "+", "chunksize", ",", "n", ")", "\n", "# create the arrays for this batch", "\n", "t_neighbs_chunk", "=", "np", ".", "zeros", "(", "\n", "(", "chunk_stop", "-", "chunk_start", ",", "n", ")", ",", "dtype", "=", "np", ".", "bool_", ")", "\n", "v_neighbs_chunk", "=", "np", ".", "zeros", "(", "\n", "(", "chunk_stop", "-", "chunk_start", ",", "n", ")", ",", "dtype", "=", "np", ".", "bool_", ")", "\n", "transcript_arr", "=", "np", ".", "zeros", "(", "\n", "(", "chunk_stop", "-", "chunk_start", ",", "length", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "# since Node2Vec walks depend on the last two vertices, we need to start the", "\n", "# the first two columns of the transcript array to contain the walk startpoints", "\n", "transcript_arr", "[", ":", ",", "0", "]", "=", "range", "(", "chunk_start", ",", "chunk_stop", ")", "\n", "transcript_arr", "[", ":", ",", "1", "]", "=", "range", "(", "chunk_start", ",", "chunk_stop", ")", "\n", "# do the walks", "\n", "transcript_arr", "=", "_batch_walks", "(", "transcript_arr", ",", "length", ",", "p", ",", "q", ",", "\n", "rows", ",", "indxs", ",", "t_neighbs_chunk", ",", "v_neighbs_chunk", ")", "\n", "transcripts", "=", "np", ".", "vstack", "(", "(", "transcripts", ",", "transcript_arr", ")", ")", "\n", "", "return", "transcripts", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._batch_walks": [[120, 138], ["numba.njit", "numba.prange", "range", "node2vec._do_step"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_step"], ["", "@", "njit", "(", "parallel", "=", "True", ")", "\n", "def", "_batch_walks", "(", "transcript_arr", ",", "length", ",", "p", ",", "q", ",", "rows", ",", "indxs", ",", "t_neighbs_chunk", ",", "v_neighbs_chunk", ")", ":", "\n", "    ", "\"\"\"Performs walks for all vertices in the first two columns of transcript_arr\"\"\"", "\n", "# walks for each vertex are done in parallel", "\n", "for", "i", "in", "prange", "(", "transcript_arr", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "step", "in", "range", "(", "length", ")", ":", "\n", "# as far as I can tell, I can't do prange(start, stop), so this", "\n", "# continue is necessary.", "\n", "            ", "if", "step", "<", "2", ":", "\n", "                ", "continue", "\n", "", "v", "=", "transcript_arr", "[", "i", ",", "step", "-", "1", "]", "\n", "t", "=", "transcript_arr", "[", "i", ",", "step", "-", "2", "]", "\n", "t_neighbs", "=", "rows", "[", "indxs", "[", "v", "]", ":", "indxs", "[", "v", "+", "1", "]", "]", "\n", "v_neighbs", "=", "rows", "[", "indxs", "[", "t", "]", ":", "indxs", "[", "t", "+", "1", "]", "]", "\n", "# get the probability distribution over the next step", "\n", "transcript_arr", "[", "i", ",", "step", "]", "=", "_do_step", "(", "\n", "t", ",", "v", ",", "p", ",", "q", ",", "t_neighbs", ",", "v_neighbs", ")", "\n", "", "", "return", "transcript_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._prob_map": [[140, 152], ["numba.njit", "node2vec._prob_map", "node2vec._prob_map"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._prob_map", "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._prob_map"], ["", "@", "njit", "(", ")", "\n", "def", "_prob_map", "(", "val", ",", "p_arr", ",", "beg", ",", "end", ")", ":", "\n", "    ", "\"\"\"returns the least index into p_arr with value at least val\"\"\"", "\n", "# binary search, assumes p_arr is sorted", "\n", "if", "end", "-", "beg", "<=", "1", ":", "\n", "        ", "return", "beg", "\n", "", "else", ":", "\n", "        ", "pivot", "=", "beg", "+", "(", "(", "end", "-", "beg", ")", "//", "2", ")", "\n", "if", "val", "<", "p_arr", "[", "pivot", "]", ":", "\n", "            ", "return", "_prob_map", "(", "val", ",", "p_arr", ",", "beg", ",", "pivot", ")", "\n", "", "else", ":", "\n", "            ", "return", "_prob_map", "(", "val", ",", "p_arr", ",", "pivot", ",", "end", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_walks": [[154, 186], ["snlpy.embeddings.deepwalk.process_adj", "numpy.random.seed", "snlpy.embeddings.deepwalk._WalkContainer", "numpy.vstack", "len", "node2vec._do_n2v_walks", "range"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.deepwalk.process_adj", "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.node2vec._do_n2v_walks"], ["", "", "", "def", "_do_walks", "(", "adj", ",", "walk_length", ",", "walk_number", ",", "p", ",", "q", ",", "chunksize", "=", "4000", ")", ":", "\n", "    ", "\"\"\"Perform node2vec's second order walks\n\n    PARAMETERS\n    ----------\n    adj : CsrGraph\n        adjacency matrix of graph to do walks on\n    walk_length : int\n        length of random walks\n    walk_number : int\n        number of random walks per vertex\n    p : float\n        parameter for Node2Vec walks\n    q : float\n        parameter for Node2Vec walks\n    chunksize=4000 : int\n        number of walks to compute at once. Controls memory usage\n\n    RETURNS\n    -------\n    iterator containing walk transcripts as lists of strings\n    \"\"\"", "\n", "rows", ",", "indxs", "=", "process_adj", "(", "adj", ")", "\n", "n", "=", "len", "(", "indxs", ")", "-", "1", "\n", "# pool = Pool(processes=workers)", "\n", "# args = [(x, walk_length, p, q, rows, indxs)", "\n", "#         for x in range(n) for _ in range(walk_number)]", "\n", "np", ".", "random", ".", "seed", "(", ")", "\n", "walk_container", "=", "_WalkContainer", "(", "n", "*", "walk_number", ",", "walk_length", ")", "\n", "walk_container", ".", "walks", "=", "np", ".", "vstack", "(", "[", "_do_n2v_walks", "(", "\n", "p", ",", "q", ",", "walk_length", ",", "rows", ",", "indxs", ",", "chunksize", ")", "for", "_", "in", "range", "(", "walk_number", ")", "]", ")", "\n", "return", "walk_container", "\n", "", ""]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.structural.compute_features": [[4, 13], ["numba.njit", "numba.prange", "len"], "function", ["None"], ["\n", "from", "numba", "import", "njit", ",", "prange", "\n", "\n", "def", "structural_feats", "(", "pairs", ",", "adj", ",", "ppr", ",", "chunksize", "=", "10000", ")", ":", "\n", "    ", "chunked_pairs", "=", "[", "pairs", "[", "i", "*", "chunksize", ":", "(", "i", "+", "1", ")", "*", "chunksize", "]", "\n", "for", "i", "in", "range", "(", "int", "(", "len", "(", "pairs", ")", "/", "chunksize", ")", ")", "]", "\n", "if", "int", "(", "len", "(", "pairs", ")", "/", "chunksize", ")", "*", "chunksize", "!=", "len", "(", "pairs", ")", ":", "\n", "        ", "chunked_pairs", "+=", "[", "pairs", "[", "int", "(", "len", "(", "pairs", ")", "/", "chunksize", ")", "*", "chunksize", ":", "]", "]", "\n", "", "return", "np", ".", "vstack", "(", "[", "_batch_features", "(", "batch", ",", "adj", ",", "ppr", ")", "for", "batch", "in", "chunked_pairs", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.astolman_snlpy.embeddings.structural.Structural": [[15, 35], ["numpy.zeros", "enumerate", "structural.compute_features"], "function", ["home.repos.pwc.inspect_result.astolman_snlpy.embeddings.structural.compute_features"], ["    ", "if", "len", "(", "batch", ")", "==", "0", ":", "\n", "        ", "return", "\n", "", "cosines", "=", "cosine_sim", "(", "batch", ",", "adj", ")", "\n", "connectivities", "=", "compute_three_paths", "(", "batch", ",", "adj", ")", "\n", "pprs", "=", "np", ".", "array", "(", "list", "(", "map", "(", "\n", "lambda", "x", ":", "[", "ppr", "[", "x", "[", "0", "]", ",", "x", "[", "1", "]", "]", ",", "ppr", "[", "x", "[", "1", "]", ",", "x", "[", "0", "]", "]", "]", ",", "batch", ")", ")", ")", "\n", "return", "np", ".", "hstack", "(", "(", "cosines", ",", "connectivities", ",", "pprs", ")", ")", "\n", "\n", "", "def", "compute_three_paths", "(", "pairs", ",", "adj", ")", ":", "\n", "    "]]}