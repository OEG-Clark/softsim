{"home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.load_translation_dict_from_icd9": [[5, 12], ["open", "json.load"], "function", ["None"], ["def", "load_translation_dict_from_icd9", "(", "fn_icd9_graph_json", "=", "'../ICD9/icd9_graph_desc.json'", ")", ":", "\n", "    ", "\"\"\"\n    Load the icd9 graph translation dictionary\n    \"\"\"", "\n", "with", "open", "(", "fn_icd9_graph_json", ",", "encoding", "=", "'utf-8'", ")", "as", "json_file", ":", "\n", "        ", "translation_dict_icd9", "=", "json", ".", "load", "(", "json_file", ")", "\n", "", "return", "translation_dict_icd9", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.setup_matrices_by_layer": [[13, 57], ["range", "set", "list", "dict", "scipy.sparse.csr_matrix", "matrices.append", "layer_id_dicts.append", "range", "zip", "set.add", "len", "list", "rows.append", "cols.append", "vals.append", "vals.append", "len", "len", "set"], "function", ["None"], ["", "def", "setup_matrices_by_layer", "(", "code_ids", ",", "translation_dict", ",", "max_layer", "=", "1", ",", "include_duplicates", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Sets up the transition matrices and ID dictionaries for each layer of the ontology up to a maximum value (from the bottom up).\n    sample_code_ids - a dictionary mapping IDs in the output layer to codes\n    translation_dict - a dictionary containing the codes' ordered parent list (coming from the .json file provided in the ICD9 folder)\n    max_layer - integer maximum layer of the ontology (from the bottom up) up to which the hierarchical evaluation is applied\n    include_duplicates - boolean, default = True; maintains duplication across lower layers if a leaf is not present in the lowest layer (results in presence of all leafs in all layers)\n    returns a tuple:\n        matrices - a list of transition matrices from the leaves to each layer of the ontology up to max_layer (from bottom up)\n        layer_id_dicts - a list of dictionaries of code IDs in vectors for each layer of the ontology up to max_layer (from the bottom up)\n    \"\"\"", "\n", "matrices", "=", "[", "]", "# tranlsation matrices per layer", "\n", "layer_id_dicts", "=", "[", "]", "# id-to-code dictionary per layer", "\n", "\n", "\n", "for", "layer", "in", "range", "(", "max_layer", ")", ":", "\n", "        ", "rows", ",", "cols", ",", "vals", "=", "[", "]", ",", "[", "]", ",", "[", "]", "# setup for a sparse matrix", "\n", "layer_codeset", "=", "set", "(", ")", "# codeset for ancestors - in order to remove duplicates for layer representation", "\n", "for", "code", "in", "code_ids", ":", "\n", "            ", "candidate", "=", "translation_dict", "[", "code", "]", "[", "\"parents\"", "]", "[", "layer", "]", "\n", "if", "layer", "==", "max_layer", "-", "1", "or", "candidate", "!=", "translation_dict", "[", "code", "]", "[", "\"parents\"", "]", "[", "layer", "+", "1", "]", "or", "include_duplicates", ":", "\n", "                ", "layer_codeset", ".", "add", "(", "translation_dict", "[", "code", "]", "[", "\"parents\"", "]", "[", "layer", "]", ")", "# collection of relevant ancestors in the layer", "\n", "\n", "", "", "layer_ranges", "=", "list", "(", "range", "(", "len", "(", "layer_codeset", ")", ")", ")", "\n", "layer_id_dict", "=", "dict", "(", "zip", "(", "list", "(", "layer_codeset", ")", ",", "layer_ranges", ")", ")", "# association of IDs with relevant acestors in the layer", "\n", "\n", "for", "code", "in", "code_ids", ":", "\n", "            ", "ancestor", "=", "translation_dict", "[", "code", "]", "[", "\"parents\"", "]", "[", "layer", "]", "\n", "if", "ancestor", "in", "layer_codeset", ":", "\n", "                ", "rows", ".", "append", "(", "code_ids", "[", "code", "]", ")", "# row number (current code)", "\n", "cols", ".", "append", "(", "layer_id_dict", "[", "ancestor", "]", ")", "# col number (ancestor)", "\n", "if", "include_duplicates", "or", "layer", "==", "max_layer", "-", "2", ":", "# if duplicates are allowed or the next layer is the final layer, create an edge", "\n", "                    ", "vals", ".", "append", "(", "1", ")", "\n", "", "else", ":", "# otherwise observe the ancestor of the ancestor - if this matches the current code, do not create an edge. Otherwise create an edge.", "\n", "                    ", "double_ancestor", "=", "translation_dict", "[", "ancestor", "]", "[", "\"parents\"", "]", "[", "layer", "+", "1", "]", "\n", "duplicate_ancestor", "=", "double_ancestor", "==", "code", "\n", "vals", ".", "append", "(", "not", "(", "duplicate_ancestor", ")", "*", "1", ")", "\n", "\n", "", "", "", "matrix", "=", "csr_matrix", "(", "(", "vals", ",", "(", "rows", ",", "cols", ")", ")", ",", "shape", "=", "(", "(", "len", "(", "code_ids", ")", ")", ",", "(", "len", "(", "set", "(", "cols", ")", ")", ")", ")", ")", "# set up the sparse matrix", "\n", "\n", "matrices", ".", "append", "(", "matrix", ")", "# append the matrix for this layer", "\n", "layer_id_dicts", ".", "append", "(", "layer_id_dict", ")", "# append the id dictionary for this layer", "\n", "\n", "", "return", "matrices", ",", "layer_id_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.low_level_filter": [[59, 81], ["set", "list", "dict", "scipy.sparse.csr_matrix", "range", "zip", "rows.append", "set.add", "len", "list", "cols.append", "vals.append", "cols.append", "vals.append", "len", "len", "set"], "function", ["None"], ["", "def", "low_level_filter", "(", "code_ids", ",", "translation_dict", ")", ":", "\n", "    ", "\"\"\"\n    Creates the matrix to keep only the lowest-level leaf codes\n    \"\"\"", "\n", "rows", ",", "cols", ",", "vals", "=", "[", "]", ",", "[", "]", ",", "[", "]", "# setup for a sparse matrix", "\n", "layer_codeset", "=", "set", "(", ")", "# set of relevant lowest-level leaves", "\n", "for", "code", "in", "code_ids", ":", "\n", "        ", "direct_parent", "=", "translation_dict", "[", "code", "]", "[", "\"parents\"", "]", "[", "0", "]", "\n", "if", "direct_parent", "!=", "code", ":", "\n", "            ", "layer_codeset", ".", "add", "(", "code", ")", "# collection of relevant lowest-layer codes", "\n", "", "", "layer_ranges", "=", "list", "(", "range", "(", "len", "(", "layer_codeset", ")", ")", ")", "\n", "layer_id_dict", "=", "dict", "(", "zip", "(", "list", "(", "layer_codeset", ")", ",", "layer_ranges", ")", ")", "\n", "for", "code", "in", "code_ids", ":", "\n", "        ", "rows", ".", "append", "(", "code_ids", "[", "code", "]", ")", "# row number (current code)", "\n", "if", "code", "in", "layer_codeset", ":", "\n", "            ", "cols", ".", "append", "(", "layer_id_dict", "[", "code", "]", ")", "# col number (ancestor)", "\n", "vals", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "cols", ".", "append", "(", "0", ")", "\n", "vals", ".", "append", "(", "0", ")", "\n", "", "", "matrix", "=", "csr_matrix", "(", "(", "vals", ",", "(", "rows", ",", "cols", ")", ")", ",", "shape", "=", "(", "(", "len", "(", "rows", ")", ")", ",", "(", "len", "(", "set", "(", "cols", ")", ")", ")", ")", ")", "\n", "return", "matrix", ",", "layer_id_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.combined_matrix_setup": [[82, 86], ["evaluation_setup.low_level_filter", "evaluation_setup.setup_matrices_by_layer"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.low_level_filter", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.setup_matrices_by_layer"], ["", "def", "combined_matrix_setup", "(", "code_ids", ",", "translation_dict", ",", "max_layer", "=", "1", ",", "include_duplicates", "=", "False", ")", ":", "\n", "    ", "low_level_matrix", ",", "low_level_id_dict", "=", "low_level_filter", "(", "code_ids", ",", "translation_dict", ")", "\n", "matrices", ",", "level_id_dicts", "=", "setup_matrices_by_layer", "(", "code_ids", ",", "translation_dict", ",", "max_layer", ",", "include_duplicates", ")", "\n", "return", "[", "low_level_matrix", "]", "+", "matrices", ",", "[", "low_level_id_dict", "]", "+", "level_id_dicts", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.hierarchical_eval_setup": [[87, 111], ["range", "numpy.concatenate", "numpy.concatenate", "np.concatenate.append", "np.concatenate.append"], "function", ["None"], ["", "def", "hierarchical_eval_setup", "(", "preds", ",", "golds", ",", "layer_matrices", ",", "max_onto_layers", ")", ":", "\n", "    ", "\"\"\"\n    inputs:\n      preds - a numpy array, a matrix of predictions\n      golds - a numpy array, a matrix of true labels\n      layer_matrices - a list of numpy arrays translating the leaf nodes into layers of the ontology\n      max_onto_layers - an integer describing the maximum layer (from the bottom up) within the ontology to be evaluated on\n    \"\"\"", "\n", "\n", "combined_preds", "=", "[", "]", "\n", "combined_golds", "=", "[", "]", "\n", "\n", "# handling further layers", "\n", "for", "i", "in", "range", "(", "max_onto_layers", "+", "1", ")", ":", "\n", "        ", "translation_matrix", "=", "layer_matrices", "[", "i", "]", "# layer matrix retrieval", "\n", "translated_preds", ",", "translated_golds", "=", "preds", "*", "translation_matrix", ",", "golds", "*", "translation_matrix", "# translation from flat predictions into the layer", "\n", "combined_preds", ".", "append", "(", "translated_preds", ")", "\n", "combined_golds", ".", "append", "(", "translated_golds", ")", "\n", "\n", "# concatenation between layers for predictions and true labels respectively", "\n", "", "combined_preds", "=", "np", ".", "concatenate", "(", "combined_preds", ",", "1", ")", "\n", "combined_golds", "=", "np", ".", "concatenate", "(", "combined_golds", ",", "1", ")", "\n", "\n", "return", "combined_preds", ",", "combined_golds", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul": [[10, 24], ["numpy.sum", "numpy.minimum"], "function", ["None"], ["def", "tp_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", ":", "\n", "    ", "\"\"\"\n    Calculation of True Positives in non-binary setting.\n    On the ancestor levels leaf-level mismatches do not matter. If an ancestor-prediction has an ancestor-gold counterpart,\n    it is considered a TP. Hence, the overall TP for an ancestor is the minimum of the count of the predicted ancestor \n    and the count of the gold standard ancestor.\n    \n    inputs\n      pred: numpy array of predictions\n      gold: numpy array of true labels\n      axes: axes on which summing is to be performed (all dimensions for overall TP)\n    returns integer if axes represent all dimensions, a vector of integers otherwise \n    \"\"\"", "\n", "return", "np", ".", "sum", "(", "np", ".", "minimum", "(", "pred", ",", "gold", ")", ",", "axis", "=", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul": [[25, 39], ["numpy.sum", "numpy.maximum"], "function", ["None"], ["", "def", "fp_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", ":", "\n", "    ", "\"\"\"\n    Calculation of False Positives in non-binary setting.\n    If an ancestor-prediction does not have an ancestor-gold counterpart, it is considered a FP. \n    Hence, the overall FP for an ancestor represents how many more times the ancestor has been predicted in a document \n    compared to how many times it appears in the gold standard.\n    \n    inputs\n      pred: numpy array of predictions\n      gold: numpy array of true labels\n      axes: axes on which summing is to be performed (all dimensions for overall FP)\n    returns integer if axes represent all dimensions, a vector of integers otherwise \n    \"\"\"", "\n", "return", "np", ".", "sum", "(", "np", ".", "maximum", "(", "pred", "-", "gold", ",", "0", ")", ",", "axis", "=", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul": [[40, 54], ["numpy.sum", "numpy.maximum"], "function", ["None"], ["", "def", "fn_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", ":", "\n", "    ", "\"\"\"\n    Calculation of False Negatives in non-binary setting.\n    If an ancestor-gold does not have an ancestor-prediction counterpart, it is considered a FN. \n    Hence, the overall FN for an ancestor represents how many more times the ancestor appears in a document \n    compared to how many times it was predicted for the document.\n    \n    inputs\n      pred: numpy array of predictions\n      gold: numpy array of true labels\n      axes: axes on which summing is to be performed (all dimensions for overall FN)\n    returns integer if axes represent all dimensions, a vector of integers otherwise \n    \"\"\"", "\n", "return", "np", ".", "sum", "(", "np", ".", "maximum", "(", "gold", "-", "pred", ",", "0", ")", ",", "axis", "=", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul_full": [[56, 62], ["multi_level_eval.tp_matrix_mul"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul"], ["", "def", "tp_matrix_mul_full", "(", "pred", ",", "gold", ",", "axes", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "\"\"\"\n    Overall TP for a non-binary 2d matrix\n    returns integer\n    \"\"\"", "\n", "return", "tp_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul_full": [[63, 69], ["multi_level_eval.fp_matrix_mul"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul"], ["", "def", "fp_matrix_mul_full", "(", "pred", ",", "gold", ",", "axes", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "\"\"\"\n    Overall FP for a non-binary 2d matrix\n    returns integer\n    \"\"\"", "\n", "return", "fp_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul_full": [[70, 76], ["multi_level_eval.fn_matrix_mul"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul"], ["", "def", "fn_matrix_mul_full", "(", "pred", ",", "gold", ",", "axes", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "\"\"\"\n    Overall FN for a non-binary 2d matrix\n    returns integer\n    \"\"\"", "\n", "return", "fn_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul_per_class": [[78, 84], ["multi_level_eval.tp_matrix_mul"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul"], ["", "def", "tp_matrix_mul_per_class", "(", "pred", ",", "gold", ",", "axes", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    per-class TP for a non-binary 2d matrix\n    returns 1d np.array\n    \"\"\"", "\n", "return", "tp_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul_per_class": [[85, 91], ["multi_level_eval.fp_matrix_mul"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul"], ["", "def", "fp_matrix_mul_per_class", "(", "pred", ",", "gold", ",", "axes", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    per-class FP for a non-binary 2d matrix\n    returns 1d np.array\n    \"\"\"", "\n", "return", "fp_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul_per_class": [[92, 98], ["multi_level_eval.fn_matrix_mul"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul"], ["", "def", "fn_matrix_mul_per_class", "(", "pred", ",", "gold", ",", "axes", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    per-class FN for a non-binary 2d matrix\n    returns 1d np.array\n    \"\"\"", "\n", "return", "fn_matrix_mul", "(", "pred", ",", "gold", ",", "axes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report": [[99, 141], ["multi_level_eval.tp_matrix_mul_per_class", "multi_level_eval.fp_matrix_mul_per_class", "multi_level_eval.fn_matrix_mul_per_class", "numpy.sum", "sorted", "pandas.DataFrame", "list", "zip"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul_per_class", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul_per_class", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul_per_class"], ["", "def", "report", "(", "pred", ",", "gold", ",", "code_id_dict", ")", ":", "\n", "    ", "\"\"\"\n    Creates a per-class dataframe report.\n    This includes the Precision, Recall, F1 score, Support in the evaluation set, and the code itself.\n    inputs:\n        pred          2d np.array prediction matrix\n        gold          2d np.array matrix of gold standard labels\n        code_id_dict  dictionary mapping codes to their ID in the prediction/gold vectors\n    returns Pandas DataFrame\n    \"\"\"", "\n", "\n", "# Calculation of TP/FP/FN per class", "\n", "tp", "=", "tp_matrix_mul_per_class", "(", "pred", ",", "gold", ")", "\n", "fp", "=", "fp_matrix_mul_per_class", "(", "pred", ",", "gold", ")", "\n", "fn", "=", "fn_matrix_mul_per_class", "(", "pred", ",", "gold", ")", "\n", "\n", "# Calculation of the support within the evaluation set", "\n", "support", "=", "np", ".", "sum", "(", "gold", ",", "axis", "=", "0", ")", "\n", "\n", "\n", "# Precision", "\n", "prec_denom", "=", "tp", "+", "fp", "\n", "prec_denom_corrected", "=", "prec_denom", "+", "(", "prec_denom", "==", "0", ")", "*", "1", "\n", "prec", "=", "tp", "/", "prec_denom_corrected", "\n", "\n", "# Recall", "\n", "rec_denom", "=", "tp", "+", "fn", "\n", "rec_denom_corrected", "=", "rec_denom", "+", "(", "rec_denom", "==", "0", ")", "*", "1", "\n", "rec", "=", "tp", "/", "(", "rec_denom_corrected", ")", "\n", "\n", "# F1 score", "\n", "f1_denom", "=", "prec", "+", "rec", "\n", "f1_denom_corrected", "=", "f1_denom", "+", "(", "(", "f1_denom", "==", "0", ")", "*", "1", ")", "\n", "f1", "=", "2", "*", "(", "prec", "*", "rec", ")", "/", "(", "f1_denom_corrected", ")", "\n", "\n", "# matchin codes", "\n", "code_ids", "=", "sorted", "(", "code_id_dict", ")", "\n", "codes", "=", "[", "code_id_dict", "[", "k", "]", "for", "k", "in", "code_ids", "]", "\n", "\n", "df", "=", "pd", ".", "DataFrame", "(", "list", "(", "zip", "(", "prec", ",", "rec", ",", "f1", ",", "support", ",", "codes", ")", ")", ",", "\n", "columns", "=", "[", "'Precision'", ",", "\"Recall\"", ",", "\"F1\"", ",", "\"Support\"", ",", "\"Code\"", "]", ")", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_micro": [[142, 171], ["multi_level_eval.tp_matrix_mul_full", "multi_level_eval.fp_matrix_mul_full", "multi_level_eval.fn_matrix_mul_full", "dict"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul_full", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul_full", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul_full"], ["", "def", "report_micro", "(", "pred", ",", "gold", ")", ":", "\n", "    ", "\"\"\"\n    Creates an overall report on the micro lvel.\n    This includes the micro Precision, Recall, F1 score.\n    inputs:\n        pred          2d np.array prediction matrix\n        gold          2d np.array matrix of gold standard labels\n        code_id_dict  dictionary mapping codes to their ID in the prediction/gold vectors\n    returns a dictionary with real values for \"Precision\", \"Recall\", and \"F1\"\n    \"\"\"", "\n", "tp", "=", "tp_matrix_mul_full", "(", "pred", ",", "gold", ")", "\n", "fp", "=", "fp_matrix_mul_full", "(", "pred", ",", "gold", ")", "\n", "fn", "=", "fn_matrix_mul_full", "(", "pred", ",", "gold", ")", "\n", "\n", "prec_denom", "=", "tp", "+", "fp", "\n", "prec_denom_corrected", "=", "prec_denom", "+", "(", "prec_denom", "==", "0", ")", "*", "1", "\n", "prec_micro", "=", "tp", "/", "prec_denom_corrected", "\n", "\n", "rec_denom", "=", "tp", "+", "fn", "\n", "rec_denom_corrected", "=", "rec_denom", "+", "(", "rec_denom", "==", "0", ")", "*", "1", "\n", "rec_micro", "=", "tp", "/", "(", "rec_denom_corrected", ")", "\n", "\n", "f1_denom", "=", "prec_micro", "+", "rec_micro", "\n", "f1_denom_corrected", "=", "f1_denom", "+", "(", "(", "f1_denom", "==", "0", ")", "*", "1", ")", "\n", "f1", "=", "2", "*", "(", "prec_micro", "*", "rec_micro", ")", "/", "(", "f1_denom_corrected", ")", "\n", "\n", "report_dict", "=", "dict", "(", "{", "\"Precision\"", ":", "prec_micro", ",", "\"Recall\"", ":", "rec_micro", ",", "\"F1\"", ":", "f1", "}", ")", "\n", "\n", "return", "report_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_macro": [[172, 202], ["multi_level_eval.tp_matrix_mul_per_class", "multi_level_eval.fp_matrix_mul_per_class", "multi_level_eval.fn_matrix_mul_per_class", "numpy.average", "numpy.average", "dict"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.tp_matrix_mul_per_class", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fp_matrix_mul_per_class", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.fn_matrix_mul_per_class"], ["", "def", "report_macro", "(", "pred", ",", "gold", ")", ":", "\n", "    ", "\"\"\"\n    Creates an overall report on the macro lvel.\n    This includes the macro Precision, Recall, F1 score.\n    inputs:\n        pred          2d np.array prediction matrix\n        gold          2d np.array matrix of gold standard labels\n        code_id_dict  dictionary mapping codes to their ID in the prediction/gold vectors\n    returns a dictionary with real values for \"Precision\", \"Recall\", and \"F1\"\n    \"\"\"", "\n", "tp", "=", "tp_matrix_mul_per_class", "(", "pred", ",", "gold", ")", "\n", "fp", "=", "fp_matrix_mul_per_class", "(", "pred", ",", "gold", ")", "\n", "fn", "=", "fn_matrix_mul_per_class", "(", "pred", ",", "gold", ")", "\n", "\n", "prec_denom", "=", "tp", "+", "fp", "\n", "prec_denom_corrected", "=", "prec_denom", "+", "(", "prec_denom", "==", "0", ")", "*", "1", "\n", "prec", "=", "tp", "/", "prec_denom_corrected", "\n", "prec_macro", "=", "np", ".", "average", "(", "prec", ",", "axis", "=", "0", ")", "\n", "\n", "rec_denom", "=", "tp", "+", "fn", "\n", "rec_denom_corrected", "=", "rec_denom", "+", "(", "rec_denom", "==", "0", ")", "*", "1", "\n", "rec", "=", "tp", "/", "(", "rec_denom_corrected", ")", "\n", "rec_macro", "=", "np", ".", "average", "(", "rec", ",", "axis", "=", "0", ")", "\n", "\n", "f1_denom", "=", "prec_macro", "+", "rec_macro", "\n", "f1_denom_corrected", "=", "f1_denom", "+", "(", "(", "f1_denom", "==", "0", ")", "*", "1", ")", "\n", "f1", "=", "2", "*", "(", "prec_macro", "*", "rec_macro", ")", "/", "(", "f1_denom_corrected", ")", "\n", "report_dict", "=", "dict", "(", "{", "\"Precision\"", ":", "prec_macro", ",", "\"Recall\"", ":", "rec_macro", ",", "\"F1\"", ":", "f1", "}", ")", "\n", "\n", "return", "report_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_macro_bin": [[203, 213], ["multi_level_eval.report_macro"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_macro"], ["", "def", "report_macro_bin", "(", "pred", ",", "gold", ")", ":", "\n", "    ", "\"\"\"\n    binarised version of report_macro - the prediction and gold matrix are set to binary, \n    where positive entries are set to 1.\n    \n    return report_macro on these binarised inputs\n    \"\"\"", "\n", "pred_bin", "=", "(", "pred", ">", "0", ")", "*", "1", "\n", "gold_bin", "=", "(", "gold", ">", "0", ")", "*", "1", "\n", "return", "report_macro", "(", "pred_bin", ",", "gold_bin", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_micro_bin": [[214, 224], ["multi_level_eval.report_micro"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_micro"], ["", "def", "report_micro_bin", "(", "pred", ",", "gold", ")", ":", "\n", "    ", "\"\"\"\n    binarised version of report_micro - the prediction and gold matrix are set to binary, \n    where positive entries are set to 1.\n    \n    return report_micro on these binarised inputs\n    \"\"\"", "\n", "pred_bin", "=", "(", "pred", ">", "0", ")", "*", "1", "\n", "gold_bin", "=", "(", "gold", ">", "0", ")", "*", "1", "\n", "return", "report_micro", "(", "pred_bin", ",", "gold_bin", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_bin": [[225, 232], ["multi_level_eval.report"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report"], ["", "def", "report_bin", "(", "pred", ",", "gold", ",", "code_id_dict", ")", ":", "\n", "    ", "\"\"\"\n    Creates a per-class dataframe report on binarised inputs.\n    \"\"\"", "\n", "pred_bin", "=", "(", "pred", ">", "0", ")", "*", "1", "\n", "gold_bin", "=", "(", "gold", ">", "0", ")", "*", "1", "\n", "return", "report", "(", "pred_bin", ",", "gold_bin", ",", "code_id_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.hierarchical_evaluation": [[233, 288], ["evaluation_setup.combined_matrix_setup", "evaluation_setup.hierarchical_eval_setup", "print", "print", "multi_level_eval.report_micro", "print", "print", "multi_level_eval.report_micro_bin", "print", "range", "print", "range", "matrices[].toarray", "pred.dot", "gold.dot", "print", "multi_level_eval.report_micro", "print", "print", "print", "print", "list_results_by_layer.append", "matrices[].toarray", "str", "str"], "function", ["home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.combined_matrix_setup", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.evaluation_setup.hierarchical_eval_setup", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_micro", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_micro_bin", "home.repos.pwc.inspect_result.modr00cka_cophe.scripts.multi_level_eval.report_micro"], ["", "def", "hierarchical_evaluation", "(", "pred", ",", "gold", ",", "code_ids", ",", "translation_dict", ",", "max_onto_layers", "=", "3", ",", "verbo", "=", "False", ")", ":", "\n", "    ", "'''\n    A summary function for final reporting.\n    Inputs:\n        pred                2d np.array prediction matrix\n        gold                2d np.array matrix of gold standard labels\n        code_ids            dictionary mapping codes to their ID in the prediction/gold vectors\n        translation_dict    dictionary mapping codes to their ID in the prediction/gold vectors\n        max_onto_layers           an integer describing the maximum layer (from the bottom up) within the ontology to be evaluated on\n        verbo               whether to verbolise the translation matrices\n    Return 4 variables: \n        micro prec for the overall hierarchical evaluation,\n        rec for the overall hierarchical evaluation,\n        f1 for the overall hierarchical evaluation, \n        the list of results per layer, from layer 1 (leaf node only) up to layer 4 (so there are 4 sets of results, each set has 3 metrics, i.e. micro prec,rec,f1).\n    '''", "\n", "matrices", ",", "layer_id_dicts", "=", "(", "combined_matrix_setup", "(", "code_ids", ",", "translation_dict", ",", "max_layer", "=", "max_onto_layers", ")", ")", "\n", "if", "verbo", ":", "\n", "        ", "print", "(", "\"========TRANSLATION MATRICES========\"", ")", "\n", "for", "layer_ind", "in", "range", "(", "max_onto_layers", "+", "1", ")", ":", "\n", "            ", "print", "(", "\"Layer %s labels:\"", "%", "(", "str", "(", "layer_ind", "+", "1", ")", ")", ")", "\n", "print", "(", "matrices", "[", "layer_ind", "]", ".", "shape", ",", "matrices", "[", "layer_ind", "]", ".", "toarray", "(", ")", ",", "layer_id_dicts", "[", "layer_ind", "]", ")", "\n", "print", "(", "\"====================================\"", ")", "\n", "\n", "", "", "combined_preds", ",", "combined_golds", "=", "hierarchical_eval_setup", "(", "pred", ",", "gold", ",", "matrices", ",", "max_onto_layers", "=", "max_onto_layers", ")", "\n", "print", "(", "'hiearchical evaluation - micro-level results'", ")", "\n", "print", "(", "'overall hierarchical evaluation results:'", ")", "\n", "he_micro_dict", "=", "report_micro", "(", "combined_preds", ",", "combined_golds", ")", "\n", "#he_macro_dict = report_macro(combined_preds, combined_golds)", "\n", "he_micro_prec", ",", "he_micro_rec", ",", "he_micro_f1", "=", "he_micro_dict", "[", "'Precision'", "]", ",", "he_micro_dict", "[", "'Recall'", "]", ",", "he_micro_dict", "[", "'F1'", "]", "\n", "#he_macro_prec,he_macro_rec,he_macro_f1 = he_macro_dict['Precision'],he_macro_dict['Recall'],he_macro_dict['F1']", "\n", "print", "(", "he_micro_dict", ")", "\n", "#print(he_macro_dict)", "\n", "print", "(", "'overall set-based results:'", ")", "\n", "he_micro_set_based_dict", "=", "report_micro_bin", "(", "combined_preds", ",", "combined_golds", ")", "\n", "print", "(", "he_micro_set_based_dict", ")", "\n", "\n", "list_results_by_layer", "=", "[", "]", "\n", "#get results and loop over parent levels", "\n", "for", "layer_ind", "in", "range", "(", "max_onto_layers", "+", "1", ")", ":", "\n", "        ", "child_to_parent_matrix", "=", "matrices", "[", "layer_ind", "]", ".", "toarray", "(", ")", "\n", "\n", "parent_pred_matrix", "=", "pred", ".", "dot", "(", "child_to_parent_matrix", ")", "\n", "parent_gold_matrix", "=", "gold", ".", "dot", "(", "child_to_parent_matrix", ")", "\n", "print", "(", "'result at layer %s'", "%", "str", "(", "layer_ind", "+", "1", ")", ")", "\n", "he_micro_dict", "=", "report_micro", "(", "parent_pred_matrix", ",", "parent_gold_matrix", ")", "\n", "#he_macro_dict = report_macro(parent_pred_matrix, parent_gold_matrix)", "\n", "he_micro_prec_layer", ",", "he_micro_rec_layer", ",", "he_micro_f1_layer", "=", "he_micro_dict", "[", "'Precision'", "]", ",", "he_micro_dict", "[", "'Recall'", "]", ",", "he_micro_dict", "[", "'F1'", "]", "\n", "#he_macro_prec,he_macro_rec,he_macro_f1 = he_macro_dict['Precision'],he_macro_dict['Recall'],he_macro_dict['F1']", "\n", "print", "(", "he_micro_dict", ")", "\n", "#print(he_macro_dict)", "\n", "for", "metric_per_layer", "in", "(", "he_micro_prec_layer", ",", "he_micro_rec_layer", ",", "he_micro_f1_layer", ")", ":", "#,he_macro_prec,he_macro_rec,he_macro_f1", "\n", "            ", "list_results_by_layer", ".", "append", "(", "metric_per_layer", ")", "\n", "\n", "", "", "return", "he_micro_prec", ",", "he_micro_rec", ",", "he_micro_f1", ",", "list_results_by_layer", "\n", "\n"]]}