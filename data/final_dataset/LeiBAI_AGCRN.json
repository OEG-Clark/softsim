{"home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.TrainInits.init_seed": [[5, 15], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.cuda.manual_seed"], "function", ["None"], ["def", "init_seed", "(", "seed", ")", ":", "\n", "    ", "'''\n    Disable cudnn to maximize reproducibility\n    '''", "\n", "torch", ".", "cuda", ".", "cudnn_enabled", "=", "False", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.TrainInits.init_device": [[16, 24], ["torch.cuda.is_available", "torch.cuda.set_device", "int"], "function", ["None"], ["", "def", "init_device", "(", "opt", ")", ":", "\n", "    ", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "opt", ".", "cuda", "=", "True", "\n", "torch", ".", "cuda", ".", "set_device", "(", "int", "(", "opt", ".", "device", "[", "5", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "opt", ".", "cuda", "=", "False", "\n", "opt", ".", "device", "=", "'cpu'", "\n", "", "return", "opt", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.TrainInits.init_optim": [[25, 30], ["torch.optim.Adam", "model.parameters"], "function", ["None"], ["", "def", "init_optim", "(", "model", ",", "opt", ")", ":", "\n", "    ", "'''\n    Initialize optimizer\n    '''", "\n", "return", "torch", ".", "optim", ".", "Adam", "(", "params", "=", "model", ".", "parameters", "(", ")", ",", "lr", "=", "opt", ".", "lr_init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.TrainInits.init_lr_scheduler": [[31, 38], ["torch.optim.lr_scheduler.MultiStepLR"], "function", ["None"], ["", "def", "init_lr_scheduler", "(", "optim", ",", "opt", ")", ":", "\n", "    ", "'''\n    Initialize the learning rate scheduler\n    '''", "\n", "#return torch.optim.lr_scheduler.StepLR(optimizer=optim,gamma=opt.lr_scheduler_rate,step_size=opt.lr_scheduler_step)", "\n", "return", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "optimizer", "=", "optim", ",", "milestones", "=", "opt", ".", "lr_decay_steps", ",", "\n", "gamma", "=", "opt", ".", "lr_scheduler_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.TrainInits.print_model_parameters": [[39, 47], ["print", "sum", "print", "print", "model.named_parameters", "print", "param.nelement", "model.parameters"], "function", ["None"], ["", "def", "print_model_parameters", "(", "model", ",", "only_num", "=", "True", ")", ":", "\n", "    ", "print", "(", "'*****************Model Parameter*****************'", ")", "\n", "if", "not", "only_num", ":", "\n", "        ", "for", "name", ",", "param", "in", "model", ".", "named_parameters", "(", ")", ":", "\n", "            ", "print", "(", "name", ",", "param", ".", "shape", ",", "param", ".", "requires_grad", ")", "\n", "", "", "total_num", "=", "sum", "(", "[", "param", ".", "nelement", "(", ")", "for", "param", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "print", "(", "'Total params num: {}'", ".", "format", "(", "total_num", ")", ")", "\n", "print", "(", "'*****************Finish Parameter****************'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.TrainInits.get_memory_usage": [[48, 52], ["torch.cuda.memory_allocated", "torch.cuda.memory_cached"], "function", ["None"], ["", "def", "get_memory_usage", "(", "device", ")", ":", "\n", "    ", "allocated_memory", "=", "torch", ".", "cuda", ".", "memory_allocated", "(", "device", ")", "/", "(", "1024", "*", "1024.", ")", "\n", "cached_memory", "=", "torch", ".", "cuda", ".", "memory_cached", "(", "device", ")", "/", "(", "1024", "*", "1024.", ")", "\n", "return", "allocated_memory", ",", "cached_memory", "\n", "#print('Allocated Memory: {:.2f} MB, Cached Memory: {:.2f} MB'.format(allocated_memory, cached_memory))", ""]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.NScaler.transform": [[6, 8], ["None"], "methods", ["None"], ["    ", "def", "transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "data", "\n", "", "def", "inverse_transform", "(", "self", ",", "data", ")", ":", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.NScaler.inverse_transform": [[8, 10], ["None"], "methods", ["None"], ["", "def", "inverse_transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.StandardScaler.__init__": [[16, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "self", ".", "mean", "=", "mean", "\n", "self", ".", "std", "=", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.StandardScaler.transform": [[20, 22], ["None"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "(", "data", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.StandardScaler.inverse_transform": [[23, 28], ["torch.from_numpy().to().type", "torch.from_numpy().to().type", "type", "type", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "inverse_transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "if", "type", "(", "data", ")", "==", "torch", ".", "Tensor", "and", "type", "(", "self", ".", "mean", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "self", ".", "std", "=", "torch", ".", "from_numpy", "(", "self", ".", "std", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "data", ".", "dtype", ")", "\n", "self", ".", "mean", "=", "torch", ".", "from_numpy", "(", "self", ".", "mean", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "data", ".", "dtype", ")", "\n", "", "return", "(", "data", "*", "self", ".", "std", ")", "+", "self", ".", "mean", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.MinMax01Scaler.__init__": [[34, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min", ",", "max", ")", ":", "\n", "        ", "self", ".", "min", "=", "min", "\n", "self", ".", "max", "=", "max", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.MinMax01Scaler.transform": [[38, 40], ["None"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "(", "data", "-", "self", ".", "min", ")", "/", "(", "self", ".", "max", "-", "self", ".", "min", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.MinMax01Scaler.inverse_transform": [[41, 46], ["torch.from_numpy().to().type", "torch.from_numpy().to().type", "type", "type", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "inverse_transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "if", "type", "(", "data", ")", "==", "torch", ".", "Tensor", "and", "type", "(", "self", ".", "min", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "self", ".", "min", "=", "torch", ".", "from_numpy", "(", "self", ".", "min", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "data", ".", "dtype", ")", "\n", "self", ".", "max", "=", "torch", ".", "from_numpy", "(", "self", ".", "max", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "data", ".", "dtype", ")", "\n", "", "return", "(", "data", "*", "(", "self", ".", "max", "-", "self", ".", "min", ")", "+", "self", ".", "min", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.MinMax11Scaler.__init__": [[52, 55], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min", ",", "max", ")", ":", "\n", "        ", "self", ".", "min", "=", "min", "\n", "self", ".", "max", "=", "max", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.MinMax11Scaler.transform": [[56, 58], ["None"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "return", "(", "(", "data", "-", "self", ".", "min", ")", "/", "(", "self", ".", "max", "-", "self", ".", "min", ")", ")", "*", "2.", "-", "1.", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.MinMax11Scaler.inverse_transform": [[59, 64], ["torch.from_numpy().to().type", "torch.from_numpy().to().type", "type", "type", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "inverse_transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "if", "type", "(", "data", ")", "==", "torch", ".", "Tensor", "and", "type", "(", "self", ".", "min", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "self", ".", "min", "=", "torch", ".", "from_numpy", "(", "self", ".", "min", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "data", ".", "dtype", ")", "\n", "self", ".", "max", "=", "torch", ".", "from_numpy", "(", "self", ".", "max", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "data", ".", "dtype", ")", "\n", "", "return", "(", "(", "data", "+", "1.", ")", "/", "2.", ")", "*", "(", "self", ".", "max", "-", "self", ".", "min", ")", "+", "self", ".", "min", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.__init__": [[67, 71], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "min", ",", "max", ")", ":", "\n", "        ", "self", ".", "min", "=", "min", "\n", "self", ".", "min_max", "=", "max", "-", "self", ".", "min", "\n", "self", ".", "min_max", "[", "self", ".", "min_max", "==", "0", "]", "=", "1", "\n", "", "def", "transform", "(", "self", ",", "data", ")", ":", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.transform": [[71, 74], ["print"], "methods", ["None"], ["", "def", "transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "print", "(", "data", ".", "shape", ",", "self", ".", "min_max", ".", "shape", ")", "\n", "return", "(", "data", "-", "self", ".", "min", ")", "/", "self", ".", "min_max", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform": [[75, 81], ["torch.from_numpy().to().type", "torch.from_numpy().to().type", "type", "type", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "inverse_transform", "(", "self", ",", "data", ")", ":", "\n", "        ", "if", "type", "(", "data", ")", "==", "torch", ".", "Tensor", "and", "type", "(", "self", ".", "min", ")", "==", "np", ".", "ndarray", ":", "\n", "            ", "self", ".", "min_max", "=", "torch", ".", "from_numpy", "(", "self", ".", "min_max", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "self", ".", "min", "=", "torch", ".", "from_numpy", "(", "self", ".", "min", ")", ".", "to", "(", "data", ".", "device", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "#print(data.dtype, self.min_max.dtype, self.min.dtype)", "\n", "", "return", "(", "data", "*", "self", ".", "min_max", "+", "self", ".", "min", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.one_hot_by_column": [[82, 97], ["range", "column.max", "column.min", "numpy.zeros", "numpy.hstack", "numpy.arange"], "function", ["None"], ["", "", "def", "one_hot_by_column", "(", "data", ")", ":", "\n", "#data is a 2D numpy array", "\n", "    ", "len", "=", "data", ".", "shape", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "data", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "column", "=", "data", "[", ":", ",", "i", "]", "\n", "max", "=", "column", ".", "max", "(", ")", "\n", "min", "=", "column", ".", "min", "(", ")", "\n", "#print(len, max, min)", "\n", "zero_matrix", "=", "np", ".", "zeros", "(", "(", "len", ",", "max", "-", "min", "+", "1", ")", ")", "\n", "zero_matrix", "[", "np", ".", "arange", "(", "len", ")", ",", "column", "-", "min", "]", "=", "1", "\n", "if", "i", "==", "0", ":", "\n", "            ", "encoded", "=", "zero_matrix", "\n", "", "else", ":", "\n", "            ", "encoded", "=", "np", ".", "hstack", "(", "(", "encoded", ",", "zero_matrix", ")", ")", "\n", "", "", "return", "encoded", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.minmax_by_column": [[99, 112], ["range", "column.max", "column.min", "numpy.hstack"], "function", ["None"], ["", "def", "minmax_by_column", "(", "data", ")", ":", "\n", "# data is a 2D numpy array", "\n", "    ", "for", "i", "in", "range", "(", "data", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "column", "=", "data", "[", ":", ",", "i", "]", "\n", "max", "=", "column", ".", "max", "(", ")", "\n", "min", "=", "column", ".", "min", "(", ")", "\n", "column", "=", "(", "column", "-", "min", ")", "/", "(", "max", "-", "min", ")", "\n", "column", "=", "column", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "if", "i", "==", "0", ":", "\n", "            ", "_normalized", "=", "column", "\n", "", "else", ":", "\n", "            ", "_normalized", "=", "np", ".", "hstack", "(", "(", "_normalized", ",", "column", ")", ")", "\n", "", "", "return", "_normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAE_torch": [[11, 17], ["torch.mean", "torch.gt", "torch.masked_select", "torch.masked_select", "torch.abs"], "function", ["None"], ["def", "MAE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "true", "-", "pred", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MSE_torch": [[18, 24], ["torch.mean", "torch.gt", "torch.masked_select", "torch.masked_select"], "function", ["None"], ["", "def", "MSE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "mean", "(", "(", "pred", "-", "true", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RMSE_torch": [[25, 31], ["torch.sqrt", "torch.gt", "torch.masked_select", "torch.masked_select", "torch.mean"], "function", ["None"], ["", "def", "RMSE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "sqrt", "(", "torch", ".", "mean", "(", "(", "pred", "-", "true", ")", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RRSE_torch": [[32, 38], ["torch.gt", "torch.masked_select", "torch.masked_select", "torch.sqrt", "torch.sqrt", "torch.sum", "torch.sum", "torch.masked_select.mean"], "function", ["None"], ["", "def", "RRSE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "sqrt", "(", "torch", ".", "sum", "(", "(", "pred", "-", "true", ")", "**", "2", ")", ")", "/", "torch", ".", "sqrt", "(", "torch", ".", "sum", "(", "(", "pred", "-", "true", ".", "mean", "(", ")", ")", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.CORR_torch": [[39, 62], ["pred.transpose.mean", "true.transpose.mean", "pred.transpose.std", "true.transpose.std", "correlation[].mean", "len", "pred.transpose.unsqueeze().unsqueeze", "true.transpose.unsqueeze().unsqueeze", "len", "pred.transpose.transpose().unsqueeze", "true.transpose.transpose().unsqueeze", "pred.transpose.unsqueeze", "true.transpose.unsqueeze", "len", "pred.transpose.transpose", "true.transpose.transpose", "pred.transpose.transpose", "true.transpose.transpose"], "function", ["None"], ["", "def", "CORR_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "#input B, T, N, D or B, N, D or B, N", "\n", "    ", "if", "len", "(", "pred", ".", "shape", ")", "==", "2", ":", "\n", "        ", "pred", "=", "pred", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "true", "=", "true", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "", "elif", "len", "(", "pred", ".", "shape", ")", "==", "3", ":", "\n", "        ", "pred", "=", "pred", ".", "transpose", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "true", "=", "true", ".", "transpose", "(", "1", ",", "2", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "", "elif", "len", "(", "pred", ".", "shape", ")", "==", "4", ":", "\n", "#B, T, N, D -> B, T, D, N", "\n", "        ", "pred", "=", "pred", ".", "transpose", "(", "2", ",", "3", ")", "\n", "true", "=", "true", ".", "transpose", "(", "2", ",", "3", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "", "dims", "=", "(", "0", ",", "1", ",", "2", ")", "\n", "pred_mean", "=", "pred", ".", "mean", "(", "dim", "=", "dims", ")", "\n", "true_mean", "=", "true", ".", "mean", "(", "dim", "=", "dims", ")", "\n", "pred_std", "=", "pred", ".", "std", "(", "dim", "=", "dims", ")", "\n", "true_std", "=", "true", ".", "std", "(", "dim", "=", "dims", ")", "\n", "correlation", "=", "(", "(", "pred", "-", "pred_mean", ")", "*", "(", "true", "-", "true_mean", ")", ")", ".", "mean", "(", "dim", "=", "dims", ")", "/", "(", "pred_std", "*", "true_std", ")", "\n", "index", "=", "(", "true_std", "!=", "0", ")", "\n", "correlation", "=", "(", "correlation", "[", "index", "]", ")", ".", "mean", "(", ")", "\n", "return", "correlation", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAPE_torch": [[64, 70], ["torch.mean", "torch.gt", "torch.masked_select", "torch.masked_select", "torch.abs", "torch.div"], "function", ["None"], ["", "def", "MAPE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "torch", ".", "div", "(", "(", "true", "-", "pred", ")", ",", "true", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.PNBI_torch": [[71, 78], ["torch.gt().float", "torch.gt().float.mean", "torch.gt", "torch.masked_select", "torch.masked_select", "torch.gt"], "function", ["None"], ["", "def", "PNBI_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "indicator", "=", "torch", ".", "gt", "(", "pred", "-", "true", ",", "0", ")", ".", "float", "(", ")", "\n", "return", "indicator", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.oPNBI_torch": [[79, 86], ["bias.mean", "torch.gt", "torch.masked_select", "torch.masked_select"], "function", ["None"], ["", "def", "oPNBI_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "bias", "=", "(", "true", "+", "pred", ")", "/", "(", "2", "*", "true", ")", "\n", "return", "bias", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MARE_torch": [[87, 93], ["torch.div", "torch.gt", "torch.masked_select", "torch.masked_select", "torch.sum", "torch.sum", "torch.abs"], "function", ["None"], ["", "def", "MARE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "div", "(", "torch", ".", "sum", "(", "torch", ".", "abs", "(", "(", "true", "-", "pred", ")", ")", ")", ",", "torch", ".", "sum", "(", "true", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.SMAPE_torch": [[94, 100], ["torch.mean", "torch.gt", "torch.masked_select", "torch.masked_select", "torch.abs", "torch.abs", "torch.abs"], "function", ["None"], ["", "def", "SMAPE_torch", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "torch", ".", "gt", "(", "true", ",", "mask_value", ")", "\n", "pred", "=", "torch", ".", "masked_select", "(", "pred", ",", "mask", ")", "\n", "true", "=", "torch", ".", "masked_select", "(", "true", ",", "mask", ")", "\n", "", "return", "torch", ".", "mean", "(", "torch", ".", "abs", "(", "true", "-", "pred", ")", "/", "(", "torch", ".", "abs", "(", "true", ")", "+", "torch", ".", "abs", "(", "pred", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAE_np": [[102, 109], ["numpy.mean", "numpy.where", "numpy.absolute"], "function", ["None"], ["", "def", "MAE_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "MAE", "=", "np", ".", "mean", "(", "np", ".", "absolute", "(", "pred", "-", "true", ")", ")", "\n", "return", "MAE", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RMSE_np": [[110, 117], ["numpy.sqrt", "numpy.where", "numpy.mean", "numpy.square"], "function", ["None"], ["", "def", "RMSE_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "RMSE", "=", "np", ".", "sqrt", "(", "np", ".", "mean", "(", "np", ".", "square", "(", "pred", "-", "true", ")", ")", ")", "\n", "return", "RMSE", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RRSE_np": [[119, 126], ["true.mean", "numpy.divide", "numpy.where", "numpy.sqrt", "numpy.sqrt", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "RRSE_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "mean", "=", "true", ".", "mean", "(", ")", "\n", "return", "np", ".", "divide", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "pred", "-", "true", ")", "**", "2", ")", ")", ",", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "(", "true", "-", "mean", ")", "**", "2", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAPE_np": [[127, 133], ["numpy.mean", "numpy.where", "numpy.absolute", "numpy.divide"], "function", ["None"], ["", "def", "MAPE_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "return", "np", ".", "mean", "(", "np", ".", "absolute", "(", "np", ".", "divide", "(", "(", "true", "-", "pred", ")", ",", "true", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.PNBI_np": [[134, 144], ["numpy.where", "np.where.mean", "numpy.where"], "function", ["None"], ["", "def", "PNBI_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "#if PNBI=0, all pred are smaller than true", "\n", "#if PNBI=1, all pred are bigger than true", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "bias", "=", "pred", "-", "true", "\n", "indicator", "=", "np", ".", "where", "(", "bias", ">", "0", ",", "True", ",", "False", ")", "\n", "return", "indicator", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.oPNBI_np": [[145, 155], ["bias.mean", "numpy.where"], "function", ["None"], ["", "def", "oPNBI_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "#if oPNBI>1, pred are bigger than true", "\n", "#if oPNBI<1, pred are smaller than true", "\n", "#however, this metric is too sentive to small values. Not good!", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "bias", "=", "(", "true", "+", "pred", ")", "/", "(", "2", "*", "true", ")", "\n", "return", "bias", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MARE_np": [[156, 162], ["numpy.divide", "numpy.where", "numpy.sum", "numpy.sum", "numpy.absolute"], "function", ["None"], ["", "def", "MARE_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "    ", "if", "mask_value", "!=", "None", ":", "\n", "        ", "mask", "=", "np", ".", "where", "(", "true", ">", "(", "mask_value", ")", ",", "True", ",", "False", ")", "\n", "true", "=", "true", "[", "mask", "]", "\n", "pred", "=", "pred", "[", "mask", "]", "\n", "", "return", "np", ".", "divide", "(", "np", ".", "sum", "(", "np", ".", "absolute", "(", "(", "true", "-", "pred", ")", ")", ")", ",", "np", ".", "sum", "(", "true", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.CORR_np": [[163, 188], ["pred.transpose.mean", "true.transpose.mean", "pred.transpose.std", "true.transpose.std", "correlation[].mean", "len", "pred.transpose.unsqueeze().unsqueeze", "true.transpose.unsqueeze().unsqueeze", "len", "numpy.expand_dims", "numpy.expand_dims", "pred.transpose.unsqueeze", "true.transpose.unsqueeze", "pred.transpose.transpose", "true.transpose.transpose", "len", "pred.transpose.transpose", "true.transpose.transpose"], "function", ["None"], ["", "def", "CORR_np", "(", "pred", ",", "true", ",", "mask_value", "=", "None", ")", ":", "\n", "#input B, T, N, D or B, N, D or B, N", "\n", "    ", "if", "len", "(", "pred", ".", "shape", ")", "==", "2", ":", "\n", "#B, N", "\n", "        ", "pred", "=", "pred", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "true", "=", "true", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "", "elif", "len", "(", "pred", ".", "shape", ")", "==", "3", ":", "\n", "#np.transpose include permute, B, T, N", "\n", "        ", "pred", "=", "np", ".", "expand_dims", "(", "pred", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", ",", "axis", "=", "1", ")", "\n", "true", "=", "np", ".", "expand_dims", "(", "true", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", ",", "axis", "=", "1", ")", "\n", "", "elif", "len", "(", "pred", ".", "shape", ")", "==", "4", ":", "\n", "#B, T, N, D -> B, T, D, N", "\n", "        ", "pred", "=", "pred", ".", "transpose", "(", "0", ",", "1", ",", "2", ",", "3", ")", "\n", "true", "=", "true", ".", "transpose", "(", "0", ",", "1", ",", "2", ",", "3", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "", "dims", "=", "(", "0", ",", "1", ",", "2", ")", "\n", "pred_mean", "=", "pred", ".", "mean", "(", "axis", "=", "dims", ")", "\n", "true_mean", "=", "true", ".", "mean", "(", "axis", "=", "dims", ")", "\n", "pred_std", "=", "pred", ".", "std", "(", "axis", "=", "dims", ")", "\n", "true_std", "=", "true", ".", "std", "(", "axis", "=", "dims", ")", "\n", "correlation", "=", "(", "(", "pred", "-", "pred_mean", ")", "*", "(", "true", "-", "true_mean", ")", ")", ".", "mean", "(", "axis", "=", "dims", ")", "/", "(", "pred_std", "*", "true_std", ")", "\n", "index", "=", "(", "true_std", "!=", "0", ")", "\n", "correlation", "=", "(", "correlation", "[", "index", "]", ")", ".", "mean", "(", ")", "\n", "return", "correlation", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.All_Metrics": [[189, 212], ["type", "type", "type", "metrics.MAE_np", "metrics.RMSE_np", "metrics.MAPE_np", "metrics.RRSE_np", "type", "metrics.MAE_torch", "metrics.RMSE_torch", "metrics.MAPE_torch", "metrics.RRSE_torch", "metrics.CORR_torch"], "function", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAE_np", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RMSE_np", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAPE_np", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RRSE_np", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAE_torch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RMSE_torch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAPE_torch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RRSE_torch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.CORR_torch"], ["", "def", "All_Metrics", "(", "pred", ",", "true", ",", "mask1", ",", "mask2", ")", ":", "\n", "#mask1 filter the very small value, mask2 filter the value lower than a defined threshold", "\n", "    ", "assert", "type", "(", "pred", ")", "==", "type", "(", "true", ")", "\n", "if", "type", "(", "pred", ")", "==", "np", ".", "ndarray", ":", "\n", "        ", "mae", "=", "MAE_np", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "rmse", "=", "RMSE_np", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "mape", "=", "MAPE_np", "(", "pred", ",", "true", ",", "mask2", ")", "\n", "rrse", "=", "RRSE_np", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "corr", "=", "0", "\n", "#corr = CORR_np(pred, true, mask1)", "\n", "#pnbi = PNBI_np(pred, true, mask1)", "\n", "#opnbi = oPNBI_np(pred, true, mask2)", "\n", "", "elif", "type", "(", "pred", ")", "==", "torch", ".", "Tensor", ":", "\n", "        ", "mae", "=", "MAE_torch", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "rmse", "=", "RMSE_torch", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "mape", "=", "MAPE_torch", "(", "pred", ",", "true", ",", "mask2", ")", "\n", "rrse", "=", "RRSE_torch", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "corr", "=", "CORR_torch", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "#pnbi = PNBI_torch(pred, true, mask1)", "\n", "#opnbi = oPNBI_torch(pred, true, mask2)", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "\n", "", "return", "mae", ",", "rmse", ",", "mape", ",", "rrse", ",", "corr", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.SIGIR_Metrics": [[213, 217], ["metrics.RRSE_torch", "metrics.CORR_torch"], "function", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.RRSE_torch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.CORR_torch"], ["", "def", "SIGIR_Metrics", "(", "pred", ",", "true", ",", "mask1", ",", "mask2", ")", ":", "\n", "    ", "rrse", "=", "RRSE_torch", "(", "pred", ",", "true", ",", "mask1", ")", "\n", "corr", "=", "CORR_torch", "(", "pred", ",", "true", ",", "0", ")", "\n", "return", "rrse", ",", "corr", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.add_window.Add_Window_Horizon": [[3, 28], ["len", "numpy.array", "numpy.array", "np.array.append", "np.array.append", "np.array.append", "np.array.append"], "function", ["None"], ["def", "Add_Window_Horizon", "(", "data", ",", "window", "=", "3", ",", "horizon", "=", "1", ",", "single", "=", "False", ")", ":", "\n", "    ", "'''\n    :param data: shape [B, ...]\n    :param window:\n    :param horizon:\n    :return: X is [B, W, ...], Y is [B, H, ...]\n    '''", "\n", "length", "=", "len", "(", "data", ")", "\n", "end_index", "=", "length", "-", "horizon", "-", "window", "+", "1", "\n", "X", "=", "[", "]", "#windows", "\n", "Y", "=", "[", "]", "#horizon", "\n", "index", "=", "0", "\n", "if", "single", ":", "\n", "        ", "while", "index", "<", "end_index", ":", "\n", "            ", "X", ".", "append", "(", "data", "[", "index", ":", "index", "+", "window", "]", ")", "\n", "Y", ".", "append", "(", "data", "[", "index", "+", "window", "+", "horizon", "-", "1", ":", "index", "+", "window", "+", "horizon", "]", ")", "\n", "index", "=", "index", "+", "1", "\n", "", "", "else", ":", "\n", "        ", "while", "index", "<", "end_index", ":", "\n", "            ", "X", ".", "append", "(", "data", "[", "index", ":", "index", "+", "window", "]", ")", "\n", "Y", ".", "append", "(", "data", "[", "index", "+", "window", ":", "index", "+", "window", "+", "horizon", "]", ")", "\n", "index", "=", "index", "+", "1", "\n", "", "", "X", "=", "np", ".", "array", "(", "X", ")", "\n", "Y", "=", "np", ".", "array", "(", "Y", ")", "\n", "return", "X", ",", "Y", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.logger.get_logger": [[5, 34], ["logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setLevel", "os.path.join", "print", "logging.FileHandler", "logging.FileHandler.setLevel", "logging.FileHandler.setFormatter", "logging.getLogger.addHandler"], "function", ["None"], ["def", "get_logger", "(", "root", ",", "name", "=", "None", ",", "debug", "=", "True", ")", ":", "\n", "#when debug is true, show DEBUG and INFO in screen", "\n", "#when debug is false, show DEBUG in file and info in both screen&file", "\n", "#INFO will always be in screen", "\n", "# create a logger", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", "name", ")", "\n", "#critical > error > warning > info > debug > notset", "\n", "logger", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "\n", "# define the formate", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "'%(asctime)s: %(message)s'", ",", "\"%Y-%m-%d %H:%M\"", ")", "\n", "# create another handler for output log to console", "\n", "console_handler", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "if", "debug", ":", "\n", "        ", "console_handler", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "", "else", ":", "\n", "        ", "console_handler", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "# create a handler for write log to file", "\n", "logfile", "=", "os", ".", "path", ".", "join", "(", "root", ",", "'run.log'", ")", "\n", "print", "(", "'Creat Log File in: '", ",", "logfile", ")", "\n", "file_handler", "=", "logging", ".", "FileHandler", "(", "logfile", ",", "mode", "=", "'w'", ")", "\n", "file_handler", ".", "setLevel", "(", "logging", ".", "DEBUG", ")", "\n", "file_handler", ".", "setFormatter", "(", "formatter", ")", "\n", "", "console_handler", ".", "setFormatter", "(", "formatter", ")", "\n", "# add Handler to logger", "\n", "logger", ".", "addHandler", "(", "console_handler", ")", "\n", "if", "not", "debug", ":", "\n", "        ", "logger", ".", "addHandler", "(", "file_handler", ")", "\n", "", "return", "logger", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.load_dataset.load_st_dataset": [[4, 18], ["print", "os.path.join", "len", "numpy.expand_dims", "np.expand_dims.max", "np.expand_dims.min", "np.expand_dims.mean", "numpy.median", "os.path.join", "numpy.load", "numpy.load"], "function", ["None"], ["def", "load_st_dataset", "(", "dataset", ")", ":", "\n", "#output B, N, D", "\n", "    ", "if", "dataset", "==", "'PEMSD4'", ":", "\n", "        ", "data_path", "=", "os", ".", "path", ".", "join", "(", "'../data/PeMSD4/pems04.npz'", ")", "\n", "data", "=", "np", ".", "load", "(", "data_path", ")", "[", "'data'", "]", "[", ":", ",", ":", ",", "0", "]", "#onley the first dimension, traffic flow data", "\n", "", "elif", "dataset", "==", "'PEMSD8'", ":", "\n", "        ", "data_path", "=", "os", ".", "path", ".", "join", "(", "'../data/PeMSD8/pems08.npz'", ")", "\n", "data", "=", "np", ".", "load", "(", "data_path", ")", "[", "'data'", "]", "[", ":", ",", ":", ",", "0", "]", "#onley the first dimension, traffic flow data", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "", "if", "len", "(", "data", ".", "shape", ")", "==", "2", ":", "\n", "        ", "data", "=", "np", ".", "expand_dims", "(", "data", ",", "axis", "=", "-", "1", ")", "\n", "", "print", "(", "'Load %s Dataset shaped: '", "%", "dataset", ",", "data", ".", "shape", ",", "data", ".", "max", "(", ")", ",", "data", ".", "min", "(", ")", ",", "data", ".", "mean", "(", ")", ",", "np", ".", "median", "(", "data", ")", ")", "\n", "return", "data", "\n", "", ""]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.normalize_dataset": [[8, 52], ["lib.normalization.MinMax01Scaler", "lib.normalization.ColumnMinMaxScaler.transform", "print", "scaler.transform.min", "scaler.transform.max", "scaler.transform.min", "scaler.transform.max", "lib.normalization.MinMax11Scaler", "lib.normalization.ColumnMinMaxScaler.transform", "print", "scaler.transform.min", "scaler.transform.max", "scaler.transform.min", "scaler.transform.max", "lib.normalization.StandardScaler", "lib.normalization.ColumnMinMaxScaler.transform", "print", "scaler.transform.mean", "scaler.transform.std", "scaler.transform.mean", "scaler.transform.std", "lib.normalization.NScaler", "lib.normalization.ColumnMinMaxScaler.transform", "print", "lib.normalization.ColumnMinMaxScaler", "lib.normalization.ColumnMinMaxScaler.transform", "print", "scaler.transform.min", "scaler.transform.max"], "function", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.transform"], ["def", "normalize_dataset", "(", "data", ",", "normalizer", ",", "column_wise", "=", "False", ")", ":", "\n", "    ", "if", "normalizer", "==", "'max01'", ":", "\n", "        ", "if", "column_wise", ":", "\n", "            ", "minimum", "=", "data", ".", "min", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "maximum", "=", "data", ".", "max", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "minimum", "=", "data", ".", "min", "(", ")", "\n", "maximum", "=", "data", ".", "max", "(", ")", "\n", "", "scaler", "=", "MinMax01Scaler", "(", "minimum", ",", "maximum", ")", "\n", "data", "=", "scaler", ".", "transform", "(", "data", ")", "\n", "print", "(", "'Normalize the dataset by MinMax01 Normalization'", ")", "\n", "", "elif", "normalizer", "==", "'max11'", ":", "\n", "        ", "if", "column_wise", ":", "\n", "            ", "minimum", "=", "data", ".", "min", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "maximum", "=", "data", ".", "max", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "minimum", "=", "data", ".", "min", "(", ")", "\n", "maximum", "=", "data", ".", "max", "(", ")", "\n", "", "scaler", "=", "MinMax11Scaler", "(", "minimum", ",", "maximum", ")", "\n", "data", "=", "scaler", ".", "transform", "(", "data", ")", "\n", "print", "(", "'Normalize the dataset by MinMax11 Normalization'", ")", "\n", "", "elif", "normalizer", "==", "'std'", ":", "\n", "        ", "if", "column_wise", ":", "\n", "            ", "mean", "=", "data", ".", "mean", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "std", "=", "data", ".", "std", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "mean", "=", "data", ".", "mean", "(", ")", "\n", "std", "=", "data", ".", "std", "(", ")", "\n", "", "scaler", "=", "StandardScaler", "(", "mean", ",", "std", ")", "\n", "data", "=", "scaler", ".", "transform", "(", "data", ")", "\n", "print", "(", "'Normalize the dataset by Standard Normalization'", ")", "\n", "", "elif", "normalizer", "==", "'None'", ":", "\n", "        ", "scaler", "=", "NScaler", "(", ")", "\n", "data", "=", "scaler", ".", "transform", "(", "data", ")", "\n", "print", "(", "'Does not normalize the dataset'", ")", "\n", "", "elif", "normalizer", "==", "'cmax'", ":", "\n", "#column min max, to be depressed", "\n", "#note: axis must be the spatial dimension, please check !", "\n", "        ", "scaler", "=", "ColumnMinMaxScaler", "(", "data", ".", "min", "(", "axis", "=", "0", ")", ",", "data", ".", "max", "(", "axis", "=", "0", ")", ")", "\n", "data", "=", "scaler", ".", "transform", "(", "data", ")", "\n", "print", "(", "'Normalize the dataset by Column Min-Max Normalization'", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "\n", "", "return", "data", ",", "scaler", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.split_data_by_days": [[53, 66], ["int"], "function", ["None"], ["", "def", "split_data_by_days", "(", "data", ",", "val_days", ",", "test_days", ",", "interval", "=", "60", ")", ":", "\n", "    ", "'''\n    :param data: [B, *]\n    :param val_days:\n    :param test_days:\n    :param interval: interval (15, 30, 60) minutes\n    :return:\n    '''", "\n", "T", "=", "int", "(", "(", "24", "*", "60", ")", "/", "interval", ")", "\n", "test_data", "=", "data", "[", "-", "T", "*", "test_days", ":", "]", "\n", "val_data", "=", "data", "[", "-", "T", "*", "(", "test_days", "+", "val_days", ")", ":", "-", "T", "*", "test_days", "]", "\n", "train_data", "=", "data", "[", ":", "-", "T", "*", "(", "test_days", "+", "val_days", ")", "]", "\n", "return", "train_data", ",", "val_data", ",", "test_data", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.split_data_by_ratio": [[67, 73], ["int", "int", "int", "int"], "function", ["None"], ["", "def", "split_data_by_ratio", "(", "data", ",", "val_ratio", ",", "test_ratio", ")", ":", "\n", "    ", "data_len", "=", "data", ".", "shape", "[", "0", "]", "\n", "test_data", "=", "data", "[", "-", "int", "(", "data_len", "*", "test_ratio", ")", ":", "]", "\n", "val_data", "=", "data", "[", "-", "int", "(", "data_len", "*", "(", "test_ratio", "+", "val_ratio", ")", ")", ":", "-", "int", "(", "data_len", "*", "test_ratio", ")", "]", "\n", "train_data", "=", "data", "[", ":", "-", "int", "(", "data_len", "*", "(", "test_ratio", "+", "val_ratio", ")", ")", "]", "\n", "return", "train_data", ",", "val_data", ",", "test_data", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.data_loader": [[74, 82], ["torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.cuda.is_available", "torch.cuda.is_available", "TensorFloat", "TensorFloat"], "function", ["None"], ["", "def", "data_loader", "(", "X", ",", "Y", ",", "batch_size", ",", "shuffle", "=", "True", ",", "drop_last", "=", "True", ")", ":", "\n", "    ", "cuda", "=", "True", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "False", "\n", "TensorFloat", "=", "torch", ".", "cuda", ".", "FloatTensor", "if", "cuda", "else", "torch", ".", "FloatTensor", "\n", "X", ",", "Y", "=", "TensorFloat", "(", "X", ")", ",", "TensorFloat", "(", "Y", ")", "\n", "data", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "X", ",", "Y", ")", "\n", "dataloader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "data", ",", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "shuffle", ",", "drop_last", "=", "drop_last", ")", "\n", "return", "dataloader", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.get_dataloader": [[84, 109], ["lib.load_dataset.load_st_dataset", "dataloader.normalize_dataset", "lib.add_window.Add_Window_Horizon", "lib.add_window.Add_Window_Horizon", "lib.add_window.Add_Window_Horizon", "print", "print", "print", "dataloader.data_loader", "dataloader.data_loader", "dataloader.split_data_by_days", "dataloader.split_data_by_ratio", "len", "dataloader.data_loader"], "function", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.load_dataset.load_st_dataset", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.normalize_dataset", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.add_window.Add_Window_Horizon", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.add_window.Add_Window_Horizon", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.add_window.Add_Window_Horizon", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.data_loader", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.data_loader", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.split_data_by_days", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.split_data_by_ratio", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.dataloader.data_loader"], ["", "def", "get_dataloader", "(", "args", ",", "normalizer", "=", "'std'", ",", "tod", "=", "False", ",", "dow", "=", "False", ",", "weather", "=", "False", ",", "single", "=", "True", ")", ":", "\n", "#load raw st dataset", "\n", "    ", "data", "=", "load_st_dataset", "(", "args", ".", "dataset", ")", "# B, N, D", "\n", "#normalize st data", "\n", "data", ",", "scaler", "=", "normalize_dataset", "(", "data", ",", "normalizer", ",", "args", ".", "column_wise", ")", "\n", "#spilit dataset by days or by ratio", "\n", "if", "args", ".", "test_ratio", ">", "1", ":", "\n", "        ", "data_train", ",", "data_val", ",", "data_test", "=", "split_data_by_days", "(", "data", ",", "args", ".", "val_ratio", ",", "args", ".", "test_ratio", ")", "\n", "", "else", ":", "\n", "        ", "data_train", ",", "data_val", ",", "data_test", "=", "split_data_by_ratio", "(", "data", ",", "args", ".", "val_ratio", ",", "args", ".", "test_ratio", ")", "\n", "#add time window", "\n", "", "x_tra", ",", "y_tra", "=", "Add_Window_Horizon", "(", "data_train", ",", "args", ".", "lag", ",", "args", ".", "horizon", ",", "single", ")", "\n", "x_val", ",", "y_val", "=", "Add_Window_Horizon", "(", "data_val", ",", "args", ".", "lag", ",", "args", ".", "horizon", ",", "single", ")", "\n", "x_test", ",", "y_test", "=", "Add_Window_Horizon", "(", "data_test", ",", "args", ".", "lag", ",", "args", ".", "horizon", ",", "single", ")", "\n", "print", "(", "'Train: '", ",", "x_tra", ".", "shape", ",", "y_tra", ".", "shape", ")", "\n", "print", "(", "'Val: '", ",", "x_val", ".", "shape", ",", "y_val", ".", "shape", ")", "\n", "print", "(", "'Test: '", ",", "x_test", ".", "shape", ",", "y_test", ".", "shape", ")", "\n", "##############get dataloader######################", "\n", "train_dataloader", "=", "data_loader", "(", "x_tra", ",", "y_tra", ",", "args", ".", "batch_size", ",", "shuffle", "=", "True", ",", "drop_last", "=", "True", ")", "\n", "if", "len", "(", "x_val", ")", "==", "0", ":", "\n", "        ", "val_dataloader", "=", "None", "\n", "", "else", ":", "\n", "        ", "val_dataloader", "=", "data_loader", "(", "x_val", ",", "y_val", ",", "args", ".", "batch_size", ",", "shuffle", "=", "False", ",", "drop_last", "=", "True", ")", "\n", "", "test_dataloader", "=", "data_loader", "(", "x_test", ",", "y_test", ",", "args", ".", "batch_size", ",", "shuffle", "=", "False", ",", "drop_last", "=", "False", ")", "\n", "return", "train_dataloader", ",", "val_dataloader", ",", "test_dataloader", ",", "scaler", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRNCell.AGCRNCell.__init__": [[6, 12], ["torch.Module.__init__", "model.AGCN.AVWGCN", "model.AGCN.AVWGCN"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "node_num", ",", "dim_in", ",", "dim_out", ",", "cheb_k", ",", "embed_dim", ")", ":", "\n", "        ", "super", "(", "AGCRNCell", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "node_num", "=", "node_num", "\n", "self", ".", "hidden_dim", "=", "dim_out", "\n", "self", ".", "gate", "=", "AVWGCN", "(", "dim_in", "+", "self", ".", "hidden_dim", ",", "2", "*", "dim_out", ",", "cheb_k", ",", "embed_dim", ")", "\n", "self", ".", "update", "=", "AVWGCN", "(", "dim_in", "+", "self", ".", "hidden_dim", ",", "dim_out", ",", "cheb_k", ",", "embed_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRNCell.AGCRNCell.forward": [[13, 24], ["state.to.to.to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.split", "torch.split", "torch.split", "torch.split", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "AGCRNCell.AGCRNCell.gate", "AGCRNCell.AGCRNCell.update"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "state", ",", "node_embeddings", ")", ":", "\n", "#x: B, num_nodes, input_dim", "\n", "#state: B, num_nodes, hidden_dim", "\n", "        ", "state", "=", "state", ".", "to", "(", "x", ".", "device", ")", "\n", "input_and_state", "=", "torch", ".", "cat", "(", "(", "x", ",", "state", ")", ",", "dim", "=", "-", "1", ")", "\n", "z_r", "=", "torch", ".", "sigmoid", "(", "self", ".", "gate", "(", "input_and_state", ",", "node_embeddings", ")", ")", "\n", "z", ",", "r", "=", "torch", ".", "split", "(", "z_r", ",", "self", ".", "hidden_dim", ",", "dim", "=", "-", "1", ")", "\n", "candidate", "=", "torch", ".", "cat", "(", "(", "x", ",", "z", "*", "state", ")", ",", "dim", "=", "-", "1", ")", "\n", "hc", "=", "torch", ".", "tanh", "(", "self", ".", "update", "(", "candidate", ",", "node_embeddings", ")", ")", "\n", "h", "=", "r", "*", "state", "+", "(", "1", "-", "r", ")", "*", "hc", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRNCell.AGCRNCell.init_hidden_state": [[25, 27], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["None"], ["", "def", "init_hidden_state", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "batch_size", ",", "self", ".", "node_num", ",", "self", ".", "hidden_dim", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.__init__": [[11, 33], ["object.__init__", "len", "os.path.join", "os.path.join", "lib.logger.get_logger", "BasicTrainer.Trainer.logger.info", "len", "os.makedirs", "os.path.isdir"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.__init__", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.logger.get_logger"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "loss", ",", "optimizer", ",", "train_loader", ",", "val_loader", ",", "test_loader", ",", "\n", "scaler", ",", "args", ",", "lr_scheduler", "=", "None", ")", ":", "\n", "        ", "super", "(", "Trainer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "optimizer", "=", "optimizer", "\n", "self", ".", "train_loader", "=", "train_loader", "\n", "self", ".", "val_loader", "=", "val_loader", "\n", "self", ".", "test_loader", "=", "test_loader", "\n", "self", ".", "scaler", "=", "scaler", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "lr_scheduler", "=", "lr_scheduler", "\n", "self", ".", "train_per_epoch", "=", "len", "(", "train_loader", ")", "\n", "if", "val_loader", "!=", "None", ":", "\n", "            ", "self", ".", "val_per_epoch", "=", "len", "(", "val_loader", ")", "\n", "", "self", ".", "best_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "args", ".", "log_dir", ",", "'best_model.pth'", ")", "\n", "self", ".", "loss_figure_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "args", ".", "log_dir", ",", "'loss.png'", ")", "\n", "#log", "\n", "if", "os", ".", "path", ".", "isdir", "(", "args", ".", "log_dir", ")", "==", "False", "and", "not", "args", ".", "debug", ":", "\n", "            ", "os", ".", "makedirs", "(", "args", ".", "log_dir", ",", "exist_ok", "=", "True", ")", "\n", "", "self", ".", "logger", "=", "get_logger", "(", "args", ".", "log_dir", ",", "name", "=", "args", ".", "model", ",", "debug", "=", "args", ".", "debug", ")", "\n", "self", ".", "logger", ".", "info", "(", "'Experiment log path in: {}'", ".", "format", "(", "args", ".", "log_dir", ")", ")", "\n", "#if not args.debug:", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.val_epoch": [[38, 56], ["BasicTrainer.Trainer.model.eval", "BasicTrainer.Trainer.logger.info", "torch.no_grad", "enumerate", "len", "BasicTrainer.Trainer.model", "BasicTrainer.Trainer.loss", "BasicTrainer.Trainer.scaler.inverse_transform", "BasicTrainer.Trainer.cuda", "torch.isnan", "BasicTrainer.Trainer.item"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform"], ["", "def", "val_epoch", "(", "self", ",", "epoch", ",", "val_dataloader", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "total_val_loss", "=", "0", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "val_dataloader", ")", ":", "\n", "                ", "data", "=", "data", "[", "...", ",", ":", "self", ".", "args", ".", "input_dim", "]", "\n", "label", "=", "target", "[", "...", ",", ":", "self", ".", "args", ".", "output_dim", "]", "\n", "output", "=", "self", ".", "model", "(", "data", ",", "target", ",", "teacher_forcing_ratio", "=", "0.", ")", "\n", "if", "self", ".", "args", ".", "real_value", ":", "\n", "                    ", "label", "=", "self", ".", "scaler", ".", "inverse_transform", "(", "label", ")", "\n", "", "loss", "=", "self", ".", "loss", "(", "output", ".", "cuda", "(", ")", ",", "label", ")", "\n", "#a whole batch of Metr_LA is filtered", "\n", "if", "not", "torch", ".", "isnan", "(", "loss", ")", ":", "\n", "                    ", "total_val_loss", "+=", "loss", ".", "item", "(", ")", "\n", "", "", "", "val_loss", "=", "total_val_loss", "/", "len", "(", "val_dataloader", ")", "\n", "self", ".", "logger", ".", "info", "(", "'**********Val Epoch {}: average Loss: {:.6f}'", ".", "format", "(", "epoch", ",", "val_loss", ")", ")", "\n", "return", "val_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.train_epoch": [[57, 96], ["BasicTrainer.Trainer.model.train", "enumerate", "BasicTrainer.Trainer.logger.info", "BasicTrainer.Trainer.optimizer.zero_grad", "BasicTrainer.Trainer.model", "BasicTrainer.Trainer.loss", "BasicTrainer.Trainer.backward", "BasicTrainer.Trainer.optimizer.step", "BasicTrainer.Trainer.item", "BasicTrainer.Trainer.lr_scheduler.step", "BasicTrainer.Trainer._compute_sampling_threshold", "BasicTrainer.Trainer.scaler.inverse_transform", "BasicTrainer.Trainer.cuda", "torch.nn.utils.clip_grad_norm_", "BasicTrainer.Trainer.logger.info", "BasicTrainer.Trainer.model.parameters", "BasicTrainer.Trainer.item"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.train", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer._compute_sampling_threshold", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform"], ["", "def", "train_epoch", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "self", ".", "model", ".", "train", "(", ")", "\n", "total_loss", "=", "0", "\n", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "self", ".", "train_loader", ")", ":", "\n", "            ", "data", "=", "data", "[", "...", ",", ":", "self", ".", "args", ".", "input_dim", "]", "\n", "label", "=", "target", "[", "...", ",", ":", "self", ".", "args", ".", "output_dim", "]", "# (..., 1)", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "#teacher_forcing for RNN encoder-decoder model", "\n", "#if teacher_forcing_ratio = 1: use label as input in the decoder for all steps", "\n", "if", "self", ".", "args", ".", "teacher_forcing", ":", "\n", "                ", "global_step", "=", "(", "epoch", "-", "1", ")", "*", "self", ".", "train_per_epoch", "+", "batch_idx", "\n", "teacher_forcing_ratio", "=", "self", ".", "_compute_sampling_threshold", "(", "global_step", ",", "self", ".", "args", ".", "tf_decay_steps", ")", "\n", "", "else", ":", "\n", "                ", "teacher_forcing_ratio", "=", "1.", "\n", "#data and target shape: B, T, N, F; output shape: B, T, N, F", "\n", "", "output", "=", "self", ".", "model", "(", "data", ",", "target", ",", "teacher_forcing_ratio", "=", "teacher_forcing_ratio", ")", "\n", "if", "self", ".", "args", ".", "real_value", ":", "\n", "                ", "label", "=", "self", ".", "scaler", ".", "inverse_transform", "(", "label", ")", "\n", "", "loss", "=", "self", ".", "loss", "(", "output", ".", "cuda", "(", ")", ",", "label", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# add max grad clipping", "\n", "if", "self", ".", "args", ".", "grad_norm", ":", "\n", "                ", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "self", ".", "args", ".", "max_grad_norm", ")", "\n", "", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "total_loss", "+=", "loss", ".", "item", "(", ")", "\n", "\n", "#log information", "\n", "if", "batch_idx", "%", "self", ".", "args", ".", "log_step", "==", "0", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "'Train Epoch {}: {}/{} Loss: {:.6f}'", ".", "format", "(", "\n", "epoch", ",", "batch_idx", ",", "self", ".", "train_per_epoch", ",", "loss", ".", "item", "(", ")", ")", ")", "\n", "", "", "train_epoch_loss", "=", "total_loss", "/", "self", ".", "train_per_epoch", "\n", "self", ".", "logger", ".", "info", "(", "'**********Train Epoch {}: averaged Loss: {:.6f}, tf_ratio: {:.6f}'", ".", "format", "(", "epoch", ",", "train_epoch_loss", ",", "teacher_forcing_ratio", ")", ")", "\n", "\n", "#learning rate decay", "\n", "if", "self", ".", "args", ".", "lr_decay", ":", "\n", "            ", "self", ".", "lr_scheduler", ".", "step", "(", ")", "\n", "", "return", "train_epoch_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.train": [[97, 153], ["float", "time.time", "range", "BasicTrainer.Trainer.logger.info", "BasicTrainer.Trainer.model.load_state_dict", "BasicTrainer.Trainer.test", "BasicTrainer.Trainer.train_epoch", "BasicTrainer.Trainer.val_epoch", "train_loss_list.append", "val_loss_list.append", "time.time", "torch.save", "BasicTrainer.Trainer.logger.info", "BasicTrainer.Trainer.logger.warning", "BasicTrainer.Trainer.logger.info", "copy.deepcopy", "BasicTrainer.Trainer.logger.info", "BasicTrainer.Trainer.model.state_dict"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.test", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.train_epoch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.val_epoch"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "best_model", "=", "None", "\n", "best_loss", "=", "float", "(", "'inf'", ")", "\n", "not_improved_count", "=", "0", "\n", "train_loss_list", "=", "[", "]", "\n", "val_loss_list", "=", "[", "]", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "for", "epoch", "in", "range", "(", "1", ",", "self", ".", "args", ".", "epochs", "+", "1", ")", ":", "\n", "#epoch_time = time.time()", "\n", "            ", "train_epoch_loss", "=", "self", ".", "train_epoch", "(", "epoch", ")", "\n", "#print(time.time()-epoch_time)", "\n", "#exit()", "\n", "if", "self", ".", "val_loader", "==", "None", ":", "\n", "                ", "val_dataloader", "=", "self", ".", "test_loader", "\n", "", "else", ":", "\n", "                ", "val_dataloader", "=", "self", ".", "val_loader", "\n", "", "val_epoch_loss", "=", "self", ".", "val_epoch", "(", "epoch", ",", "val_dataloader", ")", "\n", "\n", "#print('LR:', self.optimizer.param_groups[0]['lr'])", "\n", "train_loss_list", ".", "append", "(", "train_epoch_loss", ")", "\n", "val_loss_list", ".", "append", "(", "val_epoch_loss", ")", "\n", "if", "train_epoch_loss", ">", "1e6", ":", "\n", "                ", "self", ".", "logger", ".", "warning", "(", "'Gradient explosion detected. Ending...'", ")", "\n", "break", "\n", "#if self.val_loader == None:", "\n", "#val_epoch_loss = train_epoch_loss", "\n", "", "if", "val_epoch_loss", "<", "best_loss", ":", "\n", "                ", "best_loss", "=", "val_epoch_loss", "\n", "not_improved_count", "=", "0", "\n", "best_state", "=", "True", "\n", "", "else", ":", "\n", "                ", "not_improved_count", "+=", "1", "\n", "best_state", "=", "False", "\n", "# early stop", "\n", "", "if", "self", ".", "args", ".", "early_stop", ":", "\n", "                ", "if", "not_improved_count", "==", "self", ".", "args", ".", "early_stop_patience", ":", "\n", "                    ", "self", ".", "logger", ".", "info", "(", "\"Validation performance didn\\'t improve for {} epochs. \"", "\n", "\"Training stops.\"", ".", "format", "(", "self", ".", "args", ".", "early_stop_patience", ")", ")", "\n", "break", "\n", "# save the best state", "\n", "", "", "if", "best_state", "==", "True", ":", "\n", "                ", "self", ".", "logger", ".", "info", "(", "'*********************************Current best model saved!'", ")", "\n", "best_model", "=", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "\n", "", "", "training_time", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "self", ".", "logger", ".", "info", "(", "\"Total training time: {:.4f}min, best loss: {:.6f}\"", ".", "format", "(", "(", "training_time", "/", "60", ")", ",", "best_loss", ")", ")", "\n", "\n", "#save the best model to file", "\n", "if", "not", "self", ".", "args", ".", "debug", ":", "\n", "            ", "torch", ".", "save", "(", "best_model", ",", "self", ".", "best_path", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Saving current best model to \"", "+", "self", ".", "best_path", ")", "\n", "\n", "#test", "\n", "", "self", ".", "model", ".", "load_state_dict", "(", "best_model", ")", "\n", "#self.val_epoch(self.args.epochs, self.test_loader)", "\n", "self", ".", "test", "(", "self", ".", "model", ",", "self", ".", "args", ",", "self", ".", "test_loader", ",", "self", ".", "scaler", ",", "self", ".", "logger", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.save_checkpoint": [[154, 162], ["torch.save", "BasicTrainer.Trainer.logger.info", "BasicTrainer.Trainer.model.state_dict", "BasicTrainer.Trainer.optimizer.state_dict"], "methods", ["None"], ["", "def", "save_checkpoint", "(", "self", ")", ":", "\n", "        ", "state", "=", "{", "\n", "'state_dict'", ":", "self", ".", "model", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "self", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'config'", ":", "self", ".", "args", "\n", "}", "\n", "torch", ".", "save", "(", "state", ",", "self", ".", "best_path", ")", "\n", "self", ".", "logger", ".", "info", "(", "\"Saving current best model to \"", "+", "self", ".", "best_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer.test": [[163, 196], ["model.eval", "scaler.inverse_transform", "numpy.save", "numpy.save", "range", "lib.metrics.All_Metrics", "logger.info", "torch.load", "model.load_state_dict", "model.to", "torch.no_grad", "enumerate", "torch.cat", "torch.cat", "scaler.inverse_transform", "scaler.inverse_transform.cpu().numpy", "scaler.inverse_transform.cpu().numpy", "lib.metrics.All_Metrics", "logger.info", "model", "scaler.inverse_transform.append", "scaler.inverse_transform.append", "torch.cat", "scaler.inverse_transform.cpu", "scaler.inverse_transform.cpu"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.All_Metrics", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.All_Metrics"], ["", "@", "staticmethod", "\n", "def", "test", "(", "model", ",", "args", ",", "data_loader", ",", "scaler", ",", "logger", ",", "path", "=", "None", ")", ":", "\n", "        ", "if", "path", "!=", "None", ":", "\n", "            ", "check_point", "=", "torch", ".", "load", "(", "path", ")", "\n", "state_dict", "=", "check_point", "[", "'state_dict'", "]", "\n", "args", "=", "check_point", "[", "'config'", "]", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "model", ".", "to", "(", "args", ".", "device", ")", "\n", "", "model", ".", "eval", "(", ")", "\n", "y_pred", "=", "[", "]", "\n", "y_true", "=", "[", "]", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "batch_idx", ",", "(", "data", ",", "target", ")", "in", "enumerate", "(", "data_loader", ")", ":", "\n", "                ", "data", "=", "data", "[", "...", ",", ":", "args", ".", "input_dim", "]", "\n", "label", "=", "target", "[", "...", ",", ":", "args", ".", "output_dim", "]", "\n", "output", "=", "model", "(", "data", ",", "target", ",", "teacher_forcing_ratio", "=", "0", ")", "\n", "y_true", ".", "append", "(", "label", ")", "\n", "y_pred", ".", "append", "(", "output", ")", "\n", "", "", "y_true", "=", "scaler", ".", "inverse_transform", "(", "torch", ".", "cat", "(", "y_true", ",", "dim", "=", "0", ")", ")", "\n", "if", "args", ".", "real_value", ":", "\n", "            ", "y_pred", "=", "torch", ".", "cat", "(", "y_pred", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "y_pred", "=", "scaler", ".", "inverse_transform", "(", "torch", ".", "cat", "(", "y_pred", ",", "dim", "=", "0", ")", ")", "\n", "", "np", ".", "save", "(", "'./{}_true.npy'", ".", "format", "(", "args", ".", "dataset", ")", ",", "y_true", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "np", ".", "save", "(", "'./{}_pred.npy'", ".", "format", "(", "args", ".", "dataset", ")", ",", "y_pred", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "for", "t", "in", "range", "(", "y_true", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "mae", ",", "rmse", ",", "mape", ",", "_", ",", "_", "=", "All_Metrics", "(", "y_pred", "[", ":", ",", "t", ",", "...", "]", ",", "y_true", "[", ":", ",", "t", ",", "...", "]", ",", "\n", "args", ".", "mae_thresh", ",", "args", ".", "mape_thresh", ")", "\n", "logger", ".", "info", "(", "\"Horizon {:02d}, MAE: {:.2f}, RMSE: {:.2f}, MAPE: {:.4f}%\"", ".", "format", "(", "\n", "t", "+", "1", ",", "mae", ",", "rmse", ",", "mape", "*", "100", ")", ")", "\n", "", "mae", ",", "rmse", ",", "mape", ",", "_", ",", "_", "=", "All_Metrics", "(", "y_pred", ",", "y_true", ",", "args", ".", "mae_thresh", ",", "args", ".", "mape_thresh", ")", "\n", "logger", ".", "info", "(", "\"Average Horizon, MAE: {:.2f}, RMSE: {:.2f}, MAPE: {:.4f}%\"", ".", "format", "(", "\n", "mae", ",", "rmse", ",", "mape", "*", "100", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.BasicTrainer.Trainer._compute_sampling_threshold": [[197, 206], ["math.exp"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_compute_sampling_threshold", "(", "global_step", ",", "k", ")", ":", "\n", "        ", "\"\"\"\n        Computes the sampling probability for scheduled sampling using inverse sigmoid.\n        :param global_step:\n        :param k:\n        :return:\n        \"\"\"", "\n", "return", "k", "/", "(", "k", "+", "math", ".", "exp", "(", "global_step", "/", "k", ")", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.Run.masked_mae_loss": [[35, 43], ["lib.metrics.MAE_torch", "scaler.inverse_transform", "scaler.inverse_transform"], "function", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.metrics.MAE_torch", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform", "home.repos.pwc.inspect_result.LeiBAI_AGCRN.lib.normalization.ColumnMinMaxScaler.inverse_transform"], ["def", "masked_mae_loss", "(", "scaler", ",", "mask_value", ")", ":", "\n", "    ", "def", "loss", "(", "preds", ",", "labels", ")", ":", "\n", "        ", "if", "scaler", ":", "\n", "            ", "preds", "=", "scaler", ".", "inverse_transform", "(", "preds", ")", "\n", "labels", "=", "scaler", ".", "inverse_transform", "(", "labels", ")", "\n", "", "mae", "=", "MAE_torch", "(", "pred", "=", "preds", ",", "true", "=", "labels", ",", "mask_value", "=", "mask_value", ")", "\n", "return", "mae", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRN.AVWDCRNN.__init__": [[6, 16], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "AGCRN.AVWDCRNN.dcrnn_cells.append", "range", "model.AGCRNCell.AGCRNCell", "AGCRN.AVWDCRNN.dcrnn_cells.append", "model.AGCRNCell.AGCRNCell"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "node_num", ",", "dim_in", ",", "dim_out", ",", "cheb_k", ",", "embed_dim", ",", "num_layers", "=", "1", ")", ":", "\n", "        ", "super", "(", "AVWDCRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "num_layers", ">=", "1", ",", "'At least one DCRNN layer in the Encoder.'", "\n", "self", ".", "node_num", "=", "node_num", "\n", "self", ".", "input_dim", "=", "dim_in", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "dcrnn_cells", "=", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "dcrnn_cells", ".", "append", "(", "AGCRNCell", "(", "node_num", ",", "dim_in", ",", "dim_out", ",", "cheb_k", ",", "embed_dim", ")", ")", "\n", "for", "_", "in", "range", "(", "1", ",", "num_layers", ")", ":", "\n", "            ", "self", ".", "dcrnn_cells", ".", "append", "(", "AGCRNCell", "(", "node_num", ",", "dim_out", ",", "dim_out", ",", "cheb_k", ",", "embed_dim", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRN.AVWDCRNN.forward": [[17, 36], ["range", "range", "output_hidden.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "inner_states.append"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "init_state", ",", "node_embeddings", ")", ":", "\n", "#shape of x: (B, T, N, D)", "\n", "#shape of init_state: (num_layers, B, N, hidden_dim)", "\n", "        ", "assert", "x", ".", "shape", "[", "2", "]", "==", "self", ".", "node_num", "and", "x", ".", "shape", "[", "3", "]", "==", "self", ".", "input_dim", "\n", "seq_length", "=", "x", ".", "shape", "[", "1", "]", "\n", "current_inputs", "=", "x", "\n", "output_hidden", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "state", "=", "init_state", "[", "i", "]", "\n", "inner_states", "=", "[", "]", "\n", "for", "t", "in", "range", "(", "seq_length", ")", ":", "\n", "                ", "state", "=", "self", ".", "dcrnn_cells", "[", "i", "]", "(", "current_inputs", "[", ":", ",", "t", ",", ":", ",", ":", "]", ",", "state", ",", "node_embeddings", ")", "\n", "inner_states", ".", "append", "(", "state", ")", "\n", "", "output_hidden", ".", "append", "(", "state", ")", "\n", "current_inputs", "=", "torch", ".", "stack", "(", "inner_states", ",", "dim", "=", "1", ")", "\n", "#current_inputs: the outputs of last layer: (B, T, N, hidden_dim)", "\n", "#output_hidden: the last state for each layer: (num_layers, B, N, hidden_dim)", "\n", "#last_state: (B, N, hidden_dim)", "\n", "", "return", "current_inputs", ",", "output_hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRN.AVWDCRNN.init_hidden": [[37, 42], ["range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "init_states.append", "AGCRN.AVWDCRNN.dcrnn_cells[].init_hidden_state"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRNCell.AGCRNCell.init_hidden_state"], ["", "def", "init_hidden", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "init_states", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "init_states", ".", "append", "(", "self", ".", "dcrnn_cells", "[", "i", "]", ".", "init_hidden_state", "(", "batch_size", ")", ")", "\n", "", "return", "torch", ".", "stack", "(", "init_states", ",", "dim", "=", "0", ")", "#(num_layers, B, N, hidden_dim)", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRN.AGCRN.__init__": [[44, 61], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "AGCRN.AVWDCRNN", "torch.Conv2d", "torch.Conv2d", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "super", "(", "AGCRN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_node", "=", "args", ".", "num_nodes", "\n", "self", ".", "input_dim", "=", "args", ".", "input_dim", "\n", "self", ".", "hidden_dim", "=", "args", ".", "rnn_units", "\n", "self", ".", "output_dim", "=", "args", ".", "output_dim", "\n", "self", ".", "horizon", "=", "args", ".", "horizon", "\n", "self", ".", "num_layers", "=", "args", ".", "num_layers", "\n", "\n", "self", ".", "default_graph", "=", "args", ".", "default_graph", "\n", "self", ".", "node_embeddings", "=", "nn", ".", "Parameter", "(", "torch", ".", "randn", "(", "self", ".", "num_node", ",", "args", ".", "embed_dim", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n", "self", ".", "encoder", "=", "AVWDCRNN", "(", "args", ".", "num_nodes", ",", "args", ".", "input_dim", ",", "args", ".", "rnn_units", ",", "args", ".", "cheb_k", ",", "\n", "args", ".", "embed_dim", ",", "args", ".", "num_layers", ")", "\n", "\n", "#predictor", "\n", "self", ".", "end_conv", "=", "nn", ".", "Conv2d", "(", "1", ",", "args", ".", "horizon", "*", "self", ".", "output_dim", ",", "kernel_size", "=", "(", "1", ",", "self", ".", "hidden_dim", ")", ",", "bias", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRN.AGCRN.forward": [[62, 77], ["AGCRN.AGCRN.encoder.init_hidden", "AGCRN.AGCRN.encoder", "AGCRN.AGCRN.end_conv", "output.permute.permute.squeeze().reshape", "output.permute.permute.permute", "output.permute.permute.squeeze"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCRN.AVWDCRNN.init_hidden"], ["", "def", "forward", "(", "self", ",", "source", ",", "targets", ",", "teacher_forcing_ratio", "=", "0.5", ")", ":", "\n", "#source: B, T_1, N, D", "\n", "#target: B, T_2, N, D", "\n", "#supports = F.softmax(F.relu(torch.mm(self.nodevec1, self.nodevec1.transpose(0,1))), dim=1)", "\n", "\n", "        ", "init_state", "=", "self", ".", "encoder", ".", "init_hidden", "(", "source", ".", "shape", "[", "0", "]", ")", "\n", "output", ",", "_", "=", "self", ".", "encoder", "(", "source", ",", "init_state", ",", "self", ".", "node_embeddings", ")", "#B, T, N, hidden", "\n", "output", "=", "output", "[", ":", ",", "-", "1", ":", ",", ":", ",", ":", "]", "#B, 1, N, hidden", "\n", "\n", "#CNN based predictor", "\n", "output", "=", "self", ".", "end_conv", "(", "(", "output", ")", ")", "#B, T*C, N, 1", "\n", "output", "=", "output", ".", "squeeze", "(", "-", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "horizon", ",", "self", ".", "output_dim", ",", "self", ".", "num_node", ")", "\n", "output", "=", "output", ".", "permute", "(", "0", ",", "1", ",", "3", ",", "2", ")", "#B, T, N, C", "\n", "\n", "return", "output", "", "", "", ""]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.__init__": [[6, 11], ["torch.Module.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim_in", ",", "dim_out", ",", "cheb_k", ",", "embed_dim", ")", ":", "\n", "        ", "super", "(", "AVWGCN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cheb_k", "=", "cheb_k", "\n", "self", ".", "weights_pool", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "embed_dim", ",", "cheb_k", ",", "dim_in", ",", "dim_out", ")", ")", "\n", "self", ".", "bias_pool", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "embed_dim", ",", "dim_out", ")", ")", "\n", "", "def", "forward", "(", "self", ",", "x", ",", "node_embeddings", ")", ":", "\n"]], "home.repos.pwc.inspect_result.LeiBAI_AGCRN.model.AGCN.AVWGCN.forward": [[11, 27], ["torch.softmax", "torch.softmax", "torch.softmax", "range", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "x_g.permute.permute.permute", "torch.relu", "torch.relu", "torch.relu", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "torch.eye().to", "support_set.append", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "node_embeddings.transpose", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "node_embeddings", ")", ":", "\n", "#x shaped[B, N, C], node_embeddings shaped [N, D] -> supports shaped [N, N]", "\n", "#output shape [B, N, C]", "\n", "        ", "node_num", "=", "node_embeddings", ".", "shape", "[", "0", "]", "\n", "supports", "=", "F", ".", "softmax", "(", "F", ".", "relu", "(", "torch", ".", "mm", "(", "node_embeddings", ",", "node_embeddings", ".", "transpose", "(", "0", ",", "1", ")", ")", ")", ",", "dim", "=", "1", ")", "\n", "support_set", "=", "[", "torch", ".", "eye", "(", "node_num", ")", ".", "to", "(", "supports", ".", "device", ")", ",", "supports", "]", "\n", "#default cheb_k = 3", "\n", "for", "k", "in", "range", "(", "2", ",", "self", ".", "cheb_k", ")", ":", "\n", "            ", "support_set", ".", "append", "(", "torch", ".", "matmul", "(", "2", "*", "supports", ",", "support_set", "[", "-", "1", "]", ")", "-", "support_set", "[", "-", "2", "]", ")", "\n", "", "supports", "=", "torch", ".", "stack", "(", "support_set", ",", "dim", "=", "0", ")", "\n", "weights", "=", "torch", ".", "einsum", "(", "'nd,dkio->nkio'", ",", "node_embeddings", ",", "self", ".", "weights_pool", ")", "#N, cheb_k, dim_in, dim_out", "\n", "bias", "=", "torch", ".", "matmul", "(", "node_embeddings", ",", "self", ".", "bias_pool", ")", "#N, dim_out", "\n", "x_g", "=", "torch", ".", "einsum", "(", "\"knm,bmc->bknc\"", ",", "supports", ",", "x", ")", "#B, cheb_k, N, dim_in", "\n", "x_g", "=", "x_g", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "# B, N, cheb_k, dim_in", "\n", "x_gconv", "=", "torch", ".", "einsum", "(", "'bnki,nkio->bno'", ",", "x_g", ",", "weights", ")", "+", "bias", "#b, N, dim_out", "\n", "return", "x_gconv", "", "", "", ""]]}