{"home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.base.Base.__init__": [[14, 28], ["base.Base.set_params", "base.Base.print_init"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.base.Base.print_init"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for this model.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "self", ".", "verbose_init_arg", "=", "verbose", "\n", "self", ".", "set_params", "(", "params", ")", "\n", "self", ".", "print_pre", "=", "'     * '", "\n", "if", "self", ".", "params", ".", "verbose", ":", "\n", "            ", "self", ".", "print_init", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.base.Base.set_params": [[29, 37], ["misc_util.dict_to_namespace", "argparse.Namespace", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for this model.\"\"\"", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "# Set self.params", "\n", "self", ".", "params", "=", "Namespace", "(", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'Base'", ")", "\n", "self", ".", "params", ".", "verbose", "=", "getattr", "(", "params", ",", "'verbose'", ",", "self", ".", "verbose_init_arg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.base.Base.print_init": [[38, 41], ["print", "str"], "methods", ["None"], ["", "def", "print_init", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print a description string when object created.\"\"\"", "\n", "print", "(", "'*[INFO] Initialized '", "+", "str", "(", "self", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.base.Base.set_print_params": [[42, 46], ["hasattr", "copy.deepcopy"], "methods", ["None"], ["", "def", "set_print_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set self.print_params.\"\"\"", "\n", "if", "not", "hasattr", "(", "self", ",", "'print_params'", ")", ":", "\n", "            ", "self", ".", "print_params", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.base.Base.__str__": [[47, 50], ["base.Base.set_print_params"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScanRandGap.set_print_params"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "self", ".", "set_print_params", "(", ")", "\n", "return", "f'{self.params.name} with params={self.print_params}'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.Vertex.__init__": [[6, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "index", ":", "int", ",", "position", ":", "np", ".", "array", ",", "neighbors", "=", "None", ")", ":", "\n", "        ", "self", ".", "index", "=", "index", "\n", "self", ".", "position", "=", "position", "\n", "self", ".", "neighbors", "=", "[", "]", "if", "neighbors", "is", "None", "else", "neighbors", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.Vertex.__repr__": [[11, 13], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"({self.index}, {[n.index for n in self.neighbors]})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.Vertex.__lt__": [[14, 16], ["None"], "methods", ["None"], ["", "def", "__lt__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "position", "[", "0", "]", "<", "other", ".", "position", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.make_vertices": [[18, 27], ["range", "graph.Vertex", "range", "enumerate", "vertices[].neighbors.append", "vertices[].neighbors.append"], "function", ["None"], ["", "", "def", "make_vertices", "(", "positions", ":", "np", ".", "array", ",", "has_edge", ":", "np", ".", "array", ")", ":", "\n", "    ", "n", "=", "positions", ".", "shape", "[", "0", "]", "\n", "vertices", "=", "[", "Vertex", "(", "i", ",", "p", ")", "for", "i", ",", "p", "in", "enumerate", "(", "positions", ")", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "n", ")", ":", "\n", "            ", "if", "has_edge", "[", "i", ",", "j", "]", ":", "\n", "                ", "vertices", "[", "i", "]", ".", "neighbors", ".", "append", "(", "vertices", "[", "j", "]", ")", "\n", "vertices", "[", "j", "]", ".", "neighbors", ".", "append", "(", "vertices", "[", "i", "]", ")", "\n", "", "", "", "return", "vertices", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.make_edges": [[29, 35], ["edges.append"], "function", ["None"], ["", "def", "make_edges", "(", "vertices", ":", "List", "[", "Vertex", "]", ")", ":", "\n", "    ", "edges", "=", "[", "]", "\n", "for", "v", "in", "vertices", ":", "\n", "        ", "for", "n", "in", "v", ".", "neighbors", ":", "\n", "            ", "edges", ".", "append", "(", "(", "v", ".", "position", ",", "n", ".", "position", ")", ")", "\n", "", "", "return", "edges", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.farthest_pair": [[37, 48], ["len", "range", "float", "range", "distance_func"], "function", ["None"], ["", "def", "farthest_pair", "(", "vertices", ":", "List", "[", "Vertex", "]", ",", "distance_func", ")", ":", "\n", "    ", "n", "=", "len", "(", "vertices", ")", "\n", "max_dist", "=", "-", "float", "(", "\"inf\"", ")", "\n", "pair", "=", "(", "None", ",", "None", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "n", ")", ":", "\n", "            ", "dist", "=", "distance_func", "(", "vertices", "[", "i", "]", ",", "vertices", "[", "j", "]", ")", "\n", "if", "dist", ">", "max_dist", ":", "\n", "                ", "pair", "=", "vertices", "[", "i", "]", ",", "vertices", "[", "j", "]", "\n", "max_dist", "=", "dist", "\n", "", "", "", "return", "pair", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.backtrack": [[50, 57], ["hasattr", "path.append"], "function", ["None"], ["", "def", "backtrack", "(", "goal", ":", "Vertex", ")", ":", "\n", "    ", "v", "=", "goal", "\n", "path", "=", "[", "v", "]", "\n", "while", "hasattr", "(", "v", ",", "\"prev\"", ")", "and", "v", ".", "prev", "is", "not", "None", ":", "\n", "        ", "path", ".", "append", "(", "v", ".", "prev", ")", "\n", "v", "=", "v", ".", "prev", "\n", "", "return", "path", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.backtrack_indices": [[59, 66], ["path.append"], "function", ["None"], ["", "def", "backtrack_indices", "(", "goal", ":", "int", ",", "prev", ":", "List", "[", "int", "]", ")", ":", "\n", "    ", "v", "=", "goal", "\n", "path", "=", "[", "v", "]", "\n", "while", "prev", "[", "v", "]", "is", "not", "None", ":", "\n", "        ", "path", ".", "append", "(", "prev", "[", "v", "]", ")", "\n", "v", "=", "prev", "[", "v", "]", "\n", "", "return", "path", "[", ":", ":", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.valid_path": [[68, 73], ["range", "len"], "function", ["None"], ["", "def", "valid_path", "(", "path", ":", "List", "[", "Vertex", "]", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "1", ",", "len", "(", "path", ")", ")", ":", "\n", "        ", "if", "path", "[", "i", "]", "not", "in", "path", "[", "i", "-", "1", "]", ".", "neighbors", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.edges_of_path": [[75, 81], ["graph.valid_path", "range", "edges.append", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.valid_path"], ["", "def", "edges_of_path", "(", "path", ":", "List", "[", "Vertex", "]", ")", ":", "\n", "    ", "assert", "valid_path", "(", "path", ")", "\n", "edges", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "        ", "edges", ".", "append", "(", "(", "path", "[", "i", "]", ".", "position", ",", "path", "[", "i", "+", "1", "]", ".", "position", ")", ")", "\n", "", "return", "edges", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.cost_of_path": [[83, 89], ["graph.valid_path", "range", "distance_func", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.valid_path"], ["", "def", "cost_of_path", "(", "path", ":", "List", "[", "Vertex", "]", ",", "distance_func", ")", ":", "\n", "    ", "assert", "valid_path", "(", "path", ")", "\n", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "        ", "cost", "+=", "distance_func", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "\n", "", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path": [[91, 94], ["numpy.stack"], "function", ["None"], ["", "def", "positions_of_path", "(", "path", ")", ":", "\n", "    ", "positions", "=", "[", "v", ".", "position", "for", "v", "in", "path", "]", "\n", "return", "np", ".", "stack", "(", "positions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.make_grid": [[96, 124], ["numpy.meshgrid", "numpy.stack", "len", "range", "numpy.array", "graph.make_vertices", "graph.make_edges", "numpy.linspace", "numpy.linspace", "range", "x1.flatten", "x2.flatten", "range", "range", "abs", "abs", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.make_vertices", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.make_edges"], ["", "def", "make_grid", "(", "grid_size", ",", "x1_lims", "=", "(", "-", "1", ",", "1", ")", ",", "x2_lims", "=", "(", "-", "1", ",", "1", ")", ")", ":", "\n", "    ", "x1", ",", "x2", "=", "np", ".", "meshgrid", "(", "\n", "np", ".", "linspace", "(", "*", "x1_lims", ",", "grid_size", ")", ",", "np", ".", "linspace", "(", "*", "x2_lims", ",", "grid_size", ")", "\n", ")", "\n", "positions", "=", "np", ".", "stack", "(", "[", "x1", ".", "flatten", "(", ")", ",", "x2", ".", "flatten", "(", ")", "]", ",", "axis", "=", "-", "1", ")", "\n", "n", "=", "len", "(", "positions", ")", "\n", "\n", "has_edge", "=", "[", "[", "False", "for", "_", "in", "range", "(", "n", ")", "]", "for", "_", "in", "range", "(", "n", ")", "]", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "n", ")", ":", "\n", "            ", "if", "(", "abs", "(", "i", "-", "j", ")", "==", "1", ")", "and", "(", "\n", "j", "%", "grid_size", "!=", "0", "\n", ")", ":", "# neighbors cardinal directions", "\n", "                ", "has_edge", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "", "elif", "abs", "(", "i", "-", "j", ")", "==", "grid_size", ":", "# vertices on the edge of grid", "\n", "                ", "has_edge", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "", "elif", "(", "abs", "(", "j", "-", "i", ")", "==", "grid_size", "+", "1", ")", "and", "(", "j", "%", "grid_size", "!=", "0", ")", ":", "# diagonals", "\n", "                ", "has_edge", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "", "elif", "(", "abs", "(", "j", "-", "i", ")", "==", "grid_size", "-", "1", ")", "and", "(", "i", "%", "grid_size", "!=", "0", ")", ":", "# diagonals", "\n", "                ", "has_edge", "[", "i", "]", "[", "j", "]", "=", "True", "\n", "", "else", ":", "\n", "                ", "has_edge", "[", "i", "]", "[", "j", "]", "=", "False", "\n", "", "", "", "has_edge", "=", "np", ".", "array", "(", "has_edge", ")", "\n", "\n", "vertices", "=", "make_vertices", "(", "positions", ",", "has_edge", ")", "\n", "edges", "=", "make_edges", "(", "vertices", ")", "\n", "\n", "return", "positions", ",", "vertices", ",", "edges", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.shoelace": [[126, 138], ["all", "numpy.stack", "numpy.abs", "numpy.sum", "numpy.roll", "numpy.roll"], "function", ["None"], ["", "def", "shoelace", "(", "vertices", ":", "List", "[", "np", ".", "array", "]", ")", ":", "\n", "    ", "\"\"\"Computes the shoelace algorithm on `vertices`\n    Assumes that `vertices` contains the vertices of a 2D polygon.\n    Here we take the absolute value of the result to be independent of\n    chirality (i.e. counter-clockwise vs clockwise).\n\n    See https://en.wikipedia.org/wiki/Shoelace_formula for more details\n    \"\"\"", "\n", "assert", "all", "(", "v", ".", "ndim", "==", "1", "for", "v", "in", "vertices", ")", "\n", "positions", "=", "np", ".", "stack", "(", "vertices", ")", "\n", "x", ",", "y", "=", "positions", "[", ":", ",", "0", "]", ",", "positions", "[", ":", ",", "1", "]", "\n", "return", "np", ".", "abs", "(", "np", ".", "sum", "(", "x", "*", "np", ".", "roll", "(", "y", ",", "1", ")", "-", "np", ".", "roll", "(", "x", ",", "1", ")", "*", "y", ")", ")", "/", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.area_of_polygons": [[140, 170], ["all", "all", "range", "sum", "polygons.append", "len", "len", "enumerate", "enumerate", "len", "graph.shoelace"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.shoelace"], ["", "def", "area_of_polygons", "(", "path1", ":", "List", "[", "Vertex", "]", ",", "path2", ":", "List", "[", "Vertex", "]", ")", ":", "\n", "    ", "\"\"\"Computes the area of the polygons created by the area between two paths\n    from the same start and end node on a graph embedded in R^2.\n\n    We first find each polygon and then find each of the area using the shoelace algorithm.\n\n    Some polygons will have vertices listed clockwise and some will have vertices listed counterclockwise\n    \"\"\"", "\n", "assert", "len", "(", "path1", ")", ">", "0", "and", "len", "(", "path2", ")", ">", "0", "\n", "assert", "all", "(", "v", ".", "position", ".", "ndim", "==", "1", "for", "v", "in", "path1", ")", "\n", "assert", "all", "(", "v", ".", "position", ".", "ndim", "==", "1", "for", "v", "in", "path2", ")", "\n", "assert", "path1", "[", "0", "]", ".", "index", "==", "path2", "[", "0", "]", ".", "index", "\n", "assert", "path1", "[", "-", "1", "]", ".", "index", "==", "path2", "[", "-", "1", "]", ".", "index", "\n", "\n", "# find intersections in quadratic time", "\n", "intersections", "=", "[", "\n", "(", "i", ",", "j", ")", "\n", "for", "i", ",", "u", "in", "enumerate", "(", "path1", ")", "\n", "for", "j", ",", "v", "in", "enumerate", "(", "path2", ")", "\n", "if", "v", ".", "index", "==", "u", ".", "index", "\n", "]", "\n", "polygons", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "intersections", ")", "-", "1", ")", ":", "\n", "        ", "i", ",", "j", "=", "intersections", "[", "k", "]", "\n", "i_", ",", "j_", "=", "intersections", "[", "k", "+", "1", "]", "\n", "polygon", "=", "path1", "[", "i", ":", "i_", "]", "+", "path2", "[", "j_", ":", "j", ":", "-", "1", "]", "\n", "polygons", ".", "append", "(", "polygon", ")", "\n", "\n", "", "area", "=", "sum", "(", "shoelace", "(", "[", "v", ".", "position", "for", "v", "in", "polygon", "]", ")", "for", "polygon", "in", "polygons", ")", "\n", "return", "area", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.jaccard_similarity": [[172, 178], ["set", "set", "float", "len", "len", "set.intersection", "set.union"], "function", ["None"], ["", "def", "jaccard_similarity", "(", "list1", ",", "list2", ")", ":", "\n", "    ", "\"\"\"Return jaccard similarity between two sets.\"\"\"", "\n", "s1", "=", "set", "(", "list1", ")", "\n", "s2", "=", "set", "(", "list2", ")", "\n", "jac_sim", "=", "float", "(", "len", "(", "s1", ".", "intersection", "(", "s2", ")", ")", "/", "len", "(", "s1", ".", "union", "(", "s2", ")", ")", ")", "\n", "return", "jac_sim", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.suppress_stdout_stderr.__init__": [[39, 45], ["os.open", "os.dup", "os.dup", "range"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "# Open a pair of null files", "\n", "        ", "self", ".", "null_fds", "=", "[", "os", ".", "open", "(", "os", ".", "devnull", ",", "os", ".", "O_RDWR", ")", "for", "x", "in", "range", "(", "2", ")", "]", "\n", "\n", "# Save the actual stdout (1) and stderr (2) file descriptors.", "\n", "self", ".", "save_fds", "=", "[", "os", ".", "dup", "(", "1", ")", ",", "os", ".", "dup", "(", "2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.suppress_stdout_stderr.__enter__": [[46, 50], ["os.dup2", "os.dup2"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "# Assign the null pointers to stdout and stderr.", "\n", "        ", "os", ".", "dup2", "(", "self", ".", "null_fds", "[", "0", "]", ",", "1", ")", "\n", "os", ".", "dup2", "(", "self", ".", "null_fds", "[", "1", "]", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.suppress_stdout_stderr.__exit__": [[51, 59], ["os.dup2", "os.dup2", "os.close"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "*", "_", ")", ":", "\n", "# Re-assign the real stdout/stderr back to (1) and (2)", "\n", "        ", "os", ".", "dup2", "(", "self", ".", "save_fds", "[", "0", "]", ",", "1", ")", "\n", "os", ".", "dup2", "(", "self", ".", "save_fds", "[", "1", "]", ",", "2", ")", "\n", "\n", "# Close the null files", "\n", "for", "fd", "in", "self", ".", "null_fds", "+", "self", ".", "save_fds", ":", "\n", "            ", "os", ".", "close", "(", "fd", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace": [[9, 28], ["isinstance", "argparse.Namespace"], "function", ["None"], ["def", "dict_to_namespace", "(", "params", ")", ":", "\n", "    ", "\"\"\"\n    If params is a dict, convert it to a Namespace, and return it.\n\n    Parameters\n    ----------\n    params : Namespace_or_dict\n        Namespace or dict.\n\n    Returns\n    -------\n    params : Namespace\n        Namespace of params\n    \"\"\"", "\n", "# If params is a dict, convert to Namespace", "\n", "if", "isinstance", "(", "params", ",", "dict", ")", ":", "\n", "        ", "params", "=", "Namespace", "(", "**", "params", ")", "\n", "\n", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.timing.Timer.__init__": [[14, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "name", "=", "None", ",", "filename", "=", "None", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "filename", "=", "filename", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.timing.Timer.__enter__": [[18, 20], ["time.time"], "methods", ["None"], ["", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "self", ".", "tstart", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.timing.Timer.__exit__": [[21, 29], ["print", "time.time", "open", "print", "str", "datetime.datetime.now"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n", "        ", "message", "=", "'Elapsed: %.2f seconds'", "%", "(", "time", ".", "time", "(", ")", "-", "self", ".", "tstart", ")", "\n", "if", "self", ".", "name", ":", "\n", "            ", "message", "=", "'*[TIME] [%s] '", "%", "self", ".", "name", "+", "message", "\n", "", "print", "(", "message", ")", "\n", "if", "self", ".", "filename", ":", "\n", "            ", "with", "open", "(", "self", ".", "filename", ",", "'a'", ")", "as", "file", ":", "\n", "                ", "print", "(", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", "+", "\": \"", ",", "message", ",", "file", "=", "file", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.domain_util.unif_random_sample_domain": [[8, 13], ["numpy.random.uniform", "list", "numpy.array"], "function", ["None"], ["def", "unif_random_sample_domain", "(", "domain", ",", "n", "=", "1", ")", ":", "\n", "    ", "\"\"\"Draws a sample uniformly at random from domain (a list of tuple bounds).\"\"\"", "\n", "list_of_arr_per_dim", "=", "[", "np", ".", "random", ".", "uniform", "(", "dom", "[", "0", "]", ",", "dom", "[", "1", "]", ",", "n", ")", "for", "dom", "in", "domain", "]", "\n", "list_of_list_per_sample", "=", "[", "list", "(", "l", ")", "for", "l", "in", "np", ".", "array", "(", "list_of_arr_per_dim", ")", ".", "T", "]", "\n", "return", "list_of_list_per_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.domain_util.project_to_domain": [[15, 22], ["numpy.array().reshape", "numpy.clip", "list", "numpy.array"], "function", ["None"], ["", "def", "project_to_domain", "(", "x", ",", "domain", ")", ":", "\n", "    ", "\"\"\"Project x, a list of scalars, to be within domain (a list of tuple bounds).\"\"\"", "\n", "x_arr", "=", "np", ".", "array", "(", "x", ")", ".", "reshape", "(", "-", "1", ")", "\n", "min_list", "=", "[", "tup", "[", "0", "]", "for", "tup", "in", "domain", "]", "\n", "max_list", "=", "[", "tup", "[", "1", "]", "for", "tup", "in", "domain", "]", "\n", "x_arr_clip", "=", "np", ".", "clip", "(", "x_arr", ",", "min_list", ",", "max_list", ")", "\n", "return", "list", "(", "x_arr_clip", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer.__init__": [[13, 25], ["data_transform.DataTransformer._set_y_data", "data_transform.DataTransformer._set_y_transformers", "data_transform.DataTransformer._set_verbose"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._set_y_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._set_y_transformers", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._set_verbose"], ["def", "__init__", "(", "self", ",", "data", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        data : Namespace\n            Namespace containing data.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "self", ".", "_set_y_data", "(", "data", ")", "\n", "self", ".", "_set_y_transformers", "(", ")", "\n", "self", ".", "_set_verbose", "(", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._set_y_data": [[26, 37], ["numpy.array", "data.y.reshape", "len", "ValueError"], "methods", ["None"], ["", "def", "_set_y_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set self.y_data.\"\"\"", "\n", "\n", "# Ensure data.y is a numpy array", "\n", "data", ".", "y", "=", "np", ".", "array", "(", "data", ".", "y", ")", "\n", "\n", "if", "len", "(", "data", ".", "y", ".", "shape", ")", ">", "1", ":", "\n", "            ", "if", "not", "(", "data", ".", "y", ".", "shape", "[", "0", "]", "==", "1", "or", "data", ".", "y", ".", "shape", "[", "1", "]", "==", "1", ")", ":", "\n", "                ", "raise", "ValueError", "(", "'data.y has incorrect shape.'", ")", "\n", "", "", "self", ".", "y_data_orig_shape", "=", "data", ".", "y", ".", "shape", "\n", "self", ".", "y_data", "=", "data", ".", "y", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._set_y_transformers": [[38, 42], ["sklearn.preprocessing.StandardScaler", "data_transform.DataTransformer.ss.fit"], "methods", ["None"], ["", "def", "_set_y_transformers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set transformers for self.y_data.\"\"\"", "\n", "self", ".", "ss", "=", "StandardScaler", "(", ")", "\n", "self", ".", "ss", ".", "fit", "(", "self", ".", "y_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._set_verbose": [[43, 48], ["data_transform.DataTransformer._print_str"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._print_str"], ["", "def", "_set_verbose", "(", "self", ",", "verbose", ")", ":", "\n", "        ", "\"\"\"Set verbose options.\"\"\"", "\n", "self", ".", "verbose", "=", "verbose", "\n", "if", "self", ".", "verbose", ":", "\n", "            ", "self", ".", "_print_str", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer.transform_y_data": [[49, 66], ["y_data.reshape", "data_transform.DataTransformer.ss.transform", "data_transform.DataTransformer.reshape"], "methods", ["None"], ["", "", "def", "transform_y_data", "(", "self", ",", "y_data", "=", "None", ")", ":", "\n", "        ", "\"\"\"Return transformed y_data (default self.y_data).\"\"\"", "\n", "\n", "# Set y_data and save y_data_orig_shape", "\n", "if", "y_data", "is", "None", ":", "\n", "            ", "y_data", "=", "self", ".", "y_data", "\n", "y_data_orig_shape", "=", "self", ".", "y_data_orig_shape", "\n", "", "else", ":", "\n", "            ", "y_data_orig_shape", "=", "y_data", ".", "shape", "\n", "\n", "# Transform y_data column", "\n", "", "y_data_col", "=", "y_data", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "y_trans_col", "=", "self", ".", "ss", ".", "transform", "(", "y_data_col", ")", "\n", "\n", "# Transform y_trans back to original shape", "\n", "y_trans", "=", "y_trans_col", ".", "reshape", "(", "y_data_orig_shape", ")", "\n", "return", "y_trans", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer.inv_transform_y_data": [[67, 78], ["y_data.reshape", "data_transform.DataTransformer.ss.inverse_transform", "data_transform.DataTransformer.reshape"], "methods", ["None"], ["", "def", "inv_transform_y_data", "(", "self", ",", "y_data", ")", ":", "\n", "        ", "\"\"\"Return inverse transform of y_data.\"\"\"", "\n", "y_data_orig_shape", "=", "y_data", ".", "shape", "\n", "\n", "# Inverse transform y_data column", "\n", "y_data_col", "=", "y_data", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "y_inv_trans_col", "=", "self", ".", "ss", ".", "inverse_transform", "(", "y_data_col", ")", "\n", "\n", "# Transform y_inv_trans back to original shape", "\n", "y_inv_trans", "=", "y_inv_trans_col", ".", "reshape", "(", "y_data_orig_shape", ")", "\n", "return", "y_inv_trans", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.data_transform.DataTransformer._print_str": [[79, 82], ["print"], "methods", ["None"], ["", "def", "_print_str", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print a description string.\"\"\"", "\n", "print", "(", "'*DataTransformer'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.set_params": [[17, 22], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the execution path.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'ExePath'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.init_path_with_model": [[23, 28], ["copy.deepcopy", "copy.deepcopy", "exe_path.ExePath.reset_exe_path"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.reset_exe_path"], ["", "def", "init_path_with_model", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Set self.model, self.exe_path, self.all_obs.\"\"\"", "\n", "self", ".", "model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "self", ".", "data", "=", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "data", ")", "\n", "self", ".", "reset_exe_path", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.reset_exe_path": [[29, 32], ["argparse.Namespace"], "methods", ["None"], ["", "def", "reset_exe_path", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set self.exe_path.\"\"\"", "\n", "self", ".", "exe_path", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.set_all_obs": [[33, 39], ["argparse.Namespace"], "methods", ["None"], ["", "def", "set_all_obs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update self.all_obs given current self.model.data and self.exe_path.\"\"\"", "\n", "all_obs", "=", "Namespace", "(", ")", "\n", "all_obs", ".", "x", "=", "self", ".", "data", ".", "x", "+", "self", ".", "exe_path", ".", "x", "\n", "all_obs", ".", "y", "=", "self", ".", "data", ".", "y", "+", "self", ".", "exe_path", ".", "y", "\n", "self", ".", "all_obs", "=", "all_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.next_step": [[40, 50], ["exe_path.ExePath.set_all_obs", "exe_path.ExePath.model.set_data", "exe_path.ExePath.model.sample_post_pred", "exe_path.ExePath.exe_path.x.append", "exe_path.ExePath.exe_path.y.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_all_obs", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_pred"], ["", "def", "next_step", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Take next step of execution path on input x, return output y.\"\"\"", "\n", "self", ".", "set_all_obs", "(", ")", "\n", "self", ".", "model", ".", "set_data", "(", "self", ".", "all_obs", ")", "\n", "y", "=", "self", ".", "model", ".", "sample_post_pred", "(", "x", ",", "1", ")", "\n", "y", "=", "y", "[", "0", "]", "\n", "\n", "self", ".", "exe_path", ".", "x", ".", "append", "(", "x", ")", "\n", "self", ".", "exe_path", ".", "y", ".", "append", "(", "y", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.get_y": [[51, 54], ["exe_path.ExePath.next_step"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.exe_path.ExePath.next_step"], ["", "def", "get_y", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Call next_step method.\"\"\"", "\n", "return", "self", ".", "next_step", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.__init__": [[19, 32], ["util.base.Base.__init__", "simple_gp.SimpleGp.set_data"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "data", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for this model.\n        data : Namespace_or_dict\n            Namespace or dict of initial data, containing lists x and y.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "self", ".", "set_data", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.set_params": [[33, 43], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for this model.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'SimpleGp'", ")", "\n", "self", ".", "params", ".", "ls", "=", "getattr", "(", "params", ",", "'ls'", ",", "3.7", ")", "\n", "self", ".", "params", ".", "alpha", "=", "getattr", "(", "params", ",", "'alpha'", ",", "1.85", ")", "\n", "self", ".", "params", ".", "sigma", "=", "getattr", "(", "params", ",", "'sigma'", ",", "1e-2", ")", "\n", "self", ".", "params", ".", "kernel", "=", "getattr", "(", "params", ",", "'kernel'", ",", "kern_exp_quad", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.set_data": [[44, 54], ["argparse.Namespace", "util.misc_util.dict_to_namespace", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set self.data.\"\"\"", "\n", "if", "data", "is", "None", ":", "\n", "# Initialize self.data to be empty", "\n", "            ", "self", ".", "data", "=", "Namespace", "(", ")", "\n", "self", ".", "data", ".", "x", "=", "[", "]", "\n", "self", ".", "data", ".", "y", "=", "[", "]", "\n", "", "else", ":", "\n", "            ", "data", "=", "dict_to_namespace", "(", "data", ")", "\n", "self", ".", "data", "=", "copy", ".", "deepcopy", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_prior_mu_cov": [[55, 87], ["numpy.zeros", "simple_gp.SimpleGp.params.kernel", "len", "numpy.sqrt", "numpy.diag"], "methods", ["None"], ["", "", "def", "get_prior_mu_cov", "(", "self", ",", "x_list", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Return GP prior parameters: mean (mu) and covariance (cov).\n\n        Parameters\n        ----------\n        x_list : list\n            List of numpy ndarrays, each representing a domain point.\n        full_cov : bool\n            If True, return covariance matrix. If False, return list of standard\n            deviations.\n\n        Returns\n        -------\n        mu : ndarray\n            A numpy 1d ndarray with len=len(x_list) of floats, corresponding to\n            posterior mean for each x in x_list.\n        cov : ndarray\n            If full_cov is False, return a numpy 1d ndarray with len=len(x_list) of\n            floats, corresponding to posterior standard deviations for each x in x_list.\n            If full_cov is True, return the covariance matrix as a numpy ndarray\n            (len(x_list) x len(x_list)).\n        \"\"\"", "\n", "# NOTE: currently assumes constant zero prior mean function.", "\n", "# TODO: support other mean functions.", "\n", "mu", "=", "np", ".", "zeros", "(", "len", "(", "x_list", ")", ")", "\n", "cov", "=", "self", ".", "params", ".", "kernel", "(", "x_list", ",", "x_list", ",", "self", ".", "params", ".", "ls", ",", "self", ".", "params", ".", "alpha", ")", "\n", "\n", "if", "full_cov", "is", "False", ":", "\n", "            ", "cov", "=", "np", ".", "sqrt", "(", "np", ".", "diag", "(", "cov", ")", ")", "\n", "\n", "", "return", "mu", ",", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_post_mu_cov": [[88, 114], ["simple_gp.SimpleGp.gp_post_wrapper"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper"], ["", "def", "get_post_mu_cov", "(", "self", ",", "x_list", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Return GP posterior parameters: mean (mu) and covariance (cov). If there is no\n        data, return the GP prior parameters.\n\n        Parameters\n        ----------\n        x_list : list\n            List of numpy ndarrays, each representing a domain point.\n        full_cov : bool\n            If True, return covariance matrix. If False, return list of standard\n            deviations.\n\n        Returns\n        -------\n        mu : ndarray\n            A numpy 1d ndarray with len=len(x_list) of floats, corresponding to\n            posterior mean for each x in x_list.\n        cov : ndarray\n            If full_cov is False, return a numpy 1d ndarray with len=len(x_list) of\n            floats, corresponding to posterior standard deviations for each x in x_list.\n            If full_cov is True, return the covariance matrix as a numpy ndarray\n            (len(x_list) x len(x_list)).\n        \"\"\"", "\n", "mu", ",", "cov", "=", "self", ".", "gp_post_wrapper", "(", "x_list", ",", "self", ".", "data", ",", "full_cov", ")", "\n", "return", "mu", ",", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.gp_post_wrapper": [[115, 134], ["gp.gp_utils.gp_post", "len", "simple_gp.SimpleGp.get_prior_mu_cov"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.gp_post", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_prior_mu_cov"], ["", "def", "gp_post_wrapper", "(", "self", ",", "x_list", ",", "data", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"Wrapper for gp_post given a list of x and data Namespace.\"\"\"", "\n", "if", "len", "(", "data", ".", "x", ")", "==", "0", ":", "\n", "            ", "return", "self", ".", "get_prior_mu_cov", "(", "x_list", ",", "full_cov", ")", "\n", "\n", "# If data is not empty:", "\n", "", "mu", ",", "cov", "=", "gp_post", "(", "\n", "data", ".", "x", ",", "\n", "data", ".", "y", ",", "\n", "x_list", ",", "\n", "self", ".", "params", ".", "ls", ",", "\n", "self", ".", "params", ".", "alpha", ",", "\n", "self", ".", "params", ".", "sigma", ",", "\n", "self", ".", "params", ".", "kernel", ",", "\n", "full_cov", "=", "full_cov", ",", "\n", ")", "\n", "\n", "# Return mean and cov matrix (or std-dev array if full_cov=False)", "\n", "return", "mu", ",", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_post_mu_cov_single": [[135, 139], ["simple_gp.SimpleGp.get_post_mu_cov"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov"], ["", "def", "get_post_mu_cov_single", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Get GP posterior for an input x. Return posterior mean and std for x.\"\"\"", "\n", "mu_arr", ",", "std_arr", "=", "self", ".", "get_post_mu_cov", "(", "[", "x", "]", ",", "full_cov", "=", "False", ")", "\n", "return", "mu_arr", "[", "0", "]", ",", "std_arr", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_prior_list": [[140, 144], ["simple_gp.SimpleGp.get_prior_mu_cov", "simple_gp.SimpleGp.get_normal_samples"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_prior_mu_cov", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_normal_samples"], ["", "def", "sample_prior_list", "(", "self", ",", "x_list", ",", "n_samp", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get samples from gp prior for each input in x_list.\"\"\"", "\n", "mu", ",", "cov", "=", "self", ".", "get_prior_mu_cov", "(", "x_list", ",", "full_cov", ")", "\n", "return", "self", ".", "get_normal_samples", "(", "mu", ",", "cov", ",", "n_samp", ",", "full_cov", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_prior": [[145, 149], ["simple_gp.SimpleGp.sample_prior_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_prior_list"], ["", "def", "sample_prior", "(", "self", ",", "x", ",", "n_samp", ")", ":", "\n", "        ", "\"\"\"Get samples from gp prior for input x.\"\"\"", "\n", "sample_list", "=", "self", ".", "sample_prior_list", "(", "[", "x", "]", ",", "n_samp", ")", "\n", "return", "sample_list", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_list": [[150, 158], ["simple_gp.SimpleGp.get_post_mu_cov", "simple_gp.SimpleGp.get_normal_samples", "len", "simple_gp.SimpleGp.sample_prior_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_normal_samples", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_prior_list"], ["", "def", "sample_post_list", "(", "self", ",", "x_list", ",", "n_samp", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get samples from gp posterior for each input in x_list.\"\"\"", "\n", "if", "len", "(", "self", ".", "data", ".", "x", ")", "==", "0", ":", "\n", "            ", "return", "self", ".", "sample_prior_list", "(", "x_list", ",", "n_samp", ",", "full_cov", ")", "\n", "\n", "# If data is not empty:", "\n", "", "mu", ",", "cov", "=", "self", ".", "get_post_mu_cov", "(", "x_list", ",", "full_cov", ")", "\n", "return", "self", ".", "get_normal_samples", "(", "mu", ",", "cov", ",", "n_samp", ",", "full_cov", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post": [[159, 163], ["simple_gp.SimpleGp.sample_post_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_list"], ["", "def", "sample_post", "(", "self", ",", "x", ",", "n_samp", ")", ":", "\n", "        ", "\"\"\"Get samples from gp posterior for a single input x.\"\"\"", "\n", "sample_list", "=", "self", ".", "sample_post_list", "(", "[", "x", "]", ",", "n_samp", ")", "\n", "return", "sample_list", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_pred_list": [[164, 169], ["simple_gp.SimpleGp.sample_post_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_list"], ["", "def", "sample_post_pred_list", "(", "self", ",", "x_list", ",", "n_samp", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"Get samples from gp posterior predictive for each x in x_list.\"\"\"", "\n", "# For now, return posterior (assuming low-noise case)", "\n", "# TODO: update this function", "\n", "return", "self", ".", "sample_post_list", "(", "x_list", ",", "n_samp", ",", "full_cov", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_pred": [[170, 174], ["simple_gp.SimpleGp.sample_post_pred_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_pred_list"], ["", "def", "sample_post_pred", "(", "self", ",", "x", ",", "n_samp", ")", ":", "\n", "        ", "\"\"\"Get samples from gp posterior predictive for a single input x.\"\"\"", "\n", "sample_list", "=", "self", ".", "sample_post_pred_list", "(", "[", "x", "]", ",", "n_samp", ")", "\n", "return", "sample_list", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_normal_samples": [[175, 187], ["list", "list", "list", "gp.gp_utils.sample_mvn", "numpy.random.normal", "numpy.stack", "mu.reshape", "cov.reshape", "len"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.sample_mvn"], ["", "def", "get_normal_samples", "(", "self", ",", "mu", ",", "cov", ",", "n_samp", ",", "full_cov", ")", ":", "\n", "        ", "\"\"\"Return normal samples.\"\"\"", "\n", "if", "full_cov", ":", "\n", "            ", "sample_list", "=", "list", "(", "sample_mvn", "(", "mu", ",", "cov", ",", "n_samp", ")", ")", "\n", "", "else", ":", "\n", "            ", "sample_list", "=", "list", "(", "\n", "np", ".", "random", ".", "normal", "(", "\n", "mu", ".", "reshape", "(", "-", "1", ",", ")", ",", "cov", ".", "reshape", "(", "-", "1", ",", ")", ",", "size", "=", "(", "n_samp", ",", "len", "(", "mu", ")", ")", "\n", ")", "\n", ")", "\n", "", "x_list_sample_list", "=", "list", "(", "np", ".", "stack", "(", "sample_list", ")", ".", "T", ")", "\n", "return", "x_list_sample_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.initialize_function_sample_list": [[188, 191], ["argparse.Namespace", "range"], "methods", ["None"], ["", "def", "initialize_function_sample_list", "(", "self", ",", "n_samp", "=", "1", ")", ":", "\n", "        ", "\"\"\"Initialize a list of n_samp function samples.\"\"\"", "\n", "self", ".", "fsl_queries", "=", "[", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "for", "_", "in", "range", "(", "n_samp", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.call_function_sample_list": [[192, 214], ["zip", "simple_gp.SimpleGp.combine_data_namespaces", "y_list.append", "simple_gp.SimpleGp.gp_post_wrapper", "simple_gp.SimpleGp.get_normal_samples", "query_ns.x.append", "query_ns.y.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.combine_data_namespaces", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_normal_samples"], ["", "def", "call_function_sample_list", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Call a set of posterior function samples on respective x in x_list.\"\"\"", "\n", "y_list", "=", "[", "]", "\n", "\n", "for", "x", ",", "query_ns", "in", "zip", "(", "x_list", ",", "self", ".", "fsl_queries", ")", ":", "\n", "# Get y for a posterior function sample at x", "\n", "            ", "comb_data", "=", "self", ".", "combine_data_namespaces", "(", "self", ".", "data", ",", "query_ns", ")", "\n", "\n", "if", "x", "is", "not", "None", ":", "\n", "                ", "mu", ",", "cov", "=", "self", ".", "gp_post_wrapper", "(", "[", "x", "]", ",", "comb_data", ",", "True", ")", "\n", "y", "=", "self", ".", "get_normal_samples", "(", "mu", ",", "cov", ",", "1", ",", "True", ")", "\n", "y", "=", "y", "[", "0", "]", "[", "0", "]", "\n", "\n", "# Update query history", "\n", "query_ns", ".", "x", ".", "append", "(", "x", ")", "\n", "query_ns", ".", "y", ".", "append", "(", "y", ")", "\n", "", "else", ":", "\n", "                ", "y", "=", "None", "\n", "\n", "", "y_list", ".", "append", "(", "y", ")", "\n", "\n", "", "return", "y_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.combine_data_namespaces": [[215, 221], ["argparse.Namespace"], "methods", ["None"], ["", "def", "combine_data_namespaces", "(", "self", ",", "ns1", ",", "ns2", ")", ":", "\n", "        ", "\"\"\"Combine two data Namespaces, with fields x and y.\"\"\"", "\n", "ns", "=", "Namespace", "(", ")", "\n", "ns", ".", "x", "=", "ns1", ".", "x", "+", "ns2", ".", "x", "\n", "ns", ".", "y", "=", "ns1", ".", "y", "+", "ns2", ".", "y", "\n", "return", "ns", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.set_params": [[21, 37], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "stan.gp_fixedsig.get_stanmodel"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_stanmodel"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for this model.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "# Set self.params", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'StanGp'", ")", "\n", "self", ".", "params", ".", "kernel", "=", "getattr", "(", "params", ",", "'kernel'", ",", "kern_exp_quad", ")", "\n", "self", ".", "params", ".", "ig1", "=", "getattr", "(", "params", ",", "'ig1'", ",", "4.0", ")", "\n", "self", ".", "params", ".", "ig2", "=", "getattr", "(", "params", ",", "'ig2'", ",", "3.0", ")", "\n", "self", ".", "params", ".", "n1", "=", "getattr", "(", "params", ",", "'n1'", ",", "1.0", ")", "\n", "self", ".", "params", ".", "n2", "=", "getattr", "(", "params", ",", "'n2'", ",", "1.0", ")", "\n", "self", ".", "params", ".", "n_iter", "=", "getattr", "(", "params", ",", "'n_iter'", ",", "70", ")", "\n", "self", ".", "params", ".", "print_warnings", "=", "getattr", "(", "params", ",", "'print_warnings'", ",", "True", ")", "\n", "self", ".", "params", ".", "print_fit_result", "=", "getattr", "(", "params", ",", "'print_fit_result'", ",", "True", ")", "\n", "self", ".", "params", ".", "stanmodel", "=", "get_stanmodel", "(", "verbose", "=", "self", ".", "params", ".", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.fit_hypers": [[38, 59], ["stan_gp.StanGp.get_stan_data_dict", "stan_gp.StanGp.set_hypers_from_stanout", "Exception", "stan_gp.StanGp.run_stan_optimizing", "stan_gp.StanGp.print_fit_result", "stan_gp.StanGp.run_stan_optimizing", "print"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.get_stan_data_dict", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.set_hypers_from_stanout", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.run_stan_optimizing", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.print_fit_result", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.run_stan_optimizing"], ["", "def", "fit_hypers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Fit hyperparameters.\"\"\"", "\n", "\n", "# Only fit hyperparameters if we have some observations", "\n", "if", "not", "self", ".", "data", ".", "x", ":", "\n", "            ", "raise", "Exception", "(", "'self.data.x must not be empty in call to fit_hypers'", ")", "\n", "\n", "", "data_dict", "=", "self", ".", "get_stan_data_dict", "(", ")", "\n", "\n", "try", ":", "\n", "            ", "stanout", "=", "self", ".", "run_stan_optimizing", "(", "data_dict", ")", "\n", "", "except", "RuntimeError", ":", "\n", "            ", "if", "self", ".", "params", ".", "print_warnings", ":", "\n", "                ", "print", "(", "\n", "'  > Stan LBFGS optimizer error. Running Newton optimizer instead.'", "\n", ")", "\n", "", "stanout", "=", "self", ".", "run_stan_optimizing", "(", "data_dict", ",", "stan_opt_str", "=", "'Newton'", ")", "\n", "\n", "", "self", ".", "set_hypers_from_stanout", "(", "stanout", ")", "\n", "if", "self", ".", "params", ".", "print_fit_result", ":", "\n", "            ", "self", ".", "print_fit_result", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.get_stan_data_dict": [[60, 76], ["len", "len"], "methods", ["None"], ["", "", "def", "get_stan_data_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return data_dict for input to stan.\"\"\"", "\n", "n_dim_x", "=", "len", "(", "self", ".", "data", ".", "x", "[", "0", "]", ")", "\n", "n_obs", "=", "len", "(", "self", ".", "data", ".", "x", ")", "\n", "data_dict", "=", "{", "\n", "'ig1'", ":", "self", ".", "params", ".", "ig1", ",", "\n", "'ig2'", ":", "self", ".", "params", ".", "ig2", ",", "\n", "'n1'", ":", "self", ".", "params", ".", "n1", ",", "\n", "'n2'", ":", "self", ".", "params", ".", "n2", ",", "\n", "'sigma'", ":", "self", ".", "params", ".", "sigma", ",", "\n", "'D'", ":", "n_dim_x", ",", "\n", "'N'", ":", "n_obs", ",", "\n", "'x'", ":", "self", ".", "data", ".", "x", ",", "\n", "'y'", ":", "self", ".", "data", ".", "y", ",", "\n", "}", "\n", "return", "data_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.run_stan_optimizing": [[77, 88], ["util.misc_util.suppress_stdout_stderr", "stan_gp.StanGp.params.stanmodel.optimizing"], "methods", ["None"], ["", "def", "run_stan_optimizing", "(", "self", ",", "data_dict", ",", "stan_opt_str", "=", "'LBFGS'", ",", "stanseed", "=", "543210", ")", ":", "\n", "        ", "\"\"\"Run self.stanmodel.optimizing and return output.\"\"\"", "\n", "with", "suppress_stdout_stderr", "(", ")", ":", "\n", "            ", "stanout", "=", "self", ".", "params", ".", "stanmodel", ".", "optimizing", "(", "\n", "data_dict", ",", "\n", "iter", "=", "self", ".", "params", ".", "n_iter", ",", "\n", "seed", "=", "stanseed", ",", "\n", "as_vector", "=", "True", ",", "\n", "algorithm", "=", "stan_opt_str", ",", "\n", ")", "\n", "", "return", "stanout", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.set_hypers_from_stanout": [[89, 93], ["float", "float"], "methods", ["None"], ["", "def", "set_hypers_from_stanout", "(", "self", ",", "stanout", ")", ":", "\n", "        ", "\"\"\"Set hyperparameters given a stanout object.\"\"\"", "\n", "self", ".", "params", ".", "ls", "=", "float", "(", "stanout", "[", "'rho'", "]", ")", "\n", "self", ".", "params", ".", "alpha", "=", "float", "(", "stanout", "[", "'alpha'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.print_fit_result": [[94, 100], ["print", "print", "print", "print"], "methods", ["None"], ["", "def", "print_fit_result", "(", "self", ")", ":", "\n", "        ", "\"\"\"Print result of hyparparameter fitting.\"\"\"", "\n", "print", "(", "'*[INFO] StanGp hyperparameter fitting:'", ")", "\n", "print", "(", "f'  > ls pt est = {self.params.ls}'", ")", "\n", "print", "(", "f'  > alpha pt est = {self.params.alpha}'", ")", "\n", "print", "(", "f'  > sigma pt est = {self.params.sigma}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.get_stangp_hypers": [[102, 121], ["argparse.Namespace", "util.domain_util.unif_random_sample_domain", "stan_gp.StanGp", "stan_gp.StanGp.fit_hypers", "f", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.domain_util.unif_random_sample_domain", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.stan_gp.StanGp.fit_hypers"], ["", "", "def", "get_stangp_hypers", "(", "f", ",", "domain", "=", "[", "[", "0.0", ",", "10.0", "]", "]", ",", "n_samp", "=", "200", ")", ":", "\n", "    ", "\"\"\"Return hypers fit by StanGp, using n_samp random queries of function f.\"\"\"", "\n", "\n", "# Construct dataset with n_samp unif random samples", "\n", "data", "=", "Namespace", "(", ")", "\n", "data", ".", "x", "=", "unif_random_sample_domain", "(", "domain", ",", "n", "=", "n_samp", ")", "\n", "data", ".", "y", "=", "[", "f", "(", "x", ")", "for", "x", "in", "data", ".", "x", "]", "\n", "\n", "# Fit params with StanGp on data", "\n", "model", "=", "StanGp", "(", "data", "=", "data", ")", "\n", "model", ".", "fit_hypers", "(", ")", "\n", "gp_hypers", "=", "{", "\n", "'ls'", ":", "model", ".", "params", ".", "ls", ",", "\n", "'alpha'", ":", "model", ".", "params", ".", "alpha", ",", "\n", "'sigma'", ":", "model", ".", "params", ".", "sigma", ",", "\n", "'n_dimx'", ":", "len", "(", "domain", ")", ",", "\n", "}", "\n", "\n", "return", "gp_hypers", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_params": [[17, 22], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the function sample.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"FunctionSample\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_model": [[23, 28], ["copy.deepcopy", "copy.deepcopy", "function.FunctionSample.reset_query_history"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.reset_query_history"], ["", "def", "set_model", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Set self.model, self.data, and reset self.query_history.\"\"\"", "\n", "self", ".", "model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "self", ".", "data", "=", "copy", ".", "deepcopy", "(", "self", ".", "model", ".", "data", ")", "\n", "self", ".", "reset_query_history", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.reset_query_history": [[29, 32], ["argparse.Namespace"], "methods", ["None"], ["", "def", "reset_query_history", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reset self.query_history.\"\"\"", "\n", "self", ".", "query_history", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_query_history": [[33, 36], ["None"], "methods", ["None"], ["", "def", "set_query_history", "(", "self", ",", "query_history", ")", ":", "\n", "        ", "\"\"\"Set self.query_history to query_history.\"\"\"", "\n", "self", ".", "query_history", "=", "query_history", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_all_obs": [[37, 43], ["argparse.Namespace"], "methods", ["None"], ["", "def", "set_all_obs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Update self.all_obs given current self.model.data and self.query_history.\"\"\"", "\n", "all_obs", "=", "Namespace", "(", ")", "\n", "all_obs", ".", "x", "=", "self", ".", "data", ".", "x", "+", "self", ".", "query_history", ".", "x", "\n", "all_obs", ".", "y", "=", "self", ".", "data", ".", "y", "+", "self", ".", "query_history", ".", "y", "\n", "self", ".", "all_obs", "=", "all_obs", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.get_post_mean_std_list": [[44, 57], ["function.FunctionSample.set_all_obs", "function.FunctionSample.model.set_data", "function.FunctionSample.model.get_post_mu_cov"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_all_obs", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov"], ["", "def", "get_post_mean_std_list", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"\n        Return an array of posterior means and array of posterior std-devs (one element\n        in array for each x in x_list).\n        \"\"\"", "\n", "\n", "# Set self.model.data using self.data and self.query_history", "\n", "self", ".", "set_all_obs", "(", ")", "\n", "self", ".", "model", ".", "set_data", "(", "self", ".", "all_obs", ")", "\n", "\n", "# Compute posterior mean and std-dev", "\n", "mean_arr", ",", "std_arr", "=", "self", ".", "model", ".", "get_post_mu_cov", "(", "x_list", ",", "full_cov", "=", "False", ")", "\n", "return", "mean_arr", ",", "std_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.get_y": [[58, 75], ["function.FunctionSample.set_all_obs", "function.FunctionSample.model.set_data", "function.FunctionSample.model.sample_post_pred", "function.FunctionSample.query_history.x.append", "function.FunctionSample.query_history.y.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.set_all_obs", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.sample_post_pred"], ["", "def", "get_y", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Sample and return output y at input x.\"\"\"", "\n", "\n", "# Set self.model.data using self.data and self.query_history", "\n", "self", ".", "set_all_obs", "(", ")", "\n", "self", ".", "model", ".", "set_data", "(", "self", ".", "all_obs", ")", "\n", "\n", "# Sample y from model posterior predictive", "\n", "y", "=", "self", ".", "model", ".", "sample_post_pred", "(", "x", ",", "1", ")", "\n", "y", "=", "y", "[", "0", "]", "\n", "\n", "# Update self.query_history", "\n", "self", ".", "query_history", ".", "x", ".", "append", "(", "x", ")", "\n", "self", ".", "query_history", ".", "y", ".", "append", "(", "y", ")", "\n", "\n", "# Return output y", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.__call__": [[76, 79], ["function.FunctionSample.get_y"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.function.FunctionSample.get_y"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns self.get_y(x).\"\"\"", "\n", "return", "self", ".", "get_y", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.set_params": [[25, 35], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "gpfs_gp.GpfsGp.set_kernel"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.set_kernel"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for this model.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "# Set self.params", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'GpfsGp'", ")", "\n", "self", ".", "params", ".", "n_bases", "=", "getattr", "(", "params", ",", "'n_bases'", ",", "1000", ")", "\n", "self", ".", "params", ".", "n_dimx", "=", "getattr", "(", "params", ",", "'n_dimx'", ",", "1", ")", "\n", "self", ".", "set_kernel", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.set_kernel": [[36, 55], ["getattr", "gpflow.kernels.SquaredExponential", "getattr", "gpflow.kernels.Matern52", "Exception", "gpflow.kernels.Matern32", "Exception"], "methods", ["None"], ["", "def", "set_kernel", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set GPflow kernel.\"\"\"", "\n", "self", ".", "params", ".", "kernel_str", "=", "getattr", "(", "params", ",", "'kernel_str'", ",", "'rbf'", ")", "\n", "\n", "ls", "=", "self", ".", "params", ".", "ls", "\n", "kernvar", "=", "self", ".", "params", ".", "alpha", "**", "2", "\n", "\n", "if", "self", ".", "params", ".", "kernel_str", "==", "'rbf'", ":", "\n", "            ", "gpf_kernel", "=", "kernels", ".", "SquaredExponential", "(", "variance", "=", "kernvar", ",", "lengthscales", "=", "ls", ")", "\n", "kernel", "=", "getattr", "(", "params", ",", "'kernel'", ",", "kern_exp_quad", ")", "\n", "", "elif", "self", ".", "params", ".", "kernel_str", "==", "'matern52'", ":", "\n", "            ", "gpf_kernel", "=", "kernels", ".", "Matern52", "(", "variance", "=", "kernvar", ",", "lengthscales", "=", "ls", ")", "\n", "raise", "Exception", "(", "'Matern 52 kernel is not yet supported.'", ")", "\n", "", "elif", "self", ".", "params", ".", "kernel_str", "==", "'matern32'", ":", "\n", "            ", "gpf_kernel", "=", "kernels", ".", "Matern32", "(", "variance", "=", "kernvar", ",", "lengthscales", "=", "ls", ")", "\n", "raise", "Exception", "(", "'Matern 32 kernel is not yet supported.'", ")", "\n", "\n", "", "self", ".", "params", ".", "gpf_kernel", "=", "gpf_kernel", "\n", "self", ".", "params", ".", "kernel", "=", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.set_data": [[56, 65], ["super().set_data", "argparse.Namespace", "tensorflow.convert_to_tensor", "tensorflow.convert_to_tensor", "gpfs_gp.GpfsGp.set_model", "numpy.array", "numpy.array().reshape", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.set_model"], ["", "def", "set_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set self.data.\"\"\"", "\n", "super", "(", ")", ".", "set_data", "(", "data", ")", "\n", "self", ".", "tf_data", "=", "Namespace", "(", ")", "\n", "self", ".", "tf_data", ".", "x", "=", "tf", ".", "convert_to_tensor", "(", "np", ".", "array", "(", "self", ".", "data", ".", "x", ")", ")", "\n", "self", ".", "tf_data", ".", "y", "=", "tf", ".", "convert_to_tensor", "(", "\n", "np", ".", "array", "(", "self", ".", "data", ".", "y", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", ")", "\n", "self", ".", "set_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.set_model": [[66, 72], ["gpfs.models.PathwiseGPR"], "methods", ["None"], ["", "def", "set_model", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set GPFlowSampling as self.model.\"\"\"", "\n", "self", ".", "params", ".", "model", "=", "PathwiseGPR", "(", "\n", "data", "=", "(", "self", ".", "tf_data", ".", "x", ",", "self", ".", "tf_data", ".", "y", ")", ",", "\n", "kernel", "=", "self", ".", "params", ".", "gpf_kernel", ",", "\n", "noise_variance", "=", "self", ".", "params", ".", "sigma", "**", "2", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.initialize_function_sample_list": [[74, 85], ["gpfs_gp.GpfsGp.params.model.generate_paths", "gpfs_gp.GpfsGp.params.model.set_paths", "tensorflow.random.uniform", "tensorflow.Variable", "gpflow.config.default_float"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseSVGP.generate_paths", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_paths"], ["", "def", "initialize_function_sample_list", "(", "self", ",", "n_samp", "=", "1", ")", ":", "\n", "        ", "\"\"\"Initialize a list of n_samp function samples.\"\"\"", "\n", "n_bases", "=", "self", ".", "params", ".", "n_bases", "\n", "paths", "=", "self", ".", "params", ".", "model", ".", "generate_paths", "(", "num_samples", "=", "n_samp", ",", "num_bases", "=", "n_bases", ")", "\n", "_", "=", "self", ".", "params", ".", "model", ".", "set_paths", "(", "paths", ")", "\n", "\n", "Xinit", "=", "tf", ".", "random", ".", "uniform", "(", "\n", "[", "n_samp", ",", "self", ".", "params", ".", "n_dimx", "]", ",", "minval", "=", "0.0", ",", "maxval", "=", "0.1", ",", "dtype", "=", "floatx", "(", ")", "\n", ")", "\n", "Xvars", "=", "tf", ".", "Variable", "(", "Xinit", ")", "\n", "self", ".", "fsl_xvars", "=", "Xvars", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.call_fsl_on_xvars": [[86, 91], ["model.predict_f_samples"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.predict_f_samples"], ["", "@", "tf", ".", "function", "\n", "def", "call_fsl_on_xvars", "(", "self", ",", "model", ",", "xvars", ",", "sample_axis", "=", "0", ")", ":", "\n", "        ", "\"\"\"Call fsl on fsl_xvars.\"\"\"", "\n", "fvals", "=", "model", ".", "predict_f_samples", "(", "Xnew", "=", "xvars", ",", "sample_axis", "=", "sample_axis", ")", "\n", "return", "fvals", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.call_function_sample_list": [[92, 103], ["gpfs_gp.GpfsGp.replace_x_list_none", "gpfs_gp.GpfsGp.fsl_xvars.assign", "gpfs_gp.GpfsGp.call_fsl_on_xvars", "list", "gpfs_gp.GpfsGp.numpy().reshape", "gpfs_gp.GpfsGp.numpy"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.replace_x_list_none", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.call_fsl_on_xvars"], ["", "def", "call_function_sample_list", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Call a set of posterior function samples on respective x in x_list.\"\"\"", "\n", "\n", "# Replace Nones in x_list with first non-None value", "\n", "x_list", "=", "self", ".", "replace_x_list_none", "(", "x_list", ")", "\n", "\n", "# Set fsl_xvars as x_list, call fsl, return y_list", "\n", "self", ".", "fsl_xvars", ".", "assign", "(", "x_list", ")", "\n", "y_tf", "=", "self", ".", "call_fsl_on_xvars", "(", "self", ".", "params", ".", "model", ",", "self", ".", "fsl_xvars", ")", "\n", "y_list", "=", "list", "(", "y_tf", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", ")", "\n", "return", "y_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.GpfsGp.replace_x_list_none": [[104, 114], ["next"], "methods", ["None"], ["", "def", "replace_x_list_none", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Replace any Nones in x_list with first non-None value and return x_list.\"\"\"", "\n", "\n", "# Set new_val as first non-None element of x_list", "\n", "new_val", "=", "next", "(", "x", "for", "x", "in", "x_list", "if", "x", "is", "not", "None", ")", "\n", "\n", "# Replace all Nones in x_list with new_val", "\n", "x_list_new", "=", "[", "new_val", "if", "x", "is", "None", "else", "x", "for", "x", "in", "x_list", "]", "\n", "\n", "return", "x_list_new", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.__init__": [[123, 127], ["util.base.Base.__init__", "gpfs_gp.MultiGpfsGp.set_data", "gpfs_gp.MultiGpfsGp.set_gpfsgp_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_gpfsgp_list"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "data", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "self", ".", "set_data", "(", "data", ")", "\n", "self", ".", "set_gpfsgp_list", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_params": [[128, 136], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for this model.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'MultiGpfsGp'", ")", "\n", "self", ".", "params", ".", "n_dimy", "=", "getattr", "(", "params", ",", "'n_dimy'", ",", "1", ")", "\n", "self", ".", "params", ".", "gp_params", "=", "getattr", "(", "params", ",", "'gp_params'", ",", "{", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_data": [[137, 144], ["argparse.Namespace", "util.misc_util.dict_to_namespace", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Set self.data.\"\"\"", "\n", "if", "data", "is", "None", ":", "\n", "            ", "self", ".", "data", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "", "else", ":", "\n", "            ", "data", "=", "dict_to_namespace", "(", "data", ")", "\n", "self", ".", "data", "=", "copy", ".", "deepcopy", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.set_gpfsgp_list": [[145, 152], ["gpfs_gp.MultiGpfsGp.get_data_list", "gpfs_gp.GpfsGp"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_data_list"], ["", "", "def", "set_gpfsgp_list", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set self.gpfsgp_list by instantiating a list of GpfsGp objects.\"\"\"", "\n", "data_list", "=", "self", ".", "get_data_list", "(", "self", ".", "data", ")", "\n", "\n", "# NOTE: GpfsGp verbose set to False (though MultiGpfsGp may be verbose)", "\n", "self", ".", "gpfsgp_list", "=", "[", "\n", "GpfsGp", "(", "self", ".", "params", ".", "gp_params", ",", "dat", ",", "False", ")", "for", "dat", "in", "data_list", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.initialize_function_sample_list": [[154, 160], ["gpfsgp.initialize_function_sample_list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.initialize_function_sample_list"], ["", "def", "initialize_function_sample_list", "(", "self", ",", "n_samp", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Initialize a list of n_samp function samples, for each GP in self.gpfsgp_list.\n        \"\"\"", "\n", "for", "gpfsgp", "in", "self", ".", "gpfsgp_list", ":", "\n", "            ", "gpfsgp", ".", "initialize_function_sample_list", "(", "n_samp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.call_function_sample_list": [[161, 173], ["gpfsgp.call_function_sample_list", "list", "zip"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.call_function_sample_list"], ["", "", "def", "call_function_sample_list", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"\n        Call a set of posterior function samples on respective x in x_list, for each GP\n        in self.gpfsgp_list.\n        \"\"\"", "\n", "y_list_list", "=", "[", "\n", "gpfsgp", ".", "call_function_sample_list", "(", "x_list", ")", "for", "gpfsgp", "in", "self", ".", "gpfsgp_list", "\n", "]", "\n", "\n", "# y_list is a list, where each element is a list representing a multidim y", "\n", "y_list", "=", "[", "list", "(", "x", ")", "for", "x", "in", "zip", "(", "*", "y_list_list", ")", "]", "\n", "return", "y_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov": [[174, 178], ["gpfs_gp.MultiGpfsGp.gp_post_wrapper"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper"], ["", "def", "get_post_mu_cov", "(", "self", ",", "x_list", ",", "full_cov", "=", "False", ")", ":", "\n", "        ", "\"\"\"See SimpleGp. Returns a list of mu, and a list of cov/std.\"\"\"", "\n", "mu_list", ",", "cov_list", "=", "self", ".", "gp_post_wrapper", "(", "x_list", ",", "self", ".", "data", ",", "full_cov", ")", "\n", "return", "mu_list", ",", "cov_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper": [[179, 193], ["gpfs_gp.MultiGpfsGp.get_data_list", "zip", "gpfsgp.gp_post_wrapper", "mu_list.append", "cov_list.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_data_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper"], ["", "def", "gp_post_wrapper", "(", "self", ",", "x_list", ",", "data", ",", "full_cov", "=", "True", ")", ":", "\n", "        ", "\"\"\"See SimpleGp. Returns a list of mu, and a list of cov/std.\"\"\"", "\n", "\n", "data_list", "=", "self", ".", "get_data_list", "(", "data", ")", "\n", "mu_list", "=", "[", "]", "\n", "cov_list", "=", "[", "]", "\n", "\n", "for", "gpfsgp", ",", "data_single", "in", "zip", "(", "self", ".", "gpfsgp_list", ",", "data_list", ")", ":", "\n", "# Call usual 1d gpfsgp gp_post_wrapper", "\n", "            ", "mu", ",", "cov", "=", "gpfsgp", ".", "gp_post_wrapper", "(", "x_list", ",", "data_single", ",", "full_cov", ")", "\n", "mu_list", ".", "append", "(", "mu", ")", "\n", "cov_list", ".", "append", "(", "cov", ")", "\n", "\n", "", "return", "mu_list", ",", "cov_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_data_list": [[194, 204], ["range", "data_list.append", "argparse.Namespace"], "methods", ["None"], ["", "def", "get_data_list", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"\n        Return list of Namespaces, where each is a version of data containing only one\n        of the dimensions of data.y (and the full data.x).\n        \"\"\"", "\n", "data_list", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "self", ".", "params", ".", "n_dimy", ")", ":", "\n", "            ", "data_list", ".", "append", "(", "Namespace", "(", "x", "=", "data", ".", "x", ",", "y", "=", "[", "yi", "[", "j", "]", "for", "yi", "in", "data", ".", "y", "]", ")", ")", "\n", "\n", "", "return", "data_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.__init__": [[28, 31], ["gpflow.models.GPModel.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "*", "args", ",", "paths", ":", "AbstractSampler", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_paths", "=", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.generate_paths": [[32, 35], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "generate_paths", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "->", "AbstractSampler", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.predict_f_samples": [[36, 52], ["models.PathwiseGPModel.paths", "RuntimeError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.paths"], ["", "def", "predict_f_samples", "(", "self", ",", "\n", "Xnew", ":", "TensorLike", ",", "\n", "num_samples", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "full_cov", ":", "bool", "=", "True", ",", "\n", "full_output_cov", ":", "bool", "=", "True", ",", "\n", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "\n", "    ", "assert", "full_cov", "and", "full_output_cov", ",", "NotImplementedError", "\n", "if", "self", ".", "paths", "is", "None", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"Paths were not initialized.\"", ")", "\n", "\n", "", "if", "num_samples", "is", "not", "None", ":", "\n", "      ", "assert", "num_samples", "==", "self", ".", "paths", ".", "sample_shape", ",", "ValueError", "(", "\"Requested number of samples does not match path count.\"", ")", "\n", "\n", "", "return", "self", ".", "paths", "(", "Xnew", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.temporary_paths": [[53, 62], ["models.PathwiseGPModel.generate_paths", "models.PathwiseGPModel.set_paths", "models.PathwiseGPModel.set_paths"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseSVGP.generate_paths", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_paths", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_paths"], ["", "@", "contextmanager", "\n", "def", "temporary_paths", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "try", ":", "\n", "      ", "init_paths", "=", "self", ".", "paths", "\n", "temp_paths", "=", "self", ".", "generate_paths", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "set_paths", "(", "temp_paths", ")", "\n", "yield", "temp_paths", "\n", "", "finally", ":", "\n", "      ", "self", ".", "set_paths", "(", "init_paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_paths": [[63, 66], ["None"], "methods", ["None"], ["", "", "def", "set_paths", "(", "self", ",", "paths", ")", "->", "AbstractSampler", ":", "\n", "    ", "self", ".", "_paths", "=", "paths", "\n", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_temporary_paths": [[67, 75], ["models.PathwiseGPModel.set_paths", "models.PathwiseGPModel.set_paths"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_paths", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.set_paths"], ["", "@", "contextmanager", "\n", "def", "set_temporary_paths", "(", "self", ",", "paths", ")", ":", "\n", "    ", "try", ":", "\n", "      ", "init_paths", "=", "self", ".", "paths", "\n", "self", ".", "set_paths", "(", "paths", ")", "\n", "yield", "paths", "\n", "", "finally", ":", "\n", "      ", "self", ".", "set_paths", "(", "init_paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPModel.paths": [[76, 79], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "paths", "(", "self", ")", "->", "AbstractSampler", ":", "\n", "    ", "return", "self", ".", "_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPR.__init__": [[82, 85], ["gpflow.models.GPR.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "*", "args", ",", "paths", ":", "AbstractSampler", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "GPR", ".", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_paths", "=", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseGPR.generate_paths": [[86, 109], ["tensorflow.convert_to_tensor", "gpflow_sampling.sampling.decoupled", "gpflow_sampling.sampling.priors.random_fourier"], "methods", ["None"], ["", "def", "generate_paths", "(", "self", ",", "\n", "num_samples", ":", "int", ",", "\n", "num_bases", ":", "int", "=", "None", ",", "\n", "prior", ":", "AbstractSampler", "=", "None", ",", "\n", "sample_axis", ":", "int", "=", "None", ",", "\n", "**", "kwargs", ")", "->", "CompositeSampler", ":", "\n", "\n", "    ", "if", "prior", "is", "None", ":", "\n", "      ", "prior", "=", "sampling", ".", "priors", ".", "random_fourier", "(", "self", ".", "kernel", ",", "\n", "num_bases", "=", "num_bases", ",", "\n", "sample_shape", "=", "[", "num_samples", "]", ",", "\n", "sample_axis", "=", "sample_axis", ")", "\n", "", "elif", "num_bases", "is", "not", "None", ":", "\n", "      ", "assert", "prior", ".", "sample_shape", "==", "[", "num_samples", "]", "\n", "\n", "", "diag", "=", "tf", ".", "convert_to_tensor", "(", "self", ".", "likelihood", ".", "variance", ")", "\n", "return", "sampling", ".", "decoupled", "(", "self", ".", "kernel", ",", "\n", "prior", ",", "\n", "*", "self", ".", "data", ",", "\n", "mean_function", "=", "self", ".", "mean_function", ",", "\n", "diag", "=", "diag", ",", "\n", "sample_axis", "=", "sample_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseSVGP.__init__": [[112, 115], ["gpflow.models.SVGP.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "*", "args", ",", "paths", ":", "AbstractSampler", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "SVGP", ".", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_paths", "=", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseSVGP.generate_paths": [[116, 138], ["gpflow_sampling.sampling.decoupled", "gpflow_sampling.sampling.priors.random_fourier", "models.PathwiseSVGP._generate_u"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseSVGP._generate_u"], ["", "def", "generate_paths", "(", "self", ",", "\n", "num_samples", ":", "int", ",", "\n", "num_bases", ":", "int", "=", "None", ",", "\n", "prior", ":", "AbstractSampler", "=", "None", ",", "\n", "sample_axis", ":", "int", "=", "None", ",", "\n", "**", "kwargs", ")", "->", "CompositeSampler", ":", "\n", "\n", "    ", "if", "prior", "is", "None", ":", "\n", "      ", "prior", "=", "sampling", ".", "priors", ".", "random_fourier", "(", "self", ".", "kernel", ",", "\n", "num_bases", "=", "num_bases", ",", "\n", "sample_shape", "=", "[", "num_samples", "]", ",", "\n", "sample_axis", "=", "sample_axis", ")", "\n", "", "elif", "num_bases", "is", "not", "None", ":", "\n", "      ", "assert", "prior", ".", "sample_shape", "==", "[", "num_samples", "]", "\n", "\n", "", "return", "sampling", ".", "decoupled", "(", "self", ".", "kernel", ",", "\n", "prior", ",", "\n", "self", ".", "inducing_variable", ",", "\n", "self", ".", "_generate_u", "(", "num_samples", ")", ",", "\n", "mean_function", "=", "self", ".", "mean_function", ",", "\n", "sample_axis", "=", "sample_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.models.PathwiseSVGP._generate_u": [[139, 154], ["tensorflow.linalg.band_part", "tensorflow.random.normal", "tensorflow.transpose", "gpflow.config.default_float", "tensorflow.transpose", "gpflow_sampling.covariances.Kuu", "tensorflow.linalg.cholesky", "gpflow.config.default_jitter"], "methods", ["None"], ["", "def", "_generate_u", "(", "self", ",", "num_samples", ":", "int", ",", "L", ":", "tf", ".", "Tensor", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Returns samples $u ~ q(u)$.\n    \"\"\"", "\n", "q_sqrt", "=", "tf", ".", "linalg", ".", "band_part", "(", "self", ".", "q_sqrt", ",", "-", "1", ",", "0", ")", "\n", "shape", "=", "self", ".", "num_latent_gps", ",", "q_sqrt", ".", "shape", "[", "-", "1", "]", ",", "num_samples", "\n", "rvs", "=", "tf", ".", "random", ".", "normal", "(", "shape", ",", "dtype", "=", "default_float", "(", ")", ")", "# [L, M, S]", "\n", "uT", "=", "q_sqrt", "@", "rvs", "+", "tf", ".", "transpose", "(", "self", ".", "q_mu", ")", "[", "...", ",", "None", "]", "\n", "if", "self", ".", "whiten", ":", "\n", "      ", "if", "L", "is", "None", ":", "\n", "        ", "Z", "=", "self", ".", "inducing_variable", "\n", "K", "=", "covariances", ".", "Kuu", "(", "Z", ",", "self", ".", "kernel", ",", "jitter", "=", "default_jitter", "(", ")", ")", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "", "uT", "=", "L", "@", "uT", "\n", "", "return", "tf", ".", "transpose", "(", "uT", ")", "# [S, M, L]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.InducingImages.__init__": [[29, 48], ["gpflow.inducing_variables.InducingVariables.__init__", "gpflow.base.Parameter", "gpflow.config.default_float"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "images", ":", "TensorData", ",", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "      ", "\"\"\"\n      :param images: initial values of inducing locations in image form.\n\n      The shape of the inducing variables varies by representation:\n        - as Z: [M, height * width * channels_in]\n        - as images: [M, height, width, channels_in]\n        - as patches: [M, height * width * channels_in]\n        - as filters: [height, width, channels_in, M]\n\n      TODO:\n        - Generalize to allow for inducing image with multiple patches?\n        - Work on naming convention? The term 'image' is a bit too general.\n          Patch works, however this term  usually refers to a vectorized form\n          and (for now) overlaps with GPflow's own inducing class. Alternatives\n          include: filter, window, glimpse\n      \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "_images", "=", "Parameter", "(", "images", ",", "dtype", "=", "default_float", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.InducingImages.__len__": [[49, 51], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", "->", "int", ":", "\n", "    ", "return", "self", ".", "_images", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.InducingImages.Z": [[52, 55], ["tensorflow.reshape", "len"], "methods", ["None"], ["", "@", "property", "\n", "def", "Z", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "return", "tf", ".", "reshape", "(", "self", ".", "_images", ",", "[", "len", "(", "self", ")", ",", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.InducingImages.as_patches": [[56, 59], ["tensorflow.reshape", "len"], "methods", ["None"], ["", "@", "property", "\n", "def", "as_patches", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "return", "tf", ".", "reshape", "(", "self", ".", "as_images", ",", "[", "len", "(", "self", ")", ",", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.InducingImages.as_filters": [[60, 63], ["gpflow_sampling.utils.move_axis"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "@", "property", "\n", "def", "as_filters", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "return", "move_axis", "(", "self", ".", "as_images", ",", "0", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.InducingImages.as_images": [[64, 67], ["tensorflow.convert_to_tensor"], "methods", ["None"], ["", "@", "property", "\n", "def", "as_images", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "return", "tf", ".", "convert_to_tensor", "(", "self", ".", "_images", ",", "dtype", "=", "self", ".", "_images", ".", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.SharedInducingImages.__init__": [[70, 90], ["gpflow.inducing_variables.InducingImages.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "images", ":", "TensorData", ",", "\n", "channels_in", ":", "int", ",", "\n", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param images: initial values of inducing locations in image form.\n    :param channels_in: number of input channels to share across\n\n    Same as <InducingImages> but with the same single-channel inducing\n    images shared across all input channels.\n\n    The shape of the inducing variables varies by representation:\n      - as Z: [M, height * width]  (new!)\n      - as images: [M, height, width, channels_in]\n      - as patches [M, channels_in, height * width]\n      - as filters: [height, width, channels_in, M]\n    \"\"\"", "\n", "assert", "images", ".", "shape", ".", "ndims", "==", "4", "and", "images", ".", "shape", "[", "-", "1", "]", "==", "1", "\n", "self", ".", "channels_in", "=", "channels_in", "\n", "super", "(", ")", ".", "__init__", "(", "images", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.SharedInducingImages.as_images": [[91, 94], ["tensorflow.tile"], "methods", ["None"], ["", "@", "property", "\n", "def", "as_images", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "return", "tf", ".", "tile", "(", "self", ".", "_images", ",", "[", "1", ",", "1", ",", "1", ",", "self", ".", "channels_in", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.DepthwiseInducingImages.as_patches": [[106, 111], ["tensorflow.reshape", "tensorflow.transpose"], "methods", ["None"], ["@", "property", "\n", "def", "as_patches", "(", "self", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "images", "=", "self", ".", "as_images", "\n", "patches", "=", "tf", ".", "reshape", "(", "images", ",", "[", "images", ".", "shape", "[", "0", "]", ",", "-", "1", ",", "images", ".", "shape", "[", "-", "1", "]", "]", ")", "\n", "return", "tf", ".", "transpose", "(", "patches", ",", "[", "0", ",", "2", ",", "1", "]", ")", "# [M, channels_in, patch_len]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.inducing_variables.SharedDepthwiseInducingImages.__init__": [[115, 127], ["gpflow.inducing_variables.SharedInducingImages.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "images", ":", "TensorData", ",", "\n", "channels_in", ":", "int", ",", "\n", "name", ":", "Optional", "[", "str", "]", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param images: initial values of inducing locations in image form.\n    :param channels_in: number of input channels to share across.\n    \"\"\"", "\n", "SharedInducingImages", ".", "__init__", "(", "self", ",", "\n", "name", "=", "name", ",", "\n", "images", "=", "images", ",", "\n", "channels_in", "=", "channels_in", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.__init__": [[34, 76], ["list", "list", "gpflow.kernels.MultioutputKernel.__init__", "len", "len", "isinstance", "gpflow.kernels.Conv2d.get_spatial_out", "tensorflow.ones", "gpflow.base.Parameter", "tensorflow.reduce_prod", "gpflow.config.default_float"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out"], ["  ", "def", "__init__", "(", "self", ",", "\n", "kernel", ":", "kernels", ".", "Kernel", ",", "\n", "image_shape", ":", "List", ",", "\n", "patch_shape", ":", "List", ",", "\n", "channels_in", ":", "int", "=", "1", ",", "\n", "channels_out", ":", "int", "=", "1", ",", "\n", "weights", ":", "TensorType", "=", "\"default\"", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "\"VALID\"", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "\"NHWC\"", ")", ":", "\n", "\n", "    ", "strides", "=", "list", "(", "(", "1", ",", "1", ")", "if", "strides", "is", "None", "else", "strides", ")", "\n", "dilations", "=", "list", "(", "(", "1", ",", "1", ")", "if", "dilations", "is", "None", "else", "dilations", ")", "\n", "\n", "# Sanity checks", "\n", "assert", "len", "(", "strides", ")", "==", "2", "\n", "assert", "len", "(", "dilations", ")", "==", "2", "\n", "assert", "padding", "in", "(", "\"VALID\"", ",", "\"SAME\"", ")", "\n", "assert", "data_format", "in", "(", "\"NHWC\"", ",", "\"NCHW\"", ")", "\n", "\n", "if", "isinstance", "(", "weights", ",", "str", ")", "and", "weights", "==", "\"default\"", ":", "# TODO: improve me", "\n", "      ", "spatial_out", "=", "self", ".", "get_spatial_out", "(", "spatial_in", "=", "image_shape", ",", "\n", "filter_shape", "=", "patch_shape", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "dilations", "=", "dilations", ")", "\n", "\n", "weights", "=", "tf", ".", "ones", "(", "[", "tf", ".", "reduce_prod", "(", "spatial_out", ")", "]", ",", "dtype", "=", "default_float", "(", ")", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "kernel", "=", "kernel", "\n", "self", ".", "image_shape", "=", "image_shape", "\n", "self", ".", "patch_shape", "=", "patch_shape", "\n", "self", ".", "channels_in", "=", "channels_in", "\n", "self", ".", "channels_out", "=", "channels_out", "\n", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilations", "=", "dilations", "\n", "self", ".", "data_format", "=", "data_format", "\n", "self", ".", "_weights", "=", "None", "if", "(", "weights", "is", "None", ")", "else", "Parameter", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.__call__": [[77, 96], ["gpflow.kernels.Conv2d.K", "gpflow.kernels.Conv2d.slice", "ValueError", "gpflow.kernels.Conv2d.K_diag"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K_diag"], ["", "def", "__call__", "(", "self", ",", "\n", "X", ":", "TensorType", ",", "\n", "X2", ":", "TensorType", "=", "None", ",", "\n", "*", ",", "\n", "full_cov", ":", "bool", "=", "False", ",", "\n", "full_spatial", ":", "bool", "=", "False", ",", "\n", "presliced", ":", "bool", "=", "False", ")", ":", "\n", "\n", "    ", "if", "not", "presliced", ":", "\n", "      ", "X", ",", "X2", "=", "self", ".", "slice", "(", "X", ",", "X2", ")", "\n", "\n", "", "if", "not", "full_cov", "and", "X2", "is", "not", "None", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "\"Ambiguous inputs: passing in `X2` is not compatible with `full_cov=False`.\"", "\n", ")", "\n", "\n", "", "if", "not", "full_cov", ":", "\n", "      ", "return", "self", ".", "K_diag", "(", "X", ",", "full_spatial", "=", "full_spatial", ")", "\n", "", "return", "self", ".", "K", "(", "X", ",", "X2", ",", "full_spatial", "=", "full_spatial", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.K": [[97, 113], ["gpflow.kernels.Conv2d.get_patches", "gpflow.kernels.Conv2d.kernel.K", "tensorflow.tensordot", "gpflow.kernels.Conv2d.get_patches", "tensorflow.reduce_mean", "tensorflow.linalg.matvec"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches"], ["", "def", "K", "(", "self", ",", "X", ":", "tf", ".", "Tensor", ",", "X2", ":", "tf", ".", "Tensor", "=", "None", ",", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    TODO: For stationary kernels, implement this using convolutions?\n    \"\"\"", "\n", "P", "=", "self", ".", "get_patches", "(", "X", ",", "full_spatial", "=", "full_spatial", ")", "\n", "P2", "=", "P", "if", "X2", "is", "None", "else", "self", ".", "get_patches", "(", "X2", ",", "full_spatial", "=", "full_spatial", ")", "\n", "K", "=", "self", ".", "kernel", ".", "K", "(", "P", ",", "P2", ")", "\n", "if", "full_spatial", ":", "\n", "      ", "return", "K", "# [N, H1, W1, N2, H2, W2]", "\n", "\n", "# At this point, shape(K) = [N, H1 * W1, N2, H2 * W2]", "\n", "", "if", "self", ".", "weights", "is", "None", ":", "\n", "      ", "return", "tf", ".", "reduce_mean", "(", "K", ",", "axis", "=", "[", "-", "3", ",", "-", "1", "]", ")", "\n", "", "return", "tf", ".", "tensordot", "(", "tf", ".", "linalg", ".", "matvec", "(", "K", ",", "self", ".", "weights", ")", ",", "\n", "self", ".", "weights", ",", "\n", "axes", "=", "[", "-", "2", ",", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.K_diag": [[114, 124], ["gpflow.kernels.Conv2d.get_patches", "gpflow.kernels.Conv2d.kernel.K_diag", "tensorflow.linalg.matvec", "tensorflow.reduce_mean", "tensorflow.linalg.matvec"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K_diag"], ["", "def", "K_diag", "(", "self", ",", "X", ":", "tf", ".", "Tensor", ",", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "    ", "P", "=", "self", ".", "get_patches", "(", "X", ",", "full_spatial", "=", "full_spatial", ")", "\n", "K", "=", "self", ".", "kernel", ".", "K_diag", "(", "P", ")", "\n", "if", "full_spatial", ":", "\n", "      ", "return", "K", "# [N, H1, W1]", "\n", "\n", "# At this point, shape(K) = [N, H1 * W1]", "\n", "", "if", "self", ".", "weights", "is", "None", ":", "\n", "      ", "return", "tf", ".", "reduce_mean", "(", "K", ",", "axis", "=", "[", "-", "2", ",", "-", "1", "]", ")", "\n", "", "return", "tf", ".", "linalg", ".", "matvec", "(", "tf", ".", "linalg", ".", "matvec", "(", "K", ",", "self", ".", "weights", ")", ",", "self", ".", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.convolve": [[125, 151], ["tensorflow.nn.conv2d"], "methods", ["None"], ["", "def", "convolve", "(", "self", ",", "\n", "input", ",", "\n", "filters", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "None", ")", ":", "\n", "\n", "    ", "if", "strides", "is", "None", ":", "\n", "      ", "strides", "=", "self", ".", "strides", "\n", "\n", "", "if", "padding", "is", "None", ":", "\n", "      ", "padding", "=", "self", ".", "padding", "\n", "\n", "", "if", "dilations", "is", "None", ":", "\n", "      ", "dilations", "=", "self", ".", "dilations", "\n", "\n", "", "if", "data_format", "is", "None", ":", "\n", "      ", "data_format", "=", "self", ".", "data_format", "\n", "\n", "", "return", "tf", ".", "nn", ".", "conv2d", "(", "input", "=", "input", ",", "\n", "filters", "=", "filters", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "dilations", "=", "dilations", ",", "\n", "data_format", "=", "data_format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.get_patches": [[152, 167], ["gpflow_sampling.utils.conv_ops.reformat_data", "tensorflow.image.extract_patches", "tensorflow.reshape", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.conv_ops.reformat_data"], ["", "def", "get_patches", "(", "self", ",", "X", ":", "TensorType", ",", "full_spatial", ":", "bool", "=", "True", ")", ":", "\n", "# Extract image patches", "\n", "    ", "X_nchw", "=", "conv_ops", ".", "reformat_data", "(", "X", ",", "self", ".", "data_format", ",", "\"NHWC\"", ")", "\n", "patches", "=", "tf", ".", "image", ".", "extract_patches", "(", "images", "=", "X_nchw", ",", "\n", "sizes", "=", "[", "1", "]", "+", "self", ".", "patch_shape", "+", "[", "1", "]", ",", "\n", "strides", "=", "[", "1", "]", "+", "self", ".", "strides", "+", "[", "1", "]", ",", "\n", "rates", "=", "[", "1", "]", "+", "self", ".", "dilations", "+", "[", "1", "]", ",", "\n", "padding", "=", "self", ".", "padding", ")", "\n", "\n", "if", "full_spatial", ":", "\n", "      ", "output_shape", "=", "list", "(", "X", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "list", "(", "patches", ".", "shape", "[", "-", "3", ":", "]", ")", "\n", "", "else", ":", "\n", "      ", "output_shape", "=", "list", "(", "X", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "[", "-", "1", ",", "patches", ".", "shape", "[", "-", "1", "]", "]", "\n", "\n", "", "return", "tf", ".", "reshape", "(", "patches", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.get_shape_out": [[168, 190], ["gpflow.kernels.Conv2d.get_spatial_out", "gpflow_sampling.utils.conv_ops.reformat_shape", "list", "list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.conv_ops.reformat_shape"], ["", "def", "get_shape_out", "(", "self", ",", "\n", "shape_in", ":", "List", ",", "\n", "filter_shape", ":", "List", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "None", ")", "->", "List", ":", "\n", "\n", "    ", "if", "data_format", "is", "None", ":", "\n", "      ", "data_format", "=", "self", ".", "data_format", "\n", "\n", "", "if", "data_format", "==", "\"NHWC\"", ":", "\n", "      ", "*", "batch", ",", "height", ",", "width", ",", "_", "=", "list", "(", "shape_in", ")", "\n", "", "else", ":", "\n", "      ", "*", "batch", ",", "_", ",", "height", ",", "width", "=", "list", "(", "shape_in", ")", "\n", "\n", "", "spatial_out", "=", "self", ".", "get_spatial_out", "(", "spatial_in", "=", "[", "height", ",", "width", "]", ",", "\n", "filter_shape", "=", "filter_shape", "[", ":", "2", "]", ",", "\n", "strides", "=", "strides", ",", "\n", "dilations", "=", "dilations", ")", "\n", "\n", "nhwc_out", "=", "batch", "+", "spatial_out", "+", "[", "filter_shape", "[", "-", "1", "]", "]", "\n", "return", "conv_ops", ".", "reformat_shape", "(", "nhwc_out", ",", "\"NHWC\"", ",", "data_format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.get_spatial_out": [[191, 220], ["tensorflow.python.keras.utils.conv_utils.conv_output_length", "len", "range", "padding.lower"], "methods", ["None"], ["", "def", "get_spatial_out", "(", "self", ",", "\n", "spatial_in", ":", "List", "=", "None", ",", "\n", "filter_shape", ":", "List", "=", "None", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ")", "->", "List", ":", "\n", "\n", "    ", "if", "spatial_in", "is", "None", ":", "\n", "      ", "spatial_in", "=", "self", ".", "image_shape", "\n", "\n", "", "if", "filter_shape", "is", "None", ":", "\n", "      ", "filter_shape", "=", "self", ".", "patch_shape", "\n", "", "else", ":", "\n", "      ", "assert", "len", "(", "filter_shape", ")", "==", "2", "\n", "\n", "", "if", "strides", "is", "None", ":", "\n", "      ", "strides", "=", "self", ".", "strides", "\n", "\n", "", "if", "padding", "is", "None", ":", "\n", "      ", "padding", "=", "self", ".", "padding", "\n", "\n", "", "if", "dilations", "is", "None", ":", "\n", "      ", "dilations", "=", "self", ".", "dilations", "\n", "\n", "", "return", "[", "conv_output_length", "(", "input_length", "=", "spatial_in", "[", "i", "]", ",", "\n", "filter_size", "=", "filter_shape", "[", "i", "]", ",", "\n", "stride", "=", "strides", "[", "i", "]", ",", "\n", "padding", "=", "padding", ".", "lower", "(", ")", ",", "\n", "dilation", "=", "dilations", "[", "i", "]", ")", "for", "i", "in", "range", "(", "2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.num_patches": [[221, 224], ["tensorflow.reduce_prod", "gpflow.kernels.Conv2d.get_spatial_out"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out"], ["", "@", "property", "\n", "def", "num_patches", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "reduce_prod", "(", "self", ".", "get_spatial_out", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.weights": [[225, 230], ["tensorflow.cast"], "methods", ["None"], ["", "@", "property", "\n", "def", "weights", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "_weights", "is", "None", ":", "\n", "      ", "return", "None", "\n", "", "return", "tf", ".", "cast", "(", "1", "/", "self", ".", "num_patches", ",", "self", ".", "_weights", ".", "dtype", ")", "*", "self", ".", "_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.num_latent_gps": [[231, 234], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_latent_gps", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "channels_out", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2d.latent_kernels": [[235, 238], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "latent_kernels", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "kernel", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.__init__": [[241, 254], ["list", "list", "gpflow.kernels.Conv2d.__init__", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "*", "args", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "strides", "=", "list", "(", "(", "1", ",", "1", ")", "if", "strides", "is", "None", "else", "strides", ")", "\n", "dilations", "=", "list", "(", "(", "1", ",", "1", ")", "if", "dilations", "is", "None", "else", "dilations", ")", "\n", "if", "strides", "!=", "[", "1", ",", "1", "]", "and", "dilations", "!=", "[", "1", ",", "1", "]", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Tensorflow does not implement transposed'", "\n", "'convolutions with strides and dilations.'", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "strides", "=", "strides", ",", "dilations", "=", "dilations", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.convolve": [[255, 299], ["gpflow.kernels.Conv2dTranspose.get_shape_out", "gpflow_sampling.utils.swap_axes", "dict", "tensorflow.nn.conv2d_transpose", "tensorflow.nn.atrous_conv2d_transpose", "list", "len"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_shape_out", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes"], ["", "def", "convolve", "(", "self", ",", "\n", "input", ",", "\n", "filters", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "None", ")", ":", "\n", "\n", "    ", "if", "strides", "is", "None", ":", "\n", "      ", "strides", "=", "self", ".", "strides", "\n", "\n", "", "if", "padding", "is", "None", ":", "\n", "      ", "padding", "=", "self", ".", "padding", "\n", "\n", "", "if", "dilations", "is", "None", ":", "\n", "      ", "dilations", "=", "self", ".", "dilations", "\n", "\n", "", "if", "data_format", "is", "None", ":", "\n", "      ", "data_format", "=", "self", ".", "data_format", "\n", "\n", "", "shape_out", "=", "self", ".", "get_shape_out", "(", "shape_in", "=", "input", ".", "shape", ",", "\n", "filter_shape", "=", "filters", ".", "shape", ",", "\n", "strides", "=", "strides", ",", "\n", "dilations", "=", "dilations", ",", "\n", "data_format", "=", "data_format", ")", "\n", "\n", "_filters", "=", "swap_axes", "(", "filters", ",", "-", "2", ",", "-", "1", ")", "\n", "conv_kwargs", "=", "dict", "(", "filters", "=", "_filters", ",", "\n", "padding", "=", "padding", ",", "\n", "output_shape", "=", "shape_out", ")", "\n", "\n", "if", "dilations", "!=", "[", "1", ",", "1", "]", ":", "# TODO: improve me", "\n", "      ", "assert", "data_format", "==", "'NHWC'", "\n", "assert", "list", "(", "strides", ")", "==", "[", "1", ",", "1", "]", "\n", "assert", "len", "(", "dilations", ")", "==", "2", "and", "dilations", "[", "0", "]", "==", "dilations", "[", "1", "]", "\n", "return", "tf", ".", "nn", ".", "atrous_conv2d_transpose", "(", "input", ",", "\n", "rate", "=", "dilations", "[", "0", "]", ",", "\n", "**", "conv_kwargs", ")", "\n", "\n", "", "return", "tf", ".", "nn", ".", "conv2d_transpose", "(", "input", ",", "\n", "strides", "=", "strides", ",", "\n", "dilations", "=", "dilations", ",", "\n", "data_format", "=", "data_format", ",", "\n", "**", "conv_kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_patches": [[300, 348], ["any", "tensorflow.pad", "tensorflow.image.extract_patches", "tensorflow.reshape", "list", "enumerate", "list.append", "tensorflow.meshgrid", "tensorflow.scatter_nd", "tensorflow.reverse", "tensorflow.range", "list.append", "terms.append", "tensorflow.stack", "gpflow.kernels.Conv2dTranspose.get_spatial_out", "list", "list", "list", "list", "list", "tensorflow.reshape", "tensorflow.range", "map", "map", "list", "tensorflow.cast", "tensorflow.math.ceil", "tensorflow.math.floor", "tensorflow.cast", "tensorflow.math.ceil", "tensorflow.math.floor"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out"], ["", "def", "get_patches", "(", "self", ",", "X", ",", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Returns the patches used by a 2d transposed convolution.\n    \"\"\"", "\n", "spatial_in", "=", "X", ".", "shape", "[", "-", "3", ":", "-", "1", "]", "\n", "\n", "# Pad X with (stride - 1) zeros in between each pixel", "\n", "if", "any", "(", "stride", "!=", "1", "for", "stride", "in", "self", ".", "strides", ")", ":", "\n", "      ", "shape", "=", "list", "(", "X", ".", "shape", "[", ":", "-", "3", "]", ")", "\n", "terms", "=", "[", "tf", ".", "range", "(", "size", ")", "for", "size", "in", "shape", "]", "\n", "for", "i", ",", "stride", "in", "enumerate", "(", "self", ".", "strides", ")", ":", "\n", "        ", "size", "=", "X", ".", "shape", "[", "i", "-", "3", "]", "\n", "shape", ".", "append", "(", "stride", "*", "(", "size", "-", "1", ")", "+", "1", ")", "\n", "terms", ".", "append", "(", "tf", ".", "range", "(", "stride", "*", "size", ",", "delta", "=", "stride", ")", ")", "\n", "", "shape", ".", "append", "(", "X", ".", "shape", "[", "-", "1", "]", ")", "\n", "grid", "=", "tf", ".", "meshgrid", "(", "*", "terms", ",", "indexing", "=", "'ij'", ")", "\n", "X", "=", "tf", ".", "scatter_nd", "(", "tf", ".", "stack", "(", "grid", ",", "-", "1", ")", ",", "X", ",", "shape", ")", "\n", "\n", "# Prepare padding info", "\n", "", "if", "self", ".", "padding", "==", "\"VALID\"", ":", "\n", "      ", "h_pad", "=", "2", "*", "[", "self", ".", "dilations", "[", "0", "]", "*", "(", "self", ".", "patch_shape", "[", "0", "]", "-", "1", ")", "]", "\n", "w_pad", "=", "2", "*", "[", "self", ".", "dilations", "[", "1", "]", "*", "(", "self", ".", "patch_shape", "[", "1", "]", "-", "1", ")", "]", "\n", "", "elif", "self", ".", "padding", "==", "\"SAME\"", ":", "\n", "      ", "height_out", ",", "width_out", "=", "self", ".", "get_spatial_out", "(", "spatial_in", ")", "\n", "extra", "=", "height_out", "-", "X", ".", "shape", "[", "-", "3", "]", "\n", "h_pad", "=", "list", "(", "map", "(", "lambda", "x", ":", "tf", ".", "cast", "(", "x", ",", "tf", ".", "int64", ")", ",", "\n", "(", "tf", ".", "math", ".", "ceil", "(", "0.5", "*", "extra", ")", ",", "tf", ".", "math", ".", "floor", "(", "0.5", "*", "extra", ")", ")", ")", ")", "\n", "\n", "extra", "=", "width_out", "-", "X", ".", "shape", "[", "-", "2", "]", "\n", "w_pad", "=", "list", "(", "map", "(", "lambda", "x", ":", "tf", ".", "cast", "(", "x", ",", "tf", ".", "int64", ")", ",", "\n", "(", "tf", ".", "math", ".", "ceil", "(", "0.5", "*", "extra", ")", ",", "tf", ".", "math", ".", "floor", "(", "0.5", "*", "extra", ")", ")", ")", ")", "\n", "\n", "# Extract (flipped) image patches", "\n", "", "X_pad", "=", "tf", ".", "pad", "(", "X", ",", "[", "2", "*", "[", "0", "]", ",", "h_pad", ",", "w_pad", ",", "2", "*", "[", "0", "]", "]", ")", "\n", "patches", "=", "tf", ".", "image", ".", "extract_patches", "(", "images", "=", "X_pad", ",", "\n", "sizes", "=", "[", "1", "]", "+", "self", ".", "patch_shape", "+", "[", "1", "]", ",", "\n", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "rates", "=", "[", "1", "]", "+", "self", ".", "dilations", "+", "[", "1", "]", ",", "\n", "padding", "=", "self", ".", "padding", ")", "\n", "\n", "if", "full_spatial", ":", "\n", "      ", "output_shape", "=", "list", "(", "X", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "list", "(", "patches", ".", "shape", "[", "-", "3", ":", "]", ")", "\n", "", "else", ":", "\n", "      ", "output_shape", "=", "list", "(", "X", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "[", "-", "1", ",", "patches", ".", "shape", "[", "-", "1", "]", "]", "\n", "\n", "", "return", "tf", ".", "reshape", "(", "tf", ".", "reverse", "(", "# reverse channel-wise patches and reshape", "\n", "tf", ".", "reshape", "(", "patches", ",", "list", "(", "patches", ".", "shape", "[", ":", "-", "1", "]", ")", "+", "[", "-", "1", ",", "X", ".", "shape", "[", "-", "1", "]", "]", ")", ",", "\n", "axis", "=", "[", "-", "2", "]", ")", ",", "output_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out": [[349, 378], ["tensorflow.python.keras.utils.conv_utils.deconv_output_length", "len", "range", "padding.lower"], "methods", ["None"], ["", "def", "get_spatial_out", "(", "self", ",", "\n", "spatial_in", ":", "List", "=", "None", ",", "\n", "filter_shape", ":", "List", "=", "None", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ")", "->", "List", ":", "\n", "\n", "    ", "if", "spatial_in", "is", "None", ":", "\n", "      ", "spatial_in", "=", "self", ".", "image_shape", "\n", "\n", "", "if", "filter_shape", "is", "None", ":", "\n", "      ", "filter_shape", "=", "self", ".", "patch_shape", "\n", "", "else", ":", "\n", "      ", "assert", "len", "(", "filter_shape", ")", "==", "2", "\n", "\n", "", "if", "strides", "is", "None", ":", "\n", "      ", "strides", "=", "self", ".", "strides", "\n", "\n", "", "if", "padding", "is", "None", ":", "\n", "      ", "padding", "=", "self", ".", "padding", "\n", "\n", "", "if", "dilations", "is", "None", ":", "\n", "      ", "dilations", "=", "self", ".", "dilations", "\n", "\n", "", "return", "[", "deconv_output_length", "(", "input_length", "=", "spatial_in", "[", "i", "]", ",", "\n", "filter_size", "=", "filter_shape", "[", "i", "]", ",", "\n", "stride", "=", "strides", "[", "i", "]", ",", "\n", "padding", "=", "padding", ".", "lower", "(", ")", ",", "\n", "dilation", "=", "dilations", "[", "i", "]", ")", "for", "i", "in", "range", "(", "2", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.__init__": [[381, 420], ["list", "list", "gpflow.kernels.Conv2d.__init__", "warnings.warn", "isinstance", "gpflow.kernels.DepthwiseConv2d.get_spatial_out", "tensorflow.ones", "tensorflow.reduce_prod", "gpflow.config.default_float"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out"], ["  ", "def", "__init__", "(", "self", ",", "\n", "kernel", ":", "kernels", ".", "Kernel", ",", "\n", "image_shape", ":", "List", ",", "\n", "patch_shape", ":", "List", ",", "\n", "channels_in", ":", "int", "=", "1", ",", "\n", "channels_out", ":", "int", "=", "1", ",", "\n", "weights", ":", "TensorType", "=", "\"default\"", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "\"VALID\"", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "\"NHWC\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "    ", "strides", "=", "list", "(", "(", "1", ",", "1", ")", "if", "strides", "is", "None", "else", "strides", ")", "\n", "dilations", "=", "list", "(", "(", "1", ",", "1", ")", "if", "dilations", "is", "None", "else", "dilations", ")", "\n", "if", "strides", "!=", "[", "1", ",", "1", "]", "and", "dilations", "!=", "[", "1", ",", "1", "]", ":", "\n", "      ", "warn", "(", "f\"{self.__class__} does not pass unit tests when strides != [1, 1]\"", "\n", "f\"  and dilations != [1, 1] simultaneously.\"", ")", "\n", "\n", "", "if", "isinstance", "(", "weights", ",", "str", ")", "and", "weights", "==", "\"default\"", ":", "# TODO: improve me", "\n", "      ", "spatial_out", "=", "self", ".", "get_spatial_out", "(", "spatial_in", "=", "image_shape", ",", "\n", "filter_shape", "=", "patch_shape", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "dilations", "=", "dilations", ")", "\n", "\n", "weights", "=", "tf", ".", "ones", "(", "[", "tf", ".", "reduce_prod", "(", "spatial_out", ")", ",", "channels_in", "]", ",", "\n", "dtype", "=", "default_float", "(", ")", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "kernel", "=", "kernel", ",", "\n", "image_shape", "=", "image_shape", ",", "\n", "patch_shape", "=", "patch_shape", ",", "\n", "channels_in", "=", "channels_in", ",", "\n", "channels_out", "=", "channels_out", ",", "\n", "weights", "=", "weights", ",", "\n", "strides", "=", "strides", ",", "\n", "padding", "=", "padding", ",", "\n", "dilations", "=", "dilations", ",", "\n", "data_format", "=", "data_format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K": [[421, 440], ["gpflow.kernels.DepthwiseConv2d.get_patches", "gpflow_sampling.utils.move_axis", "gpflow_sampling.utils.batch_tensordot", "gpflow_sampling.utils.batch_tensordot", "tensorflow.reduce_mean", "gpflow.kernels.DepthwiseConv2d.get_patches", "tensorflow.linalg.diag_part", "tensorflow.reduce_mean", "gpflow_sampling.utils.move_axis", "gpflow.kernels.DepthwiseConv2d.kernel.K"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K"], ["", "def", "K", "(", "self", ",", "X", ":", "tf", ".", "Tensor", ",", "X2", ":", "tf", ".", "Tensor", "=", "None", ",", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "    ", "P", "=", "self", ".", "get_patches", "(", "X", ",", "full_spatial", "=", "full_spatial", ")", "\n", "P2", "=", "P", "if", "X2", "is", "None", "else", "self", ".", "get_patches", "(", "X2", ",", "full_spatial", "=", "full_spatial", ")", "\n", "\n", "# TODO: Temporary hack, use of self.kernel should be deprecated", "\n", "K", "=", "move_axis", "(", "\n", "tf", ".", "linalg", ".", "diag_part", "(", "\n", "move_axis", "(", "self", ".", "kernel", ".", "K", "(", "P", ",", "P2", ")", ",", "P", ".", "shape", ".", "ndims", "-", "2", ",", "-", "2", ")", ")", ",", "-", "1", ",", "0", ")", "\n", "\n", "if", "full_spatial", ":", "\n", "      ", "return", "K", "# [channels_in, N, H1, W1, N2, H2, W2]", "\n", "\n", "# At this point, shape(K) = [N, num_patches, N2, num_patches]", "\n", "", "if", "self", ".", "weights", "is", "None", ":", "\n", "      ", "return", "tf", ".", "reduce_mean", "(", "K", ",", "axis", "=", "[", "0", ",", "-", "3", ",", "-", "1", "]", ")", "\n", "\n", "", "K", "=", "batch_tensordot", "(", "K", ",", "self", ".", "weights", ",", "axes", "=", "[", "-", "1", ",", "0", "]", ",", "batch_axes", "=", "[", "0", ",", "1", "]", ")", "\n", "K", "=", "batch_tensordot", "(", "K", ",", "self", ".", "weights", ",", "axes", "=", "[", "-", "2", ",", "0", "]", ",", "batch_axes", "=", "[", "0", ",", "1", "]", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "K", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K_diag": [[441, 456], ["gpflow.kernels.DepthwiseConv2d.get_patches", "tensorflow.reduce_mean", "gpflow_sampling.utils.batch_tensordot", "gpflow_sampling.utils.batch_tensordot", "tensorflow.reduce_mean", "gpflow.kernels.DepthwiseConv2d.kernel.K", "tensorflow.reduce_mean"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K"], ["", "def", "K_diag", "(", "self", ",", "X", ":", "tf", ".", "Tensor", ",", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "\n", "P", "=", "self", ".", "get_patches", "(", "X", ",", "full_spatial", "=", "full_spatial", ")", "\n", "K", "=", "tf", ".", "reduce_mean", "(", "self", ".", "kernel", ".", "K", "(", "P", ")", ",", "axis", "=", "-", "2", ")", "# average over channels", "\n", "if", "full_spatial", ":", "\n", "      ", "return", "K", "# [num_channels, N, H1, W1, H1, W1]", "\n", "\n", "# At this point, K has shape # [num_channels, N, num_patches, num_patches]", "\n", "", "if", "self", ".", "weights", "is", "None", ":", "\n", "      ", "return", "tf", ".", "reduce_mean", "(", "K", ",", "axis", "=", "[", "-", "2", ",", "-", "1", "]", ")", "\n", "\n", "", "K", "=", "batch_tensordot", "(", "K", ",", "self", ".", "weights", ",", "axes", "=", "[", "-", "1", ",", "0", "]", ",", "batch_axes", "=", "[", "0", ",", "1", "]", ")", "\n", "K", "=", "batch_tensordot", "(", "K", ",", "self", ".", "weights", ",", "axes", "=", "[", "-", "1", ",", "0", "]", ",", "batch_axes", "=", "[", "0", ",", "1", "]", ")", "\n", "return", "tf", ".", "reduce_mean", "(", "K", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.convolve": [[457, 483], ["tensorflow.nn.depthwise_conv2d"], "methods", ["None"], ["", "def", "convolve", "(", "self", ",", "\n", "input", ",", "\n", "filters", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "padding", ":", "str", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "None", ")", ":", "\n", "\n", "    ", "if", "strides", "is", "None", ":", "\n", "      ", "strides", "=", "self", ".", "strides", "\n", "\n", "", "if", "padding", "is", "None", ":", "\n", "      ", "padding", "=", "self", ".", "padding", "\n", "\n", "", "if", "dilations", "is", "None", ":", "\n", "      ", "dilations", "=", "self", ".", "dilations", "\n", "\n", "", "if", "data_format", "is", "None", ":", "\n", "      ", "data_format", "=", "self", ".", "data_format", "\n", "\n", "", "return", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "input", "=", "input", ",", "\n", "filter", "=", "filters", ",", "\n", "strides", "=", "[", "1", "]", "+", "strides", "+", "[", "1", "]", ",", "\n", "padding", "=", "padding", ",", "\n", "dilations", "=", "dilations", ",", "\n", "data_format", "=", "data_format", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches": [[484, 493], ["gpflow.kernels.Conv2d.get_patches", "tensorflow.reshape", "gpflow_sampling.utils.move_axis", "list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "def", "get_patches", "(", "self", ",", "X", ":", "TensorType", ",", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Returns the patches used by a 2d depthwise convolution.\n    \"\"\"", "\n", "patches", "=", "super", "(", ")", ".", "get_patches", "(", "X", ",", "full_spatial", "=", "full_spatial", ")", "\n", "channels_in", "=", "X", ".", "shape", "[", "-", "3", "if", "self", ".", "data_format", "==", "\"NCHW\"", "else", "-", "1", "]", "\n", "depthwise_patches", "=", "tf", ".", "reshape", "(", "patches", ",", "\n", "list", "(", "patches", ".", "shape", "[", ":", "-", "1", "]", ")", "+", "[", "-", "1", ",", "channels_in", "]", ")", "\n", "return", "move_axis", "(", "depthwise_patches", ",", "-", "2", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_shape_out": [[494, 516], ["gpflow.kernels.DepthwiseConv2d.get_spatial_out", "gpflow_sampling.utils.conv_ops.reformat_shape", "list", "list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.conv_ops.reformat_shape"], ["", "def", "get_shape_out", "(", "self", ",", "\n", "shape_in", ":", "List", ",", "\n", "filter_shape", ":", "List", ",", "\n", "strides", ":", "List", "=", "None", ",", "\n", "dilations", ":", "List", "=", "None", ",", "\n", "data_format", ":", "str", "=", "None", ")", "->", "List", ":", "\n", "\n", "    ", "if", "data_format", "is", "None", ":", "\n", "      ", "data_format", "=", "self", ".", "data_format", "\n", "\n", "", "if", "data_format", "==", "\"NHWC\"", ":", "\n", "      ", "*", "batch", ",", "height", ",", "width", ",", "_", "=", "list", "(", "shape_in", ")", "\n", "", "else", ":", "\n", "      ", "*", "batch", ",", "_", ",", "height", ",", "width", "=", "list", "(", "shape_in", ")", "\n", "\n", "", "spatial_out", "=", "self", ".", "get_spatial_out", "(", "spatial_in", "=", "[", "height", ",", "width", "]", ",", "\n", "filter_shape", "=", "filter_shape", "[", ":", "2", "]", ",", "\n", "strides", "=", "strides", ",", "\n", "dilations", "=", "dilations", ")", "\n", "\n", "nhwc_out", "=", "batch", "+", "spatial_out", "+", "[", "filter_shape", "[", "-", "2", "]", "*", "filter_shape", "[", "-", "1", "]", "]", "\n", "return", "conv_ops", ".", "reformat_shape", "(", "nhwc_out", ",", "\"NHWC\"", ",", "data_format", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis": [[24, 33], ["None"], "function", ["None"], ["def", "normalize_axis", "(", "axis", ",", "ndims", ",", "minval", "=", "None", ",", "maxval", "=", "None", ")", ":", "\n", "  ", "if", "minval", "is", "None", ":", "\n", "    ", "minval", "=", "-", "ndims", "\n", "\n", "", "if", "maxval", "is", "None", ":", "\n", "    ", "maxval", "=", "ndims", "-", "1", "\n", "\n", "", "assert", "maxval", ">=", "axis", ">=", "minval", "\n", "return", "ndims", "+", "axis", "if", "(", "axis", "<", "0", ")", "else", "axis", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis": [[35, 46], ["len", "array_ops.normalize_axis", "array_ops.normalize_axis", "list", "list.insert", "tensorflow.transpose", "range", "list.pop"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis"], ["", "def", "move_axis", "(", "arr", ":", "tf", ".", "Tensor", ",", "src", ":", "int", ",", "dest", ":", "int", ")", ":", "\n", "  ", "ndims", "=", "len", "(", "arr", ".", "shape", ")", "\n", "src", "=", "ndims", "+", "src", "if", "(", "src", "<", "0", ")", "else", "src", "\n", "dest", "=", "ndims", "+", "dest", "if", "(", "dest", "<", "0", ")", "else", "dest", "\n", "\n", "src", "=", "normalize_axis", "(", "src", ",", "ndims", ")", "\n", "dest", "=", "normalize_axis", "(", "dest", ",", "ndims", ")", "\n", "\n", "perm", "=", "list", "(", "range", "(", "ndims", ")", ")", "\n", "perm", ".", "insert", "(", "dest", ",", "perm", ".", "pop", "(", "src", ")", ")", "\n", "return", "tf", ".", "transpose", "(", "arr", ",", "perm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes": [[48, 57], ["len", "array_ops.normalize_axis", "array_ops.normalize_axis", "list", "tensorflow.transpose", "range"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis"], ["", "def", "swap_axes", "(", "arr", ":", "tf", ".", "Tensor", ",", "a", ":", "int", ",", "b", ":", "int", ")", ":", "\n", "  ", "ndims", "=", "len", "(", "arr", ".", "shape", ")", "\n", "a", "=", "normalize_axis", "(", "a", ",", "ndims", ")", "\n", "b", "=", "normalize_axis", "(", "b", ",", "ndims", ")", "\n", "\n", "perm", "=", "list", "(", "range", "(", "ndims", ")", ")", "\n", "perm", "[", "a", "]", "=", "b", "\n", "perm", "[", "b", "]", "=", "a", "\n", "return", "tf", ".", "transpose", "(", "arr", ",", "perm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.expand_n": [[59, 63], ["len", "array_ops.normalize_axis", "slice"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis"], ["", "def", "expand_n", "(", "arr", ":", "tf", ".", "Tensor", ",", "axis", ":", "int", ",", "n", ":", "int", ")", ":", "\n", "  ", "ndims", "=", "len", "(", "arr", ".", "shape", ")", "\n", "axis", "=", "normalize_axis", "(", "axis", ",", "ndims", ",", "maxval", "=", "ndims", ")", "\n", "return", "arr", "[", "axis", "*", "(", "slice", "(", "None", ")", ",", ")", "+", "n", "*", "(", "np", ".", "newaxis", ",", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.expand_to": [[65, 71], ["len", "array_ops.expand_n", "tensorflow.identity"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.expand_n"], ["", "def", "expand_to", "(", "arr", ":", "tf", ".", "Tensor", ",", "axis", ":", "int", ",", "ndims", ":", "int", ")", ":", "\n", "  ", "_ndims", "=", "len", "(", "arr", ".", "shape", ")", "\n", "if", "_ndims", "==", "ndims", ":", "\n", "    ", "return", "tf", ".", "identity", "(", "arr", ")", "\n", "", "assert", "ndims", ">", "_ndims", "\n", "return", "expand_n", "(", "arr", ",", "axis", ",", "ndims", "-", "_ndims", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot": [[27, 113], ["len", "len", "linalg.batch_tensordot.parse_axes"], "function", ["None"], ["def", "batch_tensordot", "(", "a", ":", "tf", ".", "Tensor", ",", "\n", "b", ":", "tf", ".", "Tensor", ",", "\n", "axes", ":", "List", ",", "\n", "batch_axes", ":", "List", "=", "None", ")", "->", "tf", ".", "Tensor", ":", "\n", "  ", "\"\"\"\n  Computes tensor products like <tf.tensordot> with:\n    - Support for batch dimensions; 1-to-1 rather than Cartesian product\n    - Broadcasting of batch dimensions\n\n  Example:\n    a = tf.random.rand([5, 4, 3, 2])\n    b = tf.random.rand([6, 4, 2, 1])\n    c = batch_tensordot(a, b, [-1, -2], [[-3, -2], [-3, -1]])  # [5, 6, 4, 3]\n  \"\"\"", "\n", "ndims_a", "=", "len", "(", "a", ".", "shape", ")", "\n", "ndims_b", "=", "len", "(", "b", ".", "shape", ")", "\n", "assert", "min", "(", "ndims_a", ",", "ndims_b", ")", ">", "0", "\n", "assert", "max", "(", "ndims_a", ",", "ndims_b", ")", "<", "26", "\n", "\n", "# Prepare batch and contraction axes", "\n", "def", "parse_axes", "(", "axes", ")", ":", "\n", "    ", "if", "axes", "is", "None", ":", "\n", "      ", "return", "[", "]", ",", "[", "]", "\n", "\n", "", "assert", "len", "(", "axes", ")", "==", "2", "\n", "axes_a", ",", "axes_b", "=", "axes", "\n", "\n", "a_is_int", "=", "isinstance", "(", "axes_a", ",", "int", ")", "\n", "b_is_int", "=", "isinstance", "(", "axes_b", ",", "int", ")", "\n", "assert", "a_is_int", "==", "b_is_int", "\n", "if", "a_is_int", ":", "\n", "      ", "return", "[", "normalize_axis", "(", "axes_a", ",", "ndims_a", ")", "]", ",", "[", "normalize_axis", "(", "axes_b", ",", "ndims_b", ")", "]", "\n", "\n", "", "assert", "isinstance", "(", "axes_a", ",", "Iterable", ")", "\n", "assert", "isinstance", "(", "axes_b", ",", "Iterable", ")", "\n", "axes_a", "=", "list", "(", "axes_a", ")", "\n", "axes_b", "=", "list", "(", "axes_b", ")", "\n", "length", "=", "len", "(", "axes_a", ")", "\n", "assert", "length", "==", "len", "(", "axes_b", ")", "\n", "if", "length", "==", "0", ":", "\n", "      ", "return", "[", "]", ",", "[", "]", "\n", "\n", "", "axes_a", "=", "[", "normalize_axis", "(", "ax", ",", "ndims_a", ")", "for", "ax", "in", "axes_a", "]", "\n", "axes_b", "=", "[", "normalize_axis", "(", "ax", ",", "ndims_b", ")", "for", "ax", "in", "axes_b", "]", "\n", "return", "map", "(", "list", ",", "zip", "(", "*", "sorted", "(", "zip", "(", "axes_a", ",", "axes_b", ")", ")", ")", ")", "# sort according to a", "\n", "\n", "", "reduce_a", ",", "reduce_b", "=", "parse_axes", "(", "axes", ")", "# defines the tensor contraction", "\n", "batch_a", ",", "batch_b", "=", "parse_axes", "(", "batch_axes", ")", "# group these together 1-to-1", "\n", "\n", "# Construct left-hand side einsum conventions", "\n", "active_a", "=", "reduce_a", "+", "batch_a", "\n", "active_b", "=", "reduce_b", "+", "batch_b", "\n", "assert", "len", "(", "active_a", ")", "==", "len", "(", "set", "(", "active_a", ")", ")", "# check for duplicates", "\n", "assert", "len", "(", "active_b", ")", "==", "len", "(", "set", "(", "active_b", ")", ")", "\n", "\n", "lhs_a", "=", "list", "(", "ascii_lowercase", "[", ":", "ndims_a", "]", ")", "\n", "lhs_b", "=", "list", "(", "ascii_lowercase", "[", "ndims_a", ":", "ndims_a", "+", "ndims_b", "]", ")", "\n", "for", "(", "pos_a", ",", "pos_b", ")", "in", "zip", "(", "active_a", ",", "active_b", ")", ":", "\n", "    ", "lhs_b", "[", "pos_b", "]", "=", "lhs_a", "[", "pos_a", "]", "\n", "\n", "# Construct right-hand side einsum convention", "\n", "", "rhs", "=", "[", "]", "\n", "for", "i", ",", "char_a", "in", "enumerate", "(", "lhs_a", ")", ":", "\n", "    ", "if", "i", "not", "in", "reduce_a", ":", "\n", "      ", "rhs", ".", "append", "(", "char_a", ")", "\n", "\n", "", "", "for", "i", ",", "char_b", "in", "enumerate", "(", "lhs_b", ")", ":", "\n", "    ", "if", "i", "not", "in", "active_b", ":", "\n", "      ", "rhs", ".", "append", "(", "char_b", ")", "\n", "\n", "# Enable broadcasting by eliminate singleton dimenisions", "\n", "", "", "for", "(", "pos_a", ",", "pos_b", ")", "in", "zip", "(", "batch_a", ",", "batch_b", ")", ":", "\n", "    ", "if", "a", ".", "shape", "[", "pos_a", "]", "==", "b", ".", "shape", "[", "pos_b", "]", ":", "\n", "      ", "continue", "# TODO: test for edge cases", "\n", "\n", "", "if", "a", ".", "shape", "[", "pos_a", "]", "==", "1", ":", "\n", "      ", "a", "=", "tf", ".", "squeeze", "(", "a", ",", "axis", "=", "pos_a", ")", "\n", "del", "lhs_a", "[", "pos_a", "]", "\n", "\n", "", "if", "b", ".", "shape", "[", "pos_b", "]", "==", "1", ":", "\n", "      ", "b", "=", "tf", ".", "squeeze", "(", "b", ",", "axis", "=", "pos_b", ")", "\n", "del", "lhs_b", "[", "pos_b", "]", "\n", "\n", "# Compute einsum", "\n", "", "", "return", "tf", ".", "einsum", "(", "f\"{''.join(lhs_a)},{''.join(lhs_b)}->{''.join(rhs)}\"", ",", "a", ",", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.get_default_preconditioner": [[115, 138], ["tensorflow_probability.python.math.pivoted_cholesky", "tensorflow.linalg.LinearOperatorLowRankUpdate", "tf.linalg.LinearOperatorLowRankUpdate.inverse", "gpflow.config.default_jitter", "isinstance", "tensorflow.convert_to_tensor", "tensorflow.linalg.LinearOperatorDiag", "tensorflow.linalg.LinearOperatorScaledIdentity"], "function", ["None"], ["", "def", "get_default_preconditioner", "(", "arr", ":", "tf", ".", "Tensor", ",", "\n", "diag", ":", "Union", "[", "tf", ".", "Tensor", ",", "tf", ".", "linalg", ".", "LinearOperator", "]", ",", "\n", "max_rank", ":", "int", "=", "100", ",", "\n", "diag_rtol", ":", "float", "=", "None", ")", ":", "\n", "  ", "\"\"\"\n  Returns a <tf.linalg.LinearOperator> preconditioner representing\n  $(D + LL^{T})^{-1}$ where $D$ is a diagonal matrix and $L$ is the\n  partial pivoted Cholesky factor of a symmetric PSD matrix $A$.\n  \"\"\"", "\n", "if", "diag_rtol", "is", "None", ":", "\n", "    ", "diag_rtol", "=", "default_jitter", "(", ")", "\n", "\n", "", "N", "=", "arr", ".", "shape", "[", "-", "1", "]", "\n", "if", "not", "isinstance", "(", "diag", ",", "tf", ".", "linalg", ".", "LinearOperator", ")", ":", "\n", "    ", "diag", "=", "tf", ".", "convert_to_tensor", "(", "diag", ",", "dtype", "=", "arr", ".", "dtype", ")", "\n", "if", "N", "==", "1", "or", "(", "diag", ".", "shape", ".", "ndims", "and", "diag", ".", "shape", "[", "-", "1", "]", ">", "1", ")", ":", "\n", "      ", "diag", "=", "tf", ".", "linalg", ".", "LinearOperatorDiag", "(", "diag", ")", "\n", "", "else", ":", "\n", "      ", "diag", "=", "tf", ".", "linalg", ".", "LinearOperatorScaledIdentity", "(", "N", ",", "diag", ")", "\n", "\n", "", "", "piv_chol", "=", "pivoted_cholesky", "(", "arr", ",", "max_rank", "=", "max_rank", ",", "diag_rtol", "=", "diag_rtol", ")", "\n", "low_rank", "=", "tf", ".", "linalg", ".", "LinearOperatorLowRankUpdate", "(", "diag", ",", "piv_chol", ")", "\n", "return", "low_rank", ".", "inverse", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.gpflow_ops._getter": [[39, 47], ["get_inducing_shape.register", "enumerate", "get_inducing_shape", "get_inducing_shape"], "function", ["None"], ["", "@", "get_inducing_shape", ".", "register", "(", "SeparateIndependentInducingVariables", ")", "\n", "def", "_getter", "(", "x", ":", "SeparateIndependentInducingVariables", ")", ":", "\n", "  ", "for", "n", ",", "z", "in", "enumerate", "(", "x", ".", "inducing_variables", ")", ":", "\n", "    ", "if", "n", "==", "0", ":", "\n", "      ", "shape", "=", "get_inducing_shape", "(", "z", ")", "\n", "", "else", ":", "\n", "      ", "assert", "shape", "==", "get_inducing_shape", "(", "z", ")", "\n", "", "", "return", "[", "n", "+", "1", "]", "+", "shape", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.gpflow_ops._convert": [[61, 65], ["inducing_to_tensor.register", "tensorflow.stack", "inducing_to_tensor"], "function", ["None"], ["", "@", "inducing_to_tensor", ".", "register", "(", "SeparateIndependentInducingVariables", ")", "\n", "def", "_convert", "(", "x", ":", "InducingVariables", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "tf", ".", "stack", "(", "[", "inducing_to_tensor", "(", "z", ",", "**", "kwargs", ")", "\n", "for", "z", "in", "x", ".", "inducing_variables", "]", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.conv_ops.reformat_shape": [[24, 42], ["None"], "function", ["None"], ["def", "reformat_shape", "(", "shape", ":", "List", ",", "\n", "input_format", ":", "str", ",", "\n", "output_format", ":", "str", ")", "->", "List", ":", "\n", "  ", "\"\"\"\n  Helper method for shape data between NHWC and NCHW formats.\n  \"\"\"", "\n", "if", "input_format", "==", "output_format", ":", "\n", "    ", "return", "shape", "# noop", "\n", "\n", "", "if", "input_format", "==", "'NHWC'", ":", "\n", "    ", "assert", "output_format", "==", "\"NCHW\"", "\n", "return", "shape", "[", ":", "-", "3", "]", "+", "shape", "[", "-", "1", ":", "]", "+", "shape", "[", "-", "3", ":", "-", "1", "]", "\n", "\n", "", "if", "input_format", "==", "'NCHW'", ":", "\n", "    ", "assert", "output_format", "==", "\"NHWC\"", "\n", "return", "shape", "[", ":", "-", "3", "]", "+", "shape", "[", "-", "2", ":", "]", "+", "[", "shape", "[", "-", "3", "]", "]", "\n", "\n", "", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.conv_ops.reformat_data": [[44, 62], ["gpflow_sampling.utils.array_ops.move_axis", "gpflow_sampling.utils.array_ops.move_axis"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "def", "reformat_data", "(", "x", ":", "TensorType", ",", "\n", "format_in", ":", "str", ",", "\n", "format_out", ":", "str", ")", ":", "\n", "  ", "\"\"\"\n  Helper method for converting image data between NHWC and NCHW formats.\n  \"\"\"", "\n", "if", "format_in", "==", "format_out", ":", "\n", "    ", "return", "x", "# noop", "\n", "\n", "", "if", "format_in", "==", "\"NHWC\"", ":", "\n", "    ", "assert", "format_out", "==", "\"NCHW\"", "\n", "return", "move_axis", "(", "x", ",", "-", "1", ",", "-", "3", ")", "\n", "\n", "", "if", "format_in", "==", "\"NCHW\"", ":", "\n", "    ", "assert", "format_out", "==", "\"NHWC\"", "\n", "return", "move_axis", "(", "x", ",", "-", "3", ",", "-", "1", ")", "\n", "\n", "", "raise", "NotImplementedError", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kuus._Kuu_conv2d": [[20, 26], ["gpflow.covariances.dispatch.Kuu.register", "kern.kernel.K", "tensorflow.linalg.set_diag", "tensorflow.linalg.diag_part"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K"], ["@", "Kuu", ".", "register", "(", "InducingImages", ",", "Conv2d", ")", "\n", "def", "_Kuu_conv2d", "(", "feat", ":", "InducingImages", ",", "\n", "kern", ":", "Conv2d", ",", "\n", "jitter", ":", "float", "=", "0.0", ")", ":", "\n", "  ", "_Kuu", "=", "kern", ".", "kernel", ".", "K", "(", "feat", ".", "as_patches", ")", "\n", "return", "tf", ".", "linalg", ".", "set_diag", "(", "_Kuu", ",", "tf", ".", "linalg", ".", "diag_part", "(", "_Kuu", ")", "+", "jitter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kuus._Kuu_depthwise_conv2d": [[28, 38], ["gpflow.covariances.dispatch.Kuu.register", "gpflow_sampling.utils.move_axis", "gpflow.utilities.ops.square_distance", "tensorflow.reduce_mean", "tensorflow.linalg.set_diag", "kern.kernel.scale", "kern.kernel.K_r2", "tensorflow.linalg.diag_part"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "@", "Kuu", ".", "register", "(", "DepthwiseInducingImages", ",", "DepthwiseConv2d", ")", "\n", "def", "_Kuu_depthwise_conv2d", "(", "feat", ":", "DepthwiseInducingImages", ",", "\n", "kern", ":", "DepthwiseConv2d", ",", "\n", "jitter", ":", "float", "=", "0.0", ")", ":", "\n", "\n", "# Prepare scaled inducing patches; shape(Zp) = [channels_in, M, patch_len]", "\n", "  ", "Zp", "=", "move_axis", "(", "kern", ".", "kernel", ".", "scale", "(", "feat", ".", "as_patches", ")", ",", "-", "2", ",", "0", ")", "\n", "r2", "=", "square_distance", "(", "Zp", ",", "None", ")", "\n", "_Kuu", "=", "tf", ".", "reduce_mean", "(", "kern", ".", "kernel", ".", "K_r2", "(", "r2", ")", ",", "axis", "=", "0", ")", "# [M, M]", "\n", "return", "tf", ".", "linalg", ".", "set_diag", "(", "_Kuu", ",", "tf", ".", "linalg", ".", "diag_part", "(", "_Kuu", ")", "+", "jitter", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_fallback": [[28, 41], ["Kfu.register", "gpflow.covariances.dispatch.Kuf", "list", "tensorflow.transpose", "len", "range", "gpflow_sampling.utils.get_inducing_shape"], "function", ["None"], ["@", "Kfu", ".", "register", "(", "InducingVariables", ",", "kernels", ".", "Kernel", ",", "TensorLike", ")", "\n", "def", "_Kfu_fallback", "(", "Z", ",", "kern", ",", "X", ",", "**", "kwargs", ")", ":", "\n", "  ", "Kuf", "=", "Kuf_dispatch", "(", "Z", ",", "kern", ",", "X", ",", "**", "kwargs", ")", "\n", "\n", "# Assume features of x and z are 1-dimensional", "\n", "ndims_x", "=", "X", ".", "shape", ".", "ndims", "-", "1", "# assume x lives in 1d space", "\n", "ndims_z", "=", "len", "(", "get_inducing_shape", "(", "Z", ")", ")", "-", "1", "\n", "assert", "ndims_x", "+", "ndims_z", "==", "Kuf", ".", "shape", ".", "ndims", "\n", "\n", "# Swap the batch axes of x and z", "\n", "axes", "=", "list", "(", "range", "(", "ndims_x", "+", "ndims_z", ")", ")", "\n", "perm", "=", "axes", "[", "ndims_z", ":", "ndims_z", "+", "ndims_x", "]", "+", "axes", "[", ":", "ndims_z", "]", "\n", "return", "tf", ".", "transpose", "(", "Kuf", ",", "perm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_fallback_multioutput": [[43, 56], ["Kfu.register", "gpflow.covariances.dispatch.Kuf", "list", "tensorflow.transpose", "range"], "function", ["None"], ["", "@", "Kfu", ".", "register", "(", "InducingVariables", ",", "kernels", ".", "MultioutputKernel", ",", "TensorLike", ")", "\n", "def", "_Kfu_fallback_multioutput", "(", "Z", ",", "kern", ",", "X", ",", "**", "kwargs", ")", ":", "\n", "  ", "Kuf", "=", "Kuf_dispatch", "(", "Z", ",", "kern", ",", "X", ",", "**", "kwargs", ")", "\n", "\n", "# Assume features of x and z are 1-dimensional", "\n", "ndims_x", "=", "X", ".", "shape", ".", "ndims", "-", "1", "# assume x lives in 1d space", "\n", "ndims_z", "=", "1", "# shared Z live in 1d space, separate Z are 2d but 1-to-1 with L", "\n", "assert", "ndims_x", "+", "ndims_z", "==", "Kuf", ".", "shape", ".", "ndims", "-", "1", "\n", "\n", "# Swap the batch axes of x and z", "\n", "axes", "=", "list", "(", "range", "(", "1", ",", "ndims_x", "+", "ndims_z", "+", "1", ")", ")", "# keep L output-features first", "\n", "perm", "=", "[", "0", "]", "+", "axes", "[", "ndims_z", ":", "ndims_z", "+", "ndims_x", "]", "+", "axes", "[", ":", "ndims_z", "]", "\n", "return", "tf", ".", "transpose", "(", "Kuf", ",", "perm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_fallback_shared": [[58, 63], ["Kfu.register", "Kfus._Kfu_fallback"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_fallback"], ["", "@", "Kfu", ".", "register", "(", "SharedIndependentInducingVariables", ",", "\n", "kernels", ".", "SharedIndependent", ",", "\n", "TensorLike", ")", "\n", "def", "_Kfu_fallback_shared", "(", "Z", ",", "kern", ",", "X", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "_Kfu_fallback", "(", "Z", ",", "kern", ",", "X", ",", "**", "kwargs", ")", "# Edge-case where L is supressed", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_conv2d_fallback": [[65, 81], ["kern.get_patches", "kern.kernel.K", "tensorflow.tensordot", "kern.get_spatial_out", "tensorflow.reshape", "tensorflow.reduce_mean", "list"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.Conv2dTranspose.get_spatial_out"], ["", "def", "_Kfu_conv2d_fallback", "(", "feat", ":", "InducingImages", ",", "\n", "kern", ":", "Conv2d", ",", "\n", "Xnew", ":", "tf", ".", "Tensor", ",", "\n", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "\n", "  ", "Zp", "=", "feat", ".", "as_patches", "# [M, patch_len]", "\n", "Xp", "=", "kern", ".", "get_patches", "(", "Xnew", ",", "full_spatial", "=", "full_spatial", ")", "\n", "Kxz", "=", "kern", ".", "kernel", ".", "K", "(", "Xp", ",", "Zp", ")", "# [N, H * W, M] or [N, H, W, M]", "\n", "if", "full_spatial", ":", "# convert to 4D image format", "\n", "    ", "spatial_out", "=", "kern", ".", "get_spatial_out", "(", "Xnew", ".", "shape", "[", "-", "3", ":", "-", "1", "]", ")", "# to [N, H, W, M]", "\n", "return", "tf", ".", "reshape", "(", "Kxz", ",", "list", "(", "Kxz", ".", "shape", "[", ":", "-", "2", "]", ")", "+", "spatial_out", "+", "[", "Kxz", ".", "shape", "[", "-", "1", "]", "]", ")", "\n", "\n", "", "if", "kern", ".", "weights", "is", "None", ":", "\n", "    ", "return", "tf", ".", "reduce_mean", "(", "Kxz", ",", "axis", "=", "-", "2", ")", "\n", "\n", "", "return", "tf", ".", "tensordot", "(", "Kxz", ",", "kern", ".", "weights", ",", "[", "-", "2", ",", "-", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_conv2d": [[83, 124], ["Kfu.register", "list", "tensorflow.square", "tensorflow.transpose", "tensorflow.reshape", "kern.convolve", "kern.kernel.K_r2", "tensorflow.reshape", "isinstance", "Kfus._Kfu_conv2d_fallback", "tensorflow.math.reciprocal", "tensorflow.reshape", "tensorflow.fill", "tensorflow.nn.conv2d", "tensorflow.square", "kern.convolve", "tensorflow.reshape", "tensorflow.reduce_mean", "tensorflow.tensordot", "list", "list", "tensorflow.square", "list", "list", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_conv2d_fallback", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve"], ["", "@", "Kfu", ".", "register", "(", "InducingImages", ",", "Conv2d", ",", "object", ")", "\n", "def", "_Kfu_conv2d", "(", "feat", ":", "InducingImages", ",", "\n", "kern", ":", "Conv2d", ",", "\n", "Xnew", ":", "tf", ".", "Tensor", ",", "\n", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "\n", "  ", "if", "not", "isinstance", "(", "kern", ".", "kernel", ",", "kernels", ".", "Stationary", ")", ":", "\n", "    ", "return", "_Kfu_conv2d_fallback", "(", "feat", ",", "kern", ",", "Xnew", ",", "full_spatial", ")", "\n", "\n", "# Compute (squared) Mahalanobis distances between patches", "\n", "", "patch_shape", "=", "list", "(", "kern", ".", "patch_shape", ")", "\n", "channels_in", "=", "Xnew", ".", "shape", "[", "-", "3", "if", "kern", ".", "data_format", "==", "\"NCHW\"", "else", "-", "1", "]", "\n", "precis", "=", "tf", ".", "square", "(", "tf", ".", "math", ".", "reciprocal", "(", "kern", ".", "kernel", ".", "lengthscales", ")", ")", "\n", "\n", "# Construct lengthscale filters [h, w, channels_in, 1]", "\n", "if", "kern", ".", "kernel", ".", "ard", ":", "\n", "    ", "filters", "=", "tf", ".", "reshape", "(", "precis", ",", "patch_shape", "+", "[", "channels_in", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "    ", "filters", "=", "tf", ".", "fill", "(", "patch_shape", "+", "[", "channels_in", ",", "1", "]", ",", "precis", ")", "\n", "\n", "", "r2", "=", "tf", ".", "transpose", "(", "tf", ".", "nn", ".", "conv2d", "(", "input", "=", "tf", ".", "square", "(", "feat", ".", "as_images", ")", ",", "\n", "filters", "=", "filters", ",", "\n", "strides", "=", "[", "1", ",", "1", "]", ",", "\n", "padding", "=", "\"VALID\"", ")", ")", "\n", "\n", "X", "=", "tf", ".", "reshape", "(", "Xnew", ",", "[", "-", "1", "]", "+", "list", "(", "Xnew", ".", "shape", ")", "[", "-", "3", ":", "]", ")", "# stack as 4d images", "\n", "r2", "+=", "kern", ".", "convolve", "(", "tf", ".", "square", "(", "X", ")", ",", "filters", ")", "# [N, height_out, width_out, M]", "\n", "\n", "filters", "*=", "feat", ".", "as_filters", "# [h, w, channels_in, M]", "\n", "r2", "-=", "2", "*", "kern", ".", "convolve", "(", "X", ",", "filters", ")", "\n", "\n", "Kxz", "=", "kern", ".", "kernel", ".", "K_r2", "(", "r2", ")", "\n", "if", "not", "full_spatial", ":", "\n", "    ", "Kxz", "=", "tf", ".", "reshape", "(", "Kxz", ",", "list", "(", "Kxz", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "[", "-", "1", ",", "len", "(", "feat", ")", "]", ")", "# [N, P, M]", "\n", "if", "kern", ".", "weights", "is", "None", ":", "\n", "      ", "Kxz", "=", "tf", ".", "reduce_mean", "(", "Kxz", ",", "axis", "=", "-", "2", ")", "\n", "", "else", ":", "\n", "      ", "Kxz", "=", "tf", ".", "tensordot", "(", "Kxz", ",", "kern", ".", "weights", ",", "[", "-", "2", ",", "-", "1", "]", ")", "\n", "\n", "# Undo stacking of Xnew as 4d images X", "\n", "", "", "return", "tf", ".", "reshape", "(", "Kxz", ",", "list", "(", "Xnew", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "list", "(", "Kxz", ".", "shape", "[", "1", ":", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_depthwise_conv2d_fallback": [[126, 145], ["kern.get_patches", "tensorflow.reduce_sum", "kern.kernel.K_r2", "tensorflow.tensordot", "tensorflow.math.squared_difference", "tensorflow.reshape", "tensorflow.reduce_mean", "tensorflow.expand_dims", "kern.kernel.scale", "gpflow_sampling.utils.move_axis", "kern.kernel.scale", "list"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.get_patches", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "def", "_Kfu_depthwise_conv2d_fallback", "(", "feat", ":", "DepthwiseInducingImages", ",", "\n", "kern", ":", "DepthwiseConv2d", ",", "\n", "Xnew", ":", "tf", ".", "Tensor", ",", "\n", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "\n", "  ", "Zp", "=", "feat", ".", "as_patches", "# [M, channels_in, patch_len]", "\n", "Xp", "=", "kern", ".", "get_patches", "(", "Xnew", ",", "full_spatial", "=", "full_spatial", ")", "\n", "r2", "=", "tf", ".", "reduce_sum", "(", "tf", ".", "math", ".", "squared_difference", "(", "# compute square distances", "\n", "tf", ".", "expand_dims", "(", "kern", ".", "kernel", ".", "scale", "(", "Xp", ")", ",", "-", "Zp", ".", "shape", ".", "ndims", ")", ",", "\n", "kern", ".", "kernel", ".", "scale", "(", "Zp", ")", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "Kxz", "=", "kern", ".", "kernel", ".", "K_r2", "(", "r2", ")", "\n", "if", "full_spatial", ":", "# convert to 4D image format as [N, H, W, channels_in * M]", "\n", "    ", "return", "tf", ".", "reshape", "(", "move_axis", "(", "Kxz", ",", "-", "1", ",", "-", "2", ")", ",", "list", "(", "Kxz", ".", "shape", "[", ":", "-", "2", "]", ")", "+", "[", "-", "1", "]", ")", "\n", "\n", "", "if", "kern", ".", "weights", "is", "None", ":", "# reduce over channels and patches", "\n", "    ", "return", "tf", ".", "reduce_mean", "(", "Kxz", ",", "axis", "=", "[", "-", "3", ",", "-", "1", "]", ")", "\n", "\n", "", "return", "tf", ".", "tensordot", "(", "kern", ".", "weights", ",", "Kxz", ",", "axes", "=", "[", "(", "0", ",", "1", ")", ",", "(", "-", "3", ",", "-", "1", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_depthwise_conv2d": [[147, 197], ["Kfu.register", "list", "tensorflow.square", "tensorflow.nn.depthwise_conv2d", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.repeat", "kern.kernel.K_r2", "tensorflow.reshape", "isinstance", "Kfus._Kfu_depthwise_conv2d_fallback", "len", "tensorflow.math.reciprocal", "tensorflow.reshape", "tensorflow.fill", "gpflow_sampling.utils.move_axis", "kern.convolve", "len", "kern.convolve", "tensorflow.reduce_mean", "tensorflow.reshape", "tuple", "tensorflow.transpose", "tensorflow.square", "tensorflow.square", "tensorflow.reshape", "tensorflow.reduce_mean", "tensorflow.cast", "list", "list", "tensorflow.reduce_prod", "list", "list", "tensorflow.tensordot", "list", "len", "tensorflow.reshape"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kfus._Kfu_depthwise_conv2d_fallback", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve"], ["", "@", "Kfu", ".", "register", "(", "DepthwiseInducingImages", ",", "DepthwiseConv2d", ",", "object", ")", "\n", "def", "_Kfu_depthwise_conv2d", "(", "feat", ":", "DepthwiseInducingImages", ",", "\n", "kern", ":", "DepthwiseConv2d", ",", "\n", "Xnew", ":", "tf", ".", "Tensor", ",", "\n", "full_spatial", ":", "bool", "=", "False", ")", ":", "\n", "\n", "  ", "if", "not", "isinstance", "(", "kern", ".", "kernel", ",", "kernels", ".", "Stationary", ")", ":", "\n", "    ", "return", "_Kfu_depthwise_conv2d_fallback", "(", "feat", ",", "kern", ",", "Xnew", ",", "full_spatial", ")", "\n", "\n", "# Compute (squared) Mahalanobis distances between patches", "\n", "", "patch_shape", "=", "list", "(", "kern", ".", "patch_shape", ")", "\n", "channels_in", "=", "Xnew", ".", "shape", "[", "-", "3", "if", "kern", ".", "data_format", "==", "\"NCHW\"", "else", "-", "1", "]", "\n", "channels_out", "=", "len", "(", "feat", ")", "*", "channels_in", "\n", "precis", "=", "tf", ".", "square", "(", "tf", ".", "math", ".", "reciprocal", "(", "kern", ".", "kernel", ".", "lengthscales", ")", ")", "\n", "\n", "# Construct lengthscale filters [h, w, channels_in, 1]", "\n", "if", "kern", ".", "kernel", ".", "ard", ":", "# notice the transpose!", "\n", "    ", "assert", "tuple", "(", "precis", ".", "shape", ")", "==", "(", "channels_in", ",", "tf", ".", "reduce_prod", "(", "patch_shape", ")", ")", "\n", "filters", "=", "tf", ".", "reshape", "(", "tf", ".", "transpose", "(", "precis", ")", ",", "patch_shape", "+", "[", "channels_in", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "    ", "filters", "=", "tf", ".", "fill", "(", "patch_shape", "+", "[", "channels_in", ",", "1", "]", ",", "precis", ")", "\n", "\n", "", "ZZ", "=", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "input", "=", "tf", ".", "square", "(", "feat", ".", "as_images", ")", ",", "\n", "filter", "=", "filters", ",", "\n", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "\n", "padding", "=", "\"VALID\"", ")", "# [M, 1, 1, channels_in]", "\n", "\n", "r2", "=", "tf", ".", "reshape", "(", "move_axis", "(", "ZZ", ",", "0", ",", "-", "1", ")", ",", "[", "1", ",", "1", ",", "1", ",", "channels_out", "]", ")", "\n", "\n", "X", "=", "tf", ".", "reshape", "(", "Xnew", ",", "[", "-", "1", "]", "+", "list", "(", "Xnew", ".", "shape", ")", "[", "-", "3", ":", "]", ")", "# stack as 4d images", "\n", "r2", "+=", "tf", ".", "repeat", "(", "kern", ".", "convolve", "(", "tf", ".", "square", "(", "X", ")", ",", "filters", ")", ",", "len", "(", "feat", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "filters", "*=", "feat", ".", "as_filters", "# [h, w, channels_in, M]", "\n", "r2", "-=", "2", "*", "kern", ".", "convolve", "(", "X", ",", "filters", ")", "# [N, height_out, width_out, chan_out]", "\n", "\n", "Kxz", "=", "kern", ".", "kernel", ".", "K_r2", "(", "r2", ")", "\n", "if", "full_spatial", ":", "\n", "    ", "Kxz", "=", "tf", ".", "reduce_mean", "(", "\n", "tf", ".", "reshape", "(", "Kxz", ",", "list", "(", "Kxz", ".", "shape", "[", ":", "-", "1", "]", ")", "+", "[", "channels_in", ",", "-", "1", "]", ")", ",", "\n", "axis", "=", "-", "2", ")", "# average over input channels", "\n", "", "else", ":", "\n", "    ", "Kxz", "=", "tf", ".", "reshape", "(", "Kxz", ",", "list", "(", "Kxz", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "[", "-", "1", ",", "len", "(", "feat", ")", "]", ")", "# [N, P, M]", "\n", "if", "kern", ".", "weights", "is", "None", ":", "\n", "      ", "Kxz", "=", "tf", ".", "reduce_mean", "(", "Kxz", ",", "axis", "=", "-", "2", ")", "\n", "", "else", ":", "\n", "      ", "div", "=", "tf", ".", "cast", "(", "1", "/", "channels_in", ",", "Kxz", ".", "dtype", ")", "\n", "Kxz", "=", "div", "*", "tf", ".", "tensordot", "(", "Kxz", ",", "tf", ".", "reshape", "(", "kern", ".", "weights", ",", "[", "-", "1", "]", ")", ",", "[", "-", "2", ",", "-", "1", "]", ")", "\n", "\n", "# Undo stacking of Xnew as 4d images X", "\n", "", "", "return", "tf", ".", "reshape", "(", "Kxz", ",", "list", "(", "Xnew", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "list", "(", "Kxz", ".", "shape", "[", "1", ":", "]", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.covariances.Kufs._Kuf_conv2d_fallback": [[21, 37], ["gpflow.covariances.dispatch.Kuf.register", "gpflow_sampling.covariances.Kfus.Kfu", "list", "tensorflow.transpose", "gpflow_sampling.utils.swap_axes", "range"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes"], ["@", "Kuf", ".", "register", "(", "InducingImages", ",", "Conv2d", ",", "TensorLike", ")", "\n", "def", "_Kuf_conv2d_fallback", "(", "Z", ",", "kernel", ",", "X", ",", "full_spatial", ":", "bool", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "  ", "Kfu", "=", "Kfu_dispatch", "(", "Z", ",", "kernel", ",", "X", ",", "full_spatial", "=", "full_spatial", ",", "**", "kwargs", ")", "\n", "\n", "ndims_x", "=", "X", ".", "shape", ".", "ndims", "-", "3", "# assume x lives in 3d image space", "\n", "ndims_z", "=", "Z", ".", "as_images", ".", "shape", ".", "ndims", "-", "3", "\n", "\n", "if", "full_spatial", ":", "\n", "    ", "assert", "Kfu", ".", "shape", ".", "ndims", "==", "ndims_x", "+", "ndims_z", "+", "2", "\n", "return", "swap_axes", "(", "Kfu", ",", "-", "4", ",", "-", "1", ")", "# TODO: this is a hack", "\n", "\n", "# Swap the batch axes of x and z", "\n", "", "assert", "Kfu", ".", "shape", ".", "ndims", "==", "ndims_x", "+", "ndims_z", "\n", "axes", "=", "list", "(", "range", "(", "ndims_x", "+", "ndims_z", ")", ")", "\n", "perm", "=", "axes", "[", "ndims_x", ":", "ndims_x", "+", "ndims_z", "]", "+", "axes", "[", ":", "ndims_x", "]", "\n", "return", "tf", ".", "transpose", "(", "Kfu", ",", "perm", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.AbstractSampler.__call__": [[31, 34], ["None"], "methods", ["None"], ["  ", "@", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.AbstractSampler.sample_shape": [[35, 38], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sample_shape", "(", "self", ")", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.CompositeSampler.__init__": [[41, 53], ["tensorflow.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "join_rule", ":", "Callable", ",", "\n", "samplers", ":", "List", "[", "Callable", "]", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Combine base samples via a specified join rule.\n    \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "_join_rule", "=", "join_rule", "\n", "self", ".", "_samplers", "=", "samplers", "\n", "self", ".", "mean_function", "=", "mean_function", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.CompositeSampler.__call__": [[54, 58], ["core.CompositeSampler.join_rule", "sampler", "core.CompositeSampler.mean_function"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.CompositeSampler.join_rule"], ["", "def", "__call__", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "samples", "=", "[", "sampler", "(", "x", ",", "**", "kwargs", ")", "for", "sampler", "in", "self", ".", "samplers", "]", "\n", "vals", "=", "self", ".", "join_rule", "(", "samples", ")", "\n", "return", "vals", "if", "self", ".", "mean_function", "is", "None", "else", "vals", "+", "self", ".", "mean_function", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.CompositeSampler.join_rule": [[59, 62], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "join_rule", "(", "self", ")", "->", "Callable", ":", "\n", "    ", "return", "self", ".", "_join_rule", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.CompositeSampler.samplers": [[63, 66], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "samplers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_samplers", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.CompositeSampler.sample_shape": [[67, 75], ["enumerate"], "methods", ["None"], ["", "@", "property", "\n", "def", "sample_shape", "(", "self", ")", ":", "\n", "    ", "for", "i", ",", "sampler", "in", "enumerate", "(", "self", ".", "samplers", ")", ":", "\n", "      ", "if", "i", "==", "0", ":", "\n", "        ", "sample_shape", "=", "sampler", ".", "sample_shape", "\n", "", "else", ":", "\n", "        ", "assert", "sample_shape", "==", "sampler", ".", "sample_shape", "\n", "", "", "return", "sample_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.DenseSampler.__init__": [[78, 93], ["tensorflow.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "weights", ":", "Union", "[", "tf", ".", "Tensor", ",", "tf", ".", "Variable", "]", ",", "\n", "basis", ":", "Callable", "=", "None", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n", "sample_axis", ":", "int", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Return samples as weighted sums of features.\n    \"\"\"", "\n", "assert", "weights", ".", "shape", ".", "ndims", ">", "1", "\n", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "weights", "=", "weights", "\n", "self", ".", "basis", "=", "basis", "\n", "self", ".", "mean_function", "=", "mean_function", "\n", "self", ".", "sample_axis", "=", "sample_axis", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.DenseSampler.__call__": [[94, 125], ["gpflow_sampling.utils.move_axis", "core.DenseSampler.basis", "len", "len", "gpflow_sampling.utils.batch_tensordot", "len", "core.DenseSampler.mean_function", "isinstance", "gpflow_sampling.utils.get_inducing_shape", "gpflow_sampling.utils.normalize_axis"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis"], ["", "def", "__call__", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ",", "sample_axis", ":", "int", "=", "\"default\"", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param sample_axis: Specify an axis of inputs x as corresponding 1-to-1 with\n           sample-specific slices of weight tensor w when computing tensor dot\n           products.\n    \"\"\"", "\n", "if", "sample_axis", "==", "\"default\"", ":", "\n", "      ", "sample_axis", "=", "self", ".", "sample_axis", "\n", "\n", "", "feat", "=", "x", "if", "self", ".", "basis", "is", "None", "else", "self", ".", "basis", "(", "x", ",", "**", "kwargs", ")", "\n", "if", "sample_axis", "is", "None", ":", "\n", "      ", "batch_axes", "=", "None", "\n", "", "else", ":", "\n", "      ", "assert", "len", "(", "self", ".", "sample_shape", ")", ",", "\"Received sample_axis but self.weights has\"", "\" no dedicated axis for samples; this\"", "\" usually implies that sample_shape=[].\"", "\n", "\n", "ndims_x", "=", "len", "(", "get_inducing_shape", "(", "x", ")", "if", "\n", "isinstance", "(", "x", ",", "InducingVariables", ")", "else", "x", ".", "shape", ")", "\n", "\n", "batch_axes", "=", "[", "-", "3", ",", "normalize_axis", "(", "sample_axis", ",", "ndims_x", ")", "-", "ndims_x", "]", "\n", "\n", "# Batch-axes notwithstanding, shape(vals) = [N, S] (after move_axis)", "\n", "", "vals", "=", "move_axis", "(", "batch_tensordot", "(", "self", ".", "weights", ",", "\n", "feat", ",", "\n", "axes", "=", "[", "-", "1", ",", "-", "1", "]", ",", "\n", "batch_axes", "=", "batch_axes", ")", ",", "\n", "len", "(", "self", ".", "sample_shape", ")", ",", "# axis=-2 houses scalar output 1", "\n", "-", "1", ")", "\n", "\n", "return", "vals", "if", "self", ".", "mean_function", "is", "None", "else", "vals", "+", "self", ".", "mean_function", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.DenseSampler.sample_shape": [[126, 132], ["list", "len"], "methods", ["None"], ["", "@", "property", "\n", "def", "sample_shape", "(", "self", ")", ":", "\n", "    ", "w_shape", "=", "list", "(", "self", ".", "weights", ".", "shape", ")", "\n", "if", "len", "(", "w_shape", ")", "==", "2", ":", "\n", "      ", "return", "[", "]", "\n", "", "return", "w_shape", "[", ":", "-", "2", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.MultioutputDenseSampler.__init__": [[135, 147], ["core.DenseSampler.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "weights", ":", "Union", "[", "tf", ".", "Tensor", ",", "tf", ".", "Variable", "]", ",", "\n", "*", "args", ",", "\n", "multioutput_axis", ":", "int", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param multioutput_axis: Specify an axis of inputs x (or features thereof)\n           as corresponding 1-to-1 with output-feature-specific slices of weight\n           tensor w when computing tensor dot products.\n    \"\"\"", "\n", "self", ".", "multioutput_axis", "=", "multioutput_axis", "\n", "super", "(", ")", ".", "__init__", "(", "weights", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.core.MultioutputDenseSampler.__call__": [[148, 187], ["gpflow_sampling.utils.move_axis", "len", "batch_w.append", "len", "batch_x.append", "core.MultioutputDenseSampler.basis", "gpflow_sampling.utils.batch_tensordot", "len", "core.MultioutputDenseSampler.mean_function", "isinstance", "gpflow_sampling.utils.get_inducing_shape", "gpflow_sampling.utils.normalize_axis"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.normalize_axis"], ["", "def", "__call__", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ",", "sample_axis", ":", "int", "=", "\"default\"", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    :param sample_axis: Specify an axis of inputs x as corresponding 1-to-1 with\n           sample-specific slices of weight tensor w when computing tensor dot\n           products.\n\n    TODO: Improve hard-coding of multioutput-/sample-axis of weights.\n    \"\"\"", "\n", "if", "sample_axis", "==", "\"default\"", ":", "\n", "      ", "sample_axis", "=", "self", ".", "sample_axis", "\n", "\n", "", "if", "self", ".", "multioutput_axis", "is", "None", ":", "\n", "      ", "batch_w", "=", "[", "]", "# batch axes for w", "\n", "batch_x", "=", "[", "]", "# batch axes for x", "\n", "", "else", ":", "\n", "      ", "batch_w", "=", "[", "-", "2", "]", "\n", "batch_x", "=", "[", "self", ".", "multioutput_axis", "]", "\n", "\n", "", "if", "sample_axis", "is", "not", "None", ":", "\n", "      ", "assert", "len", "(", "self", ".", "sample_shape", ")", ",", "\"Received sample_axis but self.weights has\"", "\" no dedicated axis for samples; this\"", "\" usually implies that sample_shape=[].\"", "\n", "batch_w", ".", "append", "(", "-", "3", ")", "\n", "\n", "# TODO: If basis(x) grows the rank of x, it should only do so from the", "\n", "#       left, such that the negative i-th axis (i > 1) remains the same.", "\n", "ndims_x", "=", "len", "(", "get_inducing_shape", "(", "x", ")", "if", "\n", "isinstance", "(", "x", ",", "InducingVariables", ")", "else", "x", ".", "shape", ")", "\n", "batch_x", ".", "append", "(", "normalize_axis", "(", "sample_axis", ",", "ndims_x", ")", "-", "ndims_x", ")", "\n", "\n", "", "feat", "=", "x", "if", "self", ".", "basis", "is", "None", "else", "self", ".", "basis", "(", "x", ",", "**", "kwargs", ")", "\n", "vals", "=", "move_axis", "(", "batch_tensordot", "(", "self", ".", "weights", ",", "# output features go last", "\n", "feat", ",", "\n", "axes", "=", "[", "-", "1", ",", "-", "1", "]", ",", "\n", "batch_axes", "=", "[", "batch_w", ",", "batch_x", "]", ")", ",", "\n", "len", "(", "self", ".", "sample_shape", ")", ",", "# axis=-2 houses multioutputs L", "\n", "-", "1", ")", "\n", "\n", "return", "vals", "if", "self", ".", "mean_function", "is", "None", "else", "vals", "+", "self", ".", "mean_function", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.decoupled_samplers._decoupled_fallback": [[28, 44], ["decoupled.register", "prior", "update_rule", "gpflow_sampling.sampling.core.CompositeSampler"], "function", ["None"], ["@", "decoupled", ".", "register", "(", "Kernel", ",", "AbstractSampler", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_decoupled_fallback", "(", "kern", ":", "Kernel", ",", "\n", "prior", ":", "AbstractSampler", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "*", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n", "update_rule", ":", "Callable", "=", "exact_update", ",", "\n", "join_rule", ":", "Callable", "=", "sum", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "f", "=", "prior", "(", "Z", ",", "sample_axis", "=", "None", ")", "# [S, M, L]", "\n", "update", "=", "update_rule", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "**", "kwargs", ")", "\n", "return", "CompositeSampler", "(", "samplers", "=", "[", "prior", ",", "update", "]", ",", "\n", "join_rule", "=", "join_rule", ",", "\n", "mean_function", "=", "mean_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.decoupled_samplers._decoupled_multioutput": [[46, 73], ["decoupled.register", "prior", "update_rule", "gpflow_sampling.sampling.core.CompositeSampler", "isinstance", "isinstance"], "function", ["None"], ["", "@", "decoupled", ".", "register", "(", "MultioutputKernel", ",", "AbstractSampler", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_decoupled_multioutput", "(", "kern", ":", "MultioutputKernel", ",", "\n", "prior", ":", "AbstractSampler", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "*", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n", "update_rule", ":", "Callable", "=", "exact_update", ",", "\n", "join_rule", ":", "Callable", "=", "sum", ",", "\n", "multioutput_axis_Z", ":", "int", "=", "\"default\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "# Determine whether or not to evalaute Z pathwise (per output feature)", "\n", "# TODO: Ugly. This argument is actually being passed to the prior's basis.", "\n", "#       Disallow non-inducing-variable Z for multioutput cases of decoupled?", "\n", "  ", "if", "multioutput_axis_Z", "==", "\"default\"", ":", "\n", "    ", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "MultioutputInducingVariables", ")", "and", "not", "isinstance", "(", "Z", ",", "inducing_variables", ".", "SharedIndependentInducingVariables", ")", ":", "\n", "      ", "multioutput_axis_Z", "=", "0", "\n", "", "else", ":", "\n", "      ", "multioutput_axis_Z", "=", "None", "\n", "\n", "", "", "f", "=", "prior", "(", "Z", ",", "sample_axis", "=", "None", ",", "multioutput_axis", "=", "multioutput_axis_Z", ")", "\n", "update", "=", "update_rule", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "**", "kwargs", ")", "\n", "return", "CompositeSampler", "(", "samplers", "=", "[", "prior", ",", "update", "]", ",", "\n", "join_rule", "=", "join_rule", ",", "\n", "mean_function", "=", "mean_function", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.decoupled_samplers._decoupled_lcm": [[75, 87], ["decoupled.register", "decoupled_samplers._decoupled_multioutput", "tensorflow.tensordot", "sum"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.decoupled_samplers._decoupled_multioutput"], ["", "@", "decoupled", ".", "register", "(", "LinearCoregionalization", ",", "AbstractSampler", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_decoupled_lcm", "(", "kern", ":", "LinearCoregionalization", ",", "\n", "prior", ":", "AbstractSampler", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "*", ",", "\n", "join_rule", ":", "Callable", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "if", "join_rule", "is", "None", ":", "\n", "    ", "def", "join_rule", "(", "terms", ":", "List", "[", "tf", ".", "Tensor", "]", ")", "->", "tf", ".", "Tensor", ":", "\n", "      ", "return", "tf", ".", "tensordot", "(", "kern", ".", "W", ",", "sum", "(", "terms", ")", ",", "axes", "=", "[", "-", "1", ",", "0", "]", ")", "\n", "", "", "return", "_decoupled_multioutput", "(", "kern", ",", "prior", ",", "Z", ",", "u", ",", "join_rule", "=", "join_rule", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.sampling.decoupled_samplers._decoupled_conv": [[89, 105], ["decoupled.register", "tensorflow.squeeze", "update_rule", "gpflow_sampling.sampling.core.CompositeSampler", "prior"], "function", ["None"], ["", "@", "decoupled", ".", "register", "(", "Conv2d", ",", "AbstractSampler", ",", "InducingImages", ",", "TensorLike", ")", "\n", "def", "_decoupled_conv", "(", "kern", ":", "Conv2d", ",", "\n", "prior", ":", "AbstractSampler", ",", "\n", "Z", ":", "InducingImages", ",", "\n", "u", ":", "TensorLike", ",", "\n", "*", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n", "update_rule", ":", "Callable", "=", "exact_update", ",", "\n", "join_rule", ":", "Callable", "=", "sum", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "f", "=", "tf", ".", "squeeze", "(", "prior", "(", "Z", ",", "sample_axis", "=", "None", ")", ",", "axis", "=", "[", "-", "3", ",", "-", "2", "]", ")", "# [S, M, L]", "\n", "update", "=", "update_rule", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "**", "kwargs", ")", "\n", "return", "CompositeSampler", "(", "samplers", "=", "[", "prior", ",", "update", "]", ",", "\n", "join_rule", "=", "join_rule", ",", "\n", "mean_function", "=", "mean_function", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.linear_updates._linear_fallback": [[29, 86], ["linear.register", "tuple", "tuple", "isinstance", "tensorflow.expand_dims", "gpflow_sampling.utils.swap_axes", "gpflow_sampling.sampling.core.DenseSampler", "gpflow.config.default_jitter", "tensorflow.convert_to_tensor", "isinstance", "basis", "tensorflow.sqrt", "tensorflow.random.normal", "tensorflow.linalg.adjoint", "tensorflow.linalg.cholesky_solve", "tensorflow.matmul", "gpflow_sampling.utils.inducing_to_tensor", "tensorflow.matmul", "tensorflow.linalg.cholesky", "tensorflow.matmul", "tensorflow.linalg.set_diag", "tensorflow.linalg.cholesky", "min", "tensorflow.math.reciprocal", "tensorflow.linalg.cholesky_solve", "gpflow_sampling.utils.move_axis", "tensorflow.math.reciprocal", "tensorflow.matmul", "len", "tensorflow.eye", "tensorflow.linalg.diag_part"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["@", "linear", ".", "register", "(", "TensorLike", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_linear_fallback", "(", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "f", ":", "TensorLike", ",", "\n", "*", ",", "\n", "L", ":", "TensorLike", "=", "None", ",", "\n", "diag", ":", "TensorLike", "=", "None", ",", "\n", "basis", ":", "AbstractBasis", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "u_shape", "=", "tuple", "(", "u", ".", "shape", ")", "\n", "f_shape", "=", "tuple", "(", "f", ".", "shape", ")", "\n", "assert", "u_shape", "[", "-", "1", "]", "==", "1", ",", "\"Recieved multiple output features\"", "\n", "assert", "u_shape", "==", "f_shape", "[", "-", "len", "(", "u_shape", ")", ":", "]", ",", "\"Incompatible shapes detected\"", "\n", "\n", "# Prepare diagonal term", "\n", "if", "diag", "is", "None", ":", "# used by <GPflow.conditionals>", "\n", "    ", "diag", "=", "default_jitter", "(", ")", "\n", "", "if", "isinstance", "(", "diag", ",", "float", ")", ":", "\n", "    ", "diag", "=", "tf", ".", "convert_to_tensor", "(", "diag", ",", "dtype", "=", "f", ".", "dtype", ")", "\n", "", "diag", "=", "tf", ".", "expand_dims", "(", "diag", ",", "axis", "=", "-", "1", ")", "# [M, 1] or [1, 1] or [1]", "\n", "\n", "# Extract \"features\" of Z", "\n", "if", "basis", "is", "None", ":", "\n", "    ", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "InducingVariables", ")", ":", "\n", "      ", "feat", "=", "inducing_to_tensor", "(", "Z", ")", "# [M, D]", "\n", "", "else", ":", "\n", "      ", "feat", "=", "Z", "\n", "", "", "else", ":", "\n", "    ", "feat", "=", "basis", "(", "Z", ")", "# [M, D] (maybe a different \"D\" than above)", "\n", "\n", "# Compute error term and matrix square root $Cov(u, u)^{1/2}$", "\n", "", "err", "=", "swap_axes", "(", "u", "-", "f", ",", "-", "3", ",", "-", "1", ")", "# [1, M, S]", "\n", "err", "-=", "tf", ".", "sqrt", "(", "diag", ")", "*", "tf", ".", "random", ".", "normal", "(", "err", ".", "shape", ",", "dtype", "=", "err", ".", "dtype", ")", "\n", "M", ",", "D", "=", "feat", ".", "shape", "[", "-", "2", ":", "]", "\n", "if", "L", "is", "None", ":", "\n", "    ", "if", "D", "<", "M", ":", "\n", "      ", "feat_iDiag", "=", "feat", "*", "tf", ".", "math", ".", "reciprocal", "(", "diag", ")", "\n", "S", "=", "tf", ".", "matmul", "(", "feat_iDiag", ",", "feat", ",", "transpose_a", "=", "True", ")", "# [D, D]", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "S", "+", "tf", ".", "eye", "(", "S", ".", "shape", "[", "-", "1", "]", ",", "dtype", "=", "S", ".", "dtype", ")", ")", "\n", "", "else", ":", "\n", "      ", "K", "=", "tf", ".", "matmul", "(", "feat", ",", "feat", ",", "transpose_b", "=", "True", ")", "# [M, M]", "\n", "K", "=", "tf", ".", "linalg", ".", "set_diag", "(", "K", ",", "tf", ".", "linalg", ".", "diag_part", "(", "K", ")", "+", "diag", "[", "...", ",", "0", "]", ")", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "", "", "else", ":", "\n", "    ", "assert", "L", ".", "shape", "[", "-", "1", "]", "==", "min", "(", "M", ",", "D", ")", "# TODO: improve me", "\n", "\n", "# Solve for $Cov(u, u)^{-1}(u - f(Z))$", "\n", "", "if", "D", "<", "M", ":", "\n", "    ", "feat_iDiag", "=", "feat", "*", "tf", ".", "math", ".", "reciprocal", "(", "diag", ")", "\n", "weights", "=", "tf", ".", "linalg", ".", "adjoint", "(", "tf", ".", "linalg", ".", "cholesky_solve", "(", "L", ",", "\n", "tf", ".", "matmul", "(", "feat_iDiag", ",", "err", ",", "transpose_a", "=", "True", ")", ")", ")", "\n", "", "else", ":", "\n", "    ", "iK_err", "=", "tf", ".", "linalg", ".", "cholesky_solve", "(", "L", ",", "err", ")", "# [S, M, 1]", "\n", "weights", "=", "tf", ".", "matmul", "(", "iK_err", ",", "feat", ",", "transpose_a", "=", "True", ")", "# [S, 1, D]", "\n", "\n", "", "return", "DenseSampler", "(", "basis", "=", "basis", ",", "weights", "=", "move_axis", "(", "weights", ",", "-", "2", ",", "-", "3", ")", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.linear_updates._linear_multioutput": [[88, 151], ["linear.register", "isinstance", "tensorflow.expand_dims", "gpflow_sampling.utils.swap_axes", "gpflow_sampling.sampling.core.MultioutputDenseSampler", "tuple", "tuple", "gpflow.config.default_jitter", "tensorflow.convert_to_tensor", "isinstance", "isinstance", "tensorflow.sqrt", "tensorflow.random.normal", "tensorflow.linalg.adjoint", "tensorflow.linalg.cholesky_solve", "tensorflow.matmul", "gpflow_sampling.utils.inducing_to_tensor", "basis", "basis", "tensorflow.matmul", "tensorflow.linalg.cholesky", "tensorflow.matmul", "tensorflow.linalg.set_diag", "tensorflow.linalg.cholesky", "min", "tensorflow.math.reciprocal", "tensorflow.linalg.cholesky_solve", "gpflow_sampling.utils.swap_axes", "tensorflow.math.reciprocal", "tensorflow.matmul", "tensorflow.eye", "tensorflow.linalg.diag_part"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes"], ["", "@", "linear", ".", "register", "(", "inducing_variables", ".", "MultioutputInducingVariables", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ")", "\n", "def", "_linear_multioutput", "(", "Z", ":", "inducing_variables", ".", "MultioutputInducingVariables", ",", "\n", "u", ":", "TensorLike", ",", "\n", "f", ":", "TensorLike", ",", "\n", "*", ",", "\n", "L", ":", "TensorLike", "=", "None", ",", "\n", "diag", ":", "TensorLike", "=", "None", ",", "\n", "basis", ":", "AbstractBasis", "=", "None", ",", "\n", "multioutput_axis", ":", "int", "=", "\"default\"", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "assert", "tuple", "(", "u", ".", "shape", ")", "==", "tuple", "(", "f", ".", "shape", ")", "\n", "if", "multioutput_axis", "==", "\"default\"", ":", "\n", "    ", "multioutput_axis", "=", "None", "if", "(", "basis", "is", "None", ")", "else", "0", "\n", "\n", "# Prepare diagonal term", "\n", "", "if", "diag", "is", "None", ":", "# used by <GPflow.conditionals>", "\n", "    ", "diag", "=", "default_jitter", "(", ")", "\n", "", "if", "isinstance", "(", "diag", ",", "float", ")", ":", "\n", "    ", "diag", "=", "tf", ".", "convert_to_tensor", "(", "diag", ",", "dtype", "=", "f", ".", "dtype", ")", "\n", "", "diag", "=", "tf", ".", "expand_dims", "(", "diag", ",", "axis", "=", "-", "1", ")", "# ([L] or []) + ([M] or []) + [1]", "\n", "\n", "# Extract \"features\" of Z", "\n", "if", "basis", "is", "None", ":", "\n", "    ", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "InducingVariables", ")", ":", "\n", "      ", "feat", "=", "inducing_to_tensor", "(", "Z", ")", "# [L, M, D] or [M, D]", "\n", "", "else", ":", "\n", "      ", "feat", "=", "Z", "\n", "", "", "elif", "isinstance", "(", "Z", ",", "inducing_variables", ".", "SharedIndependentInducingVariables", ")", ":", "\n", "    ", "feat", "=", "basis", "(", "Z", ")", "\n", "", "else", ":", "\n", "    ", "feat", "=", "basis", "(", "Z", ",", "multioutput_axis", "=", "0", ")", "# first axis of Z is output-specific", "\n", "\n", "# Compute error term and matrix square root $Cov(u, u)^{1/2}$", "\n", "", "err", "=", "swap_axes", "(", "u", "-", "f", ",", "-", "3", ",", "-", "1", ")", "# [L, M, S]", "\n", "err", "-=", "tf", ".", "sqrt", "(", "diag", ")", "*", "tf", ".", "random", ".", "normal", "(", "err", ".", "shape", ",", "dtype", "=", "err", ".", "dtype", ")", "\n", "M", ",", "D", "=", "feat", ".", "shape", "[", "-", "2", ":", "]", "\n", "if", "L", "is", "None", ":", "\n", "    ", "if", "D", "<", "M", ":", "\n", "      ", "feat_iDiag", "=", "feat", "*", "tf", ".", "math", ".", "reciprocal", "(", "diag", ")", "\n", "S", "=", "tf", ".", "matmul", "(", "feat_iDiag", ",", "feat", ",", "transpose_a", "=", "True", ")", "# [L, D, D] or [D, D]", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "S", "+", "tf", ".", "eye", "(", "S", ".", "shape", "[", "-", "1", "]", ",", "dtype", "=", "S", ".", "dtype", ")", ")", "\n", "", "else", ":", "\n", "      ", "K", "=", "tf", ".", "matmul", "(", "feat", ",", "feat", ",", "transpose_b", "=", "True", ")", "# [L, M, M] or [M, M]", "\n", "K", "=", "tf", ".", "linalg", ".", "set_diag", "(", "K", ",", "tf", ".", "linalg", ".", "diag_part", "(", "K", ")", "+", "diag", "[", "...", ",", "0", "]", ")", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "", "", "else", ":", "\n", "    ", "assert", "L", ".", "shape", "[", "-", "1", "]", "==", "min", "(", "M", ",", "D", ")", "# TODO: improve me", "\n", "\n", "# Solve for $Cov(u, u)^{-1}(u - f(Z))$", "\n", "", "if", "D", "<", "M", ":", "\n", "    ", "feat_iDiag", "=", "feat", "*", "tf", ".", "math", ".", "reciprocal", "(", "diag", ")", "\n", "weights", "=", "tf", ".", "linalg", ".", "adjoint", "(", "tf", ".", "linalg", ".", "cholesky_solve", "(", "L", ",", "\n", "tf", ".", "matmul", "(", "feat_iDiag", ",", "err", ",", "transpose_a", "=", "True", ")", ")", ")", "\n", "", "else", ":", "\n", "    ", "iK_err", "=", "tf", ".", "linalg", ".", "cholesky_solve", "(", "L", ",", "err", ")", "# [L, S, M]", "\n", "weights", "=", "tf", ".", "matmul", "(", "iK_err", ",", "feat", ",", "transpose_a", "=", "True", ")", "# [L, S, D]", "\n", "\n", "", "return", "MultioutputDenseSampler", "(", "basis", "=", "basis", ",", "\n", "weights", "=", "swap_axes", "(", "weights", ",", "-", "3", ",", "-", "2", ")", ",", "# [S, L, D]", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.cg_updates._cg_fallback": [[29, 91], ["cg.register", "tuple", "tuple", "isinstance", "tensorflow.linalg.set_diag", "tensorflow.linalg.LinearOperatorFullMatrix", "tensorflow.linalg.adjoint", "tensorflow.linalg.experimental.conjugate_gradient", "tensorflow.math.count_nonzero", "gpflow_sampling.sampling.core.DenseSampler", "gpflow_sampling.bases.kernel", "gpflow.config.default_jitter", "gpflow_sampling.covariances.Kuu", "kern", "gpflow_sampling.utils.get_default_preconditioner", "tensorflow.random.normal", "gpflow_sampling.utils.get_default_preconditioner.matvec", "tensorflow.math.is_nan", "warnings.warn", "tensorflow.linalg.diag_part", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.get_default_preconditioner"], ["@", "cg", ".", "register", "(", "kernels", ".", "Kernel", ",", "TensorLike", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_cg_fallback", "(", "kern", ":", "kernels", ".", "Kernel", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "f", ":", "TensorLike", ",", "\n", "*", ",", "\n", "diag", ":", "TensorLike", "=", "None", ",", "\n", "basis", ":", "AbstractBasis", "=", "None", ",", "\n", "preconditioner", ":", "tf", ".", "linalg", ".", "LinearOperator", "=", "\"default\"", ",", "\n", "tol", ":", "float", "=", "1e-3", ",", "\n", "max_iter", ":", "int", "=", "100", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Return pathwise updates of a prior processes $f$ subject to the\n  condition $p(f | u) = N(f | u, diag)$ on $f = f(Z)$.\n  \"\"\"", "\n", "u_shape", "=", "tuple", "(", "u", ".", "shape", ")", "\n", "f_shape", "=", "tuple", "(", "f", ".", "shape", ")", "\n", "assert", "u_shape", "[", "-", "1", "]", "==", "1", ",", "\"Recieved multiple output features\"", "\n", "assert", "u_shape", "==", "f_shape", "[", "-", "len", "(", "u_shape", ")", ":", "]", ",", "\"Incompatible shapes detected\"", "\n", "if", "basis", "is", "None", ":", "# finite-dimensional basis used to express the update", "\n", "    ", "basis", "=", "kernel_basis", "(", "kern", ",", "centers", "=", "Z", ")", "\n", "\n", "", "if", "diag", "is", "None", ":", "\n", "    ", "diag", "=", "default_jitter", "(", ")", "\n", "\n", "# Prepare linear system for CG solver", "\n", "", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "InducingVariables", ")", ":", "\n", "    ", "Kff", "=", "covariances", ".", "Kuu", "(", "Z", ",", "kern", ",", "jitter", "=", "0.0", ")", "\n", "", "else", ":", "\n", "    ", "Kff", "=", "kern", "(", "Z", ",", "full_cov", "=", "True", ")", "\n", "", "Kuu", "=", "tf", ".", "linalg", ".", "set_diag", "(", "Kff", ",", "tf", ".", "linalg", ".", "diag_part", "(", "Kff", ")", "+", "diag", ")", "\n", "operator", "=", "tf", ".", "linalg", ".", "LinearOperatorFullMatrix", "(", "Kuu", ",", "\n", "is_non_singular", "=", "True", ",", "\n", "is_self_adjoint", "=", "True", ",", "\n", "is_positive_definite", "=", "True", ",", "\n", "is_square", "=", "True", ")", "\n", "\n", "if", "preconditioner", "==", "\"default\"", ":", "\n", "    ", "preconditioner", "=", "get_default_preconditioner", "(", "Kff", ",", "diag", "=", "diag", ")", "\n", "\n", "# Compute error term and CG initializer", "\n", "", "err", "=", "tf", ".", "linalg", ".", "adjoint", "(", "u", "-", "f", ")", "# [S, 1, M]", "\n", "err", "-=", "(", "diag", "**", "0.5", ")", "*", "tf", ".", "random", ".", "normal", "(", "err", ".", "shape", ",", "dtype", "=", "err", ".", "dtype", ")", "\n", "if", "preconditioner", "is", "None", ":", "\n", "    ", "initializer", "=", "None", "\n", "", "else", ":", "\n", "    ", "initializer", "=", "preconditioner", ".", "matvec", "(", "err", ")", "\n", "\n", "# Approximately solve for $Cov(u, u)^{-1}(u - f(Z))$ using linear CG", "\n", "", "res", "=", "tf", ".", "linalg", ".", "experimental", ".", "conjugate_gradient", "(", "operator", "=", "operator", ",", "\n", "rhs", "=", "err", ",", "\n", "preconditioner", "=", "preconditioner", ",", "\n", "x", "=", "initializer", ",", "\n", "tol", "=", "tol", ",", "\n", "max_iter", "=", "max_iter", ")", "\n", "\n", "weights", "=", "res", ".", "x", "\n", "if", "tf", ".", "math", ".", "count_nonzero", "(", "tf", ".", "math", ".", "is_nan", "(", "weights", ")", ")", ":", "\n", "    ", "warn", "(", "\"One or more update weights returned by CG are NaN\"", ")", "\n", "\n", "", "return", "DenseSampler", "(", "basis", "=", "basis", ",", "weights", "=", "weights", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.cg_updates._cg_independent": [[93, 163], ["cg.register", "tuple", "tuple", "isinstance", "tensorflow.linalg.set_diag", "tensorflow.linalg.LinearOperatorFullMatrix", "tensorflow.linalg.adjoint", "tensorflow.linalg.experimental.conjugate_gradient", "tensorflow.math.count_nonzero", "gpflow_sampling.sampling.core.MultioutputDenseSampler", "gpflow_sampling.bases.kernel", "gpflow.config.default_jitter", "gpflow_sampling.covariances.Kuu", "kern", "gpflow_sampling.utils.get_default_preconditioner", "tensorflow.random.normal", "gpflow_sampling.utils.get_default_preconditioner.matvec", "tensorflow.math.is_nan", "warnings.warn", "tensorflow.linalg.diag_part", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.get_default_preconditioner"], ["", "@", "cg", ".", "register", "(", "(", "kernels", ".", "SharedIndependent", ",", "\n", "kernels", ".", "SeparateIndependent", ",", "\n", "kernels", ".", "LinearCoregionalization", ")", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ")", "\n", "def", "_cg_independent", "(", "kern", ":", "kernels", ".", "MultioutputKernel", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "f", ":", "TensorLike", ",", "\n", "*", ",", "\n", "diag", ":", "TensorLike", "=", "None", ",", "\n", "basis", ":", "AbstractBasis", "=", "None", ",", "\n", "preconditioner", ":", "tf", ".", "linalg", ".", "LinearOperator", "=", "\"default\"", ",", "\n", "tol", ":", "float", "=", "1e-3", ",", "\n", "max_iter", ":", "int", "=", "100", ",", "\n", "multioutput_axis", ":", "int", "=", "0", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Return (independent) pathwise updates for each of the latent prior processes\n  $f$ subject to the condition $p(f | u) = N(f | u, diag)$ on $f = f(Z)$.\n  \"\"\"", "\n", "u_shape", "=", "tuple", "(", "u", ".", "shape", ")", "\n", "f_shape", "=", "tuple", "(", "f", ".", "shape", ")", "\n", "assert", "u_shape", "[", "-", "1", "]", "==", "kern", ".", "num_latent_gps", ",", "\"Num. outputs != num. latent GPs\"", "\n", "assert", "u_shape", "==", "f_shape", "[", "-", "len", "(", "u_shape", ")", ":", "]", ",", "\"Incompatible shapes detected\"", "\n", "if", "basis", "is", "None", ":", "# finite-dimensional basis used to express the update", "\n", "    ", "basis", "=", "kernel_basis", "(", "kern", ",", "centers", "=", "Z", ")", "\n", "\n", "", "if", "diag", "is", "None", ":", "\n", "    ", "diag", "=", "default_jitter", "(", ")", "\n", "\n", "# Prepare linear system for CG solver", "\n", "", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "InducingVariables", ")", ":", "\n", "    ", "Kff", "=", "covariances", ".", "Kuu", "(", "Z", ",", "kern", ",", "jitter", "=", "0.0", ")", "\n", "", "else", ":", "\n", "    ", "Kff", "=", "kern", "(", "Z", ",", "full_cov", "=", "True", ",", "full_output_cov", "=", "False", ")", "\n", "", "Kuu", "=", "tf", ".", "linalg", ".", "set_diag", "(", "Kff", ",", "tf", ".", "linalg", ".", "diag_part", "(", "Kff", ")", "+", "diag", ")", "\n", "operator", "=", "tf", ".", "linalg", ".", "LinearOperatorFullMatrix", "(", "Kuu", ",", "\n", "is_non_singular", "=", "True", ",", "\n", "is_self_adjoint", "=", "True", ",", "\n", "is_positive_definite", "=", "True", ",", "\n", "is_square", "=", "True", ")", "\n", "\n", "if", "preconditioner", "==", "\"default\"", ":", "\n", "    ", "preconditioner", "=", "get_default_preconditioner", "(", "Kff", ",", "diag", "=", "diag", ")", "\n", "\n", "", "err", "=", "tf", ".", "linalg", ".", "adjoint", "(", "u", "-", "f", ")", "# [S, L, M]", "\n", "err", "-=", "(", "diag", "**", "0.5", ")", "*", "tf", ".", "random", ".", "normal", "(", "err", ".", "shape", ",", "dtype", "=", "err", ".", "dtype", ")", "\n", "if", "preconditioner", "is", "None", ":", "\n", "    ", "initializer", "=", "None", "\n", "", "else", ":", "\n", "    ", "initializer", "=", "preconditioner", ".", "matvec", "(", "err", ")", "\n", "\n", "# Approximately solve for $Cov(u, u)^{-1}(u - f(Z))$ using linear CG", "\n", "", "res", "=", "tf", ".", "linalg", ".", "experimental", ".", "conjugate_gradient", "(", "operator", "=", "operator", ",", "\n", "rhs", "=", "err", ",", "\n", "preconditioner", "=", "preconditioner", ",", "\n", "x", "=", "initializer", ",", "\n", "tol", "=", "tol", ",", "\n", "max_iter", "=", "max_iter", ")", "\n", "\n", "weights", "=", "res", ".", "x", "\n", "if", "tf", ".", "math", ".", "count_nonzero", "(", "tf", ".", "math", ".", "is_nan", "(", "weights", ")", ")", ":", "\n", "    ", "warn", "(", "\"One or more update weights returned by CG are NaN\"", ")", "\n", "\n", "", "return", "MultioutputDenseSampler", "(", "basis", "=", "basis", ",", "\n", "weights", "=", "weights", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.cg_updates._cg_shared": [[165, 179], ["cg.register", "cg_updates._cg_independent"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.cg_updates._cg_independent"], ["", "@", "cg", ".", "register", "(", "kernels", ".", "SharedIndependent", ",", "\n", "inducing_variables", ".", "SharedIndependentInducingVariables", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ")", "\n", "def", "_cg_shared", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "*", ",", "multioutput_axis", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Edge-case where the multioutput axis gets suppressed.\n  \"\"\"", "\n", "return", "_cg_independent", "(", "kern", ",", "\n", "Z", ",", "\n", "u", ",", "\n", "f", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.cg_updates._cg_conv2d": [[181, 192], ["cg.register", "cg_updates._cg_independent", "gpflow_sampling.bases.kernel"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.cg_updates._cg_independent"], ["", "@", "cg", ".", "register", "(", "kernels_ext", ".", "Conv2d", ",", "InducingImages", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_cg_conv2d", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "*", ",", "basis", "=", "None", ",", "multioutput_axis", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "  ", "if", "basis", "is", "None", ":", "# finite-dimensional basis used to express the update", "\n", "    ", "basis", "=", "kernel_basis", "(", "kern", ",", "centers", "=", "Z", ",", "full_spatial", "=", "True", ")", "\n", "", "return", "_cg_independent", "(", "kern", ",", "\n", "Z", ",", "\n", "u", ",", "\n", "f", ",", "\n", "basis", "=", "basis", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.exact_updates._exact_fallback": [[28, 70], ["exact.register", "tuple", "tuple", "isinstance", "tensorflow.expand_dims", "tensorflow.linalg.adjoint", "gpflow_sampling.sampling.core.DenseSampler", "gpflow_sampling.bases.kernel", "gpflow.config.default_jitter", "tensorflow.convert_to_tensor", "tensorflow.sqrt", "tensorflow.random.normal", "isinstance", "tensorflow.linalg.set_diag", "tensorflow.linalg.cholesky", "tensorflow.linalg.cholesky_solve", "gpflow_sampling.covariances.Kuu", "kern", "tensorflow.linalg.diag_part", "len"], "function", ["None"], ["@", "exact", ".", "register", "(", "kernels", ".", "Kernel", ",", "TensorLike", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_exact_fallback", "(", "kern", ":", "kernels", ".", "Kernel", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "f", ":", "TensorLike", ",", "\n", "*", ",", "\n", "L", ":", "TensorLike", "=", "None", ",", "\n", "diag", ":", "TensorLike", "=", "None", ",", "\n", "basis", ":", "AbstractBasis", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Return pathwise updates of a prior processes $f$ subject to the\n  condition $p(f | u) = N(f | u, diag)$ on $f = f(Z)$.\n  \"\"\"", "\n", "u_shape", "=", "tuple", "(", "u", ".", "shape", ")", "\n", "f_shape", "=", "tuple", "(", "f", ".", "shape", ")", "\n", "assert", "u_shape", "[", "-", "1", "]", "==", "1", ",", "\"Recieved multiple output features\"", "\n", "assert", "u_shape", "==", "f_shape", "[", "-", "len", "(", "u_shape", ")", ":", "]", ",", "\"Incompatible shapes detected\"", "\n", "if", "basis", "is", "None", ":", "# finite-dimensional basis used to express the update", "\n", "    ", "basis", "=", "kernel_basis", "(", "kern", ",", "centers", "=", "Z", ")", "\n", "\n", "# Prepare diagonal term", "\n", "", "if", "diag", "is", "None", ":", "\n", "    ", "diag", "=", "default_jitter", "(", ")", "\n", "", "if", "isinstance", "(", "diag", ",", "float", ")", ":", "\n", "    ", "diag", "=", "tf", ".", "convert_to_tensor", "(", "diag", ",", "dtype", "=", "f", ".", "dtype", ")", "\n", "", "diag", "=", "tf", ".", "expand_dims", "(", "diag", ",", "axis", "=", "-", "1", ")", "# [M, 1] or [1, 1] or [1]", "\n", "\n", "# Compute error term and matrix square root $Cov(u, u)^{1/2}$", "\n", "err", "=", "u", "-", "f", "# [S, M, 1]", "\n", "err", "-=", "tf", ".", "sqrt", "(", "diag", ")", "*", "tf", ".", "random", ".", "normal", "(", "err", ".", "shape", ",", "dtype", "=", "err", ".", "dtype", ")", "\n", "if", "L", "is", "None", ":", "\n", "    ", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "InducingVariables", ")", ":", "\n", "      ", "K", "=", "covariances", ".", "Kuu", "(", "Z", ",", "kern", ",", "jitter", "=", "0.0", ")", "\n", "", "else", ":", "\n", "      ", "K", "=", "kern", "(", "Z", ",", "full_cov", "=", "True", ")", "\n", "", "K", "=", "tf", ".", "linalg", ".", "set_diag", "(", "K", ",", "tf", ".", "linalg", ".", "diag_part", "(", "K", ")", "+", "diag", "[", "...", ",", "0", "]", ")", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "\n", "# Solve for $Cov(u, u)^{-1}(u - f(Z))$", "\n", "", "weights", "=", "tf", ".", "linalg", ".", "adjoint", "(", "tf", ".", "linalg", ".", "cholesky_solve", "(", "L", ",", "err", ")", ")", "\n", "return", "DenseSampler", "(", "basis", "=", "basis", ",", "weights", "=", "weights", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.exact_updates._exact_independent": [[72, 123], ["exact.register", "tuple", "tuple", "isinstance", "tensorflow.expand_dims", "gpflow_sampling.utils.swap_axes", "gpflow_sampling.utils.move_axis", "gpflow_sampling.sampling.core.MultioutputDenseSampler", "gpflow_sampling.bases.kernel", "gpflow.config.default_jitter", "tensorflow.convert_to_tensor", "tensorflow.sqrt", "tensorflow.random.normal", "isinstance", "tensorflow.linalg.set_diag", "tensorflow.linalg.cholesky", "tensorflow.linalg.cholesky_solve", "gpflow_sampling.covariances.Kuu", "kern", "tensorflow.linalg.diag_part", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.swap_axes", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "@", "exact", ".", "register", "(", "(", "kernels", ".", "SharedIndependent", ",", "\n", "kernels", ".", "SeparateIndependent", ",", "\n", "kernels", ".", "LinearCoregionalization", ")", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ")", "\n", "def", "_exact_independent", "(", "kern", ":", "kernels", ".", "MultioutputKernel", ",", "\n", "Z", ":", "TensorLike", ",", "\n", "u", ":", "TensorLike", ",", "\n", "f", ":", "TensorLike", ",", "\n", "*", ",", "\n", "L", ":", "TensorLike", "=", "None", ",", "\n", "diag", ":", "TensorLike", "=", "None", ",", "\n", "basis", ":", "AbstractBasis", "=", "None", ",", "\n", "multioutput_axis", ":", "int", "=", "0", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Return (independent) pathwise updates for each of the latent prior processes\n  $f$ subject to the condition $p(f | u) = N(f | u, diag)$ on $f = f(Z)$.\n  \"\"\"", "\n", "u_shape", "=", "tuple", "(", "u", ".", "shape", ")", "\n", "f_shape", "=", "tuple", "(", "f", ".", "shape", ")", "\n", "assert", "u_shape", "[", "-", "1", "]", "==", "kern", ".", "num_latent_gps", ",", "\"Num. outputs != num. latent GPs\"", "\n", "assert", "u_shape", "==", "f_shape", "[", "-", "len", "(", "u_shape", ")", ":", "]", ",", "\"Incompatible shapes detected\"", "\n", "if", "basis", "is", "None", ":", "# finite-dimensional basis used to express the update", "\n", "    ", "basis", "=", "kernel_basis", "(", "kern", ",", "centers", "=", "Z", ")", "\n", "\n", "# Prepare diagonal term", "\n", "", "if", "diag", "is", "None", ":", "# used by <GPflow.conditionals>", "\n", "    ", "diag", "=", "default_jitter", "(", ")", "\n", "", "if", "isinstance", "(", "diag", ",", "float", ")", ":", "\n", "    ", "diag", "=", "tf", ".", "convert_to_tensor", "(", "diag", ",", "dtype", "=", "f", ".", "dtype", ")", "\n", "", "diag", "=", "tf", ".", "expand_dims", "(", "diag", ",", "axis", "=", "-", "1", ")", "# ([L] or []) + ([M] or []) + [1]", "\n", "\n", "# Compute error term and matrix square root $Cov(u, u)^{1/2}$", "\n", "err", "=", "swap_axes", "(", "u", "-", "f", ",", "-", "3", ",", "-", "1", ")", "# [L, M, S]", "\n", "err", "-=", "tf", ".", "sqrt", "(", "diag", ")", "*", "tf", ".", "random", ".", "normal", "(", "err", ".", "shape", ",", "dtype", "=", "err", ".", "dtype", ")", "\n", "if", "L", "is", "None", ":", "\n", "    ", "if", "isinstance", "(", "Z", ",", "inducing_variables", ".", "InducingVariables", ")", ":", "\n", "      ", "K", "=", "covariances", ".", "Kuu", "(", "Z", ",", "kern", ",", "jitter", "=", "0.0", ")", "\n", "", "else", ":", "\n", "      ", "K", "=", "kern", "(", "Z", ",", "full_cov", "=", "True", ",", "full_output_cov", "=", "False", ")", "\n", "", "K", "=", "tf", ".", "linalg", ".", "set_diag", "(", "K", ",", "tf", ".", "linalg", ".", "diag_part", "(", "K", ")", "+", "diag", "[", "...", ",", "0", "]", ")", "\n", "L", "=", "tf", ".", "linalg", ".", "cholesky", "(", "K", ")", "\n", "\n", "# Solve for $Cov(u, u)^{-1}(u - f(Z))$", "\n", "", "weights", "=", "move_axis", "(", "tf", ".", "linalg", ".", "cholesky_solve", "(", "L", ",", "err", ")", ",", "-", "1", ",", "-", "3", ")", "# [S, L, M]", "\n", "return", "MultioutputDenseSampler", "(", "basis", "=", "basis", ",", "\n", "weights", "=", "weights", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.exact_updates._exact_shared": [[125, 139], ["exact.register", "exact_updates._exact_independent"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.exact_updates._exact_independent"], ["", "@", "exact", ".", "register", "(", "kernels", ".", "SharedIndependent", ",", "\n", "inducing_variables", ".", "SharedIndependentInducingVariables", ",", "\n", "TensorLike", ",", "\n", "TensorLike", ")", "\n", "def", "_exact_shared", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "*", ",", "multioutput_axis", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "  ", "\"\"\"\n  Edge-case where the multioutput axis gets suppressed.\n  \"\"\"", "\n", "return", "_exact_independent", "(", "kern", ",", "\n", "Z", ",", "\n", "u", ",", "\n", "f", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.exact_updates._exact_conv2d": [[141, 152], ["exact.register", "exact_updates._exact_independent", "gpflow_sampling.bases.kernel"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.updates.exact_updates._exact_independent"], ["", "@", "exact", ".", "register", "(", "kernels_ext", ".", "Conv2d", ",", "InducingImages", ",", "TensorLike", ",", "TensorLike", ")", "\n", "def", "_exact_conv2d", "(", "kern", ",", "Z", ",", "u", ",", "f", ",", "*", ",", "basis", "=", "None", ",", "multioutput_axis", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "  ", "if", "basis", "is", "None", ":", "# finite-dimensional basis used to express the update", "\n", "    ", "basis", "=", "kernel_basis", "(", "kern", ",", "centers", "=", "Z", ",", "full_spatial", "=", "True", ")", "\n", "", "return", "_exact_independent", "(", "kern", ",", "\n", "Z", ",", "\n", "u", ",", "\n", "f", ",", "\n", "basis", "=", "basis", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.priors.fourier_priors._random_fourier": [[27, 44], ["random_fourier.register", "tensorflow.random.normal", "gpflow_sampling.sampling.core.DenseSampler", "gpflow.config.default_float", "gpflow_sampling.bases.fourier", "list"], "function", ["None"], ["@", "random_fourier", ".", "register", "(", "Kernel", ")", "\n", "def", "_random_fourier", "(", "kernel", ":", "Kernel", ",", "\n", "sample_shape", ":", "List", ",", "\n", "num_bases", ":", "int", ",", "\n", "basis", ":", "Callable", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "if", "basis", "is", "None", ":", "\n", "    ", "basis", "=", "fourier_basis", "(", "kernel", ",", "num_bases", "=", "num_bases", ")", "\n", "\n", "", "weights", "=", "tf", ".", "random", ".", "normal", "(", "list", "(", "sample_shape", ")", "+", "[", "1", ",", "num_bases", "]", ",", "dtype", "=", "dtype", ")", "\n", "return", "DenseSampler", "(", "weights", "=", "weights", ",", "basis", "=", "basis", ",", "name", "=", "name", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.priors.fourier_priors._random_fourier_multioutput": [[46, 68], ["random_fourier.register", "tensorflow.random.normal", "gpflow_sampling.sampling.core.MultioutputDenseSampler", "gpflow.config.default_float", "gpflow_sampling.bases.fourier", "list"], "function", ["None"], ["", "@", "random_fourier", ".", "register", "(", "MultioutputKernel", ")", "\n", "def", "_random_fourier_multioutput", "(", "kernel", ":", "MultioutputKernel", ",", "\n", "sample_shape", ":", "List", ",", "\n", "num_bases", ":", "int", ",", "\n", "basis", ":", "Callable", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ",", "\n", "multioutput_axis", ":", "int", "=", "0", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "if", "basis", "is", "None", ":", "\n", "    ", "basis", "=", "fourier_basis", "(", "kernel", ",", "num_bases", "=", "num_bases", ")", "\n", "\n", "", "shape", "=", "list", "(", "sample_shape", ")", "+", "[", "kernel", ".", "num_latent_gps", ",", "num_bases", "]", "\n", "weights", "=", "tf", ".", "random", ".", "normal", "(", "shape", ",", "dtype", "=", "dtype", ")", "\n", "return", "MultioutputDenseSampler", "(", "name", "=", "name", ",", "\n", "basis", "=", "basis", ",", "\n", "weights", "=", "weights", ",", "\n", "multioutput_axis", "=", "multioutput_axis", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.priors.fourier_priors._random_fourier_conv": [[70, 91], ["random_fourier.register", "tensorflow.random.normal", "gpflow_sampling.sampling.core.MultioutputDenseSampler", "gpflow.config.default_float", "gpflow_sampling.bases.fourier", "list"], "function", ["None"], ["", "@", "random_fourier", ".", "register", "(", "Conv2d", ")", "\n", "def", "_random_fourier_conv", "(", "kernel", ":", "Conv2d", ",", "\n", "sample_shape", ":", "List", ",", "\n", "num_bases", ":", "int", ",", "\n", "basis", ":", "Callable", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "if", "basis", "is", "None", ":", "\n", "    ", "basis", "=", "fourier_basis", "(", "kernel", ",", "num_bases", "=", "num_bases", ")", "\n", "\n", "", "shape", "=", "list", "(", "sample_shape", ")", "+", "[", "kernel", ".", "num_latent_gps", ",", "num_bases", "]", "\n", "weights", "=", "tf", ".", "random", ".", "normal", "(", "shape", ",", "dtype", "=", "dtype", ")", "\n", "return", "MultioutputDenseSampler", "(", "weights", "=", "weights", ",", "\n", "basis", "=", "basis", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.priors.fourier_priors._random_fourier_depthwise_conv": [[93, 115], ["random_fourier.register", "tensorflow.random.normal", "gpflow_sampling.sampling.core.MultioutputDenseSampler", "gpflow.config.default_float", "gpflow_sampling.bases.fourier", "list"], "function", ["None"], ["", "@", "random_fourier", ".", "register", "(", "DepthwiseConv2d", ")", "\n", "def", "_random_fourier_depthwise_conv", "(", "kernel", ":", "DepthwiseConv2d", ",", "\n", "sample_shape", ":", "List", ",", "\n", "num_bases", ":", "int", ",", "\n", "basis", ":", "Callable", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "if", "basis", "is", "None", ":", "\n", "    ", "basis", "=", "fourier_basis", "(", "kernel", ",", "num_bases", "=", "num_bases", ")", "\n", "\n", "", "channels_out", "=", "num_bases", "*", "kernel", ".", "channels_in", "\n", "shape", "=", "list", "(", "sample_shape", ")", "+", "[", "kernel", ".", "num_latent_gps", ",", "channels_out", "]", "\n", "weights", "=", "tf", ".", "random", ".", "normal", "(", "shape", ",", "dtype", "=", "dtype", ")", "\n", "return", "MultioutputDenseSampler", "(", "weights", "=", "weights", ",", "\n", "basis", "=", "basis", ",", "\n", "name", "=", "name", ",", "\n", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis.__init__": [[25, 28], ["tensorflow.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["\n", "\n", "# ==============================================", "\n", "#                                           core", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis.__call__": [[29, 32], ["None"], "methods", ["None"], ["# ==============================================", "\n", "class", "AbstractSampler", "(", "tf", ".", "Module", ")", ":", "\n", "  ", "@", "abstractmethod", "\n", "def", "__call__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis.initialize": [[33, 36], ["None"], "methods", ["None"], ["    ", "raise", "NotImplementedError", "\n", "\n", "", "@", "property", "\n", "def", "sample_shape", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis._maybe_initialize": [[37, 41], ["core.AbstractBasis.initialize"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize"], ["    ", "raise", "NotImplementedError", "\n", "\n", "\n", "", "", "class", "CompositeSampler", "(", "AbstractSampler", ")", ":", "\n", "  ", "def", "__init__", "(", "self", ",", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis.num_bases": [[42, 46], ["None"], "methods", ["None"], ["join_rule", ":", "Callable", ",", "\n", "samplers", ":", "List", "[", "Callable", "]", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ")", ":", "\n", "    "]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.KernelBasis.__init__": [[49, 59], ["core.AbstractBasis.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["super", "(", ")", ".", "__init__", "(", "name", "=", "name", ")", "\n", "self", ".", "_join_rule", "=", "join_rule", "\n", "self", ".", "_samplers", "=", "samplers", "\n", "self", ".", "mean_function", "=", "mean_function", "\n", "\n", "", "def", "__call__", "(", "self", ",", "x", ":", "tf", ".", "Tensor", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "samples", "=", "[", "sampler", "(", "x", ",", "**", "kwargs", ")", "for", "sampler", "in", "self", ".", "samplers", "]", "\n", "vals", "=", "self", ".", "join_rule", "(", "samples", ")", "\n", "return", "vals", "if", "self", ".", "mean_function", "is", "None", "else", "vals", "+", "self", ".", "mean_function", "(", "x", ")", "\n", "\n", "", "@", "property", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.KernelBasis.__call__": [[60, 72], ["core.KernelBasis._maybe_initialize", "isinstance", "isinstance", "core.KernelBasis.kernel.K", "gpflow_sampling.covariances.Kfu", "_kwargs.setdefault"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis._maybe_initialize", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gpfs.kernels.DepthwiseConv2d.K"], ["def", "join_rule", "(", "self", ")", "->", "Callable", ":", "\n", "    ", "return", "self", ".", "_join_rule", "\n", "\n", "", "@", "property", "\n", "def", "samplers", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_samplers", "\n", "\n", "", "@", "property", "\n", "def", "sample_shape", "(", "self", ")", ":", "\n", "    ", "for", "i", ",", "sampler", "in", "enumerate", "(", "self", ".", "samplers", ")", ":", "\n", "      ", "if", "i", "==", "0", ":", "\n", "        ", "sample_shape", "=", "sampler", ".", "sample_shape", "\n", "", "else", ":", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.KernelBasis.num_bases": [[73, 81], ["isinstance", "gpflow_sampling.utils.get_inducing_shape"], "methods", ["None"], ["        ", "assert", "sample_shape", "==", "sampler", ".", "sample_shape", "\n", "", "", "return", "sample_shape", "\n", "\n", "\n", "", "", "class", "DenseSampler", "(", "AbstractSampler", ")", ":", "\n", "  ", "def", "__init__", "(", "self", ",", "\n", "weights", ":", "Union", "[", "tf", ".", "Tensor", ",", "tf", ".", "Variable", "]", ",", "\n", "basis", ":", "Callable", "=", "None", ",", "\n", "mean_function", ":", "Callable", "=", "None", ",", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.AbstractFourierBasis.__init__": [[38, 46], ["gpflow_sampling.bases.core.AbstractBasis.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "kernel", ":", "gpflow_kernels", ".", "Kernel", ",", "\n", "num_bases", ":", "int", ",", "\n", "initialized", ":", "bool", "=", "False", ",", "\n", "name", ":", "Any", "=", "None", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "initialized", "=", "initialized", ",", "name", "=", "name", ")", "\n", "self", ".", "kernel", "=", "kernel", "\n", "self", ".", "_num_bases", "=", "num_bases", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.AbstractFourierBasis.num_bases": [[47, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_bases", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_num_bases", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Dense.__init__": [[53, 64], ["fourier_bases.AbstractFourierBasis.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "kernel", ":", "gpflow_kernels", ".", "Stationary", ",", "\n", "num_bases", ":", "int", ",", "\n", "weights", ":", "tf", ".", "Tensor", "=", "None", ",", "\n", "biases", ":", "tf", ".", "Tensor", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ")", ":", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "\n", "kernel", "=", "kernel", ",", "\n", "num_bases", "=", "num_bases", ")", "\n", "self", ".", "_weights", "=", "weights", "\n", "self", ".", "_biases", "=", "biases", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Dense.__call__": [[65, 73], ["fourier_bases.Dense._maybe_initialize", "isinstance", "tensorflow.tensordot", "tensorflow.cos", "gpflow_sampling.utils.inducing_to_tensor"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis._maybe_initialize"], ["", "def", "__call__", "(", "self", ",", "x", ":", "TensorType", ",", "**", "kwargs", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "self", ".", "_maybe_initialize", "(", "x", ",", "**", "kwargs", ")", "\n", "if", "isinstance", "(", "x", ",", "InducingVariables", ")", ":", "# TODO: Allow this behavior?", "\n", "      ", "x", "=", "inducing_to_tensor", "(", "x", ")", "\n", "\n", "", "proj", "=", "tf", ".", "tensordot", "(", "x", ",", "self", ".", "weights", ",", "axes", "=", "[", "-", "1", ",", "-", "1", "]", ")", "# [..., B]", "\n", "feat", "=", "tf", ".", "cos", "(", "proj", "+", "self", ".", "biases", ")", "\n", "return", "self", ".", "output_scale", "*", "feat", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Dense.initialize": [[74, 85], ["isinstance", "gpflow_sampling.bases.fourier_initializers.bias_initializer", "gpflow_sampling.bases.fourier_initializers.weight_initializer", "gpflow_sampling.utils.inducing_to_tensor"], "methods", ["None"], ["", "def", "initialize", "(", "self", ",", "x", ":", "TensorType", ",", "dtype", ":", "Any", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "InducingVariables", ")", ":", "\n", "      ", "x", "=", "inducing_to_tensor", "(", "x", ")", "\n", "\n", "", "if", "dtype", "is", "None", ":", "\n", "      ", "dtype", "=", "x", ".", "dtype", "\n", "\n", "", "self", ".", "_biases", "=", "bias_initializer", "(", "self", ".", "kernel", ",", "self", ".", "num_bases", ",", "dtype", "=", "dtype", ")", "\n", "self", ".", "_weights", "=", "weight_initializer", "(", "self", ".", "kernel", ",", "x", ".", "shape", "[", "-", "1", "]", ",", "\n", "batch_shape", "=", "[", "self", ".", "num_bases", "]", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Dense.weights": [[86, 91], ["tensorflow.math.reciprocal"], "methods", ["None"], ["", "@", "property", "\n", "def", "weights", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "_weights", "is", "None", ":", "\n", "      ", "return", "None", "\n", "", "return", "tf", ".", "math", ".", "reciprocal", "(", "self", ".", "kernel", ".", "lengthscales", ")", "*", "self", ".", "_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Dense.biases": [[92, 95], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "biases", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_biases", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Dense.output_scale": [[96, 99], ["tensorflow.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_scale", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "sqrt", "(", "2", "*", "self", ".", "kernel", ".", "variance", "/", "self", ".", "num_bases", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.MultioutputDense.__call__": [[102, 117], ["fourier_bases.MultioutputDense._maybe_initialize", "isinstance", "gpflow_sampling.utils.move_axis", "tensorflow.cos", "gpflow_sampling.utils.inducing_to_tensor", "gpflow_sampling.utils.batch_tensordot", "gpflow_sampling.utils.expand_to", "gpflow_sampling.utils.expand_to"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis._maybe_initialize", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.linalg.batch_tensordot", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.expand_to", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.expand_to"], ["  ", "def", "__call__", "(", "self", ",", "x", ":", "TensorType", ",", "multioutput_axis", ":", "int", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "self", ".", "_maybe_initialize", "(", "x", ",", "**", "kwargs", ")", "\n", "if", "isinstance", "(", "x", ",", "InducingVariables", ")", ":", "# TODO: Allow this behavior?", "\n", "      ", "x", "=", "inducing_to_tensor", "(", "x", ")", "\n", "\n", "# Compute (batch) tensor dot product", "\n", "", "batch_axes", "=", "None", "if", "(", "multioutput_axis", "is", "None", ")", "else", "[", "0", ",", "multioutput_axis", "]", "\n", "proj", "=", "move_axis", "(", "batch_tensordot", "(", "self", ".", "weights", ",", "\n", "x", ",", "\n", "axes", "=", "[", "-", "1", ",", "-", "1", "]", ",", "\n", "batch_axes", "=", "batch_axes", ")", ",", "1", ",", "-", "1", ")", "\n", "\n", "ndims", "=", "proj", ".", "shape", ".", "ndims", "\n", "feat", "=", "tf", ".", "cos", "(", "proj", "+", "expand_to", "(", "self", ".", "biases", ",", "axis", "=", "1", ",", "ndims", "=", "ndims", ")", ")", "\n", "return", "expand_to", "(", "self", ".", "output_scale", ",", "axis", "=", "1", ",", "ndims", "=", "ndims", ")", "*", "feat", "# [L, N, B]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.MultioutputDense.initialize": [[118, 138], ["isinstance", "tensorflow.stack", "tensorflow.stack", "gpflow_sampling.utils.inducing_to_tensor", "biases.append", "weights.append", "gpflow_sampling.bases.fourier_initializers.bias_initializer", "gpflow_sampling.bases.fourier_initializers.weight_initializer"], "methods", ["None"], ["", "def", "initialize", "(", "self", ",", "x", ":", "TensorType", ",", "dtype", ":", "Any", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "InducingVariables", ")", ":", "\n", "      ", "x", "=", "inducing_to_tensor", "(", "x", ")", "\n", "\n", "", "if", "dtype", "is", "None", ":", "\n", "      ", "dtype", "=", "x", ".", "dtype", "\n", "\n", "", "biases", "=", "[", "]", "\n", "weights", "=", "[", "]", "\n", "for", "kernel", "in", "self", ".", "kernel", ".", "latent_kernels", ":", "\n", "      ", "biases", ".", "append", "(", "\n", "bias_initializer", "(", "kernel", ",", "self", ".", "num_bases", ",", "dtype", "=", "dtype", ")", ")", "\n", "\n", "weights", ".", "append", "(", "\n", "weight_initializer", "(", "kernel", ",", "x", ".", "shape", "[", "-", "1", "]", ",", "\n", "batch_shape", "=", "[", "self", ".", "num_bases", "]", ",", "\n", "dtype", "=", "dtype", ")", ")", "\n", "\n", "", "self", ".", "_biases", "=", "tf", ".", "stack", "(", "biases", ",", "axis", "=", "0", ")", "# [L, B]", "\n", "self", ".", "_weights", "=", "tf", ".", "stack", "(", "weights", ",", "axis", "=", "0", ")", "# [L, B, D]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.MultioutputDense.weights": [[139, 167], ["gpflow_sampling.utils.expand_to", "tensorflow.math.reciprocal", "gpflow_sampling.utils.expand_to.append", "tensorflow.fill", "tensorflow.stack"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.expand_to"], ["", "@", "property", "\n", "def", "weights", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "_weights", "is", "None", ":", "\n", "      ", "return", "None", "\n", "\n", "", "num_lengthscales", "=", "None", "\n", "for", "kernel", "in", "self", ".", "kernel", ".", "latent_kernels", ":", "\n", "      ", "if", "kernel", ".", "ard", ":", "\n", "        ", "ls", "=", "kernel", ".", "lengthscales", "\n", "assert", "ls", ".", "shape", ".", "ndims", "==", "1", "\n", "if", "num_lengthscales", "is", "None", ":", "\n", "          ", "num_lengthscales", "=", "ls", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "          ", "assert", "num_lengthscales", "==", "ls", ".", "shape", "[", "0", "]", "\n", "\n", "", "", "", "inv_lengthscales", "=", "[", "]", "\n", "for", "kernel", "in", "self", ".", "kernel", ".", "latent_kernels", ":", "\n", "      ", "inv_ls", "=", "tf", ".", "math", ".", "reciprocal", "(", "kernel", ".", "lengthscales", ")", "\n", "if", "not", "kernel", ".", "ard", "and", "num_lengthscales", "is", "not", "None", ":", "\n", "        ", "inv_ls", "=", "tf", ".", "fill", "(", "[", "num_lengthscales", "]", ",", "inv_ls", ")", "\n", "", "inv_lengthscales", ".", "append", "(", "inv_ls", ")", "\n", "\n", "# [L, 1, D] or [L, 1, 1]", "\n", "", "inv_lengthscales", "=", "expand_to", "(", "arr", "=", "tf", ".", "stack", "(", "inv_lengthscales", ")", ",", "\n", "axis", "=", "1", ",", "\n", "ndims", "=", "self", ".", "_weights", ".", "shape", ".", "ndims", ")", "\n", "\n", "return", "inv_lengthscales", "*", "self", ".", "_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.MultioutputDense.output_scale": [[168, 172], ["tensorflow.stack", "tensorflow.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_scale", "(", "self", ")", ":", "\n", "    ", "variances", "=", "tf", ".", "stack", "(", "[", "k", ".", "variance", "for", "k", "in", "self", ".", "kernel", ".", "latent_kernels", "]", ")", "\n", "return", "tf", ".", "sqrt", "(", "2", "*", "variances", "/", "self", ".", "num_bases", ")", "# [L]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.__init__": [[175, 187], ["fourier_bases.AbstractFourierBasis.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "\n", "kernel", ":", "kernels", ".", "Conv2d", ",", "\n", "num_bases", ":", "int", ",", "\n", "filters", ":", "tf", ".", "Tensor", "=", "None", ",", "\n", "biases", ":", "tf", ".", "Tensor", "=", "None", ",", "\n", "name", ":", "str", "=", "None", ")", ":", "\n", "\n", "    ", "super", "(", ")", ".", "__init__", "(", "name", "=", "name", ",", "\n", "kernel", "=", "kernel", ",", "\n", "num_bases", "=", "num_bases", ")", "\n", "self", ".", "_filters", "=", "filters", "\n", "self", ".", "_biases", "=", "biases", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.__call__": [[188, 199], ["fourier_bases.Conv2d._maybe_initialize", "isinstance", "fourier_bases.Conv2d.convolve", "tensorflow.cos", "len", "len", "tensorflow.reshape", "fourier_bases.Conv2d.convolve", "tensorflow.reshape", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.core.AbstractBasis._maybe_initialize", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve"], ["", "def", "__call__", "(", "self", ",", "x", ":", "TensorType", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "self", ".", "_maybe_initialize", "(", "x", ")", "\n", "if", "isinstance", "(", "x", ",", "InducingVariables", ")", "or", "len", "(", "x", ".", "shape", ")", "==", "4", ":", "\n", "      ", "conv", "=", "self", ".", "convolve", "(", "x", ")", "\n", "", "elif", "len", "(", "x", ".", "shape", ")", ">", "4", ":", "# allow for higher order batches", "\n", "      ", "x_4d", "=", "tf", ".", "reshape", "(", "x", ",", "[", "-", "1", "]", "+", "list", "(", "x", ".", "shape", "[", "-", "3", ":", "]", ")", ")", "\n", "conv", "=", "self", ".", "convolve", "(", "x_4d", ")", "\n", "conv", "=", "tf", ".", "reshape", "(", "conv", ",", "list", "(", "x", ".", "shape", "[", ":", "-", "3", "]", ")", "+", "list", "(", "conv", ".", "shape", "[", "1", ":", "]", ")", ")", "\n", "", "else", ":", "\n", "      ", "raise", "NotImplementedError", "\n", "", "return", "self", ".", "output_scale", "*", "tf", ".", "cos", "(", "conv", "+", "self", ".", "biases", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.convolve": [[200, 207], ["isinstance", "fourier_bases.Conv2d.kernel.convolve", "tensorflow.nn.conv2d"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve"], ["", "def", "convolve", "(", "self", ",", "x", ":", "TensorType", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "inducing_variables", ".", "InducingImages", ")", ":", "\n", "      ", "return", "tf", ".", "nn", ".", "conv2d", "(", "input", "=", "x", ".", "as_images", ",", "\n", "filters", "=", "self", ".", "filters", ",", "\n", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"VALID\"", ")", "\n", "", "return", "self", ".", "kernel", ".", "convolve", "(", "input", "=", "x", ",", "filters", "=", "self", ".", "filters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.initialize": [[208, 229], ["isinstance", "gpflow_sampling.bases.fourier_initializers.bias_initializer", "gpflow_sampling.bases.fourier_initializers.weight_initializer", "tensorflow.reshape", "gpflow_sampling.utils.move_axis"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "def", "initialize", "(", "self", ",", "x", ",", "dtype", ":", "Any", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "inducing_variables", ".", "InducingImages", ")", ":", "\n", "      ", "x", "=", "x", ".", "as_images", "\n", "\n", "", "if", "dtype", "is", "None", ":", "\n", "      ", "dtype", "=", "x", ".", "dtype", "\n", "\n", "", "self", ".", "_biases", "=", "bias_initializer", "(", "self", ".", "kernel", ".", "kernel", ",", "\n", "self", ".", "num_bases", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n", "patch_size", "=", "(", "self", ".", "kernel", ".", "channels_in", "\n", "*", "self", ".", "kernel", ".", "patch_shape", "[", "0", "]", "\n", "*", "self", ".", "kernel", ".", "patch_shape", "[", "1", "]", ")", "\n", "\n", "weights", "=", "weight_initializer", "(", "self", ".", "kernel", ".", "kernel", ",", "patch_size", ",", "\n", "batch_shape", "=", "[", "self", ".", "num_bases", "]", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n", "shape", "=", "self", ".", "kernel", ".", "patch_shape", "+", "[", "self", ".", "kernel", ".", "channels_in", ",", "self", ".", "num_bases", "]", "\n", "self", ".", "_filters", "=", "tf", ".", "reshape", "(", "move_axis", "(", "weights", ",", "-", "1", ",", "0", ")", ",", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.filters": [[230, 243], ["tensorflow.math.reciprocal", "list", "tensorflow.reshape", "tensorflow.fill"], "methods", ["None"], ["", "@", "property", "\n", "def", "filters", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "_filters", "is", "None", ":", "\n", "      ", "return", "None", "\n", "\n", "", "shape", "=", "list", "(", "self", ".", "kernel", ".", "patch_shape", ")", "+", "[", "self", ".", "kernel", ".", "channels_in", ",", "1", "]", "\n", "inv_ls", "=", "tf", ".", "math", ".", "reciprocal", "(", "self", ".", "kernel", ".", "kernel", ".", "lengthscales", ")", "\n", "if", "self", ".", "kernel", ".", "kernel", ".", "ard", ":", "\n", "      ", "coeffs", "=", "tf", ".", "reshape", "(", "inv_ls", ",", "shape", ")", "\n", "", "else", ":", "\n", "      ", "coeffs", "=", "tf", ".", "fill", "(", "shape", ",", "inv_ls", ")", "\n", "\n", "", "return", "coeffs", "*", "self", ".", "_filters", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.biases": [[244, 247], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "biases", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "_biases", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.Conv2d.output_scale": [[248, 251], ["tensorflow.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_scale", "(", "self", ")", ":", "\n", "    ", "return", "tf", ".", "sqrt", "(", "2", "*", "self", ".", "kernel", ".", "kernel", ".", "variance", "/", "self", ".", "num_bases", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve": [[258, 266], ["isinstance", "fourier_bases.DepthwiseConv2d.kernel.convolve", "tensorflow.nn.depthwise_conv2d"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.convolve"], ["  ", "def", "convolve", "(", "self", ",", "x", ":", "TensorType", ")", "->", "tf", ".", "Tensor", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "inducing_variables", ".", "DepthwiseInducingImages", ")", ":", "\n", "      ", "return", "tf", ".", "nn", ".", "depthwise_conv2d", "(", "input", "=", "x", ".", "as_images", ",", "\n", "filter", "=", "self", ".", "filters", ",", "\n", "strides", "=", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "\n", "padding", "=", "\"VALID\"", ")", "\n", "\n", "", "return", "self", ".", "kernel", ".", "convolve", "(", "input", "=", "x", ",", "filters", "=", "self", ".", "filters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.initialize": [[267, 287], ["isinstance", "gpflow_sampling.bases.fourier_initializers.bias_initializer", "gpflow_sampling.bases.fourier_initializers.weight_initializer", "tensorflow.reshape", "gpflow_sampling.utils.move_axis"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.utils.array_ops.move_axis"], ["", "def", "initialize", "(", "self", ",", "x", ",", "dtype", ":", "Any", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "x", ",", "inducing_variables", ".", "InducingImages", ")", ":", "\n", "      ", "x", "=", "x", ".", "as_images", "\n", "\n", "", "if", "dtype", "is", "None", ":", "\n", "      ", "dtype", "=", "x", ".", "dtype", "\n", "\n", "", "channels_out", "=", "self", ".", "kernel", ".", "channels_in", "*", "self", ".", "num_bases", "\n", "self", ".", "_biases", "=", "bias_initializer", "(", "self", ".", "kernel", ".", "kernel", ",", "\n", "channels_out", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n", "patch_size", "=", "self", ".", "kernel", ".", "patch_shape", "[", "0", "]", "*", "self", ".", "kernel", ".", "patch_shape", "[", "1", "]", "\n", "batch_shape", "=", "[", "self", ".", "kernel", ".", "channels_in", ",", "self", ".", "num_bases", "]", "\n", "weights", "=", "weight_initializer", "(", "self", ".", "kernel", ".", "kernel", ",", "patch_size", ",", "\n", "batch_shape", "=", "batch_shape", ",", "\n", "dtype", "=", "dtype", ")", "\n", "\n", "self", ".", "_filters", "=", "tf", ".", "reshape", "(", "move_axis", "(", "weights", ",", "-", "1", ",", "0", ")", ",", "\n", "self", ".", "kernel", ".", "patch_shape", "+", "batch_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.filters": [[288, 301], ["tensorflow.math.reciprocal", "list", "tensorflow.reshape", "tensorflow.fill", "tensorflow.transpose"], "methods", ["None"], ["", "@", "property", "\n", "def", "filters", "(", "self", ")", ":", "\n", "    ", "if", "self", ".", "_filters", "is", "None", ":", "\n", "      ", "return", "None", "\n", "\n", "", "shape", "=", "list", "(", "self", ".", "kernel", ".", "patch_shape", ")", "+", "[", "self", ".", "kernel", ".", "channels_in", ",", "1", "]", "\n", "inv_ls", "=", "tf", ".", "math", ".", "reciprocal", "(", "self", ".", "kernel", ".", "kernel", ".", "lengthscales", ")", "\n", "if", "self", ".", "kernel", ".", "kernel", ".", "ard", ":", "\n", "      ", "coeffs", "=", "tf", ".", "reshape", "(", "tf", ".", "transpose", "(", "inv_ls", ")", ",", "shape", ")", "\n", "", "else", ":", "\n", "      ", "coeffs", "=", "tf", ".", "fill", "(", "shape", ",", "inv_ls", ")", "\n", "\n", "", "return", "coeffs", "*", "self", ".", "_filters", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_bases.DepthwiseConv2d.output_scale": [[302, 306], ["tensorflow.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "output_scale", "(", "self", ")", ":", "\n", "    ", "num_features_out", "=", "self", ".", "num_bases", "*", "self", ".", "kernel", ".", "channels_in", "\n", "return", "tf", ".", "sqrt", "(", "2", "*", "self", ".", "kernel", ".", "kernel", ".", "variance", "/", "num_features_out", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_initializers._bias_initializer_fallback": [[28, 40], ["bias_initializer.register", "tensorflow.random.uniform", "gpflow.config.default_float", "list"], "function", ["None"], ["@", "bias_initializer", ".", "register", "(", "kernels", ".", "Stationary", ",", "int", ")", "\n", "def", "_bias_initializer_fallback", "(", "kern", ":", "kernels", ".", "Stationary", ",", "\n", "ndims", ":", "int", ",", "\n", "*", ",", "\n", "batch_shape", ":", "List", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "maxval", ":", "float", "=", "2", "*", "np", ".", "pi", ")", "->", "tf", ".", "Tensor", ":", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "shape", "=", "[", "ndims", "]", "if", "batch_shape", "is", "None", "else", "list", "(", "batch_shape", ")", "+", "[", "ndims", "]", "\n", "return", "tf", ".", "random", ".", "uniform", "(", "shape", "=", "shape", ",", "maxval", "=", "maxval", ",", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_initializers._weight_initializer_squaredExp": [[42, 61], ["weight_initializer.register", "tensorflow.convert_to_tensor", "gpflow.config.default_float", "tensorflow.random.normal", "tuple", "tuple", "list"], "function", ["None"], ["", "@", "weight_initializer", ".", "register", "(", "kernels", ".", "SquaredExponential", ",", "int", ")", "\n", "def", "_weight_initializer_squaredExp", "(", "kern", ":", "kernels", ".", "SquaredExponential", ",", "\n", "ndims", ":", "int", ",", "\n", "*", ",", "\n", "batch_shape", ":", "List", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "normal_rvs", ":", "tf", ".", "Tensor", "=", "None", ")", "->", "tf", ".", "Tensor", ":", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "if", "batch_shape", "is", "None", ":", "\n", "    ", "batch_shape", "=", "[", "]", "\n", "\n", "", "shape", "=", "[", "ndims", "]", "if", "batch_shape", "is", "None", "else", "list", "(", "batch_shape", ")", "+", "[", "ndims", "]", "\n", "if", "normal_rvs", "is", "None", ":", "\n", "    ", "return", "tf", ".", "random", ".", "normal", "(", "shape", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "assert", "tuple", "(", "normal_rvs", ".", "shape", ")", "==", "tuple", "(", "shape", ")", "\n", "return", "tf", ".", "convert_to_tensor", "(", "normal_rvs", ",", "dtype", "=", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.fourier_initializers._weight_initializer_matern": [[63, 101], ["weight_initializer.register", "isinstance", "gpflow.config.default_float", "isinstance", "list", "tensorflow.random.normal", "tensorflow.convert_to_tensor", "tensorflow.random.gamma", "tensorflow.convert_to_tensor", "tensorflow.math.rsqrt", "isinstance", "tuple", "tuple", "tuple", "tuple"], "function", ["None"], ["", "@", "weight_initializer", ".", "register", "(", "MaternKernel", ",", "int", ")", "\n", "def", "_weight_initializer_matern", "(", "kern", ":", "MaternKernel", ",", "\n", "ndims", ":", "int", ",", "\n", "*", ",", "\n", "batch_shape", ":", "List", "=", "None", ",", "\n", "dtype", ":", "Any", "=", "None", ",", "\n", "normal_rvs", ":", "tf", ".", "Tensor", "=", "None", ",", "\n", "gamma_rvs", ":", "tf", ".", "Tensor", "=", "None", ")", "->", "tf", ".", "Tensor", ":", "\n", "  ", "if", "dtype", "is", "None", ":", "\n", "    ", "dtype", "=", "default_float", "(", ")", "\n", "\n", "", "if", "isinstance", "(", "kern", ",", "kernels", ".", "Matern12", ")", ":", "\n", "    ", "smoothness", "=", "1", "/", "2", "\n", "", "elif", "isinstance", "(", "kern", ",", "kernels", ".", "Matern32", ")", ":", "\n", "    ", "smoothness", "=", "3", "/", "2", "\n", "", "elif", "isinstance", "(", "kern", ",", "kernels", ".", "Matern52", ")", ":", "\n", "    ", "smoothness", "=", "5", "/", "2", "\n", "", "else", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "\n", "", "batch_shape", "=", "[", "]", "if", "batch_shape", "is", "None", "else", "list", "(", "batch_shape", ")", "\n", "if", "normal_rvs", "is", "None", ":", "\n", "    ", "normal_rvs", "=", "tf", ".", "random", ".", "normal", "(", "shape", "=", "batch_shape", "+", "[", "ndims", "]", ",", "dtype", "=", "dtype", ")", "\n", "", "else", ":", "\n", "    ", "assert", "tuple", "(", "normal_rvs", ".", "shape", ")", "==", "tuple", "(", "batch_shape", "+", "[", "ndims", "]", ")", "\n", "normal_rvs", "=", "tf", ".", "convert_to_tensor", "(", "normal_rvs", ",", "dtype", "=", "dtype", ")", "\n", "\n", "", "if", "gamma_rvs", "is", "None", ":", "\n", "    ", "gamma_rvs", "=", "tf", ".", "random", ".", "gamma", "(", "shape", "=", "batch_shape", "+", "[", "1", "]", ",", "\n", "alpha", "=", "smoothness", ",", "\n", "beta", "=", "smoothness", ",", "\n", "dtype", "=", "dtype", ")", "\n", "", "else", ":", "\n", "    ", "assert", "tuple", "(", "gamma_rvs", ".", "shape", ")", "==", "tuple", "(", "batch_shape", "+", "[", "1", "]", ")", "\n", "gamma_rvs", "=", "tf", ".", "convert_to_tensor", "(", "gamma_rvs", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# Return draws from a multivariate-t distribution", "\n", "", "return", "tf", ".", "math", ".", "rsqrt", "(", "gamma_rvs", ")", "*", "normal_rvs", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.dispatch._kernel_fallback": [[31, 36], ["kernel_basis.register", "gpflow_sampling.bases.core.KernelBasis"], "function", ["None"], ["@", "kernel_basis", ".", "register", "(", "gpflow_kernels", ".", "Kernel", ")", "\n", "def", "_kernel_fallback", "(", "kern", ":", "gpflow_kernels", ".", "Kernel", ",", "\n", "centers", ":", "Union", "[", "TensorType", ",", "InducingVariables", "]", ",", "\n", "**", "kwargs", ")", ":", "\n", "  ", "return", "KernelBasis", "(", "kernel", "=", "kern", ",", "centers", "=", "centers", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.dispatch._fourier_stationary": [[38, 41], ["fourier_basis.register", "gpflow_sampling.bases.fourier_bases.Dense"], "function", ["None"], ["", "@", "fourier_basis", ".", "register", "(", "gpflow_kernels", ".", "Stationary", ")", "\n", "def", "_fourier_stationary", "(", "kern", ":", "gpflow_kernels", ".", "Stationary", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "fourier_bases", ".", "Dense", "(", "kernel", "=", "kern", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.dispatch._fourier_multioutput": [[43, 46], ["fourier_basis.register", "gpflow_sampling.bases.fourier_bases.MultioutputDense"], "function", ["None"], ["", "@", "fourier_basis", ".", "register", "(", "gpflow_kernels", ".", "MultioutputKernel", ")", "\n", "def", "_fourier_multioutput", "(", "kern", ":", "gpflow_kernels", ".", "MultioutputKernel", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "fourier_bases", ".", "MultioutputDense", "(", "kernel", "=", "kern", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.dispatch._fourier_conv2d": [[48, 51], ["fourier_basis.register", "gpflow_sampling.bases.fourier_bases.Conv2d"], "function", ["None"], ["", "@", "fourier_basis", ".", "register", "(", "kernels", ".", "Conv2d", ")", "\n", "def", "_fourier_conv2d", "(", "kern", ":", "kernels", ".", "Conv2d", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "fourier_bases", ".", "Conv2d", "(", "kernel", "=", "kern", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.dispatch._fourier_conv2d_transposed": [[53, 56], ["fourier_basis.register", "gpflow_sampling.bases.fourier_bases.Conv2dTranspose"], "function", ["None"], ["", "@", "fourier_basis", ".", "register", "(", "kernels", ".", "Conv2dTranspose", ")", "\n", "def", "_fourier_conv2d_transposed", "(", "kern", ":", "kernels", ".", "Conv2dTranspose", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "fourier_bases", ".", "Conv2dTranspose", "(", "kernel", "=", "kern", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.bases.dispatch._fourier_depthwise_conv2d": [[58, 61], ["fourier_basis.register", "gpflow_sampling.bases.fourier_bases.DepthwiseConv2d"], "function", ["None"], ["", "@", "fourier_basis", ".", "register", "(", "kernels", ".", "DepthwiseConv2d", ")", "\n", "def", "_fourier_depthwise_conv2d", "(", "kern", ":", "kernels", ".", "DepthwiseConv2d", ",", "**", "kwargs", ")", ":", "\n", "  ", "return", "fourier_bases", ".", "DepthwiseConv2d", "(", "kernel", "=", "kern", ",", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig.get_stanmodel": [[16, 39], ["str", "pathlib.Path", "time.time", "pystan.StanModel", "pickle.load", "time.time", "open", "pickle.dump", "print", "print", "open", "print", "gp_fixedsig.get_model_code", "str"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_model_code"], ["def", "get_stanmodel", "(", "recompile", "=", "False", ",", "verbose", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return stan model. Recompile model if recompile is True.\"\"\"", "\n", "\n", "model_str", "=", "'gp_fixedsig'", "\n", "\n", "base_path", "=", "pathlib", ".", "Path", "(", "__file__", ")", ".", "parent", "\n", "relative_path_to_model", "=", "'model_pkls/'", "+", "model_str", "+", "'.pkl'", "\n", "model_path", "=", "str", "(", "(", "base_path", "/", "relative_path_to_model", ")", ".", "resolve", "(", ")", ")", "\n", "\n", "if", "recompile", ":", "\n", "        ", "starttime", "=", "time", ".", "time", "(", ")", "\n", "model", "=", "pystan", ".", "StanModel", "(", "model_code", "=", "get_model_code", "(", ")", ")", "\n", "buildtime", "=", "time", ".", "time", "(", ")", "-", "starttime", "\n", "with", "open", "(", "model_path", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "model", ",", "f", ")", "\n", "", "if", "verbose", ":", "\n", "            ", "print", "(", "'*[INFO] Time taken to compile = '", "+", "str", "(", "buildtime", ")", "+", "' seconds.'", ")", "\n", "print", "(", "'*[INFO] Stan model saved in file '", "+", "model_path", ")", "\n", "", "", "else", ":", "\n", "        ", "model", "=", "pickle", ".", "load", "(", "open", "(", "model_path", ",", "'rb'", ")", ")", "\n", "if", "verbose", ":", "\n", "            ", "print", "(", "'*[INFO] Stan model loaded from file {}'", ".", "format", "(", "model_path", ")", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig.get_model_code": [[41, 71], ["None"], "function", ["None"], ["", "def", "get_model_code", "(", ")", ":", "\n", "    ", "\"\"\"Parse modelp and return stan model code.\"\"\"", "\n", "\n", "return", "\"\"\"\n    data {\n        int<lower=1> D;\n        int<lower=1> N;\n        vector[D] x[N];\n        vector[N] y;\n        real<lower=0> ig1;\n        real<lower=0> ig2;\n        real<lower=0> n1;\n        real<lower=0> n2;\n        real<lower=0> sigma;\n    }\n\n    parameters {\n        real<lower=0> rho;\n        real<lower=0> alpha;\n    }\n\n    model {\n        matrix[N, N] cov = cov_exp_quad(x, alpha, rho)\n                           + diag_matrix(rep_vector(square(sigma), N));\n        matrix[N, N] L_cov = cholesky_decompose(cov);\n        rho ~ inv_gamma(ig1, ig2);\n        alpha ~ normal(n1, n2);\n        y ~ multi_normal_cholesky(rep_vector(0, N), L_cov);\n    }\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_stanmodel": [[16, 39], ["str", "pathlib.Path", "time.time", "pystan.StanModel", "pickle.load", "time.time", "open", "pickle.dump", "print", "print", "open", "print", "gp_fixedsig_distmat.get_model_code", "str"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_model_code"], ["def", "get_stanmodel", "(", "recompile", "=", "False", ",", "print_status", "=", "True", ")", ":", "\n", "    ", "\"\"\"Return stan model. Recompile model if recompile is True.\"\"\"", "\n", "\n", "model_str", "=", "'gp_fixedsig_distmat'", "\n", "\n", "base_path", "=", "pathlib", ".", "Path", "(", "__file__", ")", ".", "parent", "\n", "relative_path_to_model", "=", "'model_pkls/'", "+", "model_str", "+", "'.pkl'", "\n", "model_path", "=", "str", "(", "(", "base_path", "/", "relative_path_to_model", ")", ".", "resolve", "(", ")", ")", "\n", "\n", "if", "recompile", ":", "\n", "        ", "starttime", "=", "time", ".", "time", "(", ")", "\n", "model", "=", "pystan", ".", "StanModel", "(", "model_code", "=", "get_model_code", "(", ")", ")", "\n", "buildtime", "=", "time", ".", "time", "(", ")", "-", "starttime", "\n", "with", "open", "(", "model_path", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "model", ",", "f", ")", "\n", "", "if", "print_status", ":", "\n", "            ", "print", "(", "'*[INFO] Time taken to compile = '", "+", "str", "(", "buildtime", ")", "+", "' seconds.'", ")", "\n", "print", "(", "'*[INFO] Stan model saved in file '", "+", "model_path", ")", "\n", "", "", "else", ":", "\n", "        ", "model", "=", "pickle", ".", "load", "(", "open", "(", "model_path", ",", "'rb'", ")", ")", "\n", "if", "print_status", ":", "\n", "            ", "print", "(", "'*[INFO] Stan model loaded from file {}'", ".", "format", "(", "model_path", ")", ")", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_model_code": [[41, 70], ["None"], "function", ["None"], ["", "def", "get_model_code", "(", ")", ":", "\n", "    ", "\"\"\"Parse modelp and return stan model code.\"\"\"", "\n", "\n", "return", "\"\"\"\n    data {\n        int<lower=1> N;\n        matrix[N, N] distmat;\n        vector[N] y;\n        real<lower=0> ig1;\n        real<lower=0> ig2;\n        real<lower=0> n1;\n        real<lower=0> n2;\n        real<lower=0> sigma;\n    }\n\n    parameters {\n        real<lower=0> rho;\n        real<lower=0> alpha;\n    }\n\n    model {\n        matrix[N, N] cov = square(alpha) * exp(-distmat / square(rho))\n                           + diag_matrix(rep_vector(square(sigma), N));\n        matrix[N, N] L_cov = cholesky_decompose(cov);\n        rho ~ inv_gamma(ig1, ig2);\n        alpha ~ normal(n1, n2);\n        y ~ multi_normal_cholesky(rep_vector(0, N), L_cov);\n    }\n    \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.compile_models.main": [[11, 17], ["gp_fixedsig.get_stanmodel", "gp_fixedsig_distmat.get_stanmodel"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_stanmodel", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.stan.gp_fixedsig_distmat.get_stanmodel"], ["def", "main", "(", "model_str", ")", ":", "\n", "    ", "\"\"\"Re-compile model specified by model_str.\"\"\"", "\n", "if", "model_str", "==", "'gp_fixedsig'", ":", "\n", "        ", "model", "=", "get_stanmodel_fixedsig", "(", "recompile", "=", "True", ")", "\n", "", "elif", "model_str", "==", "'gp_fixedsig_distmat'", ":", "\n", "        ", "model", "=", "get_stanmodel_fixedsig_distmat", "(", "recompile", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.kern_exp_quad": [[11, 17], ["gp_utils.kern_exp_quad_noscale"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.kern_exp_quad_noscale"], ["def", "kern_exp_quad", "(", "xmat1", ",", "xmat2", ",", "ls", ",", "alpha", ")", ":", "\n", "    ", "\"\"\"\n    Exponentiated quadratic kernel function (aka squared exponential kernel aka\n    RBF kernel).\n    \"\"\"", "\n", "return", "alpha", "**", "2", "*", "kern_exp_quad_noscale", "(", "xmat1", ",", "xmat2", ",", "ls", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.kern_exp_quad_noscale": [[19, 27], ["gp_utils.squared_euc_distmat", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.squared_euc_distmat"], ["", "def", "kern_exp_quad_noscale", "(", "xmat1", ",", "xmat2", ",", "ls", ")", ":", "\n", "    ", "\"\"\"\n    Exponentiated quadratic kernel function (aka squared exponential kernel aka\n    RBF kernel), without scale parameter.\n    \"\"\"", "\n", "distmat", "=", "squared_euc_distmat", "(", "xmat1", ",", "xmat2", ")", "\n", "sq_norm", "=", "-", "distmat", "/", "(", "2", "*", "ls", "**", "2", ")", "\n", "return", "np", ".", "exp", "(", "sq_norm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.squared_euc_distmat": [[29, 35], ["scipy.spatial.distance.cdist"], "function", ["None"], ["", "def", "squared_euc_distmat", "(", "xmat1", ",", "xmat2", ",", "coef", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"\n    Distance matrix of squared euclidean distance (multiplied by coef) between\n    points in xmat1 and xmat2.\n    \"\"\"", "\n", "return", "coef", "*", "cdist", "(", "xmat1", ",", "xmat2", ",", "'sqeuclidean'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.kern_distmat": [[37, 45], ["distfn", "numpy.exp"], "function", ["None"], ["", "def", "kern_distmat", "(", "xmat1", ",", "xmat2", ",", "ls", ",", "alpha", ",", "distfn", ")", ":", "\n", "    ", "\"\"\"\n    Kernel for a given distmat, via passed in distfn (which is assumed to be fn\n    of xmat1 and xmat2 only).\n    \"\"\"", "\n", "distmat", "=", "distfn", "(", "xmat1", ",", "xmat2", ")", "\n", "kernmat", "=", "alpha", "**", "2", "*", "np", ".", "exp", "(", "-", "distmat", "/", "(", "2", "*", "ls", "**", "2", ")", ")", "\n", "return", "kernmat", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.kern_simple_list": [[47, 56], ["gp_utils.simple_list_distmat", "numpy.exp"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.simple_list_distmat"], ["", "def", "kern_simple_list", "(", "xlist1", ",", "xlist2", ",", "ls", ",", "alpha", ",", "base_dist", "=", "5.0", ")", ":", "\n", "    ", "\"\"\"\n    Kernel for two lists containing elements that can be compared for equality.\n    K(a,b) = 1 + base_dist if a and b are equal and K(a,b) = base_dist otherwise.\n    \"\"\"", "\n", "distmat", "=", "simple_list_distmat", "(", "xlist1", ",", "xlist2", ")", "\n", "distmat", "=", "distmat", "+", "base_dist", "\n", "kernmat", "=", "alpha", "**", "2", "*", "np", ".", "exp", "(", "-", "distmat", "/", "(", "2", "*", "ls", "**", "2", ")", ")", "\n", "return", "kernmat", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.simple_list_distmat": [[58, 79], ["list", "len", "len", "np.array().astype.reshape", "itertools.product", "numpy.array().astype", "numpy.array().astype", "numpy.array", "numpy.array", "all"], "function", ["None"], ["", "def", "simple_list_distmat", "(", "xlist1", ",", "xlist2", ",", "weight", "=", "1.0", ",", "additive", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Return distance matrix containing zeros when xlist1[i] == xlist2[j] and 0 otherwise.\n    \"\"\"", "\n", "prod_list", "=", "list", "(", "itertools", ".", "product", "(", "xlist1", ",", "xlist2", ")", ")", "\n", "len1", "=", "len", "(", "xlist1", ")", "\n", "len2", "=", "len", "(", "xlist2", ")", "\n", "try", ":", "\n", "        ", "binary_mat", "=", "np", ".", "array", "(", "[", "x", "[", "0", "]", "!=", "x", "[", "1", "]", "for", "x", "in", "prod_list", "]", ")", ".", "astype", "(", "int", ")", "\n", "", "except", ":", "\n", "# For cases where comparison returns iterable of bools", "\n", "        ", "binary_mat", "=", "np", ".", "array", "(", "[", "all", "(", "x", "[", "0", "]", "!=", "x", "[", "1", "]", ")", "for", "x", "in", "prod_list", "]", ")", ".", "astype", "(", "int", ")", "\n", "\n", "", "binary_mat", "=", "binary_mat", ".", "reshape", "(", "len1", ",", "len2", ")", "\n", "\n", "if", "additive", ":", "\n", "        ", "distmat", "=", "weight", "+", "binary_mat", "\n", "", "else", ":", "\n", "        ", "distmat", "=", "weight", "*", "binary_mat", "\n", "\n", "", "return", "distmat", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.get_product_kernel": [[81, 96], ["kernel", "kernel"], "function", ["None"], ["", "def", "get_product_kernel", "(", "kernel_list", ",", "additive", "=", "False", ")", ":", "\n", "    ", "\"\"\"Given a list of kernel functions, return product kernel.\"\"\"", "\n", "\n", "def", "product_kernel", "(", "x1", ",", "x2", ",", "ls", ",", "alpha", ")", ":", "\n", "        ", "\"\"\"Kernel returning elementwise-product of kernel matrices from kernel_list.\"\"\"", "\n", "mat_prod", "=", "kernel_list", "[", "0", "]", "(", "x1", ",", "x2", ",", "ls", ",", "1.0", ")", "\n", "for", "kernel", "in", "kernel_list", "[", "1", ":", "]", ":", "\n", "            ", "if", "additive", ":", "\n", "                ", "mat_prod", "=", "mat_prod", "+", "kernel", "(", "x1", ",", "x2", ",", "ls", ",", "1.0", ")", "\n", "", "else", ":", "\n", "                ", "mat_prod", "=", "mat_prod", "*", "kernel", "(", "x1", ",", "x2", ",", "ls", ",", "1.0", ")", "\n", "", "", "mat_prod", "=", "alpha", "**", "2", "*", "mat_prod", "\n", "return", "mat_prod", "\n", "\n", "", "return", "product_kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.get_cholesky_decomp": [[98, 112], ["gp_utils.stable_cholesky", "gp_utils.project_symmetric_to_psd_cone", "gp_utils.get_cholesky_decomp", "numpy.eye", "gp_utils.get_cholesky_decomp", "gp_utils.stable_cholesky", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.stable_cholesky", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.project_symmetric_to_psd_cone", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.get_cholesky_decomp", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.get_cholesky_decomp", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.stable_cholesky"], ["", "def", "get_cholesky_decomp", "(", "k11_nonoise", ",", "sigma", ",", "psd_str", ")", ":", "\n", "    ", "\"\"\"Return cholesky decomposition.\"\"\"", "\n", "if", "psd_str", "==", "'try_first'", ":", "\n", "        ", "k11", "=", "k11_nonoise", "+", "sigma", "**", "2", "*", "np", ".", "eye", "(", "k11_nonoise", ".", "shape", "[", "0", "]", ")", "\n", "try", ":", "\n", "            ", "return", "stable_cholesky", "(", "k11", ",", "False", ")", "\n", "", "except", "np", ".", "linalg", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "return", "get_cholesky_decomp", "(", "k11_nonoise", ",", "sigma", ",", "'project_first'", ")", "\n", "", "", "elif", "psd_str", "==", "'project_first'", ":", "\n", "        ", "k11_nonoise", "=", "project_symmetric_to_psd_cone", "(", "k11_nonoise", ")", "\n", "return", "get_cholesky_decomp", "(", "k11_nonoise", ",", "sigma", ",", "'is_psd'", ")", "\n", "", "elif", "psd_str", "==", "'is_psd'", ":", "\n", "        ", "k11", "=", "k11_nonoise", "+", "sigma", "**", "2", "*", "np", ".", "eye", "(", "k11_nonoise", ".", "shape", "[", "0", "]", ")", "\n", "return", "stable_cholesky", "(", "k11", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.stable_cholesky": [[114, 144], ["numpy.linalg.cholesky", "numpy.diag().max", "numpy.diag().max", "numpy.diag", "numpy.linalg.cholesky", "print", "numpy.diag", "numpy.eye", "print"], "function", ["None"], ["", "", "def", "stable_cholesky", "(", "mmat", ",", "make_psd", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Return a 'stable' cholesky decomposition of mmat.\"\"\"", "\n", "if", "mmat", ".", "size", "==", "0", ":", "\n", "        ", "return", "mmat", "\n", "", "try", ":", "\n", "        ", "lmat", "=", "np", ".", "linalg", ".", "cholesky", "(", "mmat", ")", "\n", "", "except", "np", ".", "linalg", ".", "linalg", ".", "LinAlgError", "as", "e", ":", "\n", "        ", "if", "not", "make_psd", ":", "\n", "            ", "raise", "e", "\n", "", "diag_noise_power", "=", "-", "11", "\n", "max_mmat", "=", "np", ".", "diag", "(", "mmat", ")", ".", "max", "(", ")", "\n", "diag_noise", "=", "np", ".", "diag", "(", "mmat", ")", ".", "max", "(", ")", "*", "1e-11", "\n", "break_loop", "=", "False", "\n", "while", "not", "break_loop", ":", "\n", "            ", "try", ":", "\n", "                ", "lmat", "=", "np", ".", "linalg", ".", "cholesky", "(", "\n", "mmat", "+", "(", "(", "10", "**", "diag_noise_power", ")", "*", "max_mmat", ")", "*", "np", ".", "eye", "(", "mmat", ".", "shape", "[", "0", "]", ")", "\n", ")", "\n", "break_loop", "=", "True", "\n", "", "except", "np", ".", "linalg", ".", "linalg", ".", "LinAlgError", ":", "\n", "                ", "if", "diag_noise_power", ">", "-", "9", ":", "\n", "                    ", "if", "verbose", ":", "\n", "                        ", "print", "(", "\n", "'\\t*stable_cholesky failed with '", "\n", "'diag_noise_power=%d.'", "%", "(", "diag_noise_power", ")", "\n", ")", "\n", "", "", "diag_noise_power", "+=", "1", "\n", "", "if", "diag_noise_power", ">=", "5", ":", "\n", "                ", "print", "(", "'\\t*stable_cholesky failed: added diag noise = %e'", "%", "(", "diag_noise", ")", ")", "\n", "", "", "", "return", "lmat", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.project_symmetric_to_psd_cone": [[146, 160], ["numpy.clip", "numpy.linalg.eig", "numpy.linalg.eigh", "print", "numpy.linalg.eig", "numpy.real", "numpy.real"], "function", ["None"], ["", "def", "project_symmetric_to_psd_cone", "(", "mmat", ",", "is_symmetric", "=", "True", ",", "epsilon", "=", "0", ")", ":", "\n", "    ", "\"\"\"Project symmetric matrix mmat to the PSD cone.\"\"\"", "\n", "if", "is_symmetric", ":", "\n", "        ", "try", ":", "\n", "            ", "eigvals", ",", "eigvecs", "=", "np", ".", "linalg", ".", "eigh", "(", "mmat", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "print", "(", "'\\tLinAlgError encountered with np.eigh. Defaulting to eig.'", ")", "\n", "eigvals", ",", "eigvecs", "=", "np", ".", "linalg", ".", "eig", "(", "mmat", ")", "\n", "eigvals", "=", "np", ".", "real", "(", "eigvals", ")", "\n", "eigvecs", "=", "np", ".", "real", "(", "eigvecs", ")", "\n", "", "", "else", ":", "\n", "        ", "eigvals", ",", "eigvecs", "=", "np", ".", "linalg", ".", "eig", "(", "mmat", ")", "\n", "", "clipped_eigvals", "=", "np", ".", "clip", "(", "eigvals", ",", "epsilon", ",", "np", ".", "inf", ")", "\n", "return", "(", "eigvecs", "*", "clipped_eigvals", ")", ".", "dot", "(", "eigvecs", ".", "T", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_lower_triangular": [[162, 165], ["gp_utils.solve_triangular_base"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_triangular_base"], ["", "def", "solve_lower_triangular", "(", "amat", ",", "b", ")", ":", "\n", "    ", "\"\"\"Solves amat*x=b when amat is lower triangular.\"\"\"", "\n", "return", "solve_triangular_base", "(", "amat", ",", "b", ",", "lower", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_upper_triangular": [[167, 170], ["gp_utils.solve_triangular_base"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_triangular_base"], ["", "def", "solve_upper_triangular", "(", "amat", ",", "b", ")", ":", "\n", "    ", "\"\"\"Solves amat*x=b when amat is upper triangular.\"\"\"", "\n", "return", "solve_triangular_base", "(", "amat", ",", "b", ",", "lower", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_triangular_base": [[172, 178], ["numpy.zeros", "scipy.linalg.solve_triangular"], "function", ["None"], ["", "def", "solve_triangular_base", "(", "amat", ",", "b", ",", "lower", ")", ":", "\n", "    ", "\"\"\"Solves amat*x=b when amat is a triangular matrix.\"\"\"", "\n", "if", "amat", ".", "size", "==", "0", "and", "b", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "b", ".", "shape", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "solve_triangular", "(", "amat", ",", "b", ",", "lower", "=", "lower", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.sample_mvn": [[180, 190], ["mu.reshape.reshape", "len", "gp_utils.stable_cholesky", "numpy.random.normal", "stable_cholesky.dot"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.stable_cholesky"], ["", "", "def", "sample_mvn", "(", "mu", ",", "covmat", ",", "nsamp", ")", ":", "\n", "    ", "\"\"\"\n    Sample from multivariate normal distribution with mean mu and covariance\n    matrix covmat.\n    \"\"\"", "\n", "mu", "=", "mu", ".", "reshape", "(", "-", "1", ")", "\n", "ndim", "=", "len", "(", "mu", ")", "\n", "lmat", "=", "stable_cholesky", "(", "covmat", ")", "\n", "umat", "=", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "ndim", ",", "nsamp", ")", ")", "\n", "return", "lmat", ".", "dot", "(", "umat", ")", ".", "T", "+", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.gp_post": [[192, 205], ["kernel", "gp_utils.get_cholesky_decomp", "gp_utils.solve_upper_triangular", "kernel", "kernel.dot", "kernel", "gp_utils.solve_lower_triangular", "gp_utils.solve_lower_triangular", "solve_lower_triangular.T.dot", "numpy.sqrt", "numpy.diag"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.get_cholesky_decomp", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_upper_triangular", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_lower_triangular", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.gp.gp_utils.solve_lower_triangular"], ["", "def", "gp_post", "(", "x_train", ",", "y_train", ",", "x_pred", ",", "ls", ",", "alpha", ",", "sigma", ",", "kernel", ",", "full_cov", "=", "True", ")", ":", "\n", "    ", "\"\"\"Compute parameters of GP posterior\"\"\"", "\n", "k11_nonoise", "=", "kernel", "(", "x_train", ",", "x_train", ",", "ls", ",", "alpha", ")", "\n", "lmat", "=", "get_cholesky_decomp", "(", "k11_nonoise", ",", "sigma", ",", "'try_first'", ")", "\n", "smat", "=", "solve_upper_triangular", "(", "lmat", ".", "T", ",", "solve_lower_triangular", "(", "lmat", ",", "y_train", ")", ")", "\n", "k21", "=", "kernel", "(", "x_pred", ",", "x_train", ",", "ls", ",", "alpha", ")", "\n", "mu2", "=", "k21", ".", "dot", "(", "smat", ")", "\n", "k22", "=", "kernel", "(", "x_pred", ",", "x_pred", ",", "ls", ",", "alpha", ")", "\n", "vmat", "=", "solve_lower_triangular", "(", "lmat", ",", "k21", ".", "T", ")", "\n", "k2", "=", "k22", "-", "vmat", ".", "T", ".", "dot", "(", "vmat", ")", "\n", "if", "full_cov", "is", "False", ":", "\n", "        ", "k2", "=", "np", ".", "sqrt", "(", "np", ".", "diag", "(", "k2", ")", ")", "\n", "", "return", "mu2", ",", "k2", "\n", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.set_params": [[19, 29], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqOptimizer.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"AcqOptimizer\"", ")", "\n", "self", ".", "params", ".", "opt_str", "=", "getattr", "(", "params", ",", "\"opt_str\"", ",", "\"batch\"", ")", "\n", "default_x_batch", "=", "[", "[", "x", "]", "for", "x", "in", "np", ".", "linspace", "(", "0.0", ",", "40.0", ",", "500", ")", "]", "\n", "self", ".", "params", ".", "x_batch", "=", "getattr", "(", "params", ",", "\"x_batch\"", ",", "default_x_batch", ")", "\n", "self", ".", "params", ".", "remove_x_dups", "=", "getattr", "(", "params", ",", "\"remove_x_dups\"", ",", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.optimize": [[30, 51], ["acqoptimize.AcqOptimizer.set_acqfunction", "acqoptimize.AcqOptimizer.acqfunction.initialize", "acqoptimize.AcqOptimizer.optimize_batch"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.set_acqfunction", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.optimize_batch"], ["", "def", "optimize", "(", "self", ",", "acqfunction", ")", ":", "\n", "        ", "\"\"\"\n        Optimize acquisition function.\n\n        Parameters\n        ----------\n        acqfunction : AcqFunction\n            AcqFunction instance.\n        \"\"\"", "\n", "\n", "# Set self.acqfunction", "\n", "self", ".", "set_acqfunction", "(", "acqfunction", ")", "\n", "\n", "# Initialize acquisition function", "\n", "self", ".", "acqfunction", ".", "initialize", "(", ")", "\n", "\n", "# Optimize acquisition function", "\n", "if", "self", ".", "params", ".", "opt_str", "==", "\"batch\"", ":", "\n", "            ", "acq_opt", "=", "self", ".", "optimize_batch", "(", ")", "\n", "\n", "", "return", "acq_opt", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.set_acqfunction": [[52, 60], ["acquisition.BaxAcqFunction"], "methods", ["None"], ["", "def", "set_acqfunction", "(", "self", ",", "acqfunction", ")", ":", "\n", "        ", "\"\"\"Set self.acqfunction, the acquisition function.\"\"\"", "\n", "if", "not", "acqfunction", ":", "\n", "# If acqfunction is None, set default acqfunction as BaxAcqFunction", "\n", "            ", "params", "=", "{", "\"acq_str\"", ":", "\"out\"", "}", "\n", "self", ".", "acqfunction", "=", "BaxAcqFunction", "(", "params", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "acqfunction", "=", "acqfunction", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.optimize_batch": [[61, 74], ["copy.deepcopy", "acqoptimize.AcqOptimizer.acqfunction", "acqoptimize.AcqOptimizer.remove_x_dups", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.remove_x_dups"], ["", "", "def", "optimize_batch", "(", "self", ")", ":", "\n", "        ", "\"\"\"Optimize acquisition function over self.params.x_batch.\"\"\"", "\n", "x_batch", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ".", "x_batch", ")", "\n", "\n", "# Optionally remove data.x (in acqfunction) duplicates", "\n", "if", "self", ".", "params", ".", "remove_x_dups", ":", "\n", "            ", "x_batch", "=", "self", ".", "remove_x_dups", "(", "x_batch", ")", "\n", "\n", "# Optimize self.acqfunction over x_batch", "\n", "", "acq_list", "=", "self", ".", "acqfunction", "(", "x_batch", ")", "\n", "acq_opt", "=", "x_batch", "[", "np", ".", "argmax", "(", "acq_list", ")", "]", "\n", "\n", "return", "acq_opt", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.remove_x_dups": [[75, 93], ["next", "enumerate", "all"], "methods", ["None"], ["", "def", "remove_x_dups", "(", "self", ",", "x_batch", ")", ":", "\n", "        ", "\"\"\"Remove elements of x_batch that are also in data.x (in self.acqfunction)\"\"\"", "\n", "\n", "# NOTE this requires self.acqfunction with model.data", "\n", "data", "=", "self", ".", "acqfunction", ".", "model", ".", "data", "\n", "\n", "# NOTE this only works for data.x consisting of list-types, not for arbitrary data.x", "\n", "for", "x", "in", "data", ".", "x", ":", "\n", "            ", "while", "True", ":", "\n", "                ", "try", ":", "\n", "                    ", "idx", ",", "pos", "=", "next", "(", "\n", "(", "tup", "for", "tup", "in", "enumerate", "(", "x_batch", ")", "if", "all", "(", "tup", "[", "1", "]", "==", "x", ")", ")", "\n", ")", "\n", "del", "x_batch", "[", "idx", "]", "\n", "", "except", ":", "\n", "                    ", "break", "\n", "\n", "", "", "", "return", "x_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acqoptimize.AcqOptimizer.set_print_params": [[94, 98], ["copy.deepcopy", "delattr"], "methods", ["None"], ["", "def", "set_print_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set self.print_params.\"\"\"", "\n", "self", ".", "print_params", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ")", "\n", "delattr", "(", "self", ".", "print_params", ",", "\"x_batch\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.__init__": [[22, 35], ["util.base.Base.__init__", "acquisition.AcqFunction.set_model"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.set_model"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "model", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for the AcqFunction.\n        model : SimpleGp\n            Instance of a SimpleGp or child class.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "self", ".", "set_model", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.set_params": [[36, 41], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'AcqFunction'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.set_model": [[42, 48], ["ValueError", "copy.deepcopy"], "methods", ["None"], ["", "def", "set_model", "(", "self", ",", "model", ")", ":", "\n", "        ", "\"\"\"Set self.model, the model underlying the acquisition function.\"\"\"", "\n", "if", "not", "model", ":", "\n", "            ", "raise", "ValueError", "(", "\"The model input parameter cannot be None.\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "model", "=", "copy", ".", "deepcopy", "(", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.initialize": [[49, 52], ["None"], "methods", ["None"], ["", "", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize the acquisition function before acquisition optimization.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.__call__": [[53, 60], ["numpy.random.random"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "\n", "# Random acquisition function", "\n", "acq_list", "=", "[", "np", ".", "random", ".", "random", "(", ")", "for", "x", "in", "x_list", "]", "\n", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.RandAcqFunction.set_params": [[67, 73], ["acquisition.AcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'RandAcqFunction'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.RandAcqFunction.__call__": [[74, 81], ["numpy.random.random"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "\n", "# Random acquisition function", "\n", "acq_list", "=", "[", "np", ".", "random", ".", "random", "(", ")", "for", "x", "in", "x_list", "]", "\n", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.__init__": [[89, 105], ["acquisition.AcqFunction.__init__", "acquisition.AlgoAcqFunction.set_model", "acquisition.AlgoAcqFunction.set_algorithm"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.set_model", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.set_algorithm"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "model", "=", "None", ",", "algorithm", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for the AcqFunction.\n        model : SimpleGp\n            Instance of a SimpleGp or child.\n        algorithm : Algorithm\n            Instance of an Algorithm or child.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "self", ".", "set_model", "(", "model", ")", "\n", "self", ".", "set_algorithm", "(", "algorithm", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.set_params": [[106, 114], ["acquisition.AcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'AlgoAcqFunction'", ")", "\n", "self", ".", "params", ".", "n_path", "=", "getattr", "(", "params", ",", "\"n_path\"", ",", "100", ")", "\n", "self", ".", "params", ".", "crop", "=", "getattr", "(", "params", ",", "\"crop\"", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.set_algorithm": [[115, 121], ["ValueError", "algorithm.get_copy"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_copy"], ["", "def", "set_algorithm", "(", "self", ",", "algorithm", ")", ":", "\n", "        ", "\"\"\"Set self.algorithm for this acquisition function.\"\"\"", "\n", "if", "not", "algorithm", ":", "\n", "            ", "raise", "ValueError", "(", "\"The algorithm input parameter cannot be None.\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "algorithm", "=", "algorithm", ".", "get_copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.initialize": [[122, 139], ["acquisition.AlgoAcqFunction.get_exe_path_and_output_samples"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.get_exe_path_and_output_samples"], ["", "", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the acquisition function before acquisition optimization. Draw\n        samples of the execution path and algorithm output from functions sampled from\n        the model.\n        \"\"\"", "\n", "exe_path_list", ",", "output_list", ",", "full_list", "=", "self", ".", "get_exe_path_and_output_samples", "(", ")", "\n", "\n", "# Set self.output_list", "\n", "self", ".", "output_list", "=", "output_list", "\n", "self", ".", "exe_path_full_list", "=", "full_list", "\n", "\n", "# Set self.exe_path_list to list of full or cropped exe paths", "\n", "if", "self", ".", "params", ".", "crop", ":", "\n", "            ", "self", ".", "exe_path_list", "=", "exe_path_list", "\n", "", "else", ":", "\n", "            ", "self", ".", "exe_path_list", "=", "full_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.get_exe_path_and_output_samples_loop": [[140, 156], ["util.timing.Timer", "range", "models.function.FunctionSample", "models.function.FunctionSample.set_model", "acquisition.AlgoAcqFunction.algorithm.run_algorithm_on_f", "exe_path_list.append", "output_list.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AcqFunction.set_model", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Noop.run_algorithm_on_f"], ["", "", "def", "get_exe_path_and_output_samples_loop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return exe_path_list and output_list respectively containing self.params.n_path\n        exe_path samples and associated outputs, using self.model and self.algorithm.\n        \"\"\"", "\n", "exe_path_list", "=", "[", "]", "\n", "output_list", "=", "[", "]", "\n", "with", "Timer", "(", "f\"Sample {self.params.n_path} execution paths\"", ")", ":", "\n", "            ", "for", "_", "in", "range", "(", "self", ".", "params", ".", "n_path", ")", ":", "\n", "                ", "fs", "=", "FunctionSample", "(", "verbose", "=", "False", ")", "\n", "fs", ".", "set_model", "(", "self", ".", "model", ")", "\n", "exe_path", ",", "output", "=", "self", ".", "algorithm", ".", "run_algorithm_on_f", "(", "fs", ")", "\n", "exe_path_list", ".", "append", "(", "exe_path", ")", "\n", "output_list", ".", "append", "(", "output", ")", "\n", "\n", "", "", "return", "exe_path_list", ",", "output_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.AlgoAcqFunction.get_exe_path_and_output_samples": [[157, 179], ["util.timing.Timer", "acquisition.AlgoAcqFunction.model.initialize_function_sample_list", "alg.algorithms.AlgorithmSet", "alg.algorithms.AlgorithmSet.run_algorithm_on_f_list", "alg.algorithms.AlgorithmSet.get_exe_path_list_crop"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.initialize_function_sample_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AlgorithmSet.run_algorithm_on_f_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AlgorithmSet.get_exe_path_list_crop"], ["", "def", "get_exe_path_and_output_samples", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return exe_path_list and output_list respectively containing self.params.n_path\n        exe_path samples and associated outputs, using self.model and self.algorithm.\n        \"\"\"", "\n", "exe_path_list", "=", "[", "]", "\n", "output_list", "=", "[", "]", "\n", "with", "Timer", "(", "f\"Sample {self.params.n_path} execution paths\"", ")", ":", "\n", "# Initialize model fsl", "\n", "            ", "self", ".", "model", ".", "initialize_function_sample_list", "(", "self", ".", "params", ".", "n_path", ")", "\n", "\n", "# Run algorithm on function sample list", "\n", "f_list", "=", "self", ".", "model", ".", "call_function_sample_list", "\n", "algoset", "=", "AlgorithmSet", "(", "self", ".", "algorithm", ")", "\n", "exe_path_full_list", ",", "output_list", "=", "algoset", ".", "run_algorithm_on_f_list", "(", "\n", "f_list", ",", "self", ".", "params", ".", "n_path", "\n", ")", "\n", "\n", "# Get crop of each exe_path in exe_path_list", "\n", "exe_path_list", "=", "algoset", ".", "get_exe_path_list_crop", "(", ")", "\n", "\n", "", "return", "exe_path_list", ",", "output_list", ",", "exe_path_full_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.set_params": [[186, 199], ["acquisition.AlgoAcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'BaxAcqFunction'", ")", "\n", "self", ".", "params", ".", "acq_str", "=", "getattr", "(", "params", ",", "\"acq_str\"", ",", "\"exe\"", ")", "\n", "self", ".", "params", ".", "min_neighbors", "=", "getattr", "(", "params", ",", "\"min_neighbors\"", ",", "10", ")", "\n", "self", ".", "params", ".", "max_neighbors", "=", "getattr", "(", "params", ",", "\"max_neighbors\"", ",", "30", ")", "\n", "self", ".", "params", ".", "dist_thresh", "=", "getattr", "(", "params", ",", "\"dist_thresh\"", ",", "1.0", ")", "\n", "self", ".", "params", ".", "dist_thresh_init", "=", "getattr", "(", "params", ",", "\"dist_thresh_init\"", ",", "20.0", ")", "\n", "self", ".", "params", ".", "dist_thresh_inc", "=", "getattr", "(", "params", ",", "\"dist_thresh_inc\"", ",", "0.5", ")", "\n", "self", ".", "params", ".", "min_n_clust", "=", "getattr", "(", "params", ",", "\"min_n_clust\"", ",", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.entropy_given_normal_std": [[200, 204], ["numpy.log", "numpy.log", "numpy.sqrt"], "methods", ["None"], ["", "def", "entropy_given_normal_std", "(", "self", ",", "std_arr", ")", ":", "\n", "        ", "\"\"\"Return entropy given an array of 1D normal standard deviations.\"\"\"", "\n", "entropy", "=", "np", ".", "log", "(", "std_arr", ")", "+", "np", ".", "log", "(", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", ")", "+", "0.5", "\n", "return", "entropy", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.acq_exe_normal": [[205, 223], ["acquisition.BaxAcqFunction.entropy_given_normal_std", "numpy.mean", "acquisition.BaxAcqFunction.entropy_given_normal_std", "h_samp_list.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], ["", "def", "acq_exe_normal", "(", "self", ",", "post_std", ",", "samp_std_list", ")", ":", "\n", "        ", "\"\"\"\n        Execution-path-based acquisition function: EIG on the execution path, via\n        predictive entropy, for normal posterior predictive distributions.\n        \"\"\"", "\n", "\n", "# Compute entropies for posterior predictive", "\n", "h_post", "=", "self", ".", "entropy_given_normal_std", "(", "post_std", ")", "\n", "\n", "# Compute entropies for posterior predictive given execution path samples", "\n", "h_samp_list", "=", "[", "]", "\n", "for", "samp_std", "in", "samp_std_list", ":", "\n", "            ", "h_samp", "=", "self", ".", "entropy_given_normal_std", "(", "samp_std", ")", "\n", "h_samp_list", ".", "append", "(", "h_samp", ")", "\n", "\n", "", "avg_h_samp", "=", "np", ".", "mean", "(", "h_samp_list", ",", "0", ")", "\n", "acq_exe", "=", "h_post", "-", "avg_h_samp", "\n", "return", "acq_exe", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.acq_out_normal": [[224, 312], ["acquisition.BaxAcqFunction.entropy_given_normal_std", "acquisition.BaxAcqFunction.get_cluster_idx_list", "print", "print", "print", "print", "print", "print", "print", "numpy.mean", "len", "len", "print", "acquisition.BaxAcqFunction.get_cluster_idx_list", "len", "numpy.mean", "mean_cluster_list.append", "numpy.mean", "numpy.sqrt", "std_cluster_list.append", "acquisition.BaxAcqFunction.entropy_given_normal_std", "h_cluster_list.extend", "len", "print", "numpy.min", "numpy.max", "len", "len", "numpy.min", "numpy.max", "len", "numpy.min", "numpy.max", "len", "zip", "len"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.get_cluster_idx_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.get_cluster_idx_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], ["", "def", "acq_out_normal", "(", "self", ",", "post_std", ",", "samp_mean_list", ",", "samp_std_list", ",", "output_list", ")", ":", "\n", "        ", "\"\"\"\n        Algorithm-output-based acquisition function: EIG on the algorithm output, via\n        predictive entropy, for normal posterior predictive distributions.\n        \"\"\"", "\n", "# Compute entropies for posterior predictive", "\n", "h_post", "=", "self", ".", "entropy_given_normal_std", "(", "post_std", ")", "\n", "\n", "# Get list of idx-list-per-cluster", "\n", "dist_thresh", "=", "self", ".", "params", ".", "dist_thresh_init", "\n", "cluster_idx_list", "=", "self", ".", "get_cluster_idx_list", "(", "output_list", ",", "dist_thresh", ")", "\n", "\n", "# -----", "\n", "print", "(", "'\\t- clust_idx_list initial details:'", ")", "\n", "len_list", "=", "[", "len", "(", "clust", ")", "for", "clust", "in", "cluster_idx_list", "]", "\n", "print", "(", "f'\\t\\t- min len_list: {np.min(len_list)},  max len_list: {np.max(len_list)},  len(len_list): {len(len_list)}'", ")", "\n", "# -----", "\n", "\n", "# Filter clusters that are too small (looping to find optimal dist_thresh)", "\n", "min_nn", "=", "self", ".", "params", ".", "min_neighbors", "\n", "min_n_clust", "=", "self", ".", "params", ".", "min_n_clust", "\n", "min_dist_thresh", "=", "self", ".", "params", ".", "dist_thresh", "\n", "\n", "cluster_idx_list_new", "=", "[", "clust", "for", "clust", "in", "cluster_idx_list", "if", "len", "(", "clust", ")", ">", "min_nn", "]", "\n", "# -----", "\n", "print", "(", "'\\t- clust_idx_list_NEW details:'", ")", "\n", "len_list", "=", "[", "len", "(", "clust", ")", "for", "clust", "in", "cluster_idx_list_new", "]", "\n", "print", "(", "f'\\t\\t- min len_list: {np.min(len_list)},  max len_list: {np.max(len_list)},  len(len_list): {len(len_list)}'", ")", "\n", "# -----", "\n", "while", "len", "(", "cluster_idx_list_new", ")", ">", "min_n_clust", "and", "dist_thresh", ">=", "min_dist_thresh", ":", "\n", "            ", "cluster_idx_list_keep", "=", "cluster_idx_list_new", "\n", "dist_thresh", "-=", "self", ".", "params", ".", "dist_thresh_inc", "\n", "print", "(", "f'NOTE: dist_thresh = {dist_thresh}'", ")", "\n", "cluster_idx_tmp", "=", "self", ".", "get_cluster_idx_list", "(", "output_list", ",", "dist_thresh", ")", "\n", "cluster_idx_list_new", "=", "[", "clust", "for", "clust", "in", "cluster_idx_tmp", "if", "len", "(", "clust", ")", ">", "min_nn", "]", "\n", "\n", "", "try", ":", "\n", "            ", "cluster_idx_list", "=", "cluster_idx_list_keep", "\n", "", "except", "UnboundLocalError", ":", "\n", "            ", "print", "(", "\n", "'WARNING: cluster_idx_list_keep not assigned, using cluster_idx_list.'", "\n", ")", "\n", "pass", "\n", "\n", "## Only remove small clusters if there are enough big clusters", "\n", "#if len(cluster_idx_list_new) > self.params.min_n_clust:", "\n", "#cluster_idx_list = cluster_idx_list_new", "\n", "\n", "# -----", "\n", "", "len_list", "=", "[", "len", "(", "clust", ")", "for", "clust", "in", "cluster_idx_list", "]", "\n", "print", "(", "'\\t- clust_idx_list final details:'", ")", "\n", "print", "(", "f'\\t\\t- min len_list: {np.min(len_list)},  max len_list: {np.max(len_list)},  len(len_list): {len(len_list)}'", ")", "\n", "print", "(", "f'\\t\\tFound dist_thresh: {dist_thresh}'", ")", "\n", "# -----", "\n", "\n", "# Compute entropies for posterior predictive given execution path samples", "\n", "h_cluster_list", "=", "[", "]", "\n", "std_cluster_list", "=", "[", "]", "\n", "mean_cluster_list", "=", "[", "]", "\n", "for", "idx_list", "in", "cluster_idx_list", ":", "\n", "# Mean of the mixture", "\n", "            ", "samp_mean_cluster_list", "=", "[", "samp_mean_list", "[", "idx", "]", "for", "idx", "in", "idx_list", "]", "\n", "samp_mean_cluster", "=", "np", ".", "mean", "(", "samp_mean_cluster_list", ",", "0", ")", "\n", "mean_cluster_list", ".", "append", "(", "samp_mean_cluster", ")", "\n", "\n", "# Std of the mixture", "\n", "samp_std_cluster_list", "=", "[", "samp_std_list", "[", "idx", "]", "for", "idx", "in", "idx_list", "]", "\n", "smcls", "=", "[", "smc", "**", "2", "for", "smc", "in", "samp_mean_cluster_list", "]", "\n", "sscls", "=", "[", "ssc", "**", "2", "for", "ssc", "in", "samp_std_cluster_list", "]", "\n", "sum_smcls_sscls", "=", "[", "smcs", "+", "sscs", "for", "smcs", ",", "sscs", "in", "zip", "(", "smcls", ",", "sscls", ")", "]", "\n", "samp_sec_moment_cluster", "=", "np", ".", "mean", "(", "sum_smcls_sscls", ",", "0", ")", "\n", "samp_var_cluster", "=", "samp_sec_moment_cluster", "-", "samp_mean_cluster", "**", "2", "\n", "samp_std_cluster", "=", "np", ".", "sqrt", "(", "samp_var_cluster", ")", "\n", "std_cluster_list", ".", "append", "(", "samp_std_cluster", ")", "\n", "\n", "# Entropy of the Gaussian approximation to the mixture", "\n", "h_cluster", "=", "self", ".", "entropy_given_normal_std", "(", "samp_std_cluster", ")", "\n", "h_cluster_list", ".", "extend", "(", "[", "h_cluster", "]", ")", "\n", "\n", "", "avg_h_cluster", "=", "np", ".", "mean", "(", "h_cluster_list", ",", "0", ")", "\n", "acq_out", "=", "h_post", "-", "avg_h_cluster", "\n", "\n", "# Store variables", "\n", "self", ".", "cluster_idx_list", "=", "cluster_idx_list", "\n", "self", ".", "mean_cluster_list", "=", "mean_cluster_list", "\n", "self", ".", "std_cluster_list", "=", "std_cluster_list", "\n", "\n", "return", "acq_out", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.get_cluster_idx_list": [[313, 341], ["acquisition.BaxAcqFunction.algorithm.get_output_dist_fn", "numpy.argsort", "numpy.array", "idx_arr_list.append", "dist_arr_list.append", "acquisition.BaxAcqFunction.", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_output_dist_fn"], ["", "def", "get_cluster_idx_list", "(", "self", ",", "output_list", ",", "dist_thresh", ")", ":", "\n", "        ", "\"\"\"\n        Cluster outputs in output_list (based on nearest neighbors, and using\n        dist_thresh as a nearness threshold) and return list of idx-list-per-cluster.\n        \"\"\"", "\n", "\n", "# Build distance matrix", "\n", "dist_fn", "=", "self", ".", "algorithm", ".", "get_output_dist_fn", "(", ")", "\n", "dist_mat", "=", "[", "[", "dist_fn", "(", "o1", ",", "o2", ")", "for", "o1", "in", "output_list", "]", "for", "o2", "in", "output_list", "]", "\n", "\n", "# Build idx_arr_list and dist_arr_list", "\n", "idx_arr_list", "=", "[", "]", "\n", "dist_arr_list", "=", "[", "]", "\n", "for", "row", "in", "dist_mat", ":", "\n", "            ", "idx_sort", "=", "np", ".", "argsort", "(", "row", ")", "\n", "dist_sort", "=", "np", ".", "array", "(", "[", "row", "[", "i", "]", "for", "i", "in", "idx_sort", "]", ")", "\n", "\n", "# Keep at most max_neighbors, as long as they are within dist_thresh", "\n", "dist_sort", "=", "dist_sort", "[", ":", "self", ".", "params", ".", "max_neighbors", "]", "\n", "row_idx_keep", "=", "np", ".", "where", "(", "dist_sort", "<", "dist_thresh", ")", "[", "0", "]", "\n", "\n", "idx_arr", "=", "idx_sort", "[", "row_idx_keep", "]", "\n", "idx_arr_list", ".", "append", "(", "idx_arr", ")", "\n", "\n", "dist_arr", "=", "dist_sort", "[", "row_idx_keep", "]", "\n", "dist_arr_list", ".", "append", "(", "dist_arr", ")", "\n", "\n", "", "return", "idx_arr_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.acq_is_normal": [[342, 438], ["acquisition.BaxAcqFunction.entropy_given_normal_std", "acquisition.BaxAcqFunction.get_cluster_idx_list", "print", "print", "print", "range", "numpy.mean", "argparse.Namespace", "acquisition.BaxAcqFunction.model.gp_post_wrapper", "samp_mean_list_full.append", "samp_std_list_full.append", "len", "len", "len", "numpy.random.normal", "numpy.vstack", "numpy.vstack", "scipy.stats.norm.pdf", "numpy.zeros", "numpy.mean", "numpy.std", "acquisition.BaxAcqFunction.entropy_given_normal_std", "h_samp_list.append", "numpy.vstack", "numpy.vstack", "scipy.stats.norm.pdf", "len", "numpy.sum", "numpy.min", "numpy.max", "len", "numpy.min", "numpy.max", "len", "len", "range", "range", "range", "range"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.get_cluster_idx_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], ["", "def", "acq_is_normal", "(", "\n", "self", ",", "post_std", ",", "samp_mean_list", ",", "samp_std_list", ",", "output_list", ",", "x_list", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Algorithm-output-based acquisition function: EIG on the algorithm output, via\n        the importance sampling strategy, for normal posterior predictive distributions.\n        \"\"\"", "\n", "# Compute list of means and stds for full execution path", "\n", "samp_mean_list_full", "=", "[", "]", "\n", "samp_std_list_full", "=", "[", "]", "\n", "for", "exe_path", "in", "self", ".", "exe_path_full_list", ":", "\n", "            ", "comb_data", "=", "Namespace", "(", ")", "\n", "comb_data", ".", "x", "=", "self", ".", "model", ".", "data", ".", "x", "+", "exe_path", ".", "x", "\n", "comb_data", ".", "y", "=", "self", ".", "model", ".", "data", ".", "y", "+", "exe_path", ".", "y", "\n", "samp_mean", ",", "samp_std", "=", "self", ".", "model", ".", "gp_post_wrapper", "(", "\n", "x_list", ",", "comb_data", ",", "full_cov", "=", "False", "\n", ")", "\n", "samp_mean_list_full", ".", "append", "(", "samp_mean", ")", "\n", "samp_std_list_full", ".", "append", "(", "samp_std", ")", "\n", "\n", "# Compute entropies for posterior predictive", "\n", "", "h_post", "=", "self", ".", "entropy_given_normal_std", "(", "post_std", ")", "\n", "\n", "# Get list of idx-list-per-cluster", "\n", "cluster_idx_list", "=", "self", ".", "get_cluster_idx_list", "(", "\n", "output_list", ",", "self", ".", "params", ".", "dist_thresh", "\n", ")", "\n", "\n", "# -----", "\n", "print", "(", "'\\t- clust_idx_list details:'", ")", "\n", "len_list", "=", "[", "len", "(", "clust", ")", "for", "clust", "in", "cluster_idx_list", "]", "\n", "print", "(", "f'\\t- min len_list: {np.min(len_list)},  max len_list: {np.max(len_list)},  len(len_list): {len(len_list)}'", ")", "\n", "# -----", "\n", "\n", "## Remove clusters that are too small", "\n", "#min_nn = self.params.min_neighbors", "\n", "#cluster_idx_list = [clust for clust in cluster_idx_list if len(clust) > min_nn]", "\n", "\n", "# -----", "\n", "len_list", "=", "[", "len", "(", "clust", ")", "for", "clust", "in", "cluster_idx_list", "]", "\n", "print", "(", "f'\\t- min len_list: {np.min(len_list)},  max len_list: {np.max(len_list)},  len(len_list): {len(len_list)}'", ")", "\n", "# -----", "\n", "\n", "# Compute entropies for posterior predictive given execution path samples", "\n", "h_samp_list", "=", "[", "]", "\n", "#for samp_mean, samp_std in zip(samp_mean_list, samp_std_list):", "\n", "for", "exe_idx", "in", "range", "(", "len", "(", "samp_mean_list", ")", ")", ":", "\n", "# Unpack", "\n", "            ", "samp_mean", "=", "samp_mean_list", "[", "exe_idx", "]", "\n", "samp_mean_full", "=", "samp_mean_list_full", "[", "exe_idx", "]", "\n", "samp_std", "=", "samp_std_list", "[", "exe_idx", "]", "\n", "samp_std_full", "=", "samp_std_list_full", "[", "exe_idx", "]", "\n", "clust_idx", "=", "cluster_idx_list", "[", "exe_idx", "]", "\n", "\n", "# Sample from proposal distribution", "\n", "n_samp", "=", "200", "\n", "pow_fac", "=", "0.001", "\n", "samp_mat", "=", "np", ".", "random", ".", "normal", "(", "samp_mean", ",", "samp_std", ",", "(", "n_samp", ",", "len", "(", "samp_mean", ")", ")", ")", "\n", "\n", "# Compute importance weights denominators", "\n", "mean_mat", "=", "np", ".", "vstack", "(", "[", "samp_mean", "for", "_", "in", "range", "(", "n_samp", ")", "]", ")", "\n", "std_mat", "=", "np", ".", "vstack", "(", "[", "samp_std", "for", "_", "in", "range", "(", "n_samp", ")", "]", ")", "\n", "pdf_mat", "=", "sps_norm", ".", "pdf", "(", "samp_mat", ",", "mean_mat", ",", "std_mat", ")", "\n", "#weight_mat_den = np.ones(pdf_mat.shape)", "\n", "weight_mat_den", "=", "pdf_mat", "\n", "\n", "# Compute importance weights numerators", "\n", "pdf_mat_sum", "=", "np", ".", "zeros", "(", "pdf_mat", ".", "shape", ")", "\n", "for", "idx", "in", "clust_idx", ":", "\n", "                ", "samp_mean_full", "=", "samp_mean_list_full", "[", "idx", "]", "\n", "samp_std_full", "=", "samp_std_list_full", "[", "idx", "]", "\n", "\n", "mean_mat", "=", "np", ".", "vstack", "(", "[", "samp_mean_full", "for", "_", "in", "range", "(", "n_samp", ")", "]", ")", "\n", "std_mat", "=", "np", ".", "vstack", "(", "[", "samp_std_full", "for", "_", "in", "range", "(", "n_samp", ")", "]", ")", "\n", "pdf_mat", "=", "sps_norm", ".", "pdf", "(", "samp_mat", ",", "mean_mat", ",", "std_mat", ")", "\n", "pdf_mat_sum", "=", "pdf_mat_sum", "+", "pdf_mat", "\n", "\n", "#weight_mat_num = np.ones(pdf_mat_sum.shape)", "\n", "", "weight_mat_num", "=", "pdf_mat_sum", "/", "len", "(", "clust_idx", ")", "\n", "weight_mat_num", "=", "weight_mat_num", "\n", "\n", "# Compute and normalize importance weights", "\n", "weight_mat", "=", "(", "weight_mat_num", "+", "1e-50", ")", "/", "(", "weight_mat_den", "+", "1.1e-50", ")", "\n", "weight_mat_norm", "=", "weight_mat", "/", "np", ".", "sum", "(", "weight_mat", ",", "0", ")", "\n", "weight_mat_norm", "=", "(", "n_samp", "*", "weight_mat_norm", ")", "**", "pow_fac", "\n", "\n", "# Reweight samples and compute statistics", "\n", "weight_samp", "=", "samp_mat", "*", "weight_mat_norm", "*", "n_samp", "\n", "is_mean", "=", "np", ".", "mean", "(", "weight_samp", ",", "0", ")", "\n", "is_std", "=", "np", ".", "std", "(", "weight_samp", ",", "0", ")", "\n", "h_samp", "=", "self", ".", "entropy_given_normal_std", "(", "is_std", ")", "\n", "h_samp_list", ".", "append", "(", "h_samp", ")", "\n", "\n", "", "avg_h_samp", "=", "np", ".", "mean", "(", "h_samp_list", ",", "0", ")", "\n", "acq_is", "=", "h_post", "-", "avg_h_samp", "\n", "return", "acq_is", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.get_acq_list_batch": [[439, 480], ["util.timing.Timer", "acquisition.BaxAcqFunction.model.get_post_mu_cov", "argparse.Namespace", "acquisition.BaxAcqFunction.model.gp_post_wrapper", "mu_list.append", "std_list.append", "acquisition.BaxAcqFunction.acq_exe_normal", "acquisition.BaxAcqFunction.acq_out_normal", "len", "acquisition.BaxAcqFunction.acq_is_normal"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.acq_exe_normal", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.acq_out_normal", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.acq_is_normal"], ["", "def", "get_acq_list_batch", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Return acquisition function for a batch of inputs x_list.\"\"\"", "\n", "\n", "with", "Timer", "(", "f\"Compute acquisition function for a batch of {len(x_list)} points\"", ")", ":", "\n", "# Compute posterior, and post given each execution path sample, for x_list", "\n", "            ", "mu", ",", "std", "=", "self", ".", "model", ".", "get_post_mu_cov", "(", "x_list", ",", "full_cov", "=", "False", ")", "\n", "\n", "# Compute mean and std arrays for posterior given execution path samples", "\n", "mu_list", "=", "[", "]", "\n", "std_list", "=", "[", "]", "\n", "for", "exe_path", "in", "self", ".", "exe_path_list", ":", "\n", "                ", "comb_data", "=", "Namespace", "(", ")", "\n", "comb_data", ".", "x", "=", "self", ".", "model", ".", "data", ".", "x", "+", "exe_path", ".", "x", "\n", "comb_data", ".", "y", "=", "self", ".", "model", ".", "data", ".", "y", "+", "exe_path", ".", "y", "\n", "samp_mu", ",", "samp_std", "=", "self", ".", "model", ".", "gp_post_wrapper", "(", "\n", "x_list", ",", "comb_data", ",", "full_cov", "=", "False", "\n", ")", "\n", "mu_list", ".", "append", "(", "samp_mu", ")", "\n", "std_list", ".", "append", "(", "samp_std", ")", "\n", "\n", "# Compute acq_list, the acqfunction value for each x in x_list", "\n", "", "if", "self", ".", "params", ".", "acq_str", "==", "\"exe\"", ":", "\n", "                ", "acq_list", "=", "self", ".", "acq_exe_normal", "(", "std", ",", "std_list", ")", "\n", "", "elif", "self", ".", "params", ".", "acq_str", "==", "'out'", ":", "\n", "                ", "acq_list", "=", "self", ".", "acq_out_normal", "(", "std", ",", "mu_list", ",", "std_list", ",", "self", ".", "output_list", ")", "\n", "", "elif", "self", ".", "params", ".", "acq_str", "==", "'is'", ":", "\n", "                ", "acq_list", "=", "self", ".", "acq_is_normal", "(", "\n", "std", ",", "mu_list", ",", "std_list", ",", "self", ".", "output_list", ",", "x_list", "\n", ")", "\n", "\n", "# Package and store acq_vars", "\n", "", "", "self", ".", "acq_vars", "=", "{", "\n", "\"mu\"", ":", "mu", ",", "\n", "\"std\"", ":", "std", ",", "\n", "\"mu_list\"", ":", "mu_list", ",", "\n", "\"std_list\"", ":", "std_list", ",", "\n", "\"acq_list\"", ":", "acq_list", ",", "\n", "}", "\n", "\n", "# Return list of acquisition function on x in x_list", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.BaxAcqFunction.__call__": [[481, 485], ["acquisition.BaxAcqFunction.get_acq_list_batch"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.get_acq_list_batch"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "acq_list", "=", "self", ".", "get_acq_list_batch", "(", "x_list", ")", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MesAcqFunction.set_params": [[492, 499], ["acquisition.BaxAcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'MesAcqFunction'", ")", "\n", "self", ".", "params", ".", "opt_mode", "=", "getattr", "(", "params", ",", "\"opt_mode\"", ",", "\"max\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MesAcqFunction.get_acq_list_batch": [[500, 528], ["util.timing.Timer", "acquisition.MesAcqFunction.model.get_post_mu_cov", "acquisition.MesAcqFunction.entropy_given_normal_std", "numpy.mean", "numpy.log", "mc_list.append", "scipy.stats.norm.cdf", "len", "numpy.array", "scipy.stats.norm.pdf", "scipy.stats.norm.cdf", "numpy.array", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], ["", "def", "get_acq_list_batch", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Return acquisition function for a batch of inputs x_list.\"\"\"", "\n", "\n", "with", "Timer", "(", "f\"Compute acquisition function for a batch of {len(x_list)} points\"", ")", ":", "\n", "# Compute entropies for posterior for x in x_list", "\n", "            ", "mu", ",", "std", "=", "self", ".", "model", ".", "get_post_mu_cov", "(", "x_list", ",", "full_cov", "=", "False", ")", "\n", "h_post", "=", "self", ".", "entropy_given_normal_std", "(", "std", ")", "\n", "\n", "mc_list", "=", "[", "]", "\n", "for", "output", "in", "self", ".", "output_list", ":", "\n", "                ", "if", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "                    ", "gam", "=", "(", "output", "-", "np", ".", "array", "(", "mu", ")", ")", "/", "np", ".", "array", "(", "std", ")", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "                    ", "gam", "=", "(", "np", ".", "array", "(", "mu", ")", "-", "output", ")", "/", "np", ".", "array", "(", "std", ")", "\n", "", "t1", "=", "gam", "*", "sps_norm", ".", "pdf", "(", "gam", ")", "/", "(", "2", "*", "sps_norm", ".", "cdf", "(", "gam", ")", ")", "\n", "t2", "=", "np", ".", "log", "(", "sps_norm", ".", "cdf", "(", "gam", ")", ")", "\n", "mc_list", ".", "append", "(", "t1", "-", "t2", ")", "\n", "", "acq_list", "=", "np", ".", "mean", "(", "mc_list", ",", "0", ")", "\n", "\n", "# Package and store acq_vars", "\n", "", "self", ".", "acq_vars", "=", "{", "\n", "\"mu\"", ":", "mu", ",", "\n", "\"std\"", ":", "std", ",", "\n", "\"acq_list\"", ":", "acq_list", ",", "\n", "}", "\n", "\n", "# Return list of acquisition function on x in x_list", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.RandBaxAcqFunction.set_params": [[536, 542], ["acquisition.BaxAcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'RandBaxAcqFunction'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.RandBaxAcqFunction.__call__": [[543, 548], ["acquisition.BaxAcqFunction.__call__", "numpy.random.uniform"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.__call__"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "acq_list", "=", "super", "(", ")", ".", "__call__", "(", "x_list", ")", "# NOTE: would super()(x_list) work?", "\n", "acq_list", "=", "[", "np", ".", "random", ".", "uniform", "(", ")", "for", "_", "in", "acq_list", "]", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.UsBaxAcqFunction.set_params": [[556, 562], ["acquisition.BaxAcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'UsBaxAcqFunction'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.UsBaxAcqFunction.__call__": [[563, 568], ["acquisition.BaxAcqFunction.__call__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.__call__"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "super", "(", ")", ".", "__call__", "(", "x_list", ")", "# NOTE: would super()(x_list) work?", "\n", "acq_list", "=", "self", ".", "acq_vars", "[", "\"std\"", "]", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.EigfBaxAcqFunction.set_params": [[576, 582], ["acquisition.BaxAcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'EigfBaxAcqFunction'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.EigfBaxAcqFunction.__call__": [[583, 589], ["acquisition.BaxAcqFunction.__call__", "acquisition.EigfBaxAcqFunction.entropy_given_normal_std"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.__call__", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "super", "(", ")", ".", "__call__", "(", "x_list", ")", "# NOTE: would super()(x_list) work?", "\n", "std_list", "=", "self", ".", "acq_vars", "[", "\"std\"", "]", "\n", "acq_list", "=", "self", ".", "entropy_given_normal_std", "(", "std_list", ")", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.set_params": [[596, 602], ["acquisition.AlgoAcqFunction.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqFunction.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'MultiBaxAcqFunction'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std": [[603, 607], ["numpy.log", "numpy.log", "numpy.sqrt"], "methods", ["None"], ["", "def", "entropy_given_normal_std", "(", "self", ",", "std_arr", ")", ":", "\n", "        ", "\"\"\"Return entropy given an array of 1D normal standard deviations.\"\"\"", "\n", "entropy", "=", "np", ".", "log", "(", "std_arr", ")", "+", "np", ".", "log", "(", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", ")", "+", "0.5", "\n", "return", "entropy", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std_list": [[608, 618], ["numpy.sum", "acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std"], ["", "def", "entropy_given_normal_std_list", "(", "self", ",", "std_arr_list", ")", ":", "\n", "        ", "\"\"\"\n        Return entropy given a list of arrays, where each is an array of 1D normal\n        standard deviations.\n        \"\"\"", "\n", "entropy_list", "=", "[", "\n", "self", ".", "entropy_given_normal_std", "(", "std_arr", ")", "for", "std_arr", "in", "std_arr_list", "\n", "]", "\n", "entropy", "=", "np", ".", "sum", "(", "entropy_list", ",", "0", ")", "\n", "return", "entropy", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.acq_exe_normal": [[619, 637], ["acquisition.MultiBaxAcqFunction.entropy_given_normal_std_list", "numpy.mean", "acquisition.MultiBaxAcqFunction.entropy_given_normal_std_list", "h_samp_list.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.entropy_given_normal_std_list"], ["", "def", "acq_exe_normal", "(", "self", ",", "post_stds", ",", "samp_stds_list", ")", ":", "\n", "        ", "\"\"\"\n        Execution-path-based acquisition function: EIG on the execution path, via\n        predictive entropy, for normal posterior predictive distributions.\n        \"\"\"", "\n", "\n", "# Compute entropies for posterior predictive", "\n", "h_post", "=", "self", ".", "entropy_given_normal_std_list", "(", "post_stds", ")", "\n", "\n", "# Compute entropies for posterior predictive given execution path samples", "\n", "h_samp_list", "=", "[", "]", "\n", "for", "samp_stds", "in", "samp_stds_list", ":", "\n", "            ", "h_samp", "=", "self", ".", "entropy_given_normal_std_list", "(", "samp_stds", ")", "\n", "h_samp_list", ".", "append", "(", "h_samp", ")", "\n", "\n", "", "avg_h_samp", "=", "np", ".", "mean", "(", "h_samp_list", ",", "0", ")", "\n", "acq_exe", "=", "h_post", "-", "avg_h_samp", "\n", "return", "acq_exe", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.get_acq_list_batch": [[638, 679], ["util.timing.Timer", "acquisition.MultiBaxAcqFunction.model.get_post_mu_cov", "isinstance", "isinstance", "acquisition.MultiBaxAcqFunction.acq_exe_normal", "argparse.Namespace", "acquisition.MultiBaxAcqFunction.model.gp_post_wrapper", "mus_list.append", "stds_list.append", "len"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.get_post_mu_cov", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.acq_exe_normal", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper"], ["", "def", "get_acq_list_batch", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Return acquisition function for a batch of inputs x_list.\"\"\"", "\n", "\n", "# Compute posterior, and post given each execution path sample, for x_list", "\n", "with", "Timer", "(", "f\"Compute acquisition function for a batch of {len(x_list)} points\"", ")", ":", "\n", "# NOTE: self.model is multimodel so the following returns a list of mus and", "\n", "# a list of stds", "\n", "            ", "mus", ",", "stds", "=", "self", ".", "model", ".", "get_post_mu_cov", "(", "x_list", ",", "full_cov", "=", "False", ")", "\n", "assert", "isinstance", "(", "mus", ",", "list", ")", "\n", "assert", "isinstance", "(", "stds", ",", "list", ")", "\n", "\n", "# Compute mean and std arrays for posterior given execution path samples", "\n", "mus_list", "=", "[", "]", "\n", "stds_list", "=", "[", "]", "\n", "for", "exe_path", "in", "self", ".", "exe_path_list", ":", "\n", "                ", "comb_data", "=", "Namespace", "(", ")", "\n", "comb_data", ".", "x", "=", "self", ".", "model", ".", "data", ".", "x", "+", "exe_path", ".", "x", "\n", "comb_data", ".", "y", "=", "self", ".", "model", ".", "data", ".", "y", "+", "exe_path", ".", "y", "\n", "\n", "# NOTE: self.model is multimodel so the following returns a list of mus", "\n", "# and a list of stds", "\n", "samp_mus", ",", "samp_stds", "=", "self", ".", "model", ".", "gp_post_wrapper", "(", "\n", "x_list", ",", "comb_data", ",", "full_cov", "=", "False", "\n", ")", "\n", "mus_list", ".", "append", "(", "samp_mus", ")", "\n", "stds_list", ".", "append", "(", "samp_stds", ")", "\n", "\n", "# Compute acq_list, the acqfunction value for each x in x_list", "\n", "", "acq_list", "=", "self", ".", "acq_exe_normal", "(", "stds", ",", "stds_list", ")", "\n", "\n", "# Package and store acq_vars", "\n", "", "self", ".", "acq_vars", "=", "{", "\n", "\"mus\"", ":", "mus", ",", "\n", "\"stds\"", ":", "stds", ",", "\n", "\"mus_list\"", ":", "mus_list", ",", "\n", "\"stds_list\"", ":", "stds_list", ",", "\n", "\"acq_list\"", ":", "acq_list", ",", "\n", "}", "\n", "\n", "# Return list of acquisition function on x in x_list", "\n", "return", "acq_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.__call__": [[680, 684], ["acquisition.MultiBaxAcqFunction.get_acq_list_batch"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.acquisition.MultiBaxAcqFunction.get_acq_list_batch"], ["", "def", "__call__", "(", "self", ",", "x_list", ")", ":", "\n", "        ", "\"\"\"Class is callable and returns acquisition function on x_list.\"\"\"", "\n", "acq_list", "=", "self", ".", "get_acq_list_batch", "(", "x_list", ")", "\n", "return", "acq_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.__init__": [[21, 37], ["util.base.Base.__init__", "matplotlib.subplots"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for the AcqOptimizer.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "self", ".", "params", ".", "figsize", ")", "\n", "self", ".", "fig", "=", "fig", "\n", "self", ".", "ax", "=", "ax", "\n", "self", ".", "h_list", "=", "[", "]", "\n", "self", ".", "clist", "=", "rcParams", "[", "'axes.prop_cycle'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.set_params": [[38, 49], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqOptimizer.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"AcqViz1D\"", ")", "\n", "self", ".", "params", ".", "figsize", "=", "getattr", "(", "params", ",", "\"figsize\"", ",", "(", "8", ",", "4", ")", ")", "\n", "self", ".", "params", ".", "n_path_max", "=", "getattr", "(", "params", ",", "\"n_path_max\"", ",", "None", ")", "\n", "self", ".", "params", ".", "xlabel", "=", "getattr", "(", "params", ",", "\"xlabel\"", ",", "\"x\"", ")", "\n", "self", ".", "params", ".", "ylabel", "=", "getattr", "(", "params", ",", "\"ylabel\"", ",", "\"y\"", ")", "\n", "self", ".", "params", ".", "lims", "=", "getattr", "(", "params", ",", "\"lims\"", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqoptimizer_all": [[50, 84], ["visualize.AcqViz1D.plot_postpred", "visualize.AcqViz1D.plot_acqfunction", "visualize.AcqViz1D.plot_exe_path_samples", "visualize.AcqViz1D.plot_model_data", "visualize.AcqViz1D.plot_acqoptima", "visualize.AcqViz1D.plot_postpred_given_exe_path_samples", "visualize.AcqViz1D.plot_post_f_samples", "visualize.AcqViz1D.make_legend", "visualize.AcqViz1D.set_post_plot_details", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_postpred", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqfunction", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_exe_path_samples", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_model_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqoptima", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_postpred_given_exe_path_samples", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_post_f_samples", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.make_legend", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.set_post_plot_details"], ["", "def", "plot_acqoptimizer_all", "(", "\n", "self", ",", "\n", "model", ",", "\n", "exe_path_list", ",", "\n", "output_list", ",", "\n", "acq_list", ",", "\n", "x_test", ",", "\n", "mu", ",", "\n", "std", ",", "\n", "mu_list", ",", "\n", "std_list", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Visualize the acquisition function, optimization, and related details, for a 1D\n        continuous domain.\n        \"\"\"", "\n", "# Plot various details", "\n", "self", ".", "plot_postpred", "(", "x_test", ",", "mu", ",", "std", ")", "\n", "self", ".", "plot_acqfunction", "(", "x_test", ",", "acq_list", ")", "\n", "self", ".", "plot_exe_path_samples", "(", "exe_path_list", ")", "\n", "self", ".", "plot_model_data", "(", "model", ".", "data", ")", "\n", "self", ".", "plot_acqoptima", "(", "acq_list", ",", "x_test", ")", "\n", "self", ".", "plot_postpred_given_exe_path_samples", "(", "x_test", ",", "mu_list", ",", "std_list", ")", "\n", "self", ".", "plot_post_f_samples", "(", "model", ",", "x_test", ",", "exe_path_list", ")", "\n", "\n", "self", ".", "make_legend", "(", ")", "\n", "self", ".", "set_post_plot_details", "(", ")", "\n", "\n", "if", "getattr", "(", "self", ",", "\"acqfunction_shown\"", ",", "False", ")", ":", "\n", "            ", "ax_tup", "=", "(", "self", ".", "ax", ",", "self", ".", "ax_acq", ")", "\n", "", "else", ":", "\n", "            ", "ax_tup", "=", "(", "self", ".", "ax", ",", ")", "\n", "\n", "", "return", "ax_tup", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_postpred": [[85, 101], ["visualize.AcqViz1D.ax.fill_between", "visualize.AcqViz1D.h_list.append", "numpy.array().reshape", "numpy.array"], "methods", ["None"], ["", "def", "plot_postpred", "(", "self", ",", "x_test", ",", "mu", ",", "std", ",", "noise", "=", "0.0", ")", ":", "\n", "        ", "\"\"\"Plot posterior predictive distribution.\"\"\"", "\n", "std", "=", "std", "+", "noise", "\n", "lcb", "=", "mu", "-", "3", "*", "std", "\n", "ucb", "=", "mu", "+", "3", "*", "std", "\n", "h", "=", "self", ".", "ax", ".", "fill_between", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "lcb", ",", "\n", "ucb", ",", "\n", "color", "=", "(", "1.0", ",", "0.9255", ",", "0.7961", ",", "1.0", ")", ",", "\n", "#color=\"orange\",", "\n", "#alpha=0.18,", "\n", "label", "=", "\"$p(y|\\mathcal{D}_t, x)$\"", ",", "\n", ")", "\n", "self", ".", "h_list", ".", "append", "(", "h", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_exe_path_crop_samples": [[102, 126], ["visualize.AcqViz1D.reduce_samp_list", "itertools.cycle", "visualize.AcqViz1D.h_list.append", "visualize.AcqViz1D.ax.plot"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list"], ["", "def", "plot_exe_path_crop_samples", "(", "self", ",", "exe_path_list", ")", ":", "\n", "        ", "\"\"\"Plot execution path samples.\"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "exe_path_list", "=", "self", ".", "reduce_samp_list", "(", "exe_path_list", ")", "\n", "\n", "# Reset color cycle", "\n", "cgen", "=", "itertools", ".", "cycle", "(", "self", ".", "clist", ")", "\n", "\n", "for", "exe_path", "in", "exe_path_list", ":", "\n", "            ", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "exe_path", ".", "x", ",", "\n", "exe_path", ".", "y", ",", "\n", "\"x\"", ",", "\n", "#color=next(cgen)['color'],", "\n", "#color=\"#d62728\",", "\n", "#color=\"deeppink\",", "\n", "color", "=", "\"magenta\"", ",", "\n", "markersize", "=", "10", ",", "\n", "linewidth", "=", "0.1", ",", "\n", "label", "=", "\"$\\{ \\\\tilde{O}_\\mathcal{A}^j \\} \\sim p(O_\\mathcal{A}(f) | \\mathcal{D}_t)$\"", ",", "\n", ")", "\n", "", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_exe_path_samples": [[127, 149], ["visualize.AcqViz1D.reduce_samp_list", "itertools.cycle", "visualize.AcqViz1D.h_list.append", "visualize.AcqViz1D.ax.plot"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list"], ["", "def", "plot_exe_path_samples", "(", "self", ",", "exe_path_list", ")", ":", "\n", "        ", "\"\"\"Plot execution path samples.\"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "exe_path_list", "=", "self", ".", "reduce_samp_list", "(", "exe_path_list", ")", "\n", "\n", "# Reset color cycle", "\n", "cgen", "=", "itertools", ".", "cycle", "(", "self", ".", "clist", ")", "\n", "\n", "for", "exe_path", "in", "exe_path_list", ":", "\n", "            ", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "exe_path", ".", "x", ",", "\n", "exe_path", ".", "y", ",", "\n", "\".\"", ",", "\n", "#color=next(cgen)['color'],", "\n", "color", "=", "\"#d62728\"", ",", "\n", "markersize", "=", "3", ",", "\n", "linewidth", "=", "0.5", ",", "\n", "label", "=", "\"$\\{ \\\\tilde{e}_\\mathcal{A}^j \\} \\sim p(e_\\mathcal{A}(f) | \\mathcal{D}_t)$\"", ",", "\n", ")", "\n", "", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_model_data": [[150, 158], ["visualize.AcqViz1D.ax.plot", "visualize.AcqViz1D.h_list.append"], "methods", ["None"], ["", "def", "plot_model_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Plot data, assumed to have attributes x and y.\"\"\"", "\n", "label", "=", "\"$\\mathcal{D}_t = \\{(x_i, y_i)\\}_{i=1}^t$\"", "\n", "#label = \"Observations\"", "\n", "#h = self.ax.plot(data.x, data.y, \"o\", color=\"deeppink\", label=label)", "\n", "h", "=", "self", ".", "ax", ".", "plot", "(", "data", ".", "x", ",", "data", ".", "y", ",", "\"o\"", ",", "color", "=", "\"black\"", ",", "label", "=", "label", ")", "\n", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqfunction": [[159, 209], ["visualize.AcqViz1D.fig.get_figheight", "visualize.AcqViz1D.fig.set_figheight", "visualize.AcqViz1D.ax.set_position", "visualize.AcqViz1D.fig.add_subplot", "visualize.AcqViz1D.ax_acq.set_position", "numpy.array", "visualize.AcqViz1D.ax_acq.plot", "visualize.AcqViz1D.h_list.append", "visualize.AcqViz1D.ax.get_position", "visualize.AcqViz1D.ax_acq.get_position", "numpy.array().reshape", "numpy.array"], "methods", ["None"], ["", "def", "plot_acqfunction", "(", "self", ",", "x_test", ",", "acq_list", ")", ":", "\n", "        ", "\"\"\"Plot acquisition function as new subplot Axes.\"\"\"", "\n", "self", ".", "acqfunction_shown", "=", "True", "\n", "\n", "# Update fig size", "\n", "fig_height", "=", "self", ".", "fig", ".", "get_figheight", "(", ")", "\n", "add_height", "=", "1.0", "\n", "self", ".", "fig", ".", "set_figheight", "(", "fig_height", "+", "add_height", ")", "\n", "\n", "# Shift current axes up, re-adjust height", "\n", "l", ",", "b", ",", "w", ",", "h", "=", "self", ".", "ax", ".", "get_position", "(", ")", ".", "bounds", "\n", "# -----", "\n", "#print('ax current bounds:')", "\n", "#print([l, b, w, h])", "\n", "# -----", "\n", "h_ratio", "=", "fig_height", "/", "(", "fig_height", "+", "add_height", ")", "\n", "new_h", "=", "h", "*", "h_ratio", "\n", "new_b", "=", "b", "+", "h", "-", "new_h", "\n", "self", ".", "ax", ".", "set_position", "(", "[", "l", ",", "new_b", ",", "w", ",", "new_h", "]", ")", "\n", "\n", "# Add subplot for acqfunction plot", "\n", "self", ".", "ax_acq", "=", "self", ".", "fig", ".", "add_subplot", "(", "2", ",", "1", ",", "(", "1", ",", "2", ")", ")", "\n", "\n", "# Adjust self.ax_acq", "\n", "l", ",", "b", ",", "w", ",", "h", "=", "self", ".", "ax_acq", ".", "get_position", "(", ")", ".", "bounds", "\n", "# -----", "\n", "#print('ax_acq current bounds:')", "\n", "#print([l, b, w, h])", "\n", "# -----", "\n", "gap_in", "=", "0.15", "# for 0.15 inch gap", "\n", "gap", "=", "h", "*", "gap_in", "/", "(", "fig_height", "+", "add_height", ")", "\n", "\n", "new_h_no_gap", "=", "h", "*", "add_height", "/", "(", "fig_height", "+", "add_height", ")", "\n", "new_h", "=", "new_h_no_gap", "-", "gap", "\n", "\n", "self", ".", "ax_acq", ".", "set_position", "(", "[", "l", ",", "b", ",", "w", ",", "new_h", "]", ")", "\n", "\n", "acq_arr", "=", "np", ".", "array", "(", "acq_list", ")", "\n", "h", "=", "self", ".", "ax_acq", ".", "plot", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "acq_arr", ",", "\n", "\"--\"", ",", "\n", "color", "=", "\"#ff7f0e\"", ",", "\n", "#color=\"red\",", "\n", "linewidth", "=", "1", ",", "\n", "label", "=", "\"$\\\\alpha_t(x)$\"", ",", "\n", ")", "\n", "\n", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqoptima": [[210, 232], ["visualize.AcqViz1D.ax_acq.get_ylim", "visualize.AcqViz1D.ax.plot", "visualize.AcqViz1D.ax_acq.plot", "visualize.AcqViz1D.h_list.append", "visualize.AcqViz1D.ax.get_ylim", "numpy.argmax"], "methods", ["None"], ["", "def", "plot_acqoptima", "(", "self", ",", "acq_list", ",", "x_test", ")", ":", "\n", "        ", "\"\"\"Plot optima of acquisition function.\"\"\"", "\n", "acq_opt", "=", "x_test", "[", "np", ".", "argmax", "(", "acq_list", ")", "]", "\n", "\n", "# Set ylims for vertical lines", "\n", "if", "self", ".", "params", ".", "lims", ":", "\n", "            ", "ylim_ax", "=", "self", ".", "params", ".", "lims", "[", "2", ":", "]", "\n", "", "else", ":", "\n", "            ", "ylim_ax", "=", "self", ".", "ax", ".", "get_ylim", "(", ")", "\n", "", "ylim_ax_acq", "=", "self", ".", "ax_acq", ".", "get_ylim", "(", ")", "\n", "\n", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "[", "acq_opt", ",", "acq_opt", "]", ",", "\n", "ylim_ax", ",", "\n", "'--'", ",", "\n", "color", "=", "\"black\"", ",", "\n", "label", "=", "\"$x_t = $ argmax$_{x \\in \\mathcal{X}}$ $\\\\alpha_t(x)$\"", ",", "\n", ")", "\n", "self", ".", "ax_acq", ".", "plot", "(", "[", "acq_opt", ",", "acq_opt", "]", ",", "ylim_ax_acq", ",", "'--'", ",", "color", "=", "\"black\"", ")", "\n", "\n", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_postpred_given_exe_path_samples": [[233, 253], ["visualize.AcqViz1D.reduce_samp_list", "visualize.AcqViz1D.reduce_samp_list", "zip", "visualize.AcqViz1D.h_list.append", "visualize.AcqViz1D.ax.fill_between", "numpy.array().reshape", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list"], ["", "def", "plot_postpred_given_exe_path_samples", "(", "self", ",", "x_test", ",", "mu_list", ",", "std_list", ")", ":", "\n", "        ", "\"\"\"Plot posterior predictive given execution path sample, for each sample.\"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "mu_list", "=", "self", ".", "reduce_samp_list", "(", "mu_list", ")", "\n", "std_list", "=", "self", ".", "reduce_samp_list", "(", "std_list", ")", "\n", "\n", "for", "mu_samp", ",", "std_samp", "in", "zip", "(", "mu_list", ",", "std_list", ")", ":", "\n", "            ", "lcb", "=", "mu_samp", "-", "3", "*", "std_samp", "\n", "ucb", "=", "mu_samp", "+", "3", "*", "std_samp", "\n", "h", "=", "self", ".", "ax", ".", "fill_between", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "lcb", ",", "\n", "ucb", ",", "\n", "color", "=", "\"blue\"", ",", "\n", "alpha", "=", "0.05", ",", "\n", "label", "=", "\"$p(y|\\mathcal{D}_t, \\\\tilde{e}_\\mathcal{A}^j, x)$\"", ",", "\n", ")", "\n", "", "self", ".", "h_list", ".", "append", "(", "h", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_post_f_samples": [[254, 284], ["visualize.AcqViz1D.reduce_samp_list", "itertools.cycle", "argparse.Namespace", "model.gp_post_wrapper", "model.get_normal_samples", "numpy.array().reshape", "visualize.AcqViz1D.ax.plot", "numpy.array().reshape", "numpy.array", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.gp_post_wrapper", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.simple_gp.SimpleGp.get_normal_samples"], ["", "def", "plot_post_f_samples", "(", "self", ",", "model", ",", "x_test", ",", "exe_path_list", ")", ":", "\n", "        ", "\"\"\"Compute and then plot posterior function samples.\"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "exe_path_list", "=", "self", ".", "reduce_samp_list", "(", "exe_path_list", ")", "\n", "\n", "# Reset color cycle", "\n", "cgen", "=", "itertools", ".", "cycle", "(", "self", ".", "clist", ")", "\n", "\n", "for", "exe_path", "in", "exe_path_list", ":", "\n", "            ", "comb_data", "=", "Namespace", "(", ")", "\n", "comb_data", ".", "x", "=", "model", ".", "data", ".", "x", "+", "exe_path", ".", "x", "\n", "comb_data", ".", "y", "=", "model", ".", "data", ".", "y", "+", "exe_path", ".", "y", "\n", "mu", ",", "cov", "=", "model", ".", "gp_post_wrapper", "(", "x_test", ",", "comb_data", ",", "full_cov", "=", "True", ")", "\n", "f_sample", "=", "model", ".", "get_normal_samples", "(", "mu", ",", "cov", ",", "1", ",", "full_cov", "=", "True", ")", "\n", "f_sample", "=", "np", ".", "array", "(", "f_sample", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "f_sample", ",", "\n", "\"-\"", ",", "\n", "#color=next(cgen)['color'],", "\n", "color", "=", "\"#d62728\"", ",", "\n", "alpha", "=", "0.5", ",", "\n", "linewidth", "=", "0.5", ",", "\n", "label", "=", "\"$\\{\\\\tilde{f}\\} \\sim p(f | \\mathcal{D}_t)$\"", ",", "\n", ")", "\n", "\n", "#self.h_list.append(h[0])", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_post_f_samples_exe_path_postpred_means": [[285, 306], ["visualize.AcqViz1D.reduce_samp_list", "visualize.AcqViz1D.ax.plot", "numpy.array().reshape", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list"], ["", "def", "plot_post_f_samples_exe_path_postpred_means", "(", "self", ",", "x_test", ",", "mu_list", ")", ":", "\n", "        ", "\"\"\"\n        Plot execution path posterior predictive means as approximate posterior function\n        samples.\n        \"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "mu_list", "=", "self", ".", "reduce_samp_list", "(", "mu_list", ")", "\n", "\n", "# TODO: consider whether following are true posterior samples.", "\n", "for", "mu_samp", "in", "mu_list", ":", "\n", "            ", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "mu_samp", ",", "\n", "\"-\"", ",", "\n", "alpha", "=", "0.5", ",", "\n", "linewidth", "=", "0.5", ",", "\n", "label", "=", "\"$\\{\\\\tilde{f}\\} \\sim p(f | \\mathcal{D}_t)$\"", ",", "\n", ")", "\n", "#self.h_list.append(h[0])", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acq_out_cluster": [[307, 343], ["visualize.AcqViz1D.plot_postpred", "visualize.AcqViz1D.plot_clusters", "visualize.AcqViz1D.plot_acqfunction", "visualize.AcqViz1D.plot_model_data", "visualize.AcqViz1D.plot_acqoptima", "visualize.AcqViz1D.make_legend"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_postpred", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_clusters", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqfunction", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_model_data", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_acqoptima", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.make_legend"], ["", "def", "plot_acq_out_cluster", "(", "\n", "self", ",", "\n", "model", ",", "\n", "exe_path_list", ",", "\n", "output_list", ",", "\n", "acq_list", ",", "\n", "x_test", ",", "\n", "mu", ",", "\n", "std", ",", "\n", "mu_list", ",", "\n", "std_list", ",", "\n", "cluster_idx_list", ",", "\n", "mean_cluster_list", ",", "\n", "std_cluster_list", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Visualize the acquisition function, optimization, and related details, for a 1D\n        continuous domain.\n        \"\"\"", "\n", "# Plot various details", "\n", "h1", "=", "self", ".", "plot_postpred", "(", "x_test", ",", "mu", ",", "std", ")", "\n", "h2", "=", "self", ".", "plot_clusters", "(", "\n", "x_test", ",", "\n", "cluster_idx_list", ",", "\n", "mean_cluster_list", ",", "\n", "std_cluster_list", ",", "\n", "output_list", ",", "\n", "exe_path_list", ",", "\n", ")", "\n", "h3", "=", "self", ".", "plot_acqfunction", "(", "x_test", ",", "acq_list", ")", "\n", "h4", "=", "self", ".", "plot_model_data", "(", "model", ".", "data", ")", "\n", "h5", "=", "self", ".", "plot_acqoptima", "(", "acq_list", ",", "x_test", ")", "\n", "\n", "## Legend", "\n", "h_list", "=", "[", "h4", "[", "0", "]", ",", "h1", ",", "h2", "[", "0", "]", ",", "h5", "[", "0", "]", ",", "h3", "[", "0", "]", "]", "\n", "self", ".", "make_legend", "(", "h_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_clusters": [[344, 376], ["itertools.cycle", "zip", "visualize.AcqViz1D.plot_cluster_exe_paths", "visualize.AcqViz1D.plot_cluster_means", "visualize.AcqViz1D.plot_cluster_property", "next"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_exe_paths", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_means", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_property"], ["", "def", "plot_clusters", "(", "\n", "self", ",", "\n", "x_test", ",", "\n", "cluster_idx_list", ",", "\n", "mean_cluster_list", ",", "\n", "std_cluster_list", ",", "\n", "output_list", ",", "\n", "exe_path_list", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Plot clusters of execution paths.\"\"\"", "\n", "\n", "# Reset color cycle", "\n", "cgen", "=", "itertools", ".", "cycle", "(", "self", ".", "clist", ")", "\n", "\n", "# Loop through clusters", "\n", "mean_std_idx_list", "=", "zip", "(", "mean_cluster_list", ",", "std_cluster_list", ",", "cluster_idx_list", ")", "\n", "for", "mean_cluster", ",", "std_cluster", ",", "cluster_idx", "in", "mean_std_idx_list", ":", "\n", "            ", "nextcolor", "=", "next", "(", "cgen", ")", "[", "'color'", "]", "\n", "\n", "# Plot execution paths in each cluster", "\n", "self", ".", "plot_cluster_exe_paths", "(", "cluster_idx", ",", "exe_path_list", ",", "nextcolor", ")", "\n", "\n", "# Plot means of each cluster", "\n", "h", "=", "self", ".", "plot_cluster_means", "(", "x_test", ",", "mean_cluster", ",", "cluster_idx", ",", "nextcolor", ")", "\n", "\n", "# Plot stds of each cluster", "\n", "#self.plot_cluster_stds(x_test, mean_cluster, std_cluster, nextcolor)", "\n", "\n", "# Plot cluster properties", "\n", "self", ".", "plot_cluster_property", "(", "cluster_idx", ",", "output_list", ",", "nextcolor", ")", "\n", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_exe_paths": [[377, 391], ["numpy.random.uniform", "matplotlib.plot", "numpy.array"], "methods", ["None"], ["", "def", "plot_cluster_exe_paths", "(", "self", ",", "cluster_idx", ",", "exe_path_list", ",", "color", ")", ":", "\n", "        ", "\"\"\"Plot execution paths for samples in each cluster.\"\"\"", "\n", "exe_path_subset", "=", "[", "exe_path_list", "[", "i", "]", "for", "i", "in", "cluster_idx", "]", "\n", "x_offset", "=", "np", ".", "random", ".", "uniform", "(", "-", "0.1", ",", "0.1", ")", "\n", "for", "exe_path", "in", "exe_path_subset", ":", "\n", "            ", "h", "=", "plt", ".", "plot", "(", "\n", "np", ".", "array", "(", "exe_path", ".", "x", ")", "+", "x_offset", ",", "\n", "exe_path", ".", "y", ",", "\n", "\".\"", ",", "\n", "color", "=", "color", ",", "\n", "markersize", "=", "4", ",", "\n", "linewidth", "=", "0.5", ",", "\n", ")", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_means": [[392, 404], ["matplotlib.plot", "numpy.array().reshape", "numpy.array", "numpy.log", "len"], "methods", ["None"], ["", "def", "plot_cluster_means", "(", "self", ",", "x_test", ",", "mean_cluster", ",", "cluster_idx", ",", "color", ")", ":", "\n", "        ", "\"\"\"Plot mean of sampled functions for each cluster.\"\"\"", "\n", "h", "=", "plt", ".", "plot", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "mean_cluster", ",", "\n", "'--'", ",", "\n", "#linewidth=0.05 * len(cluster_idx),", "\n", "linewidth", "=", "np", ".", "log", "(", "len", "(", "cluster_idx", ")", ")", "+", "0.5", ",", "\n", "color", "=", "color", ",", "\n", "label", "=", "\"Cluster posterior predictive\"", ",", "\n", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_stds": [[405, 418], ["matplotlib.fill_between", "numpy.array().reshape", "numpy.array"], "methods", ["None"], ["", "def", "plot_cluster_stds", "(", "self", ",", "x_test", ",", "mean_cluster", ",", "std_cluster", ",", "color", ")", ":", "\n", "        ", "\"\"\"Plot std of sampled functions for each cluster.\"\"\"", "\n", "lcb", "=", "mean_cluster", "-", "3", "*", "std_cluster", "\n", "ucb", "=", "mean_cluster", "+", "3", "*", "std_cluster", "\n", "h", "=", "plt", ".", "fill_between", "(", "\n", "np", ".", "array", "(", "x_test", ")", ".", "reshape", "(", "-", "1", ")", ",", "\n", "lcb", ",", "\n", "ucb", ",", "\n", "alpha", "=", "0.1", ",", "\n", "color", "=", "color", ",", "\n", "label", "=", "\"Cluster posterior predictive\"", ",", "\n", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.plot_cluster_property": [[419, 432], ["numpy.random.uniform", "matplotlib.plot"], "methods", ["None"], ["", "def", "plot_cluster_property", "(", "self", ",", "cluster_idx", ",", "output_list", ",", "color", ")", ":", "\n", "        ", "\"\"\"Plot property of interest for samples in each cluster.\"\"\"", "\n", "output_subset", "=", "[", "output_list", "[", "i", "]", "for", "i", "in", "cluster_idx", "]", "\n", "for", "output", "in", "output_subset", ":", "\n", "            ", "y_offset", "=", "np", ".", "random", ".", "uniform", "(", "-", "0.2", ",", "0.2", ")", "\n", "h", "=", "plt", ".", "plot", "(", "\n", "output", ",", "\n", "5.0", "+", "y_offset", ",", "\n", "'o'", ",", "\n", "color", "=", "color", ",", "\n", "label", "=", "\"argmax output\"", "\n", ")", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.make_legend": [[433, 474], ["visualize.AcqViz1D.fig.get_figheight", "len", "visualize.AcqViz1D.ax.legend", "visualize.AcqViz1D.ax.get_position"], "methods", ["None"], ["", "def", "make_legend", "(", "self", ")", ":", "\n", "        ", "\"\"\"Make the legend.\"\"\"", "\n", "\n", "fig_height", "=", "self", ".", "fig", ".", "get_figheight", "(", ")", "\n", "l", ",", "b", ",", "w", ",", "h", "=", "self", ".", "ax", ".", "get_position", "(", ")", ".", "bounds", "\n", "#print('legend: ax current bounds:')", "\n", "#print([l, b, w, h])", "\n", "\n", "#gap_in = 1.0", "\n", "#gap = h  * gap_in / fig_height", "\n", "#gap = gap_in * fig_height", "\n", "#gap = gap_in * h / fig_height", "\n", "#gap = 0.125 + b - 0.27", "\n", "#print(f'GAP IS: {gap}')", "\n", "\n", "n_leg", "=", "len", "(", "self", ".", "h_list", ")", "\n", "n_col", "=", "3", "\n", "n_row", "=", "1", "if", "n_leg", "<=", "n_col", "else", "2", "\n", "#bot = 0.15 if n_row == 1 else 0.21", "\n", "#bot = gap if n_row == 1 else gap", "\n", "\n", "# For legend above axes", "\n", "#bot = 0.0", "\n", "#bot = 0.1 * h", "\n", "#bot = 0.1 / (h - b)", "\n", "#bbta = (0, bot, 1, 1)", "\n", "bbta", "=", "(", "0", ",", "0.25", ",", "1", ",", "1", ")", "\n", "#h_new = 0.1 * h + 0.05", "\n", "#bbta = (0, 1.0, 1, h_new)", "\n", "\n", "loc", "=", "\"upper center\"", "\n", "\n", "# Draw legend", "\n", "leg", "=", "self", ".", "ax", ".", "legend", "(", "\n", "handles", "=", "self", ".", "h_list", ",", "\n", "loc", "=", "loc", ",", "\n", "bbox_to_anchor", "=", "bbta", ",", "\n", "ncol", "=", "n_col", ",", "\n", "mode", "=", "\"expand\"", ",", "\n", ")", "\n", "return", "leg", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.set_post_plot_details": [[475, 496], ["getattr", "getattr", "visualize.AcqViz1D.ax.set_ylabel", "visualize.AcqViz1D.ax_acq.set_xlabel", "visualize.AcqViz1D.ax.get_xaxis().set_visible", "visualize.AcqViz1D.ax.set_xlabel", "visualize.AcqViz1D.ax_acq.get_yaxis().set_visible", "visualize.AcqViz1D.ax.set_xlim", "visualize.AcqViz1D.ax_acq.set_xlim", "visualize.AcqViz1D.ax.set_ylim", "visualize.AcqViz1D.ax.get_xaxis", "visualize.AcqViz1D.ax_acq.get_yaxis"], "methods", ["None"], ["", "def", "set_post_plot_details", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set post plot details.\"\"\"", "\n", "# x axis", "\n", "if", "getattr", "(", "self", ",", "\"acqfunction_shown\"", ",", "False", ")", ":", "\n", "            ", "self", ".", "ax_acq", ".", "set_xlabel", "(", "self", ".", "params", ".", "xlabel", ")", "\n", "#self.ax.get_xaxis().set_ticklabels([])", "\n", "self", ".", "ax", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "ax", ".", "set_xlabel", "(", "self", ".", "params", ".", "xlabel", ")", "\n", "\n", "# y axis", "\n", "", "if", "getattr", "(", "self", ",", "\"acqfunction_shown\"", ",", "False", ")", ":", "\n", "#self.ax_acq.get_yaxis().set_ticklabels([])", "\n", "            ", "self", ".", "ax_acq", ".", "get_yaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "", "self", ".", "ax", ".", "set_ylabel", "(", "self", ".", "params", ".", "ylabel", ")", "\n", "\n", "# lims", "\n", "if", "self", ".", "params", ".", "lims", ":", "\n", "            ", "self", ".", "ax", ".", "set_xlim", "(", "self", ".", "params", ".", "lims", "[", "0", "]", ",", "self", ".", "params", ".", "lims", "[", "1", "]", ")", "\n", "self", ".", "ax_acq", ".", "set_xlim", "(", "self", ".", "params", ".", "lims", "[", "0", "]", ",", "self", ".", "params", ".", "lims", "[", "1", "]", ")", "\n", "self", ".", "ax", ".", "set_ylim", "(", "self", ".", "params", ".", "lims", "[", "2", "]", ",", "self", ".", "params", ".", "lims", "[", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize.AcqViz1D.reduce_samp_list": [[497, 503], ["None"], "methods", ["None"], ["", "", "def", "reduce_samp_list", "(", "self", ",", "samp_list", ")", ":", "\n", "        ", "\"\"\"Optionally reduce list of samples, based on self.n_path_max.\"\"\"", "\n", "if", "self", ".", "params", ".", "n_path_max", ":", "\n", "            ", "samp_list", "=", "samp_list", "[", ":", "self", ".", "params", ".", "n_path_max", "]", "\n", "\n", "", "return", "samp_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.__init__": [[22, 44], ["util.base.Base.__init__", "matplotlib.subplots", "matplotlib.subplots"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["def", "__init__", "(", "self", ",", "params", "=", "None", ",", "fig_ax", "=", "None", ",", "verbose", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for the AcqOptimizer.\n        fig_ax : tuple\n            Tuple containing the pair (fig, ax)\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "\n", "if", "fig_ax", "is", "None", ":", "\n", "            ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "figsize", "=", "self", ".", "params", ".", "figsize", ")", "\n", "", "else", ":", "\n", "            ", "fig", "=", "fig_ax", "[", "0", "]", "\n", "ax", "=", "fig_ax", "[", "1", "]", "\n", "\n", "", "self", ".", "fig", "=", "fig", "\n", "self", ".", "ax", "=", "ax", "\n", "self", ".", "h_list", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.set_params": [[45, 56], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the AcqOptimizer.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"AcqViz2D\"", ")", "\n", "self", ".", "params", ".", "figsize", "=", "getattr", "(", "params", ",", "\"figsize\"", ",", "(", "6", ",", "6", ")", ")", "\n", "self", ".", "params", ".", "n_path_max", "=", "getattr", "(", "params", ",", "\"n_path_max\"", ",", "None", ")", "\n", "self", ".", "params", ".", "xlabel", "=", "getattr", "(", "params", ",", "\"xlabel\"", ",", "\"x\"", ")", "\n", "self", ".", "params", ".", "ylabel", "=", "getattr", "(", "params", ",", "\"ylabel\"", ",", "\"y\"", ")", "\n", "self", ".", "params", ".", "lims", "=", "getattr", "(", "params", ",", "\"lims\"", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_function_contour": [[57, 70], ["numpy.arange", "numpy.arange", "numpy.meshgrid", "f_vec", "visualize2d.AcqViz2D.ax.contour"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.topk.bax_simple_demo.f_vec"], ["", "def", "plot_function_contour", "(", "self", ",", "f_vec", ",", "domain", ",", "n_levels", "=", "100", ",", "grid", "=", "0.025", ")", ":", "\n", "        ", "\"\"\"Make contour plot, given np.vectorize'd function f_vec(X, Y).\"\"\"", "\n", "\n", "x", "=", "np", ".", "arange", "(", "domain", "[", "0", "]", "[", "0", "]", ",", "domain", "[", "0", "]", "[", "1", "]", ",", "grid", ")", "\n", "y", "=", "np", ".", "arange", "(", "domain", "[", "1", "]", "[", "0", "]", ",", "domain", "[", "1", "]", "[", "1", "]", ",", "grid", ")", "\n", "X", ",", "Y", "=", "np", ".", "meshgrid", "(", "x", ",", "y", ")", "\n", "Z", "=", "f_vec", "(", "X", ",", "Y", ")", "\n", "\n", "# For filled contours", "\n", "#cs = self.ax.contourf(X, Y, Z, n_levels, cmap=cm.Greens_r)", "\n", "\n", "# For contour lines", "\n", "cs", "=", "self", ".", "ax", ".", "contour", "(", "X", ",", "Y", ",", "Z", ",", "n_levels", ",", "cmap", "=", "cm", ".", "Greens_r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_output_samples": [[71, 92], ["visualize2d.AcqViz2D.reduce_samp_list", "visualize2d.AcqViz2D.h_list.append", "visualize2d.AcqViz2D.ax.plot"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list"], ["", "def", "plot_output_samples", "(", "self", ",", "output_list", ")", ":", "\n", "        ", "\"\"\"\n        Plot algorithm output samples. This method assumes an optimization algorithm\n        that returns 2d locations.\n        \"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "output_list", "=", "self", ".", "reduce_samp_list", "(", "output_list", ")", "\n", "\n", "for", "output", "in", "output_list", ":", "\n", "            ", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "output", "[", "0", "]", ",", "\n", "output", "[", "1", "]", ",", "\n", "\"o\"", ",", "\n", "color", "=", "\"darkviolet\"", ",", "\n", "markersize", "=", "7", ",", "\n", "alpha", "=", "0.5", ",", "\n", "label", "=", "\"$\\{ \\\\tilde{o}_\\mathcal{A}^j \\} \\sim  p(o_\\mathcal{A} | \\mathcal{D}_t)$\"", ",", "\n", ")", "\n", "", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_exe_path_samples": [[93, 121], ["visualize2d.AcqViz2D.reduce_samp_list", "visualize2d.AcqViz2D.h_list.append", "visualize2d.AcqViz2D.ax.plot", "visualize2d.AcqViz2D.ax.plot"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list"], ["", "def", "plot_exe_path_samples", "(", "self", ",", "exe_path_list", ")", ":", "\n", "        ", "\"\"\"\n        Plot execution path samples. This method assumes an optimization algorithm\n        computes a sequence of 2d points as an execution path.\n        \"\"\"", "\n", "\n", "# Optionally crop, given self.n_path_max", "\n", "exe_path_list", "=", "self", ".", "reduce_samp_list", "(", "exe_path_list", ")", "\n", "\n", "for", "exe_path", "in", "exe_path_list", ":", "\n", "            ", "self", ".", "ax", ".", "plot", "(", "\n", "[", "xi", "[", "0", "]", "for", "xi", "in", "exe_path", ".", "x", "]", ",", "\n", "[", "xi", "[", "1", "]", "for", "xi", "in", "exe_path", ".", "x", "]", ",", "\n", "\"-\"", ",", "\n", "color", "=", "\"blue\"", ",", "\n", "alpha", "=", "0.05", ",", "\n", ")", "\n", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "[", "xi", "[", "0", "]", "for", "xi", "in", "exe_path", ".", "x", "]", ",", "\n", "[", "xi", "[", "1", "]", "for", "xi", "in", "exe_path", ".", "x", "]", ",", "\n", "\".\"", ",", "\n", "color", "=", "\"blue\"", ",", "\n", "markersize", "=", "3", ",", "\n", "alpha", "=", "0.1", ",", "\n", "label", "=", "\"$\\{ \\\\tilde{e}_\\mathcal{A}^j \\} \\sim  p(e_\\mathcal{A} | \\mathcal{D}_t)$\"", ",", "\n", ")", "\n", "", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_model_data": [[122, 140], ["visualize2d.AcqViz2D.ax.plot", "visualize2d.AcqViz2D.h_list.append"], "methods", ["None"], ["", "def", "plot_model_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Plot data, assumed to have attributes x and y.\"\"\"", "\n", "x_list", "=", "[", "xin", "[", "0", "]", "for", "xin", "in", "data", ".", "x", "]", "\n", "y_list", "=", "[", "xin", "[", "1", "]", "for", "xin", "in", "data", ".", "x", "]", "\n", "#h = self.ax.plot(", "\n", "#x_list, y_list, \"o\", color=\"black\", markersize=8", "\n", "#)", "\n", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "x_list", ",", "\n", "y_list", ",", "\n", "\"o\"", ",", "\n", "#color=\"deeppink\",", "\n", "color", "=", "\"black\"", ",", "\n", "label", "=", "\"$\\mathcal{D}_t = \\{x_i, y_i\\}_{i=1}^t$\"", ",", "\n", "markersize", "=", "7", ",", "\n", ")", "\n", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_next_query": [[141, 153], ["visualize2d.AcqViz2D.ax.scatter", "visualize2d.AcqViz2D.h_list.append"], "methods", ["None"], ["", "def", "plot_next_query", "(", "self", ",", "next_query", ")", ":", "\n", "        ", "\"\"\"Plot next query.\"\"\"", "\n", "h", "=", "self", ".", "ax", ".", "scatter", "(", "\n", "next_query", "[", "0", "]", ",", "\n", "next_query", "[", "1", "]", ",", "\n", "color", "=", "'deeppink'", ",", "\n", "s", "=", "120", ",", "\n", "label", "=", "'Next query'", ",", "\n", "zorder", "=", "10", ",", "\n", ")", "\n", "self", ".", "h_list", ".", "append", "(", "h", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_expected_output": [[154, 173], ["visualize2d.AcqViz2D.ax.plot", "visualize2d.AcqViz2D.ax.plot", "visualize2d.AcqViz2D.h_list.append"], "methods", ["None"], ["", "def", "plot_expected_output", "(", "self", ",", "expected_output", ")", ":", "\n", "        ", "\"\"\"Plot expected output.\"\"\"", "\n", "self", ".", "ax", ".", "plot", "(", "\n", "expected_output", "[", "0", "]", ",", "\n", "expected_output", "[", "1", "]", ",", "\n", "\"*\"", ",", "\n", "color", "=", "'black'", ",", "\n", "markersize", "=", "36", ",", "\n", ")", "\n", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "expected_output", "[", "0", "]", ",", "\n", "expected_output", "[", "1", "]", ",", "\n", "\"*\"", ",", "\n", "color", "=", "'deeppink'", ",", "\n", "markersize", "=", "33", ",", "\n", "label", "=", "\"$O_\\mathcal{A}(\\mathrm{E}[f | \\mathcal{D}_t])$\"", "\n", ")", "\n", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.plot_optima": [[174, 187], ["visualize2d.AcqViz2D.h_list.append", "visualize2d.AcqViz2D.ax.plot"], "methods", ["None"], ["", "def", "plot_optima", "(", "self", ",", "optima_list", ")", ":", "\n", "        ", "\"\"\"Plot optima of a function.\"\"\"", "\n", "for", "optima", "in", "optima_list", ":", "\n", "            ", "h", "=", "self", ".", "ax", ".", "plot", "(", "\n", "optima", "[", "0", "]", ",", "\n", "optima", "[", "1", "]", ",", "\n", "\"s\"", ",", "\n", "color", "=", "\"#F3C807\"", ",", "\n", "markersize", "=", "12", ",", "\n", "label", "=", "\"$O_\\mathcal{A}(f*)$\"", ",", "\n", ")", "\n", "", "self", ".", "h_list", ".", "append", "(", "h", "[", "0", "]", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.make_legend": [[188, 207], ["visualize2d.AcqViz2D.ax.legend"], "methods", ["None"], ["", "def", "make_legend", "(", "self", ",", "h_list", "=", "None", ")", ":", "\n", "        ", "\"\"\"Make the legend.\"\"\"", "\n", "if", "h_list", "is", "None", ":", "\n", "            ", "h_list", "=", "self", ".", "h_list", "\n", "\n", "# For legend within axes", "\n", "", "bbta", "=", "None", "\n", "#loc = 1", "\n", "loc", "=", "\"lower left\"", "\n", "ncol", "=", "1", "\n", "\n", "# For legend above axes", "\n", "#self.ax.set_position([0.1, 0.1, 0.85, 0.7])", "\n", "#bbta = (0.5, 1.24)", "\n", "#loc = \"upper center\"", "\n", "#ncol = 3", "\n", "\n", "# Draw legend", "\n", "lgd", "=", "self", ".", "ax", ".", "legend", "(", "handles", "=", "h_list", ",", "loc", "=", "loc", ",", "bbox_to_anchor", "=", "bbta", ",", "ncol", "=", "ncol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.acq.visualize2d.AcqViz2D.reduce_samp_list": [[208, 214], ["None"], "methods", ["None"], ["", "def", "reduce_samp_list", "(", "self", ",", "samp_list", ")", ":", "\n", "        ", "\"\"\"Optionally reduce list of samples, based on self.n_path_max.\"\"\"", "\n", "if", "self", ".", "params", ".", "n_path_max", ":", "\n", "            ", "samp_list", "=", "samp_list", "[", ":", "self", ".", "params", ".", "n_path_max", "]", "\n", "\n", "", "return", "samp_list", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Optimizer.__init__": [[35, 40], ["None"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "pi", ",", "epsilon", "=", "1e-08", ")", ":", "\n", "    ", "self", ".", "pi", "=", "pi", "\n", "self", ".", "dim", "=", "pi", ".", "num_params", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "t", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Optimizer.update": [[41, 48], ["es.Optimizer._compute_step", "numpy.linalg.norm", "numpy.linalg.norm"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Adam._compute_step"], ["", "def", "update", "(", "self", ",", "globalg", ")", ":", "\n", "    ", "self", ".", "t", "+=", "1", "\n", "step", "=", "self", ".", "_compute_step", "(", "globalg", ")", "\n", "theta", "=", "self", ".", "pi", ".", "mu", "\n", "ratio", "=", "np", ".", "linalg", ".", "norm", "(", "step", ")", "/", "(", "np", ".", "linalg", ".", "norm", "(", "theta", ")", "+", "self", ".", "epsilon", ")", "\n", "self", ".", "pi", ".", "mu", "=", "theta", "+", "step", "\n", "return", "ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Optimizer._compute_step": [[49, 51], ["None"], "methods", ["None"], ["", "def", "_compute_step", "(", "self", ",", "globalg", ")", ":", "\n", "    ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.BasicSGD.__init__": [[54, 57], ["es.Optimizer.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "pi", ",", "stepsize", ")", ":", "\n", "    ", "Optimizer", ".", "__init__", "(", "self", ",", "pi", ")", "\n", "self", ".", "stepsize", "=", "stepsize", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.BasicSGD._compute_step": [[58, 61], ["None"], "methods", ["None"], ["", "def", "_compute_step", "(", "self", ",", "globalg", ")", ":", "\n", "    ", "step", "=", "-", "self", ".", "stepsize", "*", "globalg", "\n", "return", "step", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SGD.__init__": [[63, 67], ["es.Optimizer.__init__", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "pi", ",", "stepsize", ",", "momentum", "=", "0.9", ")", ":", "\n", "    ", "Optimizer", ".", "__init__", "(", "self", ",", "pi", ")", "\n", "self", ".", "v", "=", "np", ".", "zeros", "(", "self", ".", "dim", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "stepsize", ",", "self", ".", "momentum", "=", "stepsize", ",", "momentum", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SGD._compute_step": [[68, 72], ["None"], "methods", ["None"], ["", "def", "_compute_step", "(", "self", ",", "globalg", ")", ":", "\n", "    ", "self", ".", "v", "=", "self", ".", "momentum", "*", "self", ".", "v", "+", "(", "1.", "-", "self", ".", "momentum", ")", "*", "globalg", "\n", "step", "=", "-", "self", ".", "stepsize", "*", "self", ".", "v", "\n", "return", "step", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Adam.__init__": [[75, 82], ["es.Optimizer.__init__", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["  ", "def", "__init__", "(", "self", ",", "pi", ",", "stepsize", ",", "beta1", "=", "0.99", ",", "beta2", "=", "0.999", ")", ":", "\n", "    ", "Optimizer", ".", "__init__", "(", "self", ",", "pi", ")", "\n", "self", ".", "stepsize", "=", "stepsize", "\n", "self", ".", "beta1", "=", "beta1", "\n", "self", ".", "beta2", "=", "beta2", "\n", "self", ".", "m", "=", "np", ".", "zeros", "(", "self", ".", "dim", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "v", "=", "np", ".", "zeros", "(", "self", ".", "dim", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Adam._compute_step": [[83, 89], ["numpy.sqrt", "numpy.sqrt"], "methods", ["None"], ["", "def", "_compute_step", "(", "self", ",", "globalg", ")", ":", "\n", "    ", "a", "=", "self", ".", "stepsize", "*", "np", ".", "sqrt", "(", "1", "-", "self", ".", "beta2", "**", "self", ".", "t", ")", "/", "(", "1", "-", "self", ".", "beta1", "**", "self", ".", "t", ")", "\n", "self", ".", "m", "=", "self", ".", "beta1", "*", "self", ".", "m", "+", "(", "1", "-", "self", ".", "beta1", ")", "*", "globalg", "\n", "self", ".", "v", "=", "self", ".", "beta2", "*", "self", ".", "v", "+", "(", "1", "-", "self", ".", "beta2", ")", "*", "(", "globalg", "*", "globalg", ")", "\n", "step", "=", "-", "a", "*", "self", ".", "m", "/", "(", "np", ".", "sqrt", "(", "self", ".", "v", ")", "+", "self", ".", "epsilon", ")", "\n", "return", "step", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.__init__": [[92, 107], ["cma.CMAEvolutionStrategy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_params", ",", "# number of model parameters", "\n", "sigma_init", "=", "0.10", ",", "# initial standard deviation", "\n", "popsize", "=", "255", ",", "# population size", "\n", "weight_decay", "=", "0.01", ")", ":", "# weight decay coefficient", "\n", "\n", "    ", "self", ".", "num_params", "=", "num_params", "\n", "self", ".", "sigma_init", "=", "sigma_init", "\n", "self", ".", "popsize", "=", "popsize", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "solutions", "=", "None", "\n", "\n", "import", "cma", "\n", "self", ".", "es", "=", "cma", ".", "CMAEvolutionStrategy", "(", "self", ".", "num_params", "*", "[", "0", "]", ",", "\n", "self", ".", "sigma_init", ",", "\n", "{", "'popsize'", ":", "self", ".", "popsize", ",", "\n", "}", ")", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.rms_stdev": [[109, 112], ["numpy.mean", "numpy.sqrt"], "methods", ["None"], ["", "def", "rms_stdev", "(", "self", ")", ":", "\n", "    ", "sigma", "=", "self", ".", "es", ".", "result", "[", "6", "]", "\n", "return", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "sigma", "*", "sigma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.ask": [[113, 117], ["numpy.array", "es.CMAES.es.ask"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.ask"], ["", "def", "ask", "(", "self", ")", ":", "\n", "    ", "'''returns a list of parameters'''", "\n", "self", ".", "solutions", "=", "np", ".", "array", "(", "self", ".", "es", ".", "ask", "(", ")", ")", "\n", "return", "self", ".", "solutions", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.tell": [[118, 124], ["es.CMAES.es.tell", "numpy.array", "es.compute_weight_decay", "reward_table.tolist"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.tell", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_weight_decay"], ["", "def", "tell", "(", "self", ",", "reward_table_result", ")", ":", "\n", "    ", "reward_table", "=", "-", "np", ".", "array", "(", "reward_table_result", ")", "\n", "if", "self", ".", "weight_decay", ">", "0", ":", "\n", "      ", "l2_decay", "=", "compute_weight_decay", "(", "self", ".", "weight_decay", ",", "self", ".", "solutions", ")", "\n", "reward_table", "+=", "l2_decay", "\n", "", "self", ".", "es", ".", "tell", "(", "self", ".", "solutions", ",", "(", "reward_table", ")", ".", "tolist", "(", ")", ")", "# convert minimizer to maximizer.", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.current_param": [[125, 127], ["None"], "methods", ["None"], ["", "def", "current_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "es", ".", "result", "[", "5", "]", "# mean solution, presumably better with noise", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.set_mu": [[128, 130], ["None"], "methods", ["None"], ["", "def", "set_mu", "(", "self", ",", "mu", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.best_param": [[131, 133], ["None"], "methods", ["None"], ["", "def", "best_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "es", ".", "result", "[", "0", "]", "# best evaluated solution", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.CMAES.result": [[134, 137], ["None"], "methods", ["None"], ["", "def", "result", "(", "self", ")", ":", "# return best params so far, along with historically best reward, curr reward, sigma", "\n", "    ", "r", "=", "self", ".", "es", ".", "result", "\n", "return", "(", "r", "[", "0", "]", ",", "-", "r", "[", "1", "]", ",", "-", "r", "[", "1", "]", ",", "r", "[", "6", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.__init__": [[140, 167], ["int", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_params", ",", "# number of model parameters", "\n", "sigma_init", "=", "0.1", ",", "# initial standard deviation", "\n", "sigma_decay", "=", "0.999", ",", "# anneal standard deviation", "\n", "sigma_limit", "=", "0.01", ",", "# stop annealing if less than this", "\n", "popsize", "=", "256", ",", "# population size", "\n", "elite_ratio", "=", "0.1", ",", "# percentage of the elites", "\n", "forget_best", "=", "False", ",", "# forget the historical best elites", "\n", "weight_decay", "=", "0.01", ",", "# weight decay coefficient", "\n", ")", ":", "\n", "\n", "    ", "self", ".", "num_params", "=", "num_params", "\n", "self", ".", "sigma_init", "=", "sigma_init", "\n", "self", ".", "sigma_decay", "=", "sigma_decay", "\n", "self", ".", "sigma_limit", "=", "sigma_limit", "\n", "self", ".", "popsize", "=", "popsize", "\n", "\n", "self", ".", "elite_ratio", "=", "elite_ratio", "\n", "self", ".", "elite_popsize", "=", "int", "(", "self", ".", "popsize", "*", "self", ".", "elite_ratio", ")", "\n", "\n", "self", ".", "sigma", "=", "self", ".", "sigma_init", "\n", "self", ".", "elite_params", "=", "np", ".", "zeros", "(", "(", "self", ".", "elite_popsize", ",", "self", ".", "num_params", ")", ")", "\n", "self", ".", "elite_rewards", "=", "np", ".", "zeros", "(", "self", ".", "elite_popsize", ")", "\n", "self", ".", "best_param", "=", "np", ".", "zeros", "(", "self", ".", "num_params", ")", "\n", "self", ".", "best_reward", "=", "0", "\n", "self", ".", "first_iteration", "=", "True", "\n", "self", ".", "forget_best", "=", "forget_best", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.rms_stdev": [[168, 170], ["None"], "methods", ["None"], ["", "def", "rms_stdev", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "sigma", "# same sigma for all parameters.", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.ask": [[171, 193], ["range", "range", "numpy.array", "numpy.random.randn", "numpy.copy", "numpy.where", "numpy.random.choice", "numpy.random.choice", "es.SimpleGA.ask.mate"], "methods", ["None"], ["", "def", "ask", "(", "self", ")", ":", "\n", "    ", "'''returns a list of parameters'''", "\n", "self", ".", "epsilon", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "popsize", ",", "self", ".", "num_params", ")", "*", "self", ".", "sigma", "\n", "solutions", "=", "[", "]", "\n", "\n", "def", "mate", "(", "a", ",", "b", ")", ":", "\n", "      ", "c", "=", "np", ".", "copy", "(", "a", ")", "\n", "idx", "=", "np", ".", "where", "(", "np", ".", "random", ".", "rand", "(", "(", "c", ".", "size", ")", ")", ">", "0.5", ")", "\n", "c", "[", "idx", "]", "=", "b", "[", "idx", "]", "\n", "return", "c", "\n", "\n", "", "elite_range", "=", "range", "(", "self", ".", "elite_popsize", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "popsize", ")", ":", "\n", "      ", "idx_a", "=", "np", ".", "random", ".", "choice", "(", "elite_range", ")", "\n", "idx_b", "=", "np", ".", "random", ".", "choice", "(", "elite_range", ")", "\n", "child_params", "=", "mate", "(", "self", ".", "elite_params", "[", "idx_a", "]", ",", "self", ".", "elite_params", "[", "idx_b", "]", ")", "\n", "solutions", ".", "append", "(", "child_params", "+", "self", ".", "epsilon", "[", "i", "]", ")", "\n", "\n", "", "solutions", "=", "np", ".", "array", "(", "solutions", ")", "\n", "self", ".", "solutions", "=", "solutions", "\n", "\n", "return", "solutions", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.tell": [[194, 225], ["numpy.array", "len", "es.compute_weight_decay", "numpy.concatenate", "numpy.concatenate", "numpy.copy", "numpy.argsort"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_weight_decay"], ["", "def", "tell", "(", "self", ",", "reward_table_result", ")", ":", "\n", "# input must be a numpy float array", "\n", "    ", "assert", "(", "len", "(", "reward_table_result", ")", "==", "self", ".", "popsize", ")", ",", "\"Inconsistent reward_table size reported.\"", "\n", "\n", "reward_table", "=", "np", ".", "array", "(", "reward_table_result", ")", "\n", "\n", "if", "self", ".", "weight_decay", ">", "0", ":", "\n", "      ", "l2_decay", "=", "compute_weight_decay", "(", "self", ".", "weight_decay", ",", "self", ".", "solutions", ")", "\n", "reward_table", "+=", "l2_decay", "\n", "\n", "", "if", "self", ".", "forget_best", "or", "self", ".", "first_iteration", ":", "\n", "      ", "reward", "=", "reward_table", "\n", "solution", "=", "self", ".", "solutions", "\n", "", "else", ":", "\n", "      ", "reward", "=", "np", ".", "concatenate", "(", "[", "reward_table", ",", "self", ".", "elite_rewards", "]", ")", "\n", "solution", "=", "np", ".", "concatenate", "(", "[", "self", ".", "solutions", ",", "self", ".", "elite_params", "]", ")", "\n", "\n", "", "idx", "=", "np", ".", "argsort", "(", "reward", ")", "[", ":", ":", "-", "1", "]", "[", "0", ":", "self", ".", "elite_popsize", "]", "\n", "\n", "self", ".", "elite_rewards", "=", "reward", "[", "idx", "]", "\n", "self", ".", "elite_params", "=", "solution", "[", "idx", "]", "\n", "\n", "self", ".", "curr_best_reward", "=", "self", ".", "elite_rewards", "[", "0", "]", "\n", "\n", "if", "self", ".", "first_iteration", "or", "(", "self", ".", "curr_best_reward", ">", "self", ".", "best_reward", ")", ":", "\n", "      ", "self", ".", "first_iteration", "=", "False", "\n", "self", ".", "best_reward", "=", "self", ".", "elite_rewards", "[", "0", "]", "\n", "self", ".", "best_param", "=", "np", ".", "copy", "(", "self", ".", "elite_params", "[", "0", "]", ")", "\n", "\n", "", "if", "(", "self", ".", "sigma", ">", "self", ".", "sigma_limit", ")", ":", "\n", "      ", "self", ".", "sigma", "*=", "self", ".", "sigma_decay", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.current_param": [[226, 228], ["None"], "methods", ["None"], ["", "", "def", "current_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "elite_params", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.set_mu": [[229, 231], ["None"], "methods", ["None"], ["", "def", "set_mu", "(", "self", ",", "mu", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.best_param": [[232, 234], ["None"], "methods", ["None"], ["", "def", "best_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "best_param", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.SimpleGA.result": [[235, 237], ["None"], "methods", ["None"], ["", "def", "result", "(", "self", ")", ":", "# return best params so far, along with historically best reward, curr reward, sigma", "\n", "    ", "return", "(", "self", ".", "best_param", ",", "self", ".", "best_reward", ",", "self", ".", "curr_best_reward", ",", "self", ".", "sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.__init__": [[240, 279], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "es.Adam", "int"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_params", ",", "# number of model parameters", "\n", "sigma_init", "=", "0.1", ",", "# initial standard deviation", "\n", "sigma_decay", "=", "0.999", ",", "# anneal standard deviation", "\n", "sigma_limit", "=", "0.01", ",", "# stop annealing if less than this", "\n", "learning_rate", "=", "0.01", ",", "# learning rate for standard deviation", "\n", "learning_rate_decay", "=", "0.9999", ",", "# annealing the learning rate", "\n", "learning_rate_limit", "=", "0.001", ",", "# stop annealing learning rate", "\n", "popsize", "=", "256", ",", "# population size", "\n", "antithetic", "=", "False", ",", "# whether to use antithetic sampling", "\n", "weight_decay", "=", "0.01", ",", "# weight decay coefficient", "\n", "rank_fitness", "=", "True", ",", "# use rank rather than fitness numbers", "\n", "forget_best", "=", "True", ")", ":", "# forget historical best", "\n", "\n", "    ", "self", ".", "num_params", "=", "num_params", "\n", "self", ".", "sigma_decay", "=", "sigma_decay", "\n", "self", ".", "sigma", "=", "sigma_init", "\n", "self", ".", "sigma_init", "=", "sigma_init", "\n", "self", ".", "sigma_limit", "=", "sigma_limit", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "learning_rate_decay", "=", "learning_rate_decay", "\n", "self", ".", "learning_rate_limit", "=", "learning_rate_limit", "\n", "self", ".", "popsize", "=", "popsize", "\n", "self", ".", "antithetic", "=", "antithetic", "\n", "if", "self", ".", "antithetic", ":", "\n", "      ", "assert", "(", "self", ".", "popsize", "%", "2", "==", "0", ")", ",", "\"Population size must be even\"", "\n", "self", ".", "half_popsize", "=", "int", "(", "self", ".", "popsize", "/", "2", ")", "\n", "\n", "", "self", ".", "reward", "=", "np", ".", "zeros", "(", "self", ".", "popsize", ")", "\n", "self", ".", "mu", "=", "np", ".", "zeros", "(", "self", ".", "num_params", ")", "\n", "self", ".", "best_mu", "=", "np", ".", "zeros", "(", "self", ".", "num_params", ")", "\n", "self", ".", "best_reward", "=", "0", "\n", "self", ".", "first_interation", "=", "True", "\n", "self", ".", "forget_best", "=", "forget_best", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "rank_fitness", "=", "rank_fitness", "\n", "if", "self", ".", "rank_fitness", ":", "\n", "      ", "self", ".", "forget_best", "=", "True", "# always forget the best one if we rank", "\n", "# choose optimizer", "\n", "", "self", ".", "optimizer", "=", "Adam", "(", "self", ",", "learning_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.rms_stdev": [[280, 283], ["numpy.mean", "numpy.sqrt"], "methods", ["None"], ["", "def", "rms_stdev", "(", "self", ")", ":", "\n", "    ", "sigma", "=", "self", ".", "sigma", "\n", "return", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "sigma", "*", "sigma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.ask": [[284, 296], ["numpy.random.randn", "numpy.concatenate", "numpy.random.randn", "es.OpenES.mu.reshape"], "methods", ["None"], ["", "def", "ask", "(", "self", ")", ":", "\n", "    ", "'''returns a list of parameters'''", "\n", "# antithetic sampling", "\n", "if", "self", ".", "antithetic", ":", "\n", "      ", "self", ".", "epsilon_half", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "half_popsize", ",", "self", ".", "num_params", ")", "\n", "self", ".", "epsilon", "=", "np", ".", "concatenate", "(", "[", "self", ".", "epsilon_half", ",", "-", "self", ".", "epsilon_half", "]", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "epsilon", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "popsize", ",", "self", ".", "num_params", ")", "\n", "\n", "", "self", ".", "solutions", "=", "self", ".", "mu", ".", "reshape", "(", "1", ",", "self", ".", "num_params", ")", "+", "self", ".", "epsilon", "*", "self", ".", "sigma", "\n", "\n", "return", "self", ".", "solutions", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.tell": [[297, 343], ["numpy.array", "es.OpenES.optimizer.update", "len", "es.compute_centered_ranks", "es.compute_weight_decay", "numpy.argsort", "numpy.std", "numpy.dot", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Optimizer.update", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_centered_ranks", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_weight_decay"], ["", "def", "tell", "(", "self", ",", "reward_table_result", ")", ":", "\n", "# input must be a numpy float array", "\n", "    ", "assert", "(", "len", "(", "reward_table_result", ")", "==", "self", ".", "popsize", ")", ",", "\"Inconsistent reward_table size reported.\"", "\n", "\n", "reward", "=", "np", ".", "array", "(", "reward_table_result", ")", "\n", "\n", "if", "self", ".", "rank_fitness", ":", "\n", "      ", "reward", "=", "compute_centered_ranks", "(", "reward", ")", "\n", "\n", "", "if", "self", ".", "weight_decay", ">", "0", ":", "\n", "      ", "l2_decay", "=", "compute_weight_decay", "(", "self", ".", "weight_decay", ",", "self", ".", "solutions", ")", "\n", "reward", "+=", "l2_decay", "\n", "\n", "", "idx", "=", "np", ".", "argsort", "(", "reward", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "best_reward", "=", "reward", "[", "idx", "[", "0", "]", "]", "\n", "best_mu", "=", "self", ".", "solutions", "[", "idx", "[", "0", "]", "]", "\n", "\n", "self", ".", "curr_best_reward", "=", "best_reward", "\n", "self", ".", "curr_best_mu", "=", "best_mu", "\n", "\n", "if", "self", ".", "first_interation", ":", "\n", "      ", "self", ".", "first_interation", "=", "False", "\n", "self", ".", "best_reward", "=", "self", ".", "curr_best_reward", "\n", "self", ".", "best_mu", "=", "best_mu", "\n", "", "else", ":", "\n", "      ", "if", "self", ".", "forget_best", "or", "(", "self", ".", "curr_best_reward", ">", "self", ".", "best_reward", ")", ":", "\n", "        ", "self", ".", "best_mu", "=", "best_mu", "\n", "self", ".", "best_reward", "=", "self", ".", "curr_best_reward", "\n", "\n", "# main bit:", "\n", "# standardize the rewards to have a gaussian distribution", "\n", "", "", "normalized_reward", "=", "(", "reward", "-", "np", ".", "mean", "(", "reward", ")", ")", "/", "np", ".", "std", "(", "reward", ")", "\n", "change_mu", "=", "1.", "/", "(", "self", ".", "popsize", "*", "self", ".", "sigma", ")", "*", "np", ".", "dot", "(", "self", ".", "epsilon", ".", "T", ",", "normalized_reward", ")", "\n", "\n", "#self.mu += self.learning_rate * change_mu", "\n", "\n", "self", ".", "optimizer", ".", "stepsize", "=", "self", ".", "learning_rate", "\n", "update_ratio", "=", "self", ".", "optimizer", ".", "update", "(", "-", "change_mu", ")", "\n", "\n", "# adjust sigma according to the adaptive sigma calculation", "\n", "if", "(", "self", ".", "sigma", ">", "self", ".", "sigma_limit", ")", ":", "\n", "      ", "self", ".", "sigma", "*=", "self", ".", "sigma_decay", "\n", "\n", "", "if", "(", "self", ".", "learning_rate", ">", "self", ".", "learning_rate_limit", ")", ":", "\n", "      ", "self", ".", "learning_rate", "*=", "self", ".", "learning_rate_decay", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.current_param": [[344, 346], ["None"], "methods", ["None"], ["", "", "def", "current_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "curr_best_mu", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.set_mu": [[347, 349], ["numpy.array"], "methods", ["None"], ["", "def", "set_mu", "(", "self", ",", "mu", ")", ":", "\n", "    ", "self", ".", "mu", "=", "np", ".", "array", "(", "mu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.best_param": [[350, 352], ["None"], "methods", ["None"], ["", "def", "best_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "best_mu", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.OpenES.result": [[353, 355], ["None"], "methods", ["None"], ["", "def", "result", "(", "self", ")", ":", "# return best params so far, along with historically best reward, curr reward, sigma", "\n", "    ", "return", "(", "self", ".", "best_mu", ",", "self", ".", "best_reward", ",", "self", ".", "curr_best_reward", ",", "self", ".", "sigma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.__init__": [[358, 413], ["int", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "es.Adam", "int", "int", "numpy.ones"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_params", ",", "# number of model parameters", "\n", "sigma_init", "=", "0.10", ",", "# initial standard deviation", "\n", "sigma_alpha", "=", "0.20", ",", "# learning rate for standard deviation", "\n", "sigma_decay", "=", "0.999", ",", "# anneal standard deviation", "\n", "sigma_limit", "=", "0.01", ",", "# stop annealing if less than this", "\n", "sigma_max_change", "=", "0.2", ",", "# clips adaptive sigma to 20%", "\n", "learning_rate", "=", "0.01", ",", "# learning rate for standard deviation", "\n", "learning_rate_decay", "=", "0.9999", ",", "# annealing the learning rate", "\n", "learning_rate_limit", "=", "0.01", ",", "# stop annealing learning rate", "\n", "elite_ratio", "=", "0", ",", "# if > 0, then ignore learning_rate", "\n", "popsize", "=", "256", ",", "# population size", "\n", "average_baseline", "=", "True", ",", "# set baseline to average of batch", "\n", "weight_decay", "=", "0.01", ",", "# weight decay coefficient", "\n", "rank_fitness", "=", "True", ",", "# use rank rather than fitness numbers", "\n", "forget_best", "=", "True", ")", ":", "# don't keep the historical best solution", "\n", "\n", "    ", "self", ".", "num_params", "=", "num_params", "\n", "self", ".", "sigma_init", "=", "sigma_init", "\n", "self", ".", "sigma_alpha", "=", "sigma_alpha", "\n", "self", ".", "sigma_decay", "=", "sigma_decay", "\n", "self", ".", "sigma_limit", "=", "sigma_limit", "\n", "self", ".", "sigma_max_change", "=", "sigma_max_change", "\n", "self", ".", "learning_rate", "=", "learning_rate", "\n", "self", ".", "learning_rate_decay", "=", "learning_rate_decay", "\n", "self", ".", "learning_rate_limit", "=", "learning_rate_limit", "\n", "self", ".", "popsize", "=", "popsize", "\n", "self", ".", "average_baseline", "=", "average_baseline", "\n", "if", "self", ".", "average_baseline", ":", "\n", "      ", "assert", "(", "self", ".", "popsize", "%", "2", "==", "0", ")", ",", "\"Population size must be even\"", "\n", "self", ".", "batch_size", "=", "int", "(", "self", ".", "popsize", "/", "2", ")", "\n", "", "else", ":", "\n", "      ", "assert", "(", "self", ".", "popsize", "&", "1", ")", ",", "\"Population size must be odd\"", "\n", "self", ".", "batch_size", "=", "int", "(", "(", "self", ".", "popsize", "-", "1", ")", "/", "2", ")", "\n", "\n", "# option to use greedy es method to select next mu, rather than using drift param", "\n", "", "self", ".", "elite_ratio", "=", "elite_ratio", "\n", "self", ".", "elite_popsize", "=", "int", "(", "self", ".", "popsize", "*", "self", ".", "elite_ratio", ")", "\n", "self", ".", "use_elite", "=", "False", "\n", "if", "self", ".", "elite_popsize", ">", "0", ":", "\n", "      ", "self", ".", "use_elite", "=", "True", "\n", "\n", "", "self", ".", "forget_best", "=", "forget_best", "\n", "self", ".", "batch_reward", "=", "np", ".", "zeros", "(", "self", ".", "batch_size", "*", "2", ")", "\n", "self", ".", "mu", "=", "np", ".", "zeros", "(", "self", ".", "num_params", ")", "\n", "self", ".", "sigma", "=", "np", ".", "ones", "(", "self", ".", "num_params", ")", "*", "self", ".", "sigma_init", "\n", "self", ".", "curr_best_mu", "=", "np", ".", "zeros", "(", "self", ".", "num_params", ")", "\n", "self", ".", "best_mu", "=", "np", ".", "zeros", "(", "self", ".", "num_params", ")", "\n", "self", ".", "best_reward", "=", "0", "\n", "self", ".", "first_interation", "=", "True", "\n", "self", ".", "weight_decay", "=", "weight_decay", "\n", "self", ".", "rank_fitness", "=", "rank_fitness", "\n", "if", "self", ".", "rank_fitness", ":", "\n", "      ", "self", ".", "forget_best", "=", "True", "# always forget the best one if we rank", "\n", "# choose optimizer", "\n", "", "self", ".", "optimizer", "=", "Adam", "(", "self", ",", "learning_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.rms_stdev": [[414, 417], ["numpy.mean", "numpy.sqrt"], "methods", ["None"], ["", "def", "rms_stdev", "(", "self", ")", ":", "\n", "    ", "sigma", "=", "self", ".", "sigma", "\n", "return", "np", ".", "mean", "(", "np", ".", "sqrt", "(", "sigma", "*", "sigma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.ask": [[418, 431], ["numpy.concatenate", "numpy.random.randn", "es.PEPG.sigma.reshape", "numpy.concatenate", "es.PEPG.mu.reshape", "numpy.zeros"], "methods", ["None"], ["", "def", "ask", "(", "self", ")", ":", "\n", "    ", "'''returns a list of parameters'''", "\n", "# antithetic sampling", "\n", "self", ".", "epsilon", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "batch_size", ",", "self", ".", "num_params", ")", "*", "self", ".", "sigma", ".", "reshape", "(", "1", ",", "self", ".", "num_params", ")", "\n", "self", ".", "epsilon_full", "=", "np", ".", "concatenate", "(", "[", "self", ".", "epsilon", ",", "-", "self", ".", "epsilon", "]", ")", "\n", "if", "self", ".", "average_baseline", ":", "\n", "      ", "epsilon", "=", "self", ".", "epsilon_full", "\n", "", "else", ":", "\n", "# first population is mu, then positive epsilon, then negative epsilon", "\n", "      ", "epsilon", "=", "np", ".", "concatenate", "(", "[", "np", ".", "zeros", "(", "(", "1", ",", "self", ".", "num_params", ")", ")", ",", "self", ".", "epsilon_full", "]", ")", "\n", "", "solutions", "=", "self", ".", "mu", ".", "reshape", "(", "1", ",", "self", ".", "num_params", ")", "+", "epsilon", "\n", "self", ".", "solutions", "=", "solutions", "\n", "return", "solutions", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.tell": [[432, 518], ["numpy.array", "len", "es.compute_centered_ranks", "es.compute_weight_decay", "numpy.mean", "es.PEPG.epsilon_full[].mean", "numpy.dot", "es.PEPG.optimizer.update", "numpy.minimum", "numpy.maximum", "numpy.argsort", "numpy.ones", "reward.std", "sigma.reshape", "numpy.dot", "numpy.argsort"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_centered_ranks", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_weight_decay", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Optimizer.update"], ["", "def", "tell", "(", "self", ",", "reward_table_result", ")", ":", "\n", "# input must be a numpy float array", "\n", "    ", "assert", "(", "len", "(", "reward_table_result", ")", "==", "self", ".", "popsize", ")", ",", "\"Inconsistent reward_table size reported.\"", "\n", "\n", "reward_table", "=", "np", ".", "array", "(", "reward_table_result", ")", "\n", "\n", "if", "self", ".", "rank_fitness", ":", "\n", "      ", "reward_table", "=", "compute_centered_ranks", "(", "reward_table", ")", "\n", "\n", "", "if", "self", ".", "weight_decay", ">", "0", ":", "\n", "      ", "l2_decay", "=", "compute_weight_decay", "(", "self", ".", "weight_decay", ",", "self", ".", "solutions", ")", "\n", "reward_table", "+=", "l2_decay", "\n", "\n", "", "reward_offset", "=", "1", "\n", "if", "self", ".", "average_baseline", ":", "\n", "      ", "b", "=", "np", ".", "mean", "(", "reward_table", ")", "\n", "reward_offset", "=", "0", "\n", "", "else", ":", "\n", "      ", "b", "=", "reward_table", "[", "0", "]", "# baseline", "\n", "\n", "", "reward", "=", "reward_table", "[", "reward_offset", ":", "]", "\n", "if", "self", ".", "use_elite", ":", "\n", "      ", "idx", "=", "np", ".", "argsort", "(", "reward", ")", "[", ":", ":", "-", "1", "]", "[", "0", ":", "self", ".", "elite_popsize", "]", "\n", "", "else", ":", "\n", "      ", "idx", "=", "np", ".", "argsort", "(", "reward", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "", "best_reward", "=", "reward", "[", "idx", "[", "0", "]", "]", "\n", "if", "(", "best_reward", ">", "b", "or", "self", ".", "average_baseline", ")", ":", "\n", "      ", "best_mu", "=", "self", ".", "mu", "+", "self", ".", "epsilon_full", "[", "idx", "[", "0", "]", "]", "\n", "best_reward", "=", "reward", "[", "idx", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "      ", "best_mu", "=", "self", ".", "mu", "\n", "best_reward", "=", "b", "\n", "\n", "", "self", ".", "curr_best_reward", "=", "best_reward", "\n", "self", ".", "curr_best_mu", "=", "best_mu", "\n", "\n", "if", "self", ".", "first_interation", ":", "\n", "      ", "self", ".", "sigma", "=", "np", ".", "ones", "(", "self", ".", "num_params", ")", "*", "self", ".", "sigma_init", "\n", "self", ".", "first_interation", "=", "False", "\n", "self", ".", "best_reward", "=", "self", ".", "curr_best_reward", "\n", "self", ".", "best_mu", "=", "best_mu", "\n", "", "else", ":", "\n", "      ", "if", "self", ".", "forget_best", "or", "(", "self", ".", "curr_best_reward", ">", "self", ".", "best_reward", ")", ":", "\n", "        ", "self", ".", "best_mu", "=", "best_mu", "\n", "self", ".", "best_reward", "=", "self", ".", "curr_best_reward", "\n", "\n", "# short hand", "\n", "", "", "epsilon", "=", "self", ".", "epsilon", "\n", "sigma", "=", "self", ".", "sigma", "\n", "\n", "# update the mean", "\n", "\n", "# move mean to the average of the best idx means", "\n", "if", "self", ".", "use_elite", ":", "\n", "      ", "self", ".", "mu", "+=", "self", ".", "epsilon_full", "[", "idx", "]", ".", "mean", "(", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "      ", "rT", "=", "(", "reward", "[", ":", "self", ".", "batch_size", "]", "-", "reward", "[", "self", ".", "batch_size", ":", "]", ")", "\n", "change_mu", "=", "np", ".", "dot", "(", "rT", ",", "epsilon", ")", "\n", "self", ".", "optimizer", ".", "stepsize", "=", "self", ".", "learning_rate", "\n", "update_ratio", "=", "self", ".", "optimizer", ".", "update", "(", "-", "change_mu", ")", "# adam, rmsprop, momentum, etc.", "\n", "#self.mu += (change_mu * self.learning_rate) # normal SGD method", "\n", "\n", "# adaptive sigma", "\n", "# normalization", "\n", "", "if", "(", "self", ".", "sigma_alpha", ">", "0", ")", ":", "\n", "      ", "stdev_reward", "=", "1.0", "\n", "if", "not", "self", ".", "rank_fitness", ":", "\n", "        ", "stdev_reward", "=", "reward", ".", "std", "(", ")", "\n", "", "S", "=", "(", "(", "epsilon", "*", "epsilon", "-", "(", "sigma", "*", "sigma", ")", ".", "reshape", "(", "1", ",", "self", ".", "num_params", ")", ")", "/", "sigma", ".", "reshape", "(", "1", ",", "self", ".", "num_params", ")", ")", "\n", "reward_avg", "=", "(", "reward", "[", ":", "self", ".", "batch_size", "]", "+", "reward", "[", "self", ".", "batch_size", ":", "]", ")", "/", "2.0", "\n", "rS", "=", "reward_avg", "-", "b", "\n", "delta_sigma", "=", "(", "np", ".", "dot", "(", "rS", ",", "S", ")", ")", "/", "(", "2", "*", "self", ".", "batch_size", "*", "stdev_reward", ")", "\n", "\n", "# adjust sigma according to the adaptive sigma calculation", "\n", "# for stability, don't let sigma move more than 10% of orig value", "\n", "change_sigma", "=", "self", ".", "sigma_alpha", "*", "delta_sigma", "\n", "change_sigma", "=", "np", ".", "minimum", "(", "change_sigma", ",", "self", ".", "sigma_max_change", "*", "self", ".", "sigma", ")", "\n", "change_sigma", "=", "np", ".", "maximum", "(", "change_sigma", ",", "-", "self", ".", "sigma_max_change", "*", "self", ".", "sigma", ")", "\n", "self", ".", "sigma", "+=", "change_sigma", "\n", "\n", "", "if", "(", "self", ".", "sigma_decay", "<", "1", ")", ":", "\n", "      ", "self", ".", "sigma", "[", "self", ".", "sigma", ">", "self", ".", "sigma_limit", "]", "*=", "self", ".", "sigma_decay", "\n", "\n", "", "if", "(", "self", ".", "learning_rate_decay", "<", "1", "and", "self", ".", "learning_rate", ">", "self", ".", "learning_rate_limit", ")", ":", "\n", "      ", "self", ".", "learning_rate", "*=", "self", ".", "learning_rate_decay", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.current_param": [[519, 521], ["None"], "methods", ["None"], ["", "", "def", "current_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "curr_best_mu", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.set_mu": [[522, 524], ["numpy.array"], "methods", ["None"], ["", "def", "set_mu", "(", "self", ",", "mu", ")", ":", "\n", "    ", "self", ".", "mu", "=", "np", ".", "array", "(", "mu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.best_param": [[525, 527], ["None"], "methods", ["None"], ["", "def", "best_param", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "best_mu", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.PEPG.result": [[528, 530], ["None"], "methods", ["None"], ["", "def", "result", "(", "self", ")", ":", "# return best params so far, along with historically best reward, curr reward, sigma", "\n", "    ", "return", "(", "self", ".", "best_mu", ",", "self", ".", "best_reward", ",", "self", ".", "curr_best_reward", ",", "self", ".", "sigma", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_ranks": [[7, 17], ["numpy.empty", "numpy.arange", "len", "len", "x.argsort"], "function", ["None"], ["def", "compute_ranks", "(", "x", ")", ":", "\n", "  ", "\"\"\"\n  Returns ranks in [0, len(x))\n  Note: This is different from scipy.stats.rankdata, which returns ranks in [1, len(x)].\n  (https://github.com/openai/evolution-strategies-starter/blob/master/es_distributed/es.py)\n  \"\"\"", "\n", "assert", "x", ".", "ndim", "==", "1", "\n", "ranks", "=", "np", ".", "empty", "(", "len", "(", "x", ")", ",", "dtype", "=", "int", ")", "\n", "ranks", "[", "x", ".", "argsort", "(", ")", "]", "=", "np", ".", "arange", "(", "len", "(", "x", ")", ")", "\n", "return", "ranks", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_centered_ranks": [[18, 26], ["compute_ranks().reshape().astype", "compute_ranks().reshape", "es.compute_ranks", "x.ravel"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_ranks"], ["", "def", "compute_centered_ranks", "(", "x", ")", ":", "\n", "  ", "\"\"\"\n  https://github.com/openai/evolution-strategies-starter/blob/master/es_distributed/es.py\n  \"\"\"", "\n", "y", "=", "compute_ranks", "(", "x", ".", "ravel", "(", ")", ")", ".", "reshape", "(", "x", ".", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "y", "/=", "(", "x", ".", "size", "-", "1", ")", "\n", "y", "-=", ".5", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.compute_weight_decay": [[27, 30], ["numpy.array", "numpy.mean"], "function", ["None"], ["", "def", "compute_weight_decay", "(", "weight_decay", ",", "model_param_list", ")", ":", "\n", "  ", "model_param_grid", "=", "np", ".", "array", "(", "model_param_list", ")", "\n", "return", "-", "weight_decay", "*", "np", ".", "mean", "(", "model_param_grid", "*", "model_param_grid", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.__init__": [[20, 60], ["algorithms.Algorithm.__init__"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "params", "=", "None", ",", "\n", "vertices", "=", "None", ",", "\n", "start", "=", "None", ",", "\n", "goal", "=", "None", ",", "\n", "edge_to_position", "=", "None", ",", "\n", "node_representation", "=", "\"locations\"", ",", "\n", "verbose", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        params : Namespace_or_dict\n            Namespace or dict of parameters for the algorithm.\n        vertices : list\n            List of Vertex objects\n        edge_to_position: Optional[dict].\n            If node_representation is 'indices', this must map edges to positions, i.e.\n            of type Dict[Tuple[int,int], np.ndarray]\n        node_representation: str\n            How nodes are represented. Can either be by 'locations', i.e. numpy arrays,\n            or 'indices', i.e. integers\n        start : Vertex\n            Start vertex.\n        goal : Vertex\n            Goal vertex.\n        verbose : bool\n            If True, print description string.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "params", ",", "verbose", ")", "\n", "\n", "self", ".", "vertices", "=", "vertices", "\n", "assert", "node_representation", "in", "[", "\"locations\"", ",", "\"indices\"", "]", "\n", "if", "node_representation", "==", "\"indices\"", ":", "\n", "            ", "assert", "edge_to_position", "is", "not", "None", "\n", "", "self", ".", "edge_to_position", "=", "edge_to_position", "\n", "self", ".", "node_representation", "=", "node_representation", "\n", "self", ".", "start", "=", "start", "\n", "self", ".", "goal", "=", "goal", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.set_params": [[61, 69], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"Dijkstras\"", ")", "\n", "self", ".", "params", ".", "cost_func", "=", "getattr", "(", "params", ",", "\"cost_func\"", ",", "lambda", "u", ",", "v", ":", "0", ")", "\n", "self", ".", "params", ".", "true_cost", "=", "getattr", "(", "params", ",", "\"true_cost\"", ",", "lambda", "u", ",", "v", ":", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.initialize": [[70, 86], ["super().initialize", "float", "float", "range", "range", "range", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize algorithm, reset execution path.\"\"\"", "\n", "super", "(", ")", ".", "initialize", "(", ")", "\n", "\n", "# Set up Dijkstra's", "\n", "self", ".", "explored", "=", "[", "False", "for", "_", "in", "range", "(", "len", "(", "self", ".", "vertices", ")", ")", "]", "\n", "self", ".", "min_cost", "=", "[", "float", "(", "\"inf\"", ")", "for", "_", "in", "range", "(", "len", "(", "self", ".", "vertices", ")", ")", "]", "\n", "self", ".", "prev", "=", "[", "None", "for", "_", "in", "range", "(", "len", "(", "self", ".", "vertices", ")", ")", "]", "\n", "self", ".", "to_explore", "=", "[", "(", "0", ",", "self", ".", "start", ")", "]", "# initialize priority queue", "\n", "self", ".", "num_expansions", "=", "0", "\n", "self", ".", "num_queries", "=", "0", "\n", "self", ".", "best_cost", "=", "float", "(", "\"inf\"", ")", "\n", "self", ".", "best_path", "=", "[", "]", "\n", "self", ".", "current", "=", "None", "\n", "self", ".", "curr_neigh_idx", "=", "0", "\n", "self", ".", "do_after_query", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_next_x": [[87, 124], ["heapq.heappop", "dijkstra.Dijkstra.get_next_edge", "dijkstra.Dijkstra.after_query", "dijkstra.Dijkstra.get_next_edge", "len", "dijkstra.Dijkstra.finish_algorithm", "print"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_next_edge", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.after_query", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_next_edge", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.finish_algorithm"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "while", "True", ":", "\n", "# Complete post-query todos", "\n", "# if self.num_queries > 0:", "\n", "            ", "if", "self", ".", "do_after_query", ":", "\n", "                ", "self", ".", "after_query", "(", ")", "\n", "\n", "# If self.current exists, do next step in self.current.neighbors loop", "\n", "", "if", "self", ".", "current", "is", "not", "None", ":", "\n", "                ", "return", "self", ".", "get_next_edge", "(", ")", "\n", "\n", "# If algorithm is already complete, return None", "\n", "", "if", "len", "(", "self", ".", "to_explore", ")", "==", "0", ":", "\n", "                ", "if", "not", "self", ".", "best_path", ":", "\n", "                    ", "print", "(", "\"No path exists to goal\"", ")", "\n", "", "return", "None", "\n", "\n", "# If self.current does not exist, set self.current and other variables", "\n", "", "self", ".", "best_cost", ",", "self", ".", "current", "=", "heapq", ".", "heappop", "(", "self", ".", "to_explore", ")", "\n", "if", "self", ".", "explored", "[", "self", ".", "current", ".", "index", "]", ":", "\n", "# the same node could appear in the pqueue multiple times with different costs", "\n", "                ", "self", ".", "current", "=", "None", "\n", "continue", "\n", "", "self", ".", "explored", "[", "self", ".", "current", ".", "index", "]", "=", "True", "\n", "self", ".", "num_expansions", "+=", "1", "\n", "\n", "# If algorithm completes here, return None", "\n", "if", "self", ".", "current", ".", "index", "==", "self", ".", "goal", ".", "index", ":", "\n", "                ", "self", ".", "finish_algorithm", "(", ")", "\n", "return", "None", "\n", "\n", "# Otherwise, run current_step()", "\n", "", "return", "self", ".", "get_next_edge", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_next_edge": [[125, 142], ["RuntimeError"], "methods", ["None"], ["", "", "def", "get_next_edge", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return next edge. Assumes self.current is not None.\"\"\"", "\n", "self", ".", "num_queries", "+=", "1", "\n", "if", "self", ".", "node_representation", "==", "\"locations\"", ":", "\n", "            ", "current_pos", "=", "self", ".", "current", ".", "position", "\n", "neighbor_pos", "=", "self", ".", "current", ".", "neighbors", "[", "self", ".", "curr_neigh_idx", "]", ".", "position", "\n", "next_edge_pos", "=", "(", "current_pos", "+", "neighbor_pos", ")", "/", "2", "\n", "", "elif", "self", ".", "node_representation", "==", "\"indices\"", ":", "\n", "            ", "cur_i", "=", "self", ".", "current", ".", "index", "\n", "nei_i", "=", "self", ".", "current", ".", "neighbors", "[", "self", ".", "curr_neigh_idx", "]", ".", "index", "\n", "next_edge_pos", "=", "self", ".", "edge_to_position", "[", "(", "cur_i", ",", "nei_i", ")", "]", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\n", "f\"Node representation {self.node_representation} not supported\"", "\n", ")", "\n", "", "self", ".", "do_after_query", "=", "True", "\n", "return", "next_edge_pos", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.after_query": [[143, 166], ["numpy.log1p", "numpy.exp", "heapq.heappush", "len"], "methods", ["None"], ["", "def", "after_query", "(", "self", ")", ":", "\n", "        ", "\"\"\"To do after an edge has been queried.\"\"\"", "\n", "last_edge_y", "=", "self", ".", "exe_path", ".", "y", "[", "-", "1", "]", "\n", "step_cost", "=", "np", ".", "log1p", "(", "np", ".", "exp", "(", "last_edge_y", ")", ")", "\n", "assert", "step_cost", ">=", "0", "\n", "neighbor", "=", "self", ".", "current", ".", "neighbors", "[", "self", ".", "curr_neigh_idx", "]", "\n", "self", ".", "curr_neigh_idx", "+=", "1", "\n", "\n", "if", "(", "not", "self", ".", "explored", "[", "neighbor", ".", "index", "]", ")", "and", "(", "\n", "self", ".", "best_cost", "+", "step_cost", "<", "self", ".", "min_cost", "[", "neighbor", ".", "index", "]", "\n", ")", ":", "\n", "# Push by cost", "\n", "            ", "heapq", ".", "heappush", "(", "self", ".", "to_explore", ",", "(", "self", ".", "best_cost", "+", "step_cost", ",", "neighbor", ")", ")", "\n", "self", ".", "min_cost", "[", "neighbor", ".", "index", "]", "=", "self", ".", "best_cost", "+", "step_cost", "\n", "self", ".", "prev", "[", "neighbor", ".", "index", "]", "=", "self", ".", "current", ".", "index", "\n", "\n", "# Unset do_after_query", "\n", "", "self", ".", "do_after_query", "=", "False", "\n", "\n", "# Possibly set self.current to None and self.curr_neigh_idx back to 0", "\n", "if", "self", ".", "curr_neigh_idx", ">=", "len", "(", "self", ".", "current", ".", "neighbors", ")", ":", "\n", "            ", "self", ".", "current", "=", "None", "\n", "self", ".", "curr_neigh_idx", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.finish_algorithm": [[167, 184], ["print", "dijkstra.Dijkstra.finish_algorithm.print_true_cost_of_path"], "methods", ["None"], ["", "", "def", "finish_algorithm", "(", "self", ")", ":", "\n", "        ", "\"\"\"To do if algorithm completes.\"\"\"", "\n", "print", "(", "\n", "f\"Found goal after {self.num_expansions} expansions and \"", "\n", "f\"{self.num_queries} queries with estimated cost {self.best_cost}\"", "\n", ")", "\n", "self", ".", "best_path", "=", "[", "\n", "self", ".", "vertices", "[", "i", "]", "for", "i", "in", "backtrack_indices", "(", "self", ".", "current", ".", "index", ",", "self", ".", "prev", ")", "\n", "]", "\n", "\n", "def", "print_true_cost_of_path", "(", "path", ")", ":", "\n", "            ", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "                ", "cost", "+=", "self", ".", "params", ".", "true_cost", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "[", "0", "]", "\n", "", "print", "(", "f\"True cost: {cost}\"", ")", "\n", "\n", "", "print_true_cost_of_path", "(", "self", ".", "best_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.run_algorithm_on_f_standalone": [[185, 251], ["argparse.Namespace", "dijkstra.Dijkstra.run_algorithm_on_f_standalone.dijkstras"], "methods", ["None"], ["", "def", "run_algorithm_on_f_standalone", "(", "self", ",", "f", ")", ":", "\n", "\n", "# prevent parallel processes from sharing random state", "\n", "# np.random.seed()", "\n", "\n", "        ", "def", "dijkstras", "(", "start", ":", "Vertex", ",", "goal", ":", "Vertex", ")", ":", "\n", "            ", "\"\"\"Dijkstra's algorithm.\"\"\"", "\n", "explored", "=", "[", "False", "for", "_", "in", "range", "(", "len", "(", "self", ".", "vertices", ")", ")", "]", "\n", "min_cost", "=", "[", "float", "(", "\"inf\"", ")", "for", "_", "in", "range", "(", "len", "(", "self", ".", "vertices", ")", ")", "]", "\n", "prev", "=", "[", "None", "for", "_", "in", "range", "(", "len", "(", "self", ".", "vertices", ")", ")", "]", "\n", "to_explore", "=", "[", "(", "0", ",", "start", ")", "]", "# initialize priority queue", "\n", "num_expansions", "=", "0", "\n", "num_queries", "=", "0", "\n", "\n", "while", "len", "(", "to_explore", ")", ">", "0", ":", "\n", "                ", "best_cost", ",", "current", "=", "heapq", ".", "heappop", "(", "to_explore", ")", "\n", "if", "explored", "[", "current", ".", "index", "]", ":", "\n", "# the same node could appear in the pqueue multiple times with different costs", "\n", "                    ", "continue", "\n", "", "explored", "[", "current", ".", "index", "]", "=", "True", "\n", "num_expansions", "+=", "1", "\n", "if", "current", ".", "index", "==", "goal", ".", "index", ":", "\n", "                    ", "print", "(", "\n", "f\"Found goal after {num_expansions} expansions and {num_queries} queries with estimated cost {best_cost}\"", "\n", ")", "\n", "best_path", "=", "[", "\n", "self", ".", "vertices", "[", "i", "]", "for", "i", "in", "backtrack_indices", "(", "current", ".", "index", ",", "prev", ")", "\n", "]", "\n", "\n", "def", "true_cost_of_path", "(", "path", ")", ":", "\n", "                        ", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "                            ", "cost", "+=", "self", ".", "params", ".", "true_cost", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "[", "0", "]", "\n", "", "print", "(", "\"true cost\"", ",", "cost", ")", "\n", "\n", "", "true_cost_of_path", "(", "best_path", ")", "\n", "return", "best_cost", ",", "best_path", "\n", "\n", "", "for", "neighbor", "in", "current", ".", "neighbors", ":", "\n", "                    ", "num_queries", "+=", "1", "\n", "step_cost", "=", "distance", "(", "current", ",", "neighbor", ")", "\n", "if", "(", "not", "explored", "[", "neighbor", ".", "index", "]", ")", "and", "(", "\n", "best_cost", "+", "step_cost", "<", "min_cost", "[", "neighbor", ".", "index", "]", "\n", ")", ":", "\n", "                        ", "heapq", ".", "heappush", "(", "\n", "to_explore", ",", "(", "best_cost", "+", "step_cost", ",", "neighbor", ")", "\n", ")", "# push by cost", "\n", "min_cost", "[", "neighbor", ".", "index", "]", "=", "best_cost", "+", "step_cost", "\n", "prev", "[", "neighbor", ".", "index", "]", "=", "current", ".", "index", "\n", "\n", "", "", "", "print", "(", "\"No path exists to goal\"", ")", "\n", "return", "float", "(", "\"inf\"", ")", ",", "[", "]", "\n", "\n", "", "exe_path", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "\n", "def", "distance", "(", "u", ":", "Vertex", ",", "v", ":", "Vertex", ")", ":", "\n", "            ", "cost", ",", "xs", ",", "ys", "=", "self", ".", "params", ".", "cost_func", "(", "u", ",", "v", ",", "f", ")", "\n", "\n", "exe_path", ".", "x", ".", "extend", "(", "xs", ")", "\n", "exe_path", ".", "y", ".", "extend", "(", "ys", ")", "\n", "assert", "cost", ">=", "0", "\n", "return", "cost", "\n", "\n", "", "min_cost", "=", "dijkstras", "(", "self", ".", "start", ",", "self", ".", "goal", ")", "\n", "\n", "return", "exe_path", ",", "min_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_exe_path_crop": [[252, 286], ["argparse.Namespace", "dijkstra.Dijkstra.get_output", "range", "argparse.Namespace.x.append", "next", "argparse.Namespace.y.append", "len", "RuntimeError", "enumerate", "all"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_output"], ["", "def", "get_exe_path_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the minimal execution path for output, i.e. cropped execution path,\n        specific to this algorithm.\n        \"\"\"", "\n", "exe_path_crop", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "\n", "_", ",", "best_path", "=", "self", ".", "get_output", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "best_path", ")", "-", "1", ")", ":", "\n", "            ", "if", "self", ".", "node_representation", "==", "\"locations\"", ":", "\n", "                ", "vec_start_pos", "=", "best_path", "[", "i", "]", ".", "position", "\n", "vec_end_pos", "=", "best_path", "[", "i", "+", "1", "]", ".", "position", "\n", "edge_pos", "=", "(", "vec_start_pos", "+", "vec_end_pos", ")", "/", "2.0", "\n", "", "elif", "self", ".", "node_representation", "==", "\"indices\"", ":", "\n", "                ", "vec_start", "=", "best_path", "[", "i", "]", ".", "index", "\n", "vec_end", "=", "best_path", "[", "i", "+", "1", "]", ".", "index", "\n", "edge_pos", "=", "self", ".", "edge_to_position", "[", "(", "vec_start", ",", "vec_end", ")", "]", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "f\"Node representation {self.node_representation} not supported\"", "\n", ")", "\n", "\n", "", "exe_path_crop", ".", "x", ".", "append", "(", "edge_pos", ")", "\n", "idx", ",", "pos", "=", "next", "(", "\n", "(", "\n", "tup", "\n", "for", "tup", "in", "enumerate", "(", "self", ".", "exe_path", ".", "x", ")", "\n", "if", "all", "(", "tup", "[", "1", "]", "==", "edge_pos", ")", "\n", "# if np.allclose(tup[1], edge_pos)", "\n", ")", "\n", ")", "\n", "exe_path_crop", ".", "y", ".", "append", "(", "self", ".", "exe_path", ".", "y", "[", "idx", "]", ")", "\n", "\n", "", "return", "exe_path_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_copy": [[287, 312], ["copy.deepcopy"], "methods", ["None"], ["", "def", "get_copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of this algorithm.\"\"\"", "\n", "# Cache the three Vertex attributes", "\n", "vertices", "=", "self", ".", "vertices", "\n", "start", "=", "self", ".", "start", "\n", "goal", "=", "self", ".", "goal", "\n", "\n", "# Delete the three Vertex attributes", "\n", "del", "self", ".", "vertices", "\n", "del", "self", ".", "start", "\n", "del", "self", ".", "goal", "\n", "\n", "# Copy the rest of this object then define the three Vertex attributes", "\n", "algo_copy", "=", "copy", ".", "deepcopy", "(", "self", ")", "\n", "algo_copy", ".", "vertices", "=", "vertices", "\n", "algo_copy", ".", "start", "=", "start", "\n", "algo_copy", ".", "goal", "=", "goal", "\n", "\n", "# Re-define the three Vertex attributes in this object", "\n", "self", ".", "vertices", "=", "vertices", "\n", "self", ".", "start", "=", "start", "\n", "self", ".", "goal", "=", "goal", "\n", "\n", "# Return the copy", "\n", "return", "algo_copy", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_output": [[313, 316], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return best path.\"\"\"", "\n", "return", "self", ".", "best_cost", ",", "self", ".", "best_path", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_output_dist_fn_path_cost": [[317, 330], ["numpy.array", "numpy.array", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "get_output_dist_fn_path_cost", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return distance function (based on difference in cost of shortest path) for\n        pairs of outputs.\n        \"\"\"", "\n", "\n", "# Default dist_fn casts outputs to arrays and returns Euclidean distance", "\n", "def", "dist_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "a_arr", "=", "np", ".", "array", "(", "a", "[", "0", "]", ")", "\n", "b_arr", "=", "np", ".", "array", "(", "b", "[", "0", "]", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "a_arr", "-", "b_arr", ")", "\n", "\n", "", "return", "dist_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.dijkstra.Dijkstra.get_output_dist_fn": [[331, 350], ["util.graph.edges_of_path", "util.graph.edges_of_path", "tuple", "tuple", "util.graph.jaccard_similarity", "list", "list", "list", "list"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.edges_of_path", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.edges_of_path", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.jaccard_similarity"], ["", "def", "get_output_dist_fn", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return distance function (based on overlap of edges in shortest path) for pairs\n        of outputs.\n        \"\"\"", "\n", "\n", "# Default dist_fn casts outputs to arrays and returns Euclidean distance", "\n", "def", "dist_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "edges_a", "=", "edges_of_path", "(", "a", "[", "1", "]", ")", "\n", "edges_b", "=", "edges_of_path", "(", "b", "[", "1", "]", ")", "\n", "\n", "# convert to list of hashable types", "\n", "edges_a", "=", "[", "tuple", "(", "list", "(", "e", "[", "0", "]", ")", "+", "list", "(", "e", "[", "1", "]", ")", ")", "for", "e", "in", "edges_a", "]", "\n", "edges_b", "=", "[", "tuple", "(", "list", "(", "e", "[", "0", "]", ")", "+", "list", "(", "e", "[", "1", "]", ")", ")", "for", "e", "in", "edges_b", "]", "\n", "\n", "dist", "=", "1", "-", "jaccard_similarity", "(", "edges_a", ",", "edges_b", ")", "\n", "return", "dist", "\n", "\n", "", "return", "dist_fn", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.set_params": [[19, 24], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"Algorithm\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.initialize": [[25, 28], ["argparse.Namespace"], "methods", ["None"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize algorithm, reset execution path.\"\"\"", "\n", "self", ".", "exe_path", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_next_x": [[29, 37], ["numpy.random.uniform", "len"], "methods", ["None"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "# Default behavior: return a uniform random value 10 times", "\n", "next_x", "=", "np", ".", "random", ".", "uniform", "(", ")", "if", "len", "(", "self", ".", "exe_path", ".", "x", ")", "<", "10", "else", "None", "\n", "return", "next_x", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.take_step": [[38, 47], ["algorithms.Algorithm.get_next_x", "f", "algorithms.Algorithm.exe_path.x.append", "algorithms.Algorithm.exe_path.y.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_next_x"], ["", "def", "take_step", "(", "self", ",", "f", ")", ":", "\n", "        ", "\"\"\"Take one step of the algorithm.\"\"\"", "\n", "x", "=", "self", ".", "get_next_x", "(", ")", "\n", "if", "x", "is", "not", "None", ":", "\n", "            ", "y", "=", "f", "(", "x", ")", "\n", "self", ".", "exe_path", ".", "x", ".", "append", "(", "x", ")", "\n", "self", ".", "exe_path", ".", "y", ".", "append", "(", "y", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.run_algorithm_on_f": [[48, 62], ["algorithms.Algorithm.initialize", "algorithms.Algorithm.take_step", "algorithms.Algorithm.take_step", "algorithms.Algorithm.get_output"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.take_step", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.take_step", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_output"], ["", "def", "run_algorithm_on_f", "(", "self", ",", "f", ")", ":", "\n", "        ", "\"\"\"\n        Run the algorithm by sequentially querying function f. Return the execution path\n        and output.\n        \"\"\"", "\n", "self", ".", "initialize", "(", ")", "\n", "\n", "# Step through algorithm", "\n", "x", "=", "self", ".", "take_step", "(", "f", ")", "\n", "while", "x", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "take_step", "(", "f", ")", "\n", "\n", "# Return execution path and output", "\n", "", "return", "self", ".", "exe_path", ",", "self", ".", "get_output", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_exe_path_crop": [[63, 70], ["None"], "methods", ["None"], ["", "def", "get_exe_path_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the minimal execution path for output, i.e. cropped execution path,\n        specific to this algorithm.\n        \"\"\"", "\n", "# As default, return untouched execution path", "\n", "return", "self", ".", "exe_path", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_copy": [[71, 74], ["copy.deepcopy"], "methods", ["None"], ["", "def", "get_copy", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return a copy of this algorithm.\"\"\"", "\n", "return", "copy", ".", "deepcopy", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_output": [[75, 79], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_output_dist_fn": [[80, 90], ["numpy.array", "numpy.array", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "get_output_dist_fn", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return distance function for pairs of outputs.\"\"\"", "\n", "\n", "# Default dist_fn casts outputs to arrays and returns Euclidean distance", "\n", "def", "dist_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "a_arr", "=", "np", ".", "array", "(", "a", ")", "\n", "b_arr", "=", "np", ".", "array", "(", "b", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "a_arr", "-", "b_arr", ")", "\n", "\n", "", "return", "dist_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.FixedPathAlgorithm.set_params": [[97, 104], ["algorithms.Algorithm.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"FixedPathAlgorithm\"", ")", "\n", "self", ".", "params", ".", "x_path", "=", "getattr", "(", "params", ",", "\"x_path\"", ",", "[", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.FixedPathAlgorithm.get_next_x": [[105, 114], ["len", "len"], "methods", ["None"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "len_path", "=", "len", "(", "self", ".", "exe_path", ".", "x", ")", "\n", "x_path", "=", "self", ".", "params", ".", "x_path", "\n", "next_x", "=", "x_path", "[", "len_path", "]", "if", "len_path", "<", "len", "(", "x_path", ")", "else", "None", "\n", "return", "next_x", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.FixedPathAlgorithm.get_output": [[115, 119], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "# Default behavior: return execution path", "\n", "return", "self", ".", "exe_path", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.FixedPathAlgorithm.set_print_params": [[120, 124], ["super().set_print_params", "delattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScanRandGap.set_print_params"], ["", "def", "set_print_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set self.print_params.\"\"\"", "\n", "super", "(", ")", ".", "set_print_params", "(", ")", "\n", "delattr", "(", "self", ".", "print_params", ",", "\"x_path\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScan.set_params": [[132, 138], ["algorithms.FixedPathAlgorithm.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"LinearScan\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScan.get_output": [[139, 142], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return algorithm output given the execution path.\"\"\"", "\n", "return", "self", ".", "exe_path", ".", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScanRandGap.set_params": [[151, 158], ["algorithms.LinearScan.set_params", "util.misc_util.dict_to_namespace", "getattr", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"LinearScanRandGap\"", ")", "\n", "self", ".", "params", ".", "x_path_orig", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ".", "x_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScanRandGap.run_algorithm_on_f": [[159, 176], ["copy.deepcopy", "len", "numpy.ceil", "numpy.ceil", "numpy.random.randint", "numpy.min", "numpy.max", "algorithms.Algorithm.run_algorithm_on_f", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Noop.run_algorithm_on_f"], ["", "def", "run_algorithm_on_f", "(", "self", ",", "f", ")", ":", "\n", "        ", "\"\"\"\n        Run the algorithm by sequentially querying function f. Return the execution path\n        and output.\n        \"\"\"", "\n", "x_path", "=", "copy", ".", "deepcopy", "(", "self", ".", "params", ".", "x_path_orig", ")", "\n", "n_grid", "=", "len", "(", "x_path", ")", "\n", "rand_factor", "=", "0.2", "\n", "min_gap", "=", "np", ".", "ceil", "(", "(", "1", "-", "rand_factor", ")", "*", "n_grid", ")", "\n", "max_gap", "=", "np", ".", "ceil", "(", "(", "1", "+", "rand_factor", ")", "*", "n_grid", ")", "\n", "new_n_grid", "=", "np", ".", "random", ".", "randint", "(", "min_gap", ",", "max_gap", ")", "\n", "min_x_path", "=", "np", ".", "min", "(", "x_path", ")", "\n", "max_x_path", "=", "np", ".", "max", "(", "x_path", ")", "\n", "new_x_path", "=", "[", "[", "x", "]", "for", "x", "in", "np", ".", "linspace", "(", "min_x_path", ",", "max_x_path", ",", "new_n_grid", ")", "]", "\n", "self", ".", "params", ".", "x_path", "=", "new_x_path", "\n", "\n", "return", "super", "(", ")", ".", "run_algorithm_on_f", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScanRandGap.set_print_params": [[177, 181], ["algorithms.FixedPathAlgorithm.set_print_params", "delattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.LinearScanRandGap.set_print_params"], ["", "def", "set_print_params", "(", "self", ")", ":", "\n", "        ", "\"\"\"Set self.print_params.\"\"\"", "\n", "super", "(", ")", ".", "set_print_params", "(", ")", "\n", "delattr", "(", "self", ".", "print_params", ",", "\"x_path_orig\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AverageOutputs.set_params": [[188, 194], ["algorithms.FixedPathAlgorithm.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"AverageOutputs\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AverageOutputs.get_output": [[195, 198], ["numpy.mean"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "return", "np", ".", "mean", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.SortOutputs.set_params": [[205, 211], ["algorithms.FixedPathAlgorithm.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"SortOutputs\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.SortOutputs.get_output": [[212, 215], ["numpy.argsort"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "return", "np", ".", "argsort", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.OptRightScan.set_params": [[223, 234], ["algorithms.Algorithm.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"OptRightScan\"", ")", "\n", "self", ".", "params", ".", "init_x", "=", "getattr", "(", "params", ",", "\"init_x\"", ",", "[", "4.0", "]", ")", "\n", "self", ".", "params", ".", "x_grid_gap", "=", "getattr", "(", "params", ",", "\"x_grid_gap\"", ",", "0.1", ")", "\n", "self", ".", "params", ".", "conv_thresh", "=", "getattr", "(", "params", ",", "\"conv_thresh\"", ",", "0.2", ")", "\n", "self", ".", "params", ".", "max_iter", "=", "getattr", "(", "params", ",", "\"max_iter\"", ",", "100", ")", "\n", "self", ".", "params", ".", "crop_str", "=", "getattr", "(", "params", ",", "\"crop_str\"", ",", "\"min\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.OptRightScan.get_next_x": [[235, 256], ["len", "numpy.min"], "methods", ["None"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "len_path", "=", "len", "(", "self", ".", "exe_path", ".", "x", ")", "\n", "if", "len_path", "==", "0", ":", "\n", "            ", "next_x", "=", "self", ".", "params", ".", "init_x", "\n", "", "else", ":", "\n", "            ", "next_x", "=", "[", "self", ".", "exe_path", ".", "x", "[", "-", "1", "]", "[", "0", "]", "+", "self", ".", "params", ".", "x_grid_gap", "]", "\n", "\n", "", "if", "len_path", ">=", "2", ":", "\n", "            ", "conv_max_val", "=", "np", ".", "min", "(", "self", ".", "exe_path", ".", "y", "[", ":", "-", "1", "]", ")", "+", "self", ".", "params", ".", "conv_thresh", "\n", "if", "self", ".", "exe_path", ".", "y", "[", "-", "1", "]", ">", "conv_max_val", ":", "\n", "                ", "next_x", "=", "None", "\n", "\n", "# Algorithm also has max number of steps", "\n", "", "", "if", "len_path", ">", "self", ".", "params", ".", "max_iter", ":", "\n", "            ", "next_x", "=", "None", "\n", "\n", "", "return", "next_x", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.OptRightScan.get_exe_path_crop": [[257, 275], ["argparse.Namespace", "numpy.argmin", "argparse.Namespace.x.append", "argparse.Namespace.y.append", "argparse.Namespace.x.extend", "argparse.Namespace.y.extend"], "methods", ["None"], ["", "def", "get_exe_path_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the minimal execution path for output, i.e. cropped execution path,\n        specific to this algorithm.\n        \"\"\"", "\n", "exe_path_crop", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "min_idx", "=", "np", ".", "argmin", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n", "if", "self", ".", "params", ".", "crop_str", "==", "\"min\"", ":", "\n", "            ", "exe_path_crop", ".", "x", ".", "append", "(", "self", ".", "exe_path", ".", "x", "[", "min_idx", "]", ")", "\n", "exe_path_crop", ".", "y", ".", "append", "(", "self", ".", "exe_path", ".", "y", "[", "min_idx", "]", ")", "\n", "", "elif", "self", ".", "params", ".", "crop_str", "==", "\"minplus\"", ":", "\n", "            ", "exe_path_crop", ".", "x", ".", "extend", "(", "self", ".", "exe_path", ".", "x", "[", "min_idx", ":", "]", ")", "\n", "exe_path_crop", ".", "y", ".", "extend", "(", "self", ".", "exe_path", ".", "y", "[", "min_idx", ":", "]", ")", "\n", "", "else", ":", "\n", "            ", "exe_path_crop", "=", "self", ".", "exe_path", "\n", "\n", "", "return", "exe_path_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.OptRightScan.get_output": [[276, 281], ["numpy.argmin"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "min_idx", "=", "np", ".", "argmin", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "min_pair", "=", "[", "self", ".", "exe_path", ".", "x", "[", "min_idx", "]", ",", "self", ".", "exe_path", ".", "y", "[", "min_idx", "]", "]", "\n", "return", "min_pair", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.OptRightScan.get_output_dist_fn": [[282, 291], ["numpy.array", "numpy.array", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "get_output_dist_fn", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return distance function for pairs of outputs.\"\"\"", "\n", "\n", "def", "dist_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "a", "=", "np", ".", "array", "(", "a", "[", "0", "]", "+", "[", "a", "[", "1", "]", "]", ")", "\n", "b", "=", "np", ".", "array", "(", "b", "[", "0", "]", "+", "[", "b", "[", "1", "]", "]", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "a", "-", "b", ")", "\n", "\n", "", "return", "dist_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptValGrid.set_params": [[299, 306], ["algorithms.FixedPathAlgorithm.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"GlobalOptGrid\"", ")", "\n", "self", ".", "params", ".", "opt_mode", "=", "getattr", "(", "params", ",", "\"opt_mode\"", ",", "\"min\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptValGrid.get_exe_path_opt_idx": [[307, 315], ["numpy.argmin", "numpy.argmax"], "methods", ["None"], ["", "def", "get_exe_path_opt_idx", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the index of the optimal point in execution path.\"\"\"", "\n", "if", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmin", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmax", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n", "", "return", "opt_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptValGrid.get_exe_path_crop": [[316, 328], ["algorithms.GlobalOptValGrid.get_exe_path_opt_idx", "argparse.Namespace", "argparse.Namespace.x.append", "argparse.Namespace.y.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx"], ["", "def", "get_exe_path_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the minimal execution path for output, i.e. cropped execution path,\n        specific to this algorithm.\n        \"\"\"", "\n", "opt_idx", "=", "self", ".", "get_exe_path_opt_idx", "(", ")", "\n", "\n", "exe_path_crop", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "exe_path_crop", ".", "x", ".", "append", "(", "self", ".", "exe_path", ".", "x", "[", "opt_idx", "]", ")", "\n", "exe_path_crop", ".", "y", ".", "append", "(", "self", ".", "exe_path", ".", "y", "[", "opt_idx", "]", ")", "\n", "\n", "return", "exe_path_crop", "\n", "#return self.exe_path", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptValGrid.get_output": [[330, 336], ["algorithms.GlobalOptValGrid.get_exe_path_opt_idx"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "opt_idx", "=", "self", ".", "get_exe_path_opt_idx", "(", ")", "\n", "opt_val", "=", "self", ".", "exe_path", ".", "y", "[", "opt_idx", "]", "\n", "\n", "return", "opt_val", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptGrid.get_output": [[344, 355], ["numpy.argmin", "numpy.argmax"], "methods", ["None"], ["def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "if", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmin", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmax", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n", "# Set opt_pair as [list, float]", "\n", "", "opt_pair", "=", "[", "self", ".", "exe_path", ".", "x", "[", "opt_idx", "]", ",", "self", ".", "exe_path", ".", "y", "[", "opt_idx", "]", "]", "\n", "\n", "return", "opt_pair", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptGrid.get_output_dist_fn": [[356, 365], ["numpy.array", "numpy.array", "numpy.linalg.norm"], "methods", ["None"], ["", "def", "get_output_dist_fn", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return distance function for pairs of outputs.\"\"\"", "\n", "\n", "def", "dist_fn", "(", "a", ",", "b", ")", ":", "\n", "            ", "a", "=", "np", ".", "array", "(", "a", "[", "0", "]", "+", "[", "a", "[", "1", "]", "]", ")", "\n", "b", "=", "np", ".", "array", "(", "b", "[", "0", "]", "+", "[", "b", "[", "1", "]", "]", ")", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "a", "-", "b", ")", "\n", "\n", "", "return", "dist_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRandVal.set_params": [[373, 382], ["algorithms.Algorithm.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"GlobalOptUnifRandVal\"", ")", "\n", "self", ".", "params", ".", "opt_mode", "=", "getattr", "(", "params", ",", "\"opt_mode\"", ",", "\"min\"", ")", "\n", "self", ".", "params", ".", "domain", "=", "getattr", "(", "params", ",", "\"domain\"", ",", "[", "[", "0", ",", "10", "]", "]", ")", "\n", "self", ".", "params", ".", "n_samp", "=", "getattr", "(", "params", ",", "\"n_samp\"", ",", "100", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRandVal.get_next_x": [[383, 395], ["len", "util.domain_util.unif_random_sample_domain"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.domain_util.unif_random_sample_domain"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "if", "len", "(", "self", ".", "exe_path", ".", "x", ")", "<", "self", ".", "params", ".", "n_samp", ":", "\n", "# Return a random sample in domain", "\n", "            ", "next_x", "=", "unif_random_sample_domain", "(", "self", ".", "params", ".", "domain", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "next_x", "=", "None", "\n", "\n", "", "return", "next_x", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRandVal.get_opt_idx": [[396, 404], ["numpy.argmin", "numpy.argmax"], "methods", ["None"], ["", "def", "get_opt_idx", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return index of optimal point in self.exe_path.\"\"\"", "\n", "if", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmin", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmax", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n", "", "return", "opt_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRandVal.get_output": [[405, 409], ["algorithms.GlobalOptUnifRandVal.get_opt_idx"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRandVal.get_opt_idx"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "opt_idx", "=", "self", ".", "get_opt_idx", "(", ")", "\n", "return", "self", ".", "exe_path", ".", "y", "[", "opt_idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRand.set_params": [[417, 422], ["algorithms.GlobalOptUnifRandVal.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"GlobalOptUnifRand\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRand.get_output": [[423, 427], ["algorithms.GlobalOptUnifRand.get_opt_idx"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.GlobalOptUnifRandVal.get_opt_idx"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "opt_idx", "=", "self", ".", "get_opt_idx", "(", ")", "\n", "return", "self", ".", "exe_path", ".", "x", "[", "opt_idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.set_params": [[435, 444], ["algorithms.FixedPathAlgorithm.set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"TopK\"", ")", "\n", "self", ".", "params", ".", "opt_mode", "=", "getattr", "(", "params", ",", "\"opt_mode\"", ",", "\"max\"", ")", "\n", "self", ".", "params", ".", "k", "=", "getattr", "(", "params", ",", "\"k\"", ",", "3", ")", "\n", "self", ".", "params", ".", "dist_str", "=", "getattr", "(", "params", ",", "\"dist_str\"", ",", "\"norm\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_exe_path_topk_idx": [[445, 454], ["numpy.argsort", "numpy.array", "numpy.argsort"], "methods", ["None"], ["", "def", "get_exe_path_topk_idx", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the index of the optimal point in execution path.\"\"\"", "\n", "if", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "topk_idx", "=", "np", ".", "argsort", "(", "self", ".", "exe_path", ".", "y", ")", "[", ":", "self", ".", "params", ".", "k", "]", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "            ", "rev_exe_path_y", "=", "-", "np", ".", "array", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "topk_idx", "=", "np", ".", "argsort", "(", "rev_exe_path_y", ")", "[", ":", "self", ".", "params", ".", "k", "]", "\n", "\n", "", "return", "topk_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_exe_path_crop": [[455, 467], ["algorithms.TopK.get_exe_path_topk_idx", "argparse.Namespace"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_exe_path_topk_idx"], ["", "def", "get_exe_path_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the minimal execution path for output, i.e. cropped execution path,\n        specific to this algorithm.\n        \"\"\"", "\n", "topk_idx", "=", "self", ".", "get_exe_path_topk_idx", "(", ")", "\n", "\n", "exe_path_crop", "=", "Namespace", "(", ")", "\n", "exe_path_crop", ".", "x", "=", "[", "self", ".", "exe_path", ".", "x", "[", "idx", "]", "for", "idx", "in", "topk_idx", "]", "\n", "exe_path_crop", ".", "y", "=", "[", "self", ".", "exe_path", ".", "y", "[", "idx", "]", "for", "idx", "in", "topk_idx", "]", "\n", "\n", "return", "exe_path_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_output": [[468, 477], ["algorithms.TopK.get_exe_path_topk_idx", "argparse.Namespace"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_exe_path_topk_idx"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "topk_idx", "=", "self", ".", "get_exe_path_topk_idx", "(", ")", "\n", "\n", "out_ns", "=", "Namespace", "(", ")", "\n", "out_ns", ".", "x", "=", "[", "self", ".", "exe_path", ".", "x", "[", "idx", "]", "for", "idx", "in", "topk_idx", "]", "\n", "out_ns", ".", "y", "=", "[", "self", ".", "exe_path", ".", "y", "[", "idx", "]", "for", "idx", "in", "topk_idx", "]", "\n", "\n", "return", "out_ns", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.get_output_dist_fn": [[478, 486], ["None"], "methods", ["None"], ["", "def", "get_output_dist_fn", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return distance function for pairs of outputs.\"\"\"", "\n", "if", "self", ".", "params", ".", "dist_str", "==", "\"norm\"", ":", "\n", "            ", "dist_fn", "=", "self", ".", "output_dist_fn_norm", "\n", "", "elif", "self", ".", "params", ".", "dist_str", "==", "\"jaccard\"", ":", "\n", "            ", "dist_fn", "=", "self", ".", "output_dist_fn_jaccard", "\n", "\n", "", "return", "dist_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.output_dist_fn_norm": [[487, 500], ["list", "a_list.extend", "numpy.array", "list", "b_list.extend", "numpy.array", "numpy.linalg.norm", "map", "map"], "methods", ["None"], ["", "def", "output_dist_fn_norm", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "\"\"\"Output dist_fn based on concatenated vector norm.\"\"\"", "\n", "a_list", "=", "[", "]", "\n", "list", "(", "map", "(", "a_list", ".", "extend", ",", "a", ".", "x", ")", ")", "\n", "a_list", ".", "extend", "(", "a", ".", "y", ")", "\n", "a_arr", "=", "np", ".", "array", "(", "a_list", ")", "\n", "\n", "b_list", "=", "[", "]", "\n", "list", "(", "map", "(", "b_list", ".", "extend", ",", "b", ".", "x", ")", ")", "\n", "b_list", ".", "extend", "(", "b", ".", "y", ")", "\n", "b_arr", "=", "np", ".", "array", "(", "b_list", ")", "\n", "\n", "return", "np", ".", "linalg", ".", "norm", "(", "a_arr", "-", "b_arr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.TopK.output_dist_fn_jaccard": [[501, 508], ["util.graph.jaccard_similarity", "tuple", "tuple"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.jaccard_similarity"], ["", "def", "output_dist_fn_jaccard", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "\"\"\"Output dist_fn based on Jaccard similarity.\"\"\"", "\n", "a_x_tup", "=", "[", "tuple", "(", "x", ")", "for", "x", "in", "a", ".", "x", "]", "\n", "b_x_tup", "=", "[", "tuple", "(", "x", ")", "for", "x", "in", "b", ".", "x", "]", "\n", "jac_sim", "=", "jaccard_similarity", "(", "a_x_tup", ",", "b_x_tup", ")", "\n", "dist", "=", "1", "-", "jac_sim", "\n", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Noop.set_params": [[513, 518], ["algorithms.Algorithm.set_params", "util.misc_util.dict_to_namespace", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"Noop\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Noop.run_algorithm_on_f": [[519, 535], ["numpy.random.seed", "algorithms.Noop.initialize", "random.randint", "numpy.random.rand", "print", "time.sleep", "print"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize"], ["", "def", "run_algorithm_on_f", "(", "self", ",", "f", ")", ":", "\n", "        ", "\"\"\"\n        Run the dummy noop algorithm. Note that we must reseed each time or else child\n        process will have the same state as parent, resulting in the same randomness.\n        \"\"\"", "\n", "np", ".", "random", ".", "seed", "(", ")", "\n", "self", ".", "initialize", "(", ")", "\n", "\n", "output", "=", "0", "\n", "wait_time", "=", "random", ".", "randint", "(", "1", ",", "5", ")", "\n", "rand", "=", "np", ".", "random", ".", "rand", "(", "1", ")", "\n", "print", "(", "f\"Got {rand}. Going to wait for {wait_time} seconds\"", ")", "\n", "time", ".", "sleep", "(", "wait_time", ")", "\n", "print", "(", "f\"Finished waiting for {wait_time} seconds\"", ")", "\n", "\n", "return", "self", ".", "exe_path", ",", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Noop.get_output": [[536, 539], ["RuntimeError"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "raise", "RuntimeError", "(", "\"Can't return output from execution path for Noop\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AlgorithmSet.__init__": [[544, 547], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "algo", ")", ":", "\n", "        ", "\"\"\"Set self.algo as an Algorithm.\"\"\"", "\n", "self", ".", "algo", "=", "algo", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AlgorithmSet.run_algorithm_on_f_list": [[548, 582], ["any", "algorithms.AlgorithmSet.algo.get_copy", "algo.initialize", "algo.get_next_x", "f_list", "zip", "algo.get_output", "range", "x_list_new.append", "algo.exe_path.x.append", "algo.exe_path.y.append", "algo.get_next_x"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Algorithm.get_copy", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_next_x", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_output", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_next_x"], ["", "def", "run_algorithm_on_f_list", "(", "self", ",", "f_list", ",", "n_f", ")", ":", "\n", "        ", "\"\"\"\n        Run the algorithm by sequentially querying f_list, which calls a list of n_f\n        functions given an x_list of n_f inputs. Return the lists of execution paths and\n        outputs.\n        \"\"\"", "\n", "algo_list", "=", "[", "self", ".", "algo", ".", "get_copy", "(", ")", "for", "_", "in", "range", "(", "n_f", ")", "]", "\n", "\n", "# Initialize each algo in list", "\n", "for", "algo", "in", "algo_list", ":", "\n", "            ", "algo", ".", "initialize", "(", ")", "\n", "\n", "# Step through algorithms", "\n", "", "x_list", "=", "[", "algo", ".", "get_next_x", "(", ")", "for", "algo", "in", "algo_list", "]", "\n", "while", "any", "(", "x", "is", "not", "None", "for", "x", "in", "x_list", ")", ":", "\n", "            ", "y_list", "=", "f_list", "(", "x_list", ")", "\n", "x_list_new", "=", "[", "]", "\n", "for", "algo", ",", "x", ",", "y", "in", "zip", "(", "algo_list", ",", "x_list", ",", "y_list", ")", ":", "\n", "                ", "if", "x", "is", "not", "None", ":", "\n", "                    ", "algo", ".", "exe_path", ".", "x", ".", "append", "(", "x", ")", "\n", "algo", ".", "exe_path", ".", "y", ".", "append", "(", "y", ")", "\n", "x_next", "=", "algo", ".", "get_next_x", "(", ")", "\n", "", "else", ":", "\n", "                    ", "x_next", "=", "None", "\n", "", "x_list_new", ".", "append", "(", "x_next", ")", "\n", "", "x_list", "=", "x_list_new", "\n", "\n", "# Store algo_list", "\n", "", "self", ".", "algo_list", "=", "algo_list", "\n", "\n", "# Collect exe_path_list and output_list", "\n", "exe_path_list", "=", "[", "algo", ".", "exe_path", "for", "algo", "in", "algo_list", "]", "\n", "output_list", "=", "[", "algo", ".", "get_output", "(", ")", "for", "algo", "in", "algo_list", "]", "\n", "return", "exe_path_list", ",", "output_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AlgorithmSet.get_exe_path_list_crop": [[583, 591], ["algo.get_exe_path_crop", "exe_path_list_crop.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_crop"], ["", "def", "get_exe_path_list_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return get_exe_path_crop for each algo in self.algo_list.\"\"\"", "\n", "exe_path_list_crop", "=", "[", "]", "\n", "for", "algo", "in", "self", ".", "algo_list", ":", "\n", "            ", "exe_path_crop", "=", "algo", ".", "get_exe_path_crop", "(", ")", "\n", "exe_path_list_crop", ".", "append", "(", "exe_path_crop", ")", "\n", "\n", "", "return", "exe_path_list_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.AlgorithmSet.crop_exe_path_old": [[592, 602], ["next", "len", "enumerate"], "methods", ["None"], ["", "def", "crop_exe_path_old", "(", "self", ",", "exe_path", ")", ":", "\n", "        ", "\"\"\"Return execution path without any Nones at end.\"\"\"", "\n", "try", ":", "\n", "            ", "final_idx", "=", "next", "(", "i", "for", "i", ",", "x", "in", "enumerate", "(", "exe_path", ".", "x", ")", "if", "x", "==", "None", ")", "\n", "", "except", "StopIteration", ":", "\n", "            ", "final_idx", "=", "len", "(", "exe_path", ".", "x", ")", "\n", "\n", "", "del", "exe_path", ".", "x", "[", "final_idx", ":", "]", "\n", "del", "exe_path", ".", "y", "[", "final_idx", ":", "]", "\n", "return", "exe_path", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.set_params": [[20, 37], ["super().set_params", "util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr", "len", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "\"name\"", ",", "\"EvolutionStrategies\"", ")", "\n", "self", ".", "params", ".", "init_x", "=", "getattr", "(", "params", ",", "\"init_x\"", ",", "[", "0.0", "]", ")", "# TODO: code currently requires init to 0", "\n", "self", ".", "params", ".", "n_population", "=", "getattr", "(", "params", ",", "\"n_population\"", ",", "5", ")", "\n", "self", ".", "params", ".", "n_generation", "=", "getattr", "(", "params", ",", "\"n_generation\"", ",", "3", ")", "\n", "self", ".", "params", ".", "samp_str", "=", "getattr", "(", "params", ",", "\"samp_str\"", ",", "\"cma\"", ")", "\n", "self", ".", "params", ".", "opt_mode", "=", "getattr", "(", "params", ",", "\"opt_mode\"", ",", "\"min\"", ")", "\n", "self", ".", "params", ".", "normal_scale", "=", "getattr", "(", "params", ",", "\"normal_scale\"", ",", "0.5", ")", "\n", "self", ".", "params", ".", "keep_frac", "=", "getattr", "(", "params", ",", "\"keep_frac\"", ",", "0.3", ")", "\n", "self", ".", "params", ".", "domain", "=", "getattr", "(", "params", ",", "\"domain\"", ",", "[", "[", "0", ",", "10", "]", "]", ")", "\n", "self", ".", "params", ".", "n_dim", "=", "len", "(", "self", ".", "params", ".", "init_x", ")", "\n", "self", ".", "params", ".", "n_dim_es", "=", "self", ".", "params", ".", "n_dim", "if", "self", ".", "params", ".", "n_dim", ">", "1", "else", "2", "\n", "self", ".", "params", ".", "crop", "=", "getattr", "(", "params", ",", "\"crop\"", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize": [[38, 61], ["super().initialize", "estool.es.CMAES", "evolution_strategies.SimpleMutator"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.initialize"], ["", "def", "initialize", "(", "self", ")", ":", "\n", "        ", "\"\"\"Initialize algorithm, reset execution path.\"\"\"", "\n", "super", "(", ")", ".", "initialize", "(", ")", "\n", "\n", "# set self.params.sampler and self.params.gen_list", "\n", "if", "self", ".", "params", ".", "samp_str", "==", "'cma'", ":", "\n", "            ", "self", ".", "params", ".", "sampler", "=", "CMAES", "(", "\n", "self", ".", "params", ".", "n_dim_es", ",", "\n", "popsize", "=", "self", ".", "params", ".", "n_population", ",", "\n", "weight_decay", "=", "0.0", ",", "\n", "sigma_init", "=", "0.2", ",", "\n", ")", "\n", "", "elif", "self", ".", "params", ".", "samp_str", "==", "'mut'", ":", "\n", "            ", "self", ".", "params", ".", "sampler", "=", "SimpleMutator", "(", "\n", "n_pop", "=", "self", ".", "params", ".", "n_population", ",", "\n", "init_list", "=", "[", "self", ".", "params", ".", "init_x", "]", ",", "\n", "opt_mode", "=", "self", ".", "params", ".", "opt_mode", ",", "\n", "normal_scale", "=", "self", ".", "params", ".", "normal_scale", ",", "\n", "keep_frac", "=", "self", ".", "params", ".", "keep_frac", ",", "\n", ")", "\n", "\n", "#self.params.gen_list = [self.params.init_x]", "\n", "", "self", ".", "params", ".", "gen_list", "=", "[", "]", "# TODO: figure out initialization", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_next_x": [[62, 83], ["evolution_strategies.EvolutionStrategies.params.gen_list.pop", "len", "len", "evolution_strategies.EvolutionStrategies.params.sampler.ask", "evolution_strategies.EvolutionStrategies.convert_next_gen_list", "evolution_strategies.EvolutionStrategies.project_to_domain", "copy.deepcopy", "evolution_strategies.EvolutionStrategies.params.gen_list.pop", "evolution_strategies.EvolutionStrategies.params.sampler.tell"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.ask", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.convert_next_gen_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.project_to_domain", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.tell"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "return", "self", ".", "params", ".", "gen_list", ".", "pop", "(", "0", ")", "\n", "\n", "", "except", "IndexError", ":", "\n", "            ", "max_iter", "=", "self", ".", "params", ".", "n_population", "*", "self", ".", "params", ".", "n_generation", "\n", "if", "len", "(", "self", ".", "exe_path", ".", "x", ")", "<", "max_iter", ":", "\n", "                ", "if", "len", "(", "self", ".", "exe_path", ".", "y", ")", ":", "\n", "                    ", "self", ".", "params", ".", "sampler", ".", "tell", "(", "self", ".", "exe_path", ".", "y", "[", "-", "self", ".", "params", ".", "n_population", ":", "]", ")", "\n", "\n", "", "next_gen_list", "=", "self", ".", "params", ".", "sampler", ".", "ask", "(", ")", "\n", "next_gen_list", "=", "self", ".", "convert_next_gen_list", "(", "next_gen_list", ")", "\n", "next_gen_list", "=", "self", ".", "project_to_domain", "(", "next_gen_list", ")", "\n", "self", ".", "params", ".", "gen_list", "=", "copy", ".", "deepcopy", "(", "next_gen_list", ")", "\n", "return", "self", ".", "params", ".", "gen_list", ".", "pop", "(", "0", ")", "\n", "", "else", ":", "\n", "                ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.convert_next_gen_list": [[84, 93], ["isinstance", "ngl.tolist.tolist.tolist"], "methods", ["None"], ["", "", "", "def", "convert_next_gen_list", "(", "self", ",", "next_gen_list", ")", ":", "\n", "        ", "\"\"\"Optionally convert format of next_gen_list.\"\"\"", "\n", "ngl", "=", "next_gen_list", "\n", "if", "not", "isinstance", "(", "next_gen_list", ",", "list", ")", ":", "\n", "# Assume numpy array", "\n", "            ", "ngl", "=", "ngl", ".", "tolist", "(", ")", "\n", "", "if", "self", ".", "params", ".", "n_dim", "==", "1", ":", "\n", "            ", "ngl", "=", "[", "[", "ng", "[", "0", "]", "]", "for", "ng", "in", "ngl", "]", "\n", "", "return", "ngl", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.project_to_domain": [[94, 106], ["numpy.array", "range", "numpy.array.tolist"], "methods", ["None"], ["", "def", "project_to_domain", "(", "self", ",", "next_gen_list", ")", ":", "\n", "        ", "\"\"\"Project points in next_gen_list to be within self.params.domain.\"\"\"", "\n", "next_gen_mat", "=", "np", ".", "array", "(", "next_gen_list", ")", "\n", "for", "col_idx", "in", "range", "(", "next_gen_mat", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "dom_ub", "=", "self", ".", "params", ".", "domain", "[", "col_idx", "]", "[", "1", "]", "\n", "dom_lb", "=", "self", ".", "params", ".", "domain", "[", "col_idx", "]", "[", "0", "]", "\n", "col_arr", "=", "next_gen_mat", "[", ":", ",", "col_idx", "]", "\n", "col_arr", "[", "col_arr", ">", "dom_ub", "]", "=", "dom_ub", "\n", "col_arr", "[", "col_arr", "<", "dom_lb", "]", "=", "dom_lb", "\n", "\n", "", "next_gen_list", "=", "next_gen_mat", ".", "tolist", "(", ")", "\n", "return", "next_gen_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx": [[107, 115], ["numpy.argmin", "numpy.argmax"], "methods", ["None"], ["", "def", "get_exe_path_opt_idx", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return the index of the optimal point in execution path.\"\"\"", "\n", "if", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmin", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "            ", "opt_idx", "=", "np", ".", "argmax", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n", "", "return", "opt_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_output": [[116, 121], ["evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Given an execution path, return algorithm output.\"\"\"", "\n", "opt_idx", "=", "self", ".", "get_exe_path_opt_idx", "(", ")", "\n", "\n", "return", "self", ".", "exe_path", ".", "x", "[", "opt_idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_crop": [[122, 137], ["evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx", "argparse.Namespace", "argparse.Namespace.x.append", "argparse.Namespace.y.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.get_exe_path_opt_idx"], ["", "def", "get_exe_path_crop", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the minimal execution path for output, i.e. cropped execution path,\n        specific to this algorithm.\n        \"\"\"", "\n", "opt_idx", "=", "self", ".", "get_exe_path_opt_idx", "(", ")", "\n", "exe_path_crop", "=", "Namespace", "(", "x", "=", "[", "]", ",", "y", "=", "[", "]", ")", "\n", "\n", "if", "self", ".", "params", ".", "crop", ":", "\n", "            ", "exe_path_crop", ".", "x", ".", "append", "(", "self", ".", "exe_path", ".", "x", "[", "opt_idx", "]", ")", "\n", "exe_path_crop", ".", "y", ".", "append", "(", "self", ".", "exe_path", ".", "y", "[", "opt_idx", "]", ")", "\n", "", "else", ":", "\n", "            ", "exe_path_crop", "=", "self", ".", "exe_path", "\n", "\n", "", "return", "exe_path_crop", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.__init__": [[142, 152], ["copy.deepcopy"], "methods", ["None"], ["def", "__init__", "(", "\n", "self", ",", "n_pop", ",", "init_list", ",", "opt_mode", "=", "\"min\"", ",", "normal_scale", "=", "0.5", ",", "keep_frac", "=", "0.3", "\n", ")", ":", "\n", "        ", "\"\"\"Initalize.\"\"\"", "\n", "self", ".", "n_pop", "=", "n_pop", "\n", "self", ".", "gen_list", "=", "copy", ".", "deepcopy", "(", "init_list", ")", "\n", "self", ".", "mut_list", "=", "[", "]", "\n", "self", ".", "opt_mode", "=", "opt_mode", "\n", "self", ".", "normal_scale", "=", "normal_scale", "\n", "self", ".", "keep_frac", "=", "keep_frac", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.ask": [[153, 164], ["numpy.random.randint", "len", "evolution_strategies.SimpleMutator.mutate_single", "new_mut_list.append"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.mutate_single"], ["", "def", "ask", "(", "self", ")", ":", "\n", "        ", "\"\"\"Mutate self.gen_list and return n_pop mutations.\"\"\"", "\n", "gen_idx", "=", "np", ".", "random", ".", "randint", "(", "len", "(", "self", ".", "gen_list", ")", ",", "size", "=", "self", ".", "n_pop", ")", "\n", "new_mut_list", "=", "[", "]", "\n", "for", "i", "in", "gen_idx", ":", "\n", "            ", "mut", "=", "self", ".", "mutate_single", "(", "self", ".", "gen_list", "[", "i", "]", ")", "\n", "new_mut_list", ".", "append", "(", "mut", ")", "\n", "\n", "# Save mutations as self.mut_list and return these", "\n", "", "self", ".", "mut_list", "=", "new_mut_list", "\n", "return", "new_mut_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.mutate_single": [[165, 172], ["numpy.random.normal", "vec_mut.append"], "methods", ["None"], ["", "def", "mutate_single", "(", "self", ",", "vec", ")", ":", "\n", "        ", "\"\"\"Mutate a single vector (stored as a list).\"\"\"", "\n", "vec_mut", "=", "[", "]", "\n", "for", "num", "in", "vec", ":", "\n", "            ", "num_mut", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "num", ",", "scale", "=", "self", ".", "normal_scale", ")", "\n", "vec_mut", ".", "append", "(", "num_mut", ")", "\n", "", "return", "vec_mut", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.SimpleMutator.tell": [[173, 183], ["numpy.argsort", "numpy.array", "int", "len"], "methods", ["None"], ["", "def", "tell", "(", "self", ",", "val_list", ")", ":", "\n", "        ", "\"\"\"Re-make self.gen_list, using val_list (associated with self.mut_list).\"\"\"", "\n", "\n", "# If minimizing, reverse val_list", "\n", "if", "self", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "val_list", "=", "-", "1", "*", "np", ".", "array", "(", "val_list", ")", "\n", "\n", "", "keep_idx", "=", "np", ".", "argsort", "(", "val_list", ")", "[", "int", "(", "(", "1", "-", "self", ".", "keep_frac", ")", "*", "len", "(", "val_list", ")", ")", ":", "]", "\n", "new_gen_list", "=", "[", "self", ".", "mut_list", "[", "i", "]", "for", "i", "in", "keep_idx", "[", ":", ":", "-", "1", "]", "]", "\n", "self", ".", "gen_list", "=", "new_gen_list", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategiesVal.get_output": [[190, 198], ["numpy.min", "numpy.max"], "methods", ["None"], ["def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Given an execution path, return algorithm output.\"\"\"", "\n", "if", "self", ".", "params", ".", "opt_mode", "==", "\"min\"", ":", "\n", "            ", "opt_val", "=", "np", ".", "min", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "", "elif", "self", ".", "params", ".", "opt_mode", "==", "\"max\"", ":", "\n", "            ", "opt_val", "=", "np", ".", "max", "(", "self", ".", "exe_path", ".", "y", ")", "\n", "\n", "", "return", "opt_val", "\n", "", "", ""]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.rosenbrock": [[28, 32], ["None"], "function", ["None"], ["def", "rosenbrock", "(", "x", ",", "y", ",", "a", "=", "1", ",", "b", "=", "100", ")", ":", "\n", "# NOTE rescaled to improve numerics", "\n", "# NOTE min cost path: 1.0527267184880365", "\n", "    ", "return", "1e-2", "*", "(", "(", "a", "-", "x", ")", "**", "2", "+", "b", "*", "(", "y", "-", "x", "**", "2", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.true_f": [[33, 36], ["numpy.array().reshape", "bax_grid10_viz_simple_demo.rosenbrock", "numpy.array"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.rosenbrock"], ["", "def", "true_f", "(", "x_y", ")", ":", "\n", "    ", "x_y", "=", "np", ".", "array", "(", "x_y", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "rosenbrock", "(", "x_y", "[", "...", ",", "0", "]", ",", "x_y", "[", "...", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.inv_softplus": [[37, 39], ["numpy.log", "numpy.exp"], "function", ["None"], ["", "def", "inv_softplus", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "log", "(", "np", ".", "exp", "(", "x", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.true_latent_f": [[41, 43], ["bax_grid10_viz_simple_demo.inv_softplus", "bax_grid10_viz_simple_demo.true_f"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.inv_softplus", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.true_f"], ["", "def", "true_latent_f", "(", "x_y", ")", ":", "\n", "    ", "return", "inv_softplus", "(", "true_f", "(", "x_y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.softplus": [[44, 46], ["numpy.log1p", "numpy.exp"], "function", ["None"], ["", "def", "softplus", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "log1p", "(", "np", ".", "exp", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.cost_func": [[47, 55], ["f", "bax_grid10_viz_simple_demo.softplus"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.softplus"], ["", "def", "cost_func", "(", "u", ",", "v", ",", "f", ",", "latent_f", "=", "True", ")", ":", "\n", "    ", "u_pos", ",", "v_pos", "=", "u", ".", "position", ",", "v", ".", "position", "\n", "edge", "=", "(", "u_pos", "+", "v_pos", ")", "/", "2", "\n", "edge_cost", "=", "f", "(", "edge", ")", "\n", "if", "latent_f", ":", "\n", "        ", "return", "softplus", "(", "edge_cost", ")", ",", "[", "edge", "]", ",", "[", "edge_cost", "]", "\n", "", "else", ":", "\n", "        ", "return", "edge_cost", ",", "[", "edge", "]", ",", "[", "edge_cost", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.cost_of_path": [[56, 61], ["range", "bax_grid10_viz_simple_demo.cost_func", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.cost_func"], ["", "", "def", "cost_of_path", "(", "path", ",", "cost_func", ")", ":", "\n", "    ", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "        ", "cost", "+=", "cost_func", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "\n", "", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.plot_path": [[62, 86], ["bax.util.graph.edges_of_path", "matplotlib.collections.LineCollection", "ax.add_collection", "ax.scatter", "len", "bax.util.graph.positions_of_path"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.edges_of_path", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path"], ["", "def", "plot_path", "(", "\n", "ax", ",", "\n", "path", ",", "\n", "path_color", "=", "(", "0", ",", "0", ",", "0", ",", "1.", ")", ",", "\n", "linewidths", "=", "2", ",", "\n", "linestyle", "=", "\"dotted\"", ",", "\n", "plot_vertices", "=", "False", ",", "\n", "label", "=", "None", ",", "\n", ")", ":", "\n", "# plot path taken", "\n", "    ", "path_lines", "=", "edges_of_path", "(", "path", ")", "\n", "path_lc", "=", "LC", "(", "\n", "path_lines", ",", "\n", "colors", "=", "[", "path_color", "]", "*", "len", "(", "path_lines", ")", ",", "\n", "linewidths", "=", "linewidths", ",", "\n", "linestyle", "=", "linestyle", ",", "\n", "label", "=", "label", ",", "\n", ")", "\n", "ax", ".", "add_collection", "(", "path_lc", ")", "\n", "\n", "# plot visited vertices", "\n", "if", "plot_vertices", ":", "\n", "        ", "ax", ".", "scatter", "(", "*", "positions_of_path", "(", "path", ")", ".", "T", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "1", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.plot_vertices": [[87, 90], ["ax.scatter", "bax.util.graph.positions_of_path"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path"], ["", "def", "plot_vertices", "(", "ax", ",", "vertices", ",", "**", "kwargs", ")", ":", "\n", "    ", "ax", ".", "scatter", "(", "*", "positions_of_path", "(", "vertices", ")", ".", "T", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "1", ")", ",", "**", "kwargs", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.plot_acqopt_vertex": [[91, 94], ["ax.scatter", "bax.util.graph.positions_of_path"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path"], ["", "def", "plot_acqopt_vertex", "(", "ax", ",", "vertex", ",", "**", "kwargs", ")", ":", "\n", "    ", "ax", ".", "scatter", "(", "*", "positions_of_path", "(", "[", "vertex", "]", ")", ".", "T", ",", "color", "=", "\"blue\"", ",", "**", "kwargs", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.plot_graph": [[95, 110], ["matplotlib.collections.LineCollection", "ax.add_collection", "ax.scatter", "ax.scatter", "ax.scatter", "ax.grid", "len"], "function", ["None"], ["", "def", "plot_graph", "(", "ax", ",", "edges", ",", "start", ",", "goal", ")", ":", "\n", "# plot edges", "\n", "    ", "color", "=", "(", "0.75", ",", "0.75", ",", "0.75", ",", "0.1", ")", "\n", "lc", "=", "LC", "(", "edges", ",", "colors", "=", "[", "color", "]", "*", "len", "(", "edges", ")", ",", "linewidths", "=", "1.0", ")", "\n", "ax", ".", "add_collection", "(", "lc", ")", "\n", "\n", "# plot vertices", "\n", "ax", ".", "scatter", "(", "*", "positions", ".", "T", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "1", ")", ",", "marker", "=", "'.'", ",", "facecolors", "=", "'none'", ",", "s", "=", "20", ")", "\n", "\n", "# plot start and goal vertices", "\n", "ax", ".", "scatter", "(", "*", "start", ".", "position", ",", "color", "=", "'#9907E1'", ",", "marker", "=", "'s'", ",", "label", "=", "\"Start\"", ",", "s", "=", "150", ")", "\n", "ax", ".", "scatter", "(", "*", "goal", ".", "position", ",", "color", "=", "'#F3C807'", ",", "marker", "=", "'s'", ",", "label", "=", "\"Goal\"", ",", "s", "=", "150", ")", "\n", "\n", "ax", ".", "grid", "(", "False", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid10_viz_simple_demo.plot_contourf": [[111, 116], ["numpy.meshgrid", "ax.contourf", "numpy.linspace", "numpy.linspace", "bax_grid10_viz_simple_demo.rosenbrock"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.rosenbrock"], ["", "def", "plot_contourf", "(", "fig", ",", "ax", ",", "x1_lims", ",", "x2_lims", ")", ":", "\n", "    ", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "*", "x1_lims", ")", ",", "np", ".", "linspace", "(", "*", "x2_lims", ")", ")", "\n", "\n", "# plot cost function", "\n", "cs", "=", "ax", ".", "contourf", "(", "x", ",", "y", ",", "rosenbrock", "(", "x", ",", "y", ")", ",", "cmap", "=", "'BuGn'", ")", "\n", "#cbar = fig.colorbar(cs)", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.rosenbrock": [[28, 32], ["None"], "function", ["None"], ["def", "rosenbrock", "(", "x", ",", "y", ",", "a", "=", "1", ",", "b", "=", "100", ")", ":", "\n", "# NOTE rescaled to improve numerics", "\n", "# NOTE min cost path: 1.0527267184880365", "\n", "    ", "return", "1e-2", "*", "(", "(", "a", "-", "x", ")", "**", "2", "+", "b", "*", "(", "y", "-", "x", "**", "2", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.true_f": [[33, 36], ["numpy.array().reshape", "bax_grid20_animation.rosenbrock", "numpy.array"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.rosenbrock"], ["", "def", "true_f", "(", "x_y", ")", ":", "\n", "    ", "x_y", "=", "np", ".", "array", "(", "x_y", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "rosenbrock", "(", "x_y", "[", "...", ",", "0", "]", ",", "x_y", "[", "...", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.inv_softplus": [[37, 39], ["numpy.log", "numpy.exp"], "function", ["None"], ["", "def", "inv_softplus", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "log", "(", "np", ".", "exp", "(", "x", ")", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.true_latent_f": [[41, 43], ["bax_grid20_animation.inv_softplus", "bax_grid20_animation.true_f"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.inv_softplus", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.true_f"], ["", "def", "true_latent_f", "(", "x_y", ")", ":", "\n", "    ", "return", "inv_softplus", "(", "true_f", "(", "x_y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.softplus": [[44, 46], ["numpy.log1p", "numpy.exp"], "function", ["None"], ["", "def", "softplus", "(", "x", ")", ":", "\n", "        ", "return", "np", ".", "log1p", "(", "np", ".", "exp", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.cost_func": [[47, 55], ["f", "bax_grid20_animation.softplus"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.softplus"], ["", "def", "cost_func", "(", "u", ",", "v", ",", "f", ",", "latent_f", "=", "True", ")", ":", "\n", "    ", "u_pos", ",", "v_pos", "=", "u", ".", "position", ",", "v", ".", "position", "\n", "edge", "=", "(", "u_pos", "+", "v_pos", ")", "/", "2", "\n", "edge_cost", "=", "f", "(", "edge", ")", "\n", "if", "latent_f", ":", "\n", "        ", "return", "softplus", "(", "edge_cost", ")", ",", "[", "edge", "]", ",", "[", "edge_cost", "]", "\n", "", "else", ":", "\n", "        ", "return", "edge_cost", ",", "[", "edge", "]", ",", "[", "edge_cost", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.cost_of_path": [[56, 61], ["range", "bax_grid20_animation.cost_func", "len"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.cost_func"], ["", "", "def", "cost_of_path", "(", "path", ",", "cost_func", ")", ":", "\n", "    ", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "        ", "cost", "+=", "cost_func", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "\n", "", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.plot_path": [[62, 86], ["bax.util.graph.edges_of_path", "matplotlib.collections.LineCollection", "ax.add_collection", "ax.scatter", "len", "bax.util.graph.positions_of_path"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.edges_of_path", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path"], ["", "def", "plot_path", "(", "\n", "ax", ",", "\n", "path", ",", "\n", "path_color", "=", "(", "0", ",", "0", ",", "0", ",", "1.", ")", ",", "\n", "linewidths", "=", "2", ",", "\n", "linestyle", "=", "\"dotted\"", ",", "\n", "plot_vertices", "=", "False", ",", "\n", "label", "=", "None", ",", "\n", ")", ":", "\n", "# plot path taken", "\n", "    ", "path_lines", "=", "edges_of_path", "(", "path", ")", "\n", "path_lc", "=", "LC", "(", "\n", "path_lines", ",", "\n", "colors", "=", "[", "path_color", "]", "*", "len", "(", "path_lines", ")", ",", "\n", "linewidths", "=", "linewidths", ",", "\n", "linestyle", "=", "linestyle", ",", "\n", "label", "=", "label", ",", "\n", ")", "\n", "ax", ".", "add_collection", "(", "path_lc", ")", "\n", "\n", "# plot visited vertices", "\n", "if", "plot_vertices", ":", "\n", "        ", "ax", ".", "scatter", "(", "*", "positions_of_path", "(", "path", ")", ".", "T", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "1", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.plot_vertices": [[87, 90], ["ax.scatter", "bax.util.graph.positions_of_path"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path"], ["", "def", "plot_vertices", "(", "ax", ",", "vertices", ",", "**", "kwargs", ")", ":", "\n", "    ", "ax", ".", "scatter", "(", "*", "positions_of_path", "(", "vertices", ")", ".", "T", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "1", ")", ",", "**", "kwargs", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.plot_acqopt_vertex": [[91, 94], ["ax.scatter", "bax.util.graph.positions_of_path"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.graph.positions_of_path"], ["", "def", "plot_acqopt_vertex", "(", "ax", ",", "vertex", ",", "**", "kwargs", ")", ":", "\n", "    ", "ax", ".", "scatter", "(", "*", "positions_of_path", "(", "[", "vertex", "]", ")", ".", "T", ",", "color", "=", "\"blue\"", ",", "**", "kwargs", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.plot_graph": [[95, 110], ["matplotlib.collections.LineCollection", "ax.add_collection", "ax.scatter", "ax.scatter", "ax.scatter", "ax.grid", "len"], "function", ["None"], ["", "def", "plot_graph", "(", "ax", ",", "edges", ",", "start", ",", "goal", ")", ":", "\n", "# plot edges", "\n", "    ", "color", "=", "(", "0.75", ",", "0.75", ",", "0.75", ",", "0.1", ")", "\n", "lc", "=", "LC", "(", "edges", ",", "colors", "=", "[", "color", "]", "*", "len", "(", "edges", ")", ",", "linewidths", "=", "1.0", ")", "\n", "ax", ".", "add_collection", "(", "lc", ")", "\n", "\n", "# plot vertices", "\n", "ax", ".", "scatter", "(", "*", "positions", ".", "T", ",", "color", "=", "(", "0", ",", "0", ",", "0", ",", "1", ")", ",", "marker", "=", "'.'", ",", "facecolors", "=", "'none'", ",", "s", "=", "20", ")", "\n", "\n", "# plot start and goal vertices", "\n", "ax", ".", "scatter", "(", "*", "start", ".", "position", ",", "color", "=", "'#9907E1'", ",", "marker", "=", "'s'", ",", "label", "=", "\"Start\"", ",", "s", "=", "150", ")", "\n", "ax", ".", "scatter", "(", "*", "goal", ".", "position", ",", "color", "=", "'#F3C807'", ",", "marker", "=", "'s'", ",", "label", "=", "\"Goal\"", ",", "s", "=", "150", ")", "\n", "\n", "ax", ".", "grid", "(", "False", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.plot_contourf": [[111, 117], ["numpy.meshgrid", "ax.contourf", "fig.colorbar", "numpy.linspace", "numpy.linspace", "bax_grid20_animation.rosenbrock"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.dijkstra.bax_grid20_animation.rosenbrock"], ["", "def", "plot_contourf", "(", "fig", ",", "ax", ",", "x1_lims", ",", "x2_lims", ")", ":", "\n", "    ", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "*", "x1_lims", ")", ",", "np", ".", "linspace", "(", "*", "x2_lims", ")", ")", "\n", "\n", "# plot cost function", "\n", "cs", "=", "ax", ".", "contourf", "(", "x", ",", "y", ",", "rosenbrock", "(", "x", ",", "y", ")", ",", "cmap", "=", "'BuGn'", ")", "\n", "cbar", "=", "fig", ".", "colorbar", "(", "cs", ",", "ax", "=", "ax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params": [[40, 51], ["super().set_params", "bax.util.misc_util.dict_to_namespace", "getattr", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.set_params", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.util.misc_util.dict_to_namespace"], ["def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Set self.params, the parameters for the algorithm.\"\"\"", "\n", "super", "(", ")", ".", "set_params", "(", "params", ")", "\n", "params", "=", "dict_to_namespace", "(", "params", ")", "\n", "\n", "self", ".", "params", ".", "name", "=", "getattr", "(", "params", ",", "'name'", ",", "'NStep'", ")", "\n", "self", ".", "params", ".", "n", "=", "getattr", "(", "params", ",", "'n'", ",", "10", ")", "\n", "self", ".", "params", ".", "f_is_diff", "=", "getattr", "(", "params", ",", "'f_is_diff'", ",", "DEFAULT_F_IS_DIFF", ")", "\n", "self", ".", "params", ".", "init_x", "=", "getattr", "(", "params", ",", "'init_x'", ",", "[", "0.0", ",", "0.0", "]", ")", "\n", "self", ".", "params", ".", "project_to_domain", "=", "getattr", "(", "params", ",", "'project_to_domain'", ",", "True", ")", "\n", "self", ".", "params", ".", "domain", "=", "getattr", "(", "params", ",", "'domain'", ",", "[", "[", "0.0", ",", "10.0", "]", ",", "[", "0.0", ",", "10.0", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_next_x": [[52, 74], ["len", "zip", "bax.util.domain_util.project_to_domain"], "methods", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.evolution_strategies.EvolutionStrategies.project_to_domain"], ["", "def", "get_next_x", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Given the current execution path, return the next x in the execution path. If\n        the algorithm is complete, return None.\n        \"\"\"", "\n", "len_path", "=", "len", "(", "self", ".", "exe_path", ".", "x", ")", "\n", "if", "len_path", "==", "0", ":", "\n", "            ", "next_x", "=", "self", ".", "params", ".", "init_x", "\n", "", "elif", "len_path", ">=", "self", ".", "params", ".", "n", "+", "1", ":", "\n", "            ", "next_x", "=", "None", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "params", ".", "f_is_diff", ":", "\n", "                ", "zip_path_end", "=", "zip", "(", "self", ".", "exe_path", ".", "x", "[", "-", "1", "]", ",", "self", ".", "exe_path", ".", "y", "[", "-", "1", "]", ")", "\n", "next_x", "=", "[", "xi", "+", "yi", "for", "xi", ",", "yi", "in", "zip_path_end", "]", "\n", "", "else", ":", "\n", "                ", "next_x", "=", "self", ".", "exe_path", ".", "y", "[", "-", "1", "]", "\n", "\n", "", "if", "self", ".", "params", ".", "project_to_domain", ":", "\n", "# Optionally, project to domain", "\n", "                ", "next_x", "=", "project_to_domain", "(", "next_x", ",", "self", ".", "params", ".", "domain", ")", "\n", "\n", "", "", "return", "next_x", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.NStep.get_output": [[75, 78], ["None"], "methods", ["None"], ["", "def", "get_output", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return output based on self.exe_path.\"\"\"", "\n", "return", "self", ".", "exe_path", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.step_northwest": [[80, 88], ["None"], "function", ["None"], ["", "", "def", "step_northwest", "(", "x_list", ",", "step_size", "=", "0.5", ",", "f_is_diff", "=", "DEFAULT_F_IS_DIFF", ")", ":", "\n", "    ", "\"\"\"Return x_list with a small positive value added to each element.\"\"\"", "\n", "if", "f_is_diff", ":", "\n", "        ", "diffs_list", "=", "[", "step_size", "for", "x", "in", "x_list", "]", "\n", "return", "diffs_list", "\n", "", "else", ":", "\n", "        ", "x_list_new", "=", "[", "x", "+", "step_size", "for", "x", "in", "x_list", "]", "\n", "return", "x_list_new", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.multioutput.test_multigpfsgp.plot_path_2d": [[90, 104], ["matplotlib.subplots", "ax.plot", "ax.plot", "ax.plot", "ax.plot"], "function", ["None"], ["", "", "def", "plot_path_2d", "(", "path", ",", "ax", "=", "None", ",", "true_path", "=", "False", ")", ":", "\n", "    ", "\"\"\"Plot a path through an assumed two-dimensional state space.\"\"\"", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "5", ",", "5", ")", ")", "\n", "\n", "", "x_plot", "=", "[", "xi", "[", "0", "]", "for", "xi", "in", "path", ".", "x", "]", "\n", "y_plot", "=", "[", "xi", "[", "1", "]", "for", "xi", "in", "path", ".", "x", "]", "\n", "\n", "if", "true_path", ":", "\n", "        ", "ax", ".", "plot", "(", "x_plot", ",", "y_plot", ",", "'k--'", ",", "linewidth", "=", "3", ")", "\n", "ax", ".", "plot", "(", "x_plot", ",", "y_plot", ",", "'*'", ",", "color", "=", "'k'", ",", "markersize", "=", "15", ")", "\n", "", "else", ":", "\n", "        ", "ax", ".", "plot", "(", "x_plot", ",", "y_plot", ",", "'k--'", ",", "linewidth", "=", "1", ",", "alpha", "=", "0.3", ")", "\n", "ax", ".", "plot", "(", "x_plot", ",", "y_plot", ",", "'o'", ",", "alpha", "=", "0.3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin": [[10, 42], ["copy.deepcopy", "numpy.array", "isinstance", "numpy.array", "len", "branin.branin_single", "numpy.array", "len", "branin.branin_single", "len", "ValueError", "branin.branin_single", "branin.branin_on_matrix", "np.array.reshape", "type"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_single", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_single", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_single", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_on_matrix"], ["def", "branin", "(", "x", ")", ":", "\n", "    ", "\"\"\"Branin synthetic function wrapper\"\"\"", "\n", "\n", "x", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "x", "=", "np", ".", "array", "(", "x", ")", "\n", "\n", "if", "not", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "x", "=", "np", ".", "array", "(", "x", ")", "\n", "\n", "", "if", "len", "(", "x", ".", "shape", ")", "==", "0", ":", "\n", "        ", "return", "branin_single", "(", "np", ".", "array", "(", "[", "x", "]", ")", ")", "\n", "\n", "", "elif", "len", "(", "x", ".", "shape", ")", "==", "1", ":", "\n", "# x must be single input", "\n", "        ", "return", "branin_single", "(", "x", ")", "\n", "\n", "", "elif", "len", "(", "x", ".", "shape", ")", "==", "2", ":", "\n", "# x could be single input or matrix of multiple inputs", "\n", "        ", "if", "x", ".", "shape", "[", "0", "]", "==", "1", "or", "x", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "# x is single row matrix or single column matrix", "\n", "            ", "return", "branin_single", "(", "x", ".", "reshape", "(", "-", "1", ")", ")", "\n", "\n", "", "else", ":", "\n", "# Multiple x in a matrix", "\n", "            ", "return", "branin_on_matrix", "(", "x", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "(", "\n", "'Input to branin function must be a float, or a '", "\n", "+", "'1D or 2D np array, instead of a {}'", "\n", ")", ".", "format", "(", "type", "(", "x", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_xy": [[44, 48], ["branin.branin_single"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_single"], ["", "", "@", "np", ".", "vectorize", "\n", "def", "branin_xy", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"Apply return branin function on input = (x, y).\"\"\"", "\n", "return", "branin_single", "(", "(", "x", ",", "y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_on_matrix": [[50, 65], ["numpy.array", "branin.branin_single"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_single"], ["", "def", "branin_on_matrix", "(", "X", ")", ":", "\n", "    ", "\"\"\"\n    Branin synthetic function on matrix of inputs X.\n\n    Parameters\n    ----------\n    X : ndarray\n        A numpy ndarray with shape=(n, ndimx).\n\n    Returns\n    -------\n    ndarray\n        A numpy ndarray with shape=(ndimx,).\n    \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "branin_single", "(", "x", ")", "for", "x", "in", "X", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.branin.branin_single": [[67, 90], ["numpy.cos"], "function", ["None"], ["", "def", "branin_single", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    Branin synthetic function on a single input x.\n\n    Parameters\n    ----------\n    x : ndarray\n        A numpy ndarray with shape=(ndimx,).\n\n    Returns\n    -------\n    float\n        The function value f(x), a float.\n    \"\"\"", "\n", "b", "=", "5.1", "/", "(", "4.0", "*", "np", ".", "pi", "**", "2", ")", "\n", "c", "=", "5.0", "/", "np", ".", "pi", "\n", "t", "=", "1.0", "/", "(", "8.0", "*", "np", ".", "pi", ")", "\n", "x0", "=", "x", "[", "0", "]", "\n", "x1", "=", "x", "[", "1", "]", "\n", "return", "(", "\n", "1.0", "*", "(", "x1", "-", "b", "*", "x0", "**", "2", "+", "c", "*", "x0", "-", "6.0", ")", "**", "2", "\n", "+", "10.0", "*", "(", "1", "-", "t", ")", "*", "np", ".", "cos", "(", "x0", ")", "\n", "+", "10.0", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.branin.bax_viz2d_simple_demo.run_algo_on_mean_f": [[28, 35], ["model_mf.initialize_function_sample_list", "algo_mf.run_algorithm_on_f", "numpy.mean", "f_list", "range"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.models.gpfs_gp.MultiGpfsGp.initialize_function_sample_list", "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.alg.algorithms.Noop.run_algorithm_on_f"], ["def", "run_algo_on_mean_f", "(", "model_mf", ",", "algo_mf", ",", "n_samp_mf", ")", ":", "\n", "    ", "\"\"\"Run algorithm on posterior mean (via MC estimate with n_samp samples).\"\"\"", "\n", "model_mf", ".", "initialize_function_sample_list", "(", "n_samp_mf", ")", "\n", "f_list", "=", "model_mf", ".", "call_function_sample_list", "\n", "f_mf", "=", "lambda", "x", ":", "np", ".", "mean", "(", "f_list", "(", "[", "x", "for", "_", "in", "range", "(", "n_samp_mf", ")", "]", ")", ")", "\n", "exe_path_mf", ",", "output_mf", "=", "algo_mf", ".", "run_algorithm_on_f", "(", "f_mf", ")", "\n", "return", "exe_path_mf", ",", "output_mf", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.topk.bax_simple_demo.f_vec": [[43, 47], ["f"], "function", ["None"], ["@", "np", ".", "vectorize", "\n", "def", "f_vec", "(", "x", ",", "y", ")", ":", "\n", "    ", "\"\"\"Return f on input = (x, y).\"\"\"", "\n", "return", "f", "(", "(", "x", ",", "y", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.neatplot.__init__.set_style": [[8, 13], ["matplotlib.style.use", "matplotlib.style.use", "pathlib.Path", "pathlib.Path"], "function", ["None"], []], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.neatplot.__init__.save_figure": [[14, 24], ["isinstance", "matplotlib.savefig", "print"], "function", ["None"], []], "home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.neatplot.__init__.update_rc": [[25, 28], ["matplotlib.rcParams.update"], "function", ["home.repos.pwc.inspect_result.willieneis_bayesian-algorithm-execution.estool.es.Optimizer.update"], []]}