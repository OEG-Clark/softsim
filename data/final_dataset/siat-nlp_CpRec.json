{"home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.__init__": [[15, 42], ["list", "max", "sorted", "list", "dict", "Data_loader.INFO_LOG", "numpy.array", "open().readlines", "sample.strip().split", "Data_loader.Data_Loader.item_fre.items", "zip", "zip", "Data_loader.Data_Loader.getSamplesid", "len", "len", "range", "Data_loader.Data_Loader.item2id.items", "Data_loader.Data_Loader.size", "open", "x.split", "sample.strip", "Data_loader.Data_Loader.item_fre.keys", "sample.strip().split", "len", "sample.strip"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.INFO_LOG", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.getSamplesid", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.size"], ["    ", "def", "__init__", "(", "self", ",", "options", ")", ":", "\n", "        ", "self", ".", "pad", "=", "\"<PAD>\"", "\n", "positive_data_file", "=", "options", "[", "'dir_name'", "]", "\n", "positive_examples", "=", "list", "(", "open", "(", "positive_data_file", ",", "\"r\"", ")", ".", "readlines", "(", ")", ")", "\n", "positive_examples", "=", "[", "s", "for", "s", "in", "positive_examples", "]", "\n", "\n", "self", ".", "max_document_length", "=", "max", "(", "[", "len", "(", "x", ".", "split", "(", "\",\"", ")", ")", "for", "x", "in", "positive_examples", "]", ")", "\n", "\n", "self", ".", "item_fre", "=", "{", "self", ".", "pad", ":", "0", "}", "\n", "\n", "for", "sample", "in", "positive_examples", ":", "\n", "            ", "for", "item", "in", "sample", ".", "strip", "(", ")", ".", "split", "(", "\",\"", ")", ":", "\n", "                ", "if", "item", "in", "self", ".", "item_fre", ".", "keys", "(", ")", ":", "\n", "                    ", "self", ".", "item_fre", "[", "item", "]", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "self", ".", "item_fre", "[", "item", "]", "=", "1", "\n", "", "", "self", ".", "item_fre", "[", "self", ".", "pad", "]", "+=", "self", ".", "max_document_length", "-", "len", "(", "sample", ".", "strip", "(", ")", ".", "split", "(", "\",\"", ")", ")", "\n", "\n", "", "count_pairs", "=", "sorted", "(", "self", ".", "item_fre", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "(", "-", "x", "[", "1", "]", ",", "x", "[", "0", "]", ")", ")", "\n", "self", ".", "items_voc", ",", "_", "=", "list", "(", "zip", "(", "*", "count_pairs", ")", ")", "\n", "self", ".", "item2id", "=", "dict", "(", "zip", "(", "self", ".", "items_voc", ",", "range", "(", "len", "(", "self", ".", "items_voc", ")", ")", ")", ")", "\n", "self", ".", "padid", "=", "self", ".", "item2id", "[", "self", ".", "pad", "]", "\n", "self", ".", "id2item", "=", "{", "value", ":", "key", "for", "key", ",", "value", "in", "self", ".", "item2id", ".", "items", "(", ")", "}", "\n", "\n", "INFO_LOG", "(", "\"Vocab size:{}\"", ".", "format", "(", "self", ".", "size", "(", ")", ")", ")", "\n", "\n", "self", ".", "items", "=", "np", ".", "array", "(", "self", ".", "getSamplesid", "(", "positive_examples", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.sample2id": [[45, 52], ["sample.strip().split", "sample2id.append", "sample.strip", "len"], "methods", ["None"], ["", "def", "sample2id", "(", "self", ",", "sample", ")", ":", "\n", "        ", "sample2id", "=", "[", "]", "\n", "for", "s", "in", "sample", ".", "strip", "(", ")", ".", "split", "(", "','", ")", ":", "\n", "            ", "sample2id", ".", "append", "(", "self", ".", "item2id", "[", "s", "]", ")", "\n", "", "sample2id", "=", "(", "[", "self", ".", "padid", "]", "*", "(", "self", ".", "max_document_length", "-", "len", "(", "sample2id", ")", ")", ")", "+", "sample2id", "\n", "\n", "return", "sample2id", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.getSamplesid": [[53, 59], ["samples2id.append", "Data_loader.Data_Loader.sample2id"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.sample2id"], ["", "def", "getSamplesid", "(", "self", ",", "samples", ")", ":", "\n", "        ", "samples2id", "=", "[", "]", "\n", "for", "sample", "in", "samples", ":", "\n", "            ", "samples2id", ".", "append", "(", "self", ".", "sample2id", "(", "sample", ")", ")", "\n", "\n", "", "return", "samples2id", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.size": [[61, 63], ["len"], "methods", ["None"], ["", "def", "size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "item2id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.load_generator_data": [[65, 71], ["text.reshape.reshape.reshape", "len", "len"], "methods", ["None"], ["", "def", "load_generator_data", "(", "self", ",", "sample_size", ")", ":", "\n", "        ", "text", "=", "self", ".", "text", "\n", "mod_size", "=", "len", "(", "text", ")", "-", "len", "(", "text", ")", "%", "sample_size", "\n", "text", "=", "text", "[", "0", ":", "mod_size", "]", "\n", "text", "=", "text", ".", "reshape", "(", "-", "1", ",", "sample_size", ")", "\n", "return", "text", ",", "self", ".", "vocab_indexed", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.string_to_indices": [[73, 76], ["sentence.split"], "methods", ["None"], ["", "def", "string_to_indices", "(", "self", ",", "sentence", ",", "vocab", ")", ":", "\n", "        ", "indices", "=", "[", "self", ".", "item2id", "[", "s", "]", "for", "s", "in", "sentence", ".", "split", "(", "','", ")", "]", "\n", "return", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.inidices_to_string": [[77, 86], ["None"], "methods", ["None"], ["", "def", "inidices_to_string", "(", "self", ",", "sentence", ",", "vocab", ")", ":", "\n", "        ", "id_ch", "=", "{", "vocab", "[", "ch", "]", ":", "ch", "for", "ch", "in", "vocab", "}", "\n", "sent", "=", "[", "]", "\n", "for", "c", "in", "sentence", ":", "\n", "            ", "if", "id_ch", "[", "c", "]", "==", "'eol'", ":", "\n", "                ", "break", "\n", "", "sent", "+=", "id_ch", "[", "c", "]", "\n", "\n", "", "return", "\"\"", ".", "join", "(", "sent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.INFO_LOG": [[10, 12], ["print", "time.strftime", "time.localtime"], "function", ["None"], ["def", "INFO_LOG", "(", "info", ")", ":", "\n", "    ", "print", "(", "\"[%s]%s\"", "%", "(", "time", ".", "strftime", "(", "\"%Y-%m-%d %X\"", ",", "time", ".", "localtime", "(", ")", ")", ",", "info", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForInput.__init__": [[12, 18], ["len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "vocab_size", ",", "embed_dim", ",", "block", "=", "None", ",", "block_factor", "=", "4", ",", "blocks_dims", "=", "None", ",", "name", "=", "None", ")", ":", "\n", "\t\t", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "self", ".", "block", "=", "block", "\n", "self", ".", "block_num", "=", "len", "(", "block", ")", "-", "1", "\n", "self", ".", "block_factor", "=", "block_factor", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForInput.build": [[19, 41], ["numpy.sqrt", "tensorflow.get_variable", "range", "tensorflow.get_variable", "range", "max", "otherblock_dims.append", "BlockWiseEmbedding.BlockWiseEmbeddingForInput.otherblock_w.append", "tensorflow.random_uniform_initializer", "tensorflow.get_variable", "tensorflow.get_variable"], "methods", ["None"], ["", "def", "build", "(", "self", ")", ":", "\n", "\t\t", "if", "self", ".", "block_factor", "==", "1", ":", "\n", "\t\t\t", "stdv", "=", "np", ".", "sqrt", "(", "1.", "/", "self", ".", "vocab_size", ")", "\n", "self", ".", "embedding", "=", "tf", ".", "get_variable", "(", "\"word_embedding_\"", ",", "[", "self", ".", "vocab_size", ",", "self", ".", "embed_dim", "]", ",", "\n", "initializer", "=", "tf", ".", "random_uniform_initializer", "(", "-", "stdv", ",", "stdv", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t", "otherblock_dims", "=", "[", "]", "\n", "block_factor", "=", "self", ".", "block_factor", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t\t", "dim", "=", "max", "(", "1", ",", "self", ".", "embed_dim", "/", "block_factor", ")", "\n", "otherblock_dims", ".", "append", "(", "dim", ")", "\n", "block_factor", "*=", "self", ".", "block_factor", "\n", "\n", "", "firstblock_K", "=", "self", ".", "block", "[", "0", "]", "\n", "self", ".", "firstblock_w", "=", "tf", ".", "get_variable", "(", "\"blockwiseembedding_block1_w\"", ",", "[", "firstblock_K", ",", "self", ".", "embed_dim", "]", ")", "\n", "self", ".", "otherblock_w", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t\t", "block_i_dim", "=", "otherblock_dims", "[", "i", "]", "\n", "block_i_K", "=", "self", ".", "block", "[", "i", "+", "1", "]", "-", "self", ".", "block", "[", "i", "]", "\n", "self", ".", "otherblock_w", ".", "append", "(", "[", "\n", "tf", ".", "get_variable", "(", "\"blockwiseembedding_block{}_proj_w\"", ".", "format", "(", "i", "+", "2", ")", ",", "[", "block_i_dim", ",", "self", ".", "embed_dim", "]", ")", ",", "\n", "tf", ".", "get_variable", "(", "\"blockwiseembedding_block{}_w\"", ".", "format", "(", "i", "+", "2", ")", ",", "[", "block_i_K", ",", "block_i_dim", "]", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForInput.get_input": [[43, 79], ["tensorflow.nn.embedding_lookup", "print", "list", "print", "tensorflow.zeros", "range", "tensorflow.logical_and", "tensorflow.cast", "len", "tensorflow.greater_equal", "tensorflow.less", "tensorflow.nn.embedding_lookup", "tensorflow.tensordot", "tensorflow.expand_dims", "tensorflow.cast", "tensorflow.cast", "tensorflow.nn.embedding_lookup"], "methods", ["None"], ["", "", "", "def", "get_input", "(", "self", ",", "inputs", ")", ":", "\n", "# print(\"shape: \", inputs.shape)", "\n", "# inputs: [batch_size, seq_len]", "\n", "\t\t", "if", "self", ".", "block_factor", "==", "1", ":", "\n", "\t\t\t", "outputs", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "embedding", ",", "inputs", ")", "\n", "print", "(", "'using embeddding'", ")", "\n", "", "else", ":", "\n", "\t\t\t", "input_size", "=", "list", "(", "inputs", ".", "shape", ")", "\n", "print", "(", "\"input_size: \"", ",", "input_size", ")", "\n", "outputs", "=", "tf", ".", "zeros", "(", "input_size", "+", "[", "self", ".", "embed_dim", "]", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "\n", "block_value", "=", "[", "0", "]", "+", "self", ".", "block", "\n", "for", "i", "in", "range", "(", "len", "(", "block_value", ")", "-", "1", ")", ":", "\n", "\t\t\t\t", "low_idx", "=", "block_value", "[", "i", "]", "\n", "high_idx", "=", "block_value", "[", "i", "+", "1", "]", "\n", "mask", "=", "tf", ".", "logical_and", "(", "tf", ".", "greater_equal", "(", "inputs", ",", "low_idx", ")", ",", "tf", ".", "less", "(", "inputs", ",", "high_idx", ")", ")", "\n", "\n", "# row_indices = tf.squeeze(tf.where(mask))", "\n", "mask", "=", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "float", ")", "\n", "\n", "# if row_indices.size() ==0:", "\n", "# \tcontinue", "\n", "if", "i", "==", "0", ":", "\n", "\t\t\t\t\t", "firstblock_inputs", "=", "(", "inputs", "-", "low_idx", ")", "*", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "# firstblock_inputs = tf.boolean_mask(inputs-low_idx, mask)", "\n", "firstblock_embed", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "firstblock_w", ",", "firstblock_inputs", ")", "\n", "projected", "=", "firstblock_embed", "# [batch_size, seq_len, output_dim]", "\n", "", "else", ":", "\n", "# block_i_inputs = tf.boolean_mask(inputs-low_idx, mask)", "\n", "\t\t\t\t\t", "block_i_inputs", "=", "(", "inputs", "-", "low_idx", ")", "*", "tf", ".", "cast", "(", "mask", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "block_i_embed", "=", "tf", ".", "tensordot", "(", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "otherblock_w", "[", "i", "-", "1", "]", "[", "1", "]", ",", "block_i_inputs", ")", ",", "self", ".", "otherblock_w", "[", "i", "-", "1", "]", "[", "0", "]", ",", "axes", "=", "1", ")", "\n", "# tf.where(mask, block_i_embed, outputs)", "\n", "projected", "=", "block_i_embed", "\n", "", "outputs", "+=", "projected", "*", "tf", ".", "expand_dims", "(", "mask", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.__init__": [[86, 116], ["print", "len", "range", "tensorflow.variable_scope", "tensorflow.get_variable", "range", "len", "max", "otherblock_dims.append", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.otherblock_w.append", "type", "tensorflow.get_variable", "tensorflow.get_variable"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "block", ",", "block_factor", "=", "4", ",", "otherblock_dims", "=", "None", ",", "dropout", "=", "0", ",", "adaptive_inputs", "=", "None", ",", "\n", "initializer", "=", "None", ",", "name", "=", "None", ",", "tied_pro", "=", "True", ")", ":", "\n", "\t\t", "self", ".", "block_num", "=", "len", "(", "block", ")", "-", "1", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "block_factor", "=", "block_factor", "\n", "\n", "if", "otherblock_dims", ":", "\n", "\t\t\t", "assert", "(", "len", "(", "otherblock_dims", ")", "==", "self", ".", "block_num", ")", "\n", "", "else", ":", "\n", "\t\t\t", "otherblock_dims", "=", "[", "]", "\n", "block_factor", "=", "self", ".", "block_factor", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t\t", "dim", "=", "max", "(", "1", ",", "input_dim", "/", "block_factor", ")", "\n", "otherblock_dims", ".", "append", "(", "dim", ")", "\n", "block_factor", "*=", "block_factor", "\n", "\n", "", "", "self", ".", "block", "=", "block", "\n", "firstblock_K", "=", "block", "[", "0", "]", "+", "self", ".", "block_num", "\n", "self", ".", "otherblock_w", "=", "[", "]", "\n", "with", "tf", ".", "variable_scope", "(", "name", "or", "type", "(", "self", ")", ".", "__name__", ",", "initializer", "=", "initializer", ")", ":", "\n", "\t\t\t", "self", ".", "firstblock_w", "=", "tf", ".", "get_variable", "(", "\"blockwiseembedding_softmax_block1_w\"", ",", "[", "input_dim", ",", "firstblock_K", "]", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t\t", "block_i_dim", "=", "otherblock_dims", "[", "i", "]", "\n", "block_i_K", "=", "block", "[", "i", "+", "1", "]", "-", "block", "[", "i", "]", "\n", "self", ".", "otherblock_w", ".", "append", "(", "[", "\n", "tf", ".", "get_variable", "(", "\"blockwiseembedding_softmax_block{}_proj_w\"", ".", "format", "(", "i", "+", "2", ")", ",", "[", "input_dim", ",", "block_i_dim", "]", ")", ",", "\n", "# dropout", "\n", "tf", ".", "get_variable", "(", "\"blockwiseembedding_softmax_block{}_w\"", ".", "format", "(", "i", "+", "2", ")", ",", "[", "block_i_dim", ",", "block_i_K", "]", ")", "\n", "]", ")", "\n", "", "", "print", "(", "\"dropout: \"", ",", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.loss": [[117, 160], ["tensorflow.ones", "range", "tensorflow.matmul", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "training_losses.append", "tensorflow.add", "tensorflow.nn.dropout", "tensorflow.logical_and", "tensorflow.where", "tensorflow.boolean_mask", "tensorflow.boolean_mask", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "training_losses.append", "tensorflow.SparseTensor", "tensorflow.size", "tensorflow.greater_equal", "tensorflow.less", "tensorflow.matmul", "tensorflow.matmul", "tensorflow.squeeze", "tensorflow.sparse_tensor_to_dense", "tensorflow.nn.dropout", "tensorflow.matmul", "tensorflow.where", "tensorflow.size", "tensorflow.sparse_tensor_to_dense", "tensorflow.matmul"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.size", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.Data_loader.Data_Loader.size"], ["", "def", "loss", "(", "self", ",", "inputs", ",", "labels", ",", "train", "=", "True", ",", "name", "=", "'loss'", ")", ":", "\n", "# Get block_i masks and update firstblock labels", "\n", "# start_time = time.time()", "\n", "\n", "\t\t", "training_losses", "=", "[", "]", "\n", "if", "train", ":", "\n", "\t\t\t", "inputs", "=", "tf", ".", "nn", ".", "dropout", "(", "inputs", ",", "keep_prob", "=", "1", "-", "self", ".", "dropout", ")", "\n", "\n", "", "firstblock_labels", "=", "labels", "\n", "ones", "=", "tf", ".", "ones", "(", "[", "tf", ".", "size", "(", "labels", ")", "]", ",", "dtype", "=", "tf", ".", "int32", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t", "mask", "=", "tf", ".", "logical_and", "(", "tf", ".", "greater_equal", "(", "labels", ",", "self", ".", "block", "[", "i", "]", ")", ",", "tf", ".", "less", "(", "labels", ",", "self", ".", "block", "[", "i", "+", "1", "]", ")", ")", "\n", "\n", "# Update firstblock labels", "\n", "firstblock_labels", "=", "tf", ".", "where", "(", "mask", ",", "ones", "*", "(", "self", ".", "block", "[", "0", "]", "+", "i", ")", ",", "firstblock_labels", ")", "\n", "\n", "# Compute block_i loss", "\n", "block_i_inputs", "=", "tf", ".", "boolean_mask", "(", "inputs", ",", "mask", ")", "# [block_i_num, channel]", "\n", "if", "train", ":", "\n", "\t\t\t\t", "block_i_logits", "=", "tf", ".", "matmul", "(", "\n", "tf", ".", "nn", ".", "dropout", "(", "tf", ".", "matmul", "(", "block_i_inputs", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "0", "]", ")", ",", "keep_prob", "=", "1", "-", "self", ".", "dropout", ")", ",", "\n", "self", ".", "otherblock_w", "[", "i", "]", "[", "1", "]", ")", "# [block_i_num, block_i_dim]", "\n", "", "else", ":", "\n", "\t\t\t\t", "block_i_logits", "=", "tf", ".", "matmul", "(", "tf", ".", "matmul", "(", "block_i_inputs", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "0", "]", ")", ",", "\n", "self", ".", "otherblock_w", "[", "i", "]", "[", "1", "]", ")", "# [block_i_num, block_i_dim]", "\n", "", "block_i_labels", "=", "tf", ".", "boolean_mask", "(", "labels", "-", "self", ".", "block", "[", "i", "]", ",", "mask", ")", "# [block_i_num]", "\n", "block_i_loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "logits", "=", "block_i_logits", ",", "labels", "=", "block_i_labels", ")", "\n", "training_losses", ".", "append", "(", "block_i_loss", ")", "\n", "aligned_block_i_loss", "=", "tf", ".", "SparseTensor", "(", "tf", ".", "squeeze", "(", "tf", ".", "where", "(", "mask", ")", ")", ",", "block_i_loss", ",", "\n", "[", "tf", ".", "size", "(", "labels", ",", "out_type", "=", "tf", ".", "int64", ")", "]", ")", "\n", "# print(\"##################\", tf.squeeze(tf.where(mask)).shape, block_i_loss.shape, [tf.size(labels, out_type=tf.int64).shape])", "\n", "loss", "=", "tf", ".", "sparse_tensor_to_dense", "(", "aligned_block_i_loss", ")", "if", "i", "==", "0", "else", "loss", "+", "tf", ".", "sparse_tensor_to_dense", "(", "\n", "aligned_block_i_loss", ")", "\n", "\n", "# Compute firstblock loss", "\n", "", "firstblock_logits", "=", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "firstblock_w", ")", "# (sample_num, firstblock_size)", "\n", "firstblock_loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "logits", "=", "firstblock_logits", ",", "\n", "labels", "=", "firstblock_labels", ")", "# (sample_num)", "\n", "training_losses", ".", "append", "(", "firstblock_loss", ")", "\n", "loss", "=", "tf", ".", "add", "(", "loss", ",", "firstblock_loss", ",", "name", "=", "name", ")", "\n", "\n", "# print(\"Adaptive_Softmax time: \", time.time() - start_time)", "\n", "return", "loss", ",", "training_losses", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax": [[161, 171], ["tensorflow.matmul", "tensorflow.nn.softmax", "range", "tensorflow.concat", "tensorflow.matmul", "tensorflow.nn.softmax", "softmax_list.append", "tensorflow.matmul"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax"], ["", "def", "softmax", "(", "self", ",", "inputs", ",", "name", "=", "'softmax'", ")", ":", "\n", "\t\t", "firstblock_logits", "=", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "firstblock_w", ")", "\n", "firstblock_softmax", "=", "tf", ".", "nn", ".", "softmax", "(", "firstblock_logits", ")", "\n", "softmax_list", "=", "[", "firstblock_softmax", "[", ":", ",", ":", "self", ".", "block", "[", "0", "]", "]", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t", "block_i_logits", "=", "tf", ".", "matmul", "(", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "0", "]", ")", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "1", "]", ")", "\n", "block_i_softmax", "=", "tf", ".", "nn", ".", "softmax", "(", "block_i_logits", ")", "\n", "index", "=", "self", ".", "block", "[", "0", "]", "+", "i", "\n", "softmax_list", ".", "append", "(", "block_i_softmax", "*", "firstblock_softmax", "[", ":", ",", "index", ":", "index", "+", "1", "]", ")", "\n", "", "return", "tf", ".", "concat", "(", "softmax_list", ",", "axis", "=", "1", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.block_i_top_v": [[172, 181], ["tensorflow.matmul", "tensorflow.nn.softmax", "tensorflow.nn.top_k", "list", "tensorflow.matmul", "range"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax"], ["", "def", "block_i_top_v", "(", "self", ",", "inputs", ",", "firstblock_softmax", ",", "i", ",", "top_v", "=", "5", ")", ":", "\n", "\t\t", "block_i_logits", "=", "tf", ".", "matmul", "(", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "0", "]", ")", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "1", "]", ")", "\n", "block_i_softmax", "=", "tf", ".", "nn", ".", "softmax", "(", "block_i_logits", ")", "\n", "index", "=", "self", ".", "block", "[", "0", "]", "+", "i", "\n", "block_i_pro", "=", "block_i_softmax", "*", "firstblock_softmax", "[", ":", ",", "index", ":", "index", "+", "1", "]", "\n", "block_i_top_value", ",", "block_i_top_indices", "=", "tf", ".", "nn", ".", "top_k", "(", "block_i_pro", ",", "k", "=", "top_v", ")", "\n", "# block_i_top = list((block_i_top_value[0][i], block_i_top_indices[0][i]) for i in range(top_v))", "\n", "block_i_top", "=", "list", "(", "(", "block_i_top_value", "[", "0", "]", "[", "j", "]", ",", "block_i_top_indices", "[", "0", "]", "[", "j", "]", "+", "self", ".", "block", "[", "i", "]", ")", "for", "j", "in", "range", "(", "top_v", ")", ")", "\n", "return", "block_i_top", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax_inference_top": [[182, 196], ["tensorflow.matmul", "tensorflow.nn.softmax", "tensorflow.nn.top_k", "list", "range", "tensorflow.nn.in_top_k", "tensorflow.cond", "list.extend", "tensorflow.equal", "range", "tensorflow.constant", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.block_i_top_v", "list", "tensorflow.constant", "tensorflow.constant", "range"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.block_i_top_v"], ["", "def", "softmax_inference_top", "(", "self", ",", "inputs", ",", "name", "=", "'softmax'", ",", "top_v", "=", "5", ")", ":", "\n", "\t\t", "firstblock_logits", "=", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "firstblock_w", ")", "# [batch_size==1, firstblock_item]", "\n", "firstblock_softmax", "=", "tf", ".", "nn", ".", "softmax", "(", "firstblock_logits", ")", "\n", "temp_top_value", ",", "temp_top_indices", "=", "tf", ".", "nn", ".", "top_k", "(", "firstblock_softmax", "[", ":", ",", ":", "self", ".", "block", "[", "0", "]", "]", ",", "k", "=", "top_v", ")", "\n", "temp_top", "=", "list", "(", "(", "temp_top_value", "[", "0", "]", "[", "i", "]", ",", "temp_top_indices", "[", "0", "]", "[", "i", "]", ")", "for", "i", "in", "range", "(", "top_v", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t", "top_other", "=", "tf", ".", "nn", ".", "in_top_k", "(", "firstblock_softmax", ",", "[", "self", ".", "block", "[", "0", "]", "+", "i", "]", ",", "k", "=", "top_v", ")", "\n", "block_i_top", "=", "tf", ".", "cond", "(", "tf", ".", "equal", "(", "top_other", "[", "0", "]", ",", "tf", ".", "constant", "(", "True", ")", ")", ",", "\n", "true_fn", "=", "lambda", ":", "self", ".", "block_i_top_v", "(", "inputs", ",", "firstblock_softmax", ",", "i", ",", "top_v", ")", ",", "false_fn", "=", "lambda", ":", "list", "(", "\n", "(", "tf", ".", "constant", "(", "-", "1", ",", "dtype", "=", "tf", ".", "float32", ")", ",", "tf", ".", "constant", "(", "-", "1", ",", "dtype", "=", "tf", ".", "int32", ")", ")", "for", "i", "in", "range", "(", "top_v", ")", ")", ")", "\n", "temp_top", ".", "extend", "(", "block_i_top", ")", "\n", "\n", "", "return", "temp_top", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.log_softmax": [[197, 207], ["tensorflow.matmul", "tensorflow.nn.log_softmax", "range", "tensorflow.concat", "tensorflow.matmul", "tensorflow.nn.log_softmax", "logsoftmax_list.append", "tensorflow.matmul"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.log_softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.log_softmax"], ["", "def", "log_softmax", "(", "self", ",", "inputs", ",", "name", "=", "'log_softmax'", ")", ":", "\n", "\t\t", "firstblock_logits", "=", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "firstblock_w", ")", "\n", "firstblock_logsoftmax", "=", "tf", ".", "nn", ".", "log_softmax", "(", "firstblock_logits", ")", "\n", "logsoftmax_list", "=", "[", "firstblock_logsoftmax", "[", ":", ",", ":", "self", ".", "block", "[", "0", "]", "]", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "block_num", ")", ":", "\n", "\t\t\t", "block_i_logits", "=", "tf", ".", "matmul", "(", "tf", ".", "matmul", "(", "inputs", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "0", "]", ")", ",", "self", ".", "otherblock_w", "[", "i", "]", "[", "1", "]", ")", "# drouput", "\n", "block_i_logsoftmax", "=", "tf", ".", "nn", ".", "log_softmax", "(", "block_i_logits", ")", "\n", "index", "=", "self", ".", "block", "[", "0", "]", "+", "i", "\n", "logsoftmax_list", ".", "append", "(", "block_i_logsoftmax", "+", "firstblock_logsoftmax", "[", ":", ",", "index", ":", "index", "+", "1", "]", ")", "\n", "", "return", "tf", ".", "concat", "(", "logsoftmax_list", ",", "axis", "=", "1", ",", "name", "=", "name", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.__init__": [[9, 33], ["generator_recsys.NextItNet_Decoder.allitem_embeddings.build", "BlockWiseEmbedding.BlockWiseEmbeddingForInput", "print", "BlockWiseEmbedding.BlockWiseEmbeddingForInput", "print"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForInput.build"], ["    ", "def", "__init__", "(", "self", ",", "model_para", ")", ":", "\n", "        ", "self", ".", "model_para", "=", "model_para", "\n", "embedding_width", "=", "model_para", "[", "'in_embed_size'", "]", "\n", "output_dim", "=", "model_para", "[", "'dilated_channels'", "]", "\n", "# embedding", "\n", "# self.allitem_embeddings = tf.get_variable('allitem_embeddings',", "\n", "#                                             [model_para['item_size'], embedding_width],", "\n", "#                                             initializer=tf.truncated_normal_initializer(stddev=0.02))", "\n", "\n", "# block-wise embedding, factor :1 means embeddings and other means block-wise embedding", "\n", "\n", "if", "(", "model_para", "[", "'SoftmaxType'", "]", "==", "'Block_Input_Full'", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "'Block_Input_Softmax'", "\n", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "'Block_Input_Softmax_Inference'", ")", "and", "model_para", "[", "'factor'", "]", "!=", "1", ":", "\n", "            ", "self", ".", "allitem_embeddings", "=", "bl", "(", "model_para", "[", "'item_size'", "]", ",", "embedding_width", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ",", "\n", "block", "=", "model_para", "[", "\"block\"", "]", ")", "\n", "print", "(", "\"using block embedding for input\"", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "allitem_embeddings", "=", "bl", "(", "model_para", "[", "'item_size'", "]", ",", "embedding_width", ",", "\n", "block_factor", "=", "1", ",", "\n", "block", "=", "model_para", "[", "\"block\"", "]", ")", "\n", "print", "(", "\"using embedding\"", ")", "\n", "\n", "", "self", ".", "allitem_embeddings", ".", "build", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.train_graph": [[35, 132], ["tensorflow.placeholder", "generator_recsys.NextItNet_Decoder.model_graph", "tensorflow.reduce_mean", "print", "tensorflow.reshape", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.reshape", "int", "tensorflow.nn.sampled_softmax_loss", "tensorflow.reduce_mean", "tensorflow.random_normal_initializer", "tensorflow.constant_initializer", "print", "ops_compress.conv1d", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.get_variable", "tensorflow.tensordot", "tensorflow.nn.relu", "print", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.matmul", "tensorflow.nn.bias_add", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.nn.l2_loss", "tensorflow.random_normal_initializer", "tensorflow.get_variable", "tensorflow.tensordot", "tensorflow.random_normal_initializer", "tensorflow.constant_initializer", "print", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.reshape", "tensorflow.matmul", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.trainable_variables", "tensorflow.random_normal_initializer", "tensorflow.get_variable", "tensorflow.tensordot", "print", "tensorflow.reshape", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax", "lowranksoftmax.LowRankSoftmax.loss", "tensorflow.random_normal_initializer", "tensorflow.reshape", "print", "tensorflow.reshape", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax", "lowranksoftmax.LowRankSoftmax.loss", "tensorflow.reshape", "print", "tensorflow.reshape", "lowranksoftmax.LowRankSoftmax", "lowranksoftmax.LowRankSoftmax.loss", "tensorflow.reshape", "print", "tensorflow.reshape", "lowranksoftmax.LowRankSoftmax", "lowranksoftmax.LowRankSoftmax.loss", "tensorflow.reshape"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.model_graph", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.loss", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.loss", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.loss", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.loss"], ["", "def", "train_graph", "(", "self", ")", ":", "#, is_negsample=False):", "\n", "        ", "model_para", "=", "self", ".", "model_para", "\n", "self", ".", "itemseq_input", "=", "tf", ".", "placeholder", "(", "'int32'", ",", "\n", "[", "model_para", "[", "'batch_size'", "]", ",", "model_para", "[", "'seq_len'", "]", "]", ",", "name", "=", "'itemseq_input'", ")", "\n", "label_seq", ",", "dilate_input", "=", "self", ".", "model_graph", "(", "self", ".", "itemseq_input", ",", "train", "=", "True", ")", "\n", "\n", "# dilate_input : [batch_size, seq_len, dilated_channels]", "\n", "\n", "if", "model_para", "[", "'SoftmaxType'", "]", "==", "\"neg\"", ":", "\n", "            ", "print", "(", "\"using neg\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "self", ".", "softmax_w", "=", "tf", ".", "get_variable", "(", "\"softmax_w\"", ",", "[", "model_para", "[", "'item_size'", "]", ",", "model_para", "[", "'dilated_channels'", "]", "]", ",", "tf", ".", "float32", ",", "tf", ".", "random_normal_initializer", "(", "0.0", ",", "0.01", ")", ")", "\n", "self", ".", "softmax_b", "=", "tf", ".", "get_variable", "(", "\"softmax_b\"", ",", "[", "model_para", "[", "'item_size'", "]", "]", ",", "tf", ".", "float32", ",", "tf", ".", "constant_initializer", "(", "0.1", ")", ")", "\n", "label_flat", "=", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", ",", "1", "]", ")", "# 1 is the number of positive example", "\n", "num_sampled", "=", "int", "(", "0.2", "*", "model_para", "[", "'item_size'", "]", ")", "#sample 20% as negatives", "\n", "# tf.nn.nce_loss", "\n", "loss", "=", "tf", ".", "nn", ".", "sampled_softmax_loss", "(", "self", ".", "softmax_w", ",", "self", ".", "softmax_b", ",", "label_flat", ",", "logits_2D", ",", "num_sampled", ",", "model_para", "[", "'item_size'", "]", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "\"FullSoftmax_conv\"", ":", "\n", "            ", "print", "(", "\"using FullSoftmax_conv\"", ")", "\n", "if", "model_para", "[", "'dilated_channels'", "]", "!=", "model_para", "[", "'out_embed_size'", "]", ":", "\n", "                ", "self", ".", "softmax_pro_w", "=", "tf", ".", "get_variable", "(", "\"softmax_pro_w\"", ",", "[", "model_para", "[", "'dilated_channels'", "]", ",", "model_para", "[", "'embed_size'", "]", "]", ",", "\n", "tf", ".", "float32", ",", "tf", ".", "random_normal_initializer", "(", "0.0", ",", "0.01", ")", ")", "\n", "dilate_input", "=", "tf", ".", "tensordot", "(", "dilate_input", ",", "self", ".", "softmax_pro_w", ",", "axes", "=", "1", ")", "\n", "\n", "", "logits", "=", "ops_compress", ".", "conv1d", "(", "tf", ".", "nn", ".", "relu", "(", "dilate_input", ")", ",", "model_para", "[", "'item_size'", "]", ",", "name", "=", "'logits'", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "-", "1", ",", "model_para", "[", "'item_size'", "]", "]", ")", "\n", "label_flat", "=", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "labels", "=", "label_flat", ",", "logits", "=", "logits_2D", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "\"FullSoftmax\"", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "\"Block_Input_Full\"", ":", "\n", "            ", "print", "(", "\"using FullSoftmax\"", ")", "\n", "if", "model_para", "[", "'dilated_channels'", "]", "!=", "model_para", "[", "'out_embed_size'", "]", ":", "\n", "                ", "self", ".", "softmax_pro_w", "=", "tf", ".", "get_variable", "(", "\"softmax_pro_w\"", ",", "[", "model_para", "[", "'dilated_channels'", "]", ",", "model_para", "[", "'out_embed_size'", "]", "]", ",", "\n", "tf", ".", "float32", ",", "tf", ".", "random_normal_initializer", "(", "0.0", ",", "0.01", ")", ")", "\n", "dilate_input", "=", "tf", ".", "tensordot", "(", "dilate_input", ",", "self", ".", "softmax_pro_w", ",", "axes", "=", "1", ")", "\n", "\n", "", "self", ".", "softmax_w", "=", "tf", ".", "get_variable", "(", "\"softmax_w\"", ",", "[", "model_para", "[", "'out_embed_size'", "]", ",", "model_para", "[", "'item_size'", "]", "]", ",", "\n", "tf", ".", "float32", ",", "tf", ".", "random_normal_initializer", "(", "0.0", ",", "0.01", ")", ")", "\n", "self", ".", "softmax_b", "=", "tf", ".", "get_variable", "(", "\"softmax_b\"", ",", "[", "model_para", "[", "'item_size'", "]", "]", ",", "tf", ".", "float32", ",", "\n", "tf", ".", "constant_initializer", "(", "0.1", ")", ")", "\n", "\n", "label_flat", "=", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'out_embed_size'", "]", "]", ")", "\n", "logits_2D", "=", "tf", ".", "matmul", "(", "logits_2D", ",", "self", ".", "softmax_w", ")", "\n", "logits_2D", "=", "tf", ".", "nn", ".", "bias_add", "(", "logits_2D", ",", "self", ".", "softmax_b", ")", "\n", "loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "labels", "=", "label_flat", ",", "logits", "=", "logits_2D", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "\"FullSoftmax_Tied\"", ":", "\n", "            ", "print", "(", "\"using FullSoftmax_Tied\"", ")", "\n", "if", "model_para", "[", "'dilated_channels'", "]", "!=", "model_para", "[", "'embed_size'", "]", ":", "\n", "                ", "self", ".", "softmax_pro_w", "=", "tf", ".", "get_variable", "(", "\"softmax_pro_w\"", ",", "[", "model_para", "[", "'dilated_channels'", "]", ",", "model_para", "[", "'embed_size'", "]", "]", ",", "\n", "tf", ".", "float32", ",", "tf", ".", "random_normal_initializer", "(", "0.0", ",", "0.01", ")", ")", "\n", "dilate_input", "=", "tf", ".", "tensordot", "(", "dilate_input", ",", "self", ".", "softmax_pro_w", ",", "axes", "=", "1", ")", "\n", "\n", "", "self", ".", "softmax_w", "=", "tf", ".", "transpose", "(", "self", ".", "allitem_embeddings", ".", "embedding", ")", "\n", "# self.softmax_b = tf.get_variable(\"softmax_b\", [model_para['item_size']], tf.float32,", "\n", "#                                  tf.constant_initializer(0.1))", "\n", "\n", "label_flat", "=", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "logits_2D", "=", "tf", ".", "matmul", "(", "logits_2D", ",", "self", ".", "softmax_w", ")", "\n", "# logits_2D = tf.nn.bias_add(logits_2D, self.softmax_b)", "\n", "loss", "=", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "labels", "=", "label_flat", ",", "logits", "=", "logits_2D", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "\"Block_for_Softmax\"", ":", "\n", "            ", "print", "(", "\"using Block_for_Softmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "assert", "model_para", "[", "'dilated_channels'", "]", "==", "model_para", "[", "'out_embed_size'", "]", "\n", "softmax_layer", "=", "bs", "(", "input_dim", "=", "model_para", "[", "'dilated_channels'", "]", ",", "block", "=", "block", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "loss", ",", "_", "=", "softmax_layer", ".", "loss", "(", "logits_2D", ",", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", ",", "\"loss\"", ")", "\n", "", "elif", "(", "model_para", "[", "'SoftmaxType'", "]", "==", "'Block_Input_Softmax'", "\n", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "'Block_Input_Softmax_Inference'", ")", "and", "model_para", "[", "'factor'", "]", "!=", "1", ":", "\n", "            ", "print", "(", "\"using Block_Input_Softmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "assert", "model_para", "[", "'dilated_channels'", "]", "==", "model_para", "[", "'out_embed_size'", "]", "\n", "softmax_layer", "=", "bs", "(", "input_dim", "=", "model_para", "[", "'dilated_channels'", "]", ",", "block", "=", "block", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "loss", ",", "_", "=", "softmax_layer", ".", "loss", "(", "logits_2D", ",", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", ",", "\"loss\"", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "'LowrankSoftmax'", "and", "model_para", "[", "'factor'", "]", "!=", "1", ":", "\n", "            ", "print", "(", "\"using LowrankSoftmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "lowranksoftmax", ".", "LowRankSoftmax", "(", "input_dim", "=", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "block", "=", "block", ",", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "loss", "=", "softmax_layer", ".", "loss", "(", "logits_2D", ",", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", ",", "\"loss\"", ")", "\n", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "'Block_Input_LowrankSoftmax'", "and", "model_para", "[", "'factor'", "]", "!=", "1", ":", "\n", "            ", "print", "(", "\"using Block_Input_LowrankSoftmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "lowranksoftmax", ".", "LowRankSoftmax", "(", "input_dim", "=", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "block", "=", "block", ",", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "loss", "=", "softmax_layer", ".", "loss", "(", "logits_2D", ",", "tf", ".", "reshape", "(", "label_seq", ",", "[", "-", "1", "]", ")", ",", "\"loss\"", ")", "\n", "\n", "", "self", ".", "loss", "=", "tf", ".", "reduce_mean", "(", "loss", ")", "\n", "regularization", "=", "0.001", "*", "tf", ".", "reduce_mean", "(", "[", "tf", ".", "nn", ".", "l2_loss", "(", "v", ")", "for", "v", "in", "tf", ".", "trainable_variables", "(", ")", "]", ")", "\n", "self", ".", "loss", "=", "self", ".", "loss", "+", "regularization", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.model_graph": [[135, 180], ["print", "generator_recsys.NextItNet_Decoder.allitem_embeddings.get_input", "tensorflow.get_variable", "tensorflow.tensordot", "enumerate", "ops_compress.nextitnet_residual_block", "enumerate", "ops_compress.nextitnet_residual_block_cross_layer", "enumerate", "ops_compress.nextitnet_residual_block_cross_block", "enumerate", "ops_compress.nextitnet_residual_block_adjacent_layer", "enumerate", "ops_compress.nextitnet_residual_adjacent_block"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForInput.get_input", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_cross_layer", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_cross_block", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_adjacent_layer", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_adjacent_block"], ["", "def", "model_graph", "(", "self", ",", "itemseq_input", ",", "train", "=", "True", ")", ":", "\n", "        ", "model_para", "=", "self", ".", "model_para", "\n", "context_seq", "=", "itemseq_input", "[", ":", ",", "0", ":", "-", "1", "]", "\n", "label_seq", "=", "itemseq_input", "[", ":", ",", "1", ":", "]", "\n", "\n", "print", "(", "\"context_seq: \"", ",", "context_seq", ".", "shape", ")", "\n", "context_embedding", "=", "self", ".", "allitem_embeddings", ".", "get_input", "(", "context_seq", ")", "\n", "\n", "# self_attention", "\n", "# mask = self_attention.make_std_mask(context_seq, pad=model_para['pad'])", "\n", "# context_embedding = self_attention.attention(context_embedding, context_embedding, context_embedding, mask,", "\n", "#                                              dropout=0.5, train=train)", "\n", "dilate_input", "=", "context_embedding", "\n", "if", "(", "model_para", "[", "'SoftmaxType'", "]", "==", "\"FullSoftmax\"", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "\"FullSoftmax_conv\"", "or", "\n", "model_para", "[", "'SoftmaxType'", "]", "==", "\"Block_for_Softmax\"", ")", "and", "model_para", "[", "'in_embed_size'", "]", "!=", "model_para", "[", "'dilated_channels'", "]", ":", "\n", "            ", "embed_proj_w", "=", "tf", ".", "get_variable", "(", "\"embed_w\"", ",", "[", "model_para", "[", "'in_embed_size'", "]", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "dilate_input", "=", "tf", ".", "tensordot", "(", "dilate_input", ",", "embed_proj_w", ",", "axes", "=", "1", ")", "\n", "\n", "", "if", "model_para", "[", "'parametersharing_type'", "]", "==", "'original'", ":", "\n", "            ", "for", "layer_id", ",", "dilation", "in", "enumerate", "(", "model_para", "[", "'dilations'", "]", ")", ":", "\n", "                ", "dilate_input", "=", "ops_compress", ".", "nextitnet_residual_block", "(", "dilate_input", ",", "dilation", ",", "\n", "layer_id", ",", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "model_para", "[", "'kernel_size'", "]", ",", "causal", "=", "True", ",", "train", "=", "train", ")", "\n", "", "", "elif", "model_para", "[", "'parametersharing_type'", "]", "==", "'cross-layer'", ":", "\n", "            ", "for", "layer_id", ",", "dilation", "in", "enumerate", "(", "model_para", "[", "'dilations'", "]", ")", ":", "\n", "                ", "dilate_input", "=", "ops_compress", ".", "nextitnet_residual_block_cross_layer", "(", "dilate_input", ",", "dilation", ",", "\n", "layer_id", ",", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "model_para", "[", "'kernel_size'", "]", ",", "causal", "=", "True", ",", "train", "=", "train", ")", "\n", "", "", "elif", "model_para", "[", "'parametersharing_type'", "]", "==", "'cross-block'", ":", "\n", "            ", "for", "layer_id", ",", "dilation", "in", "enumerate", "(", "model_para", "[", "'dilations'", "]", ")", ":", "\n", "                ", "dilate_input", "=", "ops_compress", ".", "nextitnet_residual_block_cross_block", "(", "dilate_input", ",", "dilation", ",", "\n", "layer_id", ",", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "model_para", "[", "'kernel_size'", "]", ",", "causal", "=", "True", ",", "train", "=", "train", ")", "\n", "", "", "elif", "model_para", "[", "'parametersharing_type'", "]", "==", "'adjacent-layer'", ":", "\n", "            ", "for", "layer_id", ",", "dilation", "in", "enumerate", "(", "model_para", "[", "'dilations'", "]", ")", ":", "\n", "                ", "dilate_input", "=", "ops_compress", ".", "nextitnet_residual_block_adjacent_layer", "(", "dilate_input", ",", "dilation", ",", "\n", "layer_id", ",", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "model_para", "[", "'kernel_size'", "]", ",", "causal", "=", "True", ",", "train", "=", "train", ")", "\n", "", "", "elif", "model_para", "[", "'parametersharing_type'", "]", "==", "'adjacent-block'", ":", "\n", "            ", "for", "layer_id", ",", "dilation", "in", "enumerate", "(", "model_para", "[", "'dilations'", "]", ")", ":", "\n", "                ", "dilate_input", "=", "ops_compress", ".", "nextitnet_residual_adjacent_block", "(", "dilate_input", ",", "dilation", ",", "\n", "layer_id", ",", "model_para", "[", "'dilated_channels'", "]", ",", "\n", "model_para", "[", "'kernel_size'", "]", ",", "causal", "=", "True", ",", "train", "=", "train", ")", "\n", "", "", "return", "label_seq", ",", "dilate_input", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.predict_graph_onrecall": [[184, 267], ["tensorflow.placeholder", "tensorflow.placeholder", "generator_recsys.NextItNet_Decoder.model_graph", "tensorflow.get_variable_scope().reuse_variables", "tensorflow.nn.embedding_lookup", "tensorflow.matmul", "tensorflow.reshape", "tensorflow.nn.embedding_lookup", "tensorflow.add", "tensorflow.nn.softmax", "tensorflow.transpose", "tensorflow.reshape", "tensorflow.matmul", "tensorflow.nn.bias_add", "tensorflow.nn.softmax", "tensorflow.get_variable_scope", "tensorflow.transpose", "print", "ops_compress.conv1d", "tensorflow.reshape", "tensorflow.nn.softmax", "tensorflow.shape", "tensorflow.tensordot", "tensorflow.nn.relu", "print", "tensorflow.reshape", "tensorflow.matmul", "tensorflow.nn.bias_add", "tensorflow.nn.softmax", "tensorflow.tensordot", "print", "tensorflow.reshape", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "print", "tensorflow.reshape", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "print", "tensorflow.reshape", "lowranksoftmax.LowRankSoftmax", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "print", "tensorflow.reshape", "lowranksoftmax.LowRankSoftmax", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "print", "tensorflow.reshape", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax", "BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax_inference_top"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.model_graph", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax_inference_top"], ["", "def", "predict_graph_onrecall", "(", "self", ",", "reuse", "=", "False", ")", ":", "#is_negsample=False,", "\n", "        ", "if", "reuse", ":", "\n", "            ", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse_variables", "(", ")", "\n", "", "model_para", "=", "self", ".", "model_para", "#", "\n", "self", ".", "input_predict", "=", "tf", ".", "placeholder", "(", "'int32'", ",", "[", "model_para", "[", "'batch_size'", "]", ",", "model_para", "[", "'seq_len'", "]", "]", ",", "name", "=", "'input_predict'", ")", "\n", "self", ".", "input_recall", "=", "tf", ".", "placeholder", "(", "'int32'", ",", "[", "model_para", "[", "'batch_size'", "]", ",", "model_para", "[", "'seq_len'", "]", "]", ",", "name", "=", "'input_recall'", ")", "# candidate items", "\n", "\n", "label_seq", ",", "dilate_input", "=", "self", ".", "model_graph", "(", "self", ".", "input_predict", ",", "train", "=", "False", ")", "\n", "# label_flat = tf.reshape(label_seq[:, -1:], [-1]) # [batch_size]", "\n", "\n", "if", "model_para", "[", "'SoftmaxType'", "]", "==", "'neg_nowork'", ":", "\n", "            ", "logits_2D", "=", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", "\n", "recall_mat", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "softmax_w", ",", "self", ".", "input_recall", ")", "\n", "logits_2D", "=", "tf", ".", "matmul", "(", "logits_2D", ",", "tf", ".", "transpose", "(", "recall_mat", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "logits_2D", ",", "[", "-", "1", ",", "tf", ".", "shape", "(", "self", ".", "input_recall", ")", "[", "1", "]", "]", ")", "\n", "recall_bias", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "softmax_b", ",", "self", ".", "input_recall", ")", "\n", "logits_2D", "=", "tf", ".", "add", "(", "logits_2D", ",", "recall_bias", ")", "\n", "probs_flat", "=", "tf", ".", "nn", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "'neg'", ":", "\n", "            ", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'out_embed_size'", "]", "]", ")", "\n", "logits_2D", "=", "tf", ".", "matmul", "(", "logits_2D", ",", "tf", ".", "transpose", "(", "self", ".", "softmax_w", ")", ")", "\n", "logits_2D", "=", "tf", ".", "nn", ".", "bias_add", "(", "logits_2D", ",", "self", ".", "softmax_b", ")", "\n", "probs_flat", "=", "tf", ".", "nn", ".", "softmax", "(", "logits_2D", ")", "\n", "", "elif", "model_para", "[", "'SoftmaxType'", "]", "==", "'FullSoftmax_conv'", ":", "\n", "            ", "print", "(", "\"recall one valid using FullSoftmax_conv\"", ")", "\n", "if", "model_para", "[", "'dilated_channels'", "]", "!=", "model_para", "[", "'embed_size'", "]", ":", "\n", "                ", "dilate_input", "=", "tf", ".", "tensordot", "(", "dilate_input", ",", "self", ".", "softmax_pro_w", ",", "axes", "=", "1", ")", "\n", "\n", "", "logits", "=", "ops_compress", ".", "conv1d", "(", "tf", ".", "nn", ".", "relu", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ")", ",", "model_para", "[", "'item_size'", "]", ",", "name", "=", "'logits'", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "-", "1", ",", "model_para", "[", "'item_size'", "]", "]", ")", "#[batch_size, item_size]", "\n", "probs_flat", "=", "tf", ".", "nn", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "\n", "", "elif", "model_para", "[", "\"SoftmaxType\"", "]", "==", "\"FullSoftmax\"", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "\"Block_Input_Full\"", "or", "model_para", "[", "'SoftmaxType'", "]", "==", "\"FullSoftmax_Tied\"", ":", "\n", "            ", "print", "(", "\"valid using FullSoftmax\"", ")", "\n", "if", "model_para", "[", "'dilated_channels'", "]", "!=", "model_para", "[", "'out_embed_size'", "]", ":", "\n", "                ", "dilate_input", "=", "tf", ".", "tensordot", "(", "dilate_input", ",", "self", ".", "softmax_pro_w", ",", "axes", "=", "1", ")", "\n", "\n", "", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'out_embed_size'", "]", "]", ")", "\n", "logits_2D", "=", "tf", ".", "matmul", "(", "logits_2D", ",", "self", ".", "softmax_w", ")", "\n", "logits_2D", "=", "tf", ".", "nn", ".", "bias_add", "(", "logits_2D", ",", "self", ".", "softmax_b", ")", "\n", "probs_flat", "=", "tf", ".", "nn", ".", "softmax", "(", "logits_2D", ")", "\n", "", "elif", "model_para", "[", "\"SoftmaxType\"", "]", "==", "\"Block_for_Softmax\"", ":", "\n", "            ", "print", "(", "\"recall one valid using Block_for_Softmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "#[batch_size, dilated_channels]", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "bs", "(", "model_para", "[", "\"dilated_channels\"", "]", ",", "block", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "# loss, _ = softmax_layer.loss(logits_2D, label_flat, train=False, name=\"loss\")", "\n", "probs_flat", "=", "softmax_layer", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "\n", "", "elif", "model_para", "[", "\"SoftmaxType\"", "]", "==", "\"Block_Input_Softmax\"", "and", "model_para", "[", "'factor'", "]", "!=", "1", ":", "\n", "            ", "print", "(", "\"recall one valid using Block_Input_Softmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "bs", "(", "model_para", "[", "\"dilated_channels\"", "]", ",", "block", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "# loss, _ = softmax_layer.loss(logits_2D, label_flat, train=False, name=\"loss\")", "\n", "probs_flat", "=", "softmax_layer", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "\n", "", "elif", "model_para", "[", "\"SoftmaxType\"", "]", "==", "\"LowrankSoftmax\"", ":", "\n", "            ", "print", "(", "\"recall one valid using LowrankSoftmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "lowranksoftmax", ".", "LowRankSoftmax", "(", "input_dim", "=", "model_para", "[", "'dilated_channels'", "]", ",", "block", "=", "block", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "# loss, _ = softmax_layer.loss(logits_2D, label_flat, train=False, name=\"loss\")", "\n", "probs_flat", "=", "softmax_layer", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "# [batch_size, item_size]", "\n", "", "elif", "model_para", "[", "\"SoftmaxType\"", "]", "==", "\"Block_Input_LowrankSoftmax\"", ":", "\n", "            ", "print", "(", "\"recall one valid using Block_Input_LowrankSoftmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "lowranksoftmax", ".", "LowRankSoftmax", "(", "input_dim", "=", "model_para", "[", "'dilated_channels'", "]", ",", "block", "=", "block", ",", "\n", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "# loss, _ = softmax_layer.loss(logits_2D, label_flat, train=False, name=\"loss\")", "\n", "probs_flat", "=", "softmax_layer", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "# [batch_size, item_size]", "\n", "", "elif", "model_para", "[", "\"SoftmaxType\"", "]", "==", "\"Block_Input_Softmax_Inference\"", "and", "model_para", "[", "'factor'", "]", "!=", "1", ":", "\n", "            ", "print", "(", "\"recall one valid using Block_Input_Softmax\"", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ",", "[", "-", "1", ",", "model_para", "[", "'dilated_channels'", "]", "]", ")", "\n", "block", "=", "model_para", "[", "'block'", "]", "\n", "softmax_layer", "=", "bs", "(", "model_para", "[", "\"dilated_channels\"", "]", ",", "block", "=", "block", ",", "block_factor", "=", "model_para", "[", "'factor'", "]", ")", "\n", "# loss, _ = softmax_layer.loss(logits_2D, label_flat, train=False, name=\"loss\")", "\n", "probs_flat", "=", "softmax_layer", ".", "softmax_inference_top", "(", "logits_2D", ",", "name", "=", "'softmax'", ",", "top_v", "=", "model_para", "[", "'top_k'", "]", ")", "\n", "\n", "# self.loss_test = tf.reduce_mean(loss)", "\n", "\n", "", "self", ".", "g_probs", "=", "probs_flat", "\n", "# newly added for weishi, since each input is one user (i.e., a batch), in fact we just need to rank the first batch, the below code is to select top-5", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.predict_graph_onrecall_ori": [[276, 308], ["tensorflow.placeholder", "tensorflow.placeholder", "generator_recsys.NextItNet_Decoder.model_graph", "tensorflow.nn.softmax", "tensorflow.nn.top_k", "tensorflow.get_variable_scope().reuse_variables", "tensorflow.nn.embedding_lookup", "tensorflow.matmul", "tensorflow.reshape", "tensorflow.nn.embedding_lookup", "tensorflow.add", "ops_compress.conv1d", "tensorflow.reshape", "tensorflow.transpose", "tensorflow.nn.relu", "tensorflow.get_variable_scope", "tensorflow.shape"], "methods", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.generator_recsys.NextItNet_Decoder.model_graph", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.BlockWiseEmbedding.BlockWiseEmbeddingForSoftmax.softmax", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d"], ["", "def", "predict_graph_onrecall_ori", "(", "self", ",", "is_negsample", "=", "False", ",", "reuse", "=", "False", ")", ":", "\n", "\n", "        ", "if", "reuse", ":", "\n", "            ", "tf", ".", "get_variable_scope", "(", ")", ".", "reuse_variables", "(", ")", "\n", "", "model_para", "=", "self", ".", "model_para", "\n", "self", ".", "input_predict", "=", "tf", ".", "placeholder", "(", "'int32'", ",", "[", "model_para", "[", "'batch_size'", "]", ",", "model_para", "[", "'seq_len'", "]", "]", ",", "name", "=", "'input_predict'", ")", "\n", "self", ".", "input_recall", "=", "tf", ".", "placeholder", "(", "'int32'", ",", "[", "model_para", "[", "'batch_size'", "]", ",", "model_para", "[", "'seq_len'", "]", "]", ",", "name", "=", "'input_recall'", ")", "# candidate items", "\n", "\n", "label_seq", ",", "dilate_input", "=", "self", ".", "model_graph", "(", "self", ".", "input_predict", ",", "train", "=", "False", ")", "\n", "\n", "\n", "if", "is_negsample", ":", "\n", "            ", "logits_2D", "=", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", "\n", "recall_mat", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "softmax_w", ",", "self", ".", "input_recall", ")", "\n", "logits_2D", "=", "tf", ".", "matmul", "(", "logits_2D", ",", "tf", ".", "transpose", "(", "recall_mat", ",", "[", "0", ",", "2", ",", "1", "]", ")", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "logits_2D", ",", "[", "-", "1", ",", "tf", ".", "shape", "(", "self", ".", "input_recall", ")", "[", "1", "]", "]", ")", "\n", "recall_bias", "=", "tf", ".", "nn", ".", "embedding_lookup", "(", "self", ".", "softmax_b", ",", "self", ".", "input_recall", ")", "\n", "logits_2D", "=", "tf", ".", "add", "(", "logits_2D", ",", "recall_bias", ")", "\n", "\n", "", "else", ":", "\n", "# logits = ops.conv1d(tf.nn.relu(dilate_input), model_para['item_size'], name='logits')", "\n", "            ", "logits", "=", "ops_compress", ".", "conv1d", "(", "tf", ".", "nn", ".", "relu", "(", "dilate_input", "[", ":", ",", "-", "1", ":", ",", ":", "]", ")", ",", "model_para", "[", "'item_size'", "]", ",", "name", "=", "'logits'", ")", "\n", "logits_2D", "=", "tf", ".", "reshape", "(", "logits", ",", "[", "-", "1", ",", "model_para", "[", "'item_size'", "]", "]", ")", "\n", "\n", "", "probs_flat", "=", "tf", ".", "nn", ".", "softmax", "(", "logits_2D", ",", "name", "=", "'softmax'", ")", "\n", "\n", "self", ".", "g_probs", "=", "probs_flat", "\n", "# newly added for weishi, since each input is one user (i.e., a batch), in fact we just need to rank the first batch, the below code is to select top-5", "\n", "# self.top_k= tf.nn.top_k(self.g_probs[:,-1], k=model_para['top_k'],name='top-k')", "\n", "\n", "# be carefule with the top-k values since the index represents the orders of your recalled items but not the original order.", "\n", "self", ".", "top_k", "=", "tf", ".", "nn", ".", "top_k", "(", "self", ".", "g_probs", ",", "k", "=", "model_para", "[", "'top_k'", "]", ",", "name", "=", "'top-k'", ")", "\n", "# self.top_k=tf.gather(self.input_recall, tf.contrib.framework.argsort(self.g_probs),name='top-k')", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_cross_layer": [[5, 37], ["tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu", "tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm"], ["def", "nextitnet_residual_block_cross_layer", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "    ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name", "=", "\"nextitnet_residual_block{}_layer\"", ".", "format", "(", "resblock_type", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv\"", "\n", ")", "\n", "\n", "", "resblock_norm_name1", "=", "\"nextitnet_residual_block{}_layer_{}_{}_norm1\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_norm_name1", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm1\"", ",", "trainable", "=", "train", ")", "\n", "# input_ln=tf.contrib.layers.layer_norm(dilated_conv,reuse=not train, trainable=train)  #performance is not good, paramter wrong?", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "", "with", "tf", ".", "variable_scope", "(", "resblock_name", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "relu1", ",", "residual_channels", ",", "\n", "2", "*", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv\"", "\n", ")", "\n", "", "resblock_norm_name2", "=", "\"nextitnet_residual_block{}_layer_{}_{}_norm2\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_norm_name2", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm2\"", ",", "trainable", "=", "train", ")", "\n", "#input_ln = tf.contrib.layers.layer_norm(dilated_conv, reuse=not train, trainable=train)", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "return", "input_", "+", "relu1", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_adjacent_layer": [[40, 67], ["tensorflow.variable_scope", "ops_compress.conv1d", "ops_compress.layer_norm", "tensorflow.nn.relu", "ops_compress.conv1d", "ops_compress.layer_norm", "tensorflow.nn.relu"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm"], ["", "", "def", "nextitnet_residual_block_adjacent_layer", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "    ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name1", "=", "\"nextitnet_residual_block{}_layer_{}_{}\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name1", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv\"", "\n", ")", "\n", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm1\"", ",", "trainable", "=", "train", ")", "\n", "# input_ln=tf.contrib.layers.layer_norm(dilated_conv,reuse=not train, trainable=train)  #performance is not good, paramter wrong?", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "dilated_conv", "=", "conv1d", "(", "relu1", ",", "residual_channels", ",", "\n", "2", "*", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv\"", "\n", ")", "\n", "\n", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm2\"", ",", "trainable", "=", "train", ")", "\n", "#input_ln = tf.contrib.layers.layer_norm(dilated_conv, reuse=not train, trainable=train)", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "return", "input_", "+", "relu1", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_adjacent_block": [[70, 102], ["tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu", "tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm"], ["", "", "def", "nextitnet_residual_adjacent_block", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "    ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name1", "=", "\"nextitnet_residual_block{}_layer_{}_0\"", ".", "format", "(", "resblock_type", ",", "layer_id", "/", "2", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name1", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv1\"", "\n", ")", "\n", "", "resblock_norm_name1", "=", "\"nextitnet_residual_block{}_layer_{}_{}_norm1\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_norm_name1", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm1\"", ",", "trainable", "=", "train", ")", "\n", "# input_ln=tf.contrib.layers.layer_norm(dilated_conv,reuse=not train, trainable=train)  #performance is not good, paramter wrong?", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "", "resblock_name2", "=", "\"nextitnet_residual_block{}_layer_{}_1\"", ".", "format", "(", "resblock_type", ",", "layer_id", "/", "2", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name2", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "relu1", ",", "residual_channels", ",", "\n", "2", "*", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv2\"", "\n", ")", "\n", "", "resblock_norm_name2", "=", "\"nextitnet_residual_block{}_layer_{}_{}_norm2\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_norm_name2", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm2\"", ",", "trainable", "=", "train", ")", "\n", "#input_ln = tf.contrib.layers.layer_norm(dilated_conv, reuse=not train, trainable=train)", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "return", "input_", "+", "relu1", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_cross_block": [[106, 138], ["tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu", "tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm"], ["", "", "def", "nextitnet_residual_block_cross_block", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "    ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name1", "=", "\"nextitnet_residual_block{}_layer_0\"", ".", "format", "(", "resblock_type", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name1", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv1\"", "\n", ")", "\n", "", "resblock_norm_name1", "=", "\"nextitnet_residual_block{}_layer_{}_{}_norm1\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_norm_name1", ")", ":", "\n", "        ", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm1\"", ",", "trainable", "=", "train", ")", "\n", "# input_ln=tf.contrib.layers.layer_norm(dilated_conv,reuse=not train, trainable=train)  #performance is not good, paramter wrong?", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "", "resblock_name2", "=", "\"nextitnet_residual_block{}_layer_1\"", ".", "format", "(", "resblock_type", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name2", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "relu1", ",", "residual_channels", ",", "\n", "2", "*", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv2\"", "\n", ")", "\n", "", "resblock_norm_name2", "=", "\"nextitnet_residual_block{}_layer_{}_{}_norm2\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_norm_name2", ")", ":", "\n", "        ", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm2\"", ",", "trainable", "=", "train", ")", "\n", "#input_ln = tf.contrib.layers.layer_norm(dilated_conv, reuse=not train, trainable=train)", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "return", "input_", "+", "relu1", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block": [[140, 168], ["tensorflow.variable_scope", "ops_compress.conv1d", "ops_compress.layer_norm", "tensorflow.nn.relu", "ops_compress.conv1d", "ops_compress.layer_norm", "tensorflow.nn.relu"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm"], ["", "", "def", "nextitnet_residual_block", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "    ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name", "=", "\"nextitnet_residual_block{}_layer_{}_{}\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name", ")", ":", "\n", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv1\"", "\n", ")", "\n", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm1\"", ",", "trainable", "=", "train", ")", "\n", "# input_ln=tf.contrib.layers.layer_norm(dilated_conv,reuse=not train, trainable=train)  #performance is not good, paramter wrong?", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "\n", "dilated_conv", "=", "conv1d", "(", "relu1", ",", "residual_channels", ",", "\n", "2", "*", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv2\"", "\n", ")", "\n", "\n", "input_ln", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm2\"", ",", "trainable", "=", "train", ")", "\n", "#input_ln = tf.contrib.layers.layer_norm(dilated_conv, reuse=not train, trainable=train)", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "\n", "return", "input_", "+", "relu1", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_one": [[171, 193], ["tensorflow.variable_scope", "ops_compress.layer_norm", "tensorflow.nn.relu", "ops_compress.conv1d", "ops_compress.layer_norm", "tensorflow.nn.relu", "ops_compress.conv1d", "ops_compress.layer_norm", "tensorflow.nn.relu", "ops_compress.conv1d", "int", "int"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d"], ["", "", "def", "nextitnet_residual_block_one", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "        ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name", "=", "\"nextitnet_residual_block_one_{}_layer_{}_{}\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name", ")", ":", "\n", "            ", "input_ln", "=", "layer_norm", "(", "input_", ",", "name", "=", "\"layer_norm1\"", ",", "trainable", "=", "train", ")", "\n", "relu1", "=", "tf", ".", "nn", ".", "relu", "(", "input_ln", ")", "\n", "conv1", "=", "conv1d", "(", "relu1", ",", "int", "(", "0.5", "*", "residual_channels", ")", ",", "name", "=", "\"conv1d_1\"", ")", "\n", "conv1", "=", "layer_norm", "(", "conv1", ",", "name", "=", "\"layer_norm2\"", ",", "trainable", "=", "train", ")", "\n", "relu2", "=", "tf", ".", "nn", ".", "relu", "(", "conv1", ")", "\n", "\n", "dilated_conv", "=", "conv1d", "(", "relu2", ",", "int", "(", "0.5", "*", "residual_channels", ")", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv\"", "\n", ")", "\n", "\n", "dilated_conv", "=", "layer_norm", "(", "dilated_conv", ",", "name", "=", "\"layer_norm3\"", ",", "trainable", "=", "train", ")", "\n", "relu3", "=", "tf", ".", "nn", ".", "relu", "(", "dilated_conv", ")", "\n", "conv2", "=", "conv1d", "(", "relu3", ",", "residual_channels", ",", "name", "=", "'conv1d_2'", ")", "\n", "return", "input_", "+", "conv2", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.nextitnet_residual_block_gatedCNN": [[197, 222], ["tensorflow.variable_scope", "ops_compress.conv1d", "tensorflow.nn.tanh", "ops_compress.conv1d", "tensorflow.nn.sigmoid", "tensorflow.multiply", "ops_compress.conv1d"], "function", ["home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d", "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d"], ["", "", "def", "nextitnet_residual_block_gatedCNN", "(", "input_", ",", "dilation", ",", "layer_id", ",", "\n", "residual_channels", ",", "kernel_size", ",", "\n", "causal", "=", "True", ",", "train", "=", "True", ")", ":", "\n", "    ", "resblock_type", "=", "\"decoder\"", "\n", "resblock_name", "=", "\"gatedCNN_{}_layer_{}_{}\"", ".", "format", "(", "resblock_type", ",", "layer_id", ",", "dilation", ")", "\n", "with", "tf", ".", "variable_scope", "(", "resblock_name", ")", ":", "\n", "\n", "\n", "        ", "dilated_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"dilated_conv\"", "\n", ")", "\n", "tanh", "=", "tf", ".", "nn", ".", "tanh", "(", "dilated_conv", ")", "\n", "gate_conv", "=", "conv1d", "(", "input_", ",", "residual_channels", ",", "\n", "dilation", ",", "kernel_size", ",", "\n", "causal", "=", "causal", ",", "\n", "name", "=", "\"gate_conv\"", "\n", ")", "\n", "\n", "sigm", "=", "tf", ".", "nn", ".", "sigmoid", "(", "gate_conv", ")", "\n", "multi", "=", "tf", ".", "multiply", "(", "tanh", ",", "sigm", ")", "\n", "multi", "=", "conv1d", "(", "multi", ",", "residual_channels", ",", "name", "=", "\"conv1d_1\"", ")", "\n", "\n", "return", "input_", "+", "multi", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.conv1d": [[225, 245], ["tensorflow.variable_scope", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.squeeze", "tensorflow.pad", "tensorflow.expand_dims", "tensorflow.expand_dims", "tensorflow.truncated_normal_initializer", "tensorflow.constant_initializer", "tensorflow.nn.atrous_conv2d", "tensorflow.nn.conv2d", "input_.get_shape"], "function", ["None"], ["", "", "def", "conv1d", "(", "input_", ",", "output_channels", ",", "\n", "dilation", "=", "1", ",", "kernel_size", "=", "1", ",", "causal", "=", "False", ",", "\n", "name", "=", "\"dilated_conv\"", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ",", "reuse", "=", "tf", ".", "AUTO_REUSE", ")", ":", "\n", "# print(\"input_.get_shape *********: \", input_.get_shape())", "\n", "        ", "weight", "=", "tf", ".", "get_variable", "(", "'weight'", ",", "[", "1", ",", "kernel_size", ",", "input_", ".", "get_shape", "(", ")", "[", "-", "1", "]", ",", "output_channels", "]", ",", "initializer", "=", "tf", ".", "truncated_normal_initializer", "(", "stddev", "=", "0.02", ",", "seed", "=", "1", ")", ")", "\n", "bias", "=", "tf", ".", "get_variable", "(", "'bias'", ",", "[", "output_channels", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0.0", ")", ")", "\n", "\n", "if", "causal", ":", "\n", "            ", "padding", "=", "[", "[", "0", ",", "0", "]", ",", "[", "(", "kernel_size", "-", "1", ")", "*", "dilation", ",", "0", "]", ",", "[", "0", ",", "0", "]", "]", "\n", "padded", "=", "tf", ".", "pad", "(", "input_", ",", "padding", ")", "\n", "input_expanded", "=", "tf", ".", "expand_dims", "(", "padded", ",", "dim", "=", "1", ")", "\n", "out", "=", "tf", ".", "nn", ".", "atrous_conv2d", "(", "input_expanded", ",", "weight", ",", "rate", "=", "dilation", ",", "padding", "=", "'VALID'", ")", "+", "bias", "\n", "", "else", ":", "\n", "            ", "input_expanded", "=", "tf", ".", "expand_dims", "(", "input_", ",", "dim", "=", "1", ")", "\n", "# out = tf.nn.atrous_conv2d(input_expanded, w, rate = dilation, padding = 'SAME') + bias", "\n", "out", "=", "tf", ".", "nn", ".", "conv2d", "(", "input_expanded", ",", "weight", ",", "strides", "=", "[", "1", ",", "1", ",", "1", ",", "1", "]", ",", "padding", "=", "\"SAME\"", ")", "+", "bias", "\n", "\n", "", "return", "tf", ".", "squeeze", "(", "out", ",", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.ops_compress.layer_norm": [[248, 261], ["tensorflow.variable_scope", "x.get_shape", "tensorflow.get_variable", "tensorflow.get_variable", "tensorflow.nn.moments", "tensorflow.sqrt", "int", "tensorflow.constant_initializer", "int", "tensorflow.constant_initializer", "len"], "function", ["None"], ["", "", "def", "layer_norm", "(", "x", ",", "name", ",", "epsilon", "=", "1e-8", ",", "trainable", "=", "True", ")", ":", "\n", "    ", "with", "tf", ".", "variable_scope", "(", "name", ")", ":", "\n", "        ", "shape", "=", "x", ".", "get_shape", "(", ")", "\n", "beta", "=", "tf", ".", "get_variable", "(", "'beta'", ",", "[", "int", "(", "shape", "[", "-", "1", "]", ")", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "0", ")", ",", "trainable", "=", "trainable", ")", "\n", "gamma", "=", "tf", ".", "get_variable", "(", "'gamma'", ",", "[", "int", "(", "shape", "[", "-", "1", "]", ")", "]", ",", "\n", "initializer", "=", "tf", ".", "constant_initializer", "(", "1", ")", ",", "trainable", "=", "trainable", ")", "\n", "\n", "mean", ",", "variance", "=", "tf", ".", "nn", ".", "moments", "(", "x", ",", "axes", "=", "[", "len", "(", "shape", ")", "-", "1", "]", ",", "keep_dims", "=", "True", ")", "\n", "\n", "x", "=", "(", "x", "-", "mean", ")", "/", "tf", ".", "sqrt", "(", "variance", "+", "epsilon", ")", "\n", "\n", "return", "gamma", "*", "x", "+", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.utils.sample_top": [[3, 10], ["numpy.random.choice", "numpy.argsort", "numpy.sum"], "function", ["None"], ["def", "sample_top", "(", "a", "=", "[", "]", ",", "top_k", "=", "10", ")", ":", "\n", "    ", "idx", "=", "np", ".", "argsort", "(", "a", ")", "[", ":", ":", "-", "1", "]", "\n", "idx", "=", "idx", "[", ":", "top_k", "]", "\n", "probs", "=", "a", "[", "idx", "]", "\n", "probs", "=", "probs", "/", "np", ".", "sum", "(", "probs", ")", "\n", "choice", "=", "np", ".", "random", ".", "choice", "(", "idx", ",", "p", "=", "probs", ")", "\n", "return", "choice", "\n", "\n"]], "home.repos.pwc.inspect_result.siat-nlp_CpRec.None.utils.sample_top_k": [[12, 19], ["numpy.argsort"], "function", ["None"], ["", "def", "sample_top_k", "(", "a", "=", "[", "]", ",", "top_k", "=", "10", ")", ":", "\n", "    ", "idx", "=", "np", ".", "argsort", "(", "a", ")", "[", ":", ":", "-", "1", "]", "\n", "idx", "=", "idx", "[", ":", "top_k", "]", "\n", "# probs = a[idx]", "\n", "# probs = probs / np.sum(probs)", "\n", "# choice = np.random.choice(idx, p=probs)", "\n", "return", "idx", "\n", "\n"]]}